.TH "libMesh::ExodusII_IO_Helper" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::ExodusII_IO_Helper \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <exodusII_io_helper\&.h>\fP
.PP
Inherits \fBlibMesh::ParallelObject\fP\&.
.PP
Inherited by \fBlibMesh::Nemesis_IO_Helper\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBConversion\fP"
.br
.ti -1c
.RI "class \fBElementMaps\fP"
.br
.ti -1c
.RI "class \fBNamesData\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBExodusII_IO_Helper\fP (const \fBParallelObject\fP &parent, bool v=false, bool run_only_on_proc0=true, bool single_precision=false)"
.br
.ti -1c
.RI "virtual \fB~ExodusII_IO_Helper\fP ()"
.br
.ti -1c
.RI "const char * \fBget_elem_type\fP () const "
.br
.ti -1c
.RI "void \fBopen\fP (const char *filename, bool read_only)"
.br
.ti -1c
.RI "void \fBread_header\fP ()"
.br
.ti -1c
.RI "void \fBprint_header\fP ()"
.br
.ti -1c
.RI "void \fBread_nodes\fP ()"
.br
.ti -1c
.RI "void \fBread_node_num_map\fP ()"
.br
.ti -1c
.RI "void \fBprint_nodes\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "void \fBread_block_info\fP ()"
.br
.ti -1c
.RI "int \fBget_block_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_block_name\fP (int index)"
.br
.ti -1c
.RI "int \fBget_side_set_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_side_set_name\fP (int index)"
.br
.ti -1c
.RI "int \fBget_node_set_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_node_set_name\fP (int index)"
.br
.ti -1c
.RI "void \fBread_elem_in_block\fP (int block)"
.br
.ti -1c
.RI "void \fBread_elem_num_map\fP ()"
.br
.ti -1c
.RI "void \fBread_sideset_info\fP ()"
.br
.ti -1c
.RI "void \fBread_nodeset_info\fP ()"
.br
.ti -1c
.RI "void \fBread_sideset\fP (int id, int offset)"
.br
.ti -1c
.RI "void \fBread_nodeset\fP (int id)"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.ti -1c
.RI "int \fBinquire\fP (int req_info, std::string error_msg='')"
.br
.ti -1c
.RI "void \fBread_time_steps\fP ()"
.br
.ti -1c
.RI "void \fBread_num_time_steps\fP ()"
.br
.ti -1c
.RI "void \fBread_nodal_var_values\fP (std::string nodal_var_name, int time_step)"
.br
.ti -1c
.RI "void \fBread_elemental_var_values\fP (std::string elemental_var_name, int time_step)"
.br
.ti -1c
.RI "virtual void \fBcreate\fP (std::string filename)"
.br
.ti -1c
.RI "virtual void \fBinitialize\fP (std::string \fBtitle\fP, const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "virtual void \fBwrite_nodal_coordinates\fP (const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "virtual void \fBwrite_elements\fP (const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "virtual void \fBwrite_sidesets\fP (const \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "virtual void \fBwrite_nodesets\fP (const \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "void \fBinitialize_element_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBinitialize_nodal_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBinitialize_global_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBwrite_timestep\fP (int timestep, \fBReal\fP time)"
.br
.ti -1c
.RI "void \fBwrite_element_values\fP (const \fBMeshBase\fP &\fBmesh\fP, const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBwrite_nodal_values\fP (int var_id, const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBwrite_information_records\fP (const std::vector< std::string > &records)"
.br
.ti -1c
.RI "void \fBwrite_global_values\fP (const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBuse_mesh_dimension_instead_of_spatial_dimension\fP (bool val)"
.br
.ti -1c
.RI "void \fBset_coordinate_offset\fP (\fBPoint\fP p)"
.br
.ti -1c
.RI "std::vector< std::string > \fBget_complex_names\fP (const std::vector< std::string > &names) const "
.br
.ti -1c
.RI "void \fBmessage\fP (const std::string &msg)"
.br
.ti -1c
.RI "void \fBmessage\fP (const std::string &msg, int i)"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "int \fBex_id\fP"
.br
.ti -1c
.RI "int \fBex_err\fP"
.br
.ti -1c
.RI "int \fBnum_dim\fP"
.br
.ti -1c
.RI "int \fBnum_global_vars\fP"
.br
.ti -1c
.RI "int \fBnum_nodes\fP"
.br
.ti -1c
.RI "int \fBnum_elem\fP"
.br
.ti -1c
.RI "int \fBnum_elem_blk\fP"
.br
.ti -1c
.RI "int \fBnum_node_sets\fP"
.br
.ti -1c
.RI "int \fBnum_side_sets\fP"
.br
.ti -1c
.RI "int \fBnum_elem_this_blk\fP"
.br
.ti -1c
.RI "int \fBnum_nodes_per_elem\fP"
.br
.ti -1c
.RI "int \fBnum_attr\fP"
.br
.ti -1c
.RI "int \fBnum_elem_all_sidesets\fP"
.br
.ti -1c
.RI "std::vector< int > \fBblock_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBconnect\fP"
.br
.ti -1c
.RI "std::vector< int > \fBss_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnodeset_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_sides_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_nodes_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_df_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_node_df_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBside_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBid_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_num_map\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_num_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBx\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBy\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBz\fP"
.br
.ti -1c
.RI "std::vector< char > \fBtitle\fP"
.br
.ti -1c
.RI "std::vector< char > \fBelem_type\fP"
.br
.ti -1c
.RI "std::map< int, int > \fBlibmesh_elem_num_to_exodus\fP"
.br
.ti -1c
.RI "std::vector< int > \fBexodus_elem_num_to_libmesh\fP"
.br
.ti -1c
.RI "std::map< int, int > \fBlibmesh_node_num_to_exodus\fP"
.br
.ti -1c
.RI "std::vector< int > \fBexodus_node_num_to_libmesh\fP"
.br
.ti -1c
.RI "int \fBnum_time_steps\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBtime_steps\fP"
.br
.ti -1c
.RI "int \fBnum_nodal_vars\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBnodal_var_names\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBnodal_var_values\fP"
.br
.ti -1c
.RI "int \fBnum_elem_vars\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBelem_var_names\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBelem_var_values\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBglobal_var_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_block_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_ss_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_ns_names\fP"
.br
.ti -1c
.RI "bool \fBverbose\fP"
.br
.ti -1c
.RI "bool \fBopened_for_writing\fP"
.br
.ti -1c
.RI "bool \fBopened_for_reading\fP"
.br
.ti -1c
.RI "std::string \fBcurrent_filename\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fB_run_only_on_proc0\fP"
.br
.ti -1c
.RI "bool \fB_elem_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_global_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_nodal_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_use_mesh_dimension_instead_of_spatial_dimension\fP"
.br
.ti -1c
.RI "\fBPoint\fP \fB_coordinate_offset\fP"
.br
.ti -1c
.RI "bool \fB_single_precision\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBExodusVarType\fP { \fBNODAL\fP =0, \fBELEMENTAL\fP =1, \fBGLOBAL\fP =2 }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBread_var_names\fP (\fBExodusVarType\fP type)"
.br
.ti -1c
.RI "void \fBwrite_var_names\fP (\fBExodusVarType\fP type, std::vector< std::string > &names)"
.br
.ti -1c
.RI "void \fBcheck_existing_vars\fP (\fBExodusVarType\fP type, std::vector< std::string > &names, std::vector< std::string > &names_from_file)"
.br
.ti -1c
.RI "void \fBread_var_names_impl\fP (const char *var_type, int &count, std::vector< std::string > &result)"
.br
.ti -1c
.RI "void \fBwrite_var_names_impl\fP (const char *var_type, int &count, std::vector< std::string > &names)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This is the \fC\fBExodusII_IO_Helper\fP\fP class\&. This class hides the implementation details of interfacing with the Exodus binary format\&.
.PP
\fBAuthor:\fP
.RS 4
Johw W\&. Peterson, 2002\&. 
.RE
.PP

.PP
Definition at line 69 of file exodusII_io_helper\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBlibMesh::ExodusII_IO_Helper::ExodusVarType\fP\fC [private]\fP"
Wraps calls to exII::ex_get_var_names() and exII::ex_get_var_param()\&. The enumeration controls whether nodal, elemental, or global variable names are read and which class members are filled in\&. NODAL: num_nodal_vars nodal_var_names ELEMENTAL: num_elem_vars elem_var_names GLOBAL: num_global_vars global_var_names 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINODAL \fP\fP
.TP
\fB\fIELEMENTAL \fP\fP
.TP
\fB\fIGLOBAL \fP\fP
.PP
Definition at line 559 of file exodusII_io_helper\&.h\&.
.PP
.nf
559 {NODAL=0, ELEMENTAL=1, GLOBAL=2};
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::ExodusII_IO_Helper::ExodusII_IO_Helper (const \fBParallelObject\fP &parent, boolv = \fCfalse\fP, boolrun_only_on_proc0 = \fCtrue\fP, boolsingle_precision = \fCfalse\fP)"
Constructor\&. Automatically initializes all the private members of the class\&. Also allows you to set the verbosity level to v=true (on) or v=false (off)\&. The second argument, if true, tells the class to only perform its actions if running on processor zero\&. If you initialize this to false, the writing methods will run on all processors instead\&. 
.PP
Definition at line 230 of file exodusII_io_helper\&.C\&.
.PP
References elem_type, and title\&.
.PP
.nf
233                                                               :
234   ParallelObject(parent),
235   ex_id(0),
236   ex_err(0),
237   num_dim(0),
238   num_global_vars(0),
239   num_nodes(0),
240   num_elem(0),
241   num_elem_blk(0),
242   num_node_sets(0),
243   num_side_sets(0),
244   num_elem_this_blk(0),
245   num_nodes_per_elem(0),
246   num_attr(0),
247   num_elem_all_sidesets(0),
248   num_time_steps(0),
249   num_nodal_vars(0),
250   num_elem_vars(0),
251   verbose(v),
252   opened_for_writing(false),
253   opened_for_reading(false),
254   _run_only_on_proc0(run_only_on_proc0),
255   _elem_vars_initialized(false),
256   _global_vars_initialized(false),
257   _nodal_vars_initialized(false),
258   _use_mesh_dimension_instead_of_spatial_dimension(false),
259   _single_precision(single_precision)
260 {
261   title\&.resize(MAX_LINE_LENGTH+1);
262   elem_type\&.resize(MAX_STR_LENGTH);
263 }
.fi
.SS "libMesh::ExodusII_IO_Helper::~ExodusII_IO_Helper ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 267 of file exodusII_io_helper\&.C\&.
.PP
.nf
268 {
269 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::ExodusII_IO_Helper::check_existing_vars (\fBExodusVarType\fPtype, std::vector< std::string > &names, std::vector< std::string > &names_from_file)\fC [private]\fP"
When appending: during initialization, check that variable names in the file match those you attempt to initialize with\&. 
.PP
Definition at line 1569 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::err, libMesh::out, and read_var_names()\&.
.PP
Referenced by initialize_element_variables(), initialize_global_variables(), and initialize_nodal_variables()\&.
.PP
.nf
1572 {
1573   // There may already be global variables in the file (for example,
1574   // if we're appending) and in that case, we
1575   // 1\&.) Cannot initialize them again\&.
1576   // 2\&.) Should check to be sure that the global variable names are the same\&.
1577 
1578   // Fills up names_from_file for us
1579   this->read_var_names(type);
1580 
1581   // Both the names of the global variables and their order must match
1582   if (names_from_file != names)
1583     {
1584       libMesh::err << "Error! The Exodus file already contains the variables:" << std::endl;
1585       for (unsigned i=0; i<names_from_file\&.size(); ++i)
1586         libMesh::out << names_from_file[i] << std::endl;
1587 
1588       libMesh::err << "And you asked to write:" << std::endl;
1589       for (unsigned i=0; i<names\&.size(); ++i)
1590         libMesh::out << names[i] << std::endl;
1591 
1592       libmesh_error();
1593     }
1594 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::close ()"
Closes the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 695 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, ex_close(), ex_err, ex_id, message(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::~ExodusII_IO(), and libMesh::Nemesis_IO_Helper::~Nemesis_IO_Helper()\&.
.PP
.nf
696 {
697   // Always call close on processor 0\&.
698   // If we're running on multiple processors, i\&.e\&. as one of several Nemesis files,
699   // we call close on all processors\&.\&.\&.
700   if ((this->processor_id() == 0) || (!_run_only_on_proc0))
701     {
702       ex_err = exII::ex_close(ex_id);
703       EX_CHECK_ERR(ex_err, "Error closing Exodus file\&.");
704       message("Exodus file closed successfully\&.");
705     }
706 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "void libMesh::ExodusII_IO_Helper::create (std::stringfilename)\fC [virtual]\fP"
Opens an \fCExodusII\fP mesh file named \fCfilename\fP for writing\&. 
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 970 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, _single_precision, current_filename, ex_id, std::min(), opened_for_writing, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::Real, and verbose\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
971 {
972   // If we're processor 0, always create the file\&.
973   // If we running on all procs, e\&.g\&. as one of several Nemesis files, also
974   // call create there\&.
975   if ((this->processor_id() == 0) || (!_run_only_on_proc0))
976     {
977       int
978         comp_ws = 0,
979         io_ws = 0;
980 
981       if(_single_precision)
982         {
983           comp_ws = sizeof(float);
984           io_ws = sizeof(float);
985         }
986       // Fall back on double precision when necessary since ExodusII
987       // doesn't seem to support long double
988       else
989         {
990           comp_ws = std::min(sizeof(Real), sizeof(double));
991           io_ws = std::min(sizeof(Real), sizeof(double));
992         }
993 
994       ex_id = exII::ex_create(filename\&.c_str(), EX_CLOBBER, &comp_ws, &io_ws);
995 
996       EX_CHECK_ERR(ex_id, "Error creating ExodusII mesh file\&.");
997 
998       if (verbose)
999         libMesh::out << "File created successfully\&." << std::endl;
1000     }
1001 
1002   opened_for_writing = true;
1003   current_filename = filename;
1004 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_block_id (intindex)"
Get the block number for the given block index\&. 
.PP
Definition at line 444 of file exodusII_io_helper\&.C\&.
.PP
References block_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read(), and write_element_values()\&.
.PP
.nf
445 {
446   libmesh_assert_less (static_cast<unsigned int>(index), block_ids\&.size());
447 
448   return block_ids[index];
449 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_block_name (intindex)"
Get the block name for the given block index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 453 of file exodusII_io_helper\&.C\&.
.PP
References block_ids, and id_to_block_names\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
454 {
455   libmesh_assert_less (static_cast<unsigned int>(index), block_ids\&.size());
456 
457   return id_to_block_names[block_ids[index]];
458 }
.fi
.SS "std::vector< std::string > libMesh::ExodusII_IO_Helper::get_complex_names (const std::vector< std::string > &names) const"
Returns a vector with three copies of each element in the provided name vector, starting with r_, i_ and a_ respectively\&. 
.PP
Definition at line 1786 of file exodusII_io_helper\&.C\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data(), libMesh::Nemesis_IO::write_global_data(), libMesh::ExodusII_IO::write_global_data(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.PP
.nf
1787 {
1788   std::vector<std::string>::const_iterator names_it = names\&.begin();
1789   std::vector<std::string>::const_iterator names_end = names\&.end();
1790 
1791   std::vector<std::string> complex_names;
1792 
1793   // This will loop over all names and create new "complex" names
1794   // (i\&.e\&. names that start with r_, i_ or a_
1795   for (; names_it != names_end; ++names_it)
1796     {
1797       std::cout << "VARIABLE: " << *names_it << std::endl;
1798       std::stringstream name_real, name_imag, name_abs;
1799       name_real << "r_" << *names_it;
1800       name_imag << "i_" << *names_it;
1801       name_abs << "a_" << *names_it;
1802 
1803       complex_names\&.push_back(name_real\&.str());
1804       complex_names\&.push_back(name_imag\&.str());
1805       complex_names\&.push_back(name_abs\&.str());
1806     }
1807 
1808   return complex_names;
1809 }
.fi
.SS "const char * libMesh::ExodusII_IO_Helper::get_elem_type () const"

.PP
\fBReturns:\fP
.RS 4
the current element type\&. Note: the default behavior is for this value to be in all capital letters, e\&.g\&. \fCHEX27\fP\&. 
.RE
.PP

.PP
Definition at line 273 of file exodusII_io_helper\&.C\&.
.PP
References elem_type\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
274 {
275   return &elem_type[0];
276 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_node_set_id (intindex)"
Get the node set id for the given node set index\&. 
.PP
Definition at line 480 of file exodusII_io_helper\&.C\&.
.PP
References nodeset_ids\&.
.PP
.nf
481 {
482   libmesh_assert_less (static_cast<unsigned int>(index), nodeset_ids\&.size());
483 
484   return nodeset_ids[index];
485 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_node_set_name (intindex)"
Get the node set name for the given node set index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 489 of file exodusII_io_helper\&.C\&.
.PP
References id_to_ns_names, and nodeset_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
490 {
491   libmesh_assert_less (static_cast<unsigned int>(index), nodeset_ids\&.size());
492 
493   return id_to_ns_names[nodeset_ids[index]];
494 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_side_set_id (intindex)"
Get the side set id for the given side set index\&. 
.PP
Definition at line 462 of file exodusII_io_helper\&.C\&.
.PP
References ss_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
463 {
464   libmesh_assert_less (static_cast<unsigned int>(index), ss_ids\&.size());
465 
466   return ss_ids[index];
467 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_side_set_name (intindex)"
Get the side set name for the given side set index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 471 of file exodusII_io_helper\&.C\&.
.PP
References id_to_ss_names, and ss_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
472 {
473   libmesh_assert_less (static_cast<unsigned int>(index), ss_ids\&.size());
474 
475   return id_to_ss_names[ss_ids[index]];
476 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize (std::stringtitle, const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
Initializes the Exodus file\&. 
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 1008 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, _use_mesh_dimension_instead_of_spatial_dimension, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::MeshBase::boundary_info, end, libMesh::err, ex_err, ex_id, ex_put_init(), libMesh::DofObject::id(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_active_elem(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), num_dim, num_elem, num_elem_blk, num_node_sets, num_nodes, num_side_sets, libMesh::ParallelObject::processor_id(), libMesh::MeshBase::spatial_dimension(), and libMesh::Elem::subdomain_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1009 {
1010   // n_active_elem() is a parallel_only function
1011   unsigned int n_active_elem = mesh\&.n_active_elem();
1012 
1013   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1014     return;
1015 
1016   if (_use_mesh_dimension_instead_of_spatial_dimension)
1017     num_dim = mesh\&.mesh_dimension();
1018   else
1019     num_dim = mesh\&.spatial_dimension();
1020 
1021   num_elem = mesh\&.n_elem();
1022 
1023   if(!use_discontinuous)
1024   {
1025     num_nodes = mesh\&.n_nodes();
1026   }
1027   else
1028   {
1029     MeshBase::const_element_iterator       it  = mesh\&.active_elements_begin();
1030     const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1031     for (; it!=end; ++it)
1032       num_nodes += (*it)->n_nodes();
1033   }
1034 
1035   std::vector<boundary_id_type> unique_side_boundaries;
1036   std::vector<boundary_id_type> unique_node_boundaries;
1037 
1038   mesh\&.boundary_info->build_side_boundary_ids(unique_side_boundaries);
1039   mesh\&.boundary_info->build_node_boundary_ids(unique_node_boundaries);
1040 
1041   num_side_sets = unique_side_boundaries\&.size();
1042   num_node_sets = unique_node_boundaries\&.size();
1043 
1044   //loop through element and map between block and element vector
1045   std::map<subdomain_id_type, std::vector<unsigned int>  > subdomain_map;
1046 
1047   MeshBase::const_element_iterator it = mesh\&.active_elements_begin();
1048   const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1049   for (; it!=end; ++it)
1050     {
1051       const Elem * elem = *it;
1052       subdomain_id_type cur_subdomain = elem->subdomain_id();
1053 
1054       subdomain_map[cur_subdomain]\&.push_back(elem->id());
1055     }
1056   num_elem_blk = subdomain_map\&.size();
1057 
1058   if (str_title\&.size() > MAX_LINE_LENGTH)
1059     {
1060       libMesh::err << "Warning, Exodus files cannot have titles longer than "
1061                    << MAX_LINE_LENGTH
1062                    << " characters\&.  Your title will be truncated\&."
1063                    << std::endl;
1064       str_title\&.resize(MAX_LINE_LENGTH);
1065     }
1066 
1067   ex_err = exII::ex_put_init(ex_id,
1068                              str_title\&.c_str(),
1069                              num_dim,
1070                              num_nodes,
1071                              n_active_elem,
1072                              num_elem_blk,
1073                              num_node_sets,
1074                              num_side_sets);
1075 
1076   EX_CHECK_ERR(ex_err, "Error initializing new Exodus file\&.");
1077 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_element_variables (std::vector< std::string >names)"
Sets up the nodal variables 
.PP
Definition at line 1468 of file exodusII_io_helper\&.C\&.
.PP
References _elem_vars_initialized, _run_only_on_proc0, check_existing_vars(), elem_var_names, ELEMENTAL, ex_err, ex_id, ex_put_elem_var_tab(), num_elem_blk, num_elem_vars, libMesh::ParallelObject::processor_id(), and write_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data()\&.
.PP
.nf
1469 {
1470   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1471     return;
1472 
1473   // Quick return if there are no element variables to write
1474   if (names\&.size() == 0)
1475     return;
1476 
1477   // Quick return if we have already called this function
1478   if (_elem_vars_initialized)
1479     return;
1480 
1481   // Be sure that variables in the file match what we are asking for
1482   if (num_elem_vars > 0)
1483     {
1484       this->check_existing_vars(ELEMENTAL, names, this->elem_var_names);
1485       return;
1486     }
1487 
1488   // Set the flag so we can skip this stuff on subsequent calls to
1489   // initialize_element_variables()
1490   _elem_vars_initialized = true;
1491 
1492   this->write_var_names(ELEMENTAL, names);
1493 
1494   // Form the element variable truth table and send to Exodus\&.
1495   // This tells which variables are written to which blocks,
1496   // and can dramatically speed up writing element variables
1497   //
1498   // We really should initialize all entries in the truth table to 0
1499   // and then loop over all subdomains, setting their entries to 1
1500   // if a given variable exists on that subdomain\&.  However,
1501   // we don't have that information, and the element variables
1502   // passed to us are padded with zeroes for the blocks where
1503   // they aren't defined\&.  To be consistent with that, fill
1504   // the truth table with ones\&.
1505   std::vector<int> truth_tab(num_elem_blk*num_elem_vars, 1);
1506   ex_err = exII::ex_put_elem_var_tab(ex_id,
1507                                      num_elem_blk,
1508                                      num_elem_vars,
1509                                      &truth_tab[0]);
1510   EX_CHECK_ERR(ex_err, "Error writing element truth table\&.");
1511 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_global_variables (std::vector< std::string >names)"
Sets up the global variables 
.PP
Definition at line 1543 of file exodusII_io_helper\&.C\&.
.PP
References _global_vars_initialized, _run_only_on_proc0, check_existing_vars(), GLOBAL, global_var_names, num_global_vars, libMesh::ParallelObject::processor_id(), and write_var_names()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_global_data(), and libMesh::ExodusII_IO::write_global_data()\&.
.PP
.nf
1544 {
1545   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1546     return;
1547 
1548   // Quick return if there are no global variables to write
1549   if (names\&.size() == 0)
1550     return;
1551 
1552   if (_global_vars_initialized)
1553     return;
1554 
1555   // Be sure that variables in the file match what we are asking for
1556   if (num_global_vars > 0)
1557     {
1558       this->check_existing_vars(GLOBAL, names, this->global_var_names);
1559       return;
1560     }
1561 
1562   _global_vars_initialized = true;
1563 
1564   this->write_var_names(GLOBAL, names);
1565 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_nodal_variables (std::vector< std::string >names)"
Sets up the nodal variables 
.PP
Definition at line 1515 of file exodusII_io_helper\&.C\&.
.PP
References _nodal_vars_initialized, _run_only_on_proc0, check_existing_vars(), NODAL, nodal_var_names, num_nodal_vars, libMesh::ParallelObject::processor_id(), and write_var_names()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1516 {
1517   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1518     return;
1519 
1520   // Quick return if there are no nodal variables to write
1521   if (names\&.size() == 0)
1522     return;
1523 
1524   // Quick return if we have already called this function
1525   if (_nodal_vars_initialized)
1526     return;
1527 
1528   // Be sure that variables in the file match what we are asking for
1529   if (num_nodal_vars > 0)
1530     {
1531       this->check_existing_vars(NODAL, names, this->nodal_var_names);
1532       return;
1533     }
1534 
1535   // Set the flag so we can skip the rest of this function on subsequent calls\&.
1536   _nodal_vars_initialized = true;
1537 
1538   this->write_var_names(NODAL, names);
1539 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::inquire (intreq_info, std::stringerror_msg = \fC''\fP)"
Generic inquiry, returns the value 
.PP
Definition at line 710 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_id, and ex_inquire()\&.
.PP
Referenced by read_num_time_steps(), read_sideset_info(), and write_information_records()\&.
.PP
.nf
711 {
712   int ret_int = 0;
713   char ret_char = 0;
714   float ret_float = 0\&.;
715 
716   ex_err = exII::ex_inquire(ex_id,
717                             req_info_in,
718                             &ret_int,
719                             &ret_float,
720                             &ret_char);
721 
722   EX_CHECK_ERR(ex_err, error_msg);
723 
724   return ret_int;
725 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::message (const std::string &msg)"
Prints the message defined in \fCmsg\fP\&. Can be turned off if verbosity is set to 0\&. 
.PP
Definition at line 280 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::out, and verbose\&.
.PP
Referenced by close(), read_block_info(), read_elem_in_block(), read_elem_num_map(), read_header(), read_node_num_map(), read_nodes(), read_nodeset(), read_nodeset_info(), read_sideset(), and read_sideset_info()\&.
.PP
.nf
281 {
282   if (verbose) libMesh::out << msg << std::endl;
283 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::message (const std::string &msg, inti)"
Prints the message defined in \fCmsg\fP, and appends the number \fCi\fP to the end of the message\&. Useful for printing messages in loops\&. Can be turned off if verbosity is set to 0\&. 
.PP
Definition at line 287 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::out, and verbose\&.
.PP
.nf
288 {
289   if (verbose) libMesh::out << msg << i << "\&." << std::endl;
290 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "void libMesh::ExodusII_IO_Helper::open (const char *filename, boolread_only)"
Opens an \fCExodusII\fP mesh file named \fCfilename\fP\&. If read_only==true, the file will be opened with the EX_READ flag, otherwise it will be opened with the EX_WRITE flag\&. 
.PP
Definition at line 294 of file exodusII_io_helper\&.C\&.
.PP
References current_filename, ex_id, opened_for_reading, opened_for_writing, libMesh::out, libMesh::Real, and verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
295 {
296   // Version of Exodus you are using
297   float ex_version = 0\&.;
298 
299   // Word size in bytes of the floating point variables used in the
300   // application program (0, 4, or 8)
301   int comp_ws = sizeof(Real);
302 
303   // Word size in bytes of the floating point data as they are stored
304   // in the ExodusII file\&.  "If this argument is 0, the word size of the
305   // floating point data already stored in the file is returned"
306   int io_ws = 0;
307 
308   ex_id = exII::ex_open(filename,
309                         read_only ? EX_READ : EX_WRITE,
310                         &comp_ws,
311                         &io_ws,
312                         &ex_version);
313 
314   std::string err_msg = std::string("Error opening ExodusII mesh file: ") + std::string(filename);
315   EX_CHECK_ERR(ex_id, err_msg);
316   if (verbose) libMesh::out << "File opened successfully\&." << std::endl;
317 
318   if (read_only)
319     opened_for_reading = true;
320   else
321     opened_for_writing = true;
322 
323   current_filename = std::string(filename);
324 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::print_header ()"
Prints the \fCExodusII\fP mesh file header, which includes the mesh title, the number of nodes, number of elements, mesh dimension, number of sidesets, and number of nodesets\&. 
.PP
Definition at line 358 of file exodusII_io_helper\&.C\&.
.PP
References num_dim, num_elem, num_elem_blk, num_node_sets, num_nodes, num_side_sets, libMesh::out, title, and verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
359 {
360   if (verbose)
361     libMesh::out << "Title: \t" << &title[0] << std::endl
362                  << "Mesh Dimension: \t"   << num_dim << std::endl
363                  << "Number of Nodes: \t" << num_nodes << std::endl
364                  << "Number of elements: \t" << num_elem << std::endl
365                  << "Number of elt blocks: \t" << num_elem_blk << std::endl
366                  << "Number of node sets: \t" << num_node_sets << std::endl
367                  << "Number of side sets: \t" << num_side_sets << std::endl;
368 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::print_nodes (std::ostream &out = \fC\fBlibMesh::out\fP\fP)"
Prints the nodal information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 409 of file exodusII_io_helper\&.C\&.
.PP
References num_nodes, x, y, and z\&.
.PP
.nf
410 {
411   for (int i=0; i<num_nodes; i++)
412     out_stream << "(" << x[i] << ", " << y[i] << ", " << z[i] << ")" << std::endl;
413 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), initialize(), initialize_element_variables(), initialize_global_variables(), initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), write_element_values(), write_elements(), libMesh::ExodusII_IO::write_global_data(), write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), write_information_records(), write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), write_nodal_values(), write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_block_info ()"
Reads information for all of the blocks in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 417 of file exodusII_io_helper\&.C\&.
.PP
References block_ids, EX_ELEM_BLOCK, ex_err, ex_get_elem_blk_ids(), ex_get_name(), ex_id, id_to_block_names, message(), and num_elem_blk\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
418 {
419   block_ids\&.resize(num_elem_blk);
420   // Get all element block IDs\&.
421   ex_err = exII::ex_get_elem_blk_ids(ex_id,
422                                      block_ids\&.empty() ? NULL : &block_ids[0]);
423   // Usually, there is only one
424   // block since there is only
425   // one type of element\&.
426   // However, there could be more\&.
427 
428   EX_CHECK_ERR(ex_err, "Error getting block IDs\&.");
429   message("All block IDs retrieved successfully\&.");
430 
431   char name_buffer[MAX_STR_LENGTH+1];
432   for (int i=0; i<num_elem_blk; ++i)
433     {
434       ex_err = exII::ex_get_name(ex_id, exII::EX_ELEM_BLOCK,
435                                  block_ids[i], name_buffer);
436       EX_CHECK_ERR(ex_err, "Error getting block name\&.");
437       id_to_block_names[block_ids[i]] = name_buffer;
438     }
439   message("All block names retrieved successfully\&.");
440 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elem_in_block (intblock)"
Reads all of the element connectivity for block \fCblock\fP in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 499 of file exodusII_io_helper\&.C\&.
.PP
References block_ids, connect, elem_type, ex_err, ex_get_elem_block(), ex_get_elem_conn(), ex_id, message(), num_attr, num_elem_this_blk, num_nodes_per_elem, libMesh::out, and verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
500 {
501   libmesh_assert_less (static_cast<unsigned int>(block), block_ids\&.size());
502 
503   ex_err = exII::ex_get_elem_block(ex_id,
504                                    block_ids[block],
505                                    &elem_type[0],
506                                    &num_elem_this_blk,
507                                    &num_nodes_per_elem,
508                                    &num_attr);
509   if (verbose)
510     libMesh::out << "Reading a block of " << num_elem_this_blk
511                  << " " << &elem_type[0] << "(s)"
512                  << " having " << num_nodes_per_elem
513                  << " nodes per element\&." << std::endl;
514 
515   EX_CHECK_ERR(ex_err, "Error getting block info\&.");
516   message("Info retrieved successfully for block: ", block);
517 
518 
519 
520   // Read in the connectivity of the elements of this block,
521   // watching out for the case where we actually have no
522   // elements in this block (possible with parallel files)
523   connect\&.resize(num_nodes_per_elem*num_elem_this_blk);
524 
525   if (!connect\&.empty())
526     {
527       ex_err = exII::ex_get_elem_conn(ex_id,
528                                       block_ids[block],
529                                       &connect[0]);
530 
531       EX_CHECK_ERR(ex_err, "Error reading block connectivity\&.");
532       message("Connectivity retrieved successfully for block: ", block);
533     }
534 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elem_num_map ()"
Reads the optional \fCnode_num_map\fP from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 539 of file exodusII_io_helper\&.C\&.
.PP
References elem_num_map, ex_err, ex_get_elem_num_map(), ex_id, message(), std::min(), num_elem, libMesh::out, libMesh::ParallelObject::processor_id(), and verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
540 {
541   elem_num_map\&.resize(num_elem);
542 
543   ex_err = exII::ex_get_elem_num_map (ex_id,
544                                       elem_num_map\&.empty() ? NULL : &elem_num_map[0]);
545 
546   EX_CHECK_ERR(ex_err, "Error retrieving element number map\&.");
547   message("Element numbering map retrieved successfully\&.");
548 
549 
550   if (verbose)
551     {
552       libMesh::out << "[" << this->processor_id() << "] elem_num_map[i] = ";
553       for (unsigned int i=0; i<static_cast<unsigned int>(std::min(10, num_elem-1)); ++i)
554         libMesh::out << elem_num_map[i] << ", ";
555       libMesh::out << "\&.\&.\&. " << elem_num_map\&.back() << std::endl;
556     }
557 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elemental_var_values (std::stringelemental_var_name, inttime_step)"
Reads elemental values for the variable 'elemental_var_name' at the specified timestep into the 'elem_var_values' array\&. 
.PP
Definition at line 907 of file exodusII_io_helper\&.C\&.
.PP
References block_ids, elem_var_names, elem_var_values, ELEMENTAL, libMesh::err, ex_err, ex_get_elem_block(), ex_get_elem_var(), ex_id, num_elem, num_elem_blk, and read_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution()\&.
.PP
.nf
908 {
909   // CAUTION: this assumes that libMesh element numbering is identical to exodus block-by-block element numbering
910   // There is no way how to get the whole elemental field from the exodus file, so we have to go block by block
911 
912   elem_var_values\&.resize(num_elem);
913 
914   this->read_var_names(ELEMENTAL);
915 
916   // See if we can find the variable we are looking for
917   unsigned int var_index = 0;
918   bool found = false;
919 
920   // Do a linear search for nodal_var_name in nodal_var_names
921   for (; var_index<elem_var_names\&.size(); ++var_index)
922     {
923       found = (elem_var_names[var_index] == elemental_var_name);
924       if (found)
925         break;
926     }
927 
928   if (!found)
929     {
930       libMesh::err << "Unable to locate variable named: " << elemental_var_name << std::endl;
931       libMesh::err << "Available variables: " << std::endl;
932       for (unsigned int i=0; i<elem_var_names\&.size(); ++i)
933         libMesh::err << elem_var_names[i] << std::endl;
934 
935       libmesh_error();
936     }
937 
938   unsigned int ex_el_num = 0;
939   for (unsigned int i=0; i<static_cast<unsigned int>(num_elem_blk); i++)
940     {
941       int n_blk_elems = 0;
942       ex_err = exII::ex_get_elem_block(ex_id,
943                                        block_ids[i],
944                                        NULL,
945                                        &n_blk_elems,
946                                        NULL,
947                                        NULL);
948       EX_CHECK_ERR(ex_err, "Error getting number of elements in block\&.");
949 
950       std::vector<Real> block_elem_var_values(num_elem);
951       ex_err = exII::ex_get_elem_var(ex_id,
952                                      time_step,
953                                      var_index+1,
954                                      block_ids[i],
955                                      n_blk_elems,
956                                      &block_elem_var_values[0]);
957       EX_CHECK_ERR(ex_err, "Error getting elemental values\&.");
958 
959       for (unsigned int j=0; j<static_cast<unsigned int>(n_blk_elems); j++)
960         {
961           elem_var_values[ex_el_num] = block_elem_var_values[j];
962           ex_el_num++;
963         }
964     }
965 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_header ()"
Reads an \fCExodusII\fP mesh file header\&. 
.PP
Definition at line 328 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_init(), ex_get_var_param(), ex_id, message(), num_dim, num_elem, num_elem_blk, num_elem_vars, num_global_vars, num_nodal_vars, num_node_sets, num_nodes, num_side_sets, read_num_time_steps(), and title\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
329 {
330   ex_err = exII::ex_get_init(ex_id,
331                              &title[0],
332                              &num_dim,
333                              &num_nodes,
334                              &num_elem,
335                              &num_elem_blk,
336                              &num_node_sets,
337                              &num_side_sets);
338 
339   EX_CHECK_ERR(ex_err, "Error retrieving header info\&.");
340 
341   this->read_num_time_steps();
342 
343   ex_err = exII::ex_get_var_param(ex_id, "n", &num_nodal_vars);
344   EX_CHECK_ERR(ex_err, "Error reading number of nodal variables\&.");
345 
346   ex_err = exII::ex_get_var_param(ex_id, "e", &num_elem_vars);
347   EX_CHECK_ERR(ex_err, "Error reading number of elemental variables\&.");
348 
349   ex_err = exII::ex_get_var_param(ex_id, "g", &num_global_vars);
350   EX_CHECK_ERR(ex_err, "Error reading number of global variables\&.");
351 
352   message("Exodus header info retrieved successfully\&.");
353 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodal_var_values (std::stringnodal_var_name, inttime_step)"
Reads the nodal values for the variable 'nodal_var_name' at the specified time into the 'nodal_var_values' array\&. 
.PP
Definition at line 752 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::err, ex_err, ex_get_nodal_var(), ex_id, NODAL, nodal_var_names, nodal_var_values, num_nodes, and read_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_nodal_solution()\&.
.PP
.nf
753 {
754   // Read the nodal variable names from file, so we can see if we have the one we're looking for
755   this->read_var_names(NODAL);
756 
757   // See if we can find the variable we are looking for
758   unsigned int var_index = 0;
759   bool found = false;
760 
761   // Do a linear search for nodal_var_name in nodal_var_names
762   for (; var_index<nodal_var_names\&.size(); ++var_index)
763     {
764       found = (nodal_var_names[var_index] == nodal_var_name);
765       if (found)
766         break;
767     }
768 
769   if (!found)
770     {
771       libMesh::err << "Unable to locate variable named: " << nodal_var_name << std::endl;
772       libMesh::err << "Available variables: " << std::endl;
773       for (unsigned int i=0; i<nodal_var_names\&.size(); ++i)
774         libMesh::err << nodal_var_names[i] << std::endl;
775 
776       libmesh_error();
777     }
778 
779   // Allocate enough space to store the nodal variable values
780   nodal_var_values\&.resize(num_nodes);
781 
782   // Call the Exodus API to read the nodal variable values
783   ex_err = exII::ex_get_nodal_var(ex_id,
784                                   time_step,
785                                   var_index+1,
786                                   num_nodes,
787                                   &nodal_var_values[0]);
788   EX_CHECK_ERR(ex_err, "Error reading nodal variable values!");
789 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_node_num_map ()"
Reads the optional \fCnode_num_map\fP from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 389 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_node_num_map(), ex_id, message(), std::min(), node_num_map, num_nodes, libMesh::out, libMesh::ParallelObject::processor_id(), and verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
390 {
391   node_num_map\&.resize(num_nodes);
392 
393   ex_err = exII::ex_get_node_num_map (ex_id,
394                                       node_num_map\&.empty() ? NULL : &node_num_map[0]);
395 
396   EX_CHECK_ERR(ex_err, "Error retrieving nodal number map\&.");
397   message("Nodal numbering map retrieved successfully\&.");
398 
399   if (verbose)
400     {
401       libMesh::out << "[" << this->processor_id() << "] node_num_map[i] = ";
402       for (unsigned int i=0; i<static_cast<unsigned int>(std::min(10, num_nodes-1)); ++i)
403         libMesh::out << node_num_map[i] << ", ";
404       libMesh::out << "\&.\&.\&. " << node_num_map\&.back() << std::endl;
405     }
406 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodes ()"
Reads the nodal data (x,y,z coordinates) from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 372 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_coord(), ex_id, message(), num_nodes, x, y, and z\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
373 {
374   x\&.resize(num_nodes);
375   y\&.resize(num_nodes);
376   z\&.resize(num_nodes);
377 
378   ex_err = exII::ex_get_coord(ex_id,
379                               static_cast<void*>(&x[0]),
380                               static_cast<void*>(&y[0]),
381                               static_cast<void*>(&z[0]));
382 
383   EX_CHECK_ERR(ex_err, "Error retrieving nodal data\&.");
384   message("Nodal data retrieved successfully\&.");
385 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodeset (intid)"
Reads information about nodeset \fCid\fP and inserts it into the global nodeset array at the position \fCoffset\fP\&. 
.PP
Definition at line 665 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_node_set(), ex_get_node_set_param(), ex_id, message(), node_list, nodeset_ids, num_node_df_per_set, and num_nodes_per_set\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
666 {
667   libmesh_assert_less (static_cast<unsigned int>(id), nodeset_ids\&.size());
668   libmesh_assert_less (static_cast<unsigned int>(id), num_nodes_per_set\&.size());
669   libmesh_assert_less (static_cast<unsigned int>(id), num_node_df_per_set\&.size());
670 
671   ex_err = exII::ex_get_node_set_param(ex_id,
672                                        nodeset_ids[id],
673                                        &num_nodes_per_set[id],
674                                        &num_node_df_per_set[id]);
675   EX_CHECK_ERR(ex_err, "Error retrieving nodeset parameters\&.");
676   message("Parameters retrieved successfully for nodeset: ", id);
677 
678   node_list\&.resize(num_nodes_per_set[id]);
679 
680   // Don't call ex_get_node_set unless there are actually nodes there to get\&.
681   // Exodus prints an annoying warning message in DEBUG mode otherwise\&.\&.\&.
682   if (num_nodes_per_set[id] > 0)
683     {
684       ex_err = exII::ex_get_node_set(ex_id,
685                                      nodeset_ids[id],
686                                      &node_list[0]);
687 
688       EX_CHECK_ERR(ex_err, "Error retrieving nodeset data\&.");
689       message("Data retrieved successfully for nodeset: ", id);
690     }
691 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodeset_info ()"
Reads information about all of the nodesets in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 594 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_name(), ex_get_node_set_ids(), ex_id, EX_NODE_SET, id_to_ns_names, message(), nodeset_ids, num_node_df_per_set, num_node_sets, and num_nodes_per_set\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
595 {
596   nodeset_ids\&.resize(num_node_sets);
597   if (num_node_sets > 0)
598     {
599       ex_err = exII::ex_get_node_set_ids(ex_id,
600                                          &nodeset_ids[0]);
601       EX_CHECK_ERR(ex_err, "Error retrieving nodeset information\&.");
602       message("All nodeset information retrieved successfully\&.");
603 
604       // Resize appropriate data structures -- only do this once outnode the loop
605       num_nodes_per_set\&.resize(num_node_sets);
606       num_node_df_per_set\&.resize(num_node_sets);
607     }
608 
609   char name_buffer[MAX_STR_LENGTH+1];
610   for (int i=0; i<num_node_sets; ++i)
611     {
612       ex_err = exII::ex_get_name(ex_id, exII::EX_NODE_SET,
613                                  nodeset_ids[i], name_buffer);
614       EX_CHECK_ERR(ex_err, "Error getting node set name\&.");
615       id_to_ns_names[nodeset_ids[i]] = name_buffer;
616     }
617   message("All node set names retrieved successfully\&.");
618 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_num_time_steps ()"
Reads the number of timesteps currently stored in the Exodus file and stores it in the num_time_steps variable\&. 
.PP
Definition at line 744 of file exodusII_io_helper\&.C\&.
.PP
References EX_INQ_TIME, inquire(), and num_time_steps\&.
.PP
Referenced by libMesh::ExodusII_IO::get_num_time_steps(), read_header(), and read_time_steps()\&.
.PP
.nf
745 {
746   num_time_steps =
747     this->inquire(exII::EX_INQ_TIME, "Error retrieving number of time steps");
748 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_sideset (intid, intoffset)"
Reads information about sideset \fCid\fP and inserts it into the global sideset array at the position \fCoffset\fP\&. 
.PP
Definition at line 622 of file exodusII_io_helper\&.C\&.
.PP
References elem_list, ex_err, ex_get_side_set(), ex_get_side_set_param(), ex_id, id_list, message(), num_df_per_set, num_sides_per_set, side_list, and ss_ids\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
623 {
624   libmesh_assert_less (static_cast<unsigned int>(id), ss_ids\&.size());
625   libmesh_assert_less (static_cast<unsigned int>(id), num_sides_per_set\&.size());
626   libmesh_assert_less (static_cast<unsigned int>(id), num_df_per_set\&.size());
627   libmesh_assert_less_equal (static_cast<unsigned int>(offset), elem_list\&.size());
628   libmesh_assert_less_equal (static_cast<unsigned int>(offset), side_list\&.size());
629 
630   ex_err = exII::ex_get_side_set_param(ex_id,
631                                        ss_ids[id],
632                                        &num_sides_per_set[id],
633                                        &num_df_per_set[id]);
634   EX_CHECK_ERR(ex_err, "Error retrieving sideset parameters\&.");
635   message("Parameters retrieved successfully for sideset: ", id);
636 
637 
638   // It's OK for offset==elem_list\&.size() as long as num_sides_per_set[id]==0
639   // because in that case we don't actually read anything\&.\&.\&.
640 #ifdef DEBUG
641   if (static_cast<unsigned int>(offset) == elem_list\&.size() ||
642       static_cast<unsigned int>(offset) == side_list\&.size() )
643     libmesh_assert_equal_to (num_sides_per_set[id], 0);
644 #endif
645 
646 
647   // Don't call ex_get_side_set unless there are actually sides there to get\&.
648   // Exodus prints an annoying warning in DEBUG mode otherwise\&.\&.\&.
649   if (num_sides_per_set[id] > 0)
650     {
651       ex_err = exII::ex_get_side_set(ex_id,
652                                      ss_ids[id],
653                                      &elem_list[offset],
654                                      &side_list[offset]);
655       EX_CHECK_ERR(ex_err, "Error retrieving sideset data\&.");
656       message("Data retrieved successfully for sideset: ", id);
657 
658       for (int i=0; i<num_sides_per_set[id]; i++)
659         id_list[i+offset] = ss_ids[id];
660     }
661 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_sideset_info ()"
Reads information about all of the sidesets in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 561 of file exodusII_io_helper\&.C\&.
.PP
References elem_list, ex_err, ex_get_name(), ex_get_side_set_ids(), ex_id, EX_INQ_SS_ELEM_LEN, EX_SIDE_SET, id_list, id_to_ss_names, inquire(), message(), num_df_per_set, num_elem_all_sidesets, num_side_sets, num_sides_per_set, side_list, and ss_ids\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
562 {
563   ss_ids\&.resize(num_side_sets);
564   if (num_side_sets > 0)
565     {
566       ex_err = exII::ex_get_side_set_ids(ex_id,
567                                          &ss_ids[0]);
568       EX_CHECK_ERR(ex_err, "Error retrieving sideset information\&.");
569       message("All sideset information retrieved successfully\&.");
570 
571       // Resize appropriate data structures -- only do this once outside the loop
572       num_sides_per_set\&.resize(num_side_sets);
573       num_df_per_set\&.resize(num_side_sets);
574 
575       // Inquire about the length of the concatenated side sets element list
576       num_elem_all_sidesets = inquire(exII::EX_INQ_SS_ELEM_LEN, "Error retrieving length of the concatenated side sets element list!");
577 
578       elem_list\&.resize (num_elem_all_sidesets);
579       side_list\&.resize (num_elem_all_sidesets);
580       id_list\&.resize   (num_elem_all_sidesets);
581     }
582 
583   char name_buffer[MAX_STR_LENGTH+1];
584   for (int i=0; i<num_side_sets; ++i)
585     {
586       ex_err = exII::ex_get_name(ex_id, exII::EX_SIDE_SET,
587                                  ss_ids[i], name_buffer);
588       EX_CHECK_ERR(ex_err, "Error getting side set name\&.");
589       id_to_ss_names[ss_ids[i]] = name_buffer;
590     }
591   message("All side set names retrieved successfully\&.");
592 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_time_steps ()"
Reads and stores the timesteps in the 'time_steps' array\&. 
.PP
Definition at line 729 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_all_times(), ex_id, num_time_steps, read_num_time_steps(), and time_steps\&.
.PP
Referenced by libMesh::ExodusII_IO::get_time_steps()\&.
.PP
.nf
730 {
731   // Make sure we have an up-to-date count of the number of time steps in the file\&.
732   this->read_num_time_steps();
733 
734   if (num_time_steps > 0)
735     {
736       time_steps\&.resize(num_time_steps);
737       ex_err = exII::ex_get_all_times(ex_id, &time_steps[0]);
738       EX_CHECK_ERR(ex_err, "Error reading timesteps!");
739     }
740 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_var_names (\fBExodusVarType\fPtype)\fC [private]\fP"

.PP
Definition at line 793 of file exodusII_io_helper\&.C\&.
.PP
References elem_var_names, ELEMENTAL, libMesh::err, GLOBAL, global_var_names, NODAL, nodal_var_names, num_elem_vars, num_global_vars, num_nodal_vars, and read_var_names_impl()\&.
.PP
Referenced by check_existing_vars(), read_elemental_var_values(), and read_nodal_var_values()\&.
.PP
.nf
794 {
795   switch (type)
796     {
797     case NODAL:
798       this->read_var_names_impl("n", num_nodal_vars, nodal_var_names);
799       break;
800     case ELEMENTAL:
801       this->read_var_names_impl("e", num_elem_vars, elem_var_names);
802       break;
803     case GLOBAL:
804       this->read_var_names_impl("g", num_global_vars, global_var_names);
805       break;
806     default:
807       libMesh::err << "Unrecognized ExodusVarType " << type << std::endl;
808       libmesh_error();
809     }
810 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_var_names_impl (const char *var_type, int &count, std::vector< std::string > &result)\fC [private]\fP"
\fBread_var_names()\fP dispatches to this function\&. 
.PP
Definition at line 814 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_get_var_names(), ex_get_var_param(), ex_id, libMesh::ExodusII_IO_Helper::NamesData::get_char_star(), libMesh::ExodusII_IO_Helper::NamesData::get_char_star_star(), libMesh::out, and verbose\&.
.PP
Referenced by read_var_names()\&.
.PP
.nf
817 {
818   // First read and store the number of names we have
819   ex_err = exII::ex_get_var_param(ex_id, var_type, &count);
820   EX_CHECK_ERR(ex_err, "Error reading number of variables\&.");
821 
822   // Second read the actual names and convert them into a format we can use
823   NamesData names_table(count, MAX_STR_LENGTH);
824 
825   ex_err = exII::ex_get_var_names(ex_id,
826                                   var_type,
827                                   count,
828                                   names_table\&.get_char_star_star()
829                                   );
830   EX_CHECK_ERR(ex_err, "Error reading variable names!");
831 
832   if (verbose)
833     {
834       libMesh::out << "Read the variable(s) from the file:" << std::endl;
835       for (int i=0; i<count; i++)
836         libMesh::out << names_table\&.get_char_star(i) << std::endl;
837     }
838 
839   // Allocate enough space for our variable name strings\&.
840   result\&.resize(count);
841 
842   // Copy the char buffers into strings\&.
843   for (int i=0; i<count; i++)
844     result[i] = names_table\&.get_char_star(i); // calls string::op=(const char*)
845 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::set_coordinate_offset (\fBPoint\fPp)"
Allows you to set a vector that is added to the coordinates of all of the nodes\&. Effectively, this 'moves' the mesh to a particular position 
.PP
Definition at line 1780 of file exodusII_io_helper\&.C\&.
.PP
References _coordinate_offset\&.
.PP
Referenced by libMesh::ExodusII_IO::set_coordinate_offset()\&.
.PP
.nf
1781 {
1782   _coordinate_offset = p;
1783 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::use_mesh_dimension_instead_of_spatial_dimension (boolval)"
Sets the underlying value of the boolean flag _use_mesh_dimension_instead_of_spatial_dimension\&. By default, the value of this flag is false\&.
.PP
See the \fBExodusII_IO\fP class documentation for a detailed description of this flag\&. 
.PP
Definition at line 1775 of file exodusII_io_helper\&.C\&.
.PP
References _use_mesh_dimension_instead_of_spatial_dimension\&.
.PP
Referenced by libMesh::ExodusII_IO::use_mesh_dimension_instead_of_spatial_dimension()\&.
.PP
.nf
1776 {
1777   _use_mesh_dimension_instead_of_spatial_dimension = val;
1778 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_element_values (const \fBMeshBase\fP &mesh, const std::vector< \fBReal\fP > &values, inttimestep)"
Writes the vector of values to the element variables\&. 
.PP
Definition at line 1612 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, _single_precision, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), data, end, ex_err, ex_id, ex_put_elem_var(), ex_update(), get_block_id(), libMesh::DofObject::id(), num_elem, libMesh::ParallelObject::processor_id(), and libMesh::Elem::subdomain_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data()\&.
.PP
.nf
1613 {
1614   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1615     return;
1616 
1617   // Loop over the element blocks and write the data one block at a time
1618   std::map<unsigned int, std::vector<unsigned int> > subdomain_map;
1619 
1620   const unsigned int num_vars = values\&.size() / num_elem;
1621 
1622   MeshBase::const_element_iterator mesh_it = mesh\&.active_elements_begin();
1623   const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1624 
1625   // loop through element and map between block and element vector
1626   for (; mesh_it!=end; ++mesh_it)
1627     {
1628       const Elem * elem = *mesh_it;
1629       subdomain_map[elem->subdomain_id()]\&.push_back(elem->id());
1630     }
1631 
1632   // For each variable, create a 'data' array which holds all the elemental variable
1633   // values *for a given block* on this processor, then write that data vector to file
1634   // before moving onto the next block\&.
1635   for (unsigned int i=0; i<num_vars; ++i)
1636     {
1637       // The size of the subdomain map is the number of blocks\&.
1638       std::map<unsigned int, std::vector<unsigned int> >::iterator it = subdomain_map\&.begin();
1639 
1640       for (unsigned int j=0; it!=subdomain_map\&.end(); ++it, ++j)
1641         {
1642           const std::vector<unsigned int> & elem_nums = (*it)\&.second;
1643           const unsigned int num_elems_this_block = elem_nums\&.size();
1644           std::vector<Real> data(num_elems_this_block);
1645 
1646           for (unsigned int k=0; k<num_elems_this_block; ++k)
1647             data[k] = values[i*num_elem + elem_nums[k]];
1648 
1649           if(_single_precision)
1650             {
1651               std::vector<float> cast_data(num_elems_this_block);
1652               for (unsigned int l=0; l<num_elems_this_block; ++l)
1653                 {
1654                   cast_data[l] = static_cast<float>(data[l]);
1655                 }
1656               ex_err = exII::ex_put_elem_var(ex_id,
1657                                              timestep,
1658                                              i+1,
1659                                              this->get_block_id(j),
1660                                              num_elems_this_block,
1661                                              &cast_data[0]);
1662             }
1663           else
1664             {
1665               ex_err = exII::ex_put_elem_var(ex_id,
1666                                              timestep,
1667                                              i+1,
1668                                              this->get_block_id(j),
1669                                              num_elems_this_block,
1670                                              &data[0]);
1671             }
1672           EX_CHECK_ERR(ex_err, "Error writing element values\&.");
1673         }
1674     }
1675 
1676   ex_err = exII::ex_update(ex_id);
1677   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1678 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_elements (const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
Writes the elements contained in 'mesh'\&. FIXME: This only works for Meshes having a single type of element! 
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 1191 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), block_ids, connect, libMesh::MeshBase::elem(), elem_num_map, end, libMesh::Utility::enum_to_string(), libMesh::err, EX_ELEM_BLOCK, ex_err, ex_id, ex_put_elem_block(), ex_put_elem_conn(), ex_put_elem_num_map(), ex_put_names(), libMesh::ExodusII_IO_Helper::Conversion::exodus_elem_type(), libMesh::ExodusII_IO_Helper::Conversion::get_canonical_type(), libMesh::ExodusII_IO_Helper::NamesData::get_char_star_star(), libMesh::ExodusII_IO_Helper::Conversion::get_inverse_node_map(), libMesh::DofObject::id(), libmesh_elem_num_to_exodus, libMesh::MeshBase::n_active_elem(), libMesh::Elem::n_nodes(), libMesh::Elem::node(), num_elem_blk, num_nodes_per_elem, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::ExodusII_IO_Helper::NamesData::push_back_entry(), libMesh::Elem::subdomain_id(), libMesh::MeshBase::subdomain_name(), libMesh::Elem::type(), and verbose\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1192 {
1193   // n_active_elem() is a parallel_only function
1194   unsigned int n_active_elem = mesh\&.n_active_elem();
1195 
1196   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1197     return;
1198 
1199   // Map from block ID to a vector of element IDs in that block\&.  Element
1200   // IDs are now of type dof_id_type, subdomain IDs are of type subdomain_id_type\&.
1201   typedef std::map<subdomain_id_type, std::vector<dof_id_type> > subdomain_map_type;
1202   subdomain_map_type subdomain_map;
1203 
1204   MeshBase::const_element_iterator mesh_it = mesh\&.active_elements_begin();
1205   const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1206   //loop through element and map between block and element vector
1207   for (; mesh_it!=end; ++mesh_it)
1208     {
1209       const Elem * elem = *mesh_it;
1210       subdomain_map[ elem->subdomain_id() ]\&.push_back(elem->id());
1211     }
1212 
1213   // element map vector
1214   num_elem_blk = subdomain_map\&.size();
1215   block_ids\&.resize(num_elem_blk);
1216   elem_num_map\&.resize(n_active_elem);
1217   std::vector<int>::iterator curr_elem_map_end = elem_num_map\&.begin();
1218 
1219   // Note: It appears that there is a bug in exodusII::ex_put_name where
1220   // the index returned from the ex_id_lkup is erronously used\&.  For now
1221   // the work around is to use the alternative function ex_put_names, but
1222   // this function requires a char** datastructure\&.
1223   NamesData names_table(num_elem_blk, MAX_STR_LENGTH);
1224 
1225   // This counter is used to fill up the libmesh_elem_num_to_exodus map in the loop below\&.
1226   unsigned libmesh_elem_num_to_exodus_counter = 0;
1227 
1228   // counter indexes into the block_ids vector
1229   unsigned int counter = 0;
1230 
1231   // node counter for discontinuous plotting
1232   unsigned int node_counter = 0;
1233 
1234   for (subdomain_map_type::iterator it=subdomain_map\&.begin(); it!=subdomain_map\&.end(); ++it)
1235     {
1236       block_ids[counter] = (*it)\&.first;
1237       names_table\&.push_back_entry(mesh\&.subdomain_name((*it)\&.first));
1238 
1239       // Get a reference to a vector of element IDs for this subdomain\&.
1240       subdomain_map_type::mapped_type& tmp_vec = (*it)\&.second;
1241 
1242       ExodusII_IO_Helper::ElementMaps em;
1243 
1244       //Use the first element in this block to get representative information\&.
1245       //Note that Exodus assumes all elements in a block are of the same type!
1246       //We are using that same assumption here!
1247       const ExodusII_IO_Helper::Conversion conv = em\&.assign_conversion(mesh\&.elem(tmp_vec[0])->type());
1248       num_nodes_per_elem = mesh\&.elem(tmp_vec[0])->n_nodes();
1249 
1250       ex_err = exII::ex_put_elem_block(ex_id,
1251                                        (*it)\&.first,
1252                                        conv\&.exodus_elem_type()\&.c_str(),
1253                                        tmp_vec\&.size(),
1254                                        num_nodes_per_elem,
1255                                        /*num_attr=*/0);
1256 
1257       EX_CHECK_ERR(ex_err, "Error writing element block\&.");
1258 
1259       connect\&.resize(tmp_vec\&.size()*num_nodes_per_elem);
1260 
1261       for (unsigned int i=0; i<tmp_vec\&.size(); i++)
1262         {
1263           unsigned int elem_id = tmp_vec[i];
1264           libmesh_elem_num_to_exodus[elem_id] = ++libmesh_elem_num_to_exodus_counter; // 1-based indexing for Exodus
1265 
1266           const Elem* elem = mesh\&.elem(elem_id);
1267 
1268           // We *might* be able to get away with writing mixed element
1269           // types which happen to have the same number of nodes, but
1270           // do we actually *want* to get away with that?
1271           // \&.) No visualization software would be able to handle it\&.
1272           // \&.) There'd be no way for us to read it back in reliably\&.
1273           // \&.) Even elements with the same number of nodes may have different connectivities (?)
1274 
1275           // This needs to be more than an assert so we don't fail
1276           // with a mysterious segfault while trying to write mixed
1277           // element meshes in optimized mode\&.
1278           if (elem->type() != conv\&.get_canonical_type())
1279             {
1280               libMesh::err << "Error: Exodus requires all elements with a given subdomain ID to be the same type\&.\n"
1281                            << "Can't write both "
1282                            << Utility::enum_to_string(elem->type())
1283                            << " and "
1284                            << Utility::enum_to_string(conv\&.get_canonical_type())
1285                            << " in the same block!"
1286                            << std::endl;
1287               libmesh_error();
1288             }
1289 
1290 
1291           for (unsigned int j=0; j<static_cast<unsigned int>(num_nodes_per_elem); ++j)
1292             {
1293               unsigned connect_index   = (i*num_nodes_per_elem)+j;
1294               unsigned elem_node_index = conv\&.get_inverse_node_map(j); // inverse node map is for writing\&.
1295               if (verbose)
1296                 {
1297                   libMesh::out << "Exodus node index: " << j
1298                                << "=LibMesh node index " << elem_node_index << std::endl;
1299                 }
1300 
1301               // FIXME: We are hard-coding the 1-based node numbering assumption here\&.
1302               if(!use_discontinuous)
1303               {
1304                 connect[connect_index] = elem->node(elem_node_index)+1;
1305               }
1306               else
1307               {
1308                 connect[connect_index] = node_counter*num_nodes_per_elem+elem_node_index+1;
1309               }
1310             }
1311 
1312           node_counter++;
1313         }
1314 
1315       ex_err = exII::ex_put_elem_conn(ex_id, (*it)\&.first, &connect[0]);
1316       EX_CHECK_ERR(ex_err, "Error writing element connectivities");
1317 
1318       // This transform command stores its result in a range that begins at the third argument,
1319       // so this command is adding values to the elem_num_map vector starting from curr_elem_map_end\&.
1320       curr_elem_map_end = std::transform(tmp_vec\&.begin(),
1321                                          tmp_vec\&.end(),
1322                                          curr_elem_map_end,
1323                                          std::bind2nd(std::plus<subdomain_map_type::mapped_type::value_type>(), 1));  // Adds one to each id to make a 1-based exodus file!
1324 
1325       // But if we don't want to add one, we just want to put the values
1326       // of tmp_vec into elem_map in the right location, we can use
1327       // std::copy()\&.
1328       // curr_elem_map_end = std::copy(tmp_vec\&.begin(), tmp_vec\&.end(), curr_elem_map_end);
1329 
1330       counter++;
1331     }
1332 
1333   // write out the element number map that we created
1334   ex_err = exII::ex_put_elem_num_map(ex_id, &elem_num_map[0]);
1335   EX_CHECK_ERR(ex_err, "Error writing element map");
1336 
1337   // Write out the block names
1338   if (num_elem_blk > 0)
1339     {
1340       ex_err = exII::ex_put_names(ex_id, exII::EX_ELEM_BLOCK, names_table\&.get_char_star_star());
1341       EX_CHECK_ERR(ex_err, "Error writing element names");
1342     }
1343 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_global_values (const std::vector< \fBReal\fP > &values, inttimestep)"
Writes the vector of global variables\&. 
.PP
Definition at line 1748 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, _single_precision, ex_err, ex_id, ex_put_glob_vars(), ex_update(), num_global_vars, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_global_data(), and libMesh::ExodusII_IO::write_global_data()\&.
.PP
.nf
1749 {
1750   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1751     return;
1752 
1753   if(_single_precision)
1754     {
1755       unsigned int num_values = values\&.size();
1756       std::vector<float> cast_values(num_values);
1757 
1758       for (unsigned int i=0; i<num_values; ++i)
1759         cast_values[i] = static_cast<float>(values[i]);
1760 
1761       ex_err = exII::ex_put_glob_vars(ex_id, timestep, num_global_vars, &cast_values[0]);
1762     }
1763   else
1764     {
1765       ex_err = exII::ex_put_glob_vars(ex_id, timestep, num_global_vars, &values[0]);
1766     }
1767   EX_CHECK_ERR(ex_err, "Error writing global values\&.");
1768 
1769   ex_err = exII::ex_update(ex_id);
1770   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1771 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_information_records (const std::vector< std::string > &records)"
Writes the vector of information records\&. 
.PP
Definition at line 1709 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, libMesh::err, ex_err, ex_id, EX_INQ_INFO, ex_put_info(), ex_update(), libMesh::ExodusII_IO_Helper::NamesData::get_char_star_star(), inquire(), libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::NamesData::push_back_entry()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_information_records(), and libMesh::ExodusII_IO::write_information_records()\&.
.PP
.nf
1710 {
1711   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1712     return;
1713 
1714   // There may already be information records in the file (for
1715   // example, if we're appending) and in that case, according to the
1716   // Exodus documentation, writing more information records is not
1717   // supported\&.
1718   int num_info = inquire(exII::EX_INQ_INFO, "Error retrieving the number of information records from file!");
1719   if (num_info > 0)
1720     {
1721       libMesh::err << "Warning! The Exodus file already contains information records\&.\n"
1722                    << "Exodus does not support writing additional records in this situation\&."
1723                    << std::endl;
1724       return;
1725     }
1726 
1727   int num_records = records\&.size();
1728 
1729   if (num_records > 0)
1730     {
1731       NamesData info(num_records, MAX_LINE_LENGTH);
1732 
1733       // If an entry is longer than MAX_LINE_LENGTH characters it's not an error, we just
1734       // write the first MAX_LINE_LENGTH characters to the file\&.
1735       for (unsigned i=0; i<records\&.size(); ++i)
1736         info\&.push_back_entry(records[i]);
1737 
1738       ex_err = exII::ex_put_info(ex_id, num_records, info\&.get_char_star_star());
1739       EX_CHECK_ERR(ex_err, "Error writing global values\&.");
1740 
1741       ex_err = exII::ex_update(ex_id);
1742       EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1743     }
1744 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_nodal_coordinates (const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
Writes the nodal coordinates contained in 'mesh' 
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 1081 of file exodusII_io_helper\&.C\&.
.PP
References _coordinate_offset, _run_only_on_proc0, _single_precision, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), end, ex_err, ex_id, ex_put_coord(), ex_put_node_num_map(), libMesh::DofObject::id(), node_num_map, libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), num_nodes, libMesh::ParallelObject::processor_id(), x, y, and z\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1082 {
1083   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1084     return;
1085 
1086   // Make room in the coordinate vectors
1087   x\&.resize(num_nodes);
1088   y\&.resize(num_nodes);
1089   z\&.resize(num_nodes);
1090 
1091   // And in the node_num_map - since the nodes aren't organized in
1092   // blocks, libmesh will always write out the identity map
1093   // here\&.\&.\&. unless there has been some refinement and coarsening\&. If
1094   // the nodes aren't renumbered after refinement and coarsening,
1095   // there may be 'holes' in the numbering, so we write out the node
1096   // map just to be on the safe side\&.
1097   node_num_map\&.resize(num_nodes);
1098 
1099   if(!use_discontinuous)
1100   {
1101     MeshBase::const_node_iterator it = mesh\&.nodes_begin();
1102     const MeshBase::const_node_iterator end = mesh\&.nodes_end();
1103     for (unsigned i = 0; it != end; ++it, ++i)
1104       {
1105         const Node* node = *it;
1106 
1107         x[i] = (*node)(0) + _coordinate_offset(0);
1108 
1109 #if LIBMESH_DIM > 1
1110         y[i]=(*node)(1) + _coordinate_offset(1);
1111 #else
1112         y[i]=0\&.;
1113 #endif
1114 #if LIBMESH_DIM > 2
1115         z[i]=(*node)(2) + _coordinate_offset(2);
1116 #else
1117         z[i]=0\&.;
1118 #endif
1119 
1120         // Fill in node_num_map entry with the proper (1-based) node id
1121         node_num_map[i] = node->id() + 1;
1122       }
1123   }
1124   else
1125   {
1126     MeshBase::const_element_iterator       it  = mesh\&.active_elements_begin();
1127     const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1128 
1129     unsigned int i = 0;
1130     for (; it!=end; ++it)
1131       for (unsigned int n=0; n<(*it)->n_nodes(); n++)
1132         {
1133           x[i]=(*it)->point(n)(0);
1134 #if LIBMESH_DIM > 1
1135           y[i]=(*it)->point(n)(1);
1136 #else
1137           y[i]=0\&.;
1138 #endif
1139 #if LIBMESH_DIM > 2
1140           z[i]=(*it)->point(n)(2);
1141 #else
1142           z[i]=0\&.;
1143 #endif
1144 
1145           // Let's skip the node_num_map in the discontinuous case,
1146           // since we're effectively duplicating nodes for the
1147           // sake of discontinuous visualization, so it isn't clear
1148           // how to deal with node_num_map here\&. It's only optional
1149           // anyway, so no big deal\&.
1150 
1151           i++;
1152       }
1153   }
1154 
1155   if(_single_precision)
1156     {
1157       std::vector<float> x_single(num_nodes), y_single(num_nodes), z_single(num_nodes);
1158       for (int i=0; i<num_nodes; ++i)
1159         {
1160           x_single[i] = static_cast<float>(x[i]);
1161           y_single[i] = static_cast<float>(y[i]);
1162           z_single[i] = static_cast<float>(z[i]);
1163         }
1164 
1165       ex_err = exII::ex_put_coord(ex_id,
1166                                   x_single\&.empty() ? NULL : &x_single[0],
1167                                   y_single\&.empty() ? NULL : &y_single[0],
1168                                   z_single\&.empty() ? NULL : &z_single[0]);
1169     }
1170   else
1171     {
1172       ex_err = exII::ex_put_coord(ex_id,
1173                                   x\&.empty() ? NULL : &x[0],
1174                                   y\&.empty() ? NULL : &y[0],
1175                                   z\&.empty() ? NULL : &z[0]);
1176     }
1177 
1178 
1179   EX_CHECK_ERR(ex_err, "Error writing coordinates to Exodus file\&.");
1180 
1181   if(!use_discontinuous)
1182   {
1183     // Also write the (1-based) node_num_map to the file\&.
1184     ex_err = exII::ex_put_node_num_map(ex_id, &node_num_map[0]);
1185     EX_CHECK_ERR(ex_err, "Error writing node_num_map");
1186   }
1187 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_nodal_values (intvar_id, const std::vector< \fBReal\fP > &values, inttimestep)"
Writes the vector of values to a nodal variable\&. 
.PP
Definition at line 1682 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, _single_precision, ex_err, ex_id, ex_put_nodal_var(), ex_update(), num_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.PP
.nf
1683 {
1684   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1685     return;
1686 
1687   if(_single_precision)
1688     {
1689       unsigned int num_values = values\&.size();
1690       std::vector<float> cast_values(num_values);
1691       for (unsigned int i=0; i<num_values; ++i)
1692         {
1693           cast_values[i] = static_cast<float>(values[i]);
1694         }
1695       ex_err = exII::ex_put_nodal_var(ex_id, timestep, var_id, num_nodes, &cast_values[0]);
1696     }
1697   else
1698     {
1699       ex_err = exII::ex_put_nodal_var(ex_id, timestep, var_id, num_nodes, &values[0]);
1700     }
1701   EX_CHECK_ERR(ex_err, "Error writing nodal values\&.");
1702 
1703   ex_err = exII::ex_update(ex_id);
1704   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1705 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_nodesets (const \fBMeshBase\fP &mesh)\fC [virtual]\fP"
Writes the nodesets contained in 'mesh' 
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 1420 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, libMesh::MeshBase::boundary_info, ex_err, ex_id, EX_NODE_SET, ex_put_names(), ex_put_node_set(), ex_put_node_set_param(), libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::NamesData::push_back_entry()\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1421 {
1422   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1423     return;
1424 
1425   std::vector< dof_id_type > nl;
1426   std::vector< boundary_id_type > il;
1427 
1428   mesh\&.boundary_info->build_node_list(nl, il);
1429 
1430   // Maps from nodeset id to the nodes
1431   std::map<boundary_id_type, std::vector<int> > node;
1432 
1433   // Accumulate the vectors to pass into ex_put_node_set
1434   for (unsigned int i=0; i<nl\&.size(); i++)
1435     node[il[i]]\&.push_back(nl[i]+1);
1436 
1437   std::vector<boundary_id_type> node_boundary_ids;
1438   mesh\&.boundary_info->build_node_boundary_ids(node_boundary_ids);
1439 
1440   // Write out the nodeset names, but only if there is something to write
1441   if (node_boundary_ids\&.size() > 0)
1442     {
1443       NamesData names_table(node_boundary_ids\&.size(), MAX_STR_LENGTH);
1444 
1445       for (unsigned int i=0; i<node_boundary_ids\&.size(); i++)
1446         {
1447           int nodeset_id = node_boundary_ids[i];
1448 
1449           int actual_id = nodeset_id;
1450 
1451           names_table\&.push_back_entry(mesh\&.boundary_info->nodeset_name(nodeset_id));
1452 
1453           ex_err = exII::ex_put_node_set_param(ex_id, actual_id, node[nodeset_id]\&.size(), 0);
1454           EX_CHECK_ERR(ex_err, "Error writing nodeset parameters");
1455 
1456           ex_err = exII::ex_put_node_set(ex_id, actual_id, &node[nodeset_id][0]);
1457           EX_CHECK_ERR(ex_err, "Error writing nodesets");
1458         }
1459 
1460       // Write out the nodeset names
1461       ex_err = exII::ex_put_names(ex_id, exII::EX_NODE_SET, names_table\&.get_char_star_star());
1462       EX_CHECK_ERR(ex_err, "Error writing nodeset names");
1463     }
1464 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_sidesets (const \fBMeshBase\fP &mesh)\fC [virtual]\fP"
Writes the sidesets contained in 'mesh' We need to build up active elements if AMR is enabled and add them to the exodus sidesets instead of the potentially inactive 'parent' elements
.PP
Reimplemented in \fBlibMesh::Nemesis_IO_Helper\fP\&.
.PP
Definition at line 1348 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, libMesh::Elem::active_family_tree_by_side(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), libMesh::MeshBase::boundary_info, libMesh::MeshBase::elem(), ex_err, ex_id, ex_put_names(), ex_put_side_set(), ex_put_side_set_param(), EX_SIDE_SET, libMesh::ExodusII_IO_Helper::Conversion::get_inverse_side_map(), libmesh_elem_num_to_exodus, libMesh::ParallelObject::processor_id(), libMesh::ExodusII_IO_Helper::NamesData::push_back_entry(), and side\&.
.PP
Referenced by libMesh::ExodusII_IO::write(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1349 {
1350   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1351     return;
1352 
1353   ExodusII_IO_Helper::ElementMaps em;
1354 
1355   std::vector< dof_id_type > el;
1356   std::vector< unsigned short int > sl;
1357   std::vector< boundary_id_type > il;
1358 
1359   mesh\&.boundary_info->build_side_list(el, sl, il);
1360 
1361   // Maps from sideset id to the element and sides
1362   std::map<int, std::vector<int> > elem;
1363   std::map<int, std::vector<int> > side;
1364 
1365   // Accumulate the vectors to pass into ex_put_side_set
1366   for (unsigned int i=0; i<el\&.size(); i++)
1367     {
1368       std::vector<const Elem *> family;
1369 #ifdef LIBMESH_ENABLE_AMR
1370 
1374       mesh\&.elem(el[i])->active_family_tree_by_side(family, sl[i], false);
1375 #else
1376       family\&.push_back(mesh\&.elem(el[i]));
1377 #endif
1378 
1379       for (unsigned int j=0; j<family\&.size(); ++j)
1380         {
1381           const ExodusII_IO_Helper::Conversion conv = em\&.assign_conversion(mesh\&.elem(family[j]->id())->type());
1382 
1383           // Use the libmesh to exodus datastructure map to get the proper sideset IDs
1384           // The datastructure contains the "collapsed" contiguous ids
1385           elem[il[i]]\&.push_back(libmesh_elem_num_to_exodus[family[j]->id()]);
1386           side[il[i]]\&.push_back(conv\&.get_inverse_side_map(sl[i]));
1387         }
1388     }
1389 
1390   std::vector<boundary_id_type> side_boundary_ids;
1391   mesh\&.boundary_info->build_side_boundary_ids(side_boundary_ids);
1392 
1393   // Write out the sideset names, but only if there is something to write
1394   if (side_boundary_ids\&.size() > 0)
1395     {
1396       NamesData names_table(side_boundary_ids\&.size(), MAX_STR_LENGTH);
1397 
1398       for (unsigned int i=0; i<side_boundary_ids\&.size(); i++)
1399         {
1400           int ss_id = side_boundary_ids[i];
1401 
1402           int actual_id = ss_id;
1403 
1404           names_table\&.push_back_entry(mesh\&.boundary_info->sideset_name(ss_id));
1405 
1406           ex_err = exII::ex_put_side_set_param(ex_id, actual_id, elem[ss_id]\&.size(), 0);
1407           EX_CHECK_ERR(ex_err, "Error writing sideset parameters");
1408 
1409           ex_err = exII::ex_put_side_set(ex_id, actual_id, &elem[ss_id][0], &side[ss_id][0]);
1410           EX_CHECK_ERR(ex_err, "Error writing sidesets");
1411         }
1412 
1413       ex_err = exII::ex_put_names(ex_id, exII::EX_SIDE_SET, names_table\&.get_char_star_star());
1414       EX_CHECK_ERR(ex_err, "Error writing sideset names");
1415     }
1416 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_timestep (inttimestep, \fBReal\fPtime)"
Writes the time for the timestep 
.PP
Definition at line 1598 of file exodusII_io_helper\&.C\&.
.PP
References _run_only_on_proc0, ex_err, ex_id, ex_put_time(), ex_update(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_timestep(), and libMesh::ExodusII_IO::write_timestep()\&.
.PP
.nf
1599 {
1600   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1601     return;
1602 
1603   ex_err = exII::ex_put_time(ex_id, timestep, &time);
1604   EX_CHECK_ERR(ex_err, "Error writing timestep\&.");
1605 
1606   ex_err = exII::ex_update(ex_id);
1607   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1608 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_var_names (\fBExodusVarType\fPtype, std::vector< std::string > &names)\fC [private]\fP"
Wraps calls to exII::ex_put_var_names() and exII::ex_put_var_param()\&. The enumeration controls whether nodal, elemental, or global variable names are read and which class members are filled in\&. 
.PP
Definition at line 850 of file exodusII_io_helper\&.C\&.
.PP
References ELEMENTAL, libMesh::err, GLOBAL, NODAL, num_elem_vars, num_global_vars, num_nodal_vars, and write_var_names_impl()\&.
.PP
Referenced by initialize_element_variables(), initialize_global_variables(), and initialize_nodal_variables()\&.
.PP
.nf
851 {
852   switch (type)
853     {
854     case NODAL:
855       this->write_var_names_impl("n", num_nodal_vars, names);
856       break;
857     case ELEMENTAL:
858       this->write_var_names_impl("e", num_elem_vars, names);
859       break;
860     case GLOBAL:
861       this->write_var_names_impl("g", num_global_vars, names);
862       break;
863     default:
864       libMesh::err << "Unrecognized ExodusVarType " << type << std::endl;
865       libmesh_error();
866     }
867 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_var_names_impl (const char *var_type, int &count, std::vector< std::string > &names)\fC [private]\fP"
\fBwrite_var_names()\fP dispatches to this function\&. 
.PP
Definition at line 871 of file exodusII_io_helper\&.C\&.
.PP
References ex_err, ex_id, ex_put_var_names(), ex_put_var_param(), libMesh::out, libMesh::ExodusII_IO_Helper::NamesData::push_back_entry(), and verbose\&.
.PP
Referenced by write_var_names()\&.
.PP
.nf
872 {
873   // Update the count variable so that it's available to other parts of the class\&.
874   count = names\&.size();
875 
876   // Write that number of variables to the file\&.
877   ex_err = exII::ex_put_var_param(ex_id, var_type, count);
878   EX_CHECK_ERR(ex_err, "Error setting number of vars\&.");
879 
880   if (names\&.size() > 0)
881     {
882       NamesData names_table(names\&.size(), MAX_STR_LENGTH);
883 
884       // Store the input names in the format required by Exodus\&.
885       for (unsigned i=0; i<names\&.size(); ++i)
886         names_table\&.push_back_entry(names[i]);
887 
888       if (verbose)
889         {
890           libMesh::out << "Writing variable name(s) to file: " << std::endl;
891           for (unsigned i=0; i<names\&.size(); ++i)
892             libMesh::out << names_table\&.get_char_star(i) << std::endl;
893         }
894 
895       ex_err = exII::ex_put_var_names(ex_id,
896                                       var_type,
897                                       names\&.size(),
898                                       names_table\&.get_char_star_star()
899                                       );
900 
901       EX_CHECK_ERR(ex_err, "Error writing variable names\&.");
902     }
903 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBPoint\fP libMesh::ExodusII_IO_Helper::_coordinate_offset\fC [protected]\fP"

.PP
Definition at line 545 of file exodusII_io_helper\&.h\&.
.PP
Referenced by set_coordinate_offset(), and write_nodal_coordinates()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_elem_vars_initialized\fC [protected]\fP"

.PP
Definition at line 531 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_element_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_global_vars_initialized\fC [protected]\fP"

.PP
Definition at line 534 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_global_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_nodal_vars_initialized\fC [protected]\fP"

.PP
Definition at line 537 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_nodal_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_run_only_on_proc0\fC [protected]\fP"

.PP
Definition at line 528 of file exodusII_io_helper\&.h\&.
.PP
Referenced by close(), create(), initialize(), initialize_element_variables(), initialize_global_variables(), initialize_nodal_variables(), write_element_values(), write_elements(), write_global_values(), write_information_records(), write_nodal_coordinates(), write_nodal_values(), write_nodesets(), write_sidesets(), and write_timestep()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_single_precision\fC [protected]\fP"

.PP
Definition at line 548 of file exodusII_io_helper\&.h\&.
.PP
Referenced by create(), libMesh::Nemesis_IO_Helper::create(), write_element_values(), write_global_values(), write_nodal_coordinates(), libMesh::Nemesis_IO_Helper::write_nodal_coordinates(), and write_nodal_values()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_use_mesh_dimension_instead_of_spatial_dimension\fC [protected]\fP"

.PP
Definition at line 542 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), and use_mesh_dimension_instead_of_spatial_dimension()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::block_ids"

.PP
Definition at line 407 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), get_block_id(), get_block_name(), libMesh::Nemesis_IO::read(), read_block_info(), read_elem_in_block(), read_elemental_var_values(), and write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::connect"

.PP
Definition at line 410 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_elem_in_block(), and write_elements()\&.
.SS "std::string libMesh::ExodusII_IO_Helper::current_filename"

.PP
Definition at line 524 of file exodusII_io_helper\&.h\&.
.PP
Referenced by create(), open(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::elem_list"

.PP
Definition at line 431 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_sideset(), and read_sideset_info()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::elem_num_map"

.PP
Definition at line 446 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::read(), read_elem_num_map(), and write_elements()\&.
.SS "std::vector<char> libMesh::ExodusII_IO_Helper::elem_type"

.PP
Definition at line 461 of file exodusII_io_helper\&.h\&.
.PP
Referenced by ExodusII_IO_Helper(), get_elem_type(), libMesh::Nemesis_IO::read(), and read_elem_in_block()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::elem_var_names"

.PP
Definition at line 492 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_element_variables(), read_elemental_var_values(), and read_var_names()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::elem_var_values"

.PP
Definition at line 495 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution(), and read_elemental_var_values()\&.
.SS "int libMesh::ExodusII_IO_Helper::ex_err"

.PP
Definition at line 371 of file exodusII_io_helper\&.h\&.
.PP
Referenced by close(), initialize(), initialize_element_variables(), inquire(), read_block_info(), read_elem_in_block(), read_elem_num_map(), read_elemental_var_values(), read_header(), read_nodal_var_values(), read_node_num_map(), read_nodes(), read_nodeset(), read_nodeset_info(), read_sideset(), read_sideset_info(), read_time_steps(), read_var_names_impl(), libMesh::Nemesis_IO::write(), write_element_values(), write_elements(), libMesh::Nemesis_IO_Helper::write_elements(), libMesh::Nemesis_IO_Helper::write_exodus_initialization_info(), write_global_values(), write_information_records(), write_nodal_coordinates(), libMesh::Nemesis_IO_Helper::write_nodal_coordinates(), write_nodal_values(), write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), write_timestep(), write_var_names_impl(), and libMesh::Nemesis_IO_Helper::~Nemesis_IO_Helper()\&.
.SS "int libMesh::ExodusII_IO_Helper::ex_id"

.PP
Definition at line 368 of file exodusII_io_helper\&.h\&.
.PP
Referenced by close(), create(), libMesh::Nemesis_IO_Helper::create(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), initialize(), initialize_element_variables(), inquire(), open(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_eb_info_global(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_init_global(), libMesh::Nemesis_IO_Helper::put_init_info(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_n_coord(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO_Helper::put_ns_param_global(), libMesh::Nemesis_IO_Helper::put_ss_param_global(), read_block_info(), read_elem_in_block(), read_elem_num_map(), read_elemental_var_values(), read_header(), read_nodal_var_values(), read_node_num_map(), read_nodes(), read_nodeset(), read_nodeset_info(), read_sideset(), read_sideset_info(), read_time_steps(), read_var_names_impl(), libMesh::Nemesis_IO::write(), write_element_values(), write_elements(), libMesh::Nemesis_IO_Helper::write_elements(), libMesh::Nemesis_IO_Helper::write_exodus_initialization_info(), write_global_values(), write_information_records(), write_nodal_coordinates(), libMesh::Nemesis_IO_Helper::write_nodal_coordinates(), write_nodal_values(), write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), write_timestep(), write_var_names_impl(), and libMesh::Nemesis_IO_Helper::~Nemesis_IO_Helper()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::exodus_elem_num_to_libmesh"

.PP
Definition at line 466 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), and libMesh::Nemesis_IO_Helper::write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::exodus_node_num_to_libmesh"

.PP
Definition at line 471 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), and libMesh::Nemesis_IO_Helper::write_nodal_coordinates()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::global_var_names"

.PP
Definition at line 498 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_global_variables(), and read_var_names()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::id_list"

.PP
Definition at line 440 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_sideset(), and read_sideset_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_block_names"

.PP
Definition at line 501 of file exodusII_io_helper\&.h\&.
.PP
Referenced by get_block_name(), and read_block_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_ns_names"

.PP
Definition at line 503 of file exodusII_io_helper\&.h\&.
.PP
Referenced by get_node_set_name(), and read_nodeset_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_ss_names"

.PP
Definition at line 502 of file exodusII_io_helper\&.h\&.
.PP
Referenced by get_side_set_name(), and read_sideset_info()\&.
.SS "std::map<int, int> libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus"

.PP
Definition at line 465 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::Nemesis_IO_Helper::compute_elem_communication_maps(), libMesh::Nemesis_IO_Helper::compute_element_maps(), write_elements(), write_sidesets(), and libMesh::Nemesis_IO_Helper::write_sidesets()\&.
.SS "std::map<int, int> libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus"

.PP
Definition at line 470 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_node_maps(), and libMesh::Nemesis_IO_Helper::write_nodesets()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::nodal_var_names"

.PP
Definition at line 483 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_nodal_variables(), read_nodal_var_values(), and read_var_names()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::nodal_var_values"

.PP
Definition at line 486 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_nodal_solution(), and read_nodal_var_values()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::node_list"

.PP
Definition at line 437 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and read_nodeset()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::node_num_map"

.PP
Definition at line 443 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_node_num_map(), and write_nodal_coordinates()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::nodeset_ids"

.PP
Definition at line 416 of file exodusII_io_helper\&.h\&.
.PP
Referenced by get_node_set_id(), get_node_set_name(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_nodeset(), and read_nodeset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_attr"

.PP
Definition at line 401 of file exodusII_io_helper\&.h\&.
.PP
Referenced by read_elem_in_block()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_df_per_set"

.PP
Definition at line 425 of file exodusII_io_helper\&.h\&.
.PP
Referenced by read_sideset(), and read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_dim"

.PP
Definition at line 374 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), print_header(), read_header(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem"

.PP
Definition at line 383 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_elem_num_map(), read_elemental_var_values(), read_header(), write_element_values(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_all_sidesets"

.PP
Definition at line 404 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_blk"

.PP
Definition at line 386 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), initialize_element_variables(), print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_block_info(), read_elemental_var_values(), read_header(), write_elements(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_this_blk"

.PP
Definition at line 395 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and read_elem_in_block()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_vars"

.PP
Definition at line 489 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_element_variables(), read_header(), read_var_names(), and write_var_names()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_global_vars"

.PP
Definition at line 377 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_global_variables(), read_header(), read_var_names(), write_global_values(), and write_var_names()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodal_vars"

.PP
Definition at line 480 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize_nodal_variables(), read_header(), read_var_names(), and write_var_names()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_node_df_per_set"

.PP
Definition at line 428 of file exodusII_io_helper\&.h\&.
.PP
Referenced by read_nodeset(), and read_nodeset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_node_sets"

.PP
Definition at line 389 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_header(), read_nodeset_info(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodes"

.PP
Definition at line 380 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), initialize(), print_header(), print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_header(), read_nodal_var_values(), read_node_num_map(), read_nodes(), libMesh::Nemesis_IO_Helper::write_exodus_initialization_info(), write_nodal_coordinates(), and write_nodal_values()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodes_per_elem"

.PP
Definition at line 398 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_elem_in_block(), write_elements(), and libMesh::Nemesis_IO_Helper::write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_nodes_per_set"

.PP
Definition at line 422 of file exodusII_io_helper\&.h\&.
.PP
Referenced by read_nodeset(), and read_nodeset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_side_sets"

.PP
Definition at line 392 of file exodusII_io_helper\&.h\&.
.PP
Referenced by initialize(), print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_header(), read_sideset_info(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_sides_per_set"

.PP
Definition at line 419 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_sideset(), and read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_time_steps"

.PP
Definition at line 474 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::get_num_time_steps(), read_num_time_steps(), and read_time_steps()\&.
.SS "bool libMesh::ExodusII_IO_Helper::opened_for_reading"

.PP
Definition at line 514 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::ExodusII_IO::get_num_time_steps(), libMesh::ExodusII_IO::get_time_steps(), and open()\&.
.SS "bool libMesh::ExodusII_IO_Helper::opened_for_writing"

.PP
Definition at line 510 of file exodusII_io_helper\&.h\&.
.PP
Referenced by create(), libMesh::Nemesis_IO_Helper::create(), libMesh::ExodusII_IO::get_num_time_steps(), open(), libMesh::ExodusII_IO::write(), libMesh::ExodusII_IO::write_element_data(), libMesh::Nemesis_IO::write_global_data(), libMesh::ExodusII_IO::write_global_data(), libMesh::Nemesis_IO::write_information_records(), libMesh::ExodusII_IO::write_information_records(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::side_list"

.PP
Definition at line 434 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_sideset(), and read_sideset_info()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::ss_ids"

.PP
Definition at line 413 of file exodusII_io_helper\&.h\&.
.PP
Referenced by get_side_set_id(), get_side_set_name(), read_sideset(), and read_sideset_info()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::time_steps"

.PP
Definition at line 477 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::get_time_steps(), and read_time_steps()\&.
.SS "std::vector<char> libMesh::ExodusII_IO_Helper::title"

.PP
Definition at line 458 of file exodusII_io_helper\&.h\&.
.PP
Referenced by ExodusII_IO_Helper(), print_header(), and read_header()\&.
.SS "bool libMesh::ExodusII_IO_Helper::verbose"

.PP
Definition at line 506 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), create(), libMesh::Nemesis_IO_Helper::create(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), message(), open(), print_header(), libMesh::Nemesis_IO_Helper::put_node_cmap(), read_elem_in_block(), read_elem_num_map(), read_node_num_map(), read_var_names_impl(), libMesh::ExodusII_IO::verbose(), libMesh::Nemesis_IO::verbose(), write_elements(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), and write_var_names_impl()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::x"

.PP
Definition at line 449 of file exodusII_io_helper\&.h\&.
.PP
Referenced by print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_nodes(), write_nodal_coordinates(), and libMesh::Nemesis_IO_Helper::write_nodal_coordinates()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::y"

.PP
Definition at line 452 of file exodusII_io_helper\&.h\&.
.PP
Referenced by print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_nodes(), write_nodal_coordinates(), and libMesh::Nemesis_IO_Helper::write_nodal_coordinates()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::z"

.PP
Definition at line 455 of file exodusII_io_helper\&.h\&.
.PP
Referenced by print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), read_nodes(), write_nodal_coordinates(), and libMesh::Nemesis_IO_Helper::write_nodal_coordinates()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
