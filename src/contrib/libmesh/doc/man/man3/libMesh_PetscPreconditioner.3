.TH "libMesh::PetscPreconditioner< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::PetscPreconditioner< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <petsc_preconditioner\&.h>\fP
.PP
Inherits \fBlibMesh::Preconditioner< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPetscPreconditioner\fP (const \fBlibMesh::Parallel::Communicator\fP &\fBcomm\fP LIBMESH_CAN_DEFAULT_TO_COMMWORLD)"
.br
.ti -1c
.RI "virtual \fB~PetscPreconditioner\fP ()"
.br
.ti -1c
.RI "virtual void \fBapply\fP (const \fBNumericVector\fP< T > &\fBx\fP, \fBNumericVector\fP< T > &y)"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit\fP ()"
.br
.ti -1c
.RI "\fBPC\fP \fBpc\fP ()"
.br
.ti -1c
.RI "bool \fBinitialized\fP () const "
.br
.ti -1c
.RI "virtual void \fBsetup\fP ()"
.br
.ti -1c
.RI "void \fBset_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > &mat)"
.br
.ti -1c
.RI "\fBPreconditionerType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "void \fBset_type\fP (const \fBPreconditionerType\fP pct)"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBset_petsc_preconditioner_type\fP (const \fBPreconditionerType\fP &preconditioner_type, \fBPC\fP &\fBpc\fP)"
.br
.ti -1c
.RI "static \fBPreconditioner\fP< T > * \fBbuild\fP (const \fBlibMesh::Parallel::Communicator\fP &\fBcomm\fP LIBMESH_CAN_DEFAULT_TO_COMMWORLD, const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBPC\fP \fB_pc\fP"
.br
.ti -1c
.RI "Mat \fB_mat\fP"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< T > * \fB_matrix\fP"
.br
.ti -1c
.RI "\fBPreconditionerType\fP \fB_preconditioner_type\fP"
.br
.ti -1c
.RI "bool \fB_is_initialized\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static void \fBset_petsc_subpreconditioner_type\fP (PCType \fBtype\fP, \fBPC\fP &\fBpc\fP)"
.br
.ti -1c
.RI "static void \fBset_petsc_subpreconditioner_type\fP (const PCType \fBtype\fP, \fBPC\fP &\fBpc\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::PetscPreconditioner< T >"
This class provides an interface to the suite of preconditioners available from Petsc\&.
.PP
\fBAuthor:\fP
.RS 4
Derek Gaston, 2009 
.RE
.PP

.PP
Definition at line 60 of file petsc_preconditioner\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBlibMesh::PetscPreconditioner\fP< T >::\fBPetscPreconditioner\fP (const \fBlibMesh::Parallel::Communicator\fP &\fBcomm\fPLIBMESH_CAN_DEFAULT_TO_COMMWORLD)\fC [inline]\fP"
Constructor\&. Initializes \fBPetscPreconditioner\fP data structures 
.PP
Definition at line 138 of file petsc_preconditioner\&.h\&.
.PP
.nf
138                                                                                     :
139   Preconditioner<T>(comm),
140   _pc(PETSC_NULL)
141 {
142 }
.fi
.SS "template<typename T > \fBlibMesh::PetscPreconditioner\fP< T >::~\fBPetscPreconditioner\fP ()\fC [inline]\fP, \fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 148 of file petsc_preconditioner\&.h\&.
.PP
.nf
149 {
150   this->clear ();
151 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > void \fBlibMesh::PetscPreconditioner\fP< T >::apply (const \fBNumericVector\fP< T > &x, \fBNumericVector\fP< T > &y)\fC [virtual]\fP"
Computes the preconditioned vector 'y' based on input 'x'\&. Usually by solving Py=x to get the action of P^-1 x\&. 
.PP
Implements \fBlibMesh::Preconditioner< T >\fP\&.
.PP
Definition at line 44 of file petsc_preconditioner\&.C\&.
.PP
References libMesh::ierr, libMesh::PetscVector< T >::vec(), and libMesh::x\&.
.PP
.nf
45 {
46   PetscVector<T> & x_pvec = libmesh_cast_ref<PetscVector<T>&>(const_cast<NumericVector<T>&>(x));
47   PetscVector<T> & y_pvec = libmesh_cast_ref<PetscVector<T>&>(const_cast<NumericVector<T>&>(y));
48 
49   Vec x_vec = x_pvec\&.vec();
50   Vec y_vec = y_pvec\&.vec();
51 
52   int ierr = PCApply(_pc,x_vec,y_vec);
53   LIBMESH_CHKERRABORT(ierr);
54 }
.fi
.SS "template<typename T> \fBPreconditioner\fP< T > * \fBlibMesh::Preconditioner\fP< T >::build (const \fBlibMesh::Parallel::Communicator\fP &\fBcomm\fPLIBMESH_CAN_DEFAULT_TO_COMMWORLD, const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBPreconditioner\fP\fP using the linear solver package specified by \fCsolver_package\fP 
.PP
Definition at line 38 of file preconditioner\&.C\&.
.PP
References libMesh::comm, libMesh::EIGEN_SOLVERS, libMesh::err, libMesh::PETSC_SOLVERS, and libMesh::TRILINOS_SOLVERS\&.
.PP
.nf
40 {
41   // Build the appropriate solver
42   switch (solver_package)
43     {
44 
45       /*
46         #ifdef LIBMESH_HAVE_LASPACK
47         case LASPACK_SOLVERS:
48         {
49         AutoPtr<Preconditioner<T> > ap(new LaspackPreconditioner<T>(comm));
50         return ap;
51         }
52         #endif
53       */
54 
55 #ifdef LIBMESH_HAVE_PETSC
56     case PETSC_SOLVERS:
57       {
58         return new PetscPreconditioner<T>(comm);
59       }
60 #endif
61 
62 #ifdef LIBMESH_HAVE_TRILINOS
63     case TRILINOS_SOLVERS:
64       return new TrilinosPreconditioner<T>(comm);
65 #endif
66 
67 #ifdef LIBMESH_HAVE_EIGEN
68     case EIGEN_SOLVERS:
69       return new EigenPreconditioner<T>(comm);
70 #endif
71 
72     default:
73       libMesh::err << "ERROR:  Unrecognized solver package: "
74                    << solver_package
75                    << std::endl;
76       libmesh_error();
77     }
78 
79   return NULL;
80 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscPreconditioner\fP< T >::clear ()\fC [virtual]\fP"
Release all memory and clear data structures\&. 
.PP
Reimplemented from \fBlibMesh::Preconditioner< T >\fP\&.
.PP
Definition at line 108 of file petsc_preconditioner\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
109 {
110   if (_pc)
111     {
112       int ierr = LibMeshPCDestroy(&_pc);
113       LIBMESH_CHKERRABORT(ierr);
114     }
115 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscPreconditioner\fP< T >::init ()\fC [virtual]\fP"
Initialize data structures if not done so already\&. 
.PP
Reimplemented from \fBlibMesh::Preconditioner< T >\fP\&.
.PP
Definition at line 60 of file petsc_preconditioner\&.C\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, libMesh::comm, libMesh::err, libMesh::ierr, and libMesh::PetscMatrix< T >::mat()\&.
.PP
.nf
61 {
62   if(!this->_matrix)
63     {
64       libMesh::err << "ERROR: No matrix set for PetscPreconditioner, but init() called" << std::endl;
65       libmesh_error();
66     }
67 
68   // Clear the preconditioner in case it has been created in the past
69   if (!this->_is_initialized)
70     {
71       // Should probably use PCReset(), but it's not working at the moment so we'll destroy instead
72       if (_pc)
73         {
74           int ierr = LibMeshPCDestroy(&_pc);
75           LIBMESH_CHKERRABORT(ierr);
76         }
77 
78       int ierr = PCCreate(this->comm()\&.get(),&_pc);
79       LIBMESH_CHKERRABORT(ierr);
80 
81       PetscMatrix<T> * pmatrix = libmesh_cast_ptr<PetscMatrix<T>*, SparseMatrix<T> >(this->_matrix);
82 
83       _mat = pmatrix->mat();
84     }
85 
86 #if PETSC_RELEASE_LESS_THAN(3,5,0)
87   int ierr = PCSetOperators(_pc,_mat,_mat,SAME_NONZERO_PATTERN);
88 #else
89   int ierr = PCSetOperators(_pc,_mat,_mat);
90 #endif
91   LIBMESH_CHKERRABORT(ierr);
92 
93   // Set the PCType\&.  Note: this used to be done *before* the call to
94   // PCSetOperators(), and only when !_is_initialized, but
95   // 1\&.) Some preconditioners (those employing sub-preconditioners,
96   // for example) have to call PCSetUp(), and can only do this after
97   // the operators have been set\&.
98   // 2\&.) It should be safe to call set_petsc_preconditioner_type()
99   // multiple times\&.
100   set_petsc_preconditioner_type(this->_preconditioner_type, _pc);
101 
102   this->_is_initialized = true;
103 }
.fi
.SS "template<typename T> bool \fBlibMesh::Preconditioner\fP< T >::initialized () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the data structures are initialized, false otherwise\&. 
.RE
.PP

.PP
Definition at line 89 of file preconditioner\&.h\&.
.PP
.nf
89 { return _is_initialized; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "template<typename T > \fBPC\fP \fBlibMesh::PetscPreconditioner\fP< T >::pc ()\fC [inline]\fP"
Returns the actual Petsc PC struct\&. Useful for more advanced purposes 
.PP
Definition at line 95 of file petsc_preconditioner\&.h\&.
.PP
References libMesh::PetscPreconditioner< T >::_pc\&.
.PP
.nf
95 { return _pc; }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "template<typename T > void \fBlibMesh::Preconditioner\fP< T >::set_matrix (\fBSparseMatrix\fP< \fBNumber\fP > &mat)\fC [inherited]\fP"
Sets the matrix P to be preconditioned\&. 
.PP
Definition at line 176 of file preconditioner\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized\&.
.PP
.nf
177 {
178   //If the matrix is changing then we (probably) need to reinitialize\&.
179   _is_initialized = false;
180   _matrix = &mat;
181 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscPreconditioner\fP< T >::set_petsc_preconditioner_type (const \fBPreconditionerType\fP &preconditioner_type, \fBPC\fP &pc)\fC [static]\fP"
Tells PETSC to use the user-specified preconditioner 
.PP
Definition at line 121 of file petsc_preconditioner\&.C\&.
.PP
References libMesh::AMG_PRECOND, libMesh::ASM_PRECOND, libMesh::BLOCK_JACOBI_PRECOND, libMesh::CHKERRABORT(), libMesh::CHOLESKY_PRECOND, libMesh::comm, libMesh::communicator, libMesh::EISENSTAT_PRECOND, libMesh::err, libMesh::ICC_PRECOND, libMesh::IDENTITY_PRECOND, libMesh::ierr, libMesh::ILU_PRECOND, libMesh::JACOBI_PRECOND, libMesh::LU_PRECOND, libMesh::PetscObjectGetComm(), libMesh::SHELL_PRECOND, libMesh::Parallel::Communicator::size(), libMesh::SOR_PRECOND, and libMesh::USER_PRECOND\&.
.PP
Referenced by libMesh::PetscLinearSolver< T >::init()\&.
.PP
.nf
122 {
123   int ierr = 0;
124 
125   // get the communicator from the PETSc object
126   Parallel::communicator comm;
127   PetscObjectGetComm((PetscObject)pc, &comm);
128   Parallel::Communicator communicator(comm);
129 
130   switch (preconditioner_type)
131     {
132     case IDENTITY_PRECOND:
133       ierr = PCSetType (pc, (char*) PCNONE);      CHKERRABORT(comm,ierr); break;
134 
135     case CHOLESKY_PRECOND:
136       ierr = PCSetType (pc, (char*) PCCHOLESKY);  CHKERRABORT(comm,ierr); break;
137 
138     case ICC_PRECOND:
139       ierr = PCSetType (pc, (char*) PCICC);       CHKERRABORT(comm,ierr); break;
140 
141     case ILU_PRECOND:
142       {
143         // In serial, just set the ILU preconditioner type
144         if (communicator\&.size())
145           {
146             ierr = PCSetType (pc, (char*) PCILU);
147             CHKERRABORT(comm,ierr);
148           }
149         else
150           {
151             // But PETSc has no truly parallel ILU, instead you have to set
152             // an actual parallel preconditioner (e\&.g\&. block Jacobi) and then
153             // assign ILU sub-preconditioners\&.
154             ierr = PCSetType (pc, (char*) PCBJACOBI);
155             CHKERRABORT(comm,ierr);
156 
157             // Set ILU as the sub preconditioner type
158             set_petsc_subpreconditioner_type(PCILU, pc);
159           }
160         break;
161       }
162 
163     case LU_PRECOND:
164       {
165         // In serial, just set the LU preconditioner type
166         if (communicator\&.size())
167           {
168             ierr = PCSetType (pc, (char*) PCLU);
169             CHKERRABORT(comm,ierr);
170           }
171         else
172           {
173             // But PETSc has no truly parallel LU, instead you have to set
174             // an actual parallel preconditioner (e\&.g\&. block Jacobi) and then
175             // assign LU sub-preconditioners\&.
176             ierr = PCSetType (pc, (char*) PCBJACOBI);
177             CHKERRABORT(comm,ierr);
178 
179             // Set ILU as the sub preconditioner type
180             set_petsc_subpreconditioner_type(PCLU, pc);
181           }
182         break;
183       }
184 
185     case ASM_PRECOND:
186       {
187         // In parallel, I think ASM uses ILU by default as the sub-preconditioner\&.\&.\&.
188         // I tried setting a different sub-preconditioner here, but apparently the matrix
189         // is not in the correct state (at this point) to call PCSetUp()\&.
190         ierr = PCSetType (pc, (char*) PCASM);
191         CHKERRABORT(comm,ierr);
192         break;
193       }
194 
195     case JACOBI_PRECOND:
196       ierr = PCSetType (pc, (char*) PCJACOBI);    CHKERRABORT(comm,ierr); break;
197 
198     case BLOCK_JACOBI_PRECOND:
199       ierr = PCSetType (pc, (char*) PCBJACOBI);   CHKERRABORT(comm,ierr); break;
200 
201     case SOR_PRECOND:
202       ierr = PCSetType (pc, (char*) PCSOR);       CHKERRABORT(comm,ierr); break;
203 
204     case EISENSTAT_PRECOND:
205       ierr = PCSetType (pc, (char*) PCEISENSTAT); CHKERRABORT(comm,ierr); break;
206 
207     case AMG_PRECOND:
208       ierr = PCSetType (pc, (char*) PCHYPRE);     CHKERRABORT(comm,ierr); break;
209 
210 #if !(PETSC_VERSION_LESS_THAN(2,1,2))
211       // Only available for PETSC >= 2\&.1\&.2
212     case USER_PRECOND:
213       ierr = PCSetType (pc, (char*) PCMAT);       CHKERRABORT(comm,ierr); break;
214 #endif
215 
216     case SHELL_PRECOND:
217       ierr = PCSetType (pc, (char*) PCSHELL);     CHKERRABORT(comm,ierr); break;
218 
219     default:
220       libMesh::err << "ERROR:  Unsupported PETSC Preconditioner: "
221                    << preconditioner_type       << std::endl
222                    << "Continuing with PETSC defaults" << std::endl;
223     }
224 
225   // Set additional options if we are doing AMG and
226   // HYPRE is available
227 #ifdef LIBMESH_HAVE_PETSC_HYPRE
228   if (preconditioner_type == AMG_PRECOND)
229     {
230       ierr = PCHYPRESetType(pc, "boomeramg");
231       CHKERRABORT(comm,ierr);
232     }
233 #endif
234 
235   // Let the commandline override stuff
236   // FIXME: Unless we are doing AMG???
237   if (preconditioner_type != AMG_PRECOND)
238     {
239       ierr = PCSetFromOptions(pc);
240       CHKERRABORT(comm,ierr);
241     }
242 }
.fi
.SS "template<typename T > static void \fBlibMesh::PetscPreconditioner\fP< T >::set_petsc_subpreconditioner_type (PCTypetype, \fBPC\fP &pc)\fC [static]\fP, \fC [private]\fP"
Some PETSc preconditioners (ILU, LU) don't work in parallel\&. This function is called from \fBset_petsc_preconditioner_type()\fP to set additional options for those so-called sub-preconditioners\&. This method ends up being static so that it can be called from \fBset_petsc_preconditioner_type()\fP\&. Not sure why \fBset_petsc_preconditioner_type()\fP needs to be static though\&.\&.\&. 
.SS "template<typename T > static void \fBlibMesh::PetscPreconditioner\fP< T >::set_petsc_subpreconditioner_type (const PCTypetype, \fBPC\fP &pc)\fC [static]\fP, \fC [private]\fP"

.SS "template<typename T > void \fBlibMesh::Preconditioner\fP< T >::set_type (const \fBPreconditionerType\fPpct)\fC [inherited]\fP"
Sets the type of preconditioner to use\&. 
.PP
Definition at line 185 of file preconditioner\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized\&.
.PP
.nf
186 {
187   //If the preconditioner type changes we (probably) need to reinitialize\&.
188   _is_initialized = false;
189   _preconditioner_type = pct;
190 }
.fi
.SS "template<typename T> virtual void \fBlibMesh::Preconditioner\fP< T >::setup ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This is called every time the 'operator might have changed'\&.
.PP
This is essentially where you need to fill in your preconditioning matrix\&. 
.PP
Definition at line 114 of file preconditioner\&.h\&.
.PP
.nf
114 {}
.fi
.SS "template<typename T> \fBPreconditionerType\fP \fBlibMesh::Preconditioner\fP< T >::type () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the type of preconditioner to use\&. 
.PP
Definition at line 124 of file preconditioner\&.h\&.
.PP
.nf
125   { return _preconditioner_type; }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "template<typename T> bool \fBlibMesh::Preconditioner\fP< T >::_is_initialized\fC [protected]\fP, \fC [inherited]\fP"
Flag indicating if the data structures have been initialized\&. 
.PP
Definition at line 148 of file preconditioner\&.h\&.
.PP
Referenced by libMesh::Preconditioner< Number >::initialized()\&.
.SS "template<typename T > Mat \fBlibMesh::PetscPreconditioner\fP< T >::_mat\fC [protected]\fP"
Petsc Matrix that's been pulled out of the _matrix object\&. This happens during init\&.\&.\&. 
.PP
Definition at line 113 of file petsc_preconditioner\&.h\&.
.SS "template<typename T> \fBSparseMatrix\fP<T>* \fBlibMesh::Preconditioner\fP< T >::_matrix\fC [protected]\fP, \fC [inherited]\fP"
The matrix P\&.\&.\&. ie the matrix to be preconditioned\&. This is often the actual system matrix of a linear sytem\&. 
.PP
Definition at line 138 of file preconditioner\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "template<typename T > \fBPC\fP \fBlibMesh::PetscPreconditioner\fP< T >::_pc\fC [protected]\fP"
\fBPreconditioner\fP context 
.PP
Definition at line 107 of file petsc_preconditioner\&.h\&.
.PP
Referenced by libMesh::PetscPreconditioner< T >::pc()\&.
.SS "template<typename T> \fBPreconditionerType\fP \fBlibMesh::Preconditioner\fP< T >::_preconditioner_type\fC [protected]\fP, \fC [inherited]\fP"
Enum statitng with type of preconditioner to use\&. 
.PP
Definition at line 143 of file preconditioner\&.h\&.
.PP
Referenced by libMesh::Preconditioner< Number >::type()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
