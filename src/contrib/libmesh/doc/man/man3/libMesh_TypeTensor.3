.TH "libMesh::TypeTensor< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::TypeTensor< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tensor_tools\&.h>\fP
.PP
Inherited by \fBlibMesh::TensorValue< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP (const \fBTypeTensor\fP< T2 > &p)"
.br
.ti -1c
.RI "\fB~TypeTensor\fP ()"
.br
.ti -1c
.RI "template<typename T2 > void \fBassign\fP (const \fBTypeTensor\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeTensor\fP & >::type \fBoperator=\fP (const Scalar &p)"
.br
.ti -1c
.RI "const T & \fBoperator()\fP (const unsigned int i, const unsigned int j) const "
.br
.ti -1c
.RI "T & \fBoperator()\fP (const unsigned int i, const unsigned int j)"
.br
.ti -1c
.RI "\fBConstTypeTensorColumn\fP< T > \fBslice\fP (const unsigned int i) const "
.br
.ti -1c
.RI "\fBTypeTensorColumn\fP< T > \fBslice\fP (const unsigned int i)"
.br
.ti -1c
.RI "\fBTypeVector\fP< T > \fBrow\fP (const unsigned int r)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator+\fP (const \fBTypeTensor\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeTensor\fP< T > & \fBoperator+=\fP (const \fBTypeTensor\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBadd\fP (const \fBTypeTensor\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBadd_scaled\fP (const \fBTypeTensor\fP< T2 > &, const T)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator-\fP (const \fBTypeTensor\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeTensor\fP< T > & \fBoperator-=\fP (const \fBTypeTensor\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBsubtract\fP (const \fBTypeTensor\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBsubtract_scaled\fP (const \fBTypeTensor\fP< T2 > &, const T)"
.br
.ti -1c
.RI "\fBTypeTensor\fP< T > \fBoperator-\fP () const "
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeTensor\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar) const "
.br
.ti -1c
.RI "template<typename Scalar > const \fBTypeTensor\fP< T > & \fBoperator*=\fP (const Scalar)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeTensor\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator/\fP (const Scalar) const "
.br
.ti -1c
.RI "const \fBTypeTensor\fP< T > & \fBoperator/=\fP (const T)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP< T > \fBoperator*\fP (const \fBTypeTensor\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBcontract\fP (const \fBTypeTensor\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator*\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "\fBTypeTensor\fP< T > \fBtranspose\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBsize\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBsize_sq\fP () const "
.br
.ti -1c
.RI "T \fBdet\fP () const "
.br
.ti -1c
.RI "T \fBtr\fP () const "
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTypeTensor\fP< T > &rhs) const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBTypeTensor\fP< T > &rhs) const "
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBTypeTensor\fP< T > &rhs) const "
.br
.ti -1c
.RI "void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "void \fBwrite_unformatted\fP (std::ostream &\fBout\fP, const bool newline=true) const "
.br
.ti -1c
.RI "template<> bool \fBoperator<\fP (const \fBTypeTensor\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "template<> bool \fBoperator>\fP (const \fBTypeTensor\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "template<> bool \fBoperator<\fP (const \fBTypeTensor\fP< \fBComplex\fP > &rhs) const"
.br
.ti -1c
.RI "template<> bool \fBoperator>\fP (const \fBTypeTensor\fP< \fBComplex\fP > &rhs) const"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "T \fB_coords\fP [LIBMESH_DIM *LIBMESH_DIM]"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBTypeTensor\fP ()"
.br
.ti -1c
.RI "\fBTypeTensor\fP (const T xx, const T xy=0, const T xz=0, const T yx=0, const T yy=0, const T yz=0, const T zx=0, const T zy=0, const T zz=0)"
.br
.ti -1c
.RI "template<typename Scalar > \fBTypeTensor\fP (const Scalar xx, const Scalar xy=0, const Scalar xz=0, const Scalar yx=0, const Scalar yy=0, const Scalar yz=0, const Scalar zx=0, const Scalar zy=0, typename \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, const Scalar >::type zz=0)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx, const \fBTypeVector\fP< T2 > &vy)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx, const \fBTypeVector\fP< T2 > &vy, const \fBTypeVector\fP< T2 > &vz)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename T2 > class \fBTypeTensor\fP"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBTypeTensor\fP< T > &t)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::TypeTensor< T >"
This class defines a tensor in \fCLIBMESH_DIM\fP dimensional space of type T\&. T may either be Real or Complex\&. The default constructor for this class is protected, suggesting that you should not instantiate one of these directly\&.
.PP
\fBAuthor:\fP
.RS 4
Roy Stogner, 2004\&. 
.RE
.PP

.PP
Definition at line 32 of file tensor_tools\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP ()\fC [inline]\fP, \fC [protected]\fP"
Empty constructor\&. Gives the tensor 0 in \fCLIBMESH_DIM\fP dimensions\&. 
.PP
Definition at line 419 of file type_tensor\&.h\&.
.PP
.nf
420 {
421   _coords[0] = 0;
422 
423 #if LIBMESH_DIM > 1
424   _coords[1] = 0;
425   _coords[2] = 0;
426   _coords[3] = 0;
427 #endif
428 
429 #if LIBMESH_DIM > 2
430   _coords[4] = 0;
431   _coords[5] = 0;
432   _coords[6] = 0;
433   _coords[7] = 0;
434   _coords[8] = 0;
435 #endif
436 }
.fi
.SS "template<typename T > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const Txx, const Txy = \fC0\fP, const Txz = \fC0\fP, const Tyx = \fC0\fP, const Tyy = \fC0\fP, const Tyz = \fC0\fP, const Tzx = \fC0\fP, const Tzy = \fC0\fP, const Tzz = \fC0\fP)\fC [inline]\fP, \fC [explicit]\fP, \fC [protected]\fP"
Constructor-from-T\&. By default sets higher dimensional entries to 0\&. This is a poor constructor for 2D tensors - if the default arguments are to be overridden it requires that the 'xz = 0\&.' etc\&. arguments also be given explicitly\&. 
.PP
Definition at line 443 of file type_tensor\&.h\&.
.PP
.nf
452 {
453   _coords[0] = xx;
454 
455 #if LIBMESH_DIM == 2
456   _coords[1] = xy;
457   _coords[2] = yx;
458   _coords[3] = yy;
459 #endif
460 
461 #if LIBMESH_DIM == 3
462   _coords[1] = xy;
463   _coords[2] = xz;
464   _coords[3] = yx;
465   _coords[4] = yy;
466   _coords[5] = yz;
467   _coords[6] = zx;
468   _coords[7] = zy;
469   _coords[8] = zz;
470 #endif
471 }
.fi
.SS "template<typename T > template<typename Scalar > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const Scalarxx, const Scalarxy = \fC0\fP, const Scalarxz = \fC0\fP, const Scalaryx = \fC0\fP, const Scalaryy = \fC0\fP, const Scalaryz = \fC0\fP, const Scalarzx = \fC0\fP, const Scalarzy = \fC0\fP, typename \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, const Scalar >::typezz = \fC0\fP)\fC [inline]\fP, \fC [explicit]\fP, \fC [protected]\fP"
Constructor-from-Scalar\&. 
.PP
Definition at line 478 of file type_tensor\&.h\&.
.PP
.nf
489 {
490   _coords[0] = xx;
491 
492 #if LIBMESH_DIM == 2
493   _coords[1] = xy;
494   _coords[2] = yx;
495   _coords[3] = yy;
496 #endif
497 
498 #if LIBMESH_DIM == 3
499   _coords[1] = xy;
500   _coords[2] = xz;
501   _coords[3] = yx;
502   _coords[4] = yy;
503   _coords[5] = yz;
504   _coords[6] = zx;
505   _coords[7] = zy;
506   _coords[8] = zz;
507 #endif
508 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx)\fC [protected]\fP"
Constructor\&. Assigns each vector to a different row of the tensor\&. We're in LIBMESH_DIM space dimensions and so LIBMESH_DIM many vectors are needed\&. 
.PP
Definition at line 525 of file type_tensor\&.h\&.
.PP
.nf
526 {
527   libmesh_assert_equal_to (LIBMESH_DIM, 1);
528   _coords[0] = vx(0);
529 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx, const \fBTypeVector\fP< T2 > &vy)\fC [protected]\fP"

.PP
Definition at line 533 of file type_tensor\&.h\&.
.PP
.nf
534 {
535   libmesh_assert_equal_to (LIBMESH_DIM, 2);
536   _coords[0] = vx(0);
537   _coords[1] = vx(1);
538   _coords[2] = vy(0);
539   _coords[3] = vy(1);
540 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const \fBTypeVector\fP< T2 > &vx, const \fBTypeVector\fP< T2 > &vy, const \fBTypeVector\fP< T2 > &vz)\fC [protected]\fP"

.PP
Definition at line 544 of file type_tensor\&.h\&.
.PP
.nf
545 {
546   libmesh_assert_equal_to (LIBMESH_DIM, 3);
547   _coords[0] = vx(0);
548   _coords[1] = vx(1);
549   _coords[2] = vx(2);
550   _coords[3] = vy(0);
551   _coords[4] = vy(1);
552   _coords[5] = vy(2);
553   _coords[6] = vz(0);
554   _coords[7] = vz(1);
555   _coords[8] = vz(2);
556 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::TypeTensor\fP< T >::\fBTypeTensor\fP (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 515 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
516 {
517   // copy the nodes from vector p to me
518   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
519     _coords[i] = p\&._coords[i];
520 }
.fi
.SS "template<typename T > \fBlibMesh::TypeTensor\fP< T >::~\fBTypeTensor\fP ()\fC [inline]\fP"
Destructor\&. 
.PP
Definition at line 563 of file type_tensor\&.h\&.
.PP
.nf
564 {
565 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeTensor\fP< T >::add (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Add to this tensor without creating a temporary\&. 
.PP
Definition at line 706 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
707 {
708   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
709     _coords[i] += p\&._coords[i];
710 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeTensor\fP< T >::add_scaled (const \fBTypeTensor\fP< T2 > &p, const Tfactor)\fC [inline]\fP"
Add a scaled tensor to this tensor without creating a temporary\&. 
.PP
Definition at line 717 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
Referenced by libMesh::HPCoarsenTest::add_projection(), libMesh::System::calculate_norm(), libMesh::MeshFunction::hessian(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::System::point_hessian(), and libMesh::HPCoarsenTest::select_refinement()\&.
.PP
.nf
718 {
719   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
720     _coords[i] += factor*p\&._coords[i];
721 
722 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeTensor\fP< T >::assign (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Assign to a tensor without creating a temporary\&. 
.PP
Definition at line 572 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
573 {
574   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
575     _coords[i] = p\&._coords[i];
576 }
.fi
.SS "template<typename T > template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBlibMesh::TypeTensor\fP< T >::contract (const \fBTypeTensor\fP< T2 > &t) const\fC [inline]\fP"
Multiply 2 tensors together, i\&.e\&. dyadic product sum_ij Aij*Bij\&. The tensors may be of different types\&.
.PP
Multiply 2 tensors together, i\&.e\&. sum Aij*Bij\&. The tensors may be of different types\&. 
.PP
Definition at line 1015 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords, and libMesh::Parallel::sum()\&.
.PP
Referenced by libMesh::HPCoarsenTest::add_projection(), libMesh::TensorTools::inner_product(), and libMesh::HPCoarsenTest::select_refinement()\&.
.PP
.nf
1016 {
1017   typename CompareTypes<T,T2>::supertype sum = 0\&.;
1018   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
1019     sum += _coords[i]*t\&._coords[i];
1020   return sum;
1021 }
.fi
.SS "template<typename T > T \fBlibMesh::TypeTensor\fP< T >::det () const\fC [inline]\fP"
Returns the determinant of the tensor\&. Because these are 3x3 tensors at most, we don't do an LU decomposition like \fBDenseMatrix\fP does\&. 
.PP
Definition at line 1036 of file type_tensor\&.h\&.
.PP
Referenced by libMesh::Sphere::Sphere()\&.
.PP
.nf
1037 {
1038 #if LIBMESH_DIM == 1
1039   return _coords[0];
1040 #endif
1041 
1042 #if LIBMESH_DIM == 2
1043   return (_coords[0] * _coords[3]
1044           - _coords[1] * _coords[2]);
1045 #endif
1046 
1047 #if LIBMESH_DIM == 3
1048   return (_coords[0] * _coords[4] * _coords[8]
1049           + _coords[1] * _coords[5] * _coords[6]
1050           + _coords[2] * _coords[3] * _coords[7]
1051           - _coords[0] * _coords[5] * _coords[7]
1052           - _coords[1] * _coords[3] * _coords[8]
1053           - _coords[2] * _coords[4] * _coords[6]);
1054 #endif
1055 }
.fi
.SS "template<typename T > const T & \fBlibMesh::TypeTensor\fP< T >::operator() (const unsigned inti, const unsigned intj) const\fC [inline]\fP"
Return the $ i,j^{th} $ element of the tensor\&. 
.PP
Definition at line 582 of file type_tensor\&.h\&.
.PP
.nf
584 {
585   libmesh_assert_less (i, 3);
586   libmesh_assert_less (j, 3);
587 
588 #if LIBMESH_DIM < 3
589   const static T my_zero = 0;
590   if (i >= LIBMESH_DIM || j >= LIBMESH_DIM)
591     return my_zero;
592 #endif
593 
594   return _coords[i*LIBMESH_DIM+j];
595 }
.fi
.SS "template<typename T > T & \fBlibMesh::TypeTensor\fP< T >::operator() (const unsigned inti, const unsigned intj)\fC [inline]\fP"
Return a writeable reference to the $ i,j^{th} $ element of the tensor\&. 
.PP
Definition at line 601 of file type_tensor\&.h\&.
.PP
.nf
603 {
604 #if LIBMESH_DIM < 3
605 
606   if (i >= LIBMESH_DIM || j >= LIBMESH_DIM)
607     {
608       //       libMesh::err << "ERROR:  You are assigning to a tensor component" << std::endl
609       // << "that is out of range for the compiled LIBMESH_DIM!"      << std::endl
610       // << " LIBMESH_DIM=" << LIBMESH_DIM << " , i=" << i << " , j=" << j << std::endl;
611       libmesh_error();
612     }
613 
614 #endif
615 
616   libmesh_assert_less (i, LIBMESH_DIM);
617   libmesh_assert_less (j, LIBMESH_DIM);
618 
619   return _coords[i*LIBMESH_DIM+j];
620 }
.fi
.SS "template<typename T > template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, \fBTypeTensor\fP< typename \fBCompareTypes\fP< T, Scalar >::supertype > >::type \fBlibMesh::TypeTensor\fP< T >::operator* (const Scalarfactor) const\fC [inline]\fP"
Multiply a tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 833 of file type_tensor\&.h\&.
.PP
.nf
834 {
835   typedef typename CompareTypes<T, Scalar>::supertype TS;
836 
837 
838 #if LIBMESH_DIM == 1
839   return TypeTensor<TS>(_coords[0]*factor);
840 #endif
841 
842 #if LIBMESH_DIM == 2
843   return TypeTensor<TS>(_coords[0]*factor,
844                         _coords[1]*factor,
845                         _coords[2]*factor,
846                         _coords[3]*factor);
847 #endif
848 
849 #if LIBMESH_DIM == 3
850   return TypeTensor<TS>(_coords[0]*factor,
851                         _coords[1]*factor,
852                         _coords[2]*factor,
853                         _coords[3]*factor,
854                         _coords[4]*factor,
855                         _coords[5]*factor,
856                         _coords[6]*factor,
857                         _coords[7]*factor,
858                         _coords[8]*factor);
859 #endif
860 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeTensor\fP< T > \fBlibMesh::TypeTensor\fP< T >::operator* (const \fBTypeTensor\fP< T2 > &p) const\fC [inline]\fP"
Multiply 2 tensors together, i\&.e\&. matrix product\&. The tensors may be of different types\&. 
.PP
Definition at line 994 of file type_tensor\&.h\&.
.PP
.nf
995 {
996   TypeTensor<T> returnval;
997   for (unsigned int i=0; i<LIBMESH_DIM; i++)
998     for (unsigned int j=0; j<LIBMESH_DIM; j++)
999       for (unsigned int k=0; k<LIBMESH_DIM; k++)
1000         returnval(i,j) += (*this)(i,k)*p(k,j);
1001 
1002   return returnval;
1003 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeVector\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeTensor\fP< T >::operator* (const \fBTypeVector\fP< T2 > &p) const\fC [inline]\fP"
Multiply a tensor and vector together, i\&.e\&. matrix-vector product\&. The tensor and vector may be of different types\&. 
.PP
Definition at line 979 of file type_tensor\&.h\&.
.PP
.nf
980 {
981   TypeVector<typename CompareTypes<T,T2>::supertype> returnval;
982   for (unsigned int i=0; i<LIBMESH_DIM; i++)
983     for (unsigned int j=0; j<LIBMESH_DIM; j++)
984       returnval(i) += (*this)(i,j)*p(j);
985 
986   return returnval;
987 }
.fi
.SS "template<typename T > template<typename Scalar > const \fBTypeTensor\fP< T > & \fBlibMesh::TypeTensor\fP< T >::operator*= (const Scalarfactor)\fC [inline]\fP"
Multiply this tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 880 of file type_tensor\&.h\&.
.PP
.nf
881 {
882   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
883     _coords[i] *= factor;
884 
885   return *this;
886 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeTensor\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeTensor\fP< T >::operator+ (const \fBTypeTensor\fP< T2 > &p) const\fC [inline]\fP"
Add two tensors\&. 
.PP
Definition at line 660 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
661 {
662 
663 #if LIBMESH_DIM == 1
664   return TypeTensor(_coords[0] + p\&._coords[0]);
665 #endif
666 
667 #if LIBMESH_DIM == 2
668   return TypeTensor(_coords[0] + p\&._coords[0],
669                     _coords[1] + p\&._coords[1],
670                     0\&.,
671                     _coords[2] + p\&._coords[2],
672                     _coords[3] + p\&._coords[3]);
673 #endif
674 
675 #if LIBMESH_DIM == 3
676   return TypeTensor(_coords[0] + p\&._coords[0],
677                     _coords[1] + p\&._coords[1],
678                     _coords[2] + p\&._coords[2],
679                     _coords[3] + p\&._coords[3],
680                     _coords[4] + p\&._coords[4],
681                     _coords[5] + p\&._coords[5],
682                     _coords[6] + p\&._coords[6],
683                     _coords[7] + p\&._coords[7],
684                     _coords[8] + p\&._coords[8]);
685 #endif
686 
687 }
.fi
.SS "template<typename T > template<typename T2 > const \fBTypeTensor\fP< T > & \fBlibMesh::TypeTensor\fP< T >::operator+= (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Add to this tensor\&. 
.PP
Definition at line 694 of file type_tensor\&.h\&.
.PP
.nf
695 {
696   this->add (p);
697 
698   return *this;
699 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeTensor\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeTensor\fP< T >::operator- (const \fBTypeTensor\fP< T2 > &p) const\fC [inline]\fP"
Subtract two tensors\&. 
.PP
Definition at line 730 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
731 {
732 
733 #if LIBMESH_DIM == 1
734   return TypeTensor(_coords[0] - p\&._coords[0]);
735 #endif
736 
737 #if LIBMESH_DIM == 2
738   return TypeTensor(_coords[0] - p\&._coords[0],
739                     _coords[1] - p\&._coords[1],
740                     0\&.,
741                     _coords[2] - p\&._coords[2],
742                     _coords[3] - p\&._coords[3]);
743 #endif
744 
745 #if LIBMESH_DIM == 3
746   return TypeTensor(_coords[0] - p\&._coords[0],
747                     _coords[1] - p\&._coords[1],
748                     _coords[2] - p\&._coords[2],
749                     _coords[3] - p\&._coords[3],
750                     _coords[4] - p\&._coords[4],
751                     _coords[5] - p\&._coords[5],
752                     _coords[6] - p\&._coords[6],
753                     _coords[7] - p\&._coords[7],
754                     _coords[8] - p\&._coords[8]);
755 #endif
756 
757 }
.fi
.SS "template<typename T > \fBTypeTensor\fP< T > \fBlibMesh::TypeTensor\fP< T >::operator- () const\fC [inline]\fP"
Return the opposite of a tensor 
.PP
Definition at line 797 of file type_tensor\&.h\&.
.PP
.nf
798 {
799 
800 #if LIBMESH_DIM == 1
801   return TypeTensor(-_coords[0]);
802 #endif
803 
804 #if LIBMESH_DIM == 2
805   return TypeTensor(-_coords[0],
806                     -_coords[1],
807                     -_coords[2],
808                     -_coords[3]);
809 #endif
810 
811 #if LIBMESH_DIM == 3
812   return TypeTensor(-_coords[0],
813                     -_coords[1],
814                     -_coords[2],
815                     -_coords[3],
816                     -_coords[4],
817                     -_coords[5],
818                     -_coords[6],
819                     -_coords[7],
820                     -_coords[8]);
821 #endif
822 
823 }
.fi
.SS "template<typename T > template<typename T2 > const \fBTypeTensor\fP< T > & \fBlibMesh::TypeTensor\fP< T >::operator-= (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Subtract from this tensor\&. 
.PP
Definition at line 764 of file type_tensor\&.h\&.
.PP
.nf
765 {
766   this->subtract (p);
767 
768   return *this;
769 }
.fi
.SS "template<typename T > template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, \fBTypeTensor\fP< typename \fBCompareTypes\fP< T, Scalar >::supertype > >::type \fBlibMesh::TypeTensor\fP< T >::operator/ (const Scalarfactor) const\fC [inline]\fP"
Divide a tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 897 of file type_tensor\&.h\&.
.PP
.nf
898 {
899   libmesh_assert_not_equal_to (factor, static_cast<T>(0\&.));
900 
901   typedef typename CompareTypes<T, Scalar>::supertype TS;
902 
903 #if LIBMESH_DIM == 1
904   return TypeTensor<TS>(_coords[0]/factor);
905 #endif
906 
907 #if LIBMESH_DIM == 2
908   return TypeTensor<TS>(_coords[0]/factor,
909                         _coords[1]/factor,
910                         _coords[2]/factor,
911                         _coords[3]/factor);
912 #endif
913 
914 #if LIBMESH_DIM == 3
915   return TypeTensor<TS>(_coords[0]/factor,
916                         _coords[1]/factor,
917                         _coords[2]/factor,
918                         _coords[3]/factor,
919                         _coords[4]/factor,
920                         _coords[5]/factor,
921                         _coords[6]/factor,
922                         _coords[7]/factor,
923                         _coords[8]/factor);
924 #endif
925 
926 }
.fi
.SS "template<typename T > const \fBTypeTensor\fP< T > & \fBlibMesh::TypeTensor\fP< T >::operator/= (const Tfactor)\fC [inline]\fP"
Divide this tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 962 of file type_tensor\&.h\&.
.PP
.nf
963 {
964   libmesh_assert_not_equal_to (factor, static_cast<T>(0\&.));
965 
966   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
967     _coords[i] /= factor;
968 
969   return *this;
970 }
.fi
.SS "template<> bool \fBlibMesh::TypeTensor\fP< \fBReal\fP >::operator< (const \fBTypeTensor\fP< \fBReal\fP > &rhs) const"

.PP
Definition at line 113 of file type_tensor\&.C\&.
.PP
.nf
114 {
115   for (unsigned int i=0; i<LIBMESH_DIM; i++)
116     for (unsigned int j=0; j<LIBMESH_DIM; j++)
117       {
118         if ((*this)(i,j) < rhs(i,j))
119           return true;
120         if ((*this)(i,j) > rhs(i,j))
121           return false;
122       }
123   return false;
124 }
.fi
.SS "template<> bool \fBlibMesh::TypeTensor\fP< \fBComplex\fP >::operator< (const \fBTypeTensor\fP< \fBComplex\fP > &rhs) const"

.PP
Definition at line 146 of file type_tensor\&.C\&.
.PP
.nf
147 {
148   for (unsigned int i=0; i<LIBMESH_DIM; i++)
149     for (unsigned int j=0; j<LIBMESH_DIM; j++)
150       {
151         if ((*this)(i,j)\&.real() < rhs(i,j)\&.real())
152           return true;
153         if ((*this)(i,j)\&.real() > rhs(i,j)\&.real())
154           return false;
155         if ((*this)(i,j)\&.imag() < rhs(i,j)\&.imag())
156           return true;
157         if ((*this)(i,j)\&.imag() > rhs(i,j)\&.imag())
158           return false;
159       }
160   return false;
161 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeTensor\fP< T >::operator< (const \fBTypeTensor\fP< T > &rhs) const"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this tensor is 'less' than another\&. Useful for sorting\&. 
.RE
.PP

.SS "template<typename T> template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeTensor\fP&>::type \fBlibMesh::TypeTensor\fP< T >::operator= (const Scalar &p)\fC [inline]\fP"
Assignment-from-scalar operator\&. Used only to zero out vectors\&. 
.PP
Definition at line 137 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::zero()\&.
.PP
.nf
138   { libmesh_assert_equal_to (p, Scalar(0)); this->zero(); return *this; }
.fi
.SS "template<typename T > bool \fBlibMesh::TypeTensor\fP< T >::operator== (const \fBTypeTensor\fP< T > &rhs) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if two tensors are equal valued\&. 
.RE
.PP

.PP
Definition at line 1098 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords, std::abs(), and libMesh::TOLERANCE\&.
.PP
.nf
1099 {
1100 #if LIBMESH_DIM == 1
1101   return (std::abs(_coords[0] - rhs\&._coords[0])
1102           < TOLERANCE);
1103 #endif
1104 
1105 #if LIBMESH_DIM == 2
1106   return ((std::abs(_coords[0] - rhs\&._coords[0]) +
1107            std::abs(_coords[1] - rhs\&._coords[1]) +
1108            std::abs(_coords[2] - rhs\&._coords[2]) +
1109            std::abs(_coords[3] - rhs\&._coords[3]))
1110           < 4\&.*TOLERANCE);
1111 #endif
1112 
1113 #if LIBMESH_DIM == 3
1114   return ((std::abs(_coords[0] - rhs\&._coords[0]) +
1115            std::abs(_coords[1] - rhs\&._coords[1]) +
1116            std::abs(_coords[2] - rhs\&._coords[2]) +
1117            std::abs(_coords[3] - rhs\&._coords[3]) +
1118            std::abs(_coords[4] - rhs\&._coords[4]) +
1119            std::abs(_coords[5] - rhs\&._coords[5]) +
1120            std::abs(_coords[6] - rhs\&._coords[6]) +
1121            std::abs(_coords[7] - rhs\&._coords[7]) +
1122            std::abs(_coords[8] - rhs\&._coords[8]))
1123           < 9\&.*TOLERANCE);
1124 #endif
1125 
1126 }
.fi
.SS "template<> bool \fBlibMesh::TypeTensor\fP< \fBReal\fP >::operator> (const \fBTypeTensor\fP< \fBReal\fP > &rhs) const"

.PP
Definition at line 129 of file type_tensor\&.C\&.
.PP
.nf
130 {
131   for (unsigned int i=0; i<LIBMESH_DIM; i++)
132     for (unsigned int j=0; j<LIBMESH_DIM; j++)
133       {
134         if ((*this)(i,j) > rhs(i,j))
135           return true;
136         if ((*this)(i,j) < rhs(i,j))
137           return false;
138       }
139   return false;
140 }
.fi
.SS "template<> bool \fBlibMesh::TypeTensor\fP< \fBComplex\fP >::operator> (const \fBTypeTensor\fP< \fBComplex\fP > &rhs) const"

.PP
Definition at line 166 of file type_tensor\&.C\&.
.PP
.nf
167 {
168   for (unsigned int i=0; i<LIBMESH_DIM; i++)
169     for (unsigned int j=0; j<LIBMESH_DIM; j++)
170       {
171         if ((*this)(i,j)\&.real() > rhs(i,j)\&.real())
172           return true;
173         if ((*this)(i,j)\&.real() < rhs(i,j)\&.real())
174           return false;
175         if ((*this)(i,j)\&.imag() > rhs(i,j)\&.imag())
176           return true;
177         if ((*this)(i,j)\&.imag() < rhs(i,j)\&.imag())
178           return false;
179       }
180   return false;
181 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeTensor\fP< T >::operator> (const \fBTypeTensor\fP< T > &rhs) const"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this tensor is 'greater' than another\&. 
.RE
.PP

.SS "template<typename T > void \fBlibMesh::TypeTensor\fP< T >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const"
Formatted print, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 39 of file type_tensor\&.C\&.
.PP
.nf
40 {
41 #if LIBMESH_DIM == 1
42 
43   os << "x=" << (*this)(0,0) << std::endl;
44 
45 #endif
46 #if LIBMESH_DIM == 2
47 
48   os << "(xx,xy)=("
49      << std::setw(8) << (*this)(0,0) << ", "
50      << std::setw(8) << (*this)(0,1) << ")"
51      << std::endl;
52   os << "(yx,yy)=("
53      << std::setw(8) << (*this)(1,0) << ", "
54      << std::setw(8) << (*this)(1,1) << ")"
55      << std::endl;
56 
57 #endif
58 #if LIBMESH_DIM == 3
59 
60   os <<  "(xx,xy,xz)=("
61      << std::setw(8) << (*this)(0,0) << ", "
62      << std::setw(8) << (*this)(0,1) << ", "
63      << std::setw(8) << (*this)(0,2) << ")"
64      << std::endl;
65   os <<  "(yx,yy,yz)=("
66      << std::setw(8) << (*this)(1,0) << ", "
67      << std::setw(8) << (*this)(1,1) << ", "
68      << std::setw(8) << (*this)(1,2) << ")"
69      << std::endl;
70   os <<  "(zx,zy,zz)=("
71      << std::setw(8) << (*this)(2,0) << ", "
72      << std::setw(8) << (*this)(2,1) << ", "
73      << std::setw(8) << (*this)(2,2) << ")"
74      << std::endl;
75 #endif
76 }
.fi
.SS "template<typename T > \fBTypeVector\fP< T > \fBlibMesh::TypeTensor\fP< T >::row (const unsigned intr)\fC [inline]\fP"
Return one row of the tensor as a \fBTypeVector\fP\&. 
.PP
Definition at line 646 of file type_tensor\&.h\&.
.PP
References libMesh::TypeVector< T >::_coords\&.
.PP
.nf
647 {
648   TypeVector<T> return_vector;
649 
650   for(unsigned int j=0; j<LIBMESH_DIM; j++)
651     return_vector\&._coords[j] = _coords[r*LIBMESH_DIM + j];
652 
653   return return_vector;
654 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::TypeTensor\fP< T >::size () const\fC [inline]\fP"
Returns the Frobenius norm of the tensor, i\&.e\&. the square-root of the sum of the elements squared\&. 
.PP
Definition at line 1027 of file type_tensor\&.h\&.
.PP
Referenced by libMesh::System::calculate_norm()\&.
.PP
.nf
1028 {
1029   return std::sqrt(this->size_sq());
1030 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::TypeTensor\fP< T >::size_sq () const\fC [inline]\fP"
Returns the Frobenius norm of the tensor squared, i\&.e\&. sum of the element magnitudes squared\&. 
.PP
Definition at line 1086 of file type_tensor\&.h\&.
.PP
References libMesh::TensorTools::norm_sq(), libMesh::Real, and libMesh::Parallel::sum()\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::calculate_norm(), libMesh::ExactErrorEstimator::find_squared_element_error(), and libMesh::HPCoarsenTest::select_refinement()\&.
.PP
.nf
1087 {
1088   Real sum = 0\&.;
1089   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
1090     sum += TensorTools::norm_sq(_coords[i]);
1091   return sum;
1092 }
.fi
.SS "template<typename T > \fBConstTypeTensorColumn\fP< T > \fBlibMesh::TypeTensor\fP< T >::slice (const unsigned inti) const\fC [inline]\fP"
Return a proxy for the $ i^{th} $ column of the tensor\&. 
.PP
Definition at line 626 of file type_tensor\&.h\&.
.PP
.nf
627 {
628   libmesh_assert_less (i, LIBMESH_DIM);
629   return ConstTypeTensorColumn<T>(*this, i);
630 }
.fi
.SS "template<typename T > \fBTypeTensorColumn\fP< T > \fBlibMesh::TypeTensor\fP< T >::slice (const unsigned inti)\fC [inline]\fP"
Return a writeable proxy for the $ i^{th} $ column of the tensor\&. 
.PP
Definition at line 636 of file type_tensor\&.h\&.
.PP
.nf
637 {
638   libmesh_assert_less (i, LIBMESH_DIM);
639   return TypeTensorColumn<T>(*this, i);
640 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeTensor\fP< T >::subtract (const \fBTypeTensor\fP< T2 > &p)\fC [inline]\fP"
Subtract from this tensor without creating a temporary\&. 
.PP
Definition at line 776 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
.nf
777 {
778   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
779     _coords[i] -= p\&._coords[i];
780 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeTensor\fP< T >::subtract_scaled (const \fBTypeTensor\fP< T2 > &p, const Tfactor)\fC [inline]\fP"
Subtract a scaled value from this tensor without creating a temporary\&. 
.PP
Definition at line 787 of file type_tensor\&.h\&.
.PP
References libMesh::TypeTensor< T >::_coords\&.
.PP
Referenced by libMesh::HPCoarsenTest::select_refinement()\&.
.PP
.nf
788 {
789   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
790     _coords[i] -= factor*p\&._coords[i];
791 }
.fi
.SS "template<typename T > T \fBlibMesh::TypeTensor\fP< T >::tr () const\fC [inline]\fP"
Returns the trace of the tensor\&. 
.PP
Definition at line 1059 of file type_tensor\&.h\&.
.PP
.nf
1060 {
1061 #if LIBMESH_DIM == 1
1062   return _coords[0];
1063 #endif
1064 
1065 #if LIBMESH_DIM == 2
1066   return _coords[0] + _coords[3];
1067 #endif
1068 
1069 #if LIBMESH_DIM == 3
1070   return _coords[0] + _coords[4] + _coords[8];
1071 #endif
1072 }
.fi
.SS "template<typename T > \fBTypeTensor\fP< T > \fBlibMesh::TypeTensor\fP< T >::transpose () const\fC [inline]\fP"
The transpose (with complex numbers not conjugated) of the tensor\&. 
.PP
Definition at line 932 of file type_tensor\&.h\&.
.PP
.nf
933 {
934 #if LIBMESH_DIM == 1
935   return TypeTensor(_coords[0]);
936 #endif
937 
938 #if LIBMESH_DIM == 2
939   return TypeTensor(_coords[0],
940                     _coords[2],
941                     _coords[1],
942                     _coords[3]);
943 #endif
944 
945 #if LIBMESH_DIM == 3
946   return TypeTensor(_coords[0],
947                     _coords[3],
948                     _coords[6],
949                     _coords[1],
950                     _coords[4],
951                     _coords[7],
952                     _coords[2],
953                     _coords[5],
954                     _coords[8]);
955 #endif
956 }
.fi
.SS "template<typename T > void \fBlibMesh::TypeTensor\fP< T >::write_unformatted (std::ostream &out, const boolnewline = \fCtrue\fP) const"
Unformatted print to the stream \fCout\fP\&. Simply prints the elements of the tensor separated by spaces and newlines\&. 
.PP
Definition at line 83 of file type_tensor\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
85 {
86   libmesh_assert (out_stream);
87 
88   out_stream << std::setiosflags(std::ios::showpoint)
89              << (*this)(0,0) << " "
90              << (*this)(0,1) << " "
91              << (*this)(0,2) << " ";
92   if (newline)
93     out_stream << '\n';
94 
95   out_stream << std::setiosflags(std::ios::showpoint)
96              << (*this)(1,0) << " "
97              << (*this)(1,1) << " "
98              << (*this)(1,2) << " ";
99   if (newline)
100     out_stream << '\n';
101 
102   out_stream << std::setiosflags(std::ios::showpoint)
103              << (*this)(2,0) << " "
104              << (*this)(2,1) << " "
105              << (*this)(2,2) << " ";
106   if (newline)
107     out_stream << '\n';
108 }
.fi
.SS "template<typename T > void \fBlibMesh::TypeTensor\fP< T >::zero ()\fC [inline]\fP"
Zero the tensor in any dimension\&. 
.PP
Definition at line 1076 of file type_tensor\&.h\&.
.PP
Referenced by libMesh::TensorValue< T >::operator=(), and libMesh::TypeTensor< T >::operator=()\&.
.PP
.nf
1077 {
1078   for (unsigned int i=0; i<LIBMESH_DIM*LIBMESH_DIM; i++)
1079     _coords[i] = 0\&.;
1080 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename T> std::ostream& operator<< (std::ostream &os, const \fBTypeTensor\fP< T > &t)\fC [friend]\fP"
Formatted print as above but allows you to do std::cout << t << std::endl; 
.PP
Definition at line 336 of file type_tensor\&.h\&.
.PP
.nf
337   {
338     t\&.print(os);
339     return os;
340   }
.fi
.SS "template<typename T> template<typename T2 > friend class \fBTypeTensor\fP\fC [friend]\fP"

.PP
Definition at line 54 of file type_tensor\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename T> T \fBlibMesh::TypeTensor\fP< T >::_coords[LIBMESH_DIM *LIBMESH_DIM]"
The coordinates of the \fC\fBTypeTensor\fP\fP 
.PP
Definition at line 353 of file type_tensor\&.h\&.
.PP
Referenced by libMesh::TypeTensor< T >::add(), libMesh::TypeTensor< T >::add_scaled(), libMesh::TypeTensor< T >::assign(), libMesh::TypeTensor< T >::contract(), libMesh::TypeTensor< T >::operator+(), libMesh::TypeTensor< T >::operator-(), libMesh::TypeTensor< T >::operator==(), libMesh::TypeTensor< T >::subtract(), libMesh::TypeTensor< T >::subtract_scaled(), and libMesh::TypeTensor< T >::TypeTensor()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
