.TH "libMesh::Nemesis_IO_Helper" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Nemesis_IO_Helper \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nemesis_io_helper\&.h>\fP
.PP
Inherits \fBlibMesh::ExodusII_IO_Helper\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNemesis_IO_Helper\fP (const \fBParallelObject\fP &parent, bool \fBverbose\fP=false, bool single_precision=false)"
.br
.ti -1c
.RI "virtual \fB~Nemesis_IO_Helper\fP ()"
.br
.ti -1c
.RI "void \fBget_init_global\fP ()"
.br
.ti -1c
.RI "void \fBget_ss_param_global\fP ()"
.br
.ti -1c
.RI "void \fBget_ns_param_global\fP ()"
.br
.ti -1c
.RI "void \fBget_eb_info_global\fP ()"
.br
.ti -1c
.RI "void \fBget_init_info\fP ()"
.br
.ti -1c
.RI "void \fBget_loadbal_param\fP ()"
.br
.ti -1c
.RI "void \fBget_elem_map\fP ()"
.br
.ti -1c
.RI "void \fBget_node_map\fP ()"
.br
.ti -1c
.RI "void \fBget_cmap_params\fP ()"
.br
.ti -1c
.RI "void \fBget_node_cmap\fP ()"
.br
.ti -1c
.RI "void \fBget_elem_cmap\fP ()"
.br
.ti -1c
.RI "void \fBput_init_info\fP (unsigned \fBnum_proc\fP, unsigned \fBnum_proc_in_file\fP, const char *\fBftype\fP)"
.br
.ti -1c
.RI "void \fBput_init_global\fP (\fBdof_id_type\fP \fBnum_nodes_global\fP, \fBdof_id_type\fP \fBnum_elems_global\fP, unsigned \fBnum_elem_blks_global\fP, unsigned \fBnum_node_sets_global\fP, unsigned \fBnum_side_sets_global\fP)"
.br
.ti -1c
.RI "void \fBput_eb_info_global\fP (std::vector< int > &\fBglobal_elem_blk_ids\fP, std::vector< int > &\fBglobal_elem_blk_cnts\fP)"
.br
.ti -1c
.RI "void \fBput_ns_param_global\fP (std::vector< int > &\fBglobal_nodeset_ids\fP, std::vector< int > &\fBnum_global_node_counts\fP, std::vector< int > &\fBnum_global_node_df_counts\fP)"
.br
.ti -1c
.RI "void \fBput_ss_param_global\fP (std::vector< int > &\fBglobal_sideset_ids\fP, std::vector< int > &\fBnum_global_side_counts\fP, std::vector< int > &\fBnum_global_side_df_counts\fP)"
.br
.ti -1c
.RI "void \fBput_loadbal_param\fP (unsigned \fBnum_internal_nodes\fP, unsigned \fBnum_border_nodes\fP, unsigned \fBnum_external_nodes\fP, unsigned \fBnum_internal_elems\fP, unsigned \fBnum_border_elems\fP, unsigned \fBnum_node_cmaps\fP, unsigned \fBnum_elem_cmaps\fP)"
.br
.ti -1c
.RI "void \fBput_cmap_params\fP (std::vector< int > &\fBnode_cmap_ids\fP, std::vector< int > &\fBnode_cmap_node_cnts\fP, std::vector< int > &\fBelem_cmap_ids\fP, std::vector< int > &\fBelem_cmap_elem_cnts\fP)"
.br
.ti -1c
.RI "void \fBput_node_cmap\fP (std::vector< std::vector< int > > &\fBnode_cmap_node_ids\fP, std::vector< std::vector< int > > &\fBnode_cmap_proc_ids\fP)"
.br
.ti -1c
.RI "void \fBput_node_map\fP (std::vector< int > &\fBnode_mapi\fP, std::vector< int > &\fBnode_mapb\fP, std::vector< int > &\fBnode_mape\fP)"
.br
.ti -1c
.RI "void \fBput_elem_cmap\fP (std::vector< std::vector< int > > &\fBelem_cmap_elem_ids\fP, std::vector< std::vector< int > > &\fBelem_cmap_side_ids\fP, std::vector< std::vector< int > > &\fBelem_cmap_proc_ids\fP)"
.br
.ti -1c
.RI "void \fBput_elem_map\fP (std::vector< int > &\fBelem_mapi\fP, std::vector< int > &\fBelem_mapb\fP)"
.br
.ti -1c
.RI "void \fBput_n_coord\fP (unsigned start_node_num, unsigned \fBnum_nodes\fP, std::vector< \fBReal\fP > &x_coor, std::vector< \fBReal\fP > &y_coor, std::vector< \fBReal\fP > &z_coor)"
.br
.ti -1c
.RI "virtual void \fBwrite_nodal_coordinates\fP (const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "virtual void \fBwrite_elements\fP (const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "virtual void \fBwrite_sidesets\fP (const \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "virtual void \fBwrite_nodesets\fP (const \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "virtual void \fBcreate\fP (std::string filename)"
.br
.ti -1c
.RI "virtual void \fBinitialize\fP (std::string \fBtitle\fP, const \fBMeshBase\fP &\fBmesh\fP, bool use_discontinuous=false)"
.br
.ti -1c
.RI "void \fBwrite_nodal_solution\fP (const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &names, int timestep)"
.br
.ti -1c
.RI "std::string \fBconstruct_nemesis_filename\fP (const std::string &base_filename)"
.br
.ti -1c
.RI "const char * \fBget_elem_type\fP () const "
.br
.ti -1c
.RI "void \fBopen\fP (const char *filename, bool read_only)"
.br
.ti -1c
.RI "void \fBread_header\fP ()"
.br
.ti -1c
.RI "void \fBprint_header\fP ()"
.br
.ti -1c
.RI "void \fBread_nodes\fP ()"
.br
.ti -1c
.RI "void \fBread_node_num_map\fP ()"
.br
.ti -1c
.RI "void \fBprint_nodes\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "void \fBread_block_info\fP ()"
.br
.ti -1c
.RI "int \fBget_block_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_block_name\fP (int index)"
.br
.ti -1c
.RI "int \fBget_side_set_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_side_set_name\fP (int index)"
.br
.ti -1c
.RI "int \fBget_node_set_id\fP (int index)"
.br
.ti -1c
.RI "std::string \fBget_node_set_name\fP (int index)"
.br
.ti -1c
.RI "void \fBread_elem_in_block\fP (int block)"
.br
.ti -1c
.RI "void \fBread_elem_num_map\fP ()"
.br
.ti -1c
.RI "void \fBread_sideset_info\fP ()"
.br
.ti -1c
.RI "void \fBread_nodeset_info\fP ()"
.br
.ti -1c
.RI "void \fBread_sideset\fP (int id, int offset)"
.br
.ti -1c
.RI "void \fBread_nodeset\fP (int id)"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.ti -1c
.RI "int \fBinquire\fP (int req_info, std::string error_msg='')"
.br
.ti -1c
.RI "void \fBread_time_steps\fP ()"
.br
.ti -1c
.RI "void \fBread_num_time_steps\fP ()"
.br
.ti -1c
.RI "void \fBread_nodal_var_values\fP (std::string nodal_var_name, int time_step)"
.br
.ti -1c
.RI "void \fBread_elemental_var_values\fP (std::string elemental_var_name, int time_step)"
.br
.ti -1c
.RI "void \fBinitialize_element_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBinitialize_nodal_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBinitialize_global_variables\fP (std::vector< std::string > names)"
.br
.ti -1c
.RI "void \fBwrite_timestep\fP (int timestep, \fBReal\fP time)"
.br
.ti -1c
.RI "void \fBwrite_element_values\fP (const \fBMeshBase\fP &\fBmesh\fP, const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBwrite_nodal_values\fP (int var_id, const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBwrite_information_records\fP (const std::vector< std::string > &records)"
.br
.ti -1c
.RI "void \fBwrite_global_values\fP (const std::vector< \fBReal\fP > &values, int timestep)"
.br
.ti -1c
.RI "void \fBuse_mesh_dimension_instead_of_spatial_dimension\fP (bool val)"
.br
.ti -1c
.RI "void \fBset_coordinate_offset\fP (\fBPoint\fP p)"
.br
.ti -1c
.RI "std::vector< std::string > \fBget_complex_names\fP (const std::vector< std::string > &names) const "
.br
.ti -1c
.RI "void \fBmessage\fP (const std::string &msg)"
.br
.ti -1c
.RI "void \fBmessage\fP (const std::string &msg, int i)"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "int \fBnemesis_err_flag\fP"
.br
.ti -1c
.RI "int \fBnum_nodes_global\fP"
.br
.ti -1c
.RI "int \fBnum_elems_global\fP"
.br
.ti -1c
.RI "int \fBnum_elem_blks_global\fP"
.br
.ti -1c
.RI "int \fBnum_node_sets_global\fP"
.br
.ti -1c
.RI "int \fBnum_side_sets_global\fP"
.br
.ti -1c
.RI "int \fBnum_proc\fP"
.br
.ti -1c
.RI "int \fBnum_proc_in_file\fP"
.br
.ti -1c
.RI "char \fBftype\fP"
.br
.ti -1c
.RI "std::vector< int > \fBglobal_sideset_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_global_side_counts\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_global_side_df_counts\fP"
.br
.ti -1c
.RI "std::vector< int > \fBglobal_nodeset_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_global_node_counts\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_global_node_df_counts\fP"
.br
.ti -1c
.RI "std::vector< int > \fBglobal_elem_blk_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBglobal_elem_blk_cnts\fP"
.br
.ti -1c
.RI "std::set< int > \fBnodes_attached_to_local_elems\fP"
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::vector< unsigned int > > \fBsubdomain_map\fP"
.br
.ti -1c
.RI "std::map< int, std::vector< int > > \fBblock_id_to_elem_connectivity\fP"
.br
.ti -1c
.RI "int \fBnum_internal_nodes\fP"
.br
.ti -1c
.RI "int \fBnum_border_nodes\fP"
.br
.ti -1c
.RI "int \fBnum_external_nodes\fP"
.br
.ti -1c
.RI "int \fBnum_internal_elems\fP"
.br
.ti -1c
.RI "int \fBnum_border_elems\fP"
.br
.ti -1c
.RI "int \fBnum_node_cmaps\fP"
.br
.ti -1c
.RI "int \fBnum_elem_cmaps\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_mapi\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_mapb\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_mapi\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_mapb\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_mape\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_cmap_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_cmap_node_cnts\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_cmap_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_cmap_elem_cnts\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBnode_cmap_node_ids\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBnode_cmap_proc_ids\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBelem_cmap_elem_ids\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBelem_cmap_side_ids\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBelem_cmap_proc_ids\fP"
.br
.ti -1c
.RI "int \fBex_id\fP"
.br
.ti -1c
.RI "int \fBex_err\fP"
.br
.ti -1c
.RI "int \fBnum_dim\fP"
.br
.ti -1c
.RI "int \fBnum_global_vars\fP"
.br
.ti -1c
.RI "int \fBnum_nodes\fP"
.br
.ti -1c
.RI "int \fBnum_elem\fP"
.br
.ti -1c
.RI "int \fBnum_elem_blk\fP"
.br
.ti -1c
.RI "int \fBnum_node_sets\fP"
.br
.ti -1c
.RI "int \fBnum_side_sets\fP"
.br
.ti -1c
.RI "int \fBnum_elem_this_blk\fP"
.br
.ti -1c
.RI "int \fBnum_nodes_per_elem\fP"
.br
.ti -1c
.RI "int \fBnum_attr\fP"
.br
.ti -1c
.RI "int \fBnum_elem_all_sidesets\fP"
.br
.ti -1c
.RI "std::vector< int > \fBblock_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBconnect\fP"
.br
.ti -1c
.RI "std::vector< int > \fBss_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnodeset_ids\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_sides_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_nodes_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_df_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnum_node_df_per_set\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBside_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBid_list\fP"
.br
.ti -1c
.RI "std::vector< int > \fBnode_num_map\fP"
.br
.ti -1c
.RI "std::vector< int > \fBelem_num_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBx\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBy\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBz\fP"
.br
.ti -1c
.RI "std::vector< char > \fBtitle\fP"
.br
.ti -1c
.RI "std::vector< char > \fBelem_type\fP"
.br
.ti -1c
.RI "std::map< int, int > \fBlibmesh_elem_num_to_exodus\fP"
.br
.ti -1c
.RI "std::vector< int > \fBexodus_elem_num_to_libmesh\fP"
.br
.ti -1c
.RI "std::map< int, int > \fBlibmesh_node_num_to_exodus\fP"
.br
.ti -1c
.RI "std::vector< int > \fBexodus_node_num_to_libmesh\fP"
.br
.ti -1c
.RI "int \fBnum_time_steps\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBtime_steps\fP"
.br
.ti -1c
.RI "int \fBnum_nodal_vars\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBnodal_var_names\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBnodal_var_values\fP"
.br
.ti -1c
.RI "int \fBnum_elem_vars\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBelem_var_names\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBelem_var_values\fP"
.br
.ti -1c
.RI "std::vector< std::string > \fBglobal_var_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_block_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_ss_names\fP"
.br
.ti -1c
.RI "std::map< int, std::string > \fBid_to_ns_names\fP"
.br
.ti -1c
.RI "bool \fBverbose\fP"
.br
.ti -1c
.RI "bool \fBopened_for_writing\fP"
.br
.ti -1c
.RI "bool \fBopened_for_reading\fP"
.br
.ti -1c
.RI "std::string \fBcurrent_filename\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fB_run_only_on_proc0\fP"
.br
.ti -1c
.RI "bool \fB_elem_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_global_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_nodal_vars_initialized\fP"
.br
.ti -1c
.RI "bool \fB_use_mesh_dimension_instead_of_spatial_dimension\fP"
.br
.ti -1c
.RI "\fBPoint\fP \fB_coordinate_offset\fP"
.br
.ti -1c
.RI "bool \fB_single_precision\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef std::map< unsigned, 
.br
std::set< unsigned >
.br
 >::iterator \fBproc_nodes_touched_iterator\fP"
.br
.ti -1c
.RI "typedef std::map< unsigned, 
.br
std::set< std::pair< unsigned, 
.br
unsigned > > >::iterator \fBproc_border_elem_sets_iterator\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBcompute_num_global_elem_blocks\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBcompute_num_global_nodesets\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBcompute_num_global_sidesets\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBbuild_element_and_node_maps\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBcompute_border_node_ids\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBcompute_internal_and_border_elems_and_internal_nodes\fP (const \fBMeshBase\fP &pmesh)"
.br
.ti -1c
.RI "void \fBcompute_communication_map_parameters\fP ()"
.br
.ti -1c
.RI "void \fBcompute_node_communication_maps\fP ()"
.br
.ti -1c
.RI "void \fBcompute_node_maps\fP ()"
.br
.ti -1c
.RI "void \fBcompute_elem_communication_maps\fP ()"
.br
.ti -1c
.RI "void \fBcompute_element_maps\fP ()"
.br
.ti -1c
.RI "void \fBwrite_exodus_initialization_info\fP (const \fBMeshBase\fP &pmesh, const std::string &\fBtitle\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
unsigned > \fBlocal_subdomain_counts\fP"
.br
.ti -1c
.RI "std::set< unsigned > \fBborder_node_ids\fP"
.br
.ti -1c
.RI "std::map< unsigned, std::set
.br
< unsigned > > \fBproc_nodes_touched_intersections\fP"
.br
.ti -1c
.RI "std::map< unsigned, std::set
.br
< std::pair< unsigned, 
.br
unsigned > > > \fBproc_border_elem_sets\fP"
.br
.ti -1c
.RI "std::set< unsigned > \fBinternal_node_ids\fP"
.br
.ti -1c
.RI "std::set< unsigned > \fBinternal_elem_ids\fP"
.br
.ti -1c
.RI "std::set< unsigned > \fBborder_elem_ids\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This is the \fC\fBNemesis_IO_Helper\fP\fP class\&. Think of it as a big struct with storage for all the stuff one might want to pull from a \fBNemesis\fP file\&. Derived from \fBExodusII_IO_Helper\fP object, since \fBNemesis\fP is based on the same file format\&.
.PP
\fBAuthor:\fP
.RS 4
John W\&. Peterson, 2008\&. 
.RE
.PP

.PP
Definition at line 60 of file nemesis_io_helper\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<unsigned, std::set<std::pair<unsigned,unsigned> > >::iterator \fBlibMesh::Nemesis_IO_Helper::proc_border_elem_sets_iterator\fP\fC [private]\fP"
Typedef for an iterator into the data structure above\&. 
.PP
Definition at line 556 of file nemesis_io_helper\&.h\&.
.SS "typedef std::map<unsigned, std::set<unsigned> >::iterator \fBlibMesh::Nemesis_IO_Helper::proc_nodes_touched_iterator\fP\fC [private]\fP"
Typedef for an iterator into the data structure above\&. 
.PP
Definition at line 546 of file nemesis_io_helper\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Nemesis_IO_Helper::Nemesis_IO_Helper (const \fBParallelObject\fP &parent, boolverbose = \fCfalse\fP, boolsingle_precision = \fCfalse\fP)\fC [explicit]\fP"
Constructor\&. 
.PP
Definition at line 42 of file nemesis_io_helper\&.C\&.
.PP
.nf
43                                                                              :
44   ExodusII_IO_Helper(parent, verbose_in, /*run_only_on_proc0=*/false, /*single_precision=*/single_precision),
45   nemesis_err_flag(0),
46   num_nodes_global(0),
47   num_elems_global(0),
48   num_elem_blks_global(0),
49   num_node_sets_global(0),
50   num_side_sets_global(0),
51   num_proc(0),
52   num_proc_in_file(0),
53   ftype('\0'),
54   num_internal_nodes(0),
55   num_border_nodes(0),
56   num_external_nodes(0),
57   num_internal_elems(0),
58   num_border_elems(0),
59   num_node_cmaps(0),
60   num_elem_cmaps(0)
61 {
62   // Warn about using untested code!
63   libmesh_experimental();
64 }
.fi
.SS "libMesh::Nemesis_IO_Helper::~Nemesis_IO_Helper ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 67 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::close(), libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, and ex_update()\&.
.PP
.nf
68 {
69   // Our destructor is called from Nemesis_IO\&.  We close the Exodus file here since we have
70   // responsibility for managing the file's lifetime\&.
71   this->ex_err = exII::ex_update(this->ex_id);
72   EX_EXCEPTIONLESS_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
73   this->close();
74 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::Nemesis_IO_Helper::build_element_and_node_maps (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function builds the libmesh -> exodus and exodus -> libmesh node and element maps\&. These maps allow us to have a consistent numbering scheme within an Exodus file, given an existing globally consistent numbering scheme from LibMesh\&. 
.PP
Definition at line 1693 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), block_id_to_elem_connectivity, libMesh::ExodusII_IO_Helper::block_ids, libMesh::Elem::build(), libMesh::MeshBase::elem(), libMesh::err, libMesh::ExodusII_IO_Helper::exodus_elem_num_to_libmesh, libMesh::ExodusII_IO_Helper::exodus_node_num_to_libmesh, libMesh::ExodusII_IO_Helper::Conversion::get_canonical_type(), libMesh::ExodusII_IO_Helper::Conversion::get_node_map(), libMesh::DofObject::id(), libMesh::libmesh_assert(), libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus, libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus, local_subdomain_counts, n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::node(), nodes_attached_to_local_elems, libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::num_nodes_per_elem, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::Elem::subdomain_id(), subdomain_map, libMesh::Elem::type(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1694 {
1695   // If we don't have any local subdomains, it had better be because
1696   // we don't have any local elements
1697 #ifdef DEBUG
1698   if (local_subdomain_counts\&.empty())
1699     {
1700       libmesh_assert(pmesh\&.active_local_elements_begin() ==
1701                      pmesh\&.active_local_elements_end());
1702       libmesh_assert(this->nodes_attached_to_local_elems\&.empty());
1703     }
1704 #endif
1705 
1706   // Elements have to be numbered contiguously based on what block
1707   // number they are in\&.  Therefore we have to do a bit of work to get
1708   // the block (ie subdomain) numbers first and store them off as
1709   // block_ids\&.
1710 
1711   // Make sure there is no leftover information in the subdomain_map, and reserve
1712   // enough space to store the elements we need\&.
1713   this->subdomain_map\&.clear();
1714   for (std::map<subdomain_id_type, unsigned>::iterator it=this->local_subdomain_counts\&.begin();
1715        it != this->local_subdomain_counts\&.end();
1716        ++it)
1717     {
1718       subdomain_id_type cur_subdomain = (*it)\&.first;
1719 
1720       /*
1721       // We can't have a zero subdomain ID in Exodus (for some reason?)
1722       // so map zero subdomains to a max value\&.\&.\&.
1723       if (cur_subdomain == 0)
1724       cur_subdomain = std::numeric_limits<subdomain_id_type>::max();
1725       */
1726 
1727       if (verbose)
1728         {
1729           libMesh::out << "[" << this->processor_id() << "] "
1730                        << "local_subdomain_counts [" << static_cast<unsigned>(cur_subdomain) << "]= "
1731                        << (*it)\&.second
1732                        << std::endl;
1733         }
1734 
1735       // *it\&.first is the subodmain ID, *it\&.second is the number of elements it contains
1736       this->subdomain_map[ cur_subdomain ]\&.reserve( (*it)\&.second );
1737     }
1738 
1739 
1740   // First loop over the elements to figure out which elements are in which subdomain
1741   MeshBase::const_element_iterator elem_it = pmesh\&.active_local_elements_begin();
1742   MeshBase::const_element_iterator elem_end = pmesh\&.active_local_elements_end();
1743 
1744   for (; elem_it != elem_end; ++elem_it)
1745     {
1746       const Elem * elem = *elem_it;
1747 
1748       // Grab the nodes while we're here\&.
1749       for (unsigned int n=0; n<elem->n_nodes(); ++n)
1750         this->nodes_attached_to_local_elems\&.insert( elem->node(n) );
1751 
1752       unsigned int cur_subdomain = elem->subdomain_id();
1753 
1754       /*
1755       // We can't have a zero subdomain ID in Exodus (for some reason?)
1756       // so map zero subdomains to a max value\&.\&.\&.
1757       if(cur_subdomain == 0)
1758       cur_subdomain = std::numeric_limits<subdomain_id_type>::max();
1759       */
1760 
1761       this->subdomain_map[cur_subdomain]\&.push_back(elem->id());
1762     }
1763 
1764   // Set num_nodes which is used by exodusII_io_helper
1765   this->num_nodes = this->nodes_attached_to_local_elems\&.size();
1766 
1767   // Now come up with a 1-based numbering for these nodes
1768   this->exodus_node_num_to_libmesh\&.clear(); // Make sure it's empty
1769   this->exodus_node_num_to_libmesh\&.reserve(this->nodes_attached_to_local_elems\&.size());
1770 
1771   // Also make sure there's no leftover information in the map which goes the
1772   // other direction\&.
1773   this->libmesh_node_num_to_exodus\&.clear();
1774 
1775   // Set the map for nodes
1776   for (std::set<int>::iterator it = this->nodes_attached_to_local_elems\&.begin();
1777        it != this->nodes_attached_to_local_elems\&.end();
1778        ++it)
1779     {
1780       // I\&.e\&. given exodus_node_id,
1781       // exodus_node_num_to_libmesh[ exodus_node_id ] returns the libmesh ID for that node\&.
1782       // Note that even though most of Exodus is 1-based, this code will map an Exodus ID of
1783       // zero to some libmesh node ID\&.  Is that a problem?
1784       this->exodus_node_num_to_libmesh\&.push_back(*it);
1785 
1786       // Likewise, given libmesh_node_id,
1787       // libmesh_node_num_to_exodus[ libmesh_node_id ] returns the *Exodus* ID for that node\&.
1788       // Unlike the exodus_node_num_to_libmesh vector above, this one is a std::map
1789       this->libmesh_node_num_to_exodus[*it] = this->exodus_node_num_to_libmesh\&.size(); // should never be zero\&.\&.\&.
1790     }
1791 
1792   // Now we're going to loop over the subdomain map and build a few things right
1793   // now that we'll use later\&.
1794 
1795   // First make sure our data structures don't have any leftover data\&.\&.\&.
1796   this->exodus_elem_num_to_libmesh\&.clear();
1797   this->block_ids\&.clear();
1798   this->libmesh_elem_num_to_exodus\&.clear();
1799 
1800   // Now loop over each subdomain and get a unique numbering for the elements
1801   for (std::map<subdomain_id_type, std::vector<unsigned int> >::iterator it = this->subdomain_map\&.begin();
1802        it != this->subdomain_map\&.end();
1803        ++it)
1804     {
1805       block_ids\&.push_back((*it)\&.first);
1806 
1807       // Vector of element IDs for this subdomain
1808       std::vector<unsigned int>& elem_ids_this_subdomain = (*it)\&.second;
1809 
1810       // The code below assumes this subdomain block is not empty, make sure that's the case!
1811       if (elem_ids_this_subdomain\&.size() == 0)
1812         {
1813           libMesh::err << "Error, no element IDs found in subdomain " << (*it)\&.first << std::endl;
1814           libmesh_error();
1815         }
1816 
1817       ExodusII_IO_Helper::ElementMaps em;
1818 
1819       // Use the first element in this block to get representative information\&.
1820       // Note that Exodus assumes all elements in a block are of the same type!
1821       // We are using that same assumption here!
1822       const ExodusII_IO_Helper::Conversion conv = em\&.assign_conversion(pmesh\&.elem(elem_ids_this_subdomain[0])->type());
1823       this->num_nodes_per_elem = pmesh\&.elem(elem_ids_this_subdomain[0])->n_nodes();
1824 
1825       // Get a reference to the connectivity vector for this subdomain\&.  This vector
1826       // is most likely empty, we are going to fill it up now\&.
1827       std::vector<int>& current_block_connectivity = this->block_id_to_elem_connectivity[(*it)\&.first];
1828 
1829       // Just in case it's not already empty\&.\&.\&.
1830       current_block_connectivity\&.clear();
1831       current_block_connectivity\&.resize(elem_ids_this_subdomain\&.size() * this->num_nodes_per_elem);
1832 
1833       for (unsigned int i=0; i<elem_ids_this_subdomain\&.size(); i++)
1834         {
1835           unsigned int elem_id = elem_ids_this_subdomain[i];
1836 
1837           // Set the number map for elements
1838           this->exodus_elem_num_to_libmesh\&.push_back(elem_id);
1839           this->libmesh_elem_num_to_exodus[elem_id] = this->exodus_elem_num_to_libmesh\&.size();
1840 
1841           const Elem * elem = pmesh\&.elem(elem_id);
1842 
1843           // Exodus/Nemesis want every block to have the same element type
1844           // libmesh_assert_equal_to (elem->type(), conv\&.get_canonical_type());
1845 
1846           // But we can get away with writing e\&.g\&. HEX8 and INFHEX8 in
1847           // the same block\&.\&.\&.
1848           libmesh_assert_equal_to (elem->n_nodes(), Elem::build(conv\&.get_canonical_type(), NULL)->n_nodes());
1849 
1850           for (unsigned int j=0; j < static_cast<unsigned int>(this->num_nodes_per_elem); j++)
1851             {
1852               const unsigned int connect_index   = (i*this->num_nodes_per_elem)+j;
1853               const unsigned int elem_node_index = conv\&.get_node_map(j);
1854               current_block_connectivity[connect_index] = this->libmesh_node_num_to_exodus[elem->node(elem_node_index)];
1855             }
1856         } // End loop over elems in this subdomain
1857     } // end loop over subdomain_map
1858 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::close ()\fC [inherited]\fP"
Closes the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 695 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, ex_close(), libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::~ExodusII_IO(), and ~Nemesis_IO_Helper()\&.
.PP
.nf
696 {
697   // Always call close on processor 0\&.
698   // If we're running on multiple processors, i\&.e\&. as one of several Nemesis files,
699   // we call close on all processors\&.\&.\&.
700   if ((this->processor_id() == 0) || (!_run_only_on_proc0))
701     {
702       ex_err = exII::ex_close(ex_id);
703       EX_CHECK_ERR(ex_err, "Error closing Exodus file\&.");
704       message("Exodus file closed successfully\&.");
705     }
706 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), compute_num_global_elem_blocks(), compute_num_global_nodesets(), compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_border_node_ids (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function constructs the set of border node IDs present on the current mesh\&. These are nodes which live on the 'border' between elements which live on different processors\&. 
.PP
Definition at line 1864 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), border_node_ids, libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::ParallelObject::n_processors(), libMesh::Elem::node(), num_border_nodes, num_node_cmaps, libMesh::out, proc_nodes_touched_intersections, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Parallel::set_union(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1865 {
1866   // The set which will eventually contain the IDs of "border nodes"\&.  These are nodes
1867   // that lie on the boundary between one or more processors\&.
1868   //std::set<unsigned> border_node_ids;
1869 
1870   // map from processor ID to set of nodes which elements from this processor "touch",
1871   // that is,
1872   // proc_nodes_touched[p] = (set all node IDs found in elements owned by processor p)
1873   std::map<unsigned, std::set<unsigned> > proc_nodes_touched;
1874 
1875 
1876   // We are going to create a lot of intermediate data structures here, so make sure
1877   // as many as possible all cleaned up by creating scope!
1878   {
1879     // Loop over active (not just active local) elements, make sets of node IDs for each
1880     // processor which has an element that "touches" a node\&.
1881     {
1882       MeshBase::const_element_iterator elem_it = pmesh\&.active_elements_begin();
1883       MeshBase::const_element_iterator elem_end = pmesh\&.active_elements_end();
1884 
1885       for (; elem_it != elem_end; ++elem_it)
1886         {
1887           const Elem* elem = *elem_it;
1888 
1889           // Get reference to the set for this processor\&.  If it does not exist
1890           // it will be created\&.
1891           std::set<unsigned>& set_p = proc_nodes_touched[ elem->processor_id() ];
1892 
1893           // Insert all nodes touched by this element into the set
1894           for (unsigned int node=0; node<elem->n_nodes(); ++node)
1895             set_p\&.insert(elem->node(node));
1896         }
1897     }
1898 
1899     // The number of node communication maps is the number of other processors
1900     // with which we share nodes\&. (I think\&.) This is just the size of the map we just
1901     // created, minus 1\&.
1902     this->num_node_cmaps = proc_nodes_touched\&.size() - 1;
1903 
1904     // If we've got no elements on this processor and haven't touched
1905     // any nodes, however, then that's 0 other processors with which
1906     // we share nodes, not -1\&.
1907     if (this->num_node_cmaps == -1)
1908       {
1909         libmesh_assert (pmesh\&.active_elements_begin() == pmesh\&.active_elements_end());
1910         this->num_node_cmaps = 0;
1911       }
1912 
1913     // We can't be connecting to more processors than exist outside
1914     // ourselves
1915     libmesh_assert_less (static_cast<unsigned>(this->num_node_cmaps), this->n_processors());
1916 
1917     if (verbose)
1918       {
1919         libMesh::out << "[" << this->processor_id()
1920                      << "] proc_nodes_touched contains "
1921                      << proc_nodes_touched\&.size()
1922                      << " sets of nodes\&."
1923                      << std::endl;
1924 
1925         for (proc_nodes_touched_iterator it = proc_nodes_touched\&.begin();
1926              it != proc_nodes_touched\&.end();
1927              ++it)
1928           {
1929             libMesh::out << "[" << this->processor_id()
1930                          << "] proc_nodes_touched[" << (*it)\&.first << "] has "
1931                          << (*it)\&.second\&.size()
1932                          << " entries\&."
1933                          << std::endl;
1934           }
1935       }
1936 
1937 
1938     // Loop over all the sets we just created and compute intersections with the
1939     // this processor's set\&.  Obviously, don't intersect with ourself\&.
1940     for (proc_nodes_touched_iterator it = proc_nodes_touched\&.begin();
1941          it != proc_nodes_touched\&.end();
1942          ++it)
1943       {
1944         // Don't compute intersections with ourself
1945         if ((*it)\&.first == this->processor_id())
1946           continue;
1947 
1948         // Otherwise, compute intersection with other processor and ourself
1949         std::set<unsigned>& my_set = proc_nodes_touched[this->processor_id()];
1950         std::set<unsigned>& other_set = (*it)\&.second;
1951         std::set<unsigned>& result_set = this->proc_nodes_touched_intersections[ (*it)\&.first ]; // created if does not exist
1952 
1953         std::set_intersection(my_set\&.begin(), my_set\&.end(),
1954                               other_set\&.begin(), other_set\&.end(),
1955                               std::inserter(result_set, result_set\&.end()));
1956       }
1957 
1958     if (verbose)
1959       {
1960         for (proc_nodes_touched_iterator it = this->proc_nodes_touched_intersections\&.begin();
1961              it != this->proc_nodes_touched_intersections\&.end();
1962              ++it)
1963           {
1964             libMesh::out << "[" << this->processor_id()
1965                          << "] this->proc_nodes_touched_intersections[" << (*it)\&.first << "] has "
1966                          << (*it)\&.second\&.size()
1967                          << " entries\&."
1968                          << std::endl;
1969           }
1970       }
1971 
1972     // Compute the set_union of all the preceding intersections\&.  This will be the set of
1973     // border node IDs for this processor\&.
1974     for (proc_nodes_touched_iterator it = this->proc_nodes_touched_intersections\&.begin();
1975          it != this->proc_nodes_touched_intersections\&.end();
1976          ++it)
1977       {
1978         std::set<unsigned>& other_set = (*it)\&.second;
1979         std::set<unsigned> intermediate_result; // Don't think we can insert into one of the sets we're unioning\&.\&.\&.
1980 
1981         std::set_union(this->border_node_ids\&.begin(), this->border_node_ids\&.end(),
1982                        other_set\&.begin(), other_set\&.end(),
1983                        std::inserter(intermediate_result, intermediate_result\&.end()));
1984 
1985         // Swap our intermediate result into the final set
1986         this->border_node_ids\&.swap(intermediate_result);
1987       }
1988 
1989     if (verbose)
1990       {
1991         libMesh::out << "[" << this->processor_id()
1992                      << "] border_node_ids\&.size()=" << this->border_node_ids\&.size()
1993                      << std::endl;
1994       }
1995   } // end scope for border node ID creation
1996 
1997   // Store the number of border node IDs to be written to Nemesis file
1998   this->num_border_nodes = this->border_node_ids\&.size();
1999 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_communication_map_parameters ()\fC [private]\fP"
This function determines the communication map parameters which will eventually be written to file 
.PP
Definition at line 1133 of file nemesis_io_helper\&.C\&.
.PP
References elem_cmap_elem_cnts, elem_cmap_ids, node_cmap_ids, node_cmap_node_cnts, num_elem_cmaps, num_node_cmaps, libMesh::out, proc_border_elem_sets, proc_nodes_touched_intersections, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1134 {
1135   // For the nodes, these are the number of entries in the sets in proc_nodes_touched_intersections
1136   // map computed above\&.  Note: this map does not contain self-intersections so we can loop over it
1137   // directly\&.
1138   this->node_cmap_node_cnts\&.clear(); // Make sure we don't have any leftover information\&.\&.\&.
1139   this->node_cmap_ids\&.clear();       // Make sure we don't have any leftover information\&.\&.\&.
1140   this->node_cmap_node_cnts\&.resize(this->num_node_cmaps);
1141   this->node_cmap_ids\&.resize(this->num_node_cmaps);
1142 
1143   {
1144     unsigned cnt=0; // Index into the vector
1145     for (proc_nodes_touched_iterator it = this->proc_nodes_touched_intersections\&.begin();
1146          it != this->proc_nodes_touched_intersections\&.end();
1147          ++it)
1148       {
1149         this->node_cmap_ids[cnt] = (*it)\&.first; // The ID of the proc we communicate with
1150         this->node_cmap_node_cnts[cnt] = (*it)\&.second\&.size(); // The number of nodes we communicate
1151         cnt++; // increment vector index!
1152       }
1153   }
1154 
1155   // Print the packed vectors we just filled
1156   if (verbose)
1157     {
1158       libMesh::out << "[" << this->processor_id() << "] node_cmap_node_cnts = ";
1159       for (unsigned i=0; i<node_cmap_node_cnts\&.size(); ++i)
1160         libMesh::out << node_cmap_node_cnts[i] << ", ";
1161       libMesh::out << std::endl;
1162 
1163       libMesh::out << "[" << this->processor_id() << "] node_cmap_ids = ";
1164       for (unsigned i=0; i<node_cmap_ids\&.size(); ++i)
1165         libMesh::out << node_cmap_ids[i] << ", ";
1166       libMesh::out << std::endl;
1167     }
1168 
1169   // For the elements, we have not yet computed all this information\&.\&.
1170   this->elem_cmap_elem_cnts\&.clear(); // Make sure we don't have any leftover information\&.\&.\&.
1171   this->elem_cmap_ids\&.clear();       // Make sure we don't have any leftover information\&.\&.\&.
1172   this->elem_cmap_elem_cnts\&.resize(this->num_elem_cmaps);
1173   this->elem_cmap_ids\&.resize(this->num_elem_cmaps);
1174 
1175   // Pack the elem_cmap_ids and elem_cmap_elem_cnts vectors
1176   {
1177     unsigned cnt=0; // Index into the vectors we're filling
1178     for (proc_border_elem_sets_iterator it = this->proc_border_elem_sets\&.begin();
1179          it != this->proc_border_elem_sets\&.end();
1180          ++it)
1181       {
1182         this->elem_cmap_ids[cnt] = (*it)\&.first; // The ID of the proc we communicate with
1183         this->elem_cmap_elem_cnts[cnt] = (*it)\&.second\&.size(); // The number of elems we communicate to/from that proc
1184         cnt++; // increment vector index!
1185       }
1186   }
1187 
1188   // Print the packed vectors we just filled
1189   if (verbose)
1190     {
1191       libMesh::out << "[" << this->processor_id() << "] elem_cmap_elem_cnts = ";
1192       for (unsigned i=0; i<elem_cmap_elem_cnts\&.size(); ++i)
1193         libMesh::out << elem_cmap_elem_cnts[i] << ", ";
1194       libMesh::out << std::endl;
1195 
1196       libMesh::out << "[" << this->processor_id() << "] elem_cmap_ids = ";
1197       for (unsigned i=0; i<elem_cmap_ids\&.size(); ++i)
1198         libMesh::out << elem_cmap_ids[i] << ", ";
1199       libMesh::out << std::endl;
1200     }
1201 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_elem_communication_maps ()\fC [private]\fP"
This function computes element communication maps (really just packs vectors) in preparation for writing them to file\&. 
.PP
Definition at line 980 of file nemesis_io_helper\&.C\&.
.PP
References elem_cmap_elem_ids, elem_cmap_ids, elem_cmap_proc_ids, elem_cmap_side_ids, libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus, num_elem_cmaps, and proc_border_elem_sets\&.
.PP
Referenced by initialize()\&.
.PP
.nf
981 {
982   // Make sure there is no leftover information
983   this->elem_cmap_elem_ids\&.clear();
984   this->elem_cmap_side_ids\&.clear();
985   this->elem_cmap_proc_ids\&.clear();
986 
987   // Allocate enough space for all our element maps
988   this->elem_cmap_elem_ids\&.resize(this->num_elem_cmaps);
989   this->elem_cmap_side_ids\&.resize(this->num_elem_cmaps);
990   this->elem_cmap_proc_ids\&.resize(this->num_elem_cmaps);
991   {
992     unsigned cnt=0; // Index into vectors
993     for (proc_border_elem_sets_iterator it=this->proc_border_elem_sets\&.begin();
994          it != this->proc_border_elem_sets\&.end();
995          ++it)
996       {
997         // Make sure the current elem_cmap_id matches the index in our map of node intersections
998         libmesh_assert_equal_to ( static_cast<unsigned>(this->elem_cmap_ids[cnt]), (*it)\&.first );
999 
1000         // Get reference to the set of IDs to be packed into the vector
1001         std::set<std::pair<unsigned,unsigned> >& elem_set = (*it)\&.second;
1002 
1003         // Resize the vectors to receive their payload
1004         this->elem_cmap_elem_ids[cnt]\&.resize(elem_set\&.size());
1005         this->elem_cmap_side_ids[cnt]\&.resize(elem_set\&.size());
1006         this->elem_cmap_proc_ids[cnt]\&.resize(elem_set\&.size());
1007 
1008         std::set<std::pair<unsigned,unsigned> >::iterator elem_set_iter = elem_set\&.begin();
1009 
1010         // Pack the vectors with elem IDs, side IDs, and processor IDs\&.
1011         for (unsigned j=0; j<this->elem_cmap_elem_ids[cnt]\&.size(); ++j, ++elem_set_iter)
1012           {
1013             this->elem_cmap_elem_ids[cnt][j] = libmesh_elem_num_to_exodus[(*elem_set_iter)\&.first];//  + 1; // Elem ID, Exodus is 1-based
1014             this->elem_cmap_side_ids[cnt][j] = (*elem_set_iter)\&.second;     // Side ID, this has already been converted above
1015             this->elem_cmap_proc_ids[cnt][j] = (*it)\&.first; // All have the same processor ID
1016           }
1017 
1018         cnt++;// increment vector index to go to next processor
1019       }
1020   } // end scope for packing
1021 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_element_maps ()\fC [private]\fP"
This function computes element maps (really just packs vectors) which map the elements to internal and border elements\&. 
.PP
Definition at line 951 of file nemesis_io_helper\&.C\&.
.PP
References border_elem_ids, elem_mapb, elem_mapi, internal_elem_ids, and libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus\&.
.PP
Referenced by initialize()\&.
.PP
.nf
952 {
953   // Make sure we don't have any leftover info
954   this->elem_mapi\&.clear();
955   this->elem_mapb\&.clear();
956 
957   // Copy set contents into vectors
958   this->elem_mapi\&.resize(this->internal_elem_ids\&.size());
959   this->elem_mapb\&.resize(this->border_elem_ids\&.size());
960 
961   {
962     unsigned cnt = 0;
963     for (std::set<unsigned>::iterator it=this->internal_elem_ids\&.begin();
964          it != this->internal_elem_ids\&.end();
965          ++it, ++cnt)
966       this->elem_mapi[cnt] = libmesh_elem_num_to_exodus[(*it)]; // + 1; // Exodus is 1-based!
967   }
968 
969   {
970     unsigned cnt = 0;
971     for (std::set<unsigned>::iterator it=this->border_elem_ids\&.begin();
972          it != this->border_elem_ids\&.end();
973          ++it, ++cnt)
974       this->elem_mapb[cnt] = libmesh_elem_num_to_exodus[(*it)]; // + 1; // Exodus is 1-based!
975   }
976 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function constructs the set of border and internal element IDs and internal node IDs present on the current mesh\&. 
.PP
Definition at line 1207 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), border_elem_ids, border_node_ids, libMesh::ExodusII_IO_Helper::Conversion::get_inverse_side_map(), libMesh::DofObject::id(), internal_elem_ids, internal_node_ids, libMesh::Elem::n_neighbors(), libMesh::Elem::n_nodes(), libMesh::Elem::neighbor(), libMesh::Elem::node(), nodes_attached_to_local_elems, num_border_elems, num_border_nodes, num_elem_cmaps, num_internal_elems, num_internal_nodes, libMesh::out, proc_border_elem_sets, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Elem::type(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1208 {
1209   // Set of all local, active element IDs\&.  After we have identified border element
1210   // IDs, the set_difference between this set and the border_elem_ids set will give us
1211   // the set of internal_elem_ids\&.
1212   std::set<unsigned> all_elem_ids;
1213 
1214   // A set of processor IDs which elements on this processor have as
1215   // neighbors\&.  The size of this set will determine the number of
1216   // element communication maps in Exodus\&.
1217   std::set<unsigned> neighboring_processor_ids;
1218 
1219   // Will be used to create conversion objects capable of mapping libmesh
1220   // element numberings into Nemesis numberings\&.
1221   ExodusII_IO_Helper::ElementMaps element_mapper;
1222 
1223   MeshBase::const_element_iterator elem_it = pmesh\&.active_local_elements_begin();
1224   MeshBase::const_element_iterator elem_end = pmesh\&.active_local_elements_end();
1225 
1226   for (; elem_it != elem_end; ++elem_it)
1227     {
1228       const Elem* elem = *elem_it;
1229 
1230       // Add this Elem's ID to all_elem_ids, later we will take the difference
1231       // between this set and the set of border_elem_ids, to get the set of
1232       // internal_elem_ids\&.
1233       all_elem_ids\&.insert(elem->id());
1234 
1235       // Will be set to true if element is determined to be a border element
1236       bool is_border_elem = false;
1237 
1238       // Construct a conversion object for this Element\&.  This will help us map
1239       // Libmesh numberings into Nemesis numberings for sides\&.
1240       ExodusII_IO_Helper::Conversion conv = element_mapper\&.assign_conversion(elem->type());
1241 
1242       // Add all this element's node IDs to the set of all node IDs\&.
1243       // The set of internal_node_ids will be the set difference between
1244       // the set of all nodes and the set of border nodes\&.
1245       //
1246       // In addition, if any node of a local node is listed in the
1247       // border nodes list, then this element goes into the proc_border_elem_sets\&.
1248       // Note that there is not a 1:1 correspondence between
1249       // border_elem_ids and the entries which go into proc_border_elem_sets\&.
1250       // The latter is for communication purposes, ie determining which elements
1251       // should be shared between processors\&.
1252       for (unsigned int node=0; node<elem->n_nodes(); ++node)
1253         {
1254           this->nodes_attached_to_local_elems\&.insert(elem->node(node));
1255         } // end loop over element's nodes
1256 
1257       // Loop over element's neighbors, see if it has a neighbor which is off-processor
1258       for (unsigned int n=0; n<elem->n_neighbors(); ++n)
1259         {
1260           if (elem->neighbor(n) != NULL)
1261             {
1262               unsigned neighbor_proc_id = elem->neighbor(n)->processor_id();
1263 
1264               // If my neighbor has a different processor ID, I must be a border element\&.
1265               // Also track the neighboring processor ID if it is are different from our processor ID
1266               if (neighbor_proc_id != this->processor_id())
1267                 {
1268                   is_border_elem = true;
1269                   neighboring_processor_ids\&.insert(neighbor_proc_id);
1270 
1271                   // Convert libmesh side(n) of this element into a side ID for Nemesis
1272                   unsigned nemesis_side_id = conv\&.get_inverse_side_map(n);
1273 
1274                   if (verbose)
1275                     libMesh::out << "[" << this->processor_id() << "] LibMesh side "
1276                                  << n
1277                                  << " mapped to (1-based) Exodus side "
1278                                  << nemesis_side_id
1279                                  << std::endl;
1280 
1281                   // Add this element's ID and the ID of the side which is on the boundary
1282                   // to the set of border elements for this processor\&.
1283                   // Note: if the set does not already exist, this creates it\&.
1284                   this->proc_border_elem_sets[ neighbor_proc_id ]\&.insert( std::make_pair(elem->id(), nemesis_side_id) );
1285                 }
1286             }
1287         } // end for loop over neighbors
1288 
1289       // If we're on a border element, add it to the set
1290       if (is_border_elem)
1291         this->border_elem_ids\&.insert( elem->id() );
1292 
1293     } // end for loop over active local elements
1294 
1295   // Take the set_difference between all elements and border elements to get internal
1296   // element IDs
1297   std::set_difference(all_elem_ids\&.begin(), all_elem_ids\&.end(),
1298                       this->border_elem_ids\&.begin(), this->border_elem_ids\&.end(),
1299                       std::inserter(this->internal_elem_ids, this->internal_elem_ids\&.end()));
1300 
1301   // Take the set_difference between all nodes and border nodes to get internal nodes
1302   std::set_difference(this->nodes_attached_to_local_elems\&.begin(), this->nodes_attached_to_local_elems\&.end(),
1303                       this->border_node_ids\&.begin(), this->border_node_ids\&.end(),
1304                       std::inserter(this->internal_node_ids, this->internal_node_ids\&.end()));
1305 
1306   if (verbose)
1307     {
1308       libMesh::out << "[" << this->processor_id() << "] neighboring_processor_ids = ";
1309       for (std::set<unsigned>::iterator it = neighboring_processor_ids\&.begin();
1310            it != neighboring_processor_ids\&.end();
1311            ++it)
1312         {
1313           libMesh::out << *it << " ";
1314         }
1315       libMesh::out << std::endl;
1316     }
1317 
1318   // The size of the neighboring_processor_ids set should be the number of element communication maps
1319   this->num_elem_cmaps = neighboring_processor_ids\&.size();
1320 
1321   if (verbose)
1322     libMesh::out << "[" << this->processor_id() << "] "
1323                  << "Number of neighboring processor IDs="
1324                  << this->num_elem_cmaps
1325                  << std::endl;
1326 
1327   if (verbose)
1328     {
1329       // Print out counts of border elements for each processor
1330       for (proc_border_elem_sets_iterator it=this->proc_border_elem_sets\&.begin();
1331            it != this->proc_border_elem_sets\&.end(); ++it)
1332         {
1333           libMesh::out << "[" << this->processor_id() << "] "
1334                        << "Proc "
1335                        << (*it)\&.first << " communicates "
1336                        << (*it)\&.second\&.size() << " elements\&." << std::endl;
1337         }
1338     }
1339 
1340   // Store the number of internal and border elements, and the number of internal nodes,
1341   // to be written to the Nemesis file\&.
1342   this->num_internal_elems = this->internal_elem_ids\&.size();
1343   this->num_border_elems = this->border_elem_ids\&.size();
1344   this->num_internal_nodes = this->internal_node_ids\&.size();
1345 
1346   if (verbose)
1347     {
1348       libMesh::out << "[" << this->processor_id() << "] num_internal_nodes=" << this->num_internal_nodes << std::endl;
1349       libMesh::out << "[" << this->processor_id() << "] num_border_nodes=" << this->num_border_nodes << std::endl;
1350       libMesh::out << "[" << this->processor_id() << "] num_border_elems=" << this->num_border_elems << std::endl;
1351       libMesh::out << "[" << this->processor_id() << "] num_internal_elems=" << this->num_internal_elems << std::endl;
1352     }
1353 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_node_communication_maps ()\fC [private]\fP"
Compute the node communcation maps (really just pack vectors) in preparation for writing them to file\&. 
.PP
Definition at line 1064 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus, node_cmap_ids, node_cmap_node_ids, node_cmap_proc_ids, num_node_cmaps, libMesh::out, proc_nodes_touched_intersections, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1065 {
1066   // Make sure there's no left-over information
1067   this->node_cmap_node_ids\&.clear();
1068   this->node_cmap_proc_ids\&.clear();
1069 
1070   // Allocate enough space for all our node maps
1071   this->node_cmap_node_ids\&.resize(this->num_node_cmaps);
1072   this->node_cmap_proc_ids\&.resize(this->num_node_cmaps);
1073   {
1074     unsigned cnt=0; // Index into vectors
1075     for (proc_nodes_touched_iterator it = this->proc_nodes_touched_intersections\&.begin();
1076          it != this->proc_nodes_touched_intersections\&.end();
1077          ++it)
1078       {
1079         // Make sure the current node_cmap_id matches the index in our map of node intersections
1080         libmesh_assert_equal_to ( static_cast<unsigned>(this->node_cmap_ids[cnt]), (*it)\&.first );
1081 
1082         // Get reference to the set of IDs to be packed into the vector\&.
1083         std::set<unsigned>& node_set = (*it)\&.second;
1084 
1085         //libMesh::out << "[" << this->processor_id() << "] node_set\&.size()=" << node_set\&.size() << std::endl;
1086 
1087         // Resize the vectors to receive their payload
1088         this->node_cmap_node_ids[cnt]\&.resize(node_set\&.size());
1089         this->node_cmap_proc_ids[cnt]\&.resize(node_set\&.size());
1090 
1091         std::set<unsigned>::iterator node_set_iter = node_set\&.begin();
1092 
1093         // Pack the vectors with node IDs and processor IDs\&.
1094         for (unsigned j=0; j<this->node_cmap_node_ids[cnt]\&.size(); ++j, ++node_set_iter)
1095           {
1096             this->node_cmap_node_ids[cnt][j] = this->libmesh_node_num_to_exodus[*node_set_iter];//(*node_set_iter) + 1; // Exodus is 1-based
1097             this->node_cmap_proc_ids[cnt][j] = (*it)\&.first;
1098           }
1099 
1100         cnt++;// increment vector index to go to next processor
1101       }
1102   } // end scope for packing
1103 
1104   // if (verbose)
1105   //   libMesh::out << "Done packing\&." << std::endl;
1106 
1107   // Print out the vectors we just packed
1108   if (verbose)
1109     {
1110       for (unsigned i=0; i<this->node_cmap_node_ids\&.size(); ++i)
1111         {
1112           libMesh::out << "[" << this->processor_id() << "] nodes communicated to proc "
1113                        << this->node_cmap_ids[i]
1114                        << " = ";
1115           for (unsigned j=0; j<this->node_cmap_node_ids[i]\&.size(); ++j)
1116             libMesh::out << this->node_cmap_node_ids[i][j] << " ";
1117           libMesh::out << std::endl;
1118         }
1119 
1120       for (unsigned i=0; i<this->node_cmap_node_ids\&.size(); ++i)
1121         {
1122           libMesh::out << "[" << this->processor_id() << "] processor ID node communicated to = ";
1123           for (unsigned j=0; j<this->node_cmap_proc_ids[i]\&.size(); ++j)
1124             libMesh::out << this->node_cmap_proc_ids[i][j] << " ";
1125           libMesh::out << std::endl;
1126         }
1127     }
1128 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_node_maps ()\fC [private]\fP"
Compute the node maps (really just pack vectors) which map the nodes to internal, border, and external nodes in the file\&. 
.PP
Definition at line 1027 of file nemesis_io_helper\&.C\&.
.PP
References border_node_ids, internal_node_ids, libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus, node_mapb, node_mape, and node_mapi\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1028 {
1029   // Make sure we don't have any leftover information
1030   this->node_mapi\&.clear();
1031   this->node_mapb\&.clear();
1032   this->node_mape\&.clear();
1033 
1034   // Make sure there's enough space to hold all our node IDs
1035   this->node_mapi\&.resize(this->internal_node_ids\&.size());
1036   this->node_mapb\&.resize(this->border_node_ids\&.size());
1037 
1038   // Copy set contents into vectors
1039   //
1040   // Can't use insert, since we are copying unsigned's into vector<int>\&.\&.\&.
1041   // this->node_mapi\&.insert(internal_node_ids\&.begin(), internal_node_ids\&.end());
1042   // this->node_mapb\&.insert(boundary_node_ids\&.begin(), boundary_node_ids\&.end());
1043   {
1044     unsigned cnt = 0;
1045     for (std::set<unsigned>::iterator it=this->internal_node_ids\&.begin();
1046          it != this->internal_node_ids\&.end();
1047          ++it, ++cnt)
1048       this->node_mapi[cnt] = this->libmesh_node_num_to_exodus[*it];// + 1; // Exodus is 1-based!
1049   }
1050 
1051   {
1052     unsigned cnt=0;
1053     for (std::set<unsigned>::iterator it=this->border_node_ids\&.begin();
1054          it != this->border_node_ids\&.end();
1055          ++it, ++cnt)
1056       this->node_mapb[cnt] = this->libmesh_node_num_to_exodus[*it];// + 1; // Exodus is 1-based!
1057   }
1058 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function uses global communication routines to determine the number of element blocks across the entire mesh\&. 
.PP
Definition at line 1584 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::Parallel::Communicator::allgather(), libMesh::ParallelObject::comm(), global_elem_blk_cnts, global_elem_blk_ids, local_subdomain_counts, num_elem_blks_global, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::Elem::subdomain_id(), libMesh::Parallel::Communicator::sum(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1585 {
1586   // 1\&.) Loop over active local elements, build up set of subdomain IDs\&.
1587   std::set<subdomain_id_type> global_subdomain_ids;
1588 
1589   // This map keeps track of the number of elements in each subdomain over all processors
1590   std::map<subdomain_id_type, unsigned> global_subdomain_counts;
1591 
1592   MeshBase::const_element_iterator elem_it = pmesh\&.active_local_elements_begin();
1593   MeshBase::const_element_iterator elem_end = pmesh\&.active_local_elements_end();
1594 
1595   for (; elem_it != elem_end; ++elem_it)
1596     {
1597       const Elem* elem = *elem_it;
1598 
1599       subdomain_id_type cur_subdomain = elem->subdomain_id();
1600 
1601       /*
1602       // We can't have a zero subdomain ID in Exodus (for some reason?)
1603       // so map zero subdomains to a max value\&.\&.\&.
1604       if (cur_subdomain == 0)
1605       cur_subdomain = std::numeric_limits<subdomain_id_type>::max();
1606       */
1607 
1608       global_subdomain_ids\&.insert(cur_subdomain);
1609 
1610       // Increment the count of elements in this subdomain
1611       global_subdomain_counts[cur_subdomain]++;
1612     }
1613 
1614   // We're next going to this->comm()\&.sum the subdomain counts, so save the local counts
1615   this->local_subdomain_counts = global_subdomain_counts;
1616 
1617   {
1618     // 2\&.) Copy local subdomain IDs into a vector for communication
1619     std::vector<subdomain_id_type> global_subdomain_ids_vector(global_subdomain_ids\&.begin(),
1620                                                                global_subdomain_ids\&.end());
1621 
1622     // 3\&.) Gather them into an enlarged vector
1623     this->comm()\&.allgather(global_subdomain_ids_vector);
1624 
1625     // 4\&.) Insert any new IDs into the set (any duplicates will be dropped)
1626     global_subdomain_ids\&.insert(global_subdomain_ids_vector\&.begin(),
1627                                 global_subdomain_ids_vector\&.end());
1628   }
1629 
1630   // 5\&.) Now global_subdomain_ids actually contains a global list of all subdomain IDs
1631   this->num_elem_blks_global = global_subdomain_ids\&.size();
1632 
1633   // Print the number of elements found locally in each subdomain
1634   if (verbose)
1635     {
1636       libMesh::out << "[" << this->processor_id() << "] ";
1637       for (std::map<subdomain_id_type, unsigned>::iterator it=global_subdomain_counts\&.begin();
1638            it != global_subdomain_counts\&.end();
1639            ++it)
1640         {
1641           libMesh::out << "ID: "
1642                        << static_cast<unsigned>((*it)\&.first)
1643                        << ", Count: " << (*it)\&.second << ", ";
1644         }
1645       libMesh::out << std::endl;
1646     }
1647 
1648   // 6\&.) this->comm()\&.sum up the number of elements in each block\&.  We know the global
1649   // subdomain IDs, so pack them into a vector one by one\&.  Use a vector of int since
1650   // that is what Nemesis wants
1651   this->global_elem_blk_cnts\&.resize(global_subdomain_ids\&.size());
1652 
1653   unsigned cnt=0;
1654   for (std::set<subdomain_id_type>::iterator it=global_subdomain_ids\&.begin();
1655        it != global_subdomain_ids\&.end(); ++it)
1656     {
1657       // Find the entry in the local map, note: if not found, will be created with 0 default value, which is OK\&.\&.\&.
1658       this->global_elem_blk_cnts[cnt++] = global_subdomain_counts[*it];
1659     }
1660 
1661   // Sum up subdomain counts from all processors
1662   this->comm()\&.sum(this->global_elem_blk_cnts);
1663 
1664   if (verbose)
1665     {
1666       libMesh::out << "[" << this->processor_id() << "] global_elem_blk_cnts = ";
1667       for (unsigned i=0; i<this->global_elem_blk_cnts\&.size(); ++i)
1668         libMesh::out << this->global_elem_blk_cnts[i] << ", ";
1669       libMesh::out << std::endl;
1670     }
1671 
1672   // 7\&.) Create a vector<int> from the global_subdomain_ids set, for passing to Nemesis
1673   this->global_elem_blk_ids\&.clear();
1674   this->global_elem_blk_ids\&.insert(this->global_elem_blk_ids\&.end(), // pos
1675                                    global_subdomain_ids\&.begin(),
1676                                    global_subdomain_ids\&.end());
1677 
1678   if (verbose)
1679     {
1680       libMesh::out << "[" << this->processor_id() << "] global_elem_blk_ids = ";
1681       for (unsigned i=0; i<this->global_elem_blk_ids\&.size(); ++i)
1682         libMesh::out << this->global_elem_blk_ids[i] << ", ";
1683       libMesh::out << std::endl;
1684     }
1685 
1686 
1687   // 8\&.) We will call put_eb_info_global later, it must be called after this->put_init_global()\&.
1688 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_num_global_nodesets (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function uses global communication routines to determine the number of nodesets across the entire mesh\&. 
.PP
Definition at line 1464 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::boundary_info, libMesh::ParallelObject::comm(), global_nodeset_ids, libMesh::MeshBase::node_ptr(), num_global_node_counts, num_node_sets_global, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Parallel::Communicator::set_union(), libMesh::Parallel::Communicator::sum(), libMesh::swap(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1465 {
1466   std::set<boundary_id_type> local_node_boundary_ids;
1467 
1468   // 1\&.) Get reference to the set of node boundary IDs *for this processor*
1469   std::set<boundary_id_type> global_node_boundary_ids
1470     (pmesh\&.boundary_info->get_node_boundary_ids()\&.begin(),
1471      pmesh\&.boundary_info->get_node_boundary_ids()\&.end());
1472 
1473   // Save a copy of the local_node_boundary_ids\&.\&.\&.
1474   local_node_boundary_ids = global_node_boundary_ids;
1475 
1476   // 2\&.) Gather boundary node IDs from other processors
1477   this->comm()\&.set_union(global_node_boundary_ids);
1478 
1479   // 3\&.) Now global_node_boundary_ids actually contains a global list of all node boundary IDs
1480   this->num_node_sets_global = global_node_boundary_ids\&.size();
1481 
1482   // 4\&.) Create a vector<int> from the global_node_boundary_ids set
1483   this->global_nodeset_ids\&.clear();
1484   this->global_nodeset_ids\&.insert(this->global_nodeset_ids\&.end(),
1485                                   global_node_boundary_ids\&.begin(),
1486                                   global_node_boundary_ids\&.end());
1487 
1488   if (verbose)
1489     {
1490       libMesh::out << "[" << this->processor_id() << "] global_nodeset_ids = ";
1491       for (unsigned i=0; i<global_nodeset_ids\&.size(); ++i)
1492         libMesh::out << global_nodeset_ids[i] << ", ";
1493       libMesh::out << std::endl;
1494 
1495       libMesh::out << "[" << this->processor_id() << "] local_node_boundary_ids = ";
1496       for (std::set<boundary_id_type>::iterator it = local_node_boundary_ids\&.begin();
1497            it != local_node_boundary_ids\&.end();
1498            ++it)
1499         libMesh::out << *it << ", ";
1500       libMesh::out << std::endl;
1501     }
1502 
1503   // 7\&.) We also need to know the number of nodes which is in each of the nodesets, globally\&.
1504   // There is probably a better way to do this\&.\&.\&.
1505   std::vector<dof_id_type> boundary_node_list;
1506   std::vector<boundary_id_type> boundary_node_boundary_id_list;
1507   pmesh\&.boundary_info->build_node_list(boundary_node_list, boundary_node_boundary_id_list);
1508 
1509   if (verbose)
1510     {
1511       libMesh::out << "[" << this->processor_id() << "] boundary_node_list\&.size()="
1512                    << boundary_node_list\&.size() << std::endl;
1513       libMesh::out << "[" << this->processor_id() << "] (boundary_node_id, boundary_id) = ";
1514       for (unsigned i=0; i<boundary_node_list\&.size(); ++i)
1515         {
1516           libMesh::out << "(" << boundary_node_list[i] << ", " << boundary_node_boundary_id_list[i] << ") ";
1517         }
1518       libMesh::out << std::endl;
1519     }
1520 
1521   // Now get the global information\&.  In this case, we only want to count boundary
1522   // information for nodes *owned* by this processor, so there are no duplicates\&.
1523 
1524   // Make sure we don't have any left over information
1525   this->num_global_node_counts\&.clear();
1526   this->num_global_node_counts\&.resize(this->global_nodeset_ids\&.size());
1527 
1528   // Unfortunately, we can't just count up all occurrences of a given id,
1529   // that would give us duplicate entries when we do the parallel summation\&.
1530   // So instead, only count entries for nodes owned by this processor\&.
1531   // Start by getting rid of all non-local node entries from the vectors\&.
1532   std::vector<dof_id_type>::iterator it_node=boundary_node_list\&.begin();
1533   std::vector<boundary_id_type>::iterator it_id=boundary_node_boundary_id_list\&.begin();
1534 
1535   // New end iterators, to be updated as we find non-local IDs
1536   std::vector<dof_id_type>::iterator new_node_list_end = boundary_node_list\&.end();
1537   std::vector<boundary_id_type>::iterator new_boundary_id_list_end = boundary_node_boundary_id_list\&.end();
1538   for ( ; it_node != new_node_list_end; )
1539     {
1540       if (pmesh\&.node_ptr( *it_node )->processor_id() != this->processor_id())
1541         {
1542           // Back up the new end iterators to prepare for swap
1543           --new_node_list_end;
1544           --new_boundary_id_list_end;
1545 
1546           // Swap places, the non-local node will now be "past-the-end"
1547           std::swap (*it_node, *new_node_list_end);
1548           std::swap (*it_id, *new_boundary_id_list_end);
1549         }
1550       else // node is local, go to next
1551         {
1552           ++it_node;
1553           ++it_id;
1554         }
1555     }
1556 
1557   // Erase from "new" end to old end on each vector\&.
1558   boundary_node_list\&.erase(new_node_list_end, boundary_node_list\&.end());
1559   boundary_node_boundary_id_list\&.erase(new_boundary_id_list_end, boundary_node_boundary_id_list\&.end());
1560 
1561   // Now we can do the local count for each ID\&.\&.\&.
1562   for (unsigned i=0; i<global_nodeset_ids\&.size(); ++i)
1563     {
1564       this->num_global_node_counts[i] = std::count(boundary_node_boundary_id_list\&.begin(),
1565                                                    boundary_node_boundary_id_list\&.end(),
1566                                                    this->global_nodeset_ids[i]);
1567     }
1568 
1569   // And finally we can sum them up
1570   this->comm()\&.sum(this->num_global_node_counts);
1571 
1572   if (verbose)
1573     {
1574       libMesh::out << "[" << this->processor_id() << "] num_global_node_counts = ";
1575       for (unsigned i=0; i<num_global_node_counts\&.size(); ++i)
1576         libMesh::out << num_global_node_counts[i] << ", ";
1577       libMesh::out << std::endl;
1578     }
1579 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::compute_num_global_sidesets (const \fBMeshBase\fP &pmesh)\fC [private]\fP"
This function uses global communication routines to determine the number of sidesets across the entire mesh\&. 
.PP
Definition at line 1357 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::boundary_info, libMesh::ParallelObject::comm(), libMesh::MeshBase::elem(), global_sideset_ids, num_global_side_counts, num_side_sets_global, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Parallel::Communicator::set_union(), libMesh::Parallel::Communicator::sum(), libMesh::swap(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
1358 {
1359   // 1\&.) Get reference to the set of side boundary IDs
1360   std::set<boundary_id_type> global_side_boundary_ids
1361     (pmesh\&.boundary_info->get_side_boundary_ids()\&.begin(),
1362      pmesh\&.boundary_info->get_side_boundary_ids()\&.end());
1363 
1364   // 2\&.) Gather boundary side IDs from other processors
1365   this->comm()\&.set_union(global_side_boundary_ids);
1366 
1367   // 3\&.) Now global_side_boundary_ids actually contains a global list of all side boundary IDs
1368   this->num_side_sets_global = global_side_boundary_ids\&.size();
1369 
1370   // 4\&.) Pack these sidesets into a vector so they can be written by Nemesis
1371   this->global_sideset_ids\&.clear(); // Make sure there is no leftover information
1372   this->global_sideset_ids\&.insert(this->global_sideset_ids\&.end(),
1373                                   global_side_boundary_ids\&.begin(),
1374                                   global_side_boundary_ids\&.end());
1375 
1376   if (verbose)
1377     {
1378       libMesh::out << "[" << this->processor_id() << "] global_sideset_ids = ";
1379       for (unsigned i=0; i<this->global_sideset_ids\&.size(); ++i)
1380         libMesh::out << this->global_sideset_ids[i] << ", ";
1381       libMesh::out << std::endl;
1382     }
1383 
1384   // We also need global counts of sides in each of the sidesets\&.  Again, there may be a
1385   // better way to do this\&.\&.\&.
1386   std::vector<dof_id_type> bndry_elem_list;
1387   std::vector<unsigned short int> bndry_side_list;
1388   std::vector<boundary_id_type> bndry_id_list;
1389   pmesh\&.boundary_info->build_side_list(bndry_elem_list, bndry_side_list, bndry_id_list);
1390 
1391   // Similarly to the nodes, we can't count any sides for elements which aren't local
1392   std::vector<dof_id_type>::iterator it_elem=bndry_elem_list\&.begin();
1393   std::vector<unsigned short>::iterator it_side=bndry_side_list\&.begin();
1394   std::vector<boundary_id_type>::iterator it_id=bndry_id_list\&.begin();
1395 
1396   // New end iterators, to be updated as we find non-local IDs
1397   std::vector<dof_id_type>::iterator new_bndry_elem_list_end = bndry_elem_list\&.end();
1398   std::vector<unsigned short>::iterator new_bndry_side_list_end = bndry_side_list\&.end();
1399   std::vector<boundary_id_type>::iterator new_bndry_id_list_end = bndry_id_list\&.end();
1400 
1401   for ( ; it_elem != new_bndry_elem_list_end; )
1402     {
1403       if (pmesh\&.elem( *it_elem )->processor_id() != this->processor_id())
1404         {
1405           // Back up the new end iterators to prepare for swap
1406           --new_bndry_elem_list_end;
1407           --new_bndry_side_list_end;
1408           --new_bndry_id_list_end;
1409 
1410           // Swap places, the non-local elem will now be "past-the-end"
1411           std::swap (*it_elem, *new_bndry_elem_list_end);
1412           std::swap (*it_side, *new_bndry_side_list_end);
1413           std::swap (*it_id, *new_bndry_id_list_end);
1414         }
1415       else // elem is local, go to next
1416         {
1417           ++it_elem;
1418           ++it_side;
1419           ++it_id;
1420         }
1421     }
1422 
1423   // Erase from "new" end to old end on each vector\&.
1424   bndry_elem_list\&.erase(new_bndry_elem_list_end, bndry_elem_list\&.end());
1425   bndry_side_list\&.erase(new_bndry_side_list_end, bndry_side_list\&.end());
1426   bndry_id_list\&.erase(new_bndry_id_list_end, bndry_id_list\&.end());
1427 
1428   this->num_global_side_counts\&.clear(); // Make sure we don't have any leftover information
1429   this->num_global_side_counts\&.resize(this->global_sideset_ids\&.size());
1430 
1431   // Get the count for each global sideset ID
1432   for (unsigned i=0; i<global_sideset_ids\&.size(); ++i)
1433     {
1434       this->num_global_side_counts[i] = std::count(bndry_id_list\&.begin(),
1435                                                    bndry_id_list\&.end(),
1436                                                    this->global_sideset_ids[i]);
1437     }
1438 
1439   if (verbose)
1440     {
1441       libMesh::out << "[" << this->processor_id() << "] num_global_side_counts = ";
1442       for (unsigned i=0; i<this->num_global_side_counts\&.size(); ++i)
1443         libMesh::out << this->num_global_side_counts[i] << ", ";
1444       libMesh::out << std::endl;
1445     }
1446 
1447   // Finally sum up the result
1448   this->comm()\&.sum(this->num_global_side_counts);
1449 
1450   if (verbose)
1451     {
1452       libMesh::out << "[" << this->processor_id() << "] num_global_side_counts = ";
1453       for (unsigned i=0; i<this->num_global_side_counts\&.size(); ++i)
1454         libMesh::out << this->num_global_side_counts[i] << ", ";
1455       libMesh::out << std::endl;
1456     }
1457 }
.fi
.SS "std::string libMesh::Nemesis_IO_Helper::construct_nemesis_filename (const std::string &base_filename)"
Given base_filename, foo\&.e, constructs the \fBNemesis\fP filename foo\&.e\&.X\&.Y, where X=n\&. CPUs and Y=processor ID 
.PP
Definition at line 2458 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ParallelObject::n_processors(), libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2459 {
2460   // Build a filename for this processor\&.  This code is cut-n-pasted from the read function
2461   // and should probably be put into a separate function\&.\&.\&.
2462   std::ostringstream file_oss;
2463 
2464   // We have to be a little careful here: Nemesis left pads its file
2465   // numbers based on the number of processors, so for example on 10
2466   // processors, we'd have:
2467   // mesh\&.e\&.10\&.00
2468   // mesh\&.e\&.10\&.01
2469   // mesh\&.e\&.10\&.02
2470   // \&.\&.\&.
2471   // mesh\&.e\&.10\&.09
2472 
2473   // And on 100 you'd have:
2474   // mesh\&.e\&.100\&.000
2475   // mesh\&.e\&.100\&.001
2476   // \&.\&.\&.
2477   // mesh\&.e\&.128\&.099
2478 
2479   // Find the length of the highest processor ID
2480   file_oss << (this->n_processors());
2481   unsigned field_width = file_oss\&.str()\&.size();
2482 
2483   if (verbose)
2484     libMesh::out << "field_width=" << field_width << std::endl;
2485 
2486   file_oss\&.str(""); // reset the string stream
2487   file_oss << base_filename
2488            << '\&.' << this->n_processors()
2489            << '\&.' << std::setfill('0') << std::setw(field_width) << this->processor_id();
2490 
2491   // Return the resulting string
2492   return file_oss\&.str();
2493 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::create (std::stringfilename)\fC [virtual]\fP"
This function is specialized from \fBExodusII_IO_Helper\fP to create the nodal coordinates stored on the local piece of the \fBMesh\fP\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 709 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_single_precision, libMesh::ExodusII_IO_Helper::ex_id, std::min(), libMesh::ExodusII_IO_Helper::opened_for_writing, libMesh::out, libMesh::Real, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
710 {
711   // Fall back on double precision when necessary since ExodusII
712   // doesn't seem to support long double
713   int
714     comp_ws = 0,
715     io_ws = 0;
716 
717   if(_single_precision)
718     {
719       comp_ws = sizeof(float);
720       io_ws = sizeof(float);
721     }
722   else
723     {
724       comp_ws = libmesh_cast_int<int>(std::min(sizeof(Real), sizeof(double)));
725       io_ws = libmesh_cast_int<int>(std::min(sizeof(Real), sizeof(double)));
726     }
727 
728   this->ex_id = exII::ex_create(filename\&.c_str(), EX_CLOBBER, &comp_ws, &io_ws);
729 
730   EX_CHECK_ERR(ex_id, "Error creating Nemesis mesh file\&.");
731 
732   if (verbose)
733     libMesh::out << "File created successfully\&." << std::endl;
734 
735   this->opened_for_writing = true;
736 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_block_id (intindex)\fC [inherited]\fP"
Get the block number for the given block index\&. 
.PP
Definition at line 444 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::block_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read(), and libMesh::ExodusII_IO_Helper::write_element_values()\&.
.PP
.nf
445 {
446   libmesh_assert_less (static_cast<unsigned int>(index), block_ids\&.size());
447 
448   return block_ids[index];
449 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_block_name (intindex)\fC [inherited]\fP"
Get the block name for the given block index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 453 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::block_ids, and libMesh::ExodusII_IO_Helper::id_to_block_names\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
454 {
455   libmesh_assert_less (static_cast<unsigned int>(index), block_ids\&.size());
456 
457   return id_to_block_names[block_ids[index]];
458 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_cmap_params ()"

.PP
Definition at line 317 of file nemesis_io_helper\&.C\&.
.PP
References elem_cmap_elem_cnts, elem_cmap_ids, libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, node_cmap_ids, node_cmap_node_cnts, num_elem_cmaps, num_node_cmaps, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
318 {
319   node_cmap_ids\&.resize(num_node_cmaps);
320   node_cmap_node_cnts\&.resize(num_node_cmaps);
321   elem_cmap_ids\&.resize(num_elem_cmaps);
322   elem_cmap_elem_cnts\&.resize(num_elem_cmaps);
323 
324   nemesis_err_flag =
325     Nemesis::ne_get_cmap_params(ex_id,
326                                 node_cmap_ids\&.empty()       ? NULL : &node_cmap_ids[0],
327                                 node_cmap_node_cnts\&.empty() ? NULL : &node_cmap_node_cnts[0],
328                                 elem_cmap_ids\&.empty()       ? NULL : &elem_cmap_ids[0],
329                                 elem_cmap_elem_cnts\&.empty() ? NULL : &elem_cmap_elem_cnts[0],
330                                 this->processor_id());
331   EX_CHECK_ERR(nemesis_err_flag, "Error reading cmap parameters!");
332 
333 
334   if (verbose)
335     {
336       libMesh::out << "[" << this->processor_id() << "] ";
337       for (unsigned int i=0; i<node_cmap_ids\&.size(); ++i)
338         libMesh::out << "node_cmap_ids["<<i<<"]=" << node_cmap_ids[i] << " ";
339       libMesh::out << std::endl;
340 
341       libMesh::out << "[" << this->processor_id() << "] ";
342       for (unsigned int i=0; i<node_cmap_node_cnts\&.size(); ++i)
343         libMesh::out << "node_cmap_node_cnts["<<i<<"]=" << node_cmap_node_cnts[i] << " ";
344       libMesh::out << std::endl;
345 
346       libMesh::out << "[" << this->processor_id() << "] ";
347       for (unsigned int i=0; i<elem_cmap_ids\&.size(); ++i)
348         libMesh::out << "elem_cmap_ids["<<i<<"]=" << elem_cmap_ids[i] << " ";
349       libMesh::out << std::endl;
350 
351       libMesh::out << "[" << this->processor_id() << "] ";
352       for (unsigned int i=0; i<elem_cmap_elem_cnts\&.size(); ++i)
353         libMesh::out << "elem_cmap_elem_cnts["<<i<<"]=" << elem_cmap_elem_cnts[i] << " ";
354       libMesh::out << std::endl;
355     }
356 }
.fi
.SS "std::vector< std::string > libMesh::ExodusII_IO_Helper::get_complex_names (const std::vector< std::string > &names) const\fC [inherited]\fP"
Returns a vector with three copies of each element in the provided name vector, starting with r_, i_ and a_ respectively\&. 
.PP
Definition at line 1786 of file exodusII_io_helper\&.C\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data(), libMesh::Nemesis_IO::write_global_data(), libMesh::ExodusII_IO::write_global_data(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.PP
.nf
1787 {
1788   std::vector<std::string>::const_iterator names_it = names\&.begin();
1789   std::vector<std::string>::const_iterator names_end = names\&.end();
1790 
1791   std::vector<std::string> complex_names;
1792 
1793   // This will loop over all names and create new "complex" names
1794   // (i\&.e\&. names that start with r_, i_ or a_
1795   for (; names_it != names_end; ++names_it)
1796     {
1797       std::cout << "VARIABLE: " << *names_it << std::endl;
1798       std::stringstream name_real, name_imag, name_abs;
1799       name_real << "r_" << *names_it;
1800       name_imag << "i_" << *names_it;
1801       name_abs << "a_" << *names_it;
1802 
1803       complex_names\&.push_back(name_real\&.str());
1804       complex_names\&.push_back(name_imag\&.str());
1805       complex_names\&.push_back(name_abs\&.str());
1806     }
1807 
1808   return complex_names;
1809 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_eb_info_global ()"

.PP
Definition at line 169 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, global_elem_blk_cnts, global_elem_blk_ids, nemesis_err_flag, num_elem_blks_global, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
170 {
171   global_elem_blk_ids\&.resize(num_elem_blks_global);
172   global_elem_blk_cnts\&.resize(num_elem_blks_global);
173 
174   nemesis_err_flag =
175     Nemesis::ne_get_eb_info_global(ex_id,
176                                    global_elem_blk_ids\&.empty()  ? NULL : &global_elem_blk_ids[0],
177                                    global_elem_blk_cnts\&.empty() ? NULL : &global_elem_blk_cnts[0]);
178   EX_CHECK_ERR(nemesis_err_flag, "Error reading global element block info!");
179 
180   if (verbose)
181     {
182       libMesh::out << "[" << this->processor_id() << "] " << "Global Element Block IDs and Counts:" << std::endl;
183       for (unsigned int bn=0; bn<global_elem_blk_ids\&.size(); ++bn)
184         {
185           libMesh::out << "  [" << this->processor_id() << "] "
186                        << "global_elem_blk_ids["<<bn<<"]=" << global_elem_blk_ids[bn]
187                        << ", global_elem_blk_cnts["<<bn<<"]=" << global_elem_blk_cnts[bn]
188                        << std::endl;
189         }
190     }
191 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_elem_cmap ()"

.PP
Definition at line 397 of file nemesis_io_helper\&.C\&.
.PP
References elem_cmap_elem_cnts, elem_cmap_elem_ids, elem_cmap_ids, elem_cmap_proc_ids, elem_cmap_side_ids, libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, num_elem_cmaps, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
398 {
399   elem_cmap_elem_ids\&.resize(num_elem_cmaps);
400   elem_cmap_side_ids\&.resize(num_elem_cmaps);
401   elem_cmap_proc_ids\&.resize(num_elem_cmaps);
402 
403   for (unsigned int i=0; i<elem_cmap_elem_ids\&.size(); ++i)
404     {
405       elem_cmap_elem_ids[i]\&.resize(elem_cmap_elem_cnts[i]);
406       elem_cmap_side_ids[i]\&.resize(elem_cmap_elem_cnts[i]);
407       elem_cmap_proc_ids[i]\&.resize(elem_cmap_elem_cnts[i]);
408 
409       nemesis_err_flag =
410         Nemesis::ne_get_elem_cmap(ex_id,
411                                   elem_cmap_ids\&.empty()         ? 0    : elem_cmap_ids[i],
412                                   elem_cmap_elem_ids[i]\&.empty() ? NULL : &elem_cmap_elem_ids[i][0],
413                                   elem_cmap_side_ids[i]\&.empty() ? NULL : &elem_cmap_side_ids[i][0],
414                                   elem_cmap_proc_ids[i]\&.empty() ? NULL : &elem_cmap_proc_ids[i][0],
415                                   this->processor_id());
416       EX_CHECK_ERR(nemesis_err_flag, "Error reading elem cmap elem, side, and processor ids!");
417 
418 
419       if (verbose)
420         {
421           libMesh::out << "[" << this->processor_id() << "] elem_cmap_elem_ids["<<i<<"]=";
422           for (unsigned int j=0; j<elem_cmap_elem_ids[i]\&.size(); ++j)
423             libMesh::out << elem_cmap_elem_ids[i][j] << " ";
424           libMesh::out << std::endl;
425 
426           // These must be the (local) side IDs (in the ExodusII face numbering scheme)
427           // of the sides shared across processors\&.
428           libMesh::out << "[" << this->processor_id() << "] elem_cmap_side_ids["<<i<<"]=";
429           for (unsigned int j=0; j<elem_cmap_side_ids[i]\&.size(); ++j)
430             libMesh::out << elem_cmap_side_ids[i][j] << " ";
431           libMesh::out << std::endl;
432 
433           // This is basically a vector, all entries of which are = elem_cmap_ids[i]
434           // Not sure if it's always guaranteed to be that or what\&.\&.\&.
435           libMesh::out << "[" << this->processor_id() << "] elem_cmap_proc_ids["<<i<<"]=";
436           for (unsigned int j=0; j<elem_cmap_proc_ids[i]\&.size(); ++j)
437             libMesh::out << elem_cmap_proc_ids[i][j] << " ";
438           libMesh::out << std::endl;
439         }
440     }
441 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_elem_map ()"

.PP
Definition at line 244 of file nemesis_io_helper\&.C\&.
.PP
References elem_mapb, elem_mapi, libMesh::ExodusII_IO_Helper::ex_id, std::min(), nemesis_err_flag, num_border_elems, num_internal_elems, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
.nf
245 {
246   elem_mapi\&.resize(num_internal_elems);
247   elem_mapb\&.resize(num_border_elems);
248 
249   nemesis_err_flag =
250     Nemesis::ne_get_elem_map(ex_id,
251                              elem_mapi\&.empty() ? NULL : &elem_mapi[0],
252                              elem_mapb\&.empty() ? NULL : &elem_mapb[0],
253                              this->processor_id()
254                              );
255   EX_CHECK_ERR(nemesis_err_flag, "Error reading element maps!");
256 
257 
258   if (verbose)
259     {
260       // These are not contiguous ranges\&.\&.\&.\&.
261       //libMesh::out << "[" << this->processor_id() << "] " << "first interior elem id=" << elem_mapi[0] << std::endl;
262       //libMesh::out << "[" << this->processor_id() << "] " << "last interior elem id=" << elem_mapi\&.back() << std::endl;
263       //libMesh::out << "[" << this->processor_id() << "] " << "first boundary elem id=" << elem_mapb[0] << std::endl;
264       //libMesh::out << "[" << this->processor_id() << "] " << "last boundary elem id=" << elem_mapb\&.back() << std::endl;
265       libMesh::out << "[" << this->processor_id() << "] elem_mapi[i] = ";
266       for (unsigned int i=0; i< static_cast<unsigned int>(num_internal_elems-1); ++i)
267         libMesh::out << elem_mapi[i] << ", ";
268       libMesh::out << "\&.\&.\&. " << elem_mapi\&.back() << std::endl;
269 
270       libMesh::out << "[" << this->processor_id() << "] elem_mapb[i] = ";
271       for (unsigned int i=0; i< static_cast<unsigned int>(std::min(10, num_border_elems-1)); ++i)
272         libMesh::out << elem_mapb[i] << ", ";
273       libMesh::out << "\&.\&.\&. " << elem_mapb\&.back() << std::endl;
274     }
275 }
.fi
.SS "const char * libMesh::ExodusII_IO_Helper::get_elem_type () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the current element type\&. Note: the default behavior is for this value to be in all capital letters, e\&.g\&. \fCHEX27\fP\&. 
.RE
.PP

.PP
Definition at line 273 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::elem_type\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
274 {
275   return &elem_type[0];
276 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_init_global ()"
Reading functions\&. These just allocate memory for you and call the \fBNemesis\fP routines of the same name\&. They also handle error checking for the \fBNemesis\fP return value\&. Be careful calling these at random, some depend on others being called first\&.\&.\&. Fills: num_nodes_global, num_elems_global, num_elem_blks_global, num_node_sets_global, num_side_sets_global Call after: \fBread_header()\fP Call before: Any other get_* function from this class 
.PP
Definition at line 78 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, num_elem_blks_global, num_elems_global, num_node_sets_global, num_nodes_global, num_side_sets_global, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
79 {
80   nemesis_err_flag =
81     Nemesis::ne_get_init_global(ex_id,
82                                 &num_nodes_global,
83                                 &num_elems_global,
84                                 &num_elem_blks_global,
85                                 &num_node_sets_global,
86                                 &num_side_sets_global);
87   EX_CHECK_ERR(nemesis_err_flag, "Error reading initial global data!");
88 
89   if (verbose)
90     {
91       libMesh::out << "[" << this->processor_id() << "] " << "num_nodes_global=" << num_nodes_global << std::endl;
92       libMesh::out << "[" << this->processor_id() << "] " << "num_elems_global=" << num_elems_global << std::endl;
93       libMesh::out << "[" << this->processor_id() << "] " << "num_elem_blks_global=" << num_elem_blks_global << std::endl;
94       libMesh::out << "[" << this->processor_id() << "] " << "num_node_sets_global=" << num_node_sets_global << std::endl;
95       libMesh::out << "[" << this->processor_id() << "] " << "num_side_sets_global=" << num_side_sets_global << std::endl;
96     }
97 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_init_info ()"

.PP
Definition at line 195 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, ftype, nemesis_err_flag, num_proc, num_proc_in_file, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
.nf
196 {
197   nemesis_err_flag =
198     Nemesis::ne_get_init_info(ex_id,
199                               &num_proc,
200                               &num_proc_in_file,
201                               &ftype);
202   EX_CHECK_ERR(nemesis_err_flag, "Error reading initial info!");
203 
204   if (verbose)
205     {
206       libMesh::out << "[" << this->processor_id() << "] " << "num_proc=" << num_proc << std::endl;
207       libMesh::out << "[" << this->processor_id() << "] " << "num_proc_in_file=" << num_proc_in_file << std::endl;
208       libMesh::out << "[" << this->processor_id() << "] " << "ftype=" << ftype << std::endl;
209     }
210 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_loadbal_param ()"

.PP
Definition at line 214 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, num_border_elems, num_border_nodes, num_elem_cmaps, num_external_nodes, num_internal_elems, num_internal_nodes, num_node_cmaps, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
215 {
216   nemesis_err_flag =
217     Nemesis::ne_get_loadbal_param(ex_id,
218                                   &num_internal_nodes,
219                                   &num_border_nodes,
220                                   &num_external_nodes,
221                                   &num_internal_elems,
222                                   &num_border_elems,
223                                   &num_node_cmaps,
224                                   &num_elem_cmaps,
225                                   this->processor_id() // The ID of the processor for which info is to be read
226                                   );
227   EX_CHECK_ERR(nemesis_err_flag, "Error reading load balance parameters!");
228 
229 
230   if (verbose)
231     {
232       libMesh::out << "[" << this->processor_id() << "] " << "num_internal_nodes=" << num_internal_nodes << std::endl;
233       libMesh::out << "[" << this->processor_id() << "] " << "num_border_nodes=" << num_border_nodes << std::endl;
234       libMesh::out << "[" << this->processor_id() << "] " << "num_external_nodes=" << num_external_nodes << std::endl;
235       libMesh::out << "[" << this->processor_id() << "] " << "num_internal_elems=" << num_internal_elems << std::endl;
236       libMesh::out << "[" << this->processor_id() << "] " << "num_border_elems=" << num_border_elems << std::endl;
237       libMesh::out << "[" << this->processor_id() << "] " << "num_node_cmaps=" << num_node_cmaps << std::endl;
238       libMesh::out << "[" << this->processor_id() << "] " << "num_elem_cmaps=" << num_elem_cmaps << std::endl;
239     }
240 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_node_cmap ()"

.PP
Definition at line 360 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, node_cmap_ids, node_cmap_node_cnts, node_cmap_node_ids, node_cmap_proc_ids, num_node_cmaps, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
361 {
362   node_cmap_node_ids\&.resize(num_node_cmaps);
363   node_cmap_proc_ids\&.resize(num_node_cmaps);
364 
365   for (unsigned int i=0; i<node_cmap_node_ids\&.size(); ++i)
366     {
367       node_cmap_node_ids[i]\&.resize(node_cmap_node_cnts[i]);
368       node_cmap_proc_ids[i]\&.resize(node_cmap_node_cnts[i]);
369 
370       nemesis_err_flag =
371         Nemesis::ne_get_node_cmap(ex_id,
372                                   node_cmap_ids\&.empty()         ? 0    : node_cmap_ids[i],
373                                   node_cmap_node_ids[i]\&.empty() ? NULL : &node_cmap_node_ids[i][0],
374                                   node_cmap_proc_ids[i]\&.empty() ? NULL : &node_cmap_proc_ids[i][0],
375                                   this->processor_id());
376       EX_CHECK_ERR(nemesis_err_flag, "Error reading node cmap node and processor ids!");
377 
378       if (verbose)
379         {
380           libMesh::out << "[" << this->processor_id() << "] node_cmap_node_ids["<<i<<"]=";
381           for (unsigned int j=0; j<node_cmap_node_ids[i]\&.size(); ++j)
382             libMesh::out << node_cmap_node_ids[i][j] << " ";
383           libMesh::out << std::endl;
384 
385           // This is basically a vector, all entries of which are = node_cmap_ids[i]
386           // Not sure if it's always guaranteed to be that or what\&.\&.\&.
387           libMesh::out << "[" << this->processor_id() << "] node_cmap_proc_ids["<<i<<"]=";
388           for (unsigned int j=0; j<node_cmap_proc_ids[i]\&.size(); ++j)
389             libMesh::out << node_cmap_proc_ids[i][j] << " ";
390           libMesh::out << std::endl;
391         }
392     }
393 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_node_map ()"

.PP
Definition at line 280 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, node_mapb, node_mape, node_mapi, num_border_nodes, num_external_nodes, num_internal_nodes, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
281 {
282   node_mapi\&.resize(num_internal_nodes);
283   node_mapb\&.resize(num_border_nodes);
284   node_mape\&.resize(num_external_nodes);
285 
286   nemesis_err_flag =
287     Nemesis::ne_get_node_map(ex_id,
288                              node_mapi\&.empty() ? NULL : &node_mapi[0],
289                              node_mapb\&.empty() ? NULL : &node_mapb[0],
290                              node_mape\&.empty() ? NULL : &node_mape[0],
291                              this->processor_id()
292                              );
293   EX_CHECK_ERR(nemesis_err_flag, "Error reading node maps!");
294 
295   if (verbose)
296     {
297       // Remark: The Exodus/Nemesis node numbring is always (?) 1-based!  This means the first interior node id will
298       // always be == 1\&.
299       libMesh::out << "[" << this->processor_id() << "] " << "first interior node id=" << node_mapi[0] << std::endl;
300       libMesh::out << "[" << this->processor_id() << "] " << "last interior node id=" << node_mapi\&.back() << std::endl;
301 
302       libMesh::out << "[" << this->processor_id() << "] " << "first boundary node id=" << node_mapb[0] << std::endl;
303       libMesh::out << "[" << this->processor_id() << "] " << "last boundary node id=" << node_mapb\&.back() << std::endl;
304 
305       // The number of external nodes is sometimes zero, don't try to access
306       // node_mape\&.back() in this case!
307       if (num_external_nodes > 0)
308         {
309           libMesh::out << "[" << this->processor_id() << "] " << "first external node id=" << node_mape[0] << std::endl;
310           libMesh::out << "[" << this->processor_id() << "] " << "last external node id=" << node_mape\&.back() << std::endl;
311         }
312     }
313 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_node_set_id (intindex)\fC [inherited]\fP"
Get the node set id for the given node set index\&. 
.PP
Definition at line 480 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::nodeset_ids\&.
.PP
.nf
481 {
482   libmesh_assert_less (static_cast<unsigned int>(index), nodeset_ids\&.size());
483 
484   return nodeset_ids[index];
485 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_node_set_name (intindex)\fC [inherited]\fP"
Get the node set name for the given node set index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 489 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::id_to_ns_names, and libMesh::ExodusII_IO_Helper::nodeset_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
490 {
491   libmesh_assert_less (static_cast<unsigned int>(index), nodeset_ids\&.size());
492 
493   return id_to_ns_names[nodeset_ids[index]];
494 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_ns_param_global ()"

.PP
Definition at line 137 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, global_nodeset_ids, nemesis_err_flag, num_global_node_counts, num_global_node_df_counts, num_node_sets_global, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
138 {
139   if (num_node_sets_global > 0)
140     {
141       global_nodeset_ids\&.resize(num_node_sets_global);
142       num_global_node_counts\&.resize(num_node_sets_global);
143       num_global_node_df_counts\&.resize(num_node_sets_global);
144 
145       nemesis_err_flag =
146         Nemesis::ne_get_ns_param_global(ex_id,
147                                         global_nodeset_ids\&.empty()        ? NULL : &global_nodeset_ids[0],
148                                         num_global_node_counts\&.empty()    ? NULL : &num_global_node_counts[0],
149                                         num_global_node_df_counts\&.empty() ? NULL : &num_global_node_df_counts[0]);
150       EX_CHECK_ERR(nemesis_err_flag, "Error reading global nodeset parameters!");
151 
152       if (verbose)
153         {
154           libMesh::out << "[" << this->processor_id() << "] " << "Global Nodeset IDs, Node Counts, and DF counts:" << std::endl;
155           for (unsigned int bn=0; bn<global_nodeset_ids\&.size(); ++bn)
156             {
157               libMesh::out << "  [" << this->processor_id() << "] "
158                            << "global_nodeset_ids["<<bn<<"]=" << global_nodeset_ids[bn]
159                            << ", num_global_node_counts["<<bn<<"]=" << num_global_node_counts[bn]
160                            << ", num_global_node_df_counts["<<bn<<"]=" << num_global_node_df_counts[bn]
161                            << std::endl;
162             }
163         }
164     }
165 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::get_side_set_id (intindex)\fC [inherited]\fP"
Get the side set id for the given side set index\&. 
.PP
Definition at line 462 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ss_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
463 {
464   libmesh_assert_less (static_cast<unsigned int>(index), ss_ids\&.size());
465 
466   return ss_ids[index];
467 }
.fi
.SS "std::string libMesh::ExodusII_IO_Helper::get_side_set_name (intindex)\fC [inherited]\fP"
Get the side set name for the given side set index if supplied in the mesh file\&. Otherwise an empty string is returned\&. 
.PP
Definition at line 471 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::id_to_ss_names, and libMesh::ExodusII_IO_Helper::ss_ids\&.
.PP
Referenced by libMesh::ExodusII_IO::read()\&.
.PP
.nf
472 {
473   libmesh_assert_less (static_cast<unsigned int>(index), ss_ids\&.size());
474 
475   return id_to_ss_names[ss_ids[index]];
476 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::get_ss_param_global ()"
Fills: global_sideset_ids, num_global_side_counts, num_global_side_df_counts Call after: \fBget_init_global()\fP 
.PP
Definition at line 101 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, global_sideset_ids, nemesis_err_flag, num_global_side_counts, num_global_side_df_counts, num_side_sets_global, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read()\&.
.PP
.nf
102 {
103   if (num_side_sets_global > 0)
104     {
105       global_sideset_ids\&.resize(num_side_sets_global);
106       num_global_side_counts\&.resize(num_side_sets_global);
107 
108       // df = "distribution factor", not really sure what that is\&.  I don't yet have a file
109       // which has distribution factors so I guess we'll worry about it later\&.\&.\&.
110       num_global_side_df_counts\&.resize(num_side_sets_global);
111 
112       nemesis_err_flag =
113         Nemesis::ne_get_ss_param_global(ex_id,
114                                         global_sideset_ids\&.empty()        ? NULL : &global_sideset_ids[0],
115                                         num_global_side_counts\&.empty()    ? NULL : &num_global_side_counts[0],
116                                         num_global_side_df_counts\&.empty() ? NULL : &num_global_side_df_counts[0]);
117       EX_CHECK_ERR(nemesis_err_flag, "Error reading global sideset parameters!");
118 
119       if (verbose)
120         {
121           libMesh::out << "[" << this->processor_id() << "] " << "Global Sideset IDs, Side Counts, and DF counts:" << std::endl;
122           for (unsigned int bn=0; bn<global_sideset_ids\&.size(); ++bn)
123             {
124               libMesh::out << "  [" << this->processor_id() << "] "
125                            << "global_sideset_ids["<<bn<<"]=" << global_sideset_ids[bn]
126                            << ", num_global_side_counts["<<bn<<"]=" << num_global_side_counts[bn]
127                            << ", num_global_side_df_counts["<<bn<<"]=" << num_global_side_df_counts[bn]
128                            << std::endl;
129             }
130         }
131     }
132 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::initialize (std::stringtitle, const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
Specialization of the initialize function from \fBExodusII_IO_Helper\fP that also writes global initial data to file\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 745 of file nemesis_io_helper\&.C\&.
.PP
References build_element_and_node_maps(), compute_border_node_ids(), compute_communication_map_parameters(), compute_elem_communication_maps(), compute_element_maps(), compute_internal_and_border_elems_and_internal_nodes(), compute_node_communication_maps(), compute_node_maps(), compute_num_global_elem_blocks(), compute_num_global_nodesets(), compute_num_global_sidesets(), elem_cmap_elem_cnts, elem_cmap_elem_ids, elem_cmap_ids, elem_cmap_proc_ids, elem_cmap_side_ids, elem_mapb, elem_mapi, global_elem_blk_cnts, global_elem_blk_ids, global_nodeset_ids, global_sideset_ids, mesh, libMesh::ParallelObject::n_processors(), node_cmap_ids, node_cmap_node_cnts, node_cmap_node_ids, node_cmap_proc_ids, node_mapb, node_mape, node_mapi, num_border_elems, num_border_nodes, num_elem_blks_global, num_elem_cmaps, num_external_nodes, num_global_node_counts, num_global_node_df_counts, num_global_side_counts, num_global_side_df_counts, num_internal_elems, num_internal_nodes, num_node_cmaps, num_node_sets_global, num_side_sets_global, libMesh::MeshBase::parallel_n_elem(), libMesh::MeshBase::parallel_n_nodes(), put_cmap_params(), put_eb_info_global(), put_elem_cmap(), put_elem_map(), put_init_global(), put_init_info(), put_loadbal_param(), put_node_cmap(), put_node_map(), put_ns_param_global(), put_ss_param_global(), and write_exodus_initialization_info()\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
746 {
747   // Make sure that the reference passed in is really a ParallelMesh
748   // const ParallelMesh& pmesh = libmesh_cast_ref<const ParallelMesh&>(mesh);
749   const MeshBase& pmesh = mesh;
750 
751   // According to Nemesis documentation, first call when writing should be to
752   // ne_put_init_info()\&.  Our reader doesn't actually call this, but we should
753   // strive to be as close to a normal nemesis file as possible\&.\&.\&.
754   this->put_init_info(this->n_processors(), 1, "p");
755 
756 
757   // Gather global "initial" information for Nemesis\&.  This consists of
758   // three parts labelled I, II, and III below\&.\&.\&.
759 
760   //
761   // I\&.) Need to compute the number of global element blocks\&.  To be consistent with
762   // Exodus, we also incorrectly associate the number of element blocks with the
763   // number of libmesh subdomains\&.\&.\&.
764   //
765   this->compute_num_global_elem_blocks(pmesh);
766 
767   //
768   // II\&.) Determine the global number of nodesets by communication\&.
769   // This code relies on BoundaryInfo storing side and node
770   // boundary IDs separately at the time they are added to the
771   // BoundaryInfo object\&.
772   //
773   this->compute_num_global_nodesets(pmesh);
774 
775   //
776   // III\&.) Need to compute the global number of sidesets by communication:
777   // This code relies on BoundaryInfo storing side and node
778   // boundary IDs separately at the time they are added to the
779   // BoundaryInfo object\&.
780   //
781   this->compute_num_global_sidesets(pmesh);
782 
783   // Now write the global data obtained in steps I, II, and III to the Nemesis file
784   this->put_init_global(pmesh\&.parallel_n_nodes(),
785                         pmesh\&.parallel_n_elem(),
786                         this->num_elem_blks_global, /* I\&.   */
787                         this->num_node_sets_global, /* II\&.  */
788                         this->num_side_sets_global  /* III\&. */
789                         );
790 
791   // Next, we'll write global element block information to the file\&.  This was already
792   // gathered in step I\&. above
793   this->put_eb_info_global(this->global_elem_blk_ids,
794                            this->global_elem_blk_cnts);
795 
796 
797   // Next, write global nodeset information to the file\&.  This was already gathered in
798   // step II\&. above\&.
799   this->num_global_node_df_counts\&.clear();
800   this->num_global_node_df_counts\&.resize(this->global_nodeset_ids\&.size()); // distribution factors all zero\&.\&.\&.
801   this->put_ns_param_global(this->global_nodeset_ids,
802                             this->num_global_node_counts,
803                             this->num_global_node_df_counts);
804 
805 
806   // Next, write global sideset information to the file\&.  This was already gathered in
807   // step III\&. above\&.
808   this->num_global_side_df_counts\&.clear();
809   this->num_global_side_df_counts\&.resize(this->global_sideset_ids\&.size()); // distribution factors all zero\&.\&.\&.
810   this->put_ss_param_global(this->global_sideset_ids,
811                             this->num_global_side_counts,
812                             this->num_global_side_df_counts);
813 
814 
815   // Before we go any further we need to derive consistent node and
816   // element numbering schemes for all local elems and nodes connected
817   // to local elements\&.
818   //
819   // Must be called *after* the local_subdomain_counts map has been constructed
820   // by the compute_num_global_elem_blocks() function!
821   this->build_element_and_node_maps(pmesh);
822 
823   // Next step is to write "load balance" parameters\&.  Several things need to
824   // be computed first though\&.\&.\&.
825 
826   // First we'll collect IDs of border nodes\&.
827   this->compute_border_node_ids(pmesh);
828 
829   // Next we'll collect numbers of internal and border elements, and internal nodes\&.
830   // Note: "A border node does not a border element make\&.\&.\&.", that is, just because one
831   // of an element's nodes has been identified as a border node, the element is not
832   // necessarily a border element\&.  It must have a side on the boundary between processors,
833   // i\&.e\&. have a face neighbor with a different processor id\&.\&.\&.
834   this->compute_internal_and_border_elems_and_internal_nodes(pmesh);
835 
836   // Finally we are ready to write the loadbal information to the file
837   this->put_loadbal_param(this->num_internal_nodes,
838                           this->num_border_nodes,
839                           this->num_external_nodes,
840                           this->num_internal_elems,
841                           this->num_border_elems,
842                           this->num_node_cmaps,
843                           this->num_elem_cmaps);
844 
845 
846   // Now we need to compute the "communication map" parameters\&.  These are basically
847   // lists of nodes and elements which need to be communicated between different processors
848   // when the mesh file is read back in\&.
849   this->compute_communication_map_parameters();
850 
851   // Write communication map parameters to file\&.
852   this->put_cmap_params(this->node_cmap_ids,
853                         this->node_cmap_node_cnts,
854                         this->elem_cmap_ids,
855                         this->elem_cmap_elem_cnts);
856 
857 
858   // Ready the node communication maps\&.  The node IDs which
859   // are communicated are the ones currently stored in
860   // proc_nodes_touched_intersections\&.
861   this->compute_node_communication_maps();
862 
863   // Write the packed node communication vectors to file\&.
864   this->put_node_cmap(this->node_cmap_node_ids,
865                       this->node_cmap_proc_ids);
866 
867 
868   // Ready the node maps\&.  These have nothing to do with communiction, they map
869   // the nodes to internal, border, and external nodes in the file\&.
870   this->compute_node_maps();
871 
872   // Call the Nemesis API to write the node maps to file\&.
873   this->put_node_map(this->node_mapi,
874                      this->node_mapb,
875                      this->node_mape);
876 
877 
878 
879   // Ready the element communication maps\&.  This includes border
880   // element IDs, sides which are on the border, and the processors to which
881   // they are to be communicated\&.\&.\&.
882   this->compute_elem_communication_maps();
883 
884 
885 
886   // Call the Nemesis API to write the packed element communication maps vectors to file
887   this->put_elem_cmap(this->elem_cmap_elem_ids,
888                       this->elem_cmap_side_ids,
889                       this->elem_cmap_proc_ids);
890 
891 
892 
893 
894 
895 
896   // Ready the Nemesis element maps (internal and border) for writing to file\&.
897   this->compute_element_maps();
898 
899   // Call the Nemesis API to write the internal and border element IDs\&.
900   this->put_elem_map(this->elem_mapi,
901                      this->elem_mapb);
902 
903 
904   // Now write Exodus-specific initialization information, some of which is
905   // different when you are using Nemesis\&.
906   this->write_exodus_initialization_info(pmesh, title_in);
907 } // end initialize()
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_element_variables (std::vector< std::string >names)\fC [inherited]\fP"
Sets up the nodal variables 
.PP
Definition at line 1468 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_elem_vars_initialized, libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::check_existing_vars(), libMesh::ExodusII_IO_Helper::elem_var_names, libMesh::ExodusII_IO_Helper::ELEMENTAL, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_elem_var_tab(), libMesh::ExodusII_IO_Helper::num_elem_blk, libMesh::ExodusII_IO_Helper::num_elem_vars, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data()\&.
.PP
.nf
1469 {
1470   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1471     return;
1472 
1473   // Quick return if there are no element variables to write
1474   if (names\&.size() == 0)
1475     return;
1476 
1477   // Quick return if we have already called this function
1478   if (_elem_vars_initialized)
1479     return;
1480 
1481   // Be sure that variables in the file match what we are asking for
1482   if (num_elem_vars > 0)
1483     {
1484       this->check_existing_vars(ELEMENTAL, names, this->elem_var_names);
1485       return;
1486     }
1487 
1488   // Set the flag so we can skip this stuff on subsequent calls to
1489   // initialize_element_variables()
1490   _elem_vars_initialized = true;
1491 
1492   this->write_var_names(ELEMENTAL, names);
1493 
1494   // Form the element variable truth table and send to Exodus\&.
1495   // This tells which variables are written to which blocks,
1496   // and can dramatically speed up writing element variables
1497   //
1498   // We really should initialize all entries in the truth table to 0
1499   // and then loop over all subdomains, setting their entries to 1
1500   // if a given variable exists on that subdomain\&.  However,
1501   // we don't have that information, and the element variables
1502   // passed to us are padded with zeroes for the blocks where
1503   // they aren't defined\&.  To be consistent with that, fill
1504   // the truth table with ones\&.
1505   std::vector<int> truth_tab(num_elem_blk*num_elem_vars, 1);
1506   ex_err = exII::ex_put_elem_var_tab(ex_id,
1507                                      num_elem_blk,
1508                                      num_elem_vars,
1509                                      &truth_tab[0]);
1510   EX_CHECK_ERR(ex_err, "Error writing element truth table\&.");
1511 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_global_variables (std::vector< std::string >names)\fC [inherited]\fP"
Sets up the global variables 
.PP
Definition at line 1543 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_global_vars_initialized, libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::check_existing_vars(), libMesh::ExodusII_IO_Helper::GLOBAL, libMesh::ExodusII_IO_Helper::global_var_names, libMesh::ExodusII_IO_Helper::num_global_vars, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_global_data(), and libMesh::ExodusII_IO::write_global_data()\&.
.PP
.nf
1544 {
1545   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1546     return;
1547 
1548   // Quick return if there are no global variables to write
1549   if (names\&.size() == 0)
1550     return;
1551 
1552   if (_global_vars_initialized)
1553     return;
1554 
1555   // Be sure that variables in the file match what we are asking for
1556   if (num_global_vars > 0)
1557     {
1558       this->check_existing_vars(GLOBAL, names, this->global_var_names);
1559       return;
1560     }
1561 
1562   _global_vars_initialized = true;
1563 
1564   this->write_var_names(GLOBAL, names);
1565 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::initialize_nodal_variables (std::vector< std::string >names)\fC [inherited]\fP"
Sets up the nodal variables 
.PP
Definition at line 1515 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_nodal_vars_initialized, libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::check_existing_vars(), libMesh::ExodusII_IO_Helper::NODAL, libMesh::ExodusII_IO_Helper::nodal_var_names, libMesh::ExodusII_IO_Helper::num_nodal_vars, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
1516 {
1517   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1518     return;
1519 
1520   // Quick return if there are no nodal variables to write
1521   if (names\&.size() == 0)
1522     return;
1523 
1524   // Quick return if we have already called this function
1525   if (_nodal_vars_initialized)
1526     return;
1527 
1528   // Be sure that variables in the file match what we are asking for
1529   if (num_nodal_vars > 0)
1530     {
1531       this->check_existing_vars(NODAL, names, this->nodal_var_names);
1532       return;
1533     }
1534 
1535   // Set the flag so we can skip the rest of this function on subsequent calls\&.
1536   _nodal_vars_initialized = true;
1537 
1538   this->write_var_names(NODAL, names);
1539 }
.fi
.SS "int libMesh::ExodusII_IO_Helper::inquire (intreq_info, std::stringerror_msg = \fC''\fP)\fC [inherited]\fP"
Generic inquiry, returns the value 
.PP
Definition at line 710 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, and ex_inquire()\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::read_num_time_steps(), libMesh::ExodusII_IO_Helper::read_sideset_info(), and libMesh::ExodusII_IO_Helper::write_information_records()\&.
.PP
.nf
711 {
712   int ret_int = 0;
713   char ret_char = 0;
714   float ret_float = 0\&.;
715 
716   ex_err = exII::ex_inquire(ex_id,
717                             req_info_in,
718                             &ret_int,
719                             &ret_float,
720                             &ret_char);
721 
722   EX_CHECK_ERR(ex_err, error_msg);
723 
724   return ret_int;
725 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::message (const std::string &msg)\fC [inherited]\fP"
Prints the message defined in \fCmsg\fP\&. Can be turned off if verbosity is set to 0\&. 
.PP
Definition at line 280 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::out, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::close(), libMesh::ExodusII_IO_Helper::read_block_info(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::read_nodeset(), libMesh::ExodusII_IO_Helper::read_nodeset_info(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.PP
.nf
281 {
282   if (verbose) libMesh::out << msg << std::endl;
283 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::message (const std::string &msg, inti)\fC [inherited]\fP"
Prints the message defined in \fCmsg\fP, and appends the number \fCi\fP to the end of the message\&. Useful for printing messages in loops\&. Can be turned off if verbosity is set to 0\&. 
.PP
Definition at line 287 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::out, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
.nf
288 {
289   if (verbose) libMesh::out << msg << i << "\&." << std::endl;
290 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), compute_border_node_ids(), construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "void libMesh::ExodusII_IO_Helper::open (const char *filename, boolread_only)\fC [inherited]\fP"
Opens an \fCExodusII\fP mesh file named \fCfilename\fP\&. If read_only==true, the file will be opened with the EX_READ flag, otherwise it will be opened with the EX_WRITE flag\&. 
.PP
Definition at line 294 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::current_filename, libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::opened_for_reading, libMesh::ExodusII_IO_Helper::opened_for_writing, libMesh::out, libMesh::Real, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
295 {
296   // Version of Exodus you are using
297   float ex_version = 0\&.;
298 
299   // Word size in bytes of the floating point variables used in the
300   // application program (0, 4, or 8)
301   int comp_ws = sizeof(Real);
302 
303   // Word size in bytes of the floating point data as they are stored
304   // in the ExodusII file\&.  "If this argument is 0, the word size of the
305   // floating point data already stored in the file is returned"
306   int io_ws = 0;
307 
308   ex_id = exII::ex_open(filename,
309                         read_only ? EX_READ : EX_WRITE,
310                         &comp_ws,
311                         &io_ws,
312                         &ex_version);
313 
314   std::string err_msg = std::string("Error opening ExodusII mesh file: ") + std::string(filename);
315   EX_CHECK_ERR(ex_id, err_msg);
316   if (verbose) libMesh::out << "File opened successfully\&." << std::endl;
317 
318   if (read_only)
319     opened_for_reading = true;
320   else
321     opened_for_writing = true;
322 
323   current_filename = std::string(filename);
324 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::print_header ()\fC [inherited]\fP"
Prints the \fCExodusII\fP mesh file header, which includes the mesh title, the number of nodes, number of elements, mesh dimension, number of sidesets, and number of nodesets\&. 
.PP
Definition at line 358 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::num_dim, libMesh::ExodusII_IO_Helper::num_elem, libMesh::ExodusII_IO_Helper::num_elem_blk, libMesh::ExodusII_IO_Helper::num_node_sets, libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::num_side_sets, libMesh::out, libMesh::ExodusII_IO_Helper::title, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
359 {
360   if (verbose)
361     libMesh::out << "Title: \t" << &title[0] << std::endl
362                  << "Mesh Dimension: \t"   << num_dim << std::endl
363                  << "Number of Nodes: \t" << num_nodes << std::endl
364                  << "Number of elements: \t" << num_elem << std::endl
365                  << "Number of elt blocks: \t" << num_elem_blk << std::endl
366                  << "Number of node sets: \t" << num_node_sets << std::endl
367                  << "Number of side sets: \t" << num_side_sets << std::endl;
368 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::print_nodes (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [inherited]\fP"
Prints the nodal information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 409 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::x, libMesh::ExodusII_IO_Helper::y, and libMesh::ExodusII_IO_Helper::z\&.
.PP
.nf
410 {
411   for (int i=0; i<num_nodes; i++)
412     out_stream << "(" << x[i] << ", " << y[i] << ", " << z[i] << ")" << std::endl;
413 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), compute_border_node_ids(), compute_communication_map_parameters(), compute_internal_and_border_elems_and_internal_nodes(), compute_node_communication_maps(), compute_num_global_elem_blocks(), compute_num_global_nodesets(), compute_num_global_sidesets(), construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), get_cmap_params(), get_eb_info_global(), get_elem_cmap(), get_elem_map(), libMesh::MeshBase::get_info(), get_init_global(), get_init_info(), get_loadbal_param(), get_node_cmap(), get_node_map(), get_ns_param_global(), get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), put_cmap_params(), put_elem_cmap(), put_elem_map(), put_loadbal_param(), put_node_cmap(), put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_cmap_params (std::vector< int > &node_cmap_ids, std::vector< int > &node_cmap_node_cnts, std::vector< int > &elem_cmap_ids, std::vector< int > &elem_cmap_elem_cnts)"
Outputs initial information for communication maps\&. Note: the order of the arguments specified in the Nemsis User's Manual is \fIwrong\fP\&. The correct order is (ids, counts, ids, counts)\&. Must be called after \fBput_loadbal_param()\fP\&. 
.PP
Definition at line 561 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, node_cmap_ids, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
565 {
566   // We might not have cmaps on every processor in some corner
567   // cases
568   if(node_cmap_ids\&.size())
569     {
570       nemesis_err_flag =
571         Nemesis::ne_put_cmap_params(ex_id,
572                                     &node_cmap_ids_in[0],
573                                     &node_cmap_node_cnts_in[0],
574                                     &elem_cmap_ids_in[0],
575                                     &elem_cmap_elem_cnts_in[0],
576                                     this->processor_id());
577     }
578 
579   EX_CHECK_ERR(nemesis_err_flag, "Error writing cmap parameters!");
580 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_eb_info_global (std::vector< int > &global_elem_blk_ids, std::vector< int > &global_elem_blk_cnts)"
Writes global block information to the file \&.) global_elem_blk_ids - list of block IDs for all blocks present in the mesh \&.) global_elem_blk_cnts - number of elements in each block for the global mesh
.PP
Must be called after \fBput_init_global()\fP\&. 
.PP
Definition at line 481 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, and nemesis_err_flag\&.
.PP
Referenced by initialize()\&.
.PP
.nf
483 {
484   nemesis_err_flag =
485     Nemesis::ne_put_eb_info_global(ex_id,
486                                    &global_elem_blk_ids_in[0],
487                                    &global_elem_blk_cnts_in[0]);
488 
489   EX_CHECK_ERR(nemesis_err_flag, "Error writing global element block information!");
490 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_elem_cmap (std::vector< std::vector< int > > &elem_cmap_elem_ids, std::vector< std::vector< int > > &elem_cmap_side_ids, std::vector< std::vector< int > > &elem_cmap_proc_ids)"
Writes information about elemental communication map\&.
.PP
Note: this class contains vector<vectors>: elem_cmap_elem_ids elem_cmap_side_ids elem_cmap_proc_ids
.PP
Must be called after \fBput_cmap_params()\fP\&. 
.PP
Definition at line 644 of file nemesis_io_helper\&.C\&.
.PP
References elem_cmap_ids, libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
647 {
648   for (unsigned int i=0; i<elem_cmap_ids\&.size(); ++i)
649     {
650       nemesis_err_flag =
651         Nemesis::ne_put_elem_cmap(ex_id,
652                                   this->elem_cmap_ids[i],
653                                   &elem_cmap_elem_ids_in[i][0],
654                                   &elem_cmap_side_ids_in[i][0],
655                                   &elem_cmap_proc_ids_in[i][0],
656                                   this->processor_id());
657 
658       EX_CHECK_ERR(nemesis_err_flag, "Error writing elem communication map to file!");
659     }
660 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_elem_map (std::vector< int > &elem_mapi, std::vector< int > &elem_mapb)"
Outputs IDs of internal and border elements\&.
.PP
Must be called after ne_put_loadbal_param()\&. 
.PP
Definition at line 665 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
667 {
668   nemesis_err_flag =
669     Nemesis::ne_put_elem_map(ex_id,
670                              elem_mapi_in\&.empty() ? NULL : &elem_mapi_in[0],
671                              elem_mapb_in\&.empty() ? NULL : &elem_mapb_in[0],
672                              this->processor_id());
673 
674   EX_CHECK_ERR(nemesis_err_flag, "Error writing Nemesis internal and border element maps to file!");
675 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_init_global (\fBdof_id_type\fPnum_nodes_global, \fBdof_id_type\fPnum_elems_global, unsignednum_elem_blks_global, unsignednum_node_sets_global, unsignednum_side_sets_global)"
Writes global information including: \&.) global number of nodes \&.) global number of elems \&.) global number of element blocks \&.) global number of node sets \&.) global number of side sets 
.PP
Definition at line 462 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, and nemesis_err_flag\&.
.PP
Referenced by initialize()\&.
.PP
.nf
467 {
468   nemesis_err_flag =
469     Nemesis::ne_put_init_global(ex_id,
470                                 num_nodes_global_in,
471                                 num_elems_global_in,
472                                 num_elem_blks_global_in,
473                                 num_node_sets_global_in,
474                                 num_side_sets_global_in);
475 
476   EX_CHECK_ERR(nemesis_err_flag, "Error writing initial global data!");
477 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_init_info (unsignednum_proc, unsignednum_proc_in_file, const char *ftype)"
Writing functions\&. Writes basic info about the partitioning to file \&.) num_proc - number of processors \&.) num_proc_in_file - number of processors in the current file - generally equal to 1 \&.) ftype = 's' for scalar load-balance file, 'p' for parallel file 
.PP
Definition at line 446 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, and nemesis_err_flag\&.
.PP
Referenced by initialize()\&.
.PP
.nf
449 {
450   nemesis_err_flag =
451     Nemesis::ne_put_init_info(ex_id,
452                               num_proc_in,
453                               num_proc_in_file_in,
454                               const_cast<char*>(ftype_in));
455 
456   EX_CHECK_ERR(nemesis_err_flag, "Error writing initial information!");
457 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_loadbal_param (unsignednum_internal_nodes, unsignednum_border_nodes, unsignednum_external_nodes, unsignednum_internal_elems, unsignednum_border_elems, unsignednum_node_cmaps, unsignednum_elem_cmaps)"
Writes load balance parameters, some of which are described below: \&.) num_internal_nodes - nodes 'wholly' owned by the current processor \&.) num_border_nodes - nodes local to a processor but residing in an element which also has nodes on other processors \&.) num_external_nodes - nodes that reside on other processors but whose element 'partially' resides on the current processor -- we assert this should be zero on reading! \&.) num_border_elems - elements local to this processor but whose nodes reside on other processors as well\&. \&.) processor - ID of the processor for which information is to be written 
.PP
Definition at line 535 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
542 {
543   nemesis_err_flag =
544     Nemesis::ne_put_loadbal_param(ex_id,
545                                   num_internal_nodes_in,
546                                   num_border_nodes_in,
547                                   num_external_nodes_in,
548                                   num_internal_elems_in,
549                                   num_border_elems_in,
550                                   num_node_cmaps_in,
551                                   num_elem_cmaps_in,
552                                   this->processor_id());
553 
554   EX_CHECK_ERR(nemesis_err_flag, "Error writing loadbal parameters!");
555 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_n_coord (unsignedstart_node_num, unsignednum_nodes, std::vector< \fBReal\fP > &x_coor, std::vector< \fBReal\fP > &y_coor, std::vector< \fBReal\fP > &z_coor)"
Writes the specified number of coordinate values starting at the specified index\&. 
.PP
Definition at line 682 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, and nemesis_err_flag\&.
.PP
.nf
687 {
688   nemesis_err_flag =
689     Nemesis::ne_put_n_coord(ex_id,
690                             start_node_num,
691                             num_nodes_in,
692                             &x_coor[0],
693                             &y_coor[0],
694                             &z_coor[0]);
695 
696   EX_CHECK_ERR(nemesis_err_flag, "Error writing coords to file!");
697 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_node_cmap (std::vector< std::vector< int > > &node_cmap_node_ids, std::vector< std::vector< int > > &node_cmap_proc_ids)"
Outputs \fIall\fP of the nodal communication maps for this processor\&. Internally, this function loops over all communication maps and calls Nemesis::ne_put_node_cmap() for each one\&.
.PP
\&.) node_cmap_node_ids = Nodal IDs of the FEM nodes in this communication map \&.) node_cmap_proc_ids = processor IDs associated with each of the nodes in node_ids
.PP
In the \fBNemesis\fP file, these all appeart to be written to the same chunks of data: n_comm_nids and n_comm_proc, but don't rely on these names\&.\&.\&.
.PP
Note: this class contains vector<vectors>: node_cmap_node_ids node_cmap_proc_ids which can be used when calling this function\&.
.PP
Must be called after \fBput_cmap_params()\fP\&. 
.PP
Definition at line 585 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, node_cmap_ids, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by initialize()\&.
.PP
.nf
587 {
588 
589   // Print to screen what we are about to print to Nemesis file
590   if (verbose)
591     {
592       for (unsigned i=0; i<node_cmap_node_ids_in\&.size(); ++i)
593         {
594           libMesh::out << "[" << this->processor_id() << "] put_node_cmap() : nodes communicated to proc "
595                        << this->node_cmap_ids[i]
596                        << " = ";
597           for (unsigned j=0; j<node_cmap_node_ids_in[i]\&.size(); ++j)
598             libMesh::out << node_cmap_node_ids_in[i][j] << " ";
599           libMesh::out << std::endl;
600         }
601 
602       for (unsigned i=0; i<node_cmap_node_ids_in\&.size(); ++i)
603         {
604           libMesh::out << "[" << this->processor_id() << "] put_node_cmap() : processor IDs = ";
605           for (unsigned j=0; j<node_cmap_proc_ids_in[i]\&.size(); ++j)
606             libMesh::out << node_cmap_proc_ids_in[i][j] << " ";
607           libMesh::out << std::endl;
608         }
609     }
610 
611   for (unsigned int i=0; i<node_cmap_node_ids_in\&.size(); ++i)
612     {
613       nemesis_err_flag =
614         Nemesis::ne_put_node_cmap(ex_id,
615                                   this->node_cmap_ids[i],
616                                   &node_cmap_node_ids_in[i][0],
617                                   &node_cmap_proc_ids_in[i][0],
618                                   this->processor_id());
619 
620       EX_CHECK_ERR(nemesis_err_flag, "Error writing node communication map to file!");
621     }
622 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_node_map (std::vector< int > &node_mapi, std::vector< int > &node_mapb, std::vector< int > &node_mape)"
Outputs IDs of internal, border, and external nodes\&. LibMesh asserts that the number of external nodes is zero in the \fBNemesis\fP files it reads 
.PP
Definition at line 627 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, nemesis_err_flag, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
630 {
631   nemesis_err_flag =
632     Nemesis::ne_put_node_map(ex_id,
633                              node_mapi_in\&.empty() ? NULL : &node_mapi_in[0],
634                              node_mapb_in\&.empty() ? NULL : &node_mapb_in[0],
635                              node_mape_in\&.empty() ? NULL : &node_mape_in[0], // Don't take address of empty vector\&.\&.\&.
636                              this->processor_id());
637 
638   EX_CHECK_ERR(nemesis_err_flag, "Error writing Nemesis internal and border node maps to file!");
639 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_ns_param_global (std::vector< int > &global_nodeset_ids, std::vector< int > &num_global_node_counts, std::vector< int > &num_global_node_df_counts)"
This function writes information about global node sets\&. \&.) global_nodeset_ids - vector of global node set IDs \&.) num_global_node_counts - vector of global node counts contained in each global node set \&.) num_global_df_count - vector of global distribution factors in each global node set
.PP
Must be called after \fBput_init_global()\fP 
.PP
Definition at line 495 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, global_nodeset_ids, and nemesis_err_flag\&.
.PP
Referenced by initialize()\&.
.PP
.nf
498 {
499   // Only add nodesets if there are some
500   if(global_nodeset_ids\&.size())
501     {
502       nemesis_err_flag =
503         Nemesis::ne_put_ns_param_global(ex_id,
504                                         &global_nodeset_ids_in[0],
505                                         &num_global_node_counts_in[0],
506                                         &num_global_node_df_counts_in[0]);
507     }
508 
509   EX_CHECK_ERR(nemesis_err_flag, "Error writing global nodeset parameters!");
510 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::put_ss_param_global (std::vector< int > &global_sideset_ids, std::vector< int > &num_global_side_counts, std::vector< int > &num_global_side_df_counts)"
This function writes information about global side sets\&. \&.) global_sideset_ids - vector of global side set IDs \&.) num_global_side_counts - vector of global side counts contained in each global side set \&.) num_global_df_count - vector of global distribution factors in each global side set
.PP
Must be called after \fBput_init_global()\fP 
.PP
Definition at line 515 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_id, global_sideset_ids, and nemesis_err_flag\&.
.PP
Referenced by initialize()\&.
.PP
.nf
518 {
519   // Only add sidesets if there are some
520   if(global_sideset_ids\&.size())
521     {
522       nemesis_err_flag =
523         Nemesis::ne_put_ss_param_global(ex_id,
524                                         &global_sideset_ids_in[0],
525                                         &num_global_side_counts_in[0],
526                                         &num_global_side_df_counts_in[0]);
527     }
528 
529   EX_CHECK_ERR(nemesis_err_flag, "Error writing global sideset parameters!");
530 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_block_info ()\fC [inherited]\fP"
Reads information for all of the blocks in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 417 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::block_ids, EX_ELEM_BLOCK, libMesh::ExodusII_IO_Helper::ex_err, ex_get_elem_blk_ids(), ex_get_name(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::id_to_block_names, libMesh::ExodusII_IO_Helper::message(), and libMesh::ExodusII_IO_Helper::num_elem_blk\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
418 {
419   block_ids\&.resize(num_elem_blk);
420   // Get all element block IDs\&.
421   ex_err = exII::ex_get_elem_blk_ids(ex_id,
422                                      block_ids\&.empty() ? NULL : &block_ids[0]);
423   // Usually, there is only one
424   // block since there is only
425   // one type of element\&.
426   // However, there could be more\&.
427 
428   EX_CHECK_ERR(ex_err, "Error getting block IDs\&.");
429   message("All block IDs retrieved successfully\&.");
430 
431   char name_buffer[MAX_STR_LENGTH+1];
432   for (int i=0; i<num_elem_blk; ++i)
433     {
434       ex_err = exII::ex_get_name(ex_id, exII::EX_ELEM_BLOCK,
435                                  block_ids[i], name_buffer);
436       EX_CHECK_ERR(ex_err, "Error getting block name\&.");
437       id_to_block_names[block_ids[i]] = name_buffer;
438     }
439   message("All block names retrieved successfully\&.");
440 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elem_in_block (intblock)\fC [inherited]\fP"
Reads all of the element connectivity for block \fCblock\fP in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 499 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::block_ids, libMesh::ExodusII_IO_Helper::connect, libMesh::ExodusII_IO_Helper::elem_type, libMesh::ExodusII_IO_Helper::ex_err, ex_get_elem_block(), ex_get_elem_conn(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::num_attr, libMesh::ExodusII_IO_Helper::num_elem_this_blk, libMesh::ExodusII_IO_Helper::num_nodes_per_elem, libMesh::out, and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
500 {
501   libmesh_assert_less (static_cast<unsigned int>(block), block_ids\&.size());
502 
503   ex_err = exII::ex_get_elem_block(ex_id,
504                                    block_ids[block],
505                                    &elem_type[0],
506                                    &num_elem_this_blk,
507                                    &num_nodes_per_elem,
508                                    &num_attr);
509   if (verbose)
510     libMesh::out << "Reading a block of " << num_elem_this_blk
511                  << " " << &elem_type[0] << "(s)"
512                  << " having " << num_nodes_per_elem
513                  << " nodes per element\&." << std::endl;
514 
515   EX_CHECK_ERR(ex_err, "Error getting block info\&.");
516   message("Info retrieved successfully for block: ", block);
517 
518 
519 
520   // Read in the connectivity of the elements of this block,
521   // watching out for the case where we actually have no
522   // elements in this block (possible with parallel files)
523   connect\&.resize(num_nodes_per_elem*num_elem_this_blk);
524 
525   if (!connect\&.empty())
526     {
527       ex_err = exII::ex_get_elem_conn(ex_id,
528                                       block_ids[block],
529                                       &connect[0]);
530 
531       EX_CHECK_ERR(ex_err, "Error reading block connectivity\&.");
532       message("Connectivity retrieved successfully for block: ", block);
533     }
534 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elem_num_map ()\fC [inherited]\fP"
Reads the optional \fCnode_num_map\fP from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 539 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::elem_num_map, libMesh::ExodusII_IO_Helper::ex_err, ex_get_elem_num_map(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), std::min(), libMesh::ExodusII_IO_Helper::num_elem, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
540 {
541   elem_num_map\&.resize(num_elem);
542 
543   ex_err = exII::ex_get_elem_num_map (ex_id,
544                                       elem_num_map\&.empty() ? NULL : &elem_num_map[0]);
545 
546   EX_CHECK_ERR(ex_err, "Error retrieving element number map\&.");
547   message("Element numbering map retrieved successfully\&.");
548 
549 
550   if (verbose)
551     {
552       libMesh::out << "[" << this->processor_id() << "] elem_num_map[i] = ";
553       for (unsigned int i=0; i<static_cast<unsigned int>(std::min(10, num_elem-1)); ++i)
554         libMesh::out << elem_num_map[i] << ", ";
555       libMesh::out << "\&.\&.\&. " << elem_num_map\&.back() << std::endl;
556     }
557 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_elemental_var_values (std::stringelemental_var_name, inttime_step)\fC [inherited]\fP"
Reads elemental values for the variable 'elemental_var_name' at the specified timestep into the 'elem_var_values' array\&. 
.PP
Definition at line 907 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::block_ids, libMesh::ExodusII_IO_Helper::elem_var_names, libMesh::ExodusII_IO_Helper::elem_var_values, libMesh::ExodusII_IO_Helper::ELEMENTAL, libMesh::err, libMesh::ExodusII_IO_Helper::ex_err, ex_get_elem_block(), ex_get_elem_var(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::num_elem, libMesh::ExodusII_IO_Helper::num_elem_blk, and libMesh::ExodusII_IO_Helper::read_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution()\&.
.PP
.nf
908 {
909   // CAUTION: this assumes that libMesh element numbering is identical to exodus block-by-block element numbering
910   // There is no way how to get the whole elemental field from the exodus file, so we have to go block by block
911 
912   elem_var_values\&.resize(num_elem);
913 
914   this->read_var_names(ELEMENTAL);
915 
916   // See if we can find the variable we are looking for
917   unsigned int var_index = 0;
918   bool found = false;
919 
920   // Do a linear search for nodal_var_name in nodal_var_names
921   for (; var_index<elem_var_names\&.size(); ++var_index)
922     {
923       found = (elem_var_names[var_index] == elemental_var_name);
924       if (found)
925         break;
926     }
927 
928   if (!found)
929     {
930       libMesh::err << "Unable to locate variable named: " << elemental_var_name << std::endl;
931       libMesh::err << "Available variables: " << std::endl;
932       for (unsigned int i=0; i<elem_var_names\&.size(); ++i)
933         libMesh::err << elem_var_names[i] << std::endl;
934 
935       libmesh_error();
936     }
937 
938   unsigned int ex_el_num = 0;
939   for (unsigned int i=0; i<static_cast<unsigned int>(num_elem_blk); i++)
940     {
941       int n_blk_elems = 0;
942       ex_err = exII::ex_get_elem_block(ex_id,
943                                        block_ids[i],
944                                        NULL,
945                                        &n_blk_elems,
946                                        NULL,
947                                        NULL);
948       EX_CHECK_ERR(ex_err, "Error getting number of elements in block\&.");
949 
950       std::vector<Real> block_elem_var_values(num_elem);
951       ex_err = exII::ex_get_elem_var(ex_id,
952                                      time_step,
953                                      var_index+1,
954                                      block_ids[i],
955                                      n_blk_elems,
956                                      &block_elem_var_values[0]);
957       EX_CHECK_ERR(ex_err, "Error getting elemental values\&.");
958 
959       for (unsigned int j=0; j<static_cast<unsigned int>(n_blk_elems); j++)
960         {
961           elem_var_values[ex_el_num] = block_elem_var_values[j];
962           ex_el_num++;
963         }
964     }
965 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_header ()\fC [inherited]\fP"
Reads an \fCExodusII\fP mesh file header\&. 
.PP
Definition at line 328 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_init(), ex_get_var_param(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::num_dim, libMesh::ExodusII_IO_Helper::num_elem, libMesh::ExodusII_IO_Helper::num_elem_blk, libMesh::ExodusII_IO_Helper::num_elem_vars, libMesh::ExodusII_IO_Helper::num_global_vars, libMesh::ExodusII_IO_Helper::num_nodal_vars, libMesh::ExodusII_IO_Helper::num_node_sets, libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::num_side_sets, libMesh::ExodusII_IO_Helper::read_num_time_steps(), and libMesh::ExodusII_IO_Helper::title\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.PP
.nf
329 {
330   ex_err = exII::ex_get_init(ex_id,
331                              &title[0],
332                              &num_dim,
333                              &num_nodes,
334                              &num_elem,
335                              &num_elem_blk,
336                              &num_node_sets,
337                              &num_side_sets);
338 
339   EX_CHECK_ERR(ex_err, "Error retrieving header info\&.");
340 
341   this->read_num_time_steps();
342 
343   ex_err = exII::ex_get_var_param(ex_id, "n", &num_nodal_vars);
344   EX_CHECK_ERR(ex_err, "Error reading number of nodal variables\&.");
345 
346   ex_err = exII::ex_get_var_param(ex_id, "e", &num_elem_vars);
347   EX_CHECK_ERR(ex_err, "Error reading number of elemental variables\&.");
348 
349   ex_err = exII::ex_get_var_param(ex_id, "g", &num_global_vars);
350   EX_CHECK_ERR(ex_err, "Error reading number of global variables\&.");
351 
352   message("Exodus header info retrieved successfully\&.");
353 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodal_var_values (std::stringnodal_var_name, inttime_step)\fC [inherited]\fP"
Reads the nodal values for the variable 'nodal_var_name' at the specified time into the 'nodal_var_values' array\&. 
.PP
Definition at line 752 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::err, libMesh::ExodusII_IO_Helper::ex_err, ex_get_nodal_var(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::NODAL, libMesh::ExodusII_IO_Helper::nodal_var_names, libMesh::ExodusII_IO_Helper::nodal_var_values, libMesh::ExodusII_IO_Helper::num_nodes, and libMesh::ExodusII_IO_Helper::read_var_names()\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_nodal_solution()\&.
.PP
.nf
753 {
754   // Read the nodal variable names from file, so we can see if we have the one we're looking for
755   this->read_var_names(NODAL);
756 
757   // See if we can find the variable we are looking for
758   unsigned int var_index = 0;
759   bool found = false;
760 
761   // Do a linear search for nodal_var_name in nodal_var_names
762   for (; var_index<nodal_var_names\&.size(); ++var_index)
763     {
764       found = (nodal_var_names[var_index] == nodal_var_name);
765       if (found)
766         break;
767     }
768 
769   if (!found)
770     {
771       libMesh::err << "Unable to locate variable named: " << nodal_var_name << std::endl;
772       libMesh::err << "Available variables: " << std::endl;
773       for (unsigned int i=0; i<nodal_var_names\&.size(); ++i)
774         libMesh::err << nodal_var_names[i] << std::endl;
775 
776       libmesh_error();
777     }
778 
779   // Allocate enough space to store the nodal variable values
780   nodal_var_values\&.resize(num_nodes);
781 
782   // Call the Exodus API to read the nodal variable values
783   ex_err = exII::ex_get_nodal_var(ex_id,
784                                   time_step,
785                                   var_index+1,
786                                   num_nodes,
787                                   &nodal_var_values[0]);
788   EX_CHECK_ERR(ex_err, "Error reading nodal variable values!");
789 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_node_num_map ()\fC [inherited]\fP"
Reads the optional \fCnode_num_map\fP from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 389 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_node_num_map(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), std::min(), libMesh::ExodusII_IO_Helper::node_num_map, libMesh::ExodusII_IO_Helper::num_nodes, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
390 {
391   node_num_map\&.resize(num_nodes);
392 
393   ex_err = exII::ex_get_node_num_map (ex_id,
394                                       node_num_map\&.empty() ? NULL : &node_num_map[0]);
395 
396   EX_CHECK_ERR(ex_err, "Error retrieving nodal number map\&.");
397   message("Nodal numbering map retrieved successfully\&.");
398 
399   if (verbose)
400     {
401       libMesh::out << "[" << this->processor_id() << "] node_num_map[i] = ";
402       for (unsigned int i=0; i<static_cast<unsigned int>(std::min(10, num_nodes-1)); ++i)
403         libMesh::out << node_num_map[i] << ", ";
404       libMesh::out << "\&.\&.\&. " << node_num_map\&.back() << std::endl;
405     }
406 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodes ()\fC [inherited]\fP"
Reads the nodal data (x,y,z coordinates) from the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 372 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_coord(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::x, libMesh::ExodusII_IO_Helper::y, and libMesh::ExodusII_IO_Helper::z\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
373 {
374   x\&.resize(num_nodes);
375   y\&.resize(num_nodes);
376   z\&.resize(num_nodes);
377 
378   ex_err = exII::ex_get_coord(ex_id,
379                               static_cast<void*>(&x[0]),
380                               static_cast<void*>(&y[0]),
381                               static_cast<void*>(&z[0]));
382 
383   EX_CHECK_ERR(ex_err, "Error retrieving nodal data\&.");
384   message("Nodal data retrieved successfully\&.");
385 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodeset (intid)\fC [inherited]\fP"
Reads information about nodeset \fCid\fP and inserts it into the global nodeset array at the position \fCoffset\fP\&. 
.PP
Definition at line 665 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_node_set(), ex_get_node_set_param(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::node_list, libMesh::ExodusII_IO_Helper::nodeset_ids, libMesh::ExodusII_IO_Helper::num_node_df_per_set, and libMesh::ExodusII_IO_Helper::num_nodes_per_set\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
666 {
667   libmesh_assert_less (static_cast<unsigned int>(id), nodeset_ids\&.size());
668   libmesh_assert_less (static_cast<unsigned int>(id), num_nodes_per_set\&.size());
669   libmesh_assert_less (static_cast<unsigned int>(id), num_node_df_per_set\&.size());
670 
671   ex_err = exII::ex_get_node_set_param(ex_id,
672                                        nodeset_ids[id],
673                                        &num_nodes_per_set[id],
674                                        &num_node_df_per_set[id]);
675   EX_CHECK_ERR(ex_err, "Error retrieving nodeset parameters\&.");
676   message("Parameters retrieved successfully for nodeset: ", id);
677 
678   node_list\&.resize(num_nodes_per_set[id]);
679 
680   // Don't call ex_get_node_set unless there are actually nodes there to get\&.
681   // Exodus prints an annoying warning message in DEBUG mode otherwise\&.\&.\&.
682   if (num_nodes_per_set[id] > 0)
683     {
684       ex_err = exII::ex_get_node_set(ex_id,
685                                      nodeset_ids[id],
686                                      &node_list[0]);
687 
688       EX_CHECK_ERR(ex_err, "Error retrieving nodeset data\&.");
689       message("Data retrieved successfully for nodeset: ", id);
690     }
691 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_nodeset_info ()\fC [inherited]\fP"
Reads information about all of the nodesets in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 594 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_name(), ex_get_node_set_ids(), libMesh::ExodusII_IO_Helper::ex_id, EX_NODE_SET, libMesh::ExodusII_IO_Helper::id_to_ns_names, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::nodeset_ids, libMesh::ExodusII_IO_Helper::num_node_df_per_set, libMesh::ExodusII_IO_Helper::num_node_sets, and libMesh::ExodusII_IO_Helper::num_nodes_per_set\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
595 {
596   nodeset_ids\&.resize(num_node_sets);
597   if (num_node_sets > 0)
598     {
599       ex_err = exII::ex_get_node_set_ids(ex_id,
600                                          &nodeset_ids[0]);
601       EX_CHECK_ERR(ex_err, "Error retrieving nodeset information\&.");
602       message("All nodeset information retrieved successfully\&.");
603 
604       // Resize appropriate data structures -- only do this once outnode the loop
605       num_nodes_per_set\&.resize(num_node_sets);
606       num_node_df_per_set\&.resize(num_node_sets);
607     }
608 
609   char name_buffer[MAX_STR_LENGTH+1];
610   for (int i=0; i<num_node_sets; ++i)
611     {
612       ex_err = exII::ex_get_name(ex_id, exII::EX_NODE_SET,
613                                  nodeset_ids[i], name_buffer);
614       EX_CHECK_ERR(ex_err, "Error getting node set name\&.");
615       id_to_ns_names[nodeset_ids[i]] = name_buffer;
616     }
617   message("All node set names retrieved successfully\&.");
618 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_num_time_steps ()\fC [inherited]\fP"
Reads the number of timesteps currently stored in the Exodus file and stores it in the num_time_steps variable\&. 
.PP
Definition at line 744 of file exodusII_io_helper\&.C\&.
.PP
References EX_INQ_TIME, libMesh::ExodusII_IO_Helper::inquire(), and libMesh::ExodusII_IO_Helper::num_time_steps\&.
.PP
Referenced by libMesh::ExodusII_IO::get_num_time_steps(), libMesh::ExodusII_IO_Helper::read_header(), and libMesh::ExodusII_IO_Helper::read_time_steps()\&.
.PP
.nf
745 {
746   num_time_steps =
747     this->inquire(exII::EX_INQ_TIME, "Error retrieving number of time steps");
748 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_sideset (intid, intoffset)\fC [inherited]\fP"
Reads information about sideset \fCid\fP and inserts it into the global sideset array at the position \fCoffset\fP\&. 
.PP
Definition at line 622 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::elem_list, libMesh::ExodusII_IO_Helper::ex_err, ex_get_side_set(), ex_get_side_set_param(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::id_list, libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::num_df_per_set, libMesh::ExodusII_IO_Helper::num_sides_per_set, libMesh::ExodusII_IO_Helper::side_list, and libMesh::ExodusII_IO_Helper::ss_ids\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
623 {
624   libmesh_assert_less (static_cast<unsigned int>(id), ss_ids\&.size());
625   libmesh_assert_less (static_cast<unsigned int>(id), num_sides_per_set\&.size());
626   libmesh_assert_less (static_cast<unsigned int>(id), num_df_per_set\&.size());
627   libmesh_assert_less_equal (static_cast<unsigned int>(offset), elem_list\&.size());
628   libmesh_assert_less_equal (static_cast<unsigned int>(offset), side_list\&.size());
629 
630   ex_err = exII::ex_get_side_set_param(ex_id,
631                                        ss_ids[id],
632                                        &num_sides_per_set[id],
633                                        &num_df_per_set[id]);
634   EX_CHECK_ERR(ex_err, "Error retrieving sideset parameters\&.");
635   message("Parameters retrieved successfully for sideset: ", id);
636 
637 
638   // It's OK for offset==elem_list\&.size() as long as num_sides_per_set[id]==0
639   // because in that case we don't actually read anything\&.\&.\&.
640 #ifdef DEBUG
641   if (static_cast<unsigned int>(offset) == elem_list\&.size() ||
642       static_cast<unsigned int>(offset) == side_list\&.size() )
643     libmesh_assert_equal_to (num_sides_per_set[id], 0);
644 #endif
645 
646 
647   // Don't call ex_get_side_set unless there are actually sides there to get\&.
648   // Exodus prints an annoying warning in DEBUG mode otherwise\&.\&.\&.
649   if (num_sides_per_set[id] > 0)
650     {
651       ex_err = exII::ex_get_side_set(ex_id,
652                                      ss_ids[id],
653                                      &elem_list[offset],
654                                      &side_list[offset]);
655       EX_CHECK_ERR(ex_err, "Error retrieving sideset data\&.");
656       message("Data retrieved successfully for sideset: ", id);
657 
658       for (int i=0; i<num_sides_per_set[id]; i++)
659         id_list[i+offset] = ss_ids[id];
660     }
661 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_sideset_info ()\fC [inherited]\fP"
Reads information about all of the sidesets in the \fCExodusII\fP mesh file\&. 
.PP
Definition at line 561 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::elem_list, libMesh::ExodusII_IO_Helper::ex_err, ex_get_name(), ex_get_side_set_ids(), libMesh::ExodusII_IO_Helper::ex_id, EX_INQ_SS_ELEM_LEN, EX_SIDE_SET, libMesh::ExodusII_IO_Helper::id_list, libMesh::ExodusII_IO_Helper::id_to_ss_names, libMesh::ExodusII_IO_Helper::inquire(), libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::num_df_per_set, libMesh::ExodusII_IO_Helper::num_elem_all_sidesets, libMesh::ExodusII_IO_Helper::num_side_sets, libMesh::ExodusII_IO_Helper::num_sides_per_set, libMesh::ExodusII_IO_Helper::side_list, and libMesh::ExodusII_IO_Helper::ss_ids\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO::read()\&.
.PP
.nf
562 {
563   ss_ids\&.resize(num_side_sets);
564   if (num_side_sets > 0)
565     {
566       ex_err = exII::ex_get_side_set_ids(ex_id,
567                                          &ss_ids[0]);
568       EX_CHECK_ERR(ex_err, "Error retrieving sideset information\&.");
569       message("All sideset information retrieved successfully\&.");
570 
571       // Resize appropriate data structures -- only do this once outside the loop
572       num_sides_per_set\&.resize(num_side_sets);
573       num_df_per_set\&.resize(num_side_sets);
574 
575       // Inquire about the length of the concatenated side sets element list
576       num_elem_all_sidesets = inquire(exII::EX_INQ_SS_ELEM_LEN, "Error retrieving length of the concatenated side sets element list!");
577 
578       elem_list\&.resize (num_elem_all_sidesets);
579       side_list\&.resize (num_elem_all_sidesets);
580       id_list\&.resize   (num_elem_all_sidesets);
581     }
582 
583   char name_buffer[MAX_STR_LENGTH+1];
584   for (int i=0; i<num_side_sets; ++i)
585     {
586       ex_err = exII::ex_get_name(ex_id, exII::EX_SIDE_SET,
587                                  ss_ids[i], name_buffer);
588       EX_CHECK_ERR(ex_err, "Error getting side set name\&.");
589       id_to_ss_names[ss_ids[i]] = name_buffer;
590     }
591   message("All side set names retrieved successfully\&.");
592 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::read_time_steps ()\fC [inherited]\fP"
Reads and stores the timesteps in the 'time_steps' array\&. 
.PP
Definition at line 729 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ex_err, ex_get_all_times(), libMesh::ExodusII_IO_Helper::ex_id, libMesh::ExodusII_IO_Helper::num_time_steps, libMesh::ExodusII_IO_Helper::read_num_time_steps(), and libMesh::ExodusII_IO_Helper::time_steps\&.
.PP
Referenced by libMesh::ExodusII_IO::get_time_steps()\&.
.PP
.nf
730 {
731   // Make sure we have an up-to-date count of the number of time steps in the file\&.
732   this->read_num_time_steps();
733 
734   if (num_time_steps > 0)
735     {
736       time_steps\&.resize(num_time_steps);
737       ex_err = exII::ex_get_all_times(ex_id, &time_steps[0]);
738       EX_CHECK_ERR(ex_err, "Error reading timesteps!");
739     }
740 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::set_coordinate_offset (\fBPoint\fPp)\fC [inherited]\fP"
Allows you to set a vector that is added to the coordinates of all of the nodes\&. Effectively, this 'moves' the mesh to a particular position 
.PP
Definition at line 1780 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_coordinate_offset\&.
.PP
Referenced by libMesh::ExodusII_IO::set_coordinate_offset()\&.
.PP
.nf
1781 {
1782   _coordinate_offset = p;
1783 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::use_mesh_dimension_instead_of_spatial_dimension (boolval)\fC [inherited]\fP"
Sets the underlying value of the boolean flag _use_mesh_dimension_instead_of_spatial_dimension\&. By default, the value of this flag is false\&.
.PP
See the \fBExodusII_IO\fP class documentation for a detailed description of this flag\&. 
.PP
Definition at line 1775 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_use_mesh_dimension_instead_of_spatial_dimension\&.
.PP
Referenced by libMesh::ExodusII_IO::use_mesh_dimension_instead_of_spatial_dimension()\&.
.PP
.nf
1776 {
1777   _use_mesh_dimension_instead_of_spatial_dimension = val;
1778 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_element_values (const \fBMeshBase\fP &mesh, const std::vector< \fBReal\fP > &values, inttimestep)\fC [inherited]\fP"
Writes the vector of values to the element variables\&. 
.PP
Definition at line 1612 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::_single_precision, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), data, end, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_elem_var(), ex_update(), libMesh::ExodusII_IO_Helper::get_block_id(), libMesh::DofObject::id(), libMesh::ExodusII_IO_Helper::num_elem, libMesh::ParallelObject::processor_id(), and libMesh::Elem::subdomain_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_element_data()\&.
.PP
.nf
1613 {
1614   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1615     return;
1616 
1617   // Loop over the element blocks and write the data one block at a time
1618   std::map<unsigned int, std::vector<unsigned int> > subdomain_map;
1619 
1620   const unsigned int num_vars = values\&.size() / num_elem;
1621 
1622   MeshBase::const_element_iterator mesh_it = mesh\&.active_elements_begin();
1623   const MeshBase::const_element_iterator end = mesh\&.active_elements_end();
1624 
1625   // loop through element and map between block and element vector
1626   for (; mesh_it!=end; ++mesh_it)
1627     {
1628       const Elem * elem = *mesh_it;
1629       subdomain_map[elem->subdomain_id()]\&.push_back(elem->id());
1630     }
1631 
1632   // For each variable, create a 'data' array which holds all the elemental variable
1633   // values *for a given block* on this processor, then write that data vector to file
1634   // before moving onto the next block\&.
1635   for (unsigned int i=0; i<num_vars; ++i)
1636     {
1637       // The size of the subdomain map is the number of blocks\&.
1638       std::map<unsigned int, std::vector<unsigned int> >::iterator it = subdomain_map\&.begin();
1639 
1640       for (unsigned int j=0; it!=subdomain_map\&.end(); ++it, ++j)
1641         {
1642           const std::vector<unsigned int> & elem_nums = (*it)\&.second;
1643           const unsigned int num_elems_this_block = elem_nums\&.size();
1644           std::vector<Real> data(num_elems_this_block);
1645 
1646           for (unsigned int k=0; k<num_elems_this_block; ++k)
1647             data[k] = values[i*num_elem + elem_nums[k]];
1648 
1649           if(_single_precision)
1650             {
1651               std::vector<float> cast_data(num_elems_this_block);
1652               for (unsigned int l=0; l<num_elems_this_block; ++l)
1653                 {
1654                   cast_data[l] = static_cast<float>(data[l]);
1655                 }
1656               ex_err = exII::ex_put_elem_var(ex_id,
1657                                              timestep,
1658                                              i+1,
1659                                              this->get_block_id(j),
1660                                              num_elems_this_block,
1661                                              &cast_data[0]);
1662             }
1663           else
1664             {
1665               ex_err = exII::ex_put_elem_var(ex_id,
1666                                              timestep,
1667                                              i+1,
1668                                              this->get_block_id(j),
1669                                              num_elems_this_block,
1670                                              &data[0]);
1671             }
1672           EX_CHECK_ERR(ex_err, "Error writing element values\&.");
1673         }
1674     }
1675 
1676   ex_err = exII::ex_update(ex_id);
1677   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1678 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_elements (const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
This function is specialized to write the connectivity\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 2352 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), block_id_to_elem_connectivity, libMesh::MeshBase::elem(), libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_elem_block(), ex_put_elem_conn(), ex_put_elem_num_map(), libMesh::ExodusII_IO_Helper::exodus_elem_num_to_libmesh, libMesh::ExodusII_IO_Helper::Conversion::exodus_elem_type(), global_elem_blk_ids, libMesh::Elem::n_nodes(), num_elem_blks_global, libMesh::ExodusII_IO_Helper::num_nodes_per_elem, subdomain_map, and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2353 {
2354 
2355   // Loop over all blocks, even if we don't have elements in each block\&.
2356   // If we don't have elements we need to write out a 0 for that block\&.\&.\&.
2357   for (unsigned int i=0; i<static_cast<unsigned>(this->num_elem_blks_global); ++i)
2358     {
2359       // Search for the current global block ID in the map
2360       std::map<int, std::vector<int> >::iterator it =
2361         this->block_id_to_elem_connectivity\&.find( this->global_elem_blk_ids[i] );
2362 
2363       // If not found, write a zero to file\&.\&.\&.\&.
2364       if (it == this->block_id_to_elem_connectivity\&.end())
2365         {
2366           this->ex_err = exII::ex_put_elem_block(this->ex_id,
2367                                                  this->global_elem_blk_ids[i],
2368                                                  "Empty",
2369                                                  0, /* n\&. elements in this block */
2370                                                  0, /* n\&. nodes per element */
2371                                                  0);  /* number of attributes per element */
2372 
2373           EX_CHECK_ERR(this->ex_err, "Error writing element block from Nemesis\&.");
2374         }
2375 
2376       // Otherwise, write the actual block information and connectivity to file
2377       else
2378         {
2379           int block = (*it)\&.first;
2380           std::vector<int> & this_block_connectivity = (*it)\&.second;
2381           std::vector<unsigned int> & elements_in_this_block = subdomain_map[block];
2382 
2383           ExodusII_IO_Helper::ElementMaps em;
2384 
2385           //Use the first element in this block to get representative information\&.
2386           //Note that Exodus assumes all elements in a block are of the same type!
2387           //We are using that same assumption here!
2388           const ExodusII_IO_Helper::Conversion conv =
2389             em\&.assign_conversion(mesh\&.elem(elements_in_this_block[0])->type());
2390 
2391           this->num_nodes_per_elem = mesh\&.elem(elements_in_this_block[0])->n_nodes();
2392 
2393           ex_err = exII::ex_put_elem_block(ex_id,
2394                                            block,
2395                                            conv\&.exodus_elem_type()\&.c_str(),
2396                                            elements_in_this_block\&.size(),
2397                                            num_nodes_per_elem,
2398                                            0);
2399           EX_CHECK_ERR(ex_err, "Error writing element block from Nemesis\&.");
2400 
2401           ex_err = exII::ex_put_elem_conn(ex_id,
2402                                           block,
2403                                           &this_block_connectivity[0]);
2404           EX_CHECK_ERR(ex_err, "Error writing element connectivities from Nemesis\&.");
2405         }
2406     } // end loop over global block IDs
2407 
2408   // Only call this once, not in the loop above!
2409   ex_err = exII::ex_put_elem_num_map(ex_id,
2410                                      exodus_elem_num_to_libmesh\&.empty() ? NULL : &exodus_elem_num_to_libmesh[0]);
2411   EX_CHECK_ERR(ex_err, "Error writing element map");
2412 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_exodus_initialization_info (const \fBMeshBase\fP &pmesh, const std::string &title)\fC [private]\fP"
This function writes exodus-specific initialization information\&. This information is slightly different when you are working with \fBNemesis\fP, as it depends on some global information being known\&. 
.PP
Definition at line 914 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_init(), global_nodeset_ids, global_sideset_ids, libMesh::ExodusII_IO_Helper::num_dim, libMesh::ExodusII_IO_Helper::num_elem, libMesh::ExodusII_IO_Helper::num_elem_blk, num_elem_blks_global, libMesh::ExodusII_IO_Helper::num_node_sets, libMesh::ExodusII_IO_Helper::num_nodes, libMesh::ExodusII_IO_Helper::num_side_sets, and libMesh::MeshBase::spatial_dimension()\&.
.PP
Referenced by initialize()\&.
.PP
.nf
916 {
917   // This follows the convention of Exodus: we always write out the mesh as LIBMESH_DIM-dimensional,
918   // even if it is 2D\&.\&.\&.
919   this->num_dim = pmesh\&.spatial_dimension();
920 
921   this->num_elem = static_cast<unsigned int>(std::distance (pmesh\&.active_local_elements_begin(),
922                                                             pmesh\&.active_local_elements_end()));
923 
924   // Exodus will also use *global* number of side and node sets,
925   // though it will not write out entries for all of them\&.\&.\&.
926   this->num_side_sets =
927     libmesh_cast_int<int>(this->global_sideset_ids\&.size());
928   this->num_node_sets =
929     libmesh_cast_int<int>(this->global_nodeset_ids\&.size());
930 
931   // We need to write the global number of blocks, even though this processor might not have
932   // elements in some of them!
933   this->num_elem_blk = this->num_elem_blks_global;
934 
935   ex_err = exII::ex_put_init(ex_id,
936                              title_in\&.c_str(),
937                              this->num_dim,
938                              this->num_nodes,
939                              this->num_elem,
940                              this->num_elem_blk,
941                              this->num_node_sets,
942                              this->num_side_sets);
943 
944   EX_CHECK_ERR(ex_err, "Error initializing new Nemesis file\&.");
945 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_global_values (const std::vector< \fBReal\fP > &values, inttimestep)\fC [inherited]\fP"
Writes the vector of global variables\&. 
.PP
Definition at line 1748 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::_single_precision, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_glob_vars(), ex_update(), libMesh::ExodusII_IO_Helper::num_global_vars, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_global_data(), and libMesh::ExodusII_IO::write_global_data()\&.
.PP
.nf
1749 {
1750   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1751     return;
1752 
1753   if(_single_precision)
1754     {
1755       unsigned int num_values = values\&.size();
1756       std::vector<float> cast_values(num_values);
1757 
1758       for (unsigned int i=0; i<num_values; ++i)
1759         cast_values[i] = static_cast<float>(values[i]);
1760 
1761       ex_err = exII::ex_put_glob_vars(ex_id, timestep, num_global_vars, &cast_values[0]);
1762     }
1763   else
1764     {
1765       ex_err = exII::ex_put_glob_vars(ex_id, timestep, num_global_vars, &values[0]);
1766     }
1767   EX_CHECK_ERR(ex_err, "Error writing global values\&.");
1768 
1769   ex_err = exII::ex_update(ex_id);
1770   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1771 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_information_records (const std::vector< std::string > &records)\fC [inherited]\fP"
Writes the vector of information records\&. 
.PP
Definition at line 1709 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::err, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, EX_INQ_INFO, ex_put_info(), ex_update(), libMesh::ExodusII_IO_Helper::NamesData::get_char_star_star(), libMesh::ExodusII_IO_Helper::inquire(), libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::NamesData::push_back_entry()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_information_records(), and libMesh::ExodusII_IO::write_information_records()\&.
.PP
.nf
1710 {
1711   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1712     return;
1713 
1714   // There may already be information records in the file (for
1715   // example, if we're appending) and in that case, according to the
1716   // Exodus documentation, writing more information records is not
1717   // supported\&.
1718   int num_info = inquire(exII::EX_INQ_INFO, "Error retrieving the number of information records from file!");
1719   if (num_info > 0)
1720     {
1721       libMesh::err << "Warning! The Exodus file already contains information records\&.\n"
1722                    << "Exodus does not support writing additional records in this situation\&."
1723                    << std::endl;
1724       return;
1725     }
1726 
1727   int num_records = records\&.size();
1728 
1729   if (num_records > 0)
1730     {
1731       NamesData info(num_records, MAX_LINE_LENGTH);
1732 
1733       // If an entry is longer than MAX_LINE_LENGTH characters it's not an error, we just
1734       // write the first MAX_LINE_LENGTH characters to the file\&.
1735       for (unsigned i=0; i<records\&.size(); ++i)
1736         info\&.push_back_entry(records[i]);
1737 
1738       ex_err = exII::ex_put_info(ex_id, num_records, info\&.get_char_star_star());
1739       EX_CHECK_ERR(ex_err, "Error writing global values\&.");
1740 
1741       ex_err = exII::ex_update(ex_id);
1742       EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1743     }
1744 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_nodal_coordinates (const \fBMeshBase\fP &mesh, booluse_discontinuous = \fCfalse\fP)\fC [virtual]\fP"
This function is specialized from \fBExodusII_IO_Helper\fP to write only the nodal coordinates stored on the local piece of the \fBMesh\fP\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 2293 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_single_precision, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_coord(), ex_put_node_num_map(), libMesh::ExodusII_IO_Helper::exodus_node_num_to_libmesh, libMesh::MeshBase::node_ptr(), libMesh::ExodusII_IO_Helper::x, libMesh::ExodusII_IO_Helper::y, and libMesh::ExodusII_IO_Helper::z\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2294 {
2295   // Make sure that the reference passed in is really a ParallelMesh
2296   // const ParallelMesh& pmesh = libmesh_cast_ref<const ParallelMesh&>(mesh);
2297 
2298   unsigned local_num_nodes = this->exodus_node_num_to_libmesh\&.size();
2299 
2300   x\&.resize(local_num_nodes);
2301   y\&.resize(local_num_nodes);
2302   z\&.resize(local_num_nodes);
2303 
2304   // Just loop over our list outputing the nodes the way we built the map
2305   for (unsigned int i=0; i<local_num_nodes; ++i)
2306     {
2307       const Node & node = *mesh\&.node_ptr(this->exodus_node_num_to_libmesh[i]);
2308       x[i]=node(0);
2309       y[i]=node(1);
2310       z[i]=node(2);
2311     }
2312 
2313   if (local_num_nodes)
2314     {
2315       if(_single_precision)
2316         {
2317           std::vector<float> x_single(local_num_nodes), y_single(local_num_nodes), z_single(local_num_nodes);
2318           for (unsigned int i=0; i<local_num_nodes; ++i)
2319             {
2320               x_single[i] = static_cast<float>(x[i]);
2321               y_single[i] = static_cast<float>(y[i]);
2322               z_single[i] = static_cast<float>(z[i]);
2323             }
2324 
2325           ex_err = exII::ex_put_coord(ex_id, &x_single[0], &y_single[0], &z_single[0]);
2326         }
2327       else
2328         {
2329           // Call Exodus API to write nodal coordinates\&.\&.\&.
2330           ex_err = exII::ex_put_coord(ex_id, &x[0], &y[0], &z[0]);
2331         }
2332       EX_CHECK_ERR(ex_err, "Error writing node coordinates");
2333 
2334       // And write the nodal map we created for them
2335       ex_err = exII::ex_put_node_num_map(ex_id, &(this->exodus_node_num_to_libmesh[0]));
2336       EX_CHECK_ERR(ex_err, "Error writing node num map");
2337     }
2338   else // Does the Exodus API want us to write empty nodal coordinates?
2339     {
2340       ex_err = exII::ex_put_coord(ex_id, NULL, NULL, NULL);
2341       EX_CHECK_ERR(ex_err, "Error writing empty node coordinates");
2342 
2343       ex_err = exII::ex_put_node_num_map(ex_id, NULL);
2344       EX_CHECK_ERR(ex_err, "Error writing empty node num map");
2345     }
2346 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_nodal_solution (const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &names, inttimestep)"
Takes a solution vector containing the solution for all variables and outputs it to the files 
.PP
Definition at line 2419 of file nemesis_io_helper\&.C\&.
.PP
References std::abs()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2422 {
2423   int num_vars = names\&.size();
2424   //int num_values = values\&.size(); // Not used?
2425 
2426   for (int c=0; c<num_vars; c++)
2427     {
2428 #ifdef LIBMESH_USE_COMPLEX_NUMBERS
2429       std::vector<Real> real_parts(num_nodes);
2430       std::vector<Real> imag_parts(num_nodes);
2431       std::vector<Real> magnitudes(num_nodes);
2432 
2433       for (int i=0; i<num_nodes; ++i)
2434         {
2435           Number value = values[this->exodus_node_num_to_libmesh[i]*num_vars + c];
2436           real_parts[i] = value\&.real();
2437           imag_parts[i] = value\&.imag();
2438           magnitudes[i] = std::abs(value);
2439         }
2440       write_nodal_values(3*c+1,real_parts,timestep);
2441       write_nodal_values(3*c+2,imag_parts,timestep);
2442       write_nodal_values(3*c+3,magnitudes,timestep);
2443 #else
2444       std::vector<Number> cur_soln(num_nodes);
2445 
2446       // Copy out this variable's solution
2447       for (int i=0; i<num_nodes; i++)
2448         cur_soln[i] = values[this->exodus_node_num_to_libmesh[i]*num_vars + c];
2449 
2450       write_nodal_values(c+1,cur_soln,timestep);
2451 #endif
2452     }
2453 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_nodal_values (intvar_id, const std::vector< \fBReal\fP > &values, inttimestep)\fC [inherited]\fP"
Writes the vector of values to a nodal variable\&. 
.PP
Definition at line 1682 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::_single_precision, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_nodal_var(), ex_update(), libMesh::ExodusII_IO_Helper::num_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.PP
.nf
1683 {
1684   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1685     return;
1686 
1687   if(_single_precision)
1688     {
1689       unsigned int num_values = values\&.size();
1690       std::vector<float> cast_values(num_values);
1691       for (unsigned int i=0; i<num_values; ++i)
1692         {
1693           cast_values[i] = static_cast<float>(values[i]);
1694         }
1695       ex_err = exII::ex_put_nodal_var(ex_id, timestep, var_id, num_nodes, &cast_values[0]);
1696     }
1697   else
1698     {
1699       ex_err = exII::ex_put_nodal_var(ex_id, timestep, var_id, num_nodes, &values[0]);
1700     }
1701   EX_CHECK_ERR(ex_err, "Error writing nodal values\&.");
1702 
1703   ex_err = exII::ex_update(ex_id);
1704   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1705 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_nodesets (const \fBMeshBase\fP &mesh)\fC [virtual]\fP"
Writes the nodesets for this processor\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 2005 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::MeshBase::boundary_info, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_node_set(), ex_put_node_set_param(), global_nodeset_ids, libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus, libMesh::out, libMesh::ParallelObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2006 {
2007   // Write the nodesets\&.  In Nemesis, the idea is to "create space" for the global
2008   // set of boundary nodesets, but to only write node IDs which are local to the current
2009   // processor\&.  This is what is done in Nemesis files created by the "loadbal" script\&.
2010 
2011   // Store a map of vectors for boundary node IDs on this processor\&.
2012   // Use a vector of int here so it can be passed directly to Exodus\&.
2013   std::map<boundary_id_type, std::vector<int> > local_node_boundary_id_lists;
2014   typedef std::map<boundary_id_type, std::vector<int> >::iterator local_node_boundary_id_lists_iterator;
2015 
2016   // FIXME: We should build this list only one time!!  We already built it above, but we
2017   // did not have the libmesh to exodus node mapping at that time\&.\&.\&. for now we'll just
2018   // build it here again, hopefully it's small relative to the size of the entire mesh\&.
2019   std::vector<dof_id_type> boundary_node_list;
2020   std::vector<boundary_id_type> boundary_node_boundary_id_list;
2021   mesh\&.boundary_info->build_node_list(boundary_node_list, boundary_node_boundary_id_list);
2022 
2023   if (verbose)
2024     {
2025       libMesh::out << "[" << this->processor_id() << "] boundary_node_list\&.size()="
2026                    << boundary_node_list\&.size() << std::endl;
2027       libMesh::out << "[" << this->processor_id() << "] (boundary_node_id, boundary_id) = ";
2028       for (unsigned i=0; i<boundary_node_list\&.size(); ++i)
2029         {
2030           libMesh::out << "(" << boundary_node_list[i] << ", " << boundary_node_boundary_id_list[i] << ") ";
2031         }
2032       libMesh::out << std::endl;
2033     }
2034 
2035   // For each node in the node list, add it to the vector of node IDs for that
2036   // set for the local processor\&.  This will be used later when writing Exodus
2037   // nodesets\&.
2038   for (unsigned i=0; i<boundary_node_list\&.size(); ++i)
2039     {
2040       // Don't try to grab a reference to the vector unless the current node is attached
2041       // to a local element\&.  Otherwise, another processor will be responsible for writing it in its nodeset\&.
2042       std::map<int, int>::iterator it = this->libmesh_node_num_to_exodus\&.find( boundary_node_list[i] );
2043 
2044       if ( it != this->libmesh_node_num_to_exodus\&.end() )
2045         {
2046           // Get reference to the vector where this node ID will be inserted\&.  If it
2047           // doesn't yet exist, this will create it\&.
2048           std::vector<int>& current_id_set = local_node_boundary_id_lists[ boundary_node_boundary_id_list[i] ];
2049 
2050           // Push back Exodus-mapped node ID for this set
2051           // TODO: reserve space in these vectors somehow\&.
2052           current_id_set\&.push_back( (*it)\&.second );
2053         }
2054     }
2055 
2056   // See what we got
2057   if (verbose)
2058     {
2059       for (std::map<boundary_id_type, std::vector<int> >::iterator it = local_node_boundary_id_lists\&.begin();
2060            it != local_node_boundary_id_lists\&.end();
2061            ++it)
2062         {
2063           libMesh::out << "[" << this->processor_id() << "] ID: " << (*it)\&.first << ", ";
2064 
2065           std::vector<int>& current_id_set = (*it)\&.second;
2066 
2067           // Libmesh node ID (Exodus Node ID)
2068           for (unsigned j=0; j<current_id_set\&.size(); ++j)
2069             libMesh::out << current_id_set[j]
2070                          << ", ";
2071 
2072           libMesh::out << std::endl;
2073         }
2074     }
2075 
2076   // Loop over *global* nodeset IDs, call the Exodus API\&.  Note that some nodesets may be empty
2077   // for a given processor\&.
2078   for (unsigned i=0; i<this->global_nodeset_ids\&.size(); ++i)
2079     {
2080       if (verbose)
2081         {
2082           libMesh::out << "[" << this->processor_id()
2083                        << "] Writing out Exodus nodeset info for ID: " << global_nodeset_ids[i] << std::endl;
2084         }
2085 
2086       // Convert current global_nodeset_id into an exodus ID, which can't be zero\&.\&.\&.
2087       int exodus_id = global_nodeset_ids[i];
2088 
2089       /*
2090       // Exodus can't handle zero nodeset IDs (?)  Use max short here since
2091       // when libmesh reads it back in, it will want to store it as a short\&.\&.\&.
2092       if (exodus_id==0)
2093       exodus_id = std::numeric_limits<short>::max();
2094       */
2095 
2096       // Try to find this boundary ID in the local list we created
2097       local_node_boundary_id_lists_iterator it =
2098         local_node_boundary_id_lists\&.find(this->global_nodeset_ids[i]);
2099 
2100       // No nodes found for this boundary ID on this processor
2101       if (it == local_node_boundary_id_lists\&.end())
2102         {
2103           if (verbose)
2104             libMesh::out << "[" << this->processor_id()
2105                          << "] No nodeset data for ID: " << global_nodeset_ids[i]
2106                          << " on this processor\&." << std::endl;
2107 
2108           // Call the Exodus interface to write the parameters of this node set
2109           this->ex_err = exII::ex_put_node_set_param(this->ex_id,
2110                                                      exodus_id,
2111                                                      0, /* No nodes for this ID */
2112                                                      0  /* No distribution factors */);
2113           EX_CHECK_ERR(this->ex_err, "Error writing nodeset parameters in Nemesis");
2114 
2115         }
2116       else // Boundary ID *was* found in list
2117         {
2118           // Get reference to the vector of node IDs
2119           std::vector<int>& current_nodeset_ids = (*it)\&.second;
2120 
2121           // Call the Exodus interface to write the parameters of this node set
2122           this->ex_err = exII::ex_put_node_set_param(this->ex_id,
2123                                                      exodus_id,
2124                                                      current_nodeset_ids\&.size(),
2125                                                      0  /* No distribution factors */);
2126 
2127           EX_CHECK_ERR(this->ex_err, "Error writing nodeset parameters in Nemesis");
2128 
2129           // Call Exodus interface to write the actual node IDs for this boundary ID
2130           this->ex_err = exII::ex_put_node_set(this->ex_id,
2131                                                exodus_id,
2132                                                &current_nodeset_ids[0]);
2133 
2134           EX_CHECK_ERR(this->ex_err, "Error writing nodesets in Nemesis");
2135 
2136         }
2137     } // end loop over global nodeset IDs
2138 }
.fi
.SS "void libMesh::Nemesis_IO_Helper::write_sidesets (const \fBMeshBase\fP &mesh)\fC [virtual]\fP"
Writes the sidesets for this processor\&. 
.PP
Reimplemented from \fBlibMesh::ExodusII_IO_Helper\fP\&.
.PP
Definition at line 2143 of file nemesis_io_helper\&.C\&.
.PP
References libMesh::Elem::active_family_tree_by_side(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), libMesh::MeshBase::boundary_info, libMesh::MeshBase::elem(), libMesh::err, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_side_set(), ex_put_side_set_param(), libMesh::ExodusII_IO_Helper::Conversion::get_inverse_side_map(), global_sideset_ids, libMesh::libmesh_assert(), libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), and libMesh::ExodusII_IO_Helper::verbose\&.
.PP
Referenced by libMesh::Nemesis_IO::write(), and libMesh::Nemesis_IO::write_nodal_data()\&.
.PP
.nf
2144 {
2145   // Write the sidesets\&.  In Nemesis, the idea is to "create space" for the global
2146   // set of boundary sidesets, but to only write sideset IDs which are local to the current
2147   // processor\&.  This is what is done in Nemesis files created by the "loadbal" script\&.
2148   // See also: ExodusII_IO_Helper::write_sidesets()\&.\&.\&.
2149 
2150 
2151   // Store a map of vectors for boundary side IDs on this processor\&.
2152   // Use a vector of int here so it can be passed directly to Exodus\&.
2153   std::map<boundary_id_type, std::vector<int> > local_elem_boundary_id_lists;
2154   std::map<boundary_id_type, std::vector<int> > local_elem_boundary_id_side_lists;
2155   typedef std::map<boundary_id_type, std::vector<int> >::iterator local_elem_boundary_id_lists_iterator;
2156 
2157   ExodusII_IO_Helper::ElementMaps em;
2158 
2159   // FIXME: We already built this list once, we should reuse that information!
2160   std::vector< dof_id_type > bndry_elem_list;
2161   std::vector< unsigned short int > bndry_side_list;
2162   std::vector< boundary_id_type > bndry_id_list;
2163 
2164   mesh\&.boundary_info->build_side_list(bndry_elem_list, bndry_side_list, bndry_id_list);
2165 
2166   // Integer looping, skipping non-local elements
2167   for (unsigned i=0; i<bndry_elem_list\&.size(); ++i)
2168     {
2169       // Get pointer to current Elem
2170       const Elem* elem = mesh\&.elem(bndry_elem_list[i]);
2171 
2172       // If element is local, process it
2173       if (elem->processor_id() == this->processor_id())
2174         {
2175           std::vector<const Elem*> family;
2176 #ifdef LIBMESH_ENABLE_AMR
2177           // We need to build up active elements if AMR is enabled and add
2178           // them to the exodus sidesets instead of the potentially inactive "parent" elements
2179           // Technically we don't need to "reset" the tree since the vector was just created\&.
2180           elem->active_family_tree_by_side(family, bndry_side_list[i], /*reset tree=*/false);
2181 #else
2182           // If AMR is not even enabled, just push back the element itself
2183           family\&.push_back( elem );
2184 #endif
2185 
2186           // Loop over all the elements in the family tree, store their converted IDs
2187           // and side IDs to the map's vectors\&.  TODO: Somehow reserve enough space for these
2188           // push_back's\&.\&.\&.
2189           for (unsigned int j=0; j<family\&.size(); ++j)
2190             {
2191               const ExodusII_IO_Helper::Conversion conv = em\&.assign_conversion(mesh\&.elem(family[j]->id())->type());
2192 
2193               // Use the libmesh to exodus datastructure map to get the proper sideset IDs
2194               // The datastructure contains the "collapsed" contiguous ids\&.
2195               //
2196               // We know the parent element is local, but let's be absolutely sure that all the children have been
2197               // actually mapped to Exodus IDs before we blindly try to add them\&.\&.\&.
2198               std::map<int,int>::iterator it = this->libmesh_elem_num_to_exodus\&.find( family[j]->id() );
2199               if (it != this->libmesh_elem_num_to_exodus\&.end())
2200                 {
2201                   local_elem_boundary_id_lists[ bndry_id_list[i] ]\&.push_back( (*it)\&.second );
2202                   local_elem_boundary_id_side_lists[ bndry_id_list[i] ]\&.push_back(conv\&.get_inverse_side_map( bndry_side_list[i] ));
2203                 }
2204               else
2205                 {
2206                   libMesh::err << "Error, no Exodus mapping for Elem "
2207                                << family[j]->id()
2208                                << " on processor "
2209                                << this->processor_id()
2210                                << std::endl;
2211                   libmesh_error();
2212                 }
2213             }
2214         }
2215     }
2216 
2217 
2218   // Loop over *global* sideset IDs, call the Exodus API\&.  Note that some sidesets may be empty
2219   // for a given processor\&.
2220   for (unsigned i=0; i<this->global_sideset_ids\&.size(); ++i)
2221     {
2222       if (verbose)
2223         {
2224           libMesh::out << "[" << this->processor_id()
2225                        << "] Writing out Exodus sideset info for ID: " << global_sideset_ids[i] << std::endl;
2226         }
2227 
2228       // Convert current global_sideset_id into an exodus ID, which can't be zero\&.\&.\&.
2229       int exodus_id = global_sideset_ids[i];
2230 
2231       /*
2232       // Exodus can't handle zero sideset IDs (?)  Use max short here since
2233       // when libmesh reads it back in, it will want to store it as a short\&.\&.\&.
2234       if (exodus_id==0)
2235       exodus_id = std::numeric_limits<short>::max();
2236       */
2237 
2238       // Try to find this boundary ID in the local list we created
2239       local_elem_boundary_id_lists_iterator it =
2240         local_elem_boundary_id_lists\&.find(this->global_sideset_ids[i]);
2241 
2242       // No sides found for this boundary ID on this processor
2243       if (it == local_elem_boundary_id_lists\&.end())
2244         {
2245           if (verbose)
2246             libMesh::out << "[" << this->processor_id()
2247                          << "] No sideset data for ID: " << global_sideset_ids[i]
2248                          << " on this processor\&." << std::endl;
2249 
2250           // Call the Exodus interface to write the parameters of this side set
2251           this->ex_err = exII::ex_put_side_set_param(this->ex_id,
2252                                                      exodus_id,
2253                                                      0, /* No sides for this ID */
2254                                                      0  /* No distribution factors */);
2255           EX_CHECK_ERR(this->ex_err, "Error writing sideset parameters in Nemesis");
2256 
2257         }
2258       else // Boundary ID *was* found in list
2259         {
2260           // Get iterator to sides vector as well
2261           local_elem_boundary_id_lists_iterator it_sides =
2262             local_elem_boundary_id_side_lists\&.find(this->global_sideset_ids[i]);
2263 
2264           libmesh_assert (it_sides != local_elem_boundary_id_side_lists\&.end());
2265 
2266           // Get reference to the vector of elem IDs
2267           std::vector<int>& current_sideset_elem_ids = (*it)\&.second;
2268 
2269           // Get reference to the vector of side IDs
2270           std::vector<int>& current_sideset_side_ids = (*it_sides)\&.second;
2271 
2272           // Call the Exodus interface to write the parameters of this side set
2273           this->ex_err = exII::ex_put_side_set_param(this->ex_id,
2274                                                      exodus_id,
2275                                                      current_sideset_elem_ids\&.size(),
2276                                                      0  /* No distribution factors */);
2277 
2278           EX_CHECK_ERR(this->ex_err, "Error writing sideset parameters in Nemesis");
2279 
2280           // Call Exodus interface to write the actual side IDs for this boundary ID
2281           this->ex_err = exII::ex_put_side_set(this->ex_id,
2282                                                exodus_id,
2283                                                &current_sideset_elem_ids[0],
2284                                                &current_sideset_side_ids[0]);
2285 
2286           EX_CHECK_ERR(this->ex_err, "Error writing sidesets in Nemesis");
2287         }
2288     } // end for loop over global sideset IDs
2289 }
.fi
.SS "void libMesh::ExodusII_IO_Helper::write_timestep (inttimestep, \fBReal\fPtime)\fC [inherited]\fP"
Writes the time for the timestep 
.PP
Definition at line 1598 of file exodusII_io_helper\&.C\&.
.PP
References libMesh::ExodusII_IO_Helper::_run_only_on_proc0, libMesh::ExodusII_IO_Helper::ex_err, libMesh::ExodusII_IO_Helper::ex_id, ex_put_time(), ex_update(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::Nemesis_IO::write_timestep(), and libMesh::ExodusII_IO::write_timestep()\&.
.PP
.nf
1599 {
1600   if ((_run_only_on_proc0) && (this->processor_id() != 0))
1601     return;
1602 
1603   ex_err = exII::ex_put_time(ex_id, timestep, &time);
1604   EX_CHECK_ERR(ex_err, "Error writing timestep\&.");
1605 
1606   ex_err = exII::ex_update(ex_id);
1607   EX_CHECK_ERR(ex_err, "Error flushing buffers to file\&.");
1608 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBPoint\fP libMesh::ExodusII_IO_Helper::_coordinate_offset\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 545 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::set_coordinate_offset(), and libMesh::ExodusII_IO_Helper::write_nodal_coordinates()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_elem_vars_initialized\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 531 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_element_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_global_vars_initialized\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 534 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_global_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_nodal_vars_initialized\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 537 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_nodal_variables()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_run_only_on_proc0\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 528 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::close(), libMesh::ExodusII_IO_Helper::create(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_single_precision\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 548 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::create(), create(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), write_nodal_coordinates(), and libMesh::ExodusII_IO_Helper::write_nodal_values()\&.
.SS "bool libMesh::ExodusII_IO_Helper::_use_mesh_dimension_instead_of_spatial_dimension\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 542 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), and libMesh::ExodusII_IO_Helper::use_mesh_dimension_instead_of_spatial_dimension()\&.
.SS "std::map<int, std::vector<int> > libMesh::Nemesis_IO_Helper::block_id_to_elem_connectivity"
This is the block connectivity, i\&.e\&. for each subdomain (block) there is an element connectivity list\&. This map associates the block ID to that vector\&. 
.PP
Definition at line 396 of file nemesis_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::block_ids\fC [inherited]\fP"

.PP
Definition at line 407 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), libMesh::ExodusII_IO_Helper::get_block_id(), libMesh::ExodusII_IO_Helper::get_block_name(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO_Helper::read_block_info(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.SS "std::set<unsigned> libMesh::Nemesis_IO_Helper::border_elem_ids\fC [private]\fP"
A set of border elem IDs for this processor\&. 
.PP
Definition at line 571 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_element_maps(), and compute_internal_and_border_elems_and_internal_nodes()\&.
.SS "std::set<unsigned> libMesh::Nemesis_IO_Helper::border_node_ids\fC [private]\fP"
The set which will eventually contain the IDs of 'border nodes'\&. These are nodes that lie on the boundary between one or more processors\&. 
.PP
Definition at line 534 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_border_node_ids(), compute_internal_and_border_elems_and_internal_nodes(), and compute_node_maps()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::connect\fC [inherited]\fP"

.PP
Definition at line 410 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.SS "std::string libMesh::ExodusII_IO_Helper::current_filename\fC [inherited]\fP"

.PP
Definition at line 524 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::create(), libMesh::ExodusII_IO_Helper::open(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::elem_cmap_elem_cnts"

.PP
Definition at line 498 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), get_cmap_params(), get_elem_cmap(), and initialize()\&.
.SS "std::vector<std::vector<int> > libMesh::Nemesis_IO_Helper::elem_cmap_elem_ids"
3 vectors of vectors for storing element communication IDs for this processor\&. There will be num_elem_cmaps rows, row i will have elem_cmap_elem_cnts[i] entries\&. To be used with Nemesis::ne_get_elem_cmap()\&. 
.PP
Definition at line 518 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_elem_communication_maps(), get_elem_cmap(), and initialize()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::elem_cmap_ids"

.PP
Definition at line 497 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), compute_elem_communication_maps(), get_cmap_params(), get_elem_cmap(), initialize(), and put_elem_cmap()\&.
.SS "std::vector<std::vector<int> > libMesh::Nemesis_IO_Helper::elem_cmap_proc_ids"

.PP
Definition at line 520 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_elem_communication_maps(), get_elem_cmap(), and initialize()\&.
.SS "std::vector<std::vector<int> > libMesh::Nemesis_IO_Helper::elem_cmap_side_ids"

.PP
Definition at line 519 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_elem_communication_maps(), get_elem_cmap(), and initialize()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::elem_list\fC [inherited]\fP"

.PP
Definition at line 431 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::elem_mapb"
Vector which stores border element IDs\&. Will have length num_border_elems\&. To be used with Nemesis::ne_get_elem_map()\&. 
.PP
Definition at line 463 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_element_maps(), get_elem_map(), and initialize()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::elem_mapi"
Vector which stores internal element IDs\&. Will have length num_internal_elems\&. To be used with Nemesis::ne_get_elem_map()\&. 
.PP
Definition at line 456 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_element_maps(), get_elem_map(), and initialize()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::elem_num_map\fC [inherited]\fP"

.PP
Definition at line 446 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.SS "std::vector<char> libMesh::ExodusII_IO_Helper::elem_type\fC [inherited]\fP"

.PP
Definition at line 461 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::ExodusII_IO_Helper(), libMesh::ExodusII_IO_Helper::get_elem_type(), libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO_Helper::read_elem_in_block()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::elem_var_names\fC [inherited]\fP"

.PP
Definition at line 492 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), and libMesh::ExodusII_IO_Helper::read_var_names()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::elem_var_values\fC [inherited]\fP"

.PP
Definition at line 495 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution(), and libMesh::ExodusII_IO_Helper::read_elemental_var_values()\&.
.SS "int libMesh::ExodusII_IO_Helper::ex_err\fC [inherited]\fP"

.PP
Definition at line 371 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::close(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::inquire(), libMesh::ExodusII_IO_Helper::read_block_info(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_nodal_var_values(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::read_nodeset(), libMesh::ExodusII_IO_Helper::read_nodeset_info(), libMesh::ExodusII_IO_Helper::read_sideset(), libMesh::ExodusII_IO_Helper::read_sideset_info(), libMesh::ExodusII_IO_Helper::read_time_steps(), libMesh::ExodusII_IO_Helper::read_var_names_impl(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), write_elements(), write_exodus_initialization_info(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), write_nodal_coordinates(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), write_sidesets(), libMesh::ExodusII_IO_Helper::write_timestep(), libMesh::ExodusII_IO_Helper::write_var_names_impl(), and ~Nemesis_IO_Helper()\&.
.SS "int libMesh::ExodusII_IO_Helper::ex_id\fC [inherited]\fP"

.PP
Definition at line 368 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::close(), libMesh::ExodusII_IO_Helper::create(), create(), get_cmap_params(), get_eb_info_global(), get_elem_cmap(), get_elem_map(), get_init_global(), get_init_info(), get_loadbal_param(), get_node_cmap(), get_node_map(), get_ns_param_global(), get_ss_param_global(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::inquire(), libMesh::ExodusII_IO_Helper::open(), put_cmap_params(), put_eb_info_global(), put_elem_cmap(), put_elem_map(), put_init_global(), put_init_info(), put_loadbal_param(), put_n_coord(), put_node_cmap(), put_node_map(), put_ns_param_global(), put_ss_param_global(), libMesh::ExodusII_IO_Helper::read_block_info(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_nodal_var_values(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::read_nodeset(), libMesh::ExodusII_IO_Helper::read_nodeset_info(), libMesh::ExodusII_IO_Helper::read_sideset(), libMesh::ExodusII_IO_Helper::read_sideset_info(), libMesh::ExodusII_IO_Helper::read_time_steps(), libMesh::ExodusII_IO_Helper::read_var_names_impl(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), write_elements(), write_exodus_initialization_info(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), write_nodal_coordinates(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), write_sidesets(), libMesh::ExodusII_IO_Helper::write_timestep(), libMesh::ExodusII_IO_Helper::write_var_names_impl(), and ~Nemesis_IO_Helper()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::exodus_elem_num_to_libmesh\fC [inherited]\fP"

.PP
Definition at line 466 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::exodus_node_num_to_libmesh\fC [inherited]\fP"

.PP
Definition at line 471 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and write_nodal_coordinates()\&.
.SS "char libMesh::Nemesis_IO_Helper::ftype"
The type of file to be written\&. Either 's', for a scalar load-balance file, or 'p' for a parallel file\&. To be used with Nemesis::ne_get_init_info()\&. 
.PP
Definition at line 348 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_init_info()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::global_elem_blk_cnts"

.PP
Definition at line 380 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_elem_blocks(), get_eb_info_global(), and initialize()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::global_elem_blk_ids"
Read the global element block IDs and counts\&. These vectors will eventually have num_elem_blks_global entries\&. To be used with Nemesis::ne_get_eb_info_global()\&. 
.PP
Definition at line 379 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_elem_blocks(), get_eb_info_global(), initialize(), and write_elements()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::global_nodeset_ids"
Containers for reading global nodeset information\&. One vector entry per nodeset\&. Each vector will eventually have num_node_sets_global entries, and will be used in calls to Nemesis::ne_get_ns_param_global()\&.
.PP
It's an error to call ne_get_ns_param_global when num_node_sets_global==0 
.PP
Definition at line 369 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_nodesets(), get_ns_param_global(), initialize(), put_ns_param_global(), write_exodus_initialization_info(), and write_nodesets()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::global_sideset_ids"
Containers for reading global sideset (boundary conditions) information\&. Each vector will eventually have num_side_sets_global entries, and be used in calls to Nemesis::ne_get_ss_param_global()\&.
.PP
It's an error to call ne_get_ss_param_global when num_side_sets_global==0 
.PP
Definition at line 357 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_sidesets(), get_ss_param_global(), initialize(), put_ss_param_global(), libMesh::Nemesis_IO::read(), write_exodus_initialization_info(), and write_sidesets()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::global_var_names\fC [inherited]\fP"

.PP
Definition at line 498 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_global_variables(), and libMesh::ExodusII_IO_Helper::read_var_names()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::id_list\fC [inherited]\fP"

.PP
Definition at line 440 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_block_names\fC [inherited]\fP"

.PP
Definition at line 501 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::get_block_name(), and libMesh::ExodusII_IO_Helper::read_block_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_ns_names\fC [inherited]\fP"

.PP
Definition at line 503 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::get_node_set_name(), and libMesh::ExodusII_IO_Helper::read_nodeset_info()\&.
.SS "std::map<int, std::string> libMesh::ExodusII_IO_Helper::id_to_ss_names\fC [inherited]\fP"

.PP
Definition at line 502 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::get_side_set_name(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "std::set<unsigned> libMesh::Nemesis_IO_Helper::internal_elem_ids\fC [private]\fP"
A set of internal elem IDs for this processor\&. 
.PP
Definition at line 566 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_element_maps(), and compute_internal_and_border_elems_and_internal_nodes()\&.
.SS "std::set<unsigned> libMesh::Nemesis_IO_Helper::internal_node_ids\fC [private]\fP"
A set of internal node IDs for this processor\&. 
.PP
Definition at line 561 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_internal_and_border_elems_and_internal_nodes(), and compute_node_maps()\&.
.SS "std::map<int, int> libMesh::ExodusII_IO_Helper::libmesh_elem_num_to_exodus\fC [inherited]\fP"

.PP
Definition at line 465 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), compute_elem_communication_maps(), compute_element_maps(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO_Helper::write_sidesets(), and write_sidesets()\&.
.SS "std::map<int, int> libMesh::ExodusII_IO_Helper::libmesh_node_num_to_exodus\fC [inherited]\fP"

.PP
Definition at line 470 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), compute_node_communication_maps(), compute_node_maps(), and write_nodesets()\&.
.SS "std::map<\fBsubdomain_id_type\fP, unsigned> libMesh::Nemesis_IO_Helper::local_subdomain_counts\fC [private]\fP"
This map keeps track of the number of elements in each subdomain (block) for \fIthis\fP processor\&. 
.PP
Definition at line 528 of file nemesis_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and compute_num_global_elem_blocks()\&.
.SS "int libMesh::Nemesis_IO_Helper::nemesis_err_flag"
Member data All (?) \fBNemesis\fP functions return an int\&. If it's negative that signals an error! Internally, we use the ExodusII_IO_Helper::check_err() function to check for errors\&. 
.PP
Definition at line 318 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_cmap_params(), get_eb_info_global(), get_elem_cmap(), get_elem_map(), get_init_global(), get_init_info(), get_loadbal_param(), get_node_cmap(), get_node_map(), get_ns_param_global(), get_ss_param_global(), put_cmap_params(), put_eb_info_global(), put_elem_cmap(), put_elem_map(), put_init_global(), put_init_info(), put_loadbal_param(), put_n_coord(), put_node_cmap(), put_node_map(), put_ns_param_global(), and put_ss_param_global()\&.
.SS "std::vector<std::string> libMesh::ExodusII_IO_Helper::nodal_var_names\fC [inherited]\fP"

.PP
Definition at line 483 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::ExodusII_IO_Helper::read_nodal_var_values(), and libMesh::ExodusII_IO_Helper::read_var_names()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::nodal_var_values\fC [inherited]\fP"

.PP
Definition at line 486 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_nodal_solution(), and libMesh::ExodusII_IO_Helper::read_nodal_var_values()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::node_cmap_ids"
Vectors for storing the communication map parameters\&. Each will eventually have length num_node_cmaps OR num_elem_cmaps as appropriate\&. For use with Nemesis::ne_get_cmap_params()\&. 
.PP
Definition at line 495 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), compute_node_communication_maps(), get_cmap_params(), get_node_cmap(), initialize(), put_cmap_params(), put_node_cmap(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::node_cmap_node_cnts"

.PP
Definition at line 496 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), get_cmap_params(), get_node_cmap(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<std::vector<int> > libMesh::Nemesis_IO_Helper::node_cmap_node_ids"
2 vectors of vectors for storing the node communication IDs for this processor\&. There will be num_node_cmaps rows, row i will have node_cmap_node_cnts[i] entries\&. To be used with Nemesis::ne_get_node_cmap()\&.
.PP
Remark: node_cmap_proc_ids is a vector, all entries of which are = node_cmap_ids[i] Not sure what the point of that is\&.\&.\&. 
.PP
Definition at line 509 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_node_communication_maps(), get_node_cmap(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<std::vector<int> > libMesh::Nemesis_IO_Helper::node_cmap_proc_ids"

.PP
Definition at line 510 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_node_communication_maps(), get_node_cmap(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::node_list\fC [inherited]\fP"

.PP
Definition at line 437 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and libMesh::ExodusII_IO_Helper::read_nodeset()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::node_mapb"
Vector which stores border node IDs\&. Will have length num_border_nodes\&. To be used with Nemesis::ne_get_node_map()\&. 
.PP
Definition at line 479 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_node_maps(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::node_mape"
Vector which stores external node IDs\&. Will have length num_external_nodes\&. To be used with Nemesis::ne_get_node_map()\&. 
.PP
Definition at line 486 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_node_maps(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::node_mapi"
Vector which stores internal node IDs\&. Will have length num_internal_nodes\&. To be used with Nemesis::ne_get_node_map()\&. 
.PP
Definition at line 472 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_node_maps(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::node_num_map\fC [inherited]\fP"

.PP
Definition at line 443 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_node_num_map(), and libMesh::ExodusII_IO_Helper::write_nodal_coordinates()\&.
.SS "std::set<int> libMesh::Nemesis_IO_Helper::nodes_attached_to_local_elems"
\fBlibMesh\fP numbered node ids attached to local elems\&. 
.PP
Definition at line 385 of file nemesis_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and compute_internal_and_border_elems_and_internal_nodes()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::nodeset_ids\fC [inherited]\fP"

.PP
Definition at line 416 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::get_node_set_id(), libMesh::ExodusII_IO_Helper::get_node_set_name(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_nodeset(), and libMesh::ExodusII_IO_Helper::read_nodeset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_attr\fC [inherited]\fP"

.PP
Definition at line 401 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::read_elem_in_block()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_border_elems"
The number of border FEM elements\&. Elements local to this processor but whose FEM nodes reside on other processors as well\&. To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 433 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_internal_and_border_elems_and_internal_nodes(), get_elem_map(), get_loadbal_param(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_border_nodes"
The number of FEM nodes local to a processor but residing in an element which also has FEM nodes on other processors\&. To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 413 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_border_node_ids(), compute_internal_and_border_elems_and_internal_nodes(), get_loadbal_param(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_df_per_set\fC [inherited]\fP"

.PP
Definition at line 425 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_dim\fC [inherited]\fP"

.PP
Definition at line 374 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::ExodusII_IO_Helper::read_header(), and write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem\fC [inherited]\fP"

.PP
Definition at line 383 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::write_element_values(), and write_exodus_initialization_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_all_sidesets\fC [inherited]\fP"

.PP
Definition at line 404 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_blk\fC [inherited]\fP"

.PP
Definition at line 386 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_block_info(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::write_elements(), and write_exodus_initialization_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_elem_blks_global"

.PP
Definition at line 326 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_elem_blocks(), get_eb_info_global(), get_init_global(), initialize(), write_elements(), and write_exodus_initialization_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_elem_cmaps"
The number of elemental communication maps for this processor\&. (One per neighboring proc?) To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 447 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), compute_elem_communication_maps(), compute_internal_and_border_elems_and_internal_nodes(), get_cmap_params(), get_elem_cmap(), get_loadbal_param(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_this_blk\fC [inherited]\fP"

.PP
Definition at line 395 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), and libMesh::ExodusII_IO_Helper::read_elem_in_block()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_elem_vars\fC [inherited]\fP"

.PP
Definition at line 489 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_var_names(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_elems_global"

.PP
Definition at line 325 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_init_global(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_external_nodes"
The number of FEM nodes that reside on another processor but whose element partially resides on the current processor\&. To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 420 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_loadbal_param(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::num_global_node_counts"

.PP
Definition at line 370 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_nodesets(), get_ns_param_global(), and initialize()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::num_global_node_df_counts"

.PP
Definition at line 371 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_ns_param_global(), and initialize()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::num_global_side_counts"

.PP
Definition at line 358 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_sidesets(), get_ss_param_global(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::Nemesis_IO_Helper::num_global_side_df_counts"

.PP
Definition at line 359 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_ss_param_global(), and initialize()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_global_vars\fC [inherited]\fP"

.PP
Definition at line 377 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_var_names(), libMesh::ExodusII_IO_Helper::write_global_values(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_internal_elems"
The number of internal FEM elements\&. Elements local to this processor\&. To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 426 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_internal_and_border_elems_and_internal_nodes(), get_elem_map(), get_loadbal_param(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_internal_nodes"
To be used with the Nemesis::ne_get_loadbal_param() routine\&. The number of FEM nodes contained in FEM elements wholly owned by the current processor\&. To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 406 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_internal_and_border_elems_and_internal_nodes(), get_loadbal_param(), get_node_map(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodal_vars\fC [inherited]\fP"

.PP
Definition at line 480 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_var_names(), and libMesh::ExodusII_IO_Helper::write_var_names()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_node_cmaps"
The number of nodal communication maps for this processor\&. (One per neighboring proc?) To be used with the Nemesis::ne_get_loadbal_param() routine\&. 
.PP
Definition at line 440 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_border_node_ids(), compute_communication_map_parameters(), compute_node_communication_maps(), get_cmap_params(), get_loadbal_param(), get_node_cmap(), initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_node_df_per_set\fC [inherited]\fP"

.PP
Definition at line 428 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::read_nodeset(), and libMesh::ExodusII_IO_Helper::read_nodeset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_node_sets\fC [inherited]\fP"

.PP
Definition at line 389 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_nodeset_info(), and write_exodus_initialization_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_node_sets_global"

.PP
Definition at line 327 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_nodesets(), get_init_global(), get_ns_param_global(), and initialize()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodes\fC [inherited]\fP"

.PP
Definition at line 380 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::ExodusII_IO_Helper::print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_nodal_var_values(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_nodes(), write_exodus_initialization_info(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), and libMesh::ExodusII_IO_Helper::write_nodal_values()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_nodes_global"
Global initial information\&. The names are self-explanatory for the most part\&. Used with Nemesis::ne_get_init_global()\&. 
.PP
Definition at line 324 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_init_global(), and libMesh::Nemesis_IO::read()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_nodes_per_elem\fC [inherited]\fP"

.PP
Definition at line 398 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::write_elements(), and write_elements()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_nodes_per_set\fC [inherited]\fP"

.PP
Definition at line 422 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::read_nodeset(), and libMesh::ExodusII_IO_Helper::read_nodeset_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_proc"
The number of processors for which the NEMESIS I file was created\&. To be used with Nemesis::ne_get_init_info()\&. 
.PP
Definition at line 334 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_init_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_proc_in_file"
The number of processors for which the NEMESIS I file stores information\&. This is generally equal to 1 (1 CPU/file) at least for the splitting Derek gave us\&. To be used with Nemesis::ne_get_init_info()\&. 
.PP
Definition at line 341 of file nemesis_io_helper\&.h\&.
.PP
Referenced by get_init_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_side_sets\fC [inherited]\fP"

.PP
Definition at line 392 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_header(), libMesh::ExodusII_IO_Helper::read_sideset_info(), and write_exodus_initialization_info()\&.
.SS "int libMesh::Nemesis_IO_Helper::num_side_sets_global"

.PP
Definition at line 328 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_num_global_sidesets(), get_init_global(), get_ss_param_global(), and initialize()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::num_sides_per_set\fC [inherited]\fP"

.PP
Definition at line 419 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "int libMesh::ExodusII_IO_Helper::num_time_steps\fC [inherited]\fP"

.PP
Definition at line 474 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::get_num_time_steps(), libMesh::ExodusII_IO_Helper::read_num_time_steps(), and libMesh::ExodusII_IO_Helper::read_time_steps()\&.
.SS "bool libMesh::ExodusII_IO_Helper::opened_for_reading\fC [inherited]\fP"

.PP
Definition at line 514 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::ExodusII_IO::get_num_time_steps(), libMesh::ExodusII_IO::get_time_steps(), and libMesh::ExodusII_IO_Helper::open()\&.
.SS "bool libMesh::ExodusII_IO_Helper::opened_for_writing\fC [inherited]\fP"

.PP
Definition at line 510 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::create(), create(), libMesh::ExodusII_IO::get_num_time_steps(), libMesh::ExodusII_IO_Helper::open(), libMesh::ExodusII_IO::write(), libMesh::ExodusII_IO::write_element_data(), libMesh::Nemesis_IO::write_global_data(), libMesh::ExodusII_IO::write_global_data(), libMesh::Nemesis_IO::write_information_records(), libMesh::ExodusII_IO::write_information_records(), libMesh::Nemesis_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_common()\&.
.SS "std::map<unsigned, std::set<std::pair<unsigned,unsigned> > > libMesh::Nemesis_IO_Helper::proc_border_elem_sets\fC [private]\fP"
Map between processor ID and (element,side) pairs bordering that processor ID\&. 
.PP
Definition at line 551 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_communication_map_parameters(), compute_elem_communication_maps(), and compute_internal_and_border_elems_and_internal_nodes()\&.
.SS "std::map<unsigned, std::set<unsigned> > libMesh::Nemesis_IO_Helper::proc_nodes_touched_intersections\fC [private]\fP"
Another map to store sets of intersections with each other processor (other than ourself, of course)\&. A node which appears in one of these vectors belongs to element owned by at least this processor and one other\&. 
.PP
Definition at line 541 of file nemesis_io_helper\&.h\&.
.PP
Referenced by compute_border_node_ids(), compute_communication_map_parameters(), and compute_node_communication_maps()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::side_list\fC [inherited]\fP"

.PP
Definition at line 434 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "std::vector<int> libMesh::ExodusII_IO_Helper::ss_ids\fC [inherited]\fP"

.PP
Definition at line 413 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::get_side_set_id(), libMesh::ExodusII_IO_Helper::get_side_set_name(), libMesh::ExodusII_IO_Helper::read_sideset(), and libMesh::ExodusII_IO_Helper::read_sideset_info()\&.
.SS "std::map<\fBsubdomain_id_type\fP, std::vector<unsigned int> > libMesh::Nemesis_IO_Helper::subdomain_map"
Map of subdomains to element numbers\&. 
.PP
Definition at line 390 of file nemesis_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), and write_elements()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::time_steps\fC [inherited]\fP"

.PP
Definition at line 477 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO::get_time_steps(), and libMesh::ExodusII_IO_Helper::read_time_steps()\&.
.SS "std::vector<char> libMesh::ExodusII_IO_Helper::title\fC [inherited]\fP"

.PP
Definition at line 458 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::ExodusII_IO_Helper(), libMesh::ExodusII_IO_Helper::print_header(), and libMesh::ExodusII_IO_Helper::read_header()\&.
.SS "bool libMesh::ExodusII_IO_Helper::verbose\fC [inherited]\fP"

.PP
Definition at line 506 of file exodusII_io_helper\&.h\&.
.PP
Referenced by build_element_and_node_maps(), compute_border_node_ids(), compute_communication_map_parameters(), compute_internal_and_border_elems_and_internal_nodes(), compute_node_communication_maps(), compute_num_global_elem_blocks(), compute_num_global_nodesets(), compute_num_global_sidesets(), construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), create(), get_cmap_params(), get_eb_info_global(), get_elem_cmap(), get_elem_map(), get_init_global(), get_init_info(), get_loadbal_param(), get_node_cmap(), get_node_map(), get_ns_param_global(), get_ss_param_global(), libMesh::ExodusII_IO_Helper::message(), libMesh::ExodusII_IO_Helper::open(), libMesh::ExodusII_IO_Helper::print_header(), put_node_cmap(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_var_names_impl(), libMesh::ExodusII_IO::verbose(), libMesh::Nemesis_IO::verbose(), libMesh::ExodusII_IO_Helper::write_elements(), write_nodesets(), write_sidesets(), and libMesh::ExodusII_IO_Helper::write_var_names_impl()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::x\fC [inherited]\fP"

.PP
Definition at line 449 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), and write_nodal_coordinates()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::y\fC [inherited]\fP"

.PP
Definition at line 452 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), and write_nodal_coordinates()\&.
.SS "std::vector<\fBReal\fP> libMesh::ExodusII_IO_Helper::z\fC [inherited]\fP"

.PP
Definition at line 455 of file exodusII_io_helper\&.h\&.
.PP
Referenced by libMesh::ExodusII_IO_Helper::print_nodes(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::ExodusII_IO_Helper::read_nodes(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), and write_nodal_coordinates()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
