.TH "libMesh::EigenTimeSolver" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::EigenTimeSolver \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <eigen_time_solver\&.h>\fP
.PP
Inherits \fBlibMesh::TimeSolver\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBDifferentiableSystem\fP \fBsys_type\fP"
.br
.ti -1c
.RI "typedef \fBTimeSolver\fP \fBParent\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEigenTimeSolver\fP (\fBsys_type\fP &s)"
.br
.ti -1c
.RI "virtual \fB~EigenTimeSolver\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBsolve\fP ()"
.br
.ti -1c
.RI "virtual void \fBadvance_timestep\fP ()"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBerror_order\fP () const "
.br
.ti -1c
.RI "virtual bool \fBelement_residual\fP (bool get_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual bool \fBside_residual\fP (bool get_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBdu\fP (const \fBSystemNorm\fP &) const "
.br
.ti -1c
.RI "virtual bool \fBis_steady\fP () const "
.br
.ti -1c
.RI "virtual void \fBinit_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBadjoint_advance_timestep\fP ()"
.br
.ti -1c
.RI "virtual void \fBretrieve_timestep\fP ()"
.br
.ti -1c
.RI "virtual void \fBbefore_timestep\fP ()"
.br
.ti -1c
.RI "const \fBsys_type\fP & \fBsystem\fP () const "
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBDiffSolver\fP > & \fBdiff_solver\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBLinearSolver\fP
.br
< \fBNumber\fP > > & \fBlinear_solver\fP ()"
.br
.ti -1c
.RI "void \fBset_solution_history\fP (const \fBSolutionHistory\fP &_solution_history)"
.br
.ti -1c
.RI "bool \fBis_adjoint\fP () const "
.br
.ti -1c
.RI "void \fBset_is_adjoint\fP (bool _is_adjoint_value)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBEigenSolver\fP< \fBNumber\fP > > \fBeigen_solver\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBtol\fP"
.br
.ti -1c
.RI "unsigned int \fBmaxits\fP"
.br
.ti -1c
.RI "unsigned int \fBn_eigenpairs_to_compute\fP"
.br
.ti -1c
.RI "unsigned int \fBn_basis_vectors_to_use\fP"
.br
.ti -1c
.RI "unsigned int \fBn_converged_eigenpairs\fP"
.br
.ti -1c
.RI "unsigned int \fBn_iterations_reqd\fP"
.br
.ti -1c
.RI "bool \fBquiet\fP"
.br
.ti -1c
.RI "unsigned int \fBreduce_deltat_on_diffsolver_failure\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBDiffSolver\fP > \fB_diff_solver\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > \fB_linear_solver\fP"
.br
.ti -1c
.RI "\fBsys_type\fP & \fB_system\fP"
.br
.ti -1c
.RI "bool \fBfirst_solve\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBold_local_nonlinear_solution\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSolutionHistory\fP > \fBsolution_history\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBNowAssembling\fP { \fBMatrix_A\fP, \fBMatrix_B\fP, \fBInvalid_Matrix\fP }"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBNowAssembling\fP \fBnow_assembling\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The name of this class is confusing\&.\&.\&.it's meant to refer to the base class (\fBTimeSolver\fP) while still telling one that it's for solving (generalized) EigenValue problems that arise from finite element discretizations\&. For a time-dependent problem du/dt=F(u), with a steady solution 0=F(u_0), we look at the time evolution of a small perturbation, p=u-u_0, for which the (linearized) governing equation is
.PP
dp/dt = F'(u_0)p
.PP
where F'(u_0) is the Jacobian\&. The generalized eigenvalue problem arises by considering perturbations of the general form p = exp(lambda*t)x, which leads to
.PP
Ax = lambda*Bx
.PP
where A is the (discretized by FEM) Jacobian matrix and B is the (discretized by FEM) mass matrix\&.
.PP
The \fBEigenSystem\fP class (by Steffen Petersen) is related but does not fall under the \fBFEMSystem\fP paradigm invented by Roy Stogner\&. The \fBEigenSolver\fP class (also by Steffen) is meant to provide a generic 'linear solver' interface for EigenValue software\&. The only current concrete implementation is a SLEPc-based eigensolver class, which we make use of here as well\&.
.PP
\fBAuthor:\fP
.RS 4
John W\&. Peterson 2007 
.RE
.PP

.PP
Definition at line 67 of file eigen_time_solver\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBTimeSolver\fP \fBlibMesh::EigenTimeSolver::Parent\fP"
The parent class 
.PP
Definition at line 78 of file eigen_time_solver\&.h\&.
.SS "typedef \fBDifferentiableSystem\fP \fBlibMesh::EigenTimeSolver::sys_type\fP"
The type of system 
.PP
Definition at line 73 of file eigen_time_solver\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBlibMesh::EigenTimeSolver::NowAssembling\fP\fC [private]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIMatrix_A \fP\fP
The matrix associated with the spatial part of the operator\&. 
.TP
\fB\fIMatrix_B \fP\fP
The matrix associated with the time derivative (mass matrix)\&. 
.TP
\fB\fIInvalid_Matrix \fP\fP
The enum is in an invalid state\&. 
.PP
Definition at line 193 of file eigen_time_solver\&.h\&.
.PP
.nf
193                      {
197     Matrix_A,
198 
202     Matrix_B,
203 
207     Invalid_Matrix
208   };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::EigenTimeSolver::EigenTimeSolver (\fBsys_type\fP &s)\fC [explicit]\fP"
Constructor\&. Requires a reference to the system to be solved\&. 
.PP
Definition at line 32 of file eigen_time_solver\&.C\&.
.PP
References eigen_solver, libMesh::GHEP, and libMesh::LARGEST_MAGNITUDE\&.
.PP
.nf
33   : Parent(s),
34     eigen_solver     (EigenSolver<Number>::build(s\&.comm())),
35     tol(pow(TOLERANCE, 5\&./3\&.)),
36     maxits(1000),
37     n_eigenpairs_to_compute(5),
38     n_basis_vectors_to_use(3*n_eigenpairs_to_compute),
39     n_converged_eigenpairs(0),
40     n_iterations_reqd(0)
41 {
42   libmesh_experimental();
43   eigen_solver->set_eigenproblem_type(GHEP);//or GNHEP
44   eigen_solver->set_position_of_spectrum(LARGEST_MAGNITUDE);
45 }
.fi
.SS "libMesh::EigenTimeSolver::~EigenTimeSolver ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 47 of file eigen_time_solver\&.C\&.
.PP
.nf
48 {
49 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::TimeSolver::adjoint_advance_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method advances the adjoint solution to the previous timestep, after an adjoint_solve() has been performed\&. This will be done before every UnsteadySolver::adjoint_solve()\&. 
.PP
Reimplemented in \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 106 of file time_solver\&.C\&.
.PP
.nf
107 {
108 }
.fi
.SS "virtual void libMesh::EigenTimeSolver::advance_timestep ()\fC [inline]\fP, \fC [virtual]\fP"
It doesn't make sense to advance the timestep, so we shouldn't call this\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 113 of file eigen_time_solver\&.h\&.
.PP
.nf
113 { }
.fi
.SS "virtual void libMesh::TimeSolver::before_timestep ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This method is for subclasses or users to override to do arbitrary processing between timesteps 
.PP
Definition at line 152 of file time_solver\&.h\&.
.PP
.nf
152 {}
.fi
.SS "virtual \fBAutoPtr\fP<\fBDiffSolver\fP>& libMesh::TimeSolver::diff_solver ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP\&.
.PP
Definition at line 167 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_diff_solver\&.
.PP
.nf
167 { return _diff_solver; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "virtual \fBReal\fP libMesh::EigenTimeSolver::du (const \fBSystemNorm\fP &) const\fC [inline]\fP, \fC [virtual]\fP"
Nominally computes the size of the difference between successive solution iterates ||u^{n+1} - u^{n}|| in some norm, but for this class just returns 0\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 139 of file eigen_time_solver\&.h\&.
.PP
.nf
139 { return 0\&.; }
.fi
.SS "bool libMesh::EigenTimeSolver::element_residual (boolget_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
Forms either the spatial (Jacobian) or mass matrix part of the operator, depending on which is requested\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 127 of file eigen_time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiablePhysics::element_constraint(), libMesh::DifferentiablePhysics::element_time_derivative(), libMesh::libmesh_assert(), libMesh::DifferentiablePhysics::mass_residual(), Matrix_A, Matrix_B, and now_assembling\&.
.PP
.nf
129 {
130   // The EigenTimeSolver always computes jacobians!
131   libmesh_assert (request_jacobian);
132 
133   // Assemble the operator for the spatial part\&.
134   if (now_assembling == Matrix_A)
135     {
136       bool jacobian_computed =
137         _system\&.element_time_derivative(request_jacobian, context);
138 
139       // The user shouldn't compute a jacobian unless requested
140       libmesh_assert(request_jacobian || !jacobian_computed);
141 
142       bool jacobian_computed2 =
143         _system\&.element_constraint(jacobian_computed, context);
144 
145       // The user shouldn't compute a jacobian unless requested
146       libmesh_assert (jacobian_computed || !jacobian_computed2);
147 
148       return jacobian_computed && jacobian_computed2;
149 
150     }
151 
152   // Assemble the mass matrix operator
153   else if (now_assembling == Matrix_B)
154     {
155       bool mass_jacobian_computed =
156         _system\&.mass_residual(request_jacobian, context);
157 
158       // Scale Jacobian by -1?
159       //context\&.elem_jacobian *= -1\&.0;
160 
161       return mass_jacobian_computed;
162     }
163 
164   else
165     {
166       libmesh_error();
167       return false;
168     }
169 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual \fBReal\fP libMesh::EigenTimeSolver::error_order () const\fC [inline]\fP, \fC [virtual]\fP"
error convergence order against deltat is not applicable to an eigenvalue problem\&. 
.PP
Definition at line 119 of file eigen_time_solver\&.h\&.
.PP
.nf
119 { return 0\&.; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::EigenTimeSolver::init ()\fC [virtual]\fP"
The initialization function\&. This method is used to initialize internal data structures before a simulation begins\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 56 of file eigen_time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::ImplicitSystem::add_matrix(), and libMesh::ImplicitSystem::have_matrix()\&.
.PP
.nf
57 {
58   // Add matrix "B" to _system if not already there\&.
59   // The user may have already added a matrix "B" before
60   // calling the System initialization\&.  This would be
61   // necessary if e\&.g\&. the System originally started life
62   // with a different type of TimeSolver and only later
63   // had its TimeSolver changed to an EigenTimeSolver\&.
64   if (!_system\&.have_matrix("B"))
65     _system\&.add_matrix("B");
66 }
.fi
.SS "void libMesh::TimeSolver::init_data ()\fC [virtual]\fP, \fC [inherited]\fP"
The data initialization function\&. This method is used to initialize internal data structures after the underlying \fBSystem\fP has been initialized 
.PP
Reimplemented in \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 77 of file time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_diff_solver, libMesh::TimeSolver::_linear_solver, libMesh::TimeSolver::_system, libMesh::System::name(), and libMesh::on_command_line()\&.
.PP
Referenced by libMesh::UnsteadySolver::init_data()\&.
.PP
.nf
78 {
79   _diff_solver->init();
80 
81   if (libMesh::on_command_line("--solver_system_names"))
82     _linear_solver->init((_system\&.name()+"_")\&.c_str());
83   else
84   _linear_solver->init();
85 }
.fi
.SS "bool libMesh::TimeSolver::is_adjoint () const\fC [inline]\fP, \fC [inherited]\fP"
Accessor for querying whether we need to do a primal or adjoint solve 
.PP
Definition at line 217 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::FEMSystem::build_context()\&.
.PP
.nf
218   { return _is_adjoint; }
.fi
.SS "virtual bool libMesh::EigenTimeSolver::is_steady () const\fC [inline]\fP, \fC [virtual]\fP"
This is effectively a steady-state solver\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 144 of file eigen_time_solver\&.h\&.
.PP
.nf
144 { return true; }
.fi
.SS "virtual \fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> >& libMesh::TimeSolver::linear_solver ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint and sensitivity problems\&. 
.PP
Definition at line 172 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_linear_solver\&.
.PP
.nf
172 { return _linear_solver; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::EigenTimeSolver::reinit ()\fC [virtual]\fP"
The reinitialization function\&. This method is used after changes in the mesh 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 51 of file eigen_time_solver\&.C\&.
.PP
.nf
52 {
53   // empty\&.\&.\&.
54 }
.fi
.SS "void libMesh::TimeSolver::retrieve_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method retrieves all the stored solutions at the current system\&.time 
.PP
Reimplemented in \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 110 of file time_solver\&.C\&.
.PP
.nf
111 {
112 }
.fi
.SS "void libMesh::TimeSolver::set_is_adjoint (bool_is_adjoint_value)\fC [inline]\fP, \fC [inherited]\fP"
Accessor for setting whether we need to do a primal or adjoint solve 
.PP
Definition at line 224 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::DifferentiableSystem::adjoint_solve(), libMesh::FEMSystem::postprocess(), and libMesh::DifferentiableSystem::solve()\&.
.PP
.nf
225   { _is_adjoint = _is_adjoint_value; }
.fi
.SS "void libMesh::TimeSolver::set_solution_history (const \fBSolutionHistory\fP &_solution_history)\fC [inherited]\fP"
A setter function users will employ if they need to do something other than save no solution history 
.PP
Definition at line 97 of file time_solver\&.C\&.
.PP
References libMesh::SolutionHistory::clone(), and libMesh::TimeSolver::solution_history\&.
.PP
.nf
98 {
99   solution_history = _solution_history\&.clone();
100 }
.fi
.SS "bool libMesh::EigenTimeSolver::side_residual (boolget_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
Forms the jacobian of the boundary terms\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 173 of file eigen_time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::libmesh_assert(), Matrix_A, Matrix_B, now_assembling, libMesh::DifferentiablePhysics::side_constraint(), libMesh::DifferentiablePhysics::side_mass_residual(), and libMesh::DifferentiablePhysics::side_time_derivative()\&.
.PP
.nf
175 {
176   // The EigenTimeSolver always requests jacobians?
177   //libmesh_assert (request_jacobian);
178 
179   // Assemble the operator for the spatial part\&.
180   if (now_assembling == Matrix_A)
181     {
182       bool jacobian_computed =
183         _system\&.side_time_derivative(request_jacobian, context);
184 
185       // The user shouldn't compute a jacobian unless requested
186       libmesh_assert (request_jacobian || !jacobian_computed);
187 
188       bool jacobian_computed2 =
189         _system\&.side_constraint(jacobian_computed, context);
190 
191       // The user shouldn't compute a jacobian unless requested
192       libmesh_assert (jacobian_computed || !jacobian_computed2);
193 
194       return jacobian_computed && jacobian_computed2;
195 
196     }
197 
198   // There is now a "side" equivalent for the mass matrix
199   else if (now_assembling == Matrix_B)
200     {
201       bool mass_jacobian_computed =
202         _system\&.side_mass_residual(request_jacobian, context);
203 
204       return mass_jacobian_computed;
205     }
206 
207   else
208     {
209       libmesh_error();
210       return false;
211     }
212 }
.fi
.SS "void libMesh::EigenTimeSolver::solve ()\fC [virtual]\fP"
Implements the assembly of both matrices A and B, and calls the \fBEigenSolver\fP to compute the eigenvalues\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 68 of file eigen_time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::assembly(), eigen_solver, libMesh::ImplicitSystem::get_matrix(), libMesh::ImplicitSystem::matrix, Matrix_A, Matrix_B, maxits, n_basis_vectors_to_use, n_converged_eigenpairs, n_eigenpairs_to_compute, n_iterations_reqd, now_assembling, libMesh::out, libMesh::TimeSolver::quiet, and tol\&.
.PP
.nf
69 {
70   // The standard implementation is basically to call:
71   // _diff_solver->solve();
72   // which internally assembles (when necessary) matrices and vectors
73   // and calls linear solver software while also doing Newton steps (see newton_solver\&.C)
74   //
75   // The element_residual and side_residual functions below control
76   // what happens in the interior of the element assembly loops\&.
77   // We have a system reference, so it's possible to call _system\&.assembly()
78   // ourselves if we want to\&.\&.\&.
79   //
80   // Interestingly, for the EigenSolver we don't need residuals\&.\&.\&.just Jacobians\&.
81   // The Jacobian should therefore always be requested, and always return
82   // jacobian_computed as being true\&.
83 
84   // The basic plan of attack is:
85   // \&.) Construct the Jacobian using _system\&.assembly(true,true) as we
86   //    would for a steady system\&.  Use a flag in this class to
87   //    control behavior in element_residual and side_residual
88   // \&.) Swap _system\&.matrix to matrix "B" (be sure to add this extra matrix during init)
89   // \&.) Call _system\&.assembly(true,true) again, using the flag in element_residual
90   //    and side_residual to only get the mass matrix terms\&.
91   // \&.) Send A and B to Steffen's EigenSolver interface\&.
92 
93   // Assemble the spatial part (matrix A) of the operator
94   if (!this->quiet)
95     libMesh::out << "Assembling matrix A\&." << std::endl;
96   _system\&.matrix =   &( _system\&.get_matrix ("System Matrix") );
97   this->now_assembling = Matrix_A;
98   _system\&.assembly(true, true);
99   //_system\&.matrix->print_matlab("matrix_A\&.m");
100 
101   // Point the system's matrix at B, call assembly again\&.
102   if (!this->quiet)
103     libMesh::out << "Assembling matrix B\&." << std::endl;
104   _system\&.matrix =   &( _system\&.get_matrix ("B") );
105   this->now_assembling = Matrix_B;
106   _system\&.assembly(true, true);
107   //_system\&.matrix->print_matlab("matrix_B\&.m");
108 
109   // Send matrices A, B to Steffen's SlepcEigenSolver interface
110   //libmesh_here();
111   if (!this->quiet)
112     libMesh::out << "Calling the EigenSolver\&." << std::endl;
113   std::pair<unsigned int, unsigned int> solve_data =
114     eigen_solver->solve_generalized (_system\&.get_matrix ("System Matrix"),
115                                      _system\&.get_matrix ("B"),
116                                      n_eigenpairs_to_compute,
117                                      n_basis_vectors_to_use,
118                                      tol,
119                                      maxits);
120 
121   this->n_converged_eigenpairs = solve_data\&.first;
122   this->n_iterations_reqd      = solve_data\&.second;
123 }
.fi
.SS "const \fBsys_type\fP& libMesh::TimeSolver::system () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 157 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
Referenced by libMesh::TimeSolver::reinit(), and libMesh::TimeSolver::solve()\&.
.PP
.nf
157 { return _system; }
.fi
.SS "\fBsys_type\fP& libMesh::TimeSolver::system ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 162 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
.nf
162 { return _system; }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBAutoPtr\fP<\fBDiffSolver\fP> libMesh::TimeSolver::_diff_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Definition at line 232 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::diff_solver(), libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::solve(), and libMesh::TimeSolver::solve()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> > libMesh::TimeSolver::_linear_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint problems\&. 
.PP
Definition at line 237 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::linear_solver(), and libMesh::TimeSolver::reinit()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBsys_type\fP& libMesh::TimeSolver::_system\fC [protected]\fP, \fC [inherited]\fP"
A reference to the system we are solving\&. 
.PP
Definition at line 242 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::du(), libMesh::EulerSolver::element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::SteadySolver::element_residual(), element_residual(), libMesh::UnsteadySolver::init(), libMesh::TimeSolver::init(), init(), libMesh::UnsteadySolver::init_data(), libMesh::TimeSolver::init_data(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::UnsteadySolver::reinit(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::EulerSolver::side_residual(), libMesh::Euler2Solver::side_residual(), libMesh::SteadySolver::side_residual(), side_residual(), libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), solve(), and libMesh::TimeSolver::system()\&.
.SS "\fBAutoPtr\fP<\fBEigenSolver\fP<\fBNumber\fP> > libMesh::EigenTimeSolver::eigen_solver"
The \fBEigenSolver\fP object\&. This is what actually makes the calls to SLEPc\&. 
.PP
Definition at line 150 of file eigen_time_solver\&.h\&.
.PP
Referenced by EigenTimeSolver(), and solve()\&.
.SS "bool libMesh::TimeSolver::first_solve\fC [protected]\fP, \fC [inherited]\fP"
A bool that will be true the first time \fBsolve()\fP is called, and false thereafter 
.PP
Definition at line 248 of file time_solver\&.h\&.
.SS "unsigned int libMesh::EigenTimeSolver::maxits"
The maximum number of iterations allowed to solve the problem\&. 
.PP
Definition at line 161 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.
.SS "unsigned int libMesh::EigenTimeSolver::n_basis_vectors_to_use"
The number of basis vectors to use in the computation\&. According to ex16, the number of basis vectors must be >= the number of eigenpairs requested, and ncv >= 2*nev is recommended\&. Increasing this number, even by a little bit, can \fIgreatly\fP reduce the number of (\fBEigenSolver\fP) iterations required to compute the desired number of eigenpairs, but the \fIcost per iteration\fP goes up drastically as well\&. 
.PP
Definition at line 177 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.
.SS "unsigned int libMesh::EigenTimeSolver::n_converged_eigenpairs"
After a solve, holds the number of eigenpairs successfully converged\&. 
.PP
Definition at line 183 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.
.SS "unsigned int libMesh::EigenTimeSolver::n_eigenpairs_to_compute"
The number of eigenvectors/values to be computed\&. 
.PP
Definition at line 166 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.
.SS "unsigned int libMesh::EigenTimeSolver::n_iterations_reqd"
After a solve, holds the number of iterations required to converge the requested number of eigenpairs\&. 
.PP
Definition at line 189 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.
.SS "\fBNowAssembling\fP libMesh::EigenTimeSolver::now_assembling\fC [private]\fP"
Flag which controls the internals of \fBelement_residual()\fP and \fBside_residual()\fP\&. 
.PP
Definition at line 213 of file eigen_time_solver\&.h\&.
.PP
Referenced by element_residual(), side_residual(), and solve()\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::TimeSolver::old_local_nonlinear_solution\fC [protected]\fP, \fC [inherited]\fP"
Serial vector of _system\&.get_vector('_old_nonlinear_solution') 
.PP
Definition at line 253 of file time_solver\&.h\&.
.SS "bool libMesh::TimeSolver::quiet\fC [inherited]\fP"
Print extra debugging information if quiet == false\&. 
.PP
Definition at line 177 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), and solve()\&.
.SS "unsigned int libMesh::TimeSolver::reduce_deltat_on_diffsolver_failure\fC [inherited]\fP"
This value (which defaults to zero) is the number of times the \fBTimeSolver\fP is allowed to halve deltat and let the \fBDiffSolver\fP repeat the latest failed solve with a reduced timestep\&. Note that this has no effect for SteadySolvers\&. Note that you must set at least one of the \fBDiffSolver\fP flags 'continue_after_max_iterations' or 'continue_after_backtrack_failure' to allow the \fBTimeSolver\fP to retry the solve\&. 
.PP
Definition at line 205 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), and libMesh::UnsteadySolver::solve()\&.
.SS "\fBAutoPtr\fP<\fBSolutionHistory\fP> libMesh::TimeSolver::solution_history\fC [protected]\fP, \fC [inherited]\fP"
An \fBAutoPtr\fP to a \fBSolutionHistory\fP object\&. Default is \fBNoSolutionHistory\fP, which the user can override by declaring a different kind of \fBSolutionHistory\fP in the application 
.PP
Definition at line 260 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::retrieve_timestep(), and libMesh::TimeSolver::set_solution_history()\&.
.SS "\fBReal\fP libMesh::EigenTimeSolver::tol"
The linear solver tolerance to be used when solving the eigenvalue problem\&. FIXME: need more info\&.\&.\&. 
.PP
Definition at line 156 of file eigen_time_solver\&.h\&.
.PP
Referenced by solve()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
