.TH "libMesh::EulerSolver" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::EulerSolver \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <euler_solver\&.h>\fP
.PP
Inherits \fBlibMesh::UnsteadySolver\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBUnsteadySolver\fP \fBParent\fP"
.br
.ti -1c
.RI "typedef \fBDifferentiableSystem\fP \fBsys_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEulerSolver\fP (\fBsys_type\fP &s)"
.br
.ti -1c
.RI "virtual \fB~EulerSolver\fP ()"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBerror_order\fP () const "
.br
.ti -1c
.RI "virtual bool \fBelement_residual\fP (bool request_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual bool \fBside_residual\fP (bool request_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBsolve\fP ()"
.br
.ti -1c
.RI "virtual void \fBadvance_timestep\fP ()"
.br
.ti -1c
.RI "virtual void \fBadjoint_advance_timestep\fP ()"
.br
.ti -1c
.RI "virtual void \fBretrieve_timestep\fP ()"
.br
.ti -1c
.RI "\fBNumber\fP \fBold_nonlinear_solution\fP (const \fBdof_id_type\fP global_dof_number) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBdu\fP (const \fBSystemNorm\fP &norm) const "
.br
.ti -1c
.RI "virtual bool \fBis_steady\fP () const "
.br
.ti -1c
.RI "virtual void \fBbefore_timestep\fP ()"
.br
.ti -1c
.RI "const \fBsys_type\fP & \fBsystem\fP () const "
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBDiffSolver\fP > & \fBdiff_solver\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBLinearSolver\fP
.br
< \fBNumber\fP > > & \fBlinear_solver\fP ()"
.br
.ti -1c
.RI "void \fBset_solution_history\fP (const \fBSolutionHistory\fP &_solution_history)"
.br
.ti -1c
.RI "bool \fBis_adjoint\fP () const "
.br
.ti -1c
.RI "void \fBset_is_adjoint\fP (bool _is_adjoint_value)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBReal\fP \fBtheta\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBold_local_nonlinear_solution\fP"
.br
.ti -1c
.RI "bool \fBquiet\fP"
.br
.ti -1c
.RI "unsigned int \fBreduce_deltat_on_diffsolver_failure\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBfirst_solve\fP"
.br
.ti -1c
.RI "bool \fBfirst_adjoint_step\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBDiffSolver\fP > \fB_diff_solver\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > \fB_linear_solver\fP"
.br
.ti -1c
.RI "\fBsys_type\fP & \fB_system\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSolutionHistory\fP > \fBsolution_history\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class defines a theta-method Euler (defaulting to Backward Euler with theta = 1\&.0) solver to handle time integration of DifferentiableSystems\&.
.PP
This class is part of the new \fBDifferentiableSystem\fP framework, which is still experimental\&. Users of this framework should beware of bugs and future API changes\&.
.PP
\fBAuthor:\fP
.RS 4
Roy H\&. Stogner 2006 
.RE
.PP

.PP
Definition at line 45 of file euler_solver\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBUnsteadySolver\fP \fBlibMesh::EulerSolver::Parent\fP"
The parent class 
.PP
Definition at line 51 of file euler_solver\&.h\&.
.SS "typedef \fBDifferentiableSystem\fP \fBlibMesh::TimeSolver::sys_type\fP\fC [inherited]\fP"
The type of system 
.PP
Definition at line 66 of file time_solver\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::EulerSolver::EulerSolver (\fBsys_type\fP &s)\fC [explicit]\fP"
Constructor\&. Requires a reference to the system to be solved\&. 
.PP
Definition at line 27 of file euler_solver\&.C\&.
.PP
.nf
28   : UnsteadySolver(s), theta(1\&.)
29 {
30 }
.fi
.SS "libMesh::EulerSolver::~EulerSolver ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 34 of file euler_solver\&.C\&.
.PP
.nf
35 {
36 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::UnsteadySolver::adjoint_advance_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method advances the adjoint solution to the previous timestep, after an adjoint_solve() has been performed\&. This will be done before every UnsteadySolver::adjoint_solve()\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 178 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::deltat, libMesh::UnsteadySolver::first_adjoint_step, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::NumericVector< T >::localize(), libMesh::UnsteadySolver::old_local_nonlinear_solution, libMesh::TimeSolver::solution_history, and libMesh::System::time\&.
.PP
.nf
179 {
180   // On the first call of this function, we dont save the adjoint solution or
181   // decrement the time, we just call the retrieve function below
182   if(!first_adjoint_step)
183     {
184       // Call the store function to store the last adjoint before decrementing the time
185       solution_history->store();
186       // Decrement the system time
187       _system\&.time -= _system\&.deltat;
188     }
189   else
190     {
191       first_adjoint_step = false;
192     }
193 
194   // Retrieve the primal solution vectors at this time using the
195   // solution_history object
196   solution_history->retrieve();
197 
198   // Dont forget to localize the old_nonlinear_solution !
199   _system\&.get_vector("_old_nonlinear_solution")\&.localize
200     (*old_local_nonlinear_solution,
201      _system\&.get_dof_map()\&.get_send_list());
202 }
.fi
.SS "void libMesh::UnsteadySolver::advance_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method advances the solution to the next timestep, after a \fBsolve()\fP has been performed\&. Often this will be done after every \fBUnsteadySolver::solve()\fP, but adaptive mesh refinement and/or adaptive time step selection may require some \fBsolve()\fP steps to be repeated\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP\&.
.PP
Definition at line 152 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::deltat, libMesh::UnsteadySolver::first_solve, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::NumericVector< T >::localize(), libMesh::UnsteadySolver::old_local_nonlinear_solution, libMesh::System::solution, libMesh::TimeSolver::solution_history, and libMesh::System::time\&.
.PP
Referenced by libMesh::UnsteadySolver::solve()\&.
.PP
.nf
153 {
154   if (!first_solve)
155     {
156       // Store the solution, does nothing by default
157       // User has to attach appropriate solution_history object for this to
158       // actually store anything anywhere
159       solution_history->store();
160 
161       _system\&.time += _system\&.deltat;
162     }
163 
164   NumericVector<Number> &old_nonlinear_soln =
165     _system\&.get_vector("_old_nonlinear_solution");
166   NumericVector<Number> &nonlinear_solution =
167     *(_system\&.solution);
168 
169   old_nonlinear_soln = nonlinear_solution;
170 
171   old_nonlinear_soln\&.localize
172     (*old_local_nonlinear_solution,
173      _system\&.get_dof_map()\&.get_send_list());
174 }
.fi
.SS "virtual void libMesh::TimeSolver::before_timestep ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This method is for subclasses or users to override to do arbitrary processing between timesteps 
.PP
Definition at line 152 of file time_solver\&.h\&.
.PP
.nf
152 {}
.fi
.SS "virtual \fBAutoPtr\fP<\fBDiffSolver\fP>& libMesh::TimeSolver::diff_solver ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP\&.
.PP
Definition at line 167 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_diff_solver\&.
.PP
.nf
167 { return _diff_solver; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "\fBReal\fP libMesh::UnsteadySolver::du (const \fBSystemNorm\fP &norm) const\fC [virtual]\fP, \fC [inherited]\fP"
Computes the size of ||u^{n+1} - u^{n}|| in some norm\&.
.PP
Note that, while you can always call this function, its result may or may not be very meaningful\&. For example, if you call this function right after calling \fBadvance_timestep()\fP then you'll get a result of zero since old_nonlinear_solution is set equal to nonlinear_solution in this function\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 227 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::calculate_norm(), libMesh::System::get_vector(), and libMesh::System::solution\&.
.PP
.nf
228 {
229 
230   AutoPtr<NumericVector<Number> > solution_copy =
231     _system\&.solution->clone();
232 
233   solution_copy->add(-1\&., _system\&.get_vector("_old_nonlinear_solution"));
234 
235   solution_copy->close();
236 
237   return _system\&.calculate_norm(*solution_copy, norm);
238 }
.fi
.SS "bool libMesh::EulerSolver::element_residual (boolrequest_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
This method uses the \fBDifferentiableSystem\fP's element_time_derivative() and element_constraint() to build a full residual on an element\&. What combination it uses will depend on theta\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 50 of file euler_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::deltat, libMesh::DiffContext::elem_reinit(), libMesh::DiffContext::elem_solution_derivative, libMesh::DifferentiablePhysics::element_constraint(), libMesh::DifferentiablePhysics::element_time_derivative(), libMesh::DifferentiablePhysics::eulerian_residual(), libMesh::DiffContext::fixed_solution_derivative, libMesh::DiffContext::get_dof_indices(), libMesh::DiffContext::get_elem_fixed_solution(), libMesh::DiffContext::get_elem_jacobian(), libMesh::DiffContext::get_elem_residual(), libMesh::DiffContext::get_elem_solution(), libMesh::DifferentiablePhysics::mass_residual(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::DenseVector< T >::size(), libMesh::DenseVector< T >::swap(), libMesh::DenseMatrix< T >::swap(), theta, libMesh::System::use_fixed_solution, libMesh::DenseMatrix< T >::zero(), and libMesh::DenseVector< T >::zero()\&.
.PP
.nf
52 {
53   unsigned int n_dofs = context\&.get_elem_solution()\&.size();
54 
55   // Local nonlinear solution at old timestep
56   DenseVector<Number> old_elem_solution(n_dofs);
57   for (unsigned int i=0; i != n_dofs; ++i)
58     old_elem_solution(i) =
59       old_nonlinear_solution(context\&.get_dof_indices()[i]);
60 
61   // Local nonlinear solution at time t_theta
62   DenseVector<Number> theta_solution(context\&.get_elem_solution());
63   theta_solution *= theta;
64   theta_solution\&.add(1\&. - theta, old_elem_solution);
65 
66   // Technically the elem_solution_derivative is either theta
67   // or -1\&.0 in this implementation, but we scale the former part
68   // ourselves
69   context\&.elem_solution_derivative = 1\&.0;
70 
71   // Technically the fixed_solution_derivative is always theta,
72   // but we're scaling a whole jacobian by theta after these first
73   // evaluations
74   context\&.fixed_solution_derivative = 1\&.0;
75 
76   // If a fixed solution is requested, we'll use theta_solution
77   if (_system\&.use_fixed_solution)
78     context\&.get_elem_fixed_solution() = theta_solution;
79 
80   // Move theta_->elem_, elem_->theta_
81   context\&.get_elem_solution()\&.swap(theta_solution);
82 
83   // Move the mesh into place first if necessary
84   context\&.elem_reinit(theta);
85 
86   // We're going to compute just the change in elem_residual
87   // (and possibly elem_jacobian), then add back the old values
88   DenseVector<Number> old_elem_residual(context\&.get_elem_residual());
89   DenseMatrix<Number> old_elem_jacobian;
90   if (request_jacobian)
91     {
92       old_elem_jacobian = context\&.get_elem_jacobian();
93       context\&.get_elem_jacobian()\&.zero();
94     }
95   context\&.get_elem_residual()\&.zero();
96 
97   // Get the time derivative at t_theta
98   bool jacobian_computed =
99     _system\&.element_time_derivative(request_jacobian, context);
100 
101   // For a moving mesh problem we may need the pseudoconvection term too
102   jacobian_computed =
103     _system\&.eulerian_residual(jacobian_computed, context) && jacobian_computed;
104 
105   // Scale the time-dependent residual and jacobian correctly
106   context\&.get_elem_residual() *= _system\&.deltat;
107   if (jacobian_computed)
108     context\&.get_elem_jacobian() *= (theta * _system\&.deltat);
109 
110   // The fixed_solution_derivative is always theta,
111   // and now we're done scaling jacobians
112   context\&.fixed_solution_derivative = theta;
113 
114   // We evaluate mass_residual with the change in solution
115   // to get the mass matrix, reusing old_elem_solution to hold that
116   // delta_solution\&.  We're solving dt*F(u) - du = 0, so our
117   // delta_solution is old_solution - new_solution\&.
118   // We're still keeping elem_solution in theta_solution for now
119   old_elem_solution -= theta_solution;
120 
121   // Move old_->elem_, theta_->old_
122   context\&.get_elem_solution()\&.swap(old_elem_solution);
123 
124   // We do a trick here to avoid using a non-1
125   // elem_solution_derivative:
126   context\&.get_elem_jacobian() *= -1\&.0;
127   context\&.fixed_solution_derivative *= -1\&.0;
128   jacobian_computed = _system\&.mass_residual(jacobian_computed, context) &&
129     jacobian_computed;
130   context\&.get_elem_jacobian() *= -1\&.0;
131   context\&.fixed_solution_derivative *= -1\&.0;
132 
133   // Move elem_->elem_, old_->theta_
134   context\&.get_elem_solution()\&.swap(theta_solution);
135 
136   // Restore the elem position if necessary
137   context\&.elem_reinit(1\&.);
138 
139   // Add the constraint term
140   jacobian_computed = _system\&.element_constraint(jacobian_computed, context) &&
141     jacobian_computed;
142 
143   // Add back the old residual and jacobian
144   context\&.get_elem_residual() += old_elem_residual;
145   if (request_jacobian)
146     {
147       if (jacobian_computed)
148         context\&.get_elem_jacobian() += old_elem_jacobian;
149       else
150         context\&.get_elem_jacobian()\&.swap(old_elem_jacobian);
151     }
152 
153   return jacobian_computed;
154 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "\fBReal\fP libMesh::EulerSolver::error_order () const\fC [virtual]\fP"
Error convergence order: 2 for Crank-Nicolson, 1 otherwise 
.PP
Implements \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 40 of file euler_solver\&.C\&.
.PP
References theta\&.
.PP
.nf
41 {
42   if (theta == 0\&.5)
43     return 2\&.;
44   return 1\&.;
45 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::UnsteadySolver::init ()\fC [virtual]\fP, \fC [inherited]\fP"
The initialization function\&. This method is used to initialize internal data structures before a simulation begins\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP\&.
.PP
Definition at line 46 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::add_vector(), and libMesh::TimeSolver::init()\&.
.PP
.nf
47 {
48   TimeSolver::init();
49 
50   _system\&.add_vector("_old_nonlinear_solution");
51 }
.fi
.SS "void libMesh::UnsteadySolver::init_data ()\fC [virtual]\fP, \fC [inherited]\fP"
The data initialization function\&. This method is used to initialize internal data structures after the underlying \fBSystem\fP has been initialized 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 55 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::GHOSTED, libMesh::TimeSolver::init_data(), libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::UnsteadySolver::old_local_nonlinear_solution, and libMesh::SERIAL\&.
.PP
.nf
56 {
57   TimeSolver::init_data();
58 
59 #ifdef LIBMESH_ENABLE_GHOSTED
60   old_local_nonlinear_solution->init (_system\&.n_dofs(), _system\&.n_local_dofs(),
61                                       _system\&.get_dof_map()\&.get_send_list(), false,
62                                       GHOSTED);
63 #else
64   old_local_nonlinear_solution->init (_system\&.n_dofs(), false, SERIAL);
65 #endif
66 }
.fi
.SS "bool libMesh::TimeSolver::is_adjoint () const\fC [inline]\fP, \fC [inherited]\fP"
Accessor for querying whether we need to do a primal or adjoint solve 
.PP
Definition at line 217 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::FEMSystem::build_context()\&.
.PP
.nf
218   { return _is_adjoint; }
.fi
.SS "virtual bool libMesh::UnsteadySolver::is_steady () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This is not a steady-state solver\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 149 of file unsteady_solver\&.h\&.
.PP
.nf
149 { return false; }
.fi
.SS "virtual \fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> >& libMesh::TimeSolver::linear_solver ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint and sensitivity problems\&. 
.PP
Definition at line 172 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_linear_solver\&.
.PP
.nf
172 { return _linear_solver; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBNumber\fP libMesh::UnsteadySolver::old_nonlinear_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the old nonlinear solution for the specified global DOF\&. 
.RE
.PP

.PP
Definition at line 216 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::n_dofs(), and libMesh::UnsteadySolver::old_local_nonlinear_solution\&.
.PP
Referenced by element_residual(), libMesh::Euler2Solver::element_residual(), side_residual(), and libMesh::Euler2Solver::side_residual()\&.
.PP
.nf
218 {
219   libmesh_assert_less (global_dof_number, _system\&.get_dof_map()\&.n_dofs());
220   libmesh_assert_less (global_dof_number, old_local_nonlinear_solution->size());
221 
222   return (*old_local_nonlinear_solution)(global_dof_number);
223 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::UnsteadySolver::reinit ()\fC [virtual]\fP, \fC [inherited]\fP"
The reinitialization function\&. This method is used to resize internal data vectors after a mesh change\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP\&.
.PP
Definition at line 70 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::GHOSTED, libMesh::NumericVector< T >::localize(), libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::UnsteadySolver::old_local_nonlinear_solution, libMesh::TimeSolver::reinit(), and libMesh::SERIAL\&.
.PP
.nf
71 {
72   TimeSolver::reinit();
73 
74 #ifdef LIBMESH_ENABLE_GHOSTED
75   old_local_nonlinear_solution->init (_system\&.n_dofs(), _system\&.n_local_dofs(),
76                                       _system\&.get_dof_map()\&.get_send_list(), false,
77                                       GHOSTED);
78 #else
79   old_local_nonlinear_solution->init (_system\&.n_dofs(), false, SERIAL);
80 #endif
81 
82   // localize the old solution
83   NumericVector<Number> &old_nonlinear_soln =
84     _system\&.get_vector("_old_nonlinear_solution");
85 
86   old_nonlinear_soln\&.localize
87     (*old_local_nonlinear_solution,
88      _system\&.get_dof_map()\&.get_send_list());
89 }
.fi
.SS "void libMesh::UnsteadySolver::retrieve_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method retrieves all the stored solutions at the current system\&.time 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 204 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::NumericVector< T >::localize(), libMesh::UnsteadySolver::old_local_nonlinear_solution, and libMesh::TimeSolver::solution_history\&.
.PP
.nf
205 {
206   // Retrieve all the stored vectors at the current time
207   solution_history->retrieve();
208 
209   // Dont forget to localize the old_nonlinear_solution !
210   _system\&.get_vector("_old_nonlinear_solution")\&.localize
211     (*old_local_nonlinear_solution,
212      _system\&.get_dof_map()\&.get_send_list());
213 }
.fi
.SS "void libMesh::TimeSolver::set_is_adjoint (bool_is_adjoint_value)\fC [inline]\fP, \fC [inherited]\fP"
Accessor for setting whether we need to do a primal or adjoint solve 
.PP
Definition at line 224 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::DifferentiableSystem::adjoint_solve(), libMesh::FEMSystem::postprocess(), and libMesh::DifferentiableSystem::solve()\&.
.PP
.nf
225   { _is_adjoint = _is_adjoint_value; }
.fi
.SS "void libMesh::TimeSolver::set_solution_history (const \fBSolutionHistory\fP &_solution_history)\fC [inherited]\fP"
A setter function users will employ if they need to do something other than save no solution history 
.PP
Definition at line 97 of file time_solver\&.C\&.
.PP
References libMesh::SolutionHistory::clone(), and libMesh::TimeSolver::solution_history\&.
.PP
.nf
98 {
99   solution_history = _solution_history\&.clone();
100 }
.fi
.SS "bool libMesh::EulerSolver::side_residual (boolrequest_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
This method uses the \fBDifferentiableSystem\fP's side_time_derivative() and side_constraint() to build a full residual on an element's side\&. What combination it uses will depend on theta\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 158 of file euler_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::deltat, libMesh::DiffContext::elem_side_reinit(), libMesh::DiffContext::elem_solution_derivative, libMesh::DiffContext::fixed_solution_derivative, libMesh::DiffContext::get_dof_indices(), libMesh::DiffContext::get_elem_fixed_solution(), libMesh::DiffContext::get_elem_jacobian(), libMesh::DiffContext::get_elem_residual(), libMesh::DiffContext::get_elem_solution(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::DifferentiablePhysics::side_constraint(), libMesh::DifferentiablePhysics::side_mass_residual(), libMesh::DifferentiablePhysics::side_time_derivative(), libMesh::DenseVector< T >::size(), libMesh::DenseVector< T >::swap(), libMesh::DenseMatrix< T >::swap(), theta, libMesh::System::use_fixed_solution, libMesh::DenseMatrix< T >::zero(), and libMesh::DenseVector< T >::zero()\&.
.PP
.nf
160 {
161   unsigned int n_dofs = context\&.get_elem_solution()\&.size();
162 
163   // Local nonlinear solution at old timestep
164   DenseVector<Number> old_elem_solution(n_dofs);
165   for (unsigned int i=0; i != n_dofs; ++i)
166     old_elem_solution(i) =
167       old_nonlinear_solution(context\&.get_dof_indices()[i]);
168 
169   // Local nonlinear solution at time t_theta
170   DenseVector<Number> theta_solution(context\&.get_elem_solution());
171   theta_solution *= theta;
172   theta_solution\&.add(1\&. - theta, old_elem_solution);
173 
174   // Technically the elem_solution_derivative is either theta
175   // or 1\&.0 in this implementation, but we scale the former part
176   // ourselves
177   context\&.elem_solution_derivative = 1\&.0;
178 
179   // Technically the fixed_solution_derivative is always theta,
180   // but we're scaling a whole jacobian by theta after these first
181   // evaluations
182   context\&.fixed_solution_derivative = 1\&.0;
183 
184   // If a fixed solution is requested, we'll use theta_solution
185   if (_system\&.use_fixed_solution)
186     context\&.get_elem_fixed_solution() = theta_solution;
187 
188   // Move theta_->elem_, elem_->theta_
189   context\&.get_elem_solution()\&.swap(theta_solution);
190 
191   // Move the mesh into place first if necessary
192   context\&.elem_side_reinit(theta);
193 
194   // We're going to compute just the change in elem_residual
195   // (and possibly elem_jacobian), then add back the old values
196   DenseVector<Number> old_elem_residual(context\&.get_elem_residual());
197   DenseMatrix<Number> old_elem_jacobian;
198   if (request_jacobian)
199     {
200       old_elem_jacobian = context\&.get_elem_jacobian();
201       context\&.get_elem_jacobian()\&.zero();
202     }
203   context\&.get_elem_residual()\&.zero();
204 
205   // Get the time derivative at t_theta
206   bool jacobian_computed =
207     _system\&.side_time_derivative(request_jacobian, context);
208 
209   // Scale the time-dependent residual and jacobian correctly
210   context\&.get_elem_residual() *= _system\&.deltat;
211   if (jacobian_computed)
212     context\&.get_elem_jacobian() *= (theta * _system\&.deltat);
213 
214   // The fixed_solution_derivative is always theta,
215   // and now we're done scaling jacobians
216   context\&.fixed_solution_derivative = theta;
217 
218   // We evaluate side_mass_residual with the change in solution
219   // to get the mass matrix, reusing old_elem_solution to hold that
220   // delta_solution\&.  We're solving dt*F(u) - du = 0, so our
221   // delta_solution is old_solution - new_solution\&.
222   // We're still keeping elem_solution in theta_solution for now
223   old_elem_solution -= theta_solution;
224 
225   // Move old_->elem_, theta_->old_
226   context\&.get_elem_solution()\&.swap(old_elem_solution);
227 
228   // We do a trick here to avoid using a non-1
229   // elem_solution_derivative:
230   context\&.get_elem_jacobian() *= -1\&.0;
231   jacobian_computed = _system\&.side_mass_residual(jacobian_computed, context) &&
232     jacobian_computed;
233   context\&.get_elem_jacobian() *= -1\&.0;
234 
235   // Move elem_->elem_, old_->theta_
236   context\&.get_elem_solution()\&.swap(theta_solution);
237 
238   // Restore the elem position if necessary
239   context\&.elem_side_reinit(1\&.);
240 
241   // Add the constraint term
242   jacobian_computed = _system\&.side_constraint(jacobian_computed, context) &&
243     jacobian_computed;
244 
245   // Add back the old residual and jacobian
246   context\&.get_elem_residual() += old_elem_residual;
247   if (request_jacobian)
248     {
249       if (jacobian_computed)
250         context\&.get_elem_jacobian() += old_elem_jacobian;
251       else
252         context\&.get_elem_jacobian()\&.swap(old_elem_jacobian);
253     }
254 
255   return jacobian_computed;
256 }
.fi
.SS "void libMesh::UnsteadySolver::solve ()\fC [virtual]\fP, \fC [inherited]\fP"
This method solves for the solution at the next timestep\&. Usually we will only need to solve one (non)linear system per timestep, but more complex subclasses may override this\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Reimplemented in \fBlibMesh::AdaptiveTimeSolver\fP, and \fBlibMesh::TwostepTimeSolver\fP\&.
.PP
Definition at line 93 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_diff_solver, libMesh::TimeSolver::_system, libMesh::UnsteadySolver::advance_timestep(), libMesh::DifferentiableSystem::deltat, libMesh::DiffSolver::DIVERGED_BACKTRACKING_FAILURE, libMesh::DiffSolver::DIVERGED_MAX_NONLINEAR_ITERATIONS, libMesh::UnsteadySolver::first_solve, libMesh::out, libMesh::TimeSolver::quiet, and libMesh::TimeSolver::reduce_deltat_on_diffsolver_failure\&.
.PP
.nf
94 {
95   if (first_solve)
96     {
97       advance_timestep();
98       first_solve = false;
99     }
100 
101   unsigned int solve_result = _diff_solver->solve();
102 
103   // If we requested the UnsteadySolver to attempt reducing dt after a
104   // failed DiffSolver solve, check the results of the solve now\&.
105   if (reduce_deltat_on_diffsolver_failure)
106     {
107       bool backtracking_failed =
108         solve_result & DiffSolver::DIVERGED_BACKTRACKING_FAILURE;
109 
110       bool max_iterations =
111         solve_result & DiffSolver::DIVERGED_MAX_NONLINEAR_ITERATIONS;
112 
113       if (backtracking_failed || max_iterations)
114         {
115           // Cut timestep in half
116           for (unsigned int nr=0; nr<reduce_deltat_on_diffsolver_failure; ++nr)
117             {
118               _system\&.deltat *= 0\&.5;
119               libMesh::out << "Newton backtracking failed\&.  Trying with smaller timestep, dt="
120                            << _system\&.deltat << std::endl;
121 
122               solve_result = _diff_solver->solve();
123 
124               // Check solve results with reduced timestep
125               bool backtracking_still_failed =
126                 solve_result & DiffSolver::DIVERGED_BACKTRACKING_FAILURE;
127 
128               bool backtracking_max_iterations =
129                 solve_result & DiffSolver::DIVERGED_MAX_NONLINEAR_ITERATIONS;
130 
131               if (!backtracking_still_failed && !backtracking_max_iterations)
132                 {
133                   if (!quiet)
134                     libMesh::out << "Reduced dt solve succeeded\&." << std::endl;
135                   return;
136                 }
137             }
138 
139           // If we made it here, we still couldn't converge the solve after
140           // reducing deltat
141           libMesh::out << "DiffSolver::solve() did not succeed after "
142                        << reduce_deltat_on_diffsolver_failure
143                        << " attempts\&." << std::endl;
144           libmesh_convergence_failure();
145 
146         } // end if (backtracking_failed || max_iterations)
147     } // end if (reduce_deltat_on_diffsolver_failure)
148 }
.fi
.SS "const \fBsys_type\fP& libMesh::TimeSolver::system () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 157 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
Referenced by libMesh::TimeSolver::reinit(), and libMesh::TimeSolver::solve()\&.
.PP
.nf
157 { return _system; }
.fi
.SS "\fBsys_type\fP& libMesh::TimeSolver::system ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 162 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
.nf
162 { return _system; }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBAutoPtr\fP<\fBDiffSolver\fP> libMesh::TimeSolver::_diff_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Definition at line 232 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::diff_solver(), libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::solve(), and libMesh::TimeSolver::solve()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> > libMesh::TimeSolver::_linear_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint problems\&. 
.PP
Definition at line 237 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::linear_solver(), and libMesh::TimeSolver::reinit()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBsys_type\fP& libMesh::TimeSolver::_system\fC [protected]\fP, \fC [inherited]\fP"
A reference to the system we are solving\&. 
.PP
Definition at line 242 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::du(), element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::SteadySolver::element_residual(), libMesh::EigenTimeSolver::element_residual(), libMesh::UnsteadySolver::init(), libMesh::TimeSolver::init(), libMesh::EigenTimeSolver::init(), libMesh::UnsteadySolver::init_data(), libMesh::TimeSolver::init_data(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::UnsteadySolver::reinit(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), side_residual(), libMesh::Euler2Solver::side_residual(), libMesh::SteadySolver::side_residual(), libMesh::EigenTimeSolver::side_residual(), libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), libMesh::EigenTimeSolver::solve(), and libMesh::TimeSolver::system()\&.
.SS "bool libMesh::UnsteadySolver::first_adjoint_step\fC [protected]\fP, \fC [inherited]\fP"
A bool that will be true the first time \fBadjoint_advance_timestep()\fP is called, (when the primal solution is to be used to set adjoint boundary conditions) and false thereafter 
.PP
Definition at line 163 of file unsteady_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep()\&.
.SS "bool libMesh::UnsteadySolver::first_solve\fC [protected]\fP, \fC [inherited]\fP"
A bool that will be true the first time \fBsolve()\fP is called, and false thereafter 
.PP
Definition at line 157 of file unsteady_solver\&.h\&.
.PP
Referenced by libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::TwostepTimeSolver::solve(), and libMesh::UnsteadySolver::solve()\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::UnsteadySolver::old_local_nonlinear_solution\fC [inherited]\fP"
Serial vector of _system\&.get_vector('_old_nonlinear_solution') 
.PP
Definition at line 133 of file unsteady_solver\&.h\&.
.PP
Referenced by libMesh::AdaptiveTimeSolver::AdaptiveTimeSolver(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::AdaptiveTimeSolver::init(), libMesh::UnsteadySolver::init_data(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::UnsteadySolver::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), and libMesh::AdaptiveTimeSolver::~AdaptiveTimeSolver()\&.
.SS "bool libMesh::TimeSolver::quiet\fC [inherited]\fP"
Print extra debugging information if quiet == false\&. 
.PP
Definition at line 177 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), and libMesh::EigenTimeSolver::solve()\&.
.SS "unsigned int libMesh::TimeSolver::reduce_deltat_on_diffsolver_failure\fC [inherited]\fP"
This value (which defaults to zero) is the number of times the \fBTimeSolver\fP is allowed to halve deltat and let the \fBDiffSolver\fP repeat the latest failed solve with a reduced timestep\&. Note that this has no effect for SteadySolvers\&. Note that you must set at least one of the \fBDiffSolver\fP flags 'continue_after_max_iterations' or 'continue_after_backtrack_failure' to allow the \fBTimeSolver\fP to retry the solve\&. 
.PP
Definition at line 205 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), and libMesh::UnsteadySolver::solve()\&.
.SS "\fBAutoPtr\fP<\fBSolutionHistory\fP> libMesh::TimeSolver::solution_history\fC [protected]\fP, \fC [inherited]\fP"
An \fBAutoPtr\fP to a \fBSolutionHistory\fP object\&. Default is \fBNoSolutionHistory\fP, which the user can override by declaring a different kind of \fBSolutionHistory\fP in the application 
.PP
Definition at line 260 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::retrieve_timestep(), and libMesh::TimeSolver::set_solution_history()\&.
.SS "\fBReal\fP libMesh::EulerSolver::theta"
The value for the theta method to employ: 1\&.0 corresponds to backwards Euler, 0\&.0 corresponds to forwards Euler, 0\&.5 corresponds to Crank-Nicolson\&. 
.PP
Definition at line 93 of file euler_solver\&.h\&.
.PP
Referenced by element_residual(), error_order(), and side_residual()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
