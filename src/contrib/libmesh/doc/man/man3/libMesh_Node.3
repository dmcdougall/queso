.TH "libMesh::Node" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Node \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <node\&.h>\fP
.PP
Inherits \fBlibMesh::Point\fP, \fBlibMesh::DofObject\fP, and \fBlibMesh::ReferenceCountedObject< Node >\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBPackedNode\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNode\fP (const \fBReal\fP \fBx\fP=0, const \fBReal\fP y=0, const \fBReal\fP z=0, const \fBdof_id_type\fP \fBid\fP=\fBinvalid_id\fP)"
.br
.ti -1c
.RI "\fBNode\fP (const \fBNode\fP &n)"
.br
.ti -1c
.RI "\fBNode\fP (const \fBPoint\fP &p, const \fBdof_id_type\fP \fBid\fP=\fBinvalid_id\fP)"
.br
.ti -1c
.RI "\fB~Node\fP ()"
.br
.ti -1c
.RI "\fBNode\fP & \fBoperator=\fP (const \fBPoint\fP &p)"
.br
.ti -1c
.RI "bool \fBactive\fP () const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBNode\fP &rhs) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "unsigned int \fBpacked_size\fP () const "
.br
.ti -1c
.RI "unsigned int \fBvalence\fP () const "
.br
.ti -1c
.RI "void \fBset_valence\fP (unsigned int val)"
.br
.ti -1c
.RI "void \fBassign\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "const \fBReal\fP & \fBoperator()\fP (const unsigned int i) const"
.br
.ti -1c
.RI "\fBReal\fP & \fBoperator()\fP (const unsigned int i)"
.br
.ti -1c
.RI "const \fBReal\fP & \fBslice\fP (const unsigned int i) const"
.br
.ti -1c
.RI "\fBReal\fP & \fBslice\fP (const unsigned int i)"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBoperator+\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator+=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBadd_scaled\fP (const \fBTypeVector\fP< T2 > &, const \fBReal\fP)"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBoperator-\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< \fBReal\fP > \fBoperator-\fP () const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator-=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBsubtract\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBsubtract_scaled\fP (const \fBTypeVector\fP< T2 > &, const \fBReal\fP)"
.br
.ti -1c
.RI "\fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar) const"
.br
.ti -1c
.RI "\fBCompareTypes\fP< \fBReal\fP, T2 >::supertype \fBoperator*\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator*=\fP (const \fBReal\fP)"
.br
.ti -1c
.RI "\fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, Scalar >
.br
::supertype > >::type \fBoperator/\fP (const Scalar) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator/=\fP (const \fBReal\fP)"
.br
.ti -1c
.RI "\fBCompareTypes\fP< \fBReal\fP, T2 >::supertype \fBcontract\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBcross\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< \fBReal\fP > \fBunit\fP () const"
.br
.ti -1c
.RI "\fBReal\fP \fBsize\fP () const"
.br
.ti -1c
.RI "\fBReal\fP \fBsize_sq\fP () const"
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "bool \fBrelative_fuzzy_equals\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const"
.br
.ti -1c
.RI "bool \fBabsolute_fuzzy_equals\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const"
.br
.ti -1c
.RI "void \fBwrite_unformatted\fP (std::ostream &\fBout\fP, const bool newline=true) const"
.br
.ti -1c
.RI "void \fBclear_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBset_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBclear_dofs\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_dofs\fP (const unsigned int sys_num=\fBlibMesh::invalid_uint\fP)"
.br
.ti -1c
.RI "void \fBinvalidate_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_processor_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_dofs\fP (const unsigned int s, const unsigned int var=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBid\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP & \fBset_id\fP ()"
.br
.ti -1c
.RI "void \fBset_id\fP (const \fBdof_id_type\fP dofid)"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBunique_id\fP () const "
.br
.ti -1c
.RI "\fBunique_id_type\fP & \fBset_unique_id\fP ()"
.br
.ti -1c
.RI "bool \fBvalid_id\fP () const "
.br
.ti -1c
.RI "bool \fBvalid_unique_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP & \fBprocessor_id\fP ()"
.br
.ti -1c
.RI "void \fBprocessor_id\fP (const \fBprocessor_id_type\fP pid)"
.br
.ti -1c
.RI "bool \fBvalid_processor_id\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_systems\fP () const "
.br
.ti -1c
.RI "void \fBset_n_systems\fP (const unsigned int s)"
.br
.ti -1c
.RI "void \fBadd_system\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_var_groups\fP (const unsigned int s) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s) const "
.br
.ti -1c
.RI "void \fBset_n_vars_per_group\fP (const unsigned int s, const std::vector< unsigned int > &nvpg)"
.br
.ti -1c
.RI "unsigned int \fBn_comp\fP (const unsigned int s, const unsigned int var) const "
.br
.ti -1c
.RI "unsigned int \fBn_comp_group\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "void \fBset_n_comp\fP (const unsigned int s, const unsigned int var, const unsigned int ncomp)"
.br
.ti -1c
.RI "void \fBset_n_comp_group\fP (const unsigned int s, const unsigned int vg, const unsigned int ncomp)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBdof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp) const "
.br
.ti -1c
.RI "void \fBset_dof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp, const \fBdof_id_type\fP dn)"
.br
.ti -1c
.RI "bool \fBhas_dofs\fP (const unsigned int s=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "void \fBset_vg_dof_base\fP (const unsigned int s, const unsigned int vg, const \fBdof_id_type\fP db)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBvg_dof_base\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBpacked_indexing_size\fP () const "
.br
.ti -1c
.RI "void \fBunpack_indexing\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.ti -1c
.RI "void \fBpack_indexing\fP (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > > target) const "
.br
.ti -1c
.RI "void \fBdebug_buffer\fP () const "
.br
.ti -1c
.RI "void \fBset_buffer\fP (const std::vector< \fBdof_id_type\fP > &buf)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNode\fP > \fBbuild\fP (const \fBNode\fP &n)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNode\fP > \fBbuild\fP (const \fBPoint\fP &p, const \fBdof_id_type\fP \fBid\fP)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNode\fP > \fBbuild\fP (const \fBReal\fP \fBx\fP, const \fBReal\fP y, const \fBReal\fP z, const \fBdof_id_type\fP \fBid\fP)"
.br
.ti -1c
.RI "static unsigned int \fBunpackable_indexing_size\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBDofObject\fP * \fBold_dof_object\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const \fBdof_id_type\fP \fBinvalid_id\fP = static_cast<\fBdof_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBunique_id_type\fP \fBinvalid_unique_id\fP = static_cast<\fBunique_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBprocessor_id_type\fP \fBinvalid_processor_id\fP = static_cast<\fBprocessor_id_type\fP>(-1)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBReal\fP \fB_coords\fP [LIBMESH_DIM]"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef unsigned char \fBvalence_idx_t\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBvalence_idx_t\fP \fB_valence\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBMeshRefinement\fP"
.br
.ti -1c
.RI "class \fBElem\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A \fC\fBNode\fP\fP is like a \fC\fBPoint\fP\fP, but with more information\&. A \fC\fBNode\fP\fP is located in space and is associated with some \fC\fP(x,y,z) coordinates\&. Additionally, a \fC\fBNode\fP\fP may be enumerated with a global \fCid\fP\&. Finally, a \fC\fBNode\fP\fP may have an arbitrary number of degrees of freedom associated with it\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk 
.RE
.PP
\fBDate:\fP
.RS 4
2003 
.RE
.PP

.PP
Definition at line 54 of file node\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef unsigned char \fBlibMesh::Node::valence_idx_t\fP\fC [private]\fP"
Type used to store node valence\&. 
.PP
Definition at line 254 of file node\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Node::Node (const \fBReal\fPx = \fC0\fP, const \fBReal\fPy = \fC0\fP, const \fBReal\fPz = \fC0\fP, const \fBdof_id_type\fPid = \fC\fBinvalid_id\fP\fP)\fC [explicit]\fP"
Constructor\&. By default sets all entries to 0\&. Gives the point 0 in \fCLIBMESH_DIM\fP dimensions with an \fCid\fP of \fC\fBNode::invalid_id\fP\fP 
.PP
Referenced by build()\&.
.SS "libMesh::Node::Node (const \fBNode\fP &n)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 298 of file node\&.h\&.
.PP
.nf
298                          :
299   Point(n),
300   DofObject(n),
301   ReferenceCountedObject<Node>()
302 #ifdef LIBMESH_ENABLE_NODE_VALENCE
303   ,
304   _valence(n\&._valence)
305 #endif
306 {
307 }
308 
309 
310 
311 inline
312 Node::Node (const Point& p,
313             const dof_id_type dofid) :
314   Point(p)
315 {
316   // optionally assign the id\&.  We have
317   // to do it like this otherwise
318   // Node n = Point p would erase
319   // the id!
320   if (dofid != invalid_id)
321     this->set_id() = dofid;
322 }
.fi
.SS "libMesh::Node::Node (const \fBPoint\fP &p, const \fBdof_id_type\fPid = \fC\fBinvalid_id\fP\fP)\fC [explicit]\fP"
Copy-constructor from a \fC\fBPoint\fP\fP\&. Optionally assigned the \fCid\fP\&. 
.SS "libMesh::Node::~Node ()\fC [inline]\fP"
Destructor\&. 
.PP
Definition at line 327 of file node\&.h\&.
.PP
.nf
328 {
329 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::absolute_fuzzy_equals (const \fBTypeVector\fP< Real  > &rhs, Realtol = \fCTOLERANCE\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCtol\fP\&. 
.RE
.PP

.SS "bool libMesh::Node::active () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the node is active\&. An active node is defined as one for which \fC\fBid()\fP\fP is not \fC\fBNode::invalid_id\fP\fP\&. Inactive nodes are nodes that are in the mesh but are not connected to any elements\&. 
.RE
.PP

.PP
Definition at line 382 of file node\&.h\&.
.PP
References libMesh::DofObject::invalid_id\&.
.PP
.nf
383 {
384   return (this->id() != Node::invalid_id);
385 }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::add (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Add to this vector without creating a temporary\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::add_scaled (const \fBTypeVector\fP< T2 > &, const Real)\fC [inherited]\fP"
Add a scaled value to this vector without creating a temporary\&. 
.SS "void libMesh::DofObject::add_system ()\fC [inherited]\fP"
Adds an additional system to the \fC\fBDofObject\fP\fP 
.PP
Definition at line 187 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), and libMesh::DofObject::set_n_systems()\&.
.PP
.nf
188 {
189   // quick return?
190   if (this->n_systems() == 0)
191     {
192       this->set_n_systems(1);
193       return;
194     }
195 
196   DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
197 
198   std::advance(it, this->n_systems());
199 
200   // this inserts the current vector size at the position for the new system - creating the
201   // entry we need for the new system indicating there are 0 variables\&.
202   _idx_buf\&.insert(it, _idx_buf\&.size());
203 
204   // cache this value before we screw it up!
205   const unsigned int ns_orig = this->n_systems();
206 
207   // incriment the number of systems and the offsets for each of
208   // the systems including the new one we just added\&.
209   for (unsigned int i=0; i<ns_orig+1; i++)
210     _idx_buf[i]++;
211 
212   libmesh_assert_equal_to (this->n_systems(), (ns_orig+1));
213   libmesh_assert_equal_to (this->n_vars(ns_orig), 0);
214   libmesh_assert_equal_to (this->n_var_groups(ns_orig), 0);
215 }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::assign (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Assign to a vector without creating a temporary\&. 
.SS "\fBAutoPtr\fP< \fBNode\fP > libMesh::Node::build (const \fBNode\fP &n)\fC [inline]\fP, \fC [static]\fP"
Builds a \fC\fBNode\fP\fP and returns an \fCAutoPtr<Node>\fP to the newly-created object\&. The \fCid\fP is copied from \fCn\&.id()\fP 
.PP
Definition at line 350 of file node\&.h\&.
.PP
References Node()\&.
.PP
Referenced by libMesh::SerialMesh::add_point(), and libMesh::ParallelMesh::add_point()\&.
.PP
.nf
351 {
352   AutoPtr<Node> ap(new Node(n));
353   return ap;
354 }
.fi
.SS "\fBAutoPtr\fP< \fBNode\fP > libMesh::Node::build (const \fBPoint\fP &p, const \fBdof_id_type\fPid)\fC [inline]\fP, \fC [static]\fP"
Builds a \fC\fBNode\fP\fP from \fC\fBPoint\fP\fP p and returns an \fCAutoPtr<Node>\fP to the newly-created object\&. Optionally assignes the \fCid\fP\&. 
.PP
Definition at line 359 of file node\&.h\&.
.PP
References Node()\&.
.PP
.nf
361 {
362 
363   AutoPtr<Node> ap(new Node(p,id));
364   return ap;
365 }
.fi
.SS "\fBAutoPtr\fP< \fBNode\fP > libMesh::Node::build (const \fBReal\fPx, const \fBReal\fPy, const \fBReal\fPz, const \fBdof_id_type\fPid)\fC [inline]\fP, \fC [static]\fP"
Builds a \fC\fBNode\fP\fP from specified points and returns an \fCAutoPtr<Node>\fP to the newly-created object\&. Optionally assigned the \fCid\fP\&. 
.PP
Definition at line 370 of file node\&.h\&.
.PP
References Node()\&.
.PP
.nf
374 {
375   AutoPtr<Node> ap(new Node(x,y,z,id));
376   return ap;
377 }
.fi
.SS "void libMesh::DofObject::clear_dofs ()\fC [inline]\fP, \fC [inherited]\fP"
Clear the \fC\fBDofMap\fP\fP data structures and return to a pristine state\&. 
.PP
Definition at line 577 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::libmesh_assert(), and libMesh::DofObject::n_systems()\&.
.PP
Referenced by libMesh::DofObject::set_n_systems(), and libMesh::DofObject::~DofObject()\&.
.PP
.nf
578 {
579   // vector swap trick to force deallocation
580   index_buffer_t()\&.swap(_idx_buf);
581 
582   libmesh_assert_equal_to (this->n_systems(), 0);
583   libmesh_assert (_idx_buf\&.empty());
584 }
.fi
.SS "void libMesh::DofObject::clear_old_dof_object ()\fC [inherited]\fP"
Sets the \fCold_dof_object\fP to NULL 
.PP
Definition at line 134 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::old_dof_object\&.
.PP
Referenced by libMesh::DofObject::operator=(), libMesh::DofObject::set_old_dof_object(), libMesh::DofObject::unpack_indexing(), and libMesh::DofObject::~DofObject()\&.
.PP
.nf
135 {
136   delete this->old_dof_object;
137   this->old_dof_object = NULL;
138 }
.fi
.SS "\fBCompareTypes\fP<\fBReal\fP , T2>::supertype \fBlibMesh::TypeVector\fP< \fBReal\fP  >::contract (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::cross (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Cross 2 vectors together, i\&.e\&. cross-product\&. 
.SS "void libMesh::DofObject::debug_buffer () const\fC [inherited]\fP"
Print our buffer for debugging\&. 
.PP
Definition at line 543 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, and libMesh::out\&.
.PP
.nf
544 {
545   libMesh::out << " [ ";
546   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
547     libMesh::out << _idx_buf[i] << " ";
548   libMesh::out << "]\n";
549 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 789 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::start_idx(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::DofMap::distribute_dofs(), libMesh::DofObject::DofObject(), get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::HPCoarsenTest::select_refinement(), libMesh::DofObject::set_dof_number(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
792 {
793   libmesh_assert_less (s,    this->n_systems());
794   libmesh_assert_less (var,  this->n_vars(s));
795   libmesh_assert_less (comp, this->n_comp(s,var));
796 
797   const unsigned int
798     vg            = this->var_to_vg(s,var),
799     start_idx_sys = this->start_idx(s);
800 
801   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
802 
803   const dof_id_type
804     base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
805 
806   // if the first component is invalid, they
807   // are all invalid
808   if (base_idx == invalid_id)
809     return invalid_id;
810 
811   // otherwise the index is the first component
812   // index augemented by the component number
813   else
814     {
815       const unsigned int
816         ncg = this->n_comp_group(s,vg),
817         vig = this->system_var_to_vg_var(s,vg,var);
818 
819       // std::cout << "base_idx, var, vg, vig, ncg, comp="
820       // << base_idx << " "
821       // << var << " "
822       // << vg << " "
823       // << vig << " "
824       // << ncg << " "
825       // << comp << '\n';
826 
827       return libmesh_cast_int<dof_id_type>(base_idx + vig*ncg + comp);
828     }
829 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::Node::get_info () const"
Prints relevant information about the node to a string\&. 
.PP
Definition at line 53 of file node\&.C\&.
.PP
References libMesh::DofObject::dof_number(), libMesh::DofObject::id(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::processor_id(), and libMesh::DofObject::valid_id()\&.
.PP
Referenced by print_info()\&.
.PP
.nf
54 {
55   std::ostringstream oss;
56 
57   oss << "  Node id()=";
58 
59   if (this->valid_id())
60     oss << this->id();
61   else
62     oss << "invalid";
63 
64   oss << ", processor_id()=" << this->processor_id() <<
65     ", Point=" << *static_cast<const Point*>(this) << '\n';
66 
67   oss << "    DoFs=";
68   for (unsigned int s=0; s != this->n_systems(); ++s)
69     for (unsigned int v=0; v != this->n_vars(s); ++v)
70       for (unsigned int c=0; c != this->n_comp(s,v); ++c)
71         oss << '(' << s << '/' << v << '/' << this->dof_number(s,v,c) << ") ";
72 
73   return oss\&.str();
74 }
.fi
.SS "bool libMesh::DofObject::has_dofs (const unsigned ints = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if any system has variables which have been assigned, false otherwise 
.RE
.PP

.PP
Definition at line 834 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::DofObject::n_systems(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::reinit(), and libMesh::Parallel::unpack()\&.
.PP
.nf
835 {
836   if (sys == libMesh::invalid_uint)
837     {
838       for (unsigned int s=0; s<this->n_systems(); s++)
839         if (this->n_vars(s))
840           return true;
841     }
842 
843   else
844     {
845       libmesh_assert_less (sys, this->n_systems());
846 
847       if (this->n_vars(sys))
848         return true;
849     }
850 
851   return false;
852 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 611 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id, libMesh::libmesh_assert(), and libMesh::DofObject::valid_id()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::MeshData::assign(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEMap::compute_single_point_map(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshData::elem_to_foreign_id(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshTools::Modification::flatten(), libMesh::for(), get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::EquationSystems::get_solution(), libMesh::LaplaceMeshSmoother::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::TreeNode< N >::insert(), libMesh::SerialMesh::insert_elem(), libMesh::ParallelMesh::insert_elem(), libMesh::SerialMesh::insert_node(), libMesh::FE< Dim, T >::inverse_map(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::Tri3Subdivision::local_node_number(), libMesh::Elem::node(), libMesh::MeshData::node_to_foreign_id(), libMesh::VTKIO::nodes_to_vtk(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::BoundaryInfo::operator=(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::ErrorVector::plot_error(), libMesh::ParallelMesh::query_elem(), libMesh::ParallelMesh::query_node_ptr(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::AbaqusIO::read_elements(), libMesh::ParallelMesh::renumber_elem(), libMesh::ParallelMesh::renumber_node(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::DofMap::scatter_constraints(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::topological_neighbor(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::CheckpointIO::write_connectivity(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), libMesh::LegacyXdrIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::CheckpointIO::write_nodes(), and libMesh::XdrIO::write_serialized_connectivity()\&.
.PP
.nf
612 {
613   libmesh_assert (this->valid_id());
614   return _id;
615 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::DofObject::invalidate ()\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all the indices for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 567 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::invalidate_id(), and libMesh::DofObject::invalidate_processor_id()\&.
.PP
Referenced by libMesh::DofObject::DofObject()\&.
.PP
.nf
568 {
569   this->invalidate_dofs ();
570   this->invalidate_id ();
571   this->invalidate_processor_id ();
572 }
.fi
.SS "void libMesh::DofObject::invalidate_dofs (const unsigned intsys_num = \fC\fBlibMesh::invalid_uint\fP\fP)\fC [inline]\fP, \fC [inherited]\fP"
Sets all degree of freedom numbers to \fCinvalid_id\fP 
.PP
Definition at line 531 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::set_vg_dof_base()\&.
.PP
Referenced by libMesh::DofObject::invalidate()\&.
.PP
.nf
532 {
533   // If the user does not specify the system number\&.\&.\&.
534   if (sys_num >= this->n_systems())
535     {
536       for (unsigned int s=0; s<this->n_systems(); s++)
537         for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
538           if (this->n_comp_group(s,vg))
539             this->set_vg_dof_base(s,vg,invalid_id);
540     }
541   // \&.\&.\&.otherwise invalidate the dofs for all systems
542   else
543     for (unsigned int vg=0; vg<this->n_var_groups(sys_num); vg++)
544       if (this->n_comp_group(sys_num,vg))
545         this->set_vg_dof_base(sys_num,vg,invalid_id);
546 }
.fi
.SS "void libMesh::DofObject::invalidate_id ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the id to \fCinvalid_id\fP 
.PP
Definition at line 551 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_id, and libMesh::DofObject::set_id()\&.
.PP
Referenced by libMesh::DofObject::invalidate()\&.
.PP
.nf
552 {
553   this->set_id (invalid_id);
554 }
.fi
.SS "void libMesh::DofObject::invalidate_processor_id ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the processor id to \fCinvalid_processor_id\fP 
.PP
Definition at line 559 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::DofObject::processor_id()\&.
.PP
Referenced by libMesh::MeshTools::correct_node_proc_ids(), libMesh::DofObject::invalidate(), libMesh::Partitioner::set_node_processor_ids(), and libMesh::Partitioner::set_parent_processor_ids()\&.
.PP
.nf
560 {
561   this->processor_id (invalid_processor_id);
562 }
.fi
.SS "unsigned int libMesh::DofObject::n_comp (const unsigned ints, const unsigned intvar) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for variable \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 759 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), and libMesh::DofObject::var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), libMesh::DofObject::n_dofs(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
761 {
762   libmesh_assert_less (s,   this->n_systems());
763   libmesh_assert_less (var, this->n_vars(s));
764 
765   return this->n_comp_group(s,this->var_to_vg(s,var));
766 }
.fi
.SS "unsigned int libMesh::DofObject::n_comp_group (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 772 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::dof_number(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::n_comp(), libMesh::DofMap::reinit(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
774 {
775   libmesh_assert_less (s,  this->n_systems());
776   libmesh_assert_less (vg, this->n_var_groups(s));
777 
778   const unsigned int
779     start_idx_sys = this->start_idx(s);
780 
781   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
782 
783   return (_idx_buf[start_idx_sys + 2*vg] % ncv_magic);
784 }
.fi
.SS "unsigned int libMesh::DofObject::n_dofs (const unsigned ints, const unsigned intvar = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom associated with system \fCs\fP for this object\&. Optionally only counts degrees of freedom for variable number \fCvar\fP 
.RE
.PP

.PP
Definition at line 589 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::DofObject::n_comp(), libMesh::DofObject::n_systems(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector()\&.
.PP
.nf
591 {
592   libmesh_assert_less (s, this->n_systems());
593 
594   unsigned int num = 0;
595 
596   // Count all variables
597   if (var == libMesh::invalid_uint)
598     for (unsigned int v=0; v<this->n_vars(s); v++)
599       num += this->n_comp(s,v);
600 
601   // Only count specified variable
602   else
603     num = this->n_comp(s,var);
604 
605   return num;
606 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "unsigned int libMesh::DofObject::n_systems () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of systems associated with this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 705 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofObject::add_system(), libMesh::DofObject::clear_dofs(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), libMesh::DofObject::end_idx(), get_info(), libMesh::Elem::get_info(), libMesh::DofObject::has_dofs(), libMesh::DofObject::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_dofs(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::Elem::refine(), libMesh::EquationSystems::reinit(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofObject::set_vg_dof_base(), libMesh::DofObject::start_idx(), and libMesh::DofObject::vg_dof_base()\&.
.PP
.nf
706 {
707   return _idx_buf\&.empty() ?
708     0 : libmesh_cast_int<unsigned int>(_idx_buf[0]);
709 }
.fi
.SS "unsigned int libMesh::DofObject::n_var_groups (const unsigned ints) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariableGroup\fP\fP variable groups associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 714 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::end_idx(), libMesh::DofObject::n_systems(), and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofObject::add_system(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::DofObject(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_vars(), libMesh::DofObject::operator=(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::DofObject::set_vg_dof_base(), libMesh::DofObject::var_to_vg(), and libMesh::DofObject::vg_dof_base()\&.
.PP
.nf
715 {
716   libmesh_assert_less (s, this->n_systems());
717 
718   return (this->end_idx(s) - this->start_idx(s)) / 2;
719 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with \fC\fBVariableGroup\fP\fP \fCvg\fP in system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 724 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofObject::add_system(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::DofMap::distribute_dofs(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), get_info(), libMesh::Elem::get_info(), libMesh::DofObject::has_dofs(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_dofs(), libMesh::DofObject::n_vars(), libMesh::DofObject::operator=(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
726 {
727   libmesh_assert_less (s,  this->n_systems());
728   libmesh_assert_less (vg, this->n_var_groups(s));
729 
730   const unsigned int start_idx_sys = this->start_idx(s);
731 
732   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
733 
734   return (libmesh_cast_int<unsigned int>
735           (_idx_buf[start_idx_sys + 2*vg]) / ncv_magic);
736 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 741 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::n_vars()\&.
.PP
.nf
742 {
743   libmesh_assert_less (s, this->n_systems());
744 
745   const unsigned int nvg = this->n_var_groups(s);
746 
747   unsigned int val=0;
748 
749   for (unsigned int vg=0; vg<nvg; vg++)
750     val += this->n_vars(s,vg);
751 
752   return val;
753 }
.fi
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator!= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors do not occupy approximately the same physical location in space\&. 
.RE
.PP

.SS "const \fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator() (const unsigned inti) const\fC [inherited]\fP"
Return the $ i^{th} $ element of the vector\&. 
.SS "\fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator() (const unsigned inti)\fC [inherited]\fP"
Return a writeable reference to the $ i^{th} $ element of the vector\&. 
.SS "\fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , Scalar>::supertype> >::type \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator* (const Scalar) const\fC [inherited]\fP"
Multiply a vector by a number, i\&.e\&. scale\&. 
.SS "\fBCompareTypes\fP<\fBReal\fP , T2>::supertype \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator* (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator*= (const Real)\fC [inherited]\fP"
Multiply this vector by a number, i\&.e\&. scale\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator+ (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Add two vectors\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator+= (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Add to this vector\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator- (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Subtract two vectors\&. 
.SS "\fBTypeVector\fP<\fBReal\fP > \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator- () const\fC [inherited]\fP"
Return the opposite of a vector 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator-= (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Subtract from this vector\&. 
.SS "\fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , Scalar>::supertype> >::type \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator/ (const Scalar) const\fC [inherited]\fP"
Divide a vector by a number, i\&.e\&. scale\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator/= (const Real)\fC [inherited]\fP"
Divide this vector by a number, i\&.e\&. scale\&. 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator< (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator<= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.SS "\fBNode\fP & libMesh::Node::operator= (const \fBPoint\fP &p)\fC [inline]\fP"
Assign to a node from a point 
.PP
Definition at line 334 of file node\&.h\&.
.PP
.nf
335 {
336   (*this)(0) = p(0);
337 #if LIBMESH_DIM > 1
338   (*this)(1) = p(1);
339 #endif
340 #if LIBMESH_DIM > 2
341   (*this)(2) = p(2);
342 #endif
343 
344   return *this;
345 }
.fi
.SS "bool libMesh::Node::operator== (const \fBNode\fP &rhs) const"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this node equals rhs, false otherwise\&. 
.RE
.PP

.PP
Definition at line 37 of file node\&.C\&.
.PP
References libMesh::TypeVector< Real >::operator==()\&.
.PP
.nf
38 {
39   // Explicitly calling the operator== defined in Point
40   return this->Point::operator==(rhs);
41 }
.fi
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator== (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCTOLERANCE\fP\&. 
.RE
.PP

.PP
Referenced by operator==()\&.
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator> (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator>= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.SS "void libMesh::DofObject::pack_indexing (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > >target) const\fC [inherited]\fP"
A method for creating packed data from our index buffer - basically a copy with prepended size with our current implementation\&. 
.PP
Definition at line 525 of file dof_object\&.C\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), and libMesh::Elem::PackedElem::pack()\&.
.PP
.nf
526 {
527 #ifdef LIBMESH_ENABLE_AMR
528   // We might need to pack old_dof_object too
529   *target++ = (old_dof_object == NULL) ? 0 : 1;
530 #endif
531 
532   *target++ = _idx_buf\&.size();
533   std::copy(_idx_buf\&.begin(), _idx_buf\&.end(), target);
534 
535 #ifdef LIBMESH_ENABLE_AMR
536   if (old_dof_object)
537     old_dof_object->pack_indexing(target);
538 #endif
539 }
.fi
.SS "unsigned int libMesh::DofObject::packed_indexing_size () const\fC [inherited]\fP"
If we pack our indices into an buffer for communications, how many ints do we need? 
.PP
Definition at line 448 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::old_dof_object, and libMesh::DofObject::packed_indexing_size()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), libMesh::DofObject::packed_indexing_size(), packed_size(), libMesh::Elem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
449 {
450   return
451 #ifdef LIBMESH_ENABLE_AMR
452     ((old_dof_object == NULL) ? 0 : old_dof_object->packed_indexing_size()) + 2 +
453 #else
454     1 +
455 #endif
456     _idx_buf\&.size();
457 }
.fi
.SS "unsigned int libMesh::Node::packed_size () const\fC [inline]\fP"

.PP
Definition at line 209 of file node\&.h\&.
.PP
References libMesh::Node::PackedNode::header_size, libMesh::DofObject::packed_indexing_size(), and libMesh::Real\&.
.PP
Referenced by libMesh::Node::PackedNode::pack()\&.
.PP
.nf
210   {
211     // use "(a+b-1)/b" trick to get a/b to round up
212     static const unsigned int idtypes_per_Real =
213       (sizeof(Real) + sizeof(largest_id_type) - 1) / sizeof(largest_id_type);
214 
215     return PackedNode::header_size + LIBMESH_DIM*idtypes_per_Real +
216       this->packed_indexing_size();
217   }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Formatted print, by default to \fC\fBlibMesh::out\fP\fP\&. 
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::Node::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const"
Prints relevant information about the node 
.PP
Definition at line 45 of file node\&.C\&.
.PP
References get_info()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
46 {
47   os << this->get_info()
48      << std::endl;
49 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::DofObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to\&.
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 673 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::CentroidPartitioner::_do_partition(), libMesh::ParallelMesh::add_elem(), libMesh::Patch::add_local_face_neighbors(), libMesh::Patch::add_local_point_neighbors(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::SerialMesh::add_point(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::Patch::build_around_element(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::Elem::Elem(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::Modification::flatten(), get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::DofObject::invalidate_processor_id(), libMesh::Elem::is_semilocal(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshFunction::operator()(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::DofObject::processor_id(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshData::read_xdr(), libMesh::Elem::refine(), libMesh::DofMap::scatter_constraints(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::CheckpointIO::write_connectivity(), libMesh::GmshIO::write_mesh(), libMesh::CheckpointIO::write_nodes(), libMesh::XdrIO::write_serialized_connectivity(), and libMesh::Nemesis_IO_Helper::write_sidesets()\&.
.PP
.nf
674 {
675   return _processor_id;
676 }
.fi
.SS "\fBprocessor_id_type\fP & libMesh::DofObject::processor_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 681 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id\&.
.PP
.nf
682 {
683   return _processor_id;
684 }
.fi
.SS "void libMesh::DofObject::processor_id (const \fBprocessor_id_type\fPpid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the \fCprocessor_id\fP for this \fC\fBDofObject\fP\fP\&. 
.PP
Definition at line 689 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::processor_id()\&.
.PP
.nf
690 {
691   this->processor_id() = pid;
692 }
.fi
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::relative_fuzzy_equals (const \fBTypeVector\fP< Real  > &rhs, Realtol = \fCTOLERANCE\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within a relative tolerance of \fCtol\fP\&. 
.RE
.PP

.SS "void libMesh::DofObject::set_buffer (const std::vector< \fBdof_id_type\fP > &buf)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 491 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf\&.
.PP
.nf
492   { _idx_buf = buf; }
.fi
.SS "void libMesh::DofObject::set_dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp, const \fBdof_id_type\fPdn)\fC [inherited]\fP"
Sets the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 405 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::dof_number(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::start_idx(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
409 {
410   libmesh_assert_less (s,    this->n_systems());
411   libmesh_assert_less (var,  this->n_vars(s));
412   libmesh_assert_less (comp, this->n_comp(s,var));
413 
414   const unsigned int
415     vg            = this->var_to_vg(s,var),
416 #ifndef NDEBUG
417     ncg           = this->n_comp_group(s,vg),
418 #endif
419     vig           = this->system_var_to_vg_var(s,vg,var),
420     start_idx_sys = this->start_idx(s);
421 
422   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
423 
424   dof_id_type &base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
425 
426   // We intend to change all dof numbers together or not at all
427   if (comp || vig)
428     libmesh_assert ((dn == invalid_id && base_idx == invalid_id) ||
429                     (dn == base_idx + vig*ncg + comp));
430 
431   // only explicitly store the base index for vig==0, comp==0
432   else
433     base_idx = dn;
434 
435   // #ifdef DEBUG
436   //   libMesh::out << " [ ";
437   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
438   //     libMesh::out << _idx_buf[i] << " ";
439   //   libMesh::out << "]\n";
440   // #endif
441 
442   libmesh_assert_equal_to (this->dof_number(s, var, comp), dn);
443 }
.fi
.SS "\fBdof_id_type\fP & libMesh::DofObject::set_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 620 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::UNVIO::element_in(), libMesh::MeshTools::Modification::flatten(), libMesh::DofObject::invalidate_id(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::RemoteElem::RemoteElem(), libMesh::SerialMesh::renumber_elem(), libMesh::ParallelMesh::renumber_elem(), libMesh::SerialMesh::renumber_node(), libMesh::ParallelMesh::renumber_node(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::DofObject::set_id(), libMesh::SerialMesh::stitching_helper(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
621 {
622   return _id;
623 }
.fi
.SS "void libMesh::DofObject::set_id (const \fBdof_id_type\fPdofid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the \fCid\fP for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 161 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::set_id()\&.
.PP
.nf
162   { this->set_id() = dofid; }
.fi
.SS "void libMesh::DofObject::set_n_comp (const unsigned ints, const unsigned intvar, const unsigned intncomp)\fC [inherited]\fP"
Sets the number of components for \fC\fBVariable\fP\fP \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 338 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::set_n_comp_group(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
341 {
342   libmesh_assert_less (s,   this->n_systems());
343   libmesh_assert_less (var, this->n_vars(s));
344 
345   this->set_n_comp_group(s, this->var_to_vg(s,var), ncomp);
346 }
.fi
.SS "void libMesh::DofObject::set_n_comp_group (const unsigned ints, const unsigned intvg, const unsigned intncomp)\fC [inherited]\fP"
Sets the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 350 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::err, libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::reinit(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
353 {
354   libmesh_assert_less (s,  this->n_systems());
355   libmesh_assert_less (vg, this->n_var_groups(s));
356 
357   // Check for trivial return
358   if (ncomp == this->n_comp_group(s,vg)) return;
359 
360 #ifndef NDEBUG
361   if (ncomp >= ncv_magic)
362     {
363       const index_t ncvm = ncv_magic;
364       libMesh::err << "ERROR: ncomp must be less than DofObject::ncv_magic!\n"
365                    << "ncomp = " << ncomp << ", ncv_magic = " << ncvm
366                    << "\nrecompile and try again!\n";
367       libmesh_error();
368     }
369 #endif
370 
371   const unsigned int
372     start_idx_sys = this->start_idx(s),
373     n_vars_group  = this->n_vars(s,vg),
374     base_offset   = start_idx_sys + 2*vg;
375 
376   libmesh_assert_less ((base_offset + 1), _idx_buf\&.size());
377 
378   // if (ncomp)
379   //   libMesh::out << "s,vg,ncomp="
380   //       << s  << ","
381   //       << vg << ","
382   //       << ncomp << '\n';
383 
384   // set the number of components, maintaining the number
385   // of variables in the group
386   _idx_buf[base_offset] = ncv_magic*n_vars_group + ncomp;
387 
388   // We use (invalid_id - 1) to signify no
389   // components for this object
390   _idx_buf[base_offset + 1] = (ncomp == 0) ? invalid_id - 1 : invalid_id;
391 
392   // this->debug_buffer();
393   // libMesh::out << "s,vg = " << s << "," << vg << '\n'
394   //     << "base_offset=" << base_offset << '\n'
395   //     << "this->n_comp(s,vg)=" << this->n_comp(s,vg) << '\n'
396   //     << "this->n_comp_group(s,vg)=" << this->n_comp_group(s,vg) << '\n'
397   //     << "this->n_vars(s,vg)=" << this->n_vars(s,vg) << '\n'
398   //     << "this->n_var_groups(s)=" << this->n_var_groups(s) << '\n';
399 
400   libmesh_assert_equal_to (ncomp, this->n_comp_group(s,vg));
401 }
.fi
.SS "void libMesh::DofObject::set_n_systems (const unsigned ints)\fC [inherited]\fP"
Sets the number of systems for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 157 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::clear_dofs(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::DofObject::add_system(), and libMesh::Elem::refine()\&.
.PP
.nf
158 {
159   // Check for trivial return
160   if (ns == this->n_systems())
161     return;
162 
163   // Clear any existing data\&.  This is safe to call
164   // even if we don't have any data\&.
165   this->clear_dofs();
166 
167   // Set the new number of systems
168   _idx_buf\&.resize(ns, ns);
169   _idx_buf[0] = ns;
170 
171 
172 #ifdef DEBUG
173 
174   // check that all systems now exist and that they have 0 size
175   libmesh_assert_equal_to (ns, this->n_systems());
176   for (unsigned int s=0; s<this->n_systems(); s++)
177     {
178       libmesh_assert_equal_to (this->n_vars(s),       0);
179       libmesh_assert_equal_to (this->n_var_groups(s), 0);
180     }
181 
182 #endif
183 }
.fi
.SS "void libMesh::DofObject::set_n_vars_per_group (const unsigned ints, const std::vector< unsigned int > &nvpg)\fC [inherited]\fP"
Sets number of variables in each group associated with system \fCs\fP for this \fC\fBDofObject\fP\fP\&. Implicit in this is salso setting the number of \fC\fBVariableGroup\fP\fP variable groups for the system\&. Has the effect of setting the number of components to 0 even when called even with (nvg == this->n_var_groups(s))\&. 
.PP
Definition at line 219 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, end, libMesh::DofObject::end_idx(), libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofObject::ncv_magic, libMesh::DofObject::set_n_comp_group(), and libMesh::DofObject::start_idx()\&.
.PP
.nf
221 {
222 
223   libmesh_assert_less (s, this->n_systems());
224 
225   // number of varaible groups for this system - inferred
226   const unsigned int nvg = libmesh_cast_int<unsigned int>(nvpg\&.size());
227 
228   // BSK - note that for compatibility with the previous implementation
229   // calling this method when (nvars == this->n_vars()) requires that
230   // we invalidate the DOF indices and set the number of components to 0\&.
231   // Note this was a bit of a suprise to me - there was no quick return in
232   // the old method, which caused removal and readdition of the DOF indices
233   // even in the case of (nvars == this->n_vars()), resulting in n_comp(s,v)
234   // implicitly becoming 0 regardless of any previous value\&.
235   // quick return?
236   if (nvg == this->n_var_groups(s))
237     {
238       for (unsigned int vg=0; vg<nvg; vg++)
239         {
240           this->set_n_comp_group(s,vg,0);
241           libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
242         }
243       return;
244     }
245 
246   // since there is ample opportunity to screw up other systems, let us
247   // cache their current sizes and later assert that they are unchanged\&.
248 #ifdef DEBUG
249   DofObject::index_buffer_t old_system_sizes;
250   old_system_sizes\&.reserve(this->n_systems());
251 
252   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
253     old_system_sizes\&.push_back(this->n_var_groups(s_ctr));
254 #endif
255 
256   // remove current indices if we have some
257   if (this->n_var_groups(s) != 0)
258     {
259       const unsigned int old_nvg_s = this->n_var_groups(s);
260 
261       DofObject::index_buffer_t::iterator
262         it  = _idx_buf\&.begin(),
263         end = _idx_buf\&.begin();
264 
265       std::advance(it,  this->start_idx(s));
266       std::advance(end, this->end_idx(s));
267       _idx_buf\&.erase(it,end);
268 
269       for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
270         _idx_buf[ctr] -= 2*old_nvg_s;
271     }
272 
273   // better not have any now!
274   libmesh_assert_equal_to (this->n_var_groups(s), 0);
275 
276   // had better not screwed up any of our sizes!
277 #ifdef DEBUG
278   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
279     if (s_ctr != s)
280       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
281 #endif
282 
283   // OK, if the user requested 0 that is what we have
284   if (nvg == 0)
285     return;
286 
287   {
288     // array to hold new indices
289     DofObject::index_buffer_t var_idxs(2*nvg);
290     for (unsigned int vg=0; vg<nvg; vg++)
291       {
292         var_idxs[2*vg    ] = ncv_magic*nvpg[vg] + 0;
293         var_idxs[2*vg + 1] = invalid_id - 1;
294       }
295 
296     DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
297     std::advance(it, this->end_idx(s));
298     _idx_buf\&.insert(it, var_idxs\&.begin(), var_idxs\&.end());
299 
300     for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
301       _idx_buf[ctr] += 2*nvg;
302 
303     // resize _idx_buf to fit so no memory is wasted\&.
304     DofObject::index_buffer_t(_idx_buf)\&.swap(_idx_buf);
305   }
306 
307   // that better had worked\&.  Assert stuff\&.
308   libmesh_assert_equal_to (nvg, this->n_var_groups(s));
309 
310 #ifdef DEBUG
311 
312   // libMesh::out << " [ ";
313   // for (unsigned int i=0; i<_idx_buf\&.size(); i++)
314   //   libMesh::out << _idx_buf[i] << " ";
315   // libMesh::out << "]\n";
316 
317   libmesh_assert_equal_to (this->n_var_groups(s), nvpg\&.size());
318 
319   for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
320     {
321       libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
322       libmesh_assert_equal_to (this->n_comp_group(s,vg), 0);
323     }
324 
325   for (unsigned int v=0; v<this->n_vars(s); v++)
326     libmesh_assert_equal_to (this->n_comp(s,v), 0);
327 
328   // again, all other system sizes shoudl be unchanged!
329   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
330     if (s_ctr != s)
331       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
332 
333 #endif
334 }
.fi
.SS "void libMesh::DofObject::set_old_dof_object ()\fC [inherited]\fP"
Sets the \fCold_dof_object\fP to a copy of \fCthis\fP 
.PP
Definition at line 142 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::clear_old_dof_object(), libMesh::DofObject::DofObject(), libMesh::libmesh_assert(), and libMesh::DofObject::old_dof_object\&.
.PP
Referenced by libMesh::DofMap::reinit()\&.
.PP
.nf
143 {
144   this->clear_old_dof_object();
145 
146   libmesh_assert (!this->old_dof_object);
147 
148   // Make a new DofObject, assign a copy of \p this\&.
149   // Make sure the copy ctor for DofObject works!!
150   this->old_dof_object = new DofObject(*this);
151 }
.fi
.SS "\fBunique_id_type\fP & libMesh::DofObject::set_unique_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 641 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::CheckpointIO::read_connectivity(), libMesh::CheckpointIO::read_nodes(), libMesh::XdrIO::read_serialized_connectivity(), and libMesh::Parallel::unpack()\&.
.PP
.nf
642 {
643 #ifdef LIBMESH_ENABLE_UNIQUE_ID
644   return _unique_id;
645 #else
646   libmesh_error();
647 #endif
648 }
.fi
.SS "void libMesh::Node::set_valence (unsigned intval)\fC [inline]\fP"
Sets the number of nodes connected with this node\&. 
.PP
Definition at line 392 of file node\&.h\&.
.PP
References _valence, and libMesh::err\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::prepare_subdivision_mesh()\&.
.PP
.nf
393 {
394 #ifndef NDEBUG
395   if (val != static_cast<valence_idx_t>(val))
396     {
397       libMesh::err << "ERROR: Node::valence_idx_t too small to hold val="
398                    << val
399                    << std::endl;
400       libmesh_error();
401     }
402 #endif // #ifndef NDEBUG
403 
404   _valence = val;
405 }
.fi
.SS "void libMesh::DofObject::set_vg_dof_base (const unsigned ints, const unsigned intvg, const \fBdof_id_type\fPdb)\fC [inline]\fP, \fC [inherited]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 881 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::start_idx(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::invalidate_dofs(), libMesh::DofMap::reinit(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
884 {
885   libmesh_assert_less (s,  this->n_systems());
886   libmesh_assert_less (vg, this->n_var_groups(s));
887 
888   const unsigned int
889     start_idx_sys = this->start_idx(s);
890 
891   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
892 
893   _idx_buf[start_idx_sys + 2*vg + 1] = db;
894 
895   libmesh_assert_equal_to (this->vg_dof_base(s,vg), db);
896 }
.fi
.SS "\fBReal\fP \fBlibMesh::TypeVector\fP< \fBReal\fP  >::size () const\fC [inherited]\fP"
Returns the magnitude of the vector, i\&.e\&. the square-root of the sum of the elements squared\&. 
.SS "\fBReal\fP \fBlibMesh::TypeVector\fP< \fBReal\fP  >::size_sq () const\fC [inherited]\fP"
Returns the magnitude of the vector squared, i\&.e\&. the sum of the element magnitudes squared\&. 
.SS "const \fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::slice (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 123 of file type_vector\&.h\&.
.PP
.nf
123 { return (*this)(i); }
.fi
.SS "\fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::slice (const unsigned inti)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 130 of file type_vector\&.h\&.
.PP
.nf
130 { return (*this)(i); }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::subtract (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Subtract from this vector without creating a temporary\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::subtract_scaled (const \fBTypeVector\fP< T2 > &, const Real)\fC [inherited]\fP"
Subtract a scaled value from this vector without creating a temporary\&. 
.SS "\fBunique_id_type\fP libMesh::DofObject::unique_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 628 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id, libMesh::DofObject::invalid_unique_id, libMesh::libmesh_assert(), and libMesh::DofObject::valid_unique_id()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::XdrIO::pack_element(), libMesh::CheckpointIO::write_connectivity(), and libMesh::CheckpointIO::write_nodes()\&.
.PP
.nf
629 {
630 #ifdef LIBMESH_ENABLE_UNIQUE_ID
631   libmesh_assert (this->valid_unique_id());
632   return _unique_id;
633 #else
634   return invalid_unique_id;
635 #endif
636 }
.fi
.SS "\fBTypeVector\fP<\fBReal\fP > \fBlibMesh::TypeVector\fP< \fBReal\fP  >::unit () const\fC [inherited]\fP"
Think of a vector as a \fCdim\fP dimensional vector\&. This will return a unit vector aligned in that direction\&. 
.SS "void libMesh::DofObject::unpack_indexing (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)\fC [inherited]\fP"
A method for creating our index buffer from packed data - basically with our current implementation we investigate the size term and then copy\&. 
.PP
Definition at line 485 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::clear_old_dof_object(), libMesh::DofObject::DofObject(), libMesh::libmesh_assert(), libMesh::DofObject::old_dof_object, and libMesh::DofObject::unpack_indexing()\&.
.PP
Referenced by libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::DofObject::unpack_indexing()\&.
.PP
.nf
486 {
487   _idx_buf\&.clear();
488 
489 #ifdef LIBMESH_ENABLE_AMR
490   this->clear_old_dof_object();
491   const int has_old_dof_object = *begin++;
492   libmesh_assert(has_old_dof_object == 1 ||
493                  has_old_dof_object == 0);
494 #endif
495 
496   const int size = *begin++;
497   _idx_buf\&.reserve(size);
498   std::copy(begin, begin+size, back_inserter(_idx_buf));
499 
500   // Check as best we can for internal consistency now
501   libmesh_assert(_idx_buf\&.empty() ||
502                  (_idx_buf[0] <= _idx_buf\&.size()));
503 #ifdef DEBUG
504   if (!_idx_buf\&.empty())
505     for (unsigned int i=1; i < _idx_buf[0]; ++i)
506       {
507         libmesh_assert_greater_equal (_idx_buf[i], _idx_buf[i-1]);
508         libmesh_assert_equal_to ((_idx_buf[i] - _idx_buf[i-1])%2, 0);
509         libmesh_assert_less_equal (_idx_buf[i], _idx_buf\&.size());
510       }
511 #endif
512 
513 #ifdef LIBMESH_ENABLE_AMR
514   if (has_old_dof_object)
515     {
516       this->old_dof_object = new DofObject();
517       this->old_dof_object->unpack_indexing(begin+size);
518     }
519 #endif
520 }
.fi
.SS "unsigned int libMesh::DofObject::unpackable_indexing_size (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)\fC [static]\fP, \fC [inherited]\fP"
If we have indices packed into an buffer for communications, how much of that buffer applies to this dof object? 
.PP
Definition at line 463 of file dof_object\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packed_size(), libMesh::Elem::PackedElem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
464 {
465 #ifdef LIBMESH_ENABLE_AMR
466   const int has_old_dof_object = *begin++;
467 
468   // Either we have an old_dof_object or we don't
469   libmesh_assert(has_old_dof_object == 1 || has_old_dof_object == 0);
470   static const int dof_header_size = 2;
471 #else
472   static const bool has_old_dof_object = false;
473   static const int dof_header_size = 1;
474 #endif
475 
476   const int this_indexing_size = *begin++;
477 
478   return dof_header_size + this_indexing_size +
479     (has_old_dof_object ?
480      unpackable_indexing_size(begin+this_indexing_size) : 0);
481 }
.fi
.SS "unsigned int libMesh::Node::valence () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of nodes connected with this node\&. Currently, this value is invalid (zero) except for subdivision meshes\&. 
.RE
.PP

.PP
Definition at line 226 of file node\&.h\&.
.PP
References _valence, and libMesh::invalid_uint\&.
.PP
Referenced by libMesh::Tri3Subdivision::get_ordered_valence()\&.
.PP
.nf
227   {
228 #ifdef LIBMESH_ENABLE_NODE_VALENCE
229     return _valence;
230 #else
231     libmesh_not_implemented();
232     return libMesh::invalid_uint;
233 #endif
234   }
.fi
.SS "bool libMesh::DofObject::valid_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 653 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id, and libMesh::DofObject::invalid_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), get_info(), libMesh::Elem::get_info(), libMesh::DofObject::id(), and libMesh::Elem::libmesh_assert_valid_node_pointers()\&.
.PP
.nf
654 {
655   return (DofObject::invalid_id != _id);
656 }
.fi
.SS "bool libMesh::DofObject::valid_processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 697 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id, and libMesh::DofObject::invalid_processor_id\&.
.PP
.nf
698 {
699   return (DofObject::invalid_processor_id != _processor_id);
700 }
.fi
.SS "bool libMesh::DofObject::valid_unique_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCunique_id\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 661 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id, and libMesh::DofObject::invalid_unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::Parallel::pack(), and libMesh::DofObject::unique_id()\&.
.PP
.nf
662 {
663 #ifdef LIBMESH_ENABLE_UNIQUE_ID
664   return (DofObject::invalid_unique_id != _unique_id);
665 #else
666   return false;
667 #endif
668 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::vg_dof_base (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 901 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::reinit(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::DofObject::set_vg_dof_base()\&.
.PP
.nf
903 {
904   libmesh_assert_less (s,  this->n_systems());
905   libmesh_assert_less (vg, this->n_var_groups(s));
906 
907   const unsigned int
908     start_idx_sys = this->start_idx(s);
909 
910   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
911 
912   // #ifdef DEBUG
913   //   std::cout << " [ ";
914   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
915   //     std::cout << _idx_buf[i] << " ";
916   //   std::cout << "]\n";
917   // #endif
918 
919   return _idx_buf[start_idx_sys + 2*vg + 1];
920 }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::write_unformatted (std::ostream &out, const boolnewline = \fCtrue\fP) const\fC [inherited]\fP"
Unformatted print to the stream \fCout\fP\&. Simply prints the elements of the vector separated by spaces\&. Optionally prints a newline, which it does by default\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::zero ()\fC [inherited]\fP"
Zero the vector in any dimension\&. 
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBElem\fP\fC [friend]\fP"

.PP
Definition at line 248 of file node\&.h\&.
.SS "friend class \fBMeshRefinement\fP\fC [friend]\fP"
This class need access to the node key information, but no one else should be able to mess with it\&. 
.PP
Definition at line 247 of file node\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReal\fP  \fBlibMesh::TypeVector\fP< \fBReal\fP  >::_coords[LIBMESH_DIM]\fC [protected]\fP, \fC [inherited]\fP"
The coordinates of the \fCTypeVector\fP 
.PP
Definition at line 347 of file type_vector\&.h\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBvalence_idx_t\fP libMesh::Node::_valence\fC [private]\fP"
The number of nodes connected with this node\&. Currently, this value is invalid (zero) except for subdivision meshes\&. 
.PP
Definition at line 261 of file node\&.h\&.
.PP
Referenced by set_valence(), and valence()\&.
.SS "const \fBdof_id_type\fP libMesh::DofObject::invalid_id = static_cast<\fBdof_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invaild \fCid\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 335 of file dof_object\&.h\&.
.PP
Referenced by libMesh::SFCPartitioner::_do_partition(), libMesh::DofMap::_dof_indices(), active(), libMesh::SerialMesh::add_point(), libMesh::MeshRefinement::add_point(), libMesh::UnstructuredMesh::all_second_order(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::dof_number(), libMesh::SerialMesh::insert_node(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::invalidate_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::Elem::node(), libMesh::DofMap::old_dof_indices(), libMesh::XdrIO::pack_element(), libMesh::Elem::point(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::DofObject::valid_id(), and libMesh::System::write_parallel_data()\&.
.SS "const \fBprocessor_id_type\fP libMesh::DofObject::invalid_processor_id = static_cast<\fBprocessor_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invalid \fCprocessor_id\fP to distinguish DoFs that have not been assigned to a processor\&. 
.PP
Definition at line 346 of file dof_object\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::MeshCommunication::allgather(), libMesh::MeshTools::bounding_box(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::Elem::Elem(), libMesh::MeshCommunication::find_global_indices(), libMesh::DofObject::invalidate_processor_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::MeshBase::n_unpartitioned_elem(), libMesh::MeshBase::n_unpartitioned_nodes(), libMesh::Elem::PackedElem::processor_id(), libMesh::CheckpointIO::read_connectivity(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_dofobject_data_by_xyz(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshTools::total_weight(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::SerialMesh::unpartitioned_elements_begin(), libMesh::ParallelMesh::unpartitioned_elements_begin(), libMesh::SerialMesh::unpartitioned_elements_end(), libMesh::ParallelMesh::unpartitioned_elements_end(), libMesh::DofObject::valid_processor_id(), and libMesh::CheckpointIO::write_connectivity()\&.
.SS "const \fBunique_id_type\fP libMesh::DofObject::invalid_unique_id = static_cast<\fBunique_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invaild \fCunique_id\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 340 of file dof_object\&.h\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::DofObject::unique_id(), and libMesh::DofObject::valid_unique_id()\&.
.SS "\fBDofObject\fP* libMesh::DofObject::old_dof_object\fC [inherited]\fP"
This object on the last mesh\&. Useful for projecting solutions from one mesh to another\&. 
.PP
Definition at line 89 of file dof_object\&.h\&.
.PP
Referenced by libMesh::DofObject::clear_old_dof_object(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::DofObject::packed_indexing_size(), libMesh::DofMap::reinit(), libMesh::DofObject::set_old_dof_object(), and libMesh::DofObject::unpack_indexing()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
