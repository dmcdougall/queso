.TH "libMesh::Node::PackedNode" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Node::PackedNode \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <node\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPackedNode\fP ()"
.br
.ti -1c
.RI "\fBPoint\fP \fBbuild_point\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static MPI_Datatype \fBcreate_mpi_datatype\fP ()"
.br
.ti -1c
.RI "static void \fBpack\fP (std::vector< \fBlargest_id_type\fP > &conn, const \fBNode\fP *\fBnode\fP)"
.br
.ti -1c
.RI "static void \fBunpack\fP (std::vector< \fBlargest_id_type\fP >::const_iterator start, \fBNode\fP &\fBnode\fP)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBdof_id_type\fP \fBid\fP"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBpid\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBx\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBy\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBz\fP"
.br
.ti -1c
.RI "\fBPackedNode\fP(const \fBNode\fP &\fBnode\fP) \fBnode\fP \fBprocessor_id\fP () = \fBpid\fP"
.br
.ti -1c
.RI "return \fBnode\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const unsigned int \fBheader_size\fP = 2"
.br
.in -1c
.SH "Detailed Description"
.PP 
Convenient way to communicate nodes\&. This struct defines a packed up node which can be easily communicated through a derived MPI datatype\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk 
.RE
.PP
\fBDate:\fP
.RS 4
2008 
.RE
.PP

.PP
Definition at line 147 of file node\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Node::PackedNode::PackedNode ()\fC [inline]\fP"

.PP
Definition at line 158 of file node\&.h\&.
.PP
.nf
158                   :
159       id(0),
160       pid(DofObject::invalid_processor_id),
161       x(0\&.),
162       y(0\&.),
163       z(0\&.)
164     {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBPoint\fP libMesh::Node::PackedNode::build_point () const\fC [inline]\fP"

.PP
Definition at line 190 of file node\&.h\&.
.PP
References libMesh::Point::Point()\&.
.PP
.nf
191     {
192       return Point(x,y,z);
193     }
.fi
.SS "MPI_Datatype libMesh::Node::PackedNode::create_mpi_datatype ()\fC [static]\fP"

.PP
Definition at line 79 of file node\&.C\&.
.PP
References id, and x\&.
.PP
.nf
80 {
81   MPI_Datatype packed_node_type;
82   MPI_Datatype types[] = { MPI_UNSIGNED, MPI_REAL };
83   int blocklengths[] = { 2, 3 };
84   MPI_Aint displs[2];
85 
86   // create a Packed node and get the addresses of the elements\&.
87   // this will properly handle id/pid getting padded, for example,
88   // in which case id and x may not be 2*sizeof(unsigned int) apart\&.
89   Node::PackedNode pn;
90 
91 #if MPI_VERSION > 1
92   MPI_Get_address (&pn\&.id, &displs[0]);
93   MPI_Get_address (&pn\&.x,  &displs[1]);
94 #else
95   MPI_Address     (&pn\&.id, &displs[0]);
96   MPI_Address     (&pn\&.x,  &displs[1]);
97 #endif // #if MPI_VERSION > 1
98 
99   displs[1] -= displs[0];
100   displs[0] = 0;
101 
102 #if MPI_VERSION > 1
103   MPI_Type_create_struct (2, blocklengths, displs, types, &packed_node_type);
104 #else
105   MPI_Type_struct (2, blocklengths, displs, types, &packed_node_type);
106 #endif // #if MPI_VERSION > 1
107 
108   return packed_node_type;
109 }
.fi
.SS "void libMesh::Node::PackedNode::pack (std::vector< \fBlargest_id_type\fP > &conn, const \fBNode\fP *node)\fC [static]\fP"
For each node the serialization is of the form [ processor_id self_ID x1 x2 y1 y2 z1 z2 dof_object_buffer_1 \&.\&.\&.] There may be 1 or 3 or 4 ints per coordinate depending on machine architecture\&. 
.PP
Definition at line 112 of file node\&.C\&.
.PP
References libMesh::DofObject::id(), libMesh::libmesh_assert(), libMesh::DofObject::pack_indexing(), libMesh::Node::packed_size(), libMesh::DofObject::processor_id(), and libMesh::Real\&.
.PP
.nf
113 {
114   libmesh_assert(node);
115 
116   conn\&.reserve (conn\&.size() + node->packed_size());
117 
118   conn\&.push_back (static_cast<largest_id_type>(node->processor_id()));
119   conn\&.push_back (static_cast<largest_id_type>(node->id()));
120 
121   // use "(a+b-1)/b" trick to get a/b to round up
122   static const unsigned int idtypes_per_Real =
123     (sizeof(Real) + sizeof(largest_id_type) - 1) / sizeof(largest_id_type);
124 
125   for (unsigned int i=0; i != LIBMESH_DIM; ++i)
126     {
127       const largest_id_type* Real_as_idtypes = reinterpret_cast<const largest_id_type*>(&((*node)(i)));
128       for (unsigned int j=0; j != idtypes_per_Real; ++j)
129         {
130           conn\&.push_back(Real_as_idtypes[j]);
131         }
132     }
133 
134   node->pack_indexing(std::back_inserter(conn));
135 }
.fi
.SS "void libMesh::Node::PackedNode::unpack (std::vector< \fBlargest_id_type\fP >::const_iteratorstart, \fBNode\fP &node)\fC [static]\fP"

.PP
Definition at line 138 of file node\&.C\&.
.PP
References libMesh::global_n_processors(), libMesh::DofObject::id(), libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::DofObject::processor_id(), libMesh::Real, libMesh::DofObject::set_id(), and libMesh::DofObject::unpack_indexing()\&.
.PP
.nf
139 {
140   processor_id_type processor_id = static_cast<processor_id_type>(*start++);
141   libmesh_assert(processor_id == DofObject::invalid_processor_id ||
142                  processor_id < libMesh::global_n_processors());
143 
144   dof_id_type id = static_cast<dof_id_type>(*start++);
145 
146   // use "(a+b-1)/b" trick to get a/b to round up
147   static const unsigned int idtypes_per_Real =
148     (sizeof(Real) + sizeof(largest_id_type) - 1) / sizeof(largest_id_type);
149 
150   std::vector<Real> xyz(3,0\&.);
151 
152   for (unsigned int i=0; i != LIBMESH_DIM; ++i)
153     {
154       const Real* ints_as_Real = reinterpret_cast<const Real*>(&(*start));
155       node(i) = *ints_as_Real;
156       start += idtypes_per_Real;
157     }
158 
159   node\&.set_id() = id;
160   node\&.processor_id() = processor_id;
161 
162   node\&.unpack_indexing(start);
163 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const unsigned int libMesh::Node::PackedNode::header_size = 2\fC [static]\fP"

.PP
Definition at line 149 of file node\&.h\&.
.PP
Referenced by libMesh::Node::packed_size()\&.
.SS "\fBdof_id_type\fP libMesh::Node::PackedNode::id"

.PP
Definition at line 151 of file node\&.h\&.
.PP
Referenced by create_mpi_datatype()\&.
.SS "return libMesh::Node::PackedNode::node"

.PP
Definition at line 187 of file node\&.h\&.
.SS "\fBprocessor_id_type\fP libMesh::Node::PackedNode::pid"

.PP
Definition at line 152 of file node\&.h\&.
.SS "\fBPackedNode\fP (const \fBNode\fP &\fBnode\fP) \fBnode\fP libMesh::Node::PackedNode::processor_id() = \fBpid\fP\fC [explicit]\fP"

.PP
Definition at line 186 of file node\&.h\&.
.SS "\fBReal\fP libMesh::Node::PackedNode::x"

.PP
Definition at line 153 of file node\&.h\&.
.PP
Referenced by create_mpi_datatype()\&.
.SS "\fBReal\fP libMesh::Node::PackedNode::y"

.PP
Definition at line 155 of file node\&.h\&.
.SS "\fBReal\fP libMesh::Node::PackedNode::z"

.PP
Definition at line 156 of file node\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
