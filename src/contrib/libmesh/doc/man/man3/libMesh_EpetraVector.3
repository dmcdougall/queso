.TH "libMesh::EpetraVector< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::EpetraVector< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <trilinos_epetra_vector\&.h>\fP
.PP
Inherits \fBlibMesh::NumericVector< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBEpetraVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBEpetraVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP n, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBEpetraVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP n, const \fBnumeric_index_type\fP \fBn_local\fP, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBEpetraVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP N, const \fBnumeric_index_type\fP \fBn_local\fP, const std::vector< \fBnumeric_index_type\fP > &ghost, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBEpetraVector\fP (Epetra_Vector &v, const \fBParallel::Communicator\fP &\fBcomm\fP LIBMESH_CAN_DEFAULT_TO_COMMWORLD)"
.br
.ti -1c
.RI "\fB~EpetraVector\fP ()"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBzero_clone\fP () const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBclone\fP () const "
.br
.ti -1c
.RI "void \fBinit\fP (const \fBnumeric_index_type\fP N, const \fBnumeric_index_type\fP \fBn_local\fP, const bool fast=false, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "void \fBinit\fP (const \fBnumeric_index_type\fP N, const bool fast=false, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "void \fBinit\fP (const \fBnumeric_index_type\fP, const \fBnumeric_index_type\fP, const std::vector< \fBnumeric_index_type\fP > &, const bool=false, const \fBParallelType\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "virtual void \fBinit\fP (const \fBNumericVector\fP< T > &other, const bool fast=false)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const T s)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBEpetraVector\fP< T > & \fBoperator=\fP (const \fBEpetraVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const std::vector< T > &v)"
.br
.ti -1c
.RI "\fBReal\fP \fBmin\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBmax\fP () const "
.br
.ti -1c
.RI "T \fBsum\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBl1_norm\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBl2_norm\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBlinfty_norm\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBsize\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBlocal_size\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBfirst_local_index\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBlast_local_index\fP () const "
.br
.ti -1c
.RI "T \fBoperator()\fP (const \fBnumeric_index_type\fP i) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator+=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator-=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "virtual \fBNumericVector\fP< T > & \fBoperator/=\fP (\fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "virtual void \fBreciprocal\fP ()"
.br
.ti -1c
.RI "virtual void \fBconjugate\fP ()"
.br
.ti -1c
.RI "void \fBset\fP (const \fBnumeric_index_type\fP i, const T value)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBnumeric_index_type\fP i, const T value)"
.br
.ti -1c
.RI "void \fBadd\fP (const T s)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "void \fBadd\fP (const T a, const \fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &\fBA\fP)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector_transpose\fP (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBDenseSubVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBscale\fP (const T factor)"
.br
.ti -1c
.RI "virtual void \fBabs\fP ()"
.br
.ti -1c
.RI "virtual T \fBdot\fP (const \fBNumericVector\fP< T > &V) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (std::vector< T > &v_local) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (\fBNumericVector\fP< T > &v_local) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (\fBNumericVector\fP< T > &v_local, const std::vector< \fBnumeric_index_type\fP > &send_list) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (const \fBnumeric_index_type\fP first_local_idx, const \fBnumeric_index_type\fP last_local_idx, const std::vector< \fBnumeric_index_type\fP > &send_list)"
.br
.ti -1c
.RI "void \fBlocalize_to_one\fP (std::vector< T > &v_local, const \fBprocessor_id_type\fP proc_id=0) const "
.br
.ti -1c
.RI "virtual void \fBpointwise_mult\fP (const \fBNumericVector\fP< T > &vec1, const \fBNumericVector\fP< T > &vec2)"
.br
.ti -1c
.RI "virtual void \fBcreate_subvector\fP (\fBNumericVector\fP< T > &subvector, const std::vector< \fBnumeric_index_type\fP > &rows) const "
.br
.ti -1c
.RI "virtual void \fBswap\fP (\fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "Epetra_Vector * \fBvec\fP ()"
.br
.ti -1c
.RI "virtual bool \fBinitialized\fP () const "
.br
.ti -1c
.RI "\fBParallelType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "\fBParallelType\fP & \fBtype\fP ()"
.br
.ti -1c
.RI "virtual bool \fBclosed\fP () const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_l1_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_l2_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_linfty_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual T \fBel\fP (const \fBnumeric_index_type\fP i) const "
.br
.ti -1c
.RI "virtual void \fBget\fP (const std::vector< \fBnumeric_index_type\fP > &index, std::vector< T > &values) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator*=\fP (const T a)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator/=\fP (const T a)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &v, const \fBShellMatrix\fP< T > &a)"
.br
.ti -1c
.RI "virtual int \fBcompare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual int \fBlocal_relative_compare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual int \fBglobal_relative_compare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "template<> void \fBprint\fP (std::ostream &os) const"
.br
.ti -1c
.RI "virtual void \fBprint_global\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "template<> void \fBprint_global\fP (std::ostream &os) const"
.br
.ti -1c
.RI "virtual void \fBprint_matlab\fP (const std::string &='') const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBbuild\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBbuild\fP (const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fB_is_closed\fP"
.br
.ti -1c
.RI "bool \fB_is_initialized\fP"
.br
.ti -1c
.RI "\fBParallelType\fP \fB_type\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "int \fBSumIntoGlobalValues\fP (int numIDs, const int *GIDs, const double *values)"
.br
.ti -1c
.RI "int \fBSumIntoGlobalValues\fP (const Epetra_IntSerialDenseVector &GIDs, const Epetra_SerialDenseVector &values)"
.br
.ti -1c
.RI "int \fBReplaceGlobalValues\fP (int numIDs, const int *GIDs, const double *values)"
.br
.ti -1c
.RI "int \fBReplaceGlobalValues\fP (const Epetra_IntSerialDenseVector &GIDs, const Epetra_SerialDenseVector &values)"
.br
.ti -1c
.RI "int \fBSumIntoGlobalValues\fP (int numIDs, const int *GIDs, const int *numValuesPerID, const double *values)"
.br
.ti -1c
.RI "int \fBReplaceGlobalValues\fP (int numIDs, const int *GIDs, const int *numValuesPerID, const double *values)"
.br
.ti -1c
.RI "int \fBGlobalAssemble\fP (Epetra_CombineMode mode=Add)"
.br
.ti -1c
.RI "void \fBsetIgnoreNonLocalEntries\fP (bool flag)"
.br
.ti -1c
.RI "void \fBFEoperatorequals\fP (const \fBEpetraVector\fP &source)"
.br
.ti -1c
.RI "int \fBinputValues\fP (int numIDs, const int *GIDs, const double *values, bool accumulate)"
.br
.ti -1c
.RI "int \fBinputValues\fP (int numIDs, const int *GIDs, const int *numValuesPerID, const double *values, bool accumulate)"
.br
.ti -1c
.RI "int \fBinputNonlocalValue\fP (int GID, double value, bool accumulate)"
.br
.ti -1c
.RI "int \fBinputNonlocalValues\fP (int GID, int numValues, const double *values, bool accumulate)"
.br
.ti -1c
.RI "void \fBdestroyNonlocalData\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Epetra_Vector * \fB_vec\fP"
.br
.ti -1c
.RI "Epetra_Map * \fB_map\fP"
.br
.ti -1c
.RI "bool \fB_destroy_vec_on_exit\fP"
.br
.ti -1c
.RI "int \fBmyFirstID_\fP"
.br
.ti -1c
.RI "int \fBmyNumIDs_\fP"
.br
.ti -1c
.RI "double * \fBmyCoefs_\fP"
.br
.ti -1c
.RI "int * \fBnonlocalIDs_\fP"
.br
.ti -1c
.RI "int * \fBnonlocalElementSize_\fP"
.br
.ti -1c
.RI "int \fBnumNonlocalIDs_\fP"
.br
.ti -1c
.RI "int \fBallocatedNonlocalLength_\fP"
.br
.ti -1c
.RI "double ** \fBnonlocalCoefs_\fP"
.br
.ti -1c
.RI "unsigned char \fBlast_edit\fP"
.br
.ti -1c
.RI "bool \fBignoreNonLocalEntries_\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::EpetraVector< T >"
Epetra vector\&. Provides a nice interface to the Trilinos Epetra data structures for parallel vectors\&.
.PP
\fBAuthor:\fP
.RS 4
Derek R\&. Gaston, 2008 
.RE
.PP

.PP
Definition at line 60 of file trilinos_epetra_vector\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBlibMesh::EpetraVector\fP< T >::\fBEpetraVector\fP (const \fBParallel::Communicator\fP &comm, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [explicit]\fP"
Dummy-Constructor\&. Dimension=0 
.PP
Definition at line 633 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::NumericVector< T >::_type, and libMesh::NumericVector< T >::type()\&.
.PP
.nf
635   : NumericVector<T>(comm, type),
636     _destroy_vec_on_exit(true),
637     myFirstID_(0),
638     myNumIDs_(0),
639     myCoefs_(NULL),
640     nonlocalIDs_(NULL),
641     nonlocalElementSize_(NULL),
642     numNonlocalIDs_(0),
643     allocatedNonlocalLength_(0),
644     nonlocalCoefs_(NULL),
645     last_edit(0),
646     ignoreNonLocalEntries_(false)
647 {
648   this->_type = type;
649 }
.fi
.SS "template<typename T > \fBlibMesh::EpetraVector\fP< T >::\fBEpetraVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPn, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. Set dimension to \fCn\fP and initialize all elements with zero\&. 
.PP
Definition at line 655 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::init()\&.
.PP
.nf
658   : NumericVector<T>(comm, type),
659     _destroy_vec_on_exit(true),
660     myFirstID_(0),
661     myNumIDs_(0),
662     myCoefs_(NULL),
663     nonlocalIDs_(NULL),
664     nonlocalElementSize_(NULL),
665     numNonlocalIDs_(0),
666     allocatedNonlocalLength_(0),
667     nonlocalCoefs_(NULL),
668     last_edit(0),
669     ignoreNonLocalEntries_(false)
670 
671 {
672   this->init(n, n, false, type);
673 }
.fi
.SS "template<typename T > \fBlibMesh::EpetraVector\fP< T >::\fBEpetraVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPn, const \fBnumeric_index_type\fPn_local, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP"
Constructor\&. Set local dimension to \fCn_local\fP, the global dimension to \fCn\fP, and initialize all elements with zero\&. 
.PP
Definition at line 679 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::init()\&.
.PP
.nf
683   : NumericVector<T>(comm, type),
684     _destroy_vec_on_exit(true),
685     myFirstID_(0),
686     myNumIDs_(0),
687     myCoefs_(NULL),
688     nonlocalIDs_(NULL),
689     nonlocalElementSize_(NULL),
690     numNonlocalIDs_(0),
691     allocatedNonlocalLength_(0),
692     nonlocalCoefs_(NULL),
693     last_edit(0),
694     ignoreNonLocalEntries_(false)
695 {
696   this->init(n, n_local, false, type);
697 }
.fi
.SS "template<typename T > \fBlibMesh::EpetraVector\fP< T >::\fBEpetraVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPN, const \fBnumeric_index_type\fPn_local, const std::vector< \fBnumeric_index_type\fP > &ghost, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP"
Constructor\&. Set local dimension to \fCn_local\fP, the global dimension to \fCn\fP, but additionally reserve memory for the indices specified by the \fCghost\fP argument\&. 
.PP
Definition at line 744 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::init()\&.
.PP
.nf
749   : NumericVector<T>(comm, AUTOMATIC),
750     _destroy_vec_on_exit(true),
751     myFirstID_(0),
752     myNumIDs_(0),
753     myCoefs_(NULL),
754     nonlocalIDs_(NULL),
755     nonlocalElementSize_(NULL),
756     numNonlocalIDs_(0),
757     allocatedNonlocalLength_(0),
758     nonlocalCoefs_(NULL),
759     last_edit(0),
760     ignoreNonLocalEntries_(false)
761 {
762   this->init(n, n_local, ghost, false, type);
763 }
.fi
.SS "template<typename T> \fBlibMesh::EpetraVector\fP< T >::\fBEpetraVector\fP (Epetra_Vector &v, const \fBParallel::Communicator\fP &\fBcomm\fPLIBMESH_CAN_DEFAULT_TO_COMMWORLD)"
Constructor\&. Creates a \fBEpetraVector\fP assuming you already have a valid Epetra Vec object\&. In this case, v is NOT destroyed by the \fBEpetraVector\fP constructor when this object goes out of scope\&. This allows ownership of v to remain with the original creator, and to simply provide additional functionality with the \fBEpetraVector\fP\&. 
.SS "template<typename T > \fBlibMesh::EpetraVector\fP< T >::~\fBEpetraVector\fP ()\fC [inline]\fP"
Destructor, deallocates memory\&. Made virtual to allow for derived classes to behave properly\&. 
.PP
Definition at line 780 of file trilinos_epetra_vector\&.h\&.
.PP
.nf
781 {
782   this->clear ();
783 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::abs ()\fC [virtual]\fP"
v = abs(v)\&.\&.\&. that is, each entry in v is replaced by its absolute value\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 372 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
373 {
374   _vec->Abs(*_vec);
375 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add (const \fBnumeric_index_type\fPi, const Tvalue)\fC [virtual]\fP"
v(i) += value 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 197 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
198 {
199   int i = static_cast<int> (i_in);
200   T value = value_in;
201 
202   libmesh_assert_less (i_in, this->size());
203 
204   SumIntoGlobalValues(1, &i, &value);
205 
206   this->_is_closed = false;
207 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add (const Ts)\fC [virtual]\fP"
$U(0-LIBMESH_DIM)+=s$\&. Addition of \fCs\fP to all components\&. Note that \fCs\fP is a scalar and not a vector\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 278 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
279 {
280   const unsigned int nl = _vec->MyLength();
281 
282   T * values = _vec->Values();
283 
284   for (unsigned int i=0; i<nl; i++)
285     values[i]+=v_in;
286 
287   this->_is_closed = false;
288 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
$ U+=V $ \&. Simple vector addition, equal to the \fCoperator\fP +=\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 292 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
293 {
294   this->add (1\&., v);
295 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add (const Ta, const \fBNumericVector\fP< T > &v)\fC [virtual]\fP"
$ U+=a*V $ \&. Simple vector addition, equal to the \fCoperator\fP +=\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 299 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec, and libMesh::EpetraVector< T >::size()\&.
.PP
.nf
300 {
301   const EpetraVector<T>* v = libmesh_cast_ptr<const EpetraVector<T>*>(&v_in);
302 
303   libmesh_assert_equal_to (this->size(), v->size());
304 
305   _vec->Update(a_in,*v->_vec, 1\&.);
306 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add_vector (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U+=v $ where \fCv\fP is a \fCstd::vector<T>\fP and you want to specify WHERE to add it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 212 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
214 {
215   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
216   libmesh_assert_equal_to (sizeof(numeric_index_type), sizeof(int));
217 
218   SumIntoGlobalValues (v\&.size(),
219                        (int*) &dof_indices[0],
220                        const_cast<T*>(&v[0]));
221 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U+=V $ where U and V are type \fCNumericVector<T>\fP and you want to specify WHERE to add the \fCNumericVector<T>\fP V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 226 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::size()\&.
.PP
.nf
228 {
229   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
230 
231   for (unsigned int i=0; i<V\&.size(); i++)
232     this->add (dof_indices[i], V(i));
233 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A)\fC [virtual]\fP"
$U+=A*V$, add the product of a \fC\fBSparseMatrix\fP\fP \fCA\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 239 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec, A, and libMesh::EpetraVector< T >::zero_clone()\&.
.PP
.nf
241 {
242   const EpetraVector<T>* V = libmesh_cast_ptr<const EpetraVector<T>*>(&V_in);
243   const EpetraMatrix<T>* A = libmesh_cast_ptr<const EpetraMatrix<T>*>(&A_in);
244 
245   // FIXME - does Trilinos let us do this *without* memory allocation?
246   AutoPtr<NumericVector<T> > temp = V->zero_clone();
247   EpetraVector<T>* tempV = libmesh_cast_ptr<EpetraVector<T>*>(temp\&.get());
248   A->mat()->Multiply(false, *V->_vec, *tempV->_vec);
249   *this += *temp;
250 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add_vector (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$U+=V $ where U and V are type DenseVector<T> and you want to specify WHERE to add the DenseVector<T> V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 255 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::DenseVector< T >::get_values(), and libMesh::DenseVector< T >::size()\&.
.PP
.nf
257 {
258   libmesh_assert_equal_to (V_in\&.size(), dof_indices\&.size());
259   libmesh_assert_equal_to (sizeof(numeric_index_type), sizeof(int));
260 
261   SumIntoGlobalValues(dof_indices\&.size(),
262                       (int *)&dof_indices[0],
263                       &const_cast<DenseVector<T> *>(&V_in)->get_values()[0]);
264 }
.fi
.SS "template<typename T> void \fBlibMesh::NumericVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &v, const \fBShellMatrix\fP< T > &a)\fC [inherited]\fP"
$U+=A*V$, add the product of a \fC\fBShellMatrix\fP\fP \fCA\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Definition at line 380 of file numeric_vector\&.C\&.
.PP
References libMesh::ShellMatrix< T >::vector_mult_add()\&.
.PP
.nf
382 {
383   a\&.vector_mult_add(*this,v);
384 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::add_vector_transpose (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)\fC [virtual]\fP"
$U+=A*V$, add the product of the transpose of a \fC\fBSparseMatrix\fP\fP \fCA_trans\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 269 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
271 {
272   libmesh_not_implemented();
273 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::NumericVector\fP< T >::build (const \fBParallel::Communicator\fP &comm, const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBNumericVector\fP\fP on the processors in communicator \fCcomm\fP using the linear solver package specified by \fCsolver_package\fP 
.PP
Definition at line 46 of file numeric_vector\&.C\&.
.PP
References libMesh::AUTOMATIC, libMesh::EIGEN_SOLVERS, libMesh::LASPACK_SOLVERS, libMesh::PETSC_SOLVERS, and libMesh::TRILINOS_SOLVERS\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::add_vector(), libMesh::NumericVector< T >::build(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::EquationSystems::get_solution(), and libMesh::System::project_vector()\&.
.PP
.nf
47 {
48   // Build the appropriate vector
49   switch (solver_package)
50     {
51 
52 
53 #ifdef LIBMESH_HAVE_LASPACK
54     case LASPACK_SOLVERS:
55       {
56         AutoPtr<NumericVector<T> > ap(new LaspackVector<T>(comm, AUTOMATIC));
57         return ap;
58       }
59 #endif
60 
61 
62 #ifdef LIBMESH_HAVE_PETSC
63     case PETSC_SOLVERS:
64       {
65         AutoPtr<NumericVector<T> > ap(new PetscVector<T>(comm, AUTOMATIC));
66         return ap;
67       }
68 #endif
69 
70 
71 #ifdef LIBMESH_HAVE_TRILINOS
72     case TRILINOS_SOLVERS:
73       {
74         AutoPtr<NumericVector<T> > ap(new EpetraVector<T>(comm, AUTOMATIC));
75         return ap;
76       }
77 #endif
78 
79 
80 #ifdef LIBMESH_HAVE_EIGEN
81     case EIGEN_SOLVERS:
82       {
83         AutoPtr<NumericVector<T> > ap(new EigenSparseVector<T>(comm, AUTOMATIC));
84         return ap;
85       }
86 #endif
87 
88 
89     default:
90       AutoPtr<NumericVector<T> > ap(new DistributedVector<T>(comm, AUTOMATIC));
91       return ap;
92 
93     }
94 
95   AutoPtr<NumericVector<T> > ap(NULL);
96   return ap;
97 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::NumericVector\fP< T >::build (const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBNumericVector\fP\fP on the processors in communicator CommWorld using the linear solver package specified by \fCsolver_package\fP\&. Deprecated\&. 
.PP
Definition at line 103 of file numeric_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::build(), and libMesh::CommWorld\&.
.PP
.nf
104 {
105   libmesh_deprecated();
106   return NumericVector<T>::build(CommWorld, solver_package);
107 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::clear ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCEpetraVector<T>\fP to a pristine state\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 893 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, and libMesh::initialized()\&.
.PP
.nf
894 {
895   if (this->initialized())
896     {
897       // We might just be an interface to a user-provided _vec
898       if (this->_destroy_vec_on_exit)
899         {
900           delete _vec;
901           _vec = NULL;
902         }
903 
904       // But we currently always own our own _map
905       delete _map;
906       _map = NULL;
907     }
908 
909   this->_is_closed = this->_is_initialized = false;
910 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::EpetraVector\fP< T >::clone () const\fC [inline]\fP, \fC [virtual]\fP"
Creates a copy of this vector and returns it in an \fC\fBAutoPtr\fP\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 942 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::AUTOMATIC, and libMesh::comm\&.
.PP
.nf
943 {
944   AutoPtr<NumericVector<T> > cloned_vector
945     (new EpetraVector<T>(this->comm(), AUTOMATIC));
946 
947   cloned_vector->init(*this, true);
948 
949   *cloned_vector = *this;
950 
951   return cloned_vector;
952 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::close ()\fC [inline]\fP, \fC [virtual]\fP"
Call the assemble functions 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 869 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::comm, libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::EpetraVector< T >::localize()\&.
.PP
.nf
870 {
871   libmesh_assert (this->initialized());
872 
873   // Are we adding or inserting?
874   unsigned char global_last_edit = last_edit;
875   this->comm()\&.max(global_last_edit);
876   libmesh_assert(!last_edit || last_edit == global_last_edit);
877 
878   if (global_last_edit == 1)
879     this->GlobalAssemble(Insert);
880   else if (global_last_edit == 2)
881     this->GlobalAssemble(Add);
882   else
883     libmesh_assert(!global_last_edit);
884 
885   this->_is_closed = true;
886   this->last_edit = 0;
887 }
.fi
.SS "template<typename T> virtual bool \fBlibMesh::NumericVector\fP< T >::closed () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the vector is closed and ready for computation, false otherwise\&. 
.RE
.PP

.PP
Definition at line 145 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::DofMap::max_constraint_error(), libMesh::LaspackVector< T >::operator=(), libMesh::EigenSparseVector< T >::operator=(), and libMesh::PetscVector< T >::operator=()\&.
.PP
.nf
145 { return _is_closed; }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given \fCthreshold\fP\&. When differences occur, the return value contains the first index \fCi\fP where the difference \fC\fP(a[i]-b[i]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 112 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), and std::max()\&.
.PP
.nf
114 {
115   libmesh_assert (this->initialized());
116   libmesh_assert (other_vector\&.initialized());
117   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
118   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
119 
120   int first_different_i = std::numeric_limits<int>::max();
121   numeric_index_type i = first_local_index();
122 
123   do
124     {
125       if ( std::abs( (*this)(i) - other_vector(i) ) > threshold )
126         first_different_i = i;
127       else
128         i++;
129     }
130   while (first_different_i==std::numeric_limits<int>::max()
131          && i<last_local_index());
132 
133   // Find the correct first differing index in parallel
134   this->comm()\&.min(first_different_i);
135 
136   if (first_different_i == std::numeric_limits<int>::max())
137     return -1;
138 
139   return first_different_i;
140 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::conjugate ()\fC [virtual]\fP"
Replace each entry v_i = real(v_i) + imag(v_i) of this vector by its complex conjugate, real(v_i) - imag(v_i)\&. Epetra is real-valued only, rendering this a no-op\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 189 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
190 {
191   // EPetra is real, rendering this a no-op\&.
192 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::create_subvector (\fBNumericVector\fP< T > &subvector, const std::vector< \fBnumeric_index_type\fP > &rows) const\fC [virtual]\fP"
Creates a 'subvector' from this vector using the rows indices of the 'rows' array\&. 
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 599 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
601 {
602   libmesh_not_implemented();
603 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::destroyNonlocalData ()\fC [private]\fP"

.PP
Definition at line 925 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
926 {
927   if (allocatedNonlocalLength_ > 0) {
928     delete [] nonlocalIDs_;
929     delete [] nonlocalElementSize_;
930     nonlocalIDs_ = NULL;
931     nonlocalElementSize_ = NULL;
932     for(int i=0; i<numNonlocalIDs_; ++i) {
933       delete [] nonlocalCoefs_[i];
934     }
935     delete [] nonlocalCoefs_;
936     nonlocalCoefs_ = NULL;
937     numNonlocalIDs_ = 0;
938     allocatedNonlocalLength_ = 0;
939   }
940   return;
941 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "template<typename T > T \fBlibMesh::EpetraVector\fP< T >::dot (const \fBNumericVector\fP< T > &V) const\fC [virtual]\fP"
Computes the dot product, p = U\&.V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 379 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec\&.
.PP
.nf
380 {
381   const EpetraVector<T>* V = libmesh_cast_ptr<const EpetraVector<T>*>(&V_in);
382 
383   T result=0\&.0;
384 
385   _vec->Dot(*V->_vec, &result);
386 
387   return result;
388 }
.fi
.SS "template<typename T> virtual T \fBlibMesh::NumericVector\fP< T >::el (const \fBnumeric_index_type\fPi) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element \fCU(i)\fP 
.RE
.PP

.PP
Definition at line 342 of file numeric_vector\&.h\&.
.PP
.nf
342 { return (*this)(i); }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::FEoperatorequals (const \fBEpetraVector\fP< T > &source)\fC [private]\fP"

.PP
Definition at line 898 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec, libMesh::EpetraVector< T >::allocatedNonlocalLength_, libMesh::EpetraVector< T >::nonlocalCoefs_, libMesh::EpetraVector< T >::nonlocalElementSize_, libMesh::EpetraVector< T >::nonlocalIDs_, and libMesh::EpetraVector< T >::numNonlocalIDs_\&.
.PP
.nf
899 {
900   (*_vec) = *(source\&._vec);
901 
902   destroyNonlocalData();
903 
904   if (source\&.allocatedNonlocalLength_ > 0) {
905     allocatedNonlocalLength_ = source\&.allocatedNonlocalLength_;
906     numNonlocalIDs_ = source\&.numNonlocalIDs_;
907     nonlocalIDs_ = new int[allocatedNonlocalLength_];
908     nonlocalElementSize_ = new int[allocatedNonlocalLength_];
909     nonlocalCoefs_ = new double*[allocatedNonlocalLength_];
910     for(int i=0; i<numNonlocalIDs_; ++i) {
911       int elemSize = source\&.nonlocalElementSize_[i];
912       nonlocalCoefs_[i] = new double[elemSize];
913       nonlocalIDs_[i] = source\&.nonlocalIDs_[i];
914       nonlocalElementSize_[i] = elemSize;
915       for(int j=0; j<elemSize; ++j) {
916         nonlocalCoefs_[i][j] = source\&.nonlocalCoefs_[i][j];
917       }
918     }
919   }
920 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::EpetraVector\fP< T >::first_local_index () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the first vector element actually stored on this processor 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 978 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
979 {
980   libmesh_assert (this->initialized());
981 
982   return _vec->Map()\&.MinMyGID();
983 }
.fi
.SS "template<typename T> void \fBlibMesh::NumericVector\fP< T >::get (const std::vector< \fBnumeric_index_type\fP > &index, std::vector< T > &values) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Access multiple components at once\&. \fCvalues\fP will be resized, if necessary, and filled\&. The default implementation calls \fCoperator()\fP for each index, but some implementations may supply faster methods here\&. 
.PP
Reimplemented in \fBlibMesh::PetscVector< T >\fP\&.
.PP
Definition at line 795 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::FEMContext::pre_fe_reinit()\&.
.PP
.nf
796 {
797   const std::size_t num = index\&.size();
798   values\&.resize(num);
799   for(std::size_t i=0; i<num; i++)
800     {
801       values[i] = (*this)(index[i]);
802     }
803 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::global_relative_compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given local relative \fCthreshold\fP\&. When differences occur, the return value contains the first index where the difference \fC\fP(a[i]-b[i])/max_j(a[j],b[j]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 177 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), libMesh::NumericVector< T >::linfty_norm(), std::max(), and libMesh::Real\&.
.PP
.nf
179 {
180   libmesh_assert (this->initialized());
181   libmesh_assert (other_vector\&.initialized());
182   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
183   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
184 
185   int first_different_i = std::numeric_limits<int>::max();
186   numeric_index_type i = first_local_index();
187 
188   const Real my_norm = this->linfty_norm();
189   const Real other_norm = other_vector\&.linfty_norm();
190   const Real abs_threshold = std::max(my_norm, other_norm) * threshold;
191 
192   do
193     {
194       if ( std::abs( (*this)(i) - other_vector(i) ) > abs_threshold )
195         first_different_i = i;
196       else
197         i++;
198     }
199   while (first_different_i==std::numeric_limits<int>::max()
200          && i<last_local_index());
201 
202   // Find the correct first differing index in parallel
203   this->comm()\&.min(first_different_i);
204 
205   if (first_different_i == std::numeric_limits<int>::max())
206     return -1;
207 
208   return first_different_i;
209 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::GlobalAssemble (Epetra_CombineModemode = \fCAdd\fP)\fC [private]\fP"
Gather any overlapping/shared data into the non-overlapping partitioning defined by the Map that was passed to this vector at construction time\&. Data imported from other processors is stored on the owning processor with a 'sumInto' or accumulate operation\&. This is a collective method -- every processor must enter it before any will complete it\&. 
.PP
Definition at line 853 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
854 {
855   //In this method we need to gather all the non-local (overlapping) data
856   //that's been input on each processor, into the (probably) non-overlapping
857   //distribution defined by the map that 'this' vector was constructed with\&.
858 
859   //We don't need to do anything if there's only one processor or if
860   //ignoreNonLocalEntries_ is true\&.
861   if (_vec->Map()\&.Comm()\&.NumProc() < 2 || ignoreNonLocalEntries_) {
862     return(0);
863   }
864 
865 
866 
867   //First build a map that describes the data in nonlocalIDs_/nonlocalCoefs_\&.
868   //We'll use the arbitrary distribution constructor of Map\&.
869 
870   Epetra_BlockMap sourceMap(-1, numNonlocalIDs_,
871                             nonlocalIDs_, nonlocalElementSize_,
872                             _vec->Map()\&.IndexBase(), _vec->Map()\&.Comm());
873 
874   //Now build a vector to hold our nonlocalCoefs_, and to act as the source-
875   //vector for our import operation\&.
876   Epetra_MultiVector nonlocalVector(sourceMap, 1);
877 
878   int i,j;
879   for(i=0; i<numNonlocalIDs_; ++i) {
880     for(j=0; j<nonlocalElementSize_[i]; ++j) {
881       nonlocalVector\&.ReplaceGlobalValue(nonlocalIDs_[i], j, 0,
882                                         nonlocalCoefs_[i][j]);
883     }
884   }
885 
886   Epetra_Export exporter(sourceMap, _vec->Map());
887 
888   EPETRA_CHK_ERR( _vec->Export(nonlocalVector, exporter, mode) );
889 
890   destroyNonlocalData();
891 
892   return(0);
893 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::init (const \fBnumeric_index_type\fPN, const \fBnumeric_index_type\fPn_local, const boolfast = \fCfalse\fP, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [virtual]\fP"
Change the dimension of the vector to \fCN\fP\&. The reserved memory for this vector remains unchanged if possible, to make things faster, but this may waste some memory, so take this in the back of your head\&. However, if \fCN==0\fP all memory is freed, i\&.e\&. if you want to resize the vector and release the memory not needed, you have to first call \fCinit(0)\fP and then \fCinit(N)\fP\&. This cited behaviour is analogous to that of the STL containers\&.
.PP
On \fCfast==false\fP, the vector is filled by zeros\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 789 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, libMesh::AUTOMATIC, libMesh::comm, libMesh::GHOSTED, libMesh::libmesh_assert(), libMesh::n_local, libMesh::PARALLEL, libMesh::SERIAL, and libMesh::zero\&.
.PP
Referenced by libMesh::EpetraVector< T >::EpetraVector(), and libMesh::EpetraVector< T >::localize()\&.
.PP
.nf
793 {
794   // We default to allocating n_local local storage
795   numeric_index_type my_n_local = n_local;
796 
797   if (type == AUTOMATIC)
798     {
799       if (n == n_local)
800         this->_type = SERIAL;
801       else
802         this->_type = PARALLEL;
803     }
804   else if (type == GHOSTED)
805     {
806       // We don't yet support GHOSTED Epetra vectors, so to get the
807       // same functionality we need a SERIAL vector with local
808       // storage allocated for every entry\&.
809       this->_type = SERIAL;
810       my_n_local = n;
811     }
812   else
813     this->_type = type;
814 
815   libmesh_assert ((this->_type==SERIAL && n==my_n_local) ||
816                   this->_type==PARALLEL);
817 
818   _map = new Epetra_Map(static_cast<int>(n),
819                         my_n_local,
820                         0,
821                         Epetra_MpiComm (this->comm()\&.get()));
822 
823   _vec = new Epetra_Vector(*_map);
824 
825   myFirstID_ = _vec->Map()\&.MinMyGID();
826   myNumIDs_ = _vec->Map()\&.NumMyElements();
827 
828   //Currently we impose the restriction that NumVectors==1, so we won't
829   //need the LDA argument when calling ExtractView\&. Hence the "dummy" arg\&.
830   int dummy;
831   _vec->ExtractView(&myCoefs_, &dummy);
832 
833   this->_is_initialized = true;
834   this->_is_closed = true;
835   this->last_edit = 0;
836 
837   if (fast == false)
838     this->zero ();
839 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::init (const \fBnumeric_index_type\fPN, const boolfast = \fCfalse\fP, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [virtual]\fP"
call init with n_local = N, 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 858 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::TriangleWrapper::init()\&.
.PP
.nf
861 {
862   this->init(n,n,fast,type);
863 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::init (const \fBnumeric_index_type\fPn, const \fBnumeric_index_type\fPn_local, const std::vector< \fBnumeric_index_type\fP > &, const boolfast = \fCfalse\fP, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [virtual]\fP"
Create a vector that holds the local indices plus those specified in the \fCghost\fP argument\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 844 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::TriangleWrapper::init()\&.
.PP
.nf
849 {
850   // TODO: we shouldn't ignore the ghost sparsity pattern
851   this->init(n, n_local, fast, type);
852 }
.fi
.SS "template<class T > void \fBlibMesh::EpetraVector\fP< T >::init (const \fBNumericVector\fP< T > &other, const boolfast = \fCfalse\fP)\fC [virtual]\fP"
Creates a vector that has the same dimension and storage type as \fCother\fP, including ghost dofs\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 770 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::TriangleWrapper::init(), libMesh::NumericVector< T >::local_size(), libMesh::NumericVector< T >::size(), and libMesh::NumericVector< T >::type()\&.
.PP
.nf
772 {
773   this->init(other\&.size(),other\&.local_size(),fast,other\&.type());
774 }
.fi
.SS "template<typename T> virtual bool \fBlibMesh::NumericVector\fP< T >::initialized () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the vector has been initialized, false otherwise\&. 
.RE
.PP

.PP
Definition at line 129 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::assemble(), libMesh::NumericVector< T >::compare(), libMesh::PetscVector< T >::create_subvector(), libMesh::NumericVector< T >::global_relative_compare(), libMesh::PetscVector< T >::init(), and libMesh::NumericVector< T >::local_relative_compare()\&.
.PP
.nf
129 { return _is_initialized; }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::inputNonlocalValue (intGID, doublevalue, boolaccumulate)\fC [private]\fP"

.PP
Definition at line 753 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
754 {
755   int insertPoint = -1;
756 
757   //find offset of GID in nonlocalIDs_
758   int offset = Epetra_Util_binary_search(GID, nonlocalIDs_, numNonlocalIDs_,
759                                          insertPoint);
760   if (offset >= 0) {
761     //if offset >= 0
762     //  put value in nonlocalCoefs_[offset][0]
763 
764     if (accumulate) {
765       nonlocalCoefs_[offset][0] += value;
766     }
767     else {
768       nonlocalCoefs_[offset][0] = value;
769     }
770   }
771   else {
772     //else
773     //  insert GID in nonlocalIDs_
774     //  insert 1   in nonlocalElementSize_
775     //  insert value in nonlocalCoefs_
776 
777     int tmp1 = numNonlocalIDs_;
778     int tmp2 = allocatedNonlocalLength_;
779     int tmp3 = allocatedNonlocalLength_;
780     EPETRA_CHK_ERR( Epetra_Util_insert(GID, insertPoint, nonlocalIDs_,
781                                        tmp1, tmp2) );
782     --tmp1;
783     EPETRA_CHK_ERR( Epetra_Util_insert(1, insertPoint, nonlocalElementSize_,
784                                        tmp1, tmp3) );
785     double* values = new double[1];
786     values[0] = value;
787     EPETRA_CHK_ERR( Epetra_Util_insert(values, insertPoint, nonlocalCoefs_,
788                                        numNonlocalIDs_, allocatedNonlocalLength_) );
789   }
790 
791   return(0);
792 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::inputNonlocalValues (intGID, intnumValues, const double *values, boolaccumulate)\fC [private]\fP"

.PP
Definition at line 796 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
798 {
799   int insertPoint = -1;
800 
801   //find offset of GID in nonlocalIDs_
802   int offset = Epetra_Util_binary_search(GID, nonlocalIDs_, numNonlocalIDs_,
803                                          insertPoint);
804   if (offset >= 0) {
805     //if offset >= 0
806     //  put value in nonlocalCoefs_[offset][0]
807 
808     if (numValues != nonlocalElementSize_[offset]) {
809       libMesh::err << "Epetra_FEVector ERROR: block-size for GID " << GID << " is "
810                    << numValues<<" which doesn't match previously set block-size of "
811                    << nonlocalElementSize_[offset] << std::endl;
812       return(-1);
813     }
814 
815     if (accumulate) {
816       for(int j=0; j<numValues; ++j) {
817         nonlocalCoefs_[offset][j] += values[j];
818       }
819     }
820     else {
821       for(int j=0; j<numValues; ++j) {
822         nonlocalCoefs_[offset][j] = values[j];
823       }
824     }
825   }
826   else {
827     //else
828     //  insert GID in nonlocalIDs_
829     //  insert numValues   in nonlocalElementSize_
830     //  insert values in nonlocalCoefs_
831 
832     int tmp1 = numNonlocalIDs_;
833     int tmp2 = allocatedNonlocalLength_;
834     int tmp3 = allocatedNonlocalLength_;
835     EPETRA_CHK_ERR( Epetra_Util_insert(GID, insertPoint, nonlocalIDs_,
836                                        tmp1, tmp2) );
837     --tmp1;
838     EPETRA_CHK_ERR( Epetra_Util_insert(numValues, insertPoint, nonlocalElementSize_,
839                                        tmp1, tmp3) );
840     double* newvalues = new double[numValues];
841     for(int j=0; j<numValues; ++j) {
842       newvalues[j] = values[j];
843     }
844     EPETRA_CHK_ERR( Epetra_Util_insert(newvalues, insertPoint, nonlocalCoefs_,
845                                        numNonlocalIDs_, allocatedNonlocalLength_) );
846   }
847 
848   return(0);
849 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::inputValues (intnumIDs, const int *GIDs, const double *values, boolaccumulate)\fC [private]\fP"

.PP
Definition at line 673 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
677 {
678   if (accumulate) {
679     libmesh_assert(last_edit == 0 || last_edit == 2);
680     last_edit = 2;
681   } else {
682     libmesh_assert(last_edit == 0 || last_edit == 1);
683     last_edit = 1;
684   }
685 
686   //Important note!! This method assumes that there is only 1 point
687   //associated with each element\&.
688 
689   for(int i=0; i<numIDs; ++i) {
690     if (_vec->Map()\&.MyGID(GIDs[i])) {
691       if (accumulate) {
692         _vec->SumIntoGlobalValue(GIDs[i], 0, 0, values[i]);
693       }
694       else {
695         _vec->ReplaceGlobalValue(GIDs[i], 0, 0, values[i]);
696       }
697     }
698     else {
699       if (!ignoreNonLocalEntries_) {
700         EPETRA_CHK_ERR( inputNonlocalValue(GIDs[i], values[i], accumulate) );
701       }
702     }
703   }
704 
705   return(0);
706 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::inputValues (intnumIDs, const int *GIDs, const int *numValuesPerID, const double *values, boolaccumulate)\fC [private]\fP"

.PP
Definition at line 710 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
715 {
716   if (accumulate) {
717     libmesh_assert(last_edit == 0 || last_edit == 2);
718     last_edit = 2;
719   } else {
720     libmesh_assert(last_edit == 0 || last_edit == 1);
721     last_edit = 1;
722   }
723 
724   int offset=0;
725   for(int i=0; i<numIDs; ++i) {
726     int numValues = numValuesPerID[i];
727     if (_vec->Map()\&.MyGID(GIDs[i])) {
728       if (accumulate) {
729         for(int j=0; j<numValues; ++j) {
730           _vec->SumIntoGlobalValue(GIDs[i], j, 0, values[offset+j]);
731         }
732       }
733       else {
734         for(int j=0; j<numValues; ++j) {
735           _vec->ReplaceGlobalValue(GIDs[i], j, 0, values[offset+j]);
736         }
737       }
738     }
739     else {
740       if (!ignoreNonLocalEntries_) {
741         EPETRA_CHK_ERR( inputNonlocalValues(GIDs[i], numValues,
742                                             &(values[offset]), accumulate) );
743       }
744     }
745     offset += numValues;
746   }
747 
748   return(0);
749 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::insert (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=v $ where v is a \fCstd::vector<T>\fP and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 311 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
313 {
314   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
315   libmesh_assert_equal_to (sizeof(numeric_index_type), sizeof(int));
316 
317   ReplaceGlobalValues (v\&.size(),
318                        (int*) &dof_indices[0],
319                        const_cast<T*>(&v[0]));
320 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::insert (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$U=V$, where U and V are type NumericVector<T> and you want to specify WHERE to insert the NumericVector<T> V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 325 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::size()\&.
.PP
.nf
327 {
328   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
329 
330   // TODO: If V is an EpetraVector this can be optimized
331   for (unsigned int i=0; i<V\&.size(); i++)
332     this->set (dof_indices[i], V(i));
333 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::insert (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=V $ where V is type DenseVector<T> and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 338 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::DenseVector< T >::size()\&.
.PP
.nf
340 {
341   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
342   libmesh_assert_equal_to (sizeof(numeric_index_type), sizeof(int));
343 
344   std::vector<T> &vals = const_cast<DenseVector<T>&>(v)\&.get_values();
345 
346   ReplaceGlobalValues (v\&.size(),
347                        (int*) &dof_indices[0],
348                        &vals[0]);
349 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::insert (const \fBDenseSubVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=V $ where V is type DenseSubVector<T> and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 354 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::DenseVectorBase< T >::size()\&.
.PP
.nf
356 {
357   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
358 
359   for (unsigned int i=0; i < v\&.size(); ++i)
360     this->set (dof_indices[i], v(i));
361 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::EpetraVector\fP< T >::l1_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_1$-norm of the vector, i\&.e\&. the sum of the absolute values\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 67 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
68 {
69   libmesh_assert(this->closed());
70 
71   Real value;
72 
73   _vec->Norm1(&value);
74 
75   return value;
76 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::EpetraVector\fP< T >::l2_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_2$-norm of the vector, i\&.e\&. the square root of the sum of the squares of the elements\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 79 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
80 {
81   libmesh_assert(this->closed());
82 
83   Real value;
84 
85   _vec->Norm2(&value);
86 
87   return value;
88 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::EpetraVector\fP< T >::last_local_index () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the last vector element actually stored on this processor 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 989 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
990 {
991   libmesh_assert (this->initialized());
992 
993   return _vec->Map()\&.MaxMyGID()+1;
994 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::EpetraVector\fP< T >::linfty_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum absolute value of the elements of this vector, which is the $l_\infty$-norm of a vector\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 91 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
92 {
93   libmesh_assert(this->closed());
94 
95   Real value;
96 
97   _vec->NormInf(&value);
98 
99   return value;
100 }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::local_relative_compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given local relative \fCthreshold\fP\&. When differences occur, the return value contains the first index where the difference \fC\fP(a[i]-b[i])/max(a[i],b[i]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 144 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), and std::max()\&.
.PP
.nf
146 {
147   libmesh_assert (this->initialized());
148   libmesh_assert (other_vector\&.initialized());
149   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
150   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
151 
152   int first_different_i = std::numeric_limits<int>::max();
153   numeric_index_type i = first_local_index();
154 
155   do
156     {
157       if ( std::abs( (*this)(i) - other_vector(i) ) > threshold *
158            std::max(std::abs((*this)(i)), std::abs(other_vector(i))))
159         first_different_i = i;
160       else
161         i++;
162     }
163   while (first_different_i==std::numeric_limits<int>::max()
164          && i<last_local_index());
165 
166   // Find the correct first differing index in parallel
167   this->comm()\&.min(first_different_i);
168 
169   if (first_different_i == std::numeric_limits<int>::max())
170     return -1;
171 
172   return first_different_i;
173 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::EpetraVector\fP< T >::local_size () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the local size of the vector (index_stop-index_start) 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 969 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
970 {
971   libmesh_assert (this->initialized());
972 
973   return _vec->MyLength();
974 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::localize (std::vector< T > &v_local) const\fC [virtual]\fP"
Creates a copy of the global vector in the local vector \fCv_local\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 550 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::comm, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::EpetraVector< T >::localize()\&.
.PP
.nf
551 {
552   // This function must be run on all processors at once
553   parallel_object_only();
554 
555   const unsigned int n  = this->size();
556   const unsigned int nl = this->local_size();
557 
558   libmesh_assert(this->_vec);
559 
560   v_local\&.clear();
561   v_local\&.reserve(n);
562 
563   // build up my local part
564   for (unsigned int i=0; i<nl; i++)
565     v_local\&.push_back((*this->_vec)[i]);
566 
567   this->comm()\&.allgather (v_local);
568 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::localize (\fBNumericVector\fP< T > &v_local) const\fC [virtual]\fP"
Same, but fills a \fCNumericVector<T>\fP instead of a \fCstd::vector\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 478 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec\&.
.PP
.nf
479 {
480   EpetraVector<T>* v_local = libmesh_cast_ptr<EpetraVector<T>*>(&v_local_in);
481 
482   Epetra_Map rootMap = Epetra_Util::Create_Root_Map( *_map, -1);
483   v_local->_vec->ReplaceMap(rootMap);
484 
485   Epetra_Import importer(v_local->_vec->Map(), *_map);
486   v_local->_vec->Import(*_vec, importer, Insert);
487 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::localize (\fBNumericVector\fP< T > &v_local, const std::vector< \fBnumeric_index_type\fP > &send_list) const\fC [virtual]\fP"
Creates a local vector \fCv_local\fP containing only information relevant to this processor, as defined by the \fCsend_list\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 492 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
494 {
495   // TODO: optimize to sync only the send list values
496   this->localize(v_local_in);
497 
498   //   EpetraVector<T>* v_local =
499   //   libmesh_cast_ptr<EpetraVector<T>*>(&v_local_in);
500 
501   //   libmesh_assert(this->_map\&.get());
502   //   libmesh_assert(v_local->_map\&.get());
503   //   libmesh_assert_equal_to (v_local->local_size(), this->size());
504   //   libmesh_assert_less_equal (send_list\&.size(), v_local->size());
505 
506   //   Epetra_Import importer (*v_local->_map, *this->_map);
507 
508   //   v_local->_vec->Import (*this->_vec, importer, Insert);
509 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::localize (const \fBnumeric_index_type\fPfirst_local_idx, const \fBnumeric_index_type\fPlast_local_idx, const std::vector< \fBnumeric_index_type\fP > &send_list)\fC [virtual]\fP"
Updates a local vector with selected values from neighboring processors, as defined by \fCsend_list\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 513 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::close(), libMesh::comm, libMesh::EpetraVector< T >::init(), libMesh::libmesh_assert_greater(), libMesh::EpetraVector< T >::localize(), libMesh::PARALLEL, and libMesh::EpetraVector< T >::set()\&.
.PP
.nf
516 {
517   // Only good for serial vectors\&.
518   libmesh_assert_equal_to (this->size(), this->local_size());
519   libmesh_assert_greater (last_local_idx, first_local_idx);
520   libmesh_assert_less_equal (send_list\&.size(), this->size());
521   libmesh_assert_less (last_local_idx, this->size());
522 
523   const unsigned int my_size       = this->size();
524   const unsigned int my_local_size = (last_local_idx - first_local_idx + 1);
525 
526   // Don't bother for serial cases
527   if ((first_local_idx == 0) &&
528       (my_local_size == my_size))
529     return;
530 
531   // Build a parallel vector, initialize it with the local
532   // parts of (*this)
533   EpetraVector<T> parallel_vec(this->comm(), PARALLEL);
534 
535   parallel_vec\&.init (my_size, my_local_size, true, PARALLEL);
536 
537   // Copy part of *this into the parallel_vec
538   for (numeric_index_type i=first_local_idx; i<=last_local_idx; i++)
539     parallel_vec\&.set(i,this->el(i));
540 
541   // localize like normal
542   parallel_vec\&.close();
543   parallel_vec\&.localize (*this, send_list);
544   this->close();
545 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::localize_to_one (std::vector< T > &v_local, const \fBprocessor_id_type\fPproc_id = \fC0\fP) const\fC [virtual]\fP"
Creates a local copy of the global vector in \fCv_local\fP only on processor \fCproc_id\fP\&. By default the data is sent to processor 0\&. This method is useful for outputting data from one processor\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 573 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::comm, libMesh::libmesh_assert(), and libMesh::n_processors()\&.
.PP
.nf
575 {
576   // This function must be run on all processors at once
577   parallel_object_only();
578 
579   const unsigned int n  = this->size();
580   const unsigned int nl = this->local_size();
581 
582   libmesh_assert_less (pid, this->n_processors());
583   libmesh_assert(this->_vec);
584 
585   v_local\&.clear();
586   v_local\&.reserve(n);
587 
588 
589   // build up my local part
590   for (unsigned int i=0; i<nl; i++)
591     v_local\&.push_back((*this->_vec)[i]);
592 
593   this->comm()\&.gather (pid, v_local);
594 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::EpetraVector\fP< T >::max () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum element in the vector\&. In case of complex numbers, this returns the maximum Real part\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1027 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1028 {
1029   libmesh_assert (this->initialized());
1030 
1031   T value;
1032 
1033   _vec->MaxValue(&value);
1034 
1035   return value;
1036 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::EpetraVector\fP< T >::min () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the minimum element in the vector\&. In case of complex numbers, this returns the minimum Real part\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1012 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1013 {
1014   libmesh_assert (this->initialized());
1015 
1016   T value;
1017 
1018   _vec->MinValue(&value);
1019 
1020   return value;
1021 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "template<typename T > T \fBlibMesh::EpetraVector\fP< T >::operator() (const \fBnumeric_index_type\fPi) const\fC [inline]\fP, \fC [virtual]\fP"
Access components, returns \fCU(i)\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 999 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1000 {
1001   libmesh_assert (this->initialized());
1002   libmesh_assert ( ((i >= this->first_local_index()) &&
1003                     (i <  this->last_local_index())) );
1004 
1005   return (*_vec)[i-this->first_local_index()];
1006 }
.fi
.SS "template<typename T> \fBNumericVector\fP<T>& \fBlibMesh::NumericVector\fP< T >::operator*= (const Ta)\fC [inline]\fP, \fC [inherited]\fP"
Multiplication operator\&. Equivalent to \fCU\&.scale(a)\fP 
.PP
Definition at line 368 of file numeric_vector\&.h\&.
.PP
.nf
368 { this->scale(a); return *this; }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator+= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
Addition operator\&. Fast equivalent to \fCU\&.add(1, V)\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 104 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), and libMesh::libmesh_assert()\&.
.PP
.nf
105 {
106   libmesh_assert(this->closed());
107 
108   this->add(1\&., v);
109 
110   return *this;
111 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator-= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
Subtraction operator\&. Fast equivalent to \fCU\&.add\fP(-1, V)\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 117 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), and libMesh::libmesh_assert()\&.
.PP
.nf
118 {
119   libmesh_assert(this->closed());
120 
121   this->add(-1\&., v);
122 
123   return *this;
124 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator/= (\fBNumericVector\fP< T > &v)\fC [virtual]\fP"
Pointwise Division operator\&. ie divide every entry in this vector by the entry in v 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 129 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::libmesh_assert(), and libMesh::NumericVector< T >::size()\&.
.PP
.nf
130 {
131   libmesh_assert(this->closed());
132   libmesh_assert_equal_to(size(), v\&.size());
133 
134   EpetraVector<T> & v_vec = libmesh_cast_ref<EpetraVector<T>&>(v);
135 
136   _vec->ReciprocalMultiply(1\&.0, *v_vec\&._vec, *_vec, 0\&.0);
137 }
.fi
.SS "template<typename T> \fBNumericVector\fP<T>& \fBlibMesh::NumericVector\fP< T >::operator/= (const Ta)\fC [inline]\fP, \fC [inherited]\fP"
Division operator\&. Equivalent to \fCU\&.scale\fP(1\&./a) 
.PP
Definition at line 374 of file numeric_vector\&.h\&.
.PP
.nf
374 { this->scale(1\&./a); return *this; }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator= (const Ts)\fC [virtual]\fP"
Change the dimension to that of the vector \fCV\fP\&. The same applies as for the other \fCinit\fP function\&.
.PP
The elements of \fCV\fP are not copied, i\&.e\&. this function is the same as calling \fCinit\fP(V\&.size(),fast)\&. $U(0-N) = s$: fill all components\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 404 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
405 {
406   _vec->PutScalar(s_in);
407 
408   return *this;
409 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
$U = V$: copy all components\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 415 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
416 {
417   const EpetraVector<T>* v = libmesh_cast_ptr<const EpetraVector<T>*>(&v_in);
418 
419   *this = *v;
420 
421   return *this;
422 }
.fi
.SS "template<typename T > \fBEpetraVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator= (const \fBEpetraVector\fP< T > &V)"
$U = V$: copy all components\&. 
.PP
Definition at line 428 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec\&.
.PP
.nf
429 {
430   (*_vec) = *v\&._vec;
431 
432   // FIXME - what about our communications data?
433 
434   return *this;
435 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::EpetraVector\fP< T >::operator= (const std::vector< T > &v)\fC [virtual]\fP"
$U = V$: copy all components\&. Case 1: The vector is the same size of The global vector\&. Only add the local components\&.
.PP
Case 2: The vector is the same size as our local piece\&. Insert directly to the local piece\&.
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 441 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
442 {
443   T * values = _vec->Values();
444 
449   if(this->size() == v\&.size())
450     {
451       const unsigned int nl=this->local_size();
452       const unsigned int fli=this->first_local_index();
453 
454       for(unsigned int i=0;i<nl;i++)
455         values[i]=v[fli+i];
456     }
457 
462   else
463     {
464       libmesh_assert_equal_to (v\&.size(), this->local_size());
465 
466       const unsigned int nl=this->local_size();
467 
468       for(unsigned int i=0;i<nl;i++)
469         values[i]=v[i];
470     }
471 
472   return *this;
473 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::pointwise_mult (const \fBNumericVector\fP< T > &vec1, const \fBNumericVector\fP< T > &vec2)\fC [virtual]\fP"
Computes the pointwise (i\&.e\&. component-wise) product of \fCvec1\fP and \fCvec2\fP and stores the result in \fC*this\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 392 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::EpetraVector< T >::_vec\&.
.PP
.nf
394 {
395   const EpetraVector<T>* V1 = libmesh_cast_ptr<const EpetraVector<T>*>(&vec1);
396   const EpetraVector<T>* V2 = libmesh_cast_ptr<const EpetraVector<T>*>(&vec2);
397 
398   _vec->Multiply(1\&.0, *V1->_vec, *V2->_vec, 0\&.0);
399 }
.fi
.SS "template<typename T > void \fBlibMesh::NumericVector\fP< T >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Prints the local contents of the vector, by default to \fBlibMesh::out\fP 
.PP
Definition at line 830 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
831 {
832   libmesh_assert (this->initialized());
833   os << "Size\tglobal =  " << this->size()
834      << "\t\tlocal =  " << this->local_size() << std::endl;
835 
836   os << "#\tValue" << std::endl;
837   for (numeric_index_type i=this->first_local_index(); i<this->last_local_index(); i++)
838     os << i << "\t" << (*this)(i) << std::endl;
839 }
.fi
.SS "template<> void \fBlibMesh::NumericVector\fP< \fBComplex\fP >::print (std::ostream &os) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 812 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
813 {
814   libmesh_assert (this->initialized());
815   os << "Size\tglobal =  " << this->size()
816      << "\t\tlocal =  " << this->local_size() << std::endl;
817 
818   // std::complex<>::operator<<() is defined, but use this form
819   os << "#\tReal part\t\tImaginary part" << std::endl;
820   for (numeric_index_type i=this->first_local_index(); i<this->last_local_index(); i++)
821     os << i << "\t"
822        << (*this)(i)\&.real() << "\t\t"
823        << (*this)(i)\&.imag() << std::endl;
824 }
.fi
.SS "template<typename T > void \fBlibMesh::NumericVector\fP< T >::print_global (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Prints the global contents of the vector, by default to \fBlibMesh::out\fP 
.PP
Definition at line 867 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), libMesh::libmesh_assert(), and libMesh::processor_id()\&.
.PP
.nf
868 {
869   libmesh_assert (this->initialized());
870 
871   std::vector<T> v(this->size());
872   this->localize(v);
873 
874   // Right now we only want one copy of the output
875   if (this->processor_id())
876     return;
877 
878   os << "Size\tglobal =  " << this->size() << std::endl;
879   os << "#\tValue" << std::endl;
880   for (numeric_index_type i=0; i!=v\&.size(); i++)
881     os << i << "\t" << v[i] << std::endl;
882 }
.fi
.SS "template<> void \fBlibMesh::NumericVector\fP< \fBComplex\fP >::print_global (std::ostream &os) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 845 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), libMesh::libmesh_assert(), and libMesh::processor_id()\&.
.PP
.nf
846 {
847   libmesh_assert (this->initialized());
848 
849   std::vector<Complex> v(this->size());
850   this->localize(v);
851 
852   // Right now we only want one copy of the output
853   if (this->processor_id())
854     return;
855 
856   os << "Size\tglobal =  " << this->size() << std::endl;
857   os << "#\tReal part\t\tImaginary part" << std::endl;
858   for (numeric_index_type i=0; i!=v\&.size(); i++)
859     os << i << "\t"
860        << v[i]\&.real() << "\t\t"
861        << v[i]\&.imag() << std::endl;
862 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "template<typename T> virtual void \fBlibMesh::NumericVector\fP< T >::print_matlab (const std::string & = \fC''\fP) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Print the contents of the matrix in Matlab's sparse matrix format\&. Optionally prints the matrix to the file named \fCname\fP\&. If \fCname\fP is not specified it is dumped to the screen\&. 
.PP
Reimplemented in \fBlibMesh::PetscVector< T >\fP\&.
.PP
Definition at line 624 of file numeric_vector\&.h\&.
.PP
.nf
625   {
626     libmesh_not_implemented();
627   }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::reciprocal ()\fC [virtual]\fP"
Replace each entry v_i of this vector by its reciprocal, 1/v_i\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 158 of file trilinos_epetra_vector\&.C\&.
.PP
References std::abs(), libMesh::err, and std::min()\&.
.PP
.nf
159 {
160   // The Epetra::reciprocal() function takes a constant reference to *another* vector,
161   // and fills _vec with its reciprocal\&.  Does that mean we can't pass *_vec as the
162   // argument?
163   // _vec->reciprocal( *_vec );
164 
165   // Alternatively, compute the reciprocal by hand\&.\&.\&. see also the add(T) member that does this\&.\&.\&.
166   const unsigned int nl = _vec->MyLength();
167 
168   T* values = _vec->Values();
169 
170   for (unsigned int i=0; i<nl; i++)
171     {
172       // Don't divide by zero (maybe only check this in debug mode?)
173       if (std::abs(values[i]) < std::numeric_limits<T>::min())
174         {
175           libMesh::err << "Error, divide by zero in DistributedVector<T>::reciprocal()!" << std::endl;
176           libmesh_error();
177         }
178 
179       values[i] = 1\&. / values[i];
180     }
181 
182   // Leave the vector in a closed state\&.\&.\&.
183   this->close();
184 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::ReplaceGlobalValues (intnumIDs, const int *GIDs, const double *values)\fC [private]\fP"
Copy values into the vector overwriting any values that already exist for the specified indices\&. 
.PP
Definition at line 644 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
646 {
647   return( inputValues( numIDs, GIDs, values, false) );
648 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::ReplaceGlobalValues (const Epetra_IntSerialDenseVector &GIDs, const Epetra_SerialDenseVector &values)\fC [private]\fP"
Copy values into the vector, replacing any values that already exist for the specified GIDs\&.
.PP
\fBParameters:\fP
.RS 4
\fIGIDs\fP List of global ids\&. Must be the same length as the accompanying list of values\&.
.br
\fIvalues\fP List of coefficient values\&. Must be the same length as the accompanying list of GIDs\&. 
.RE
.PP

.PP
Definition at line 652 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
654 {
655   if (GIDs\&.Length() != values\&.Length()) {
656     return(-1);
657   }
658 
659   return( inputValues( GIDs\&.Length(), GIDs\&.Values(), values\&.Values(), false) );
660 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::ReplaceGlobalValues (intnumIDs, const int *GIDs, const int *numValuesPerID, const double *values)\fC [private]\fP"

.PP
Definition at line 664 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
667 {
668   return( inputValues( numIDs, GIDs, numValuesPerID, values, false) );
669 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::scale (const Tfactor)\fC [virtual]\fP"
Scale each element of the vector by the given factor\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 366 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
367 {
368   _vec->Scale(factor_in);
369 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::set (const \fBnumeric_index_type\fPi, const Tvalue)\fC [virtual]\fP"
v(i) = value 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 143 of file trilinos_epetra_vector\&.C\&.
.PP
Referenced by libMesh::EpetraVector< T >::localize()\&.
.PP
.nf
144 {
145   int i = static_cast<int> (i_in);
146   T value = value_in;
147 
148   libmesh_assert_less (i_in, this->size());
149 
150   ReplaceGlobalValues(1, &i, &value);
151 
152   this->_is_closed = false;
153 }
.fi
.SS "template<typename T> void \fBlibMesh::EpetraVector\fP< T >::setIgnoreNonLocalEntries (boolflag)\fC [inline]\fP, \fC [private]\fP"
Set whether or not non-local data values should be ignored\&. 
.PP
Definition at line 584 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::ignoreNonLocalEntries_\&.
.PP
.nf
584                                            {
585     ignoreNonLocalEntries_ = flag;
586   }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::EpetraVector\fP< T >::size () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
dimension of the vector\&. This function was formerly called \fCn()\fP, but was renamed to get the \fCEpetraVector<T>\fP class closer to the C++ standard library's \fCstd::vector\fP container\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 958 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::EpetraVector< T >::add()\&.
.PP
.nf
959 {
960   libmesh_assert (this->initialized());
961 
962   return _vec->GlobalLength();
963 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_l1_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_1$-norm of the vector, i\&.e\&. the sum of the absolute values for the specified entries in the vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 320 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
321 {
322   const NumericVector<T> & v = *this;
323 
324   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
325   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
326 
327   Real norm = 0;
328 
329   for(; it!=it_end; ++it)
330     norm += std::abs(v(*it));
331 
332   this->comm()\&.sum(norm);
333 
334   return norm;
335 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_l2_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_2$-norm of the vector, i\&.e\&. the square root of the sum of the squares of the elements for the specified entries in the vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 338 of file numeric_vector\&.C\&.
.PP
References libMesh::comm, libMesh::TensorTools::norm_sq(), and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
339 {
340   const NumericVector<T> & v = *this;
341 
342   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
343   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
344 
345   Real norm = 0;
346 
347   for(; it!=it_end; ++it)
348     norm += TensorTools::norm_sq(v(*it));
349 
350   this->comm()\&.sum(norm);
351 
352   return std::sqrt(norm);
353 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_linfty_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum absolute value of the specified entries of this vector, which is the $l_\infty$-norm of a vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 356 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
357 {
358   const NumericVector<T> & v = *this;
359 
360   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
361   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
362 
363   Real norm = 0;
364 
365   for(; it!=it_end; ++it)
366     {
367       Real value = std::abs(v(*it));
368       if(value > norm)
369         norm = value;
370     }
371 
372   this->comm()\&.max(norm);
373 
374   return norm;
375 }
.fi
.SS "template<typename T > T \fBlibMesh::EpetraVector\fP< T >::sum () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the sum of values in a vector 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 48 of file trilinos_epetra_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::comm, libMesh::libmesh_assert(), and libMesh::Parallel::sum()\&.
.PP
.nf
49 {
50   libmesh_assert(this->closed());
51 
52   const unsigned int nl = _vec->MyLength();
53 
54   T sum=0\&.0;
55 
56   T * values = _vec->Values();
57 
58   for (unsigned int i=0; i<nl; i++)
59     sum += values[i];
60 
61   this->comm()\&.sum(sum);
62 
63   return sum;
64 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::SumIntoGlobalValues (intnumIDs, const int *GIDs, const double *values)\fC [private]\fP"
Accumulate values into the vector, adding them to any values that already exist for the specified indices\&. 
.PP
Definition at line 615 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
617 {
618   return( inputValues( numIDs, GIDs, values, true) );
619 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::SumIntoGlobalValues (const Epetra_IntSerialDenseVector &GIDs, const Epetra_SerialDenseVector &values)\fC [private]\fP"
Accumulate values into the vector, adding them to any values that already exist for the specified GIDs\&.
.PP
\fBParameters:\fP
.RS 4
\fIGIDs\fP List of global ids\&. Must be the same length as the accompanying list of values\&.
.br
\fIvalues\fP List of coefficient values\&. Must be the same length as the accompanying list of GIDs\&. 
.RE
.PP

.PP
Definition at line 623 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
625 {
626   if (GIDs\&.Length() != values\&.Length()) {
627     return(-1);
628   }
629 
630   return( inputValues( GIDs\&.Length(), GIDs\&.Values(), values\&.Values(), true) );
631 }
.fi
.SS "template<typename T > int \fBlibMesh::EpetraVector\fP< T >::SumIntoGlobalValues (intnumIDs, const int *GIDs, const int *numValuesPerID, const double *values)\fC [private]\fP"

.PP
Definition at line 635 of file trilinos_epetra_vector\&.C\&.
.PP
.nf
638 {
639   return( inputValues( numIDs, GIDs, numValuesPerID, values, true) );
640 }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::swap (\fBNumericVector\fP< T > &v)\fC [inline]\fP, \fC [virtual]\fP"
Swaps the raw Epetra vector context pointers\&. 
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1042 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::_destroy_vec_on_exit, libMesh::EpetraVector< T >::_map, libMesh::EpetraVector< T >::_vec, libMesh::EpetraVector< T >::allocatedNonlocalLength_, libMesh::EpetraVector< T >::ignoreNonLocalEntries_, libMesh::EpetraVector< T >::last_edit, libMesh::EpetraVector< T >::myCoefs_, libMesh::EpetraVector< T >::myFirstID_, libMesh::EpetraVector< T >::myNumIDs_, libMesh::EpetraVector< T >::nonlocalCoefs_, libMesh::EpetraVector< T >::nonlocalElementSize_, libMesh::EpetraVector< T >::nonlocalIDs_, libMesh::EpetraVector< T >::numNonlocalIDs_, libMesh::swap(), and libMesh::NumericVector< T >::swap()\&.
.PP
.nf
1043 {
1044   NumericVector<T>::swap(other);
1045 
1046   EpetraVector<T>& v = libmesh_cast_ref<EpetraVector<T>&>(other);
1047 
1048   std::swap(_vec, v\&._vec);
1049   std::swap(_map, v\&._map);
1050   std::swap(_destroy_vec_on_exit, v\&._destroy_vec_on_exit);
1051   std::swap(myFirstID_, v\&.myFirstID_);
1052   std::swap(myNumIDs_, v\&.myNumIDs_);
1053   std::swap(myCoefs_, v\&.myCoefs_);
1054   std::swap(nonlocalIDs_, v\&.nonlocalIDs_);
1055   std::swap(nonlocalElementSize_, v\&.nonlocalElementSize_);
1056   std::swap(numNonlocalIDs_, v\&.numNonlocalIDs_);
1057   std::swap(allocatedNonlocalLength_, v\&.allocatedNonlocalLength_);
1058   std::swap(nonlocalCoefs_, v\&.nonlocalCoefs_);
1059   std::swap(last_edit, v\&.last_edit);
1060   std::swap(ignoreNonLocalEntries_, v\&.ignoreNonLocalEntries_);
1061 }
.fi
.SS "template<typename T> \fBParallelType\fP \fBlibMesh::NumericVector\fP< T >::type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the type (SERIAL, PARALLEL, GHOSTED) of the vector\&. 
.RE
.PP

.PP
Definition at line 134 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::EpetraVector< T >::EpetraVector(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::DistributedVector< T >::init(), libMesh::LaspackVector< T >::init(), libMesh::EigenSparseVector< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::localize(), libMesh::MeshFunction::operator()(), libMesh::PetscVector< T >::operator=(), libMesh::System::project_vector(), and libMesh::System::read_serialized_vector()\&.
.PP
.nf
134 { return _type; }
.fi
.SS "template<typename T> \fBParallelType\fP& \fBlibMesh::NumericVector\fP< T >::type ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the type (SERIAL, PARALLEL, GHOSTED) of the vector\&. 
.RE
.PP

.PP
Definition at line 139 of file numeric_vector\&.h\&.
.PP
.nf
139 { return _type; }
.fi
.SS "template<typename T> Epetra_Vector* \fBlibMesh::EpetraVector\fP< T >::vec ()\fC [inline]\fP"
Returns the raw PETSc vector context pointer\&. Note this is generally not required in user-level code\&. Just don't do anything crazy like calling LibMeshVecDestroy()! 
.PP
Definition at line 501 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::EpetraVector< T >::_vec, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::EpetraMatrix< T >::get_diagonal(), and libMesh::NoxNonlinearSolver< T >::solve()\&.
.PP
.nf
501 { libmesh_assert(_vec); return _vec; }
.fi
.SS "template<typename T > void \fBlibMesh::EpetraVector\fP< T >::zero ()\fC [inline]\fP, \fC [virtual]\fP"
Set all entries to zero\&. Equivalent to \fCv\fP = 0, but more obvious and faster\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 916 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::closed(), libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
917 {
918   libmesh_assert (this->initialized());
919   libmesh_assert (this->closed());
920 
921   _vec->PutScalar(0\&.0);
922 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::EpetraVector\fP< T >::zero_clone () const\fC [inline]\fP, \fC [virtual]\fP"
Creates a vector which has the same type, size and partitioning as this vector, but whose data is all zero\&. Returns it in an \fC\fBAutoPtr\fP\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 928 of file trilinos_epetra_vector\&.h\&.
.PP
References libMesh::AUTOMATIC, and libMesh::comm\&.
.PP
Referenced by libMesh::EpetraVector< T >::add_vector()\&.
.PP
.nf
929 {
930   AutoPtr<NumericVector<T> > cloned_vector
931     (new EpetraVector<T>(this->comm(), AUTOMATIC));
932 
933   cloned_vector->init(*this);
934 
935   return cloned_vector;
936 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "template<typename T> bool \fBlibMesh::EpetraVector\fP< T >::_destroy_vec_on_exit\fC [private]\fP"
This boolean value should only be set to false for the constructor which takes a Epetra Vec object\&. 
.PP
Definition at line 520 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "template<typename T> bool \fBlibMesh::NumericVector\fP< T >::_is_closed\fC [protected]\fP, \fC [inherited]\fP"
Flag to see if the Numeric assemble routines have been called yet 
.PP
Definition at line 655 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::NumericVector< Number >::closed(), libMesh::DistributedVector< T >::localize(), and libMesh::DistributedVector< T >::operator=()\&.
.SS "template<typename T> bool \fBlibMesh::NumericVector\fP< T >::_is_initialized\fC [protected]\fP, \fC [inherited]\fP"
Flag to tell if init has been called yet 
.PP
Definition at line 661 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::create_subvector(), libMesh::NumericVector< Number >::initialized(), libMesh::DistributedVector< T >::localize(), and libMesh::DistributedVector< T >::operator=()\&.
.SS "template<typename T> Epetra_Map* \fBlibMesh::EpetraVector\fP< T >::_map\fC [private]\fP"
Holds the distributed Map 
.PP
Definition at line 514 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "template<typename T> \fBParallelType\fP \fBlibMesh::NumericVector\fP< T >::_type\fC [protected]\fP, \fC [inherited]\fP"
Type of vector 
.PP
Definition at line 666 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DistributedVector< T >::DistributedVector(), libMesh::EigenSparseVector< T >::EigenSparseVector(), libMesh::EpetraVector< T >::EpetraVector(), libMesh::PetscVector< T >::init(), libMesh::LaspackVector< T >::LaspackVector(), libMesh::PetscVector< T >::operator=(), libMesh::PetscVector< T >::PetscVector(), and libMesh::NumericVector< Number >::type()\&.
.SS "template<typename T> Epetra_Vector* \fBlibMesh::EpetraVector\fP< T >::_vec\fC [private]\fP"
Actual Epetra vector datatype to hold vector entries 
.PP
Definition at line 509 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::add(), libMesh::EpetraVector< T >::add_vector(), libMesh::EpetraVector< T >::dot(), libMesh::EpetraVector< T >::FEoperatorequals(), libMesh::EpetraVector< T >::localize(), libMesh::EpetraVector< T >::operator=(), libMesh::EpetraVector< T >::pointwise_mult(), libMesh::EpetraVector< T >::swap(), and libMesh::EpetraVector< T >::vec()\&.
.SS "template<typename T> int \fBlibMesh::EpetraVector\fP< T >::allocatedNonlocalLength_\fC [private]\fP"

.PP
Definition at line 613 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::FEoperatorequals(), and libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> bool \fBlibMesh::EpetraVector\fP< T >::ignoreNonLocalEntries_\fC [private]\fP"

.PP
Definition at line 623 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::setIgnoreNonLocalEntries(), and libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> unsigned char \fBlibMesh::EpetraVector\fP< T >::last_edit\fC [private]\fP"
Keep track of whether the last write operation on this vector was nothing (0) or a sum (1) or an add (2), so we can decide how to do the \fBGlobalAssemble()\fP 
.PP
Definition at line 621 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> double* \fBlibMesh::EpetraVector\fP< T >::myCoefs_\fC [private]\fP"

.PP
Definition at line 608 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> int \fBlibMesh::EpetraVector\fP< T >::myFirstID_\fC [private]\fP"

.PP
Definition at line 606 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> int \fBlibMesh::EpetraVector\fP< T >::myNumIDs_\fC [private]\fP"

.PP
Definition at line 607 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> double** \fBlibMesh::EpetraVector\fP< T >::nonlocalCoefs_\fC [private]\fP"

.PP
Definition at line 614 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::FEoperatorequals(), and libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> int* \fBlibMesh::EpetraVector\fP< T >::nonlocalElementSize_\fC [private]\fP"

.PP
Definition at line 611 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::FEoperatorequals(), and libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> int* \fBlibMesh::EpetraVector\fP< T >::nonlocalIDs_\fC [private]\fP"

.PP
Definition at line 610 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::FEoperatorequals(), and libMesh::EpetraVector< T >::swap()\&.
.SS "template<typename T> int \fBlibMesh::EpetraVector\fP< T >::numNonlocalIDs_\fC [private]\fP"

.PP
Definition at line 612 of file trilinos_epetra_vector\&.h\&.
.PP
Referenced by libMesh::EpetraVector< T >::FEoperatorequals(), and libMesh::EpetraVector< T >::swap()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
