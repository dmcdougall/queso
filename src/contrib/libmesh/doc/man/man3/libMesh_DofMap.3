.TH "libMesh::DofMap" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::DofMap \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <dof_map\&.h>\fP
.PP
Inherits \fBlibMesh::ReferenceCountedObject< DofMap >\fP, and \fBlibMesh::ParallelObject\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBAugmentSendList\fP"
.br
.ti -1c
.RI "class \fBAugmentSparsityPattern\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDofMap\fP (const unsigned int \fBsys_number\fP, const \fBParallelObject\fP &parent_decomp)"
.br
.ti -1c
.RI "\fB~DofMap\fP ()"
.br
.ti -1c
.RI "void \fBattach_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > &matrix)"
.br
.ti -1c
.RI "bool \fBis_attached\fP (\fBSparseMatrix\fP< \fBNumber\fP > &matrix)"
.br
.ti -1c
.RI "void \fBdistribute_dofs\fP (\fBMeshBase\fP &)"
.br
.ti -1c
.RI "void \fBcompute_sparsity\fP (const \fBMeshBase\fP &)"
.br
.ti -1c
.RI "void \fBclear_sparsity\fP ()"
.br
.ti -1c
.RI "void \fBattach_extra_sparsity_object\fP (\fBDofMap::AugmentSparsityPattern\fP &asp)"
.br
.ti -1c
.RI "void \fBattach_extra_sparsity_function\fP (void(*func)(\fBSparsityPattern::Graph\fP &sparsity, std::vector< \fBdof_id_type\fP > &n_nz, std::vector< \fBdof_id_type\fP > &n_oz, void *), void *context=NULL)"
.br
.ti -1c
.RI "void \fBattach_extra_send_list_object\fP (\fBDofMap::AugmentSendList\fP &asl)"
.br
.ti -1c
.RI "void \fBattach_extra_send_list_function\fP (void(*func)(std::vector< \fBdof_id_type\fP > &, void *), void *context=NULL)"
.br
.ti -1c
.RI "void \fBprepare_send_list\fP ()"
.br
.ti -1c
.RI "const std::vector< \fBdof_id_type\fP > & \fBget_send_list\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBdof_id_type\fP > & \fBget_n_nz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBdof_id_type\fP > & \fBget_n_oz\fP () const "
.br
.ti -1c
.RI "void \fBadd_variable_group\fP (const \fBVariableGroup\fP &var_group)"
.br
.ti -1c
.RI "const \fBVariableGroup\fP & \fBvariable_group\fP (const unsigned int c) const "
.br
.ti -1c
.RI "const \fBVariable\fP & \fBvariable\fP (const unsigned int c) const "
.br
.ti -1c
.RI "\fBOrder\fP \fBvariable_order\fP (const unsigned int c) const "
.br
.ti -1c
.RI "\fBOrder\fP \fBvariable_group_order\fP (const unsigned int vg) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_type\fP (const unsigned int c) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_group_type\fP (const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBn_variable_groups\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_variables\fP () const "
.br
.ti -1c
.RI "bool \fBhas_blocked_representation\fP () const "
.br
.ti -1c
.RI "unsigned int \fBblock_size\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_SCALAR_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_dofs_on_processor\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBfirst_dof\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBfirst_dof\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBfirst_old_dof\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBfirst_old_dof\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBlast_dof\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBlast_dof\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBend_dof\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBend_dof\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBend_old_dof\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBend_old_dof\fP () const "
.br
.ti -1c
.RI "void \fBdof_indices\fP (const \fBElem\fP *const elem, std::vector< \fBdof_id_type\fP > &di) const "
.br
.ti -1c
.RI "void \fBdof_indices\fP (const \fBElem\fP *const elem, std::vector< \fBdof_id_type\fP > &di, const unsigned int vn) const "
.br
.ti -1c
.RI "void \fBSCALAR_dof_indices\fP (std::vector< \fBdof_id_type\fP > &di, const unsigned int vn, const bool old_dofs=false) const "
.br
.ti -1c
.RI "bool \fBall_semilocal_indices\fP (const std::vector< \fBdof_id_type\fP > &\fBdof_indices\fP) const "
.br
.ti -1c
.RI "bool \fBuse_coupled_neighbor_dofs\fP (const \fBMeshBase\fP &\fBmesh\fP) const "
.br
.ti -1c
.RI "void \fBextract_local_vector\fP (const \fBNumericVector\fP< \fBNumber\fP > &Ug, const std::vector< \fBdof_id_type\fP > &\fBdof_indices\fP, \fBDenseVectorBase\fP< \fBNumber\fP > &Ue) const "
.br
.ti -1c
.RI "void \fBlocal_variable_indices\fP (std::vector< \fBdof_id_type\fP > &idx, const \fBMeshBase\fP &\fBmesh\fP, unsigned int var_num) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_constrained_nodes\fP () const "
.br
.ti -1c
.RI "void \fBcreate_dof_constraints\fP (const \fBMeshBase\fP &, \fBReal\fP time=0)"
.br
.ti -1c
.RI "void \fBallgather_recursive_constraints\fP (\fBMeshBase\fP &)"
.br
.ti -1c
.RI "void \fBscatter_constraints\fP (\fBMeshBase\fP &)"
.br
.ti -1c
.RI "void \fBprocess_constraints\fP (\fBMeshBase\fP &)"
.br
.ti -1c
.RI "void \fBadd_constraint_row\fP (const \fBdof_id_type\fP dof_number, const \fBDofConstraintRow\fP &constraint_row, const \fBNumber\fP constraint_rhs, const bool forbid_constraint_overwrite)"
.br
.ti -1c
.RI "void \fBadd_adjoint_constraint_row\fP (const unsigned int qoi_index, const \fBdof_id_type\fP dof_number, const \fBDofConstraintRow\fP &constraint_row, const \fBNumber\fP constraint_rhs, const bool forbid_constraint_overwrite)"
.br
.ti -1c
.RI "void \fBadd_constraint_row\fP (const \fBdof_id_type\fP dof_number, const \fBDofConstraintRow\fP &constraint_row, const bool forbid_constraint_overwrite=true)"
.br
.ti -1c
.RI "DofConstraints::const_iterator \fBconstraint_rows_begin\fP () const "
.br
.ti -1c
.RI "DofConstraints::const_iterator \fBconstraint_rows_end\fP () const "
.br
.ti -1c
.RI "NodeConstraints::const_iterator \fBnode_constraint_rows_begin\fP () const "
.br
.ti -1c
.RI "NodeConstraints::const_iterator \fBnode_constraint_rows_end\fP () const "
.br
.ti -1c
.RI "bool \fBis_constrained_dof\fP (const \fBdof_id_type\fP dof) const "
.br
.ti -1c
.RI "bool \fBhas_heterogenous_adjoint_constraint\fP (const unsigned int qoi_num, const \fBdof_id_type\fP dof) const "
.br
.ti -1c
.RI "bool \fBis_constrained_node\fP (const \fBNode\fP *node) const "
.br
.ti -1c
.RI "void \fBprint_dof_constraints\fP (std::ostream &os=\fBlibMesh::out\fP, bool print_nonlocal=false) const "
.br
.ti -1c
.RI "std::string \fBget_local_constraints\fP (bool print_nonlocal=false) const "
.br
.ti -1c
.RI "std::pair< \fBReal\fP, \fBReal\fP > \fBmax_constraint_error\fP (const \fBSystem\fP &system, \fBNumericVector\fP< \fBNumber\fP > *v=NULL) const "
.br
.ti -1c
.RI "void \fBconstrain_element_matrix\fP (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, std::vector< \fBdof_id_type\fP > &elem_dofs, bool asymmetric_constraint_rows=true) const "
.br
.ti -1c
.RI "void \fBconstrain_element_matrix\fP (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, std::vector< \fBdof_id_type\fP > &row_dofs, std::vector< \fBdof_id_type\fP > &col_dofs, bool asymmetric_constraint_rows=true) const "
.br
.ti -1c
.RI "void \fBconstrain_element_vector\fP (\fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &dofs, bool asymmetric_constraint_rows=true) const "
.br
.ti -1c
.RI "void \fBconstrain_element_matrix_and_vector\fP (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, bool asymmetric_constraint_rows=true) const "
.br
.ti -1c
.RI "void \fBheterogenously_constrain_element_matrix_and_vector\fP (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, bool asymmetric_constraint_rows=true, int qoi_index=-1) const "
.br
.ti -1c
.RI "void \fBheterogenously_constrain_element_vector\fP (const \fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, bool asymmetric_constraint_rows=true, int qoi_index=-1) const "
.br
.ti -1c
.RI "void \fBconstrain_element_dyad_matrix\fP (\fBDenseVector\fP< \fBNumber\fP > &v, \fBDenseVector\fP< \fBNumber\fP > &w, std::vector< \fBdof_id_type\fP > &row_dofs, bool asymmetric_constraint_rows=true) const "
.br
.ti -1c
.RI "void \fBconstrain_nothing\fP (std::vector< \fBdof_id_type\fP > &dofs) const "
.br
.ti -1c
.RI "void \fBenforce_constraints_exactly\fP (const \fBSystem\fP &system, \fBNumericVector\fP< \fBNumber\fP > *v=NULL, bool homogeneous=false) const "
.br
.ti -1c
.RI "void \fBenforce_adjoint_constraints_exactly\fP (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned int q) const "
.br
.ti -1c
.RI "void \fBadd_periodic_boundary\fP (const \fBPeriodicBoundaryBase\fP &periodic_boundary)"
.br
.ti -1c
.RI "void \fBadd_periodic_boundary\fP (const \fBPeriodicBoundaryBase\fP &boundary, const \fBPeriodicBoundaryBase\fP &inverse_boundary)"
.br
.ti -1c
.RI "bool \fBis_periodic_boundary\fP (const \fBboundary_id_type\fP boundaryid) const "
.br
.ti -1c
.RI "\fBPeriodicBoundaries\fP * \fBget_periodic_boundaries\fP ()"
.br
.ti -1c
.RI "void \fBadd_dirichlet_boundary\fP (const \fBDirichletBoundary\fP &dirichlet_boundary)"
.br
.ti -1c
.RI "void \fBadd_adjoint_dirichlet_boundary\fP (const \fBDirichletBoundary\fP &dirichlet_boundary, unsigned int q)"
.br
.ti -1c
.RI "void \fBremove_dirichlet_boundary\fP (const \fBDirichletBoundary\fP &dirichlet_boundary)"
.br
.ti -1c
.RI "void \fBremove_adjoint_dirichlet_boundary\fP (const \fBDirichletBoundary\fP &dirichlet_boundary, unsigned int q)"
.br
.ti -1c
.RI "const \fBDirichletBoundaries\fP * \fBget_dirichlet_boundaries\fP () const "
.br
.ti -1c
.RI "\fBDirichletBoundaries\fP * \fBget_dirichlet_boundaries\fP ()"
.br
.ti -1c
.RI "bool \fBhas_adjoint_dirichlet_boundaries\fP (unsigned int q) const "
.br
.ti -1c
.RI "const \fBDirichletBoundaries\fP * \fBget_adjoint_dirichlet_boundaries\fP (unsigned int q) const "
.br
.ti -1c
.RI "\fBDirichletBoundaries\fP * \fBget_adjoint_dirichlet_boundaries\fP (unsigned int q)"
.br
.ti -1c
.RI "void \fBold_dof_indices\fP (const \fBElem\fP *const elem, std::vector< \fBdof_id_type\fP > &di, const unsigned int vn=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_old_dofs\fP () const "
.br
.ti -1c
.RI "void \fBconstrain_p_dofs\fP (unsigned int var, const \fBElem\fP *elem, unsigned int s, unsigned int p)"
.br
.ti -1c
.RI "void \fBreinit\fP (\fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "unsigned int \fBsys_number\fP () const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBCouplingMatrix\fP * \fB_dof_coupling\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef \fBDofObject\fP *(DofMap::* \fBdofobject_accessor\fP )(\fBMeshBase\fP &\fBmesh\fP, \fBdof_id_type\fP i) const "
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fB_dof_indices\fP (const \fBElem\fP *const elem, std::vector< \fBdof_id_type\fP > &di, const unsigned int v, const std::vector< \fBNode\fP * > &elem_nodes#ifdef DEBUG, unsigned int &tot_size#endif) const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparsityPattern::Build\fP > \fBbuild_sparsity\fP (const \fBMeshBase\fP &\fBmesh\fP) const "
.br
.ti -1c
.RI "void \fBinvalidate_dofs\fP (\fBMeshBase\fP &\fBmesh\fP) const "
.br
.ti -1c
.RI "\fBDofObject\fP * \fBnode_ptr\fP (\fBMeshBase\fP &\fBmesh\fP, \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "\fBDofObject\fP * \fBelem_ptr\fP (\fBMeshBase\fP &\fBmesh\fP, \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "template<typename iterator_type > void \fBset_nonlocal_dof_objects\fP (iterator_type objects_begin, iterator_type objects_end, \fBMeshBase\fP &\fBmesh\fP, \fBdofobject_accessor\fP objects)"
.br
.ti -1c
.RI "void \fBdistribute_local_dofs_var_major\fP (\fBdof_id_type\fP &next_free_dof, \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "void \fBdistribute_local_dofs_node_major\fP (\fBdof_id_type\fP &next_free_dof, \fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "void \fBadd_neighbors_to_send_list\fP (\fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "void \fBbuild_constraint_matrix\fP (\fBDenseMatrix\fP< \fBNumber\fP > &C, std::vector< \fBdof_id_type\fP > &elem_dofs, const bool called_recursively=false) const "
.br
.ti -1c
.RI "void \fBbuild_constraint_matrix_and_vector\fP (\fBDenseMatrix\fP< \fBNumber\fP > &C, \fBDenseVector\fP< \fBNumber\fP > &H, std::vector< \fBdof_id_type\fP > &elem_dofs, int qoi_index=-1, const bool called_recursively=false) const "
.br
.ti -1c
.RI "void \fBfind_connected_dofs\fP (std::vector< \fBdof_id_type\fP > &elem_dofs) const "
.br
.ti -1c
.RI "void \fBfind_connected_dof_objects\fP (std::vector< const \fBDofObject\fP * > &objs) const "
.br
.ti -1c
.RI "void \fBadd_constraints_to_send_list\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBVariable\fP > \fB_variables\fP"
.br
.ti -1c
.RI "std::vector< \fBVariableGroup\fP > \fB_variable_groups\fP"
.br
.ti -1c
.RI "const unsigned int \fB_sys_number\fP"
.br
.ti -1c
.RI "std::vector< \fBSparseMatrix\fP
.br
< \fBNumber\fP > * > \fB_matrices\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fB_first_df\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fB_end_df\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fB_send_list\fP"
.br
.ti -1c
.RI "\fBAugmentSparsityPattern\fP * \fB_augment_sparsity_pattern\fP"
.br
.ti -1c
.RI "void(* \fB_extra_sparsity_function\fP )(\fBSparsityPattern::Graph\fP &, std::vector< \fBdof_id_type\fP > &n_nz, std::vector< \fBdof_id_type\fP > &n_oz, void *)"
.br
.ti -1c
.RI "void * \fB_extra_sparsity_context\fP"
.br
.ti -1c
.RI "\fBAugmentSendList\fP * \fB_augment_send_list\fP"
.br
.ti -1c
.RI "void(* \fB_extra_send_list_function\fP )(std::vector< \fBdof_id_type\fP > &, void *)"
.br
.ti -1c
.RI "void * \fB_extra_send_list_context\fP"
.br
.ti -1c
.RI "bool \fBneed_full_sparsity_pattern\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparsityPattern::Build\fP > \fB_sp\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > * \fB_n_nz\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > * \fB_n_oz\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_n_dfs\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_n_SCALAR_dofs\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_n_old_dfs\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fB_first_old_df\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fB_end_old_df\fP"
.br
.ti -1c
.RI "\fBDofConstraints\fP \fB_dof_constraints\fP"
.br
.ti -1c
.RI "\fBDofConstraintValueMap\fP \fB_primal_constraint_values\fP"
.br
.ti -1c
.RI "\fBAdjointDofConstraintValues\fP \fB_adjoint_constraint_values\fP"
.br
.ti -1c
.RI "\fBNodeConstraints\fP \fB_node_constraints\fP"
.br
.ti -1c
.RI "\fBPeriodicBoundaries\fP * \fB_periodic_boundaries\fP"
.br
.ti -1c
.RI "\fBDirichletBoundaries\fP * \fB_dirichlet_boundaries\fP"
.br
.ti -1c
.RI "std::vector
.br
< \fBDirichletBoundaries\fP * > \fB_adjoint_dirichlet_boundaries\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBSparsityPattern::Build\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class handles the numbering of degrees of freedom on a mesh\&. For systems of equations the class supports a fixed number of variables\&. The degrees of freedom are numbered such that sequential, contiguous blocks correspond to distinct subdomains\&. This is so that the resulting data structures will work well with parallel linear algebra packages\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2002-2007 
.RE
.PP

.PP
Definition at line 167 of file dof_map\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBDofObject\fP*(DofMap::* libMesh::DofMap::dofobject_accessor)(\fBMeshBase\fP &\fBmesh\fP, \fBdof_id_type\fP i) const \fC [private]\fP"
A member function type like node_ptr or elem_ptr 
.PP
Definition at line 1099 of file dof_map\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::DofMap::DofMap (const unsigned intsys_number, const \fBParallelObject\fP &parent_decomp)\fC [explicit]\fP"
Constructor\&. Requires the number of the system for which we will be numbering degrees of freedom & the parent object we are contained in, which defines our communication space\&. 
.PP
Definition at line 177 of file dof_map\&.C\&.
.PP
References _adjoint_dirichlet_boundaries, _dirichlet_boundaries, _periodic_boundaries, and clear()\&.
.PP
.nf
178 {
179   this->clear();
180 #ifdef LIBMESH_ENABLE_PERIODIC
181   delete _periodic_boundaries;
182 #endif
183 #ifdef LIBMESH_ENABLE_DIRICHLET
184   delete _dirichlet_boundaries;
185   for (unsigned int q = 0; q != _adjoint_dirichlet_boundaries\&.size(); ++q)
186     delete _adjoint_dirichlet_boundaries[q];
187 #endif
188 }
.fi
.SS "libMesh::DofMap::~DofMap ()"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::DofMap::_dof_indices (const \fBElem\fP *constelem, std::vector< \fBdof_id_type\fP > &di, const unsigned intv, const std::vector< \fBNode\fP * > &elem_nodes#ifdefDEBUG, unsigned int &tot_size#endif) const\fC [private]\fP"
Helper function that gets the dof indices on the current element for a non-SCALAR type variable\&.
.PP
\fBParameters:\fP
.RS 4
\fItot_size\fP In DEBUG mode this will add up the total number of dof indices that should have been added to di\&. 
.RE
.PP

.PP
Definition at line 1911 of file dof_map\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::dim, libMesh::Elem::dim(), libMesh::DofObject::dof_number(), libMesh::FEInterface::extra_hanging_dofs(), libMesh::FEType::family, libMesh::DofObject::invalid_id, libMesh::Elem::is_vertex(), libMesh::LAGRANGE, libMesh::libmesh_assert(), libMesh::DofObject::n_comp(), libMesh::FEInterface::n_dofs(), libMesh::FEInterface::n_dofs_at_node(), libMesh::FEInterface::n_dofs_per_elem(), libMesh::DofObject::n_systems(), libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::SUBDIVISION, libMesh::Elem::subdomain_id(), sys_number(), libMesh::Elem::type(), variable(), and variable_type()\&.
.PP
Referenced by dof_indices()\&.
.PP
.nf
1919 {
1920   const ElemType type        = elem->type();
1921   const unsigned int sys_num = this->sys_number();
1922   const unsigned int dim     = elem->dim();
1923 
1924   if (this->variable(v)\&.active_on_subdomain(elem->subdomain_id()))
1925     { // Do this for all the variables if one was not specified
1926       // or just for the specified variable
1927 
1928       // Increase the polynomial order on p refined elements
1929       FEType fe_type = this->variable_type(v);
1930       fe_type\&.order = static_cast<Order>(fe_type\&.order +
1931                                          elem->p_level());
1932 
1933       const bool extra_hanging_dofs =
1934         FEInterface::extra_hanging_dofs(fe_type);
1935 
1936 #ifdef DEBUG
1937       // The number of dofs per element is non-static for subdivision FE
1938       if (this->variable(v)\&.type()\&.family == SUBDIVISION)
1939         tot_size += elem_nodes\&.size();
1940       else
1941         tot_size += FEInterface::n_dofs(dim,fe_type,type);
1942 #endif
1943 
1944       // Get the node-based DOF numbers
1945       for (unsigned int n=0; n<elem_nodes\&.size(); n++)
1946         {
1947           const Node* node      = elem_nodes[n];
1948 
1949           // There is a potential problem with h refinement\&.  Imagine a
1950           // quad9 that has a linear FE on it\&.  Then, on the hanging side,
1951           // it can falsely identify a DOF at the mid-edge node\&. This is why
1952           // we call FEInterface instead of node->n_comp() directly\&.
1953           const unsigned int nc = FEInterface::n_dofs_at_node (dim,
1954                                                                fe_type,
1955                                                                type,
1956                                                                n);
1957 
1958           // If this is a non-vertex on a hanging node with extra
1959           // degrees of freedom, we use the non-vertex dofs (which
1960           // come in reverse order starting from the end, to
1961           // simplify p refinement)
1962           if (extra_hanging_dofs && !elem->is_vertex(n))
1963             {
1964               const int dof_offset = node->n_comp(sys_num,v) - nc;
1965 
1966               // We should never have fewer dofs than necessary on a
1967               // node unless we're getting indices on a parent element,
1968               // and we should never need the indices on such a node
1969               if (dof_offset < 0)
1970                 {
1971                   libmesh_assert(!elem->active());
1972                   di\&.resize(di\&.size() + nc, DofObject::invalid_id);
1973                 }
1974               else
1975                 for (int i=node->n_comp(sys_num,v)-1; i>=dof_offset; i--)
1976                   {
1977                     libmesh_assert_not_equal_to (node->dof_number(sys_num,v,i),
1978                                                  DofObject::invalid_id);
1979                     di\&.push_back(node->dof_number(sys_num,v,i));
1980                   }
1981             }
1982           // If this is a vertex or an element without extra hanging
1983           // dofs, our dofs come in forward order coming from the
1984           // beginning
1985           else
1986             for (unsigned int i=0; i<nc; i++)
1987               {
1988                 libmesh_assert_not_equal_to (node->dof_number(sys_num,v,i),
1989                                              DofObject::invalid_id);
1990                 di\&.push_back(node->dof_number(sys_num,v,i));
1991               }
1992         }
1993 
1994       // If there are any element-based DOF numbers, get them
1995       const unsigned int nc = FEInterface::n_dofs_per_elem(dim,
1996                                                            fe_type,
1997                                                            type);
1998       // We should never have fewer dofs than necessary on an
1999       // element unless we're getting indices on a parent element,
2000       // and we should never need those indices
2001       if (nc != 0)
2002         {
2003           if (elem->n_systems() > sys_num &&
2004               nc <= elem->n_comp(sys_num,v))
2005             {
2006               for (unsigned int i=0; i<nc; i++)
2007                 {
2008                   libmesh_assert_not_equal_to (elem->dof_number(sys_num,v,i),
2009                                                DofObject::invalid_id);
2010 
2011                   di\&.push_back(elem->dof_number(sys_num,v,i));
2012                 }
2013             }
2014           else
2015             {
2016               libmesh_assert(!elem->active() || fe_type\&.family == LAGRANGE || fe_type\&.family == SUBDIVISION);
2017               di\&.resize(di\&.size() + nc, DofObject::invalid_id);
2018             }
2019         }
2020     }
2021 }
.fi
.SS "void libMesh::DofMap::add_adjoint_constraint_row (const unsigned intqoi_index, const \fBdof_id_type\fPdof_number, const \fBDofConstraintRow\fP &constraint_row, const \fBNumber\fPconstraint_rhs, const boolforbid_constraint_overwrite)"
Adds a copy of the user-defined row to the constraint matrix, using an inhomogeneous right-hand-side for the adjoint constraint equation\&.
.PP
\fCforbid_constraint_overwrite\fP here only tests for overwriting the rhs\&. This method should only be used when an equivalent constraint (with a potentially different rhs) already exists for the primal problem\&. 
.PP
Definition at line 1114 of file dof_map_constraints\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1119 {
1120   // Optionally allow the user to overwrite constraints\&.  Defaults to false\&.
1121   if (forbid_constraint_overwrite)
1122     {
1123       if (!this->is_constrained_dof(dof_number))
1124         {
1125           libMesh::err << "ERROR: DOF " << dof_number << " has no corresponding primal constraint!"
1126                        << std::endl;
1127           libmesh_error();
1128         }
1129 #ifndef NDEBUG
1130       // No way to do this without a non-normalized tolerance?
1131       /*
1132       // If the user passed in more than just the rhs, let's check the
1133       // coefficients for consistency
1134       if (!constraint_row\&.empty())
1135       {
1136       DofConstraintRow row = _dof_constraints[dof_number];
1137       for (DofConstraintRow::const_iterator pos=row\&.begin();
1138       pos != row\&.end(); ++pos)
1139       {
1140       libmesh_assert(constraint_row\&.find(pos->first)->second
1141       == pos->second);
1142       }
1143       }
1144 
1145       if (_adjoint_constraint_values[qoi_index]\&.find(dof_number) !=
1146       _adjoint_constraint_values[qoi_index]\&.end())
1147       libmesh_assert_equal_to
1148       (_adjoint_constraint_values[qoi_index][dof_number],
1149       constraint_rhs);
1150       */
1151 #endif
1152     }
1153 
1154   // Creates the map of rhs values if it doesn't already exist; then
1155   // adds the current value to that map
1156   _adjoint_constraint_values[qoi_index]\&.insert(std::make_pair(dof_number, constraint_rhs));
1157 }
.fi
.SS "void libMesh::DofMap::add_adjoint_dirichlet_boundary (const \fBDirichletBoundary\fP &dirichlet_boundary, unsigned intq)"
Adds a copy of the specified Dirichlet boundary to the system, corresponding to the adjoint problem defined by Quantity of Interest \fCq\fP\&. 
.PP
Definition at line 3597 of file dof_map_constraints\&.C\&.
.PP
.nf
3599 {
3600   std::size_t old_size = _adjoint_dirichlet_boundaries\&.size();
3601   for (std::size_t i = old_size; i <= qoi_index; ++i)
3602     _adjoint_dirichlet_boundaries\&.push_back(new DirichletBoundaries());
3603 
3604   _adjoint_dirichlet_boundaries[qoi_index]->push_back(new DirichletBoundary(dirichlet_boundary));
3605 }
.fi
.SS "void libMesh::DofMap::add_constraint_row (const \fBdof_id_type\fPdof_number, const \fBDofConstraintRow\fP &constraint_row, const \fBNumber\fPconstraint_rhs, const boolforbid_constraint_overwrite)"
Adds a copy of the user-defined row to the constraint matrix, using an inhomogeneous right-hand-side for the constraint equation\&. 
.PP
Definition at line 1095 of file dof_map_constraints\&.C\&.
.PP
References libMesh::err\&.
.PP
Referenced by add_constraint_row()\&.
.PP
.nf
1099 {
1100   // Optionally allow the user to overwrite constraints\&.  Defaults to false\&.
1101   if (forbid_constraint_overwrite)
1102     if (this->is_constrained_dof(dof_number))
1103       {
1104         libMesh::err << "ERROR: DOF " << dof_number << " was already constrained!"
1105                      << std::endl;
1106         libmesh_error();
1107       }
1108 
1109   _dof_constraints\&.insert(std::make_pair(dof_number, constraint_row));
1110   _primal_constraint_values\&.insert(std::make_pair(dof_number, constraint_rhs));
1111 }
.fi
.SS "void libMesh::DofMap::add_constraint_row (const \fBdof_id_type\fPdof_number, const \fBDofConstraintRow\fP &constraint_row, const boolforbid_constraint_overwrite = \fCtrue\fP)\fC [inline]\fP"
Adds a copy of the user-defined row to the constraint matrix, using a homogeneous right-hand-side for the constraint equation\&. By default, produces an error if the DOF was already constrained\&. 
.PP
Definition at line 651 of file dof_map\&.h\&.
.PP
References add_constraint_row()\&.
.PP
.nf
654   { add_constraint_row(dof_number, constraint_row, 0\&., forbid_constraint_overwrite); }
.fi
.SS "void libMesh::DofMap::add_constraints_to_send_list ()\fC [private]\fP"
Adds entries to the \fC_send_list\fP vector corresponding to DoFs which are dependencies for constraint equations on the current processor\&. 
.PP
Definition at line 3475 of file dof_map_constraints\&.C\&.
.PP
References libMesh::comm, and libMesh::n_processors()\&.
.PP
.nf
3476 {
3477   // This function must be run on all processors at once
3478   parallel_object_only();
3479 
3480   // Return immediately if there's nothing to gather
3481   if (this->n_processors() == 1)
3482     return;
3483 
3484   // We might get to return immediately if none of the processors
3485   // found any constraints
3486   unsigned int has_constraints = !_dof_constraints\&.empty();
3487   this->comm()\&.max(has_constraints);
3488   if (!has_constraints)
3489     return;
3490 
3491   for (DofConstraints::iterator i = _dof_constraints\&.begin();
3492        i != _dof_constraints\&.end(); ++i)
3493     {
3494       dof_id_type constrained_dof = i->first;
3495 
3496       // We only need the dependencies of our own constrained dofs
3497       if (constrained_dof < this->first_dof() ||
3498           constrained_dof >= this->end_dof())
3499         continue;
3500 
3501       DofConstraintRow& constraint_row = i->second;
3502       for (DofConstraintRow::const_iterator
3503              j=constraint_row\&.begin(); j != constraint_row\&.end();
3504            ++j)
3505         {
3506           dof_id_type constraint_dependency = j->first;
3507 
3508           // No point in adding one of our own dofs to the send_list
3509           if (constraint_dependency >= this->first_dof() &&
3510               constraint_dependency < this->end_dof())
3511             continue;
3512 
3513           _send_list\&.push_back(constraint_dependency);
3514         }
3515     }
3516 }
.fi
.SS "void libMesh::DofMap::add_dirichlet_boundary (const \fBDirichletBoundary\fP &dirichlet_boundary)"
Adds a copy of the specified Dirichlet boundary to the system\&. 
.PP
Definition at line 3590 of file dof_map_constraints\&.C\&.
.PP
.nf
3591 {
3592   _dirichlet_boundaries->push_back(new DirichletBoundary(dirichlet_boundary));
3593 }
.fi
.SS "void libMesh::DofMap::add_neighbors_to_send_list (\fBMeshBase\fP &mesh)\fC [private]\fP"
Adds entries to the \fC_send_list\fP vector corresponding to DoFs on elements neighboring the current processor\&. 
.PP
Definition at line 1382 of file dof_map\&.C\&.
.PP
References _send_list, libMesh::Elem::active(), libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), dof_indices(), libMesh::DofObject::dof_number(), end_dof(), first_dof(), libMesh::Elem::get_node(), libMesh::MeshBase::max_node_id(), libMesh::DofObject::n_comp(), libMesh::Elem::n_neighbors(), libMesh::Elem::n_nodes(), libMesh::n_vars, libMesh::DofObject::n_vars(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::START_LOG(), libMesh::STOP_LOG(), and sys_number()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
1383 {
1384   START_LOG("add_neighbors_to_send_list()", "DofMap");
1385 
1386   const unsigned int sys_num = this->sys_number();
1387 
1388   //-------------------------------------------------------------------------
1389   // We need to add the DOFs from elements that live on neighboring processors
1390   // that are neighbors of the elements on the local processor
1391   //-------------------------------------------------------------------------
1392 
1393   MeshBase::const_element_iterator       local_elem_it
1394     = mesh\&.active_local_elements_begin();
1395   const MeshBase::const_element_iterator local_elem_end
1396     = mesh\&.active_local_elements_end();
1397 
1398   std::vector<bool> node_on_processor(mesh\&.max_node_id(), false);
1399   std::vector<dof_id_type> di;
1400   std::vector<const Elem *> family;
1401 
1402   // Loop over the active local elements, adding all active elements
1403   // that neighbor an active local element to the send list\&.
1404   for ( ; local_elem_it != local_elem_end; ++local_elem_it)
1405     {
1406       const Elem* elem = *local_elem_it;
1407 
1408       for (unsigned int n=0; n!=elem->n_nodes(); n++)
1409         {
1410           // Flag all the nodes of active local elements as seen, so
1411           // we can add nodal neighbor dofs to the send_list later\&.
1412           node_on_processor[elem->node(n)] = true;
1413 
1414           // Add all remote dofs on these nodes to the send_list\&.
1415           // This is necessary in case those dofs are *not* also dofs
1416           // on neighbors; e\&.g\&. in the case of a HIERARCHIC's local
1417           // side which is only a vertex on the neighbor that owns it\&.
1418           const Node* node = elem->get_node(n);
1419           const unsigned n_vars = node->n_vars(sys_num);
1420           for (unsigned int v=0; v != n_vars; ++v)
1421             {
1422               const unsigned int n_comp = node->n_comp(sys_num, v);
1423               for (unsigned int c=0; c != n_comp; ++c)
1424                 {
1425                   const dof_id_type dof_index = node->dof_number(sys_num, v, c);
1426                   if (dof_index < this->first_dof() || dof_index >= this->end_dof())
1427                     {
1428                       _send_list\&.push_back(dof_index);
1429                       // libmesh_here();
1430                       // libMesh::out << "sys_num,v,c,dof_index="
1431                       // << sys_num << ", "
1432                       // << v << ", "
1433                       // << c << ", "
1434                       // << dof_index << '\n';
1435                       // node->debug_buffer();
1436                     }
1437                 }
1438             }
1439         }
1440 
1441       // Loop over the neighbors of those elements
1442       for (unsigned int s=0; s<elem->n_neighbors(); s++)
1443         if (elem->neighbor(s) != NULL)
1444           {
1445             family\&.clear();
1446 
1447             // Find all the active elements that neighbor elem
1448 #ifdef LIBMESH_ENABLE_AMR
1449             if (!elem->neighbor(s)->active())
1450               elem->neighbor(s)->active_family_tree_by_neighbor(family, elem);
1451             else
1452 #endif
1453               family\&.push_back(elem->neighbor(s));
1454 
1455             for (dof_id_type i=0; i!=family\&.size(); ++i)
1456               // If the neighbor lives on a different processor
1457               if (family[i]->processor_id() != this->processor_id())
1458                 {
1459                   // Get the DOF indices for this neighboring element
1460                   this->dof_indices (family[i], di);
1461 
1462                   // Insert the remote DOF indices into the send list
1463                   for (std::size_t j=0; j != di\&.size(); ++j)
1464                     if (di[j] < this->first_dof() ||
1465                         di[j] >= this->end_dof())
1466                       _send_list\&.push_back(di[j]);
1467                 }
1468           }
1469     }
1470 
1471   // Now loop over all non_local active elements and add any missing
1472   // nodal-only neighbors\&.  This will also get any dofs from nonlocal
1473   // nodes on local elements, because every nonlocal node exists on a
1474   // nonlocal nodal neighbor element\&.
1475   MeshBase::const_element_iterator       elem_it
1476     = mesh\&.active_elements_begin();
1477   const MeshBase::const_element_iterator elem_end
1478     = mesh\&.active_elements_end();
1479 
1480   for ( ; elem_it != elem_end; ++elem_it)
1481     {
1482       const Elem* elem = *elem_it;
1483 
1484       // If this is one of our elements, we've already added it
1485       if (elem->processor_id() == this->processor_id())
1486         continue;
1487 
1488       // Do we need to add the element DOFs?
1489       bool add_elem_dofs = false;
1490 
1491       // Check all the nodes of the element to see if it
1492       // shares a node with us
1493       for (unsigned int n=0; n!=elem->n_nodes(); n++)
1494         if (node_on_processor[elem->node(n)])
1495           add_elem_dofs = true;
1496 
1497       // Add the element degrees of freedom if it shares at
1498       // least one node\&.
1499       if (add_elem_dofs)
1500         {
1501           // Get the DOF indices for this neighboring element
1502           this->dof_indices (elem, di);
1503 
1504           // Insert the remote DOF indices into the send list
1505           for (std::size_t j=0; j != di\&.size(); ++j)
1506             if (di[j] < this->first_dof() ||
1507                 di[j] >= this->end_dof())
1508               _send_list\&.push_back(di[j]);
1509         }
1510     }
1511 
1512   STOP_LOG("add_neighbors_to_send_list()", "DofMap");
1513 }
.fi
.SS "void libMesh::DofMap::add_periodic_boundary (const \fBPeriodicBoundaryBase\fP &periodic_boundary)"
Adds a copy of the specified periodic boundary to the system\&. 
.PP
Definition at line 3695 of file dof_map_constraints\&.C\&.
.PP
References libMesh::PeriodicBoundaryBase::clone(), libMesh::libmesh_assert(), libMesh::PeriodicBoundaryBase::merge(), libMesh::PeriodicBoundaryBase::myboundary, and libMesh::PeriodicBoundaryBase::pairedboundary\&.
.PP
.nf
3696 {
3697   // See if we already have a periodic boundary associated myboundary\&.\&.\&.
3698   PeriodicBoundaryBase* existing_boundary = _periodic_boundaries->boundary(periodic_boundary\&.myboundary);
3699 
3700   if ( existing_boundary == NULL )
3701     {
3702       // \&.\&.\&.if not, clone the input (and its inverse) and add them to the PeriodicBoundaries object
3703       PeriodicBoundaryBase* boundary = periodic_boundary\&.clone()\&.release();
3704       PeriodicBoundaryBase* inverse_boundary = periodic_boundary\&.clone(PeriodicBoundaryBase::INVERSE)\&.release();
3705 
3706       // _periodic_boundaries takes ownership of the pointers
3707       _periodic_boundaries->insert(std::make_pair(boundary->myboundary, boundary));
3708       _periodic_boundaries->insert(std::make_pair(inverse_boundary->myboundary, inverse_boundary));
3709     }
3710   else
3711     {
3712       // \&.\&.\&.otherwise, merge this object's variable IDs with the existing boundary object's\&.
3713       existing_boundary->merge(periodic_boundary);
3714 
3715       // Do the same merging process for the inverse boundary\&.  Note: the inverse better already exist!
3716       PeriodicBoundaryBase* inverse_boundary = _periodic_boundaries->boundary(periodic_boundary\&.pairedboundary);
3717       libmesh_assert(inverse_boundary);
3718       inverse_boundary->merge(periodic_boundary);
3719     }
3720 }
.fi
.SS "void libMesh::DofMap::add_periodic_boundary (const \fBPeriodicBoundaryBase\fP &boundary, const \fBPeriodicBoundaryBase\fP &inverse_boundary)"
Add a periodic boundary pair
.PP
\fBParameters:\fP
.RS 4
\fIboundary\fP - primary boundary 
.br
\fIinverse_boundary\fP - inverse boundary 
.RE
.PP

.PP
Definition at line 3725 of file dof_map_constraints\&.C\&.
.PP
References libMesh::PeriodicBoundaryBase::clone(), libMesh::PeriodicBoundaryBase::myboundary, and libMesh::PeriodicBoundaryBase::pairedboundary\&.
.PP
.nf
3726 {
3727   libmesh_assert_equal_to (boundary\&.myboundary, inverse_boundary\&.pairedboundary);
3728   libmesh_assert_equal_to (boundary\&.pairedboundary, inverse_boundary\&.myboundary);
3729 
3730   // Allocate copies on the heap\&.  The _periodic_boundaries object will manage this memory\&.
3731   // Note: this also means that the copy constructor for the PeriodicBoundary (or user class
3732   // derived therefrom) must be implemented!
3733   // PeriodicBoundary* p_boundary = new PeriodicBoundary(boundary);
3734   // PeriodicBoundary* p_inverse_boundary = new PeriodicBoundary(inverse_boundary);
3735 
3736   // We can't use normal copy construction since this leads to slicing with derived classes\&.
3737   // Use clone() "virtual constructor" instead\&.  But, this *requires* user to override the clone()
3738   // method\&.  Note also that clone() allocates memory\&.  In this case, the _periodic_boundaries object
3739   // takes responsibility for cleanup\&.
3740   PeriodicBoundaryBase* p_boundary = boundary\&.clone()\&.release();
3741   PeriodicBoundaryBase* p_inverse_boundary = inverse_boundary\&.clone()\&.release();
3742 
3743   // Add the periodic boundary and its inverse to the PeriodicBoundaries data structure\&.  The
3744   // PeriodicBoundaries data structure takes ownership of the pointers\&.
3745   _periodic_boundaries->insert(std::make_pair(p_boundary->myboundary, p_boundary));
3746   _periodic_boundaries->insert(std::make_pair(p_inverse_boundary->myboundary, p_inverse_boundary));
3747 }
.fi
.SS "void libMesh::DofMap::add_variable_group (const \fBVariableGroup\fP &var_group)"
Add an unknown of order \fCorder\fP and finite element type \fCtype\fP to the system of equations\&. Add a group of unknowns of order \fCorder\fP and finite element type \fCtype\fP to the system of equations\&. 
.PP
Definition at line 213 of file dof_map\&.C\&.
.PP
References _variable_groups, _variables, and libMesh::VariableGroup::n_variables()\&.
.PP
.nf
214 {
215   _variable_groups\&.push_back(var_group);
216 
217   VariableGroup &new_var_group = _variable_groups\&.back();
218 
219   for (unsigned int var=0; var<new_var_group\&.n_variables(); var++)
220     _variables\&.push_back (new_var_group(var));
221 }
.fi
.SS "bool libMesh::DofMap::all_semilocal_indices (const std::vector< \fBdof_id_type\fP > &dof_indices) const"
Returns \fCtrue\fP iff all degree of freedom indices in \fCdof_indices\fP are either local indices or in the \fCsend_list\fP\&. Note that this is an O(logN) operation, not O(1); we don't cache enough information for O(1) right now\&. 
.PP
Definition at line 2090 of file dof_map\&.C\&.
.PP
References _send_list, end_dof(), and first_dof()\&.
.PP
.nf
2091 {
2092   // We're all semilocal unless we find a counterexample
2093   for (std::size_t i=0; i != dof_indices_in\&.size(); ++i)
2094     {
2095       const dof_id_type di = dof_indices_in[i];
2096       // If it's not in the local indices
2097       if (di < this->first_dof() ||
2098           di >= this->end_dof())
2099         {
2100           // and if it's not in the ghost indices, then we're not
2101           // semilocal
2102           if (!std::binary_search(_send_list\&.begin(), _send_list\&.end(), di))
2103             return false;
2104         }
2105     }
2106 
2107   return true;
2108 }
.fi
.SS "void libMesh::DofMap::allgather_recursive_constraints (\fBMeshBase\fP &mesh)"
Gathers constraint equation dependencies from other processors 
.PP
Definition at line 2398 of file dof_map_constraints\&.C\&.
.PP
References libMesh::MeshBase::active_not_local_elements_begin(), libMesh::MeshBase::active_not_local_elements_end(), libMesh::comm, libMesh::DofObject::dof_number(), end, libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::libmesh_assert(), mesh, libMesh::DofObject::n_comp(), libMesh::Elem::n_nodes(), libMesh::n_processors(), n_vars, libMesh::DofObject::n_vars(), libMesh::Elem::node(), libMesh::MeshBase::node_ptr(), libMesh::processor_id(), libMesh::DofObject::processor_id(), and libMesh::TypeVector< T >::size()\&.
.PP
.nf
2399 {
2400   // This function must be run on all processors at once
2401   parallel_object_only();
2402 
2403   // Return immediately if there's nothing to gather
2404   if (this->n_processors() == 1)
2405     return;
2406 
2407   // We might get to return immediately if none of the processors
2408   // found any constraints
2409   unsigned int has_constraints = !_dof_constraints\&.empty()
2410 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2411     || !_node_constraints\&.empty()
2412 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2413     ;
2414   this->comm()\&.max(has_constraints);
2415   if (!has_constraints)
2416     return;
2417 
2418   // We might have calculated constraints for constrained dofs
2419   // which have support on other processors\&.
2420   // Push these out first\&.
2421   {
2422     std::vector<std::set<dof_id_type> > pushed_ids(this->n_processors());
2423 
2424 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2425     std::vector<std::set<dof_id_type> > pushed_node_ids(this->n_processors());
2426 #endif
2427 
2428     const unsigned int sys_num = this->sys_number();
2429 
2430     MeshBase::element_iterator
2431       foreign_elem_it  = mesh\&.active_not_local_elements_begin(),
2432       foreign_elem_end = mesh\&.active_not_local_elements_end();
2433 
2434     // Collect the constraints to push to each processor
2435     for (; foreign_elem_it != foreign_elem_end; ++foreign_elem_it)
2436       {
2437         const Elem *elem = *foreign_elem_it;
2438 
2439         // Just checking dof_indices on the foreign element isn't
2440         // enough\&.  Consider a central hanging node between a coarse
2441         // Q2/Q1 element and its finer neighbors on a higher-ranked
2442         // processor\&.  The coarse element's processor will own the node,
2443         // and will thereby own the pressure dof on that node, despite
2444         // the fact that that pressure dof doesn't directly exist on the
2445         // coarse element!
2446         //
2447         // So, we loop through dofs manually\&.
2448 
2449         {
2450           const unsigned int n_vars = elem->n_vars(sys_num);
2451           for (unsigned int v=0; v != n_vars; ++v)
2452             {
2453               const unsigned int n_comp = elem->n_comp(sys_num,v);
2454               for (unsigned int c=0; c != n_comp; ++c)
2455                 {
2456                   const unsigned int id =
2457                     elem->dof_number(sys_num,v,c);
2458                   if (this->is_constrained_dof(id))
2459                     pushed_ids[elem->processor_id()]\&.insert(id);
2460                 }
2461             }
2462         }
2463 
2464         for (unsigned int n=0; n != elem->n_nodes(); ++n)
2465           {
2466             const Node *node = elem->get_node(n);
2467             const unsigned int n_vars = node->n_vars(sys_num);
2468             for (unsigned int v=0; v != n_vars; ++v)
2469               {
2470                 const unsigned int n_comp = node->n_comp(sys_num,v);
2471                 for (unsigned int c=0; c != n_comp; ++c)
2472                   {
2473                     const unsigned int id =
2474                       node->dof_number(sys_num,v,c);
2475                     if (this->is_constrained_dof(id))
2476                       pushed_ids[elem->processor_id()]\&.insert(id);
2477                   }
2478               }
2479           }
2480 
2481 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2482         for (unsigned int n=0; n != elem->n_nodes(); ++n)
2483           if (this->is_constrained_node(elem->get_node(n)))
2484             pushed_node_ids[elem->processor_id()]\&.insert(elem->node(n));
2485 #endif
2486       }
2487 
2488     // Now trade constraint rows
2489     for (processor_id_type p = 0; p != this->n_processors(); ++p)
2490       {
2491         // Push to processor procup while receiving from procdown
2492         processor_id_type procup = (this->processor_id() + p) %
2493           this->n_processors();
2494         processor_id_type procdown = (this->n_processors() +
2495                                       this->processor_id() - p) %
2496           this->n_processors();
2497 
2498         // Pack the dof constraint rows and rhs's to push to procup
2499         const std::size_t pushed_ids_size = pushed_ids[procup]\&.size();
2500         std::vector<std::vector<dof_id_type> > pushed_keys(pushed_ids_size);
2501         std::vector<std::vector<Real> > pushed_vals(pushed_ids_size);
2502         std::vector<Number> pushed_rhss(pushed_ids_size);
2503         std::set<dof_id_type>::const_iterator it = pushed_ids[procup]\&.begin();
2504         for (std::size_t i = 0; it != pushed_ids[procup]\&.end();
2505              ++i, ++it)
2506           {
2507             const dof_id_type pushed_id = *it;
2508             DofConstraintRow &row = _dof_constraints[pushed_id];
2509             std::size_t row_size = row\&.size();
2510             pushed_keys[i]\&.reserve(row_size);
2511             pushed_vals[i]\&.reserve(row_size);
2512             for (DofConstraintRow::iterator j = row\&.begin();
2513                  j != row\&.end(); ++j)
2514               {
2515                 pushed_keys[i]\&.push_back(j->first);
2516                 pushed_vals[i]\&.push_back(j->second);
2517               }
2518 
2519             DofConstraintValueMap::const_iterator rhsit =
2520               _primal_constraint_values\&.find(pushed_id);
2521             pushed_rhss[i] =
2522               (rhsit == _primal_constraint_values\&.end()) ?
2523               0 : rhsit->second;
2524           }
2525 
2526 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2527         // Pack the node constraint rows to push to procup
2528         const std::size_t pushed_nodes_size = pushed_node_ids[procup]\&.size();
2529         std::vector<std::vector<dof_id_type> > pushed_node_keys(pushed_nodes_size);
2530         std::vector<std::vector<Real> > pushed_node_vals(pushed_nodes_size);
2531         std::vector<Point> pushed_node_offsets(pushed_nodes_size);
2532         std::set<dof_id_type>::const_iterator node_it = pushed_node_ids[procup]\&.begin();
2533         for (std::size_t i = 0; node_it != pushed_node_ids[procup]\&.end();
2534              ++i, ++node_it)
2535           {
2536             const Node *node = mesh\&.node_ptr(*node_it);
2537             NodeConstraintRow &row = _node_constraints[node]\&.first;
2538             std::size_t row_size = row\&.size();
2539             pushed_node_keys[i]\&.reserve(row_size);
2540             pushed_node_vals[i]\&.reserve(row_size);
2541             for (NodeConstraintRow::iterator j = row\&.begin();
2542                  j != row\&.end(); ++j)
2543               {
2544                 pushed_node_keys[i]\&.push_back(j->first->id());
2545                 pushed_node_vals[i]\&.push_back(j->second);
2546               }
2547             pushed_node_offsets[i] = _node_constraints[node]\&.second;
2548           }
2549 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2550 
2551         // Trade pushed dof constraint rows
2552         std::vector<dof_id_type> pushed_ids_from_me
2553           (pushed_ids[procup]\&.begin(), pushed_ids[procup]\&.end());
2554         std::vector<dof_id_type> pushed_ids_to_me;
2555         std::vector<std::vector<dof_id_type> > pushed_keys_to_me;
2556         std::vector<std::vector<Real> > pushed_vals_to_me;
2557         std::vector<Number> pushed_rhss_to_me;
2558         this->comm()\&.send_receive(procup, pushed_ids_from_me,
2559                                   procdown, pushed_ids_to_me);
2560         this->comm()\&.send_receive(procup, pushed_keys,
2561                                   procdown, pushed_keys_to_me);
2562         this->comm()\&.send_receive(procup, pushed_vals,
2563                                   procdown, pushed_vals_to_me);
2564         this->comm()\&.send_receive(procup, pushed_rhss,
2565                                   procdown, pushed_rhss_to_me);
2566         libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_keys_to_me\&.size());
2567         libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_vals_to_me\&.size());
2568         libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_rhss_to_me\&.size());
2569 
2570 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2571         // Trade pushed node constraint rows
2572         std::vector<dof_id_type> pushed_node_ids_from_me
2573           (pushed_node_ids[procup]\&.begin(), pushed_node_ids[procup]\&.end());
2574         std::vector<dof_id_type> pushed_node_ids_to_me;
2575         std::vector<std::vector<dof_id_type> > pushed_node_keys_to_me;
2576         std::vector<std::vector<Real> > pushed_node_vals_to_me;
2577         std::vector<Point> pushed_node_offsets_to_me;
2578         this->comm()\&.send_receive(procup, pushed_node_ids_from_me,
2579                                   procdown, pushed_node_ids_to_me);
2580         this->comm()\&.send_receive(procup, pushed_node_keys,
2581                                   procdown, pushed_node_keys_to_me);
2582         this->comm()\&.send_receive(procup, pushed_node_vals,
2583                                   procdown, pushed_node_vals_to_me);
2584         this->comm()\&.send_receive(procup, pushed_node_offsets,
2585                                   procdown, pushed_node_offsets_to_me);
2586 
2587         // Note that we aren't doing a send_receive on the Nodes
2588         // themselves\&.  At this point we should only be pushing out
2589         // "raw" constraints, and there should be no
2590         // constrained-by-constrained-by-etc\&. situations that could
2591         // involve non-semilocal nodes\&.
2592 
2593         libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_keys_to_me\&.size());
2594         libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_vals_to_me\&.size());
2595         libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_offsets_to_me\&.size());
2596 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2597 
2598         // Add the dof constraints that I've been sent
2599         for (std::size_t i = 0; i != pushed_ids_to_me\&.size(); ++i)
2600           {
2601             libmesh_assert_equal_to (pushed_keys_to_me[i]\&.size(), pushed_vals_to_me[i]\&.size());
2602 
2603             dof_id_type constrained = pushed_ids_to_me[i];
2604 
2605             // If we don't already have a constraint for this dof,
2606             // add the one we were sent
2607             if (!this->is_constrained_dof(constrained))
2608               {
2609                 DofConstraintRow &row = _dof_constraints[constrained];
2610                 for (std::size_t j = 0; j != pushed_keys_to_me[i]\&.size(); ++j)
2611                   {
2612                     row[pushed_keys_to_me[i][j]] = pushed_vals_to_me[i][j];
2613                   }
2614                 if (pushed_rhss_to_me[i] != Number(0))
2615                   _primal_constraint_values[constrained] = pushed_rhss_to_me[i];
2616                 else
2617                   _primal_constraint_values\&.erase(constrained);
2618               }
2619           }
2620 
2621 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2622         // Add the node constraints that I've been sent
2623         for (std::size_t i = 0; i != pushed_node_ids_to_me\&.size(); ++i)
2624           {
2625             libmesh_assert_equal_to (pushed_node_keys_to_me[i]\&.size(), pushed_node_vals_to_me[i]\&.size());
2626 
2627             dof_id_type constrained_id = pushed_node_ids_to_me[i];
2628 
2629             // If we don't already have a constraint for this node,
2630             // add the one we were sent
2631             const Node *constrained = mesh\&.node_ptr(constrained_id);
2632             if (!this->is_constrained_node(constrained))
2633               {
2634                 NodeConstraintRow &row = _node_constraints[constrained]\&.first;
2635                 for (std::size_t j = 0; j != pushed_node_keys_to_me[i]\&.size(); ++j)
2636                   {
2637                     const Node *key_node = mesh\&.node_ptr(pushed_node_keys_to_me[i][j]);
2638                     libmesh_assert(key_node);
2639                     row[key_node] = pushed_node_vals_to_me[i][j];
2640                   }
2641                 _node_constraints[constrained]\&.second = pushed_node_offsets_to_me[i];
2642               }
2643           }
2644 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2645       }
2646   }
2647 
2648   // Now start checking for any other constraints we need
2649   // to know about, requesting them recursively\&.
2650 
2651   // Create sets containing the DOFs and nodes we already depend on
2652   typedef std::set<dof_id_type> DoF_RCSet;
2653   DoF_RCSet unexpanded_dofs;
2654 
2655   for (DofConstraints::iterator i = _dof_constraints\&.begin();
2656        i != _dof_constraints\&.end(); ++i)
2657     {
2658       unexpanded_dofs\&.insert(i->first);
2659     }
2660 
2661   typedef std::set<const Node *> Node_RCSet;
2662   Node_RCSet unexpanded_nodes;
2663 
2664 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2665   for (NodeConstraints::iterator i = _node_constraints\&.begin();
2666        i != _node_constraints\&.end(); ++i)
2667     {
2668       unexpanded_nodes\&.insert(i->first);
2669     }
2670 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2671 
2672   // We have to keep recursing while the unexpanded set is
2673   // nonempty on *any* processor
2674   bool unexpanded_set_nonempty = !unexpanded_dofs\&.empty() ||
2675     !unexpanded_nodes\&.empty();
2676   this->comm()\&.max(unexpanded_set_nonempty);
2677 
2678   while (unexpanded_set_nonempty)
2679     {
2680       // Let's make sure we don't lose sync in this loop\&.
2681       parallel_object_only();
2682 
2683       // Request sets
2684       DoF_RCSet   dof_request_set;
2685       Node_RCSet node_request_set;
2686 
2687       // Request sets to send to each processor
2688       std::vector<std::vector<dof_id_type> >
2689         requested_dof_ids(this->n_processors()),
2690         requested_node_ids(this->n_processors());
2691 
2692       // And the sizes of each
2693       std::vector<dof_id_type>
2694         dof_ids_on_proc(this->n_processors(), 0),
2695         node_ids_on_proc(this->n_processors(), 0);
2696 
2697       // Fill (and thereby sort and uniq!) the main request sets
2698       for (DoF_RCSet::iterator i = unexpanded_dofs\&.begin();
2699            i != unexpanded_dofs\&.end(); ++i)
2700         {
2701           DofConstraintRow &row = _dof_constraints[*i];
2702           for (DofConstraintRow::iterator j = row\&.begin();
2703                j != row\&.end(); ++j)
2704             {
2705               const dof_id_type constraining_dof = j->first;
2706 
2707               // If it's non-local and we haven't already got a
2708               // constraint for it, we might need to ask for one
2709               if (((constraining_dof < this->first_dof()) ||
2710                    (constraining_dof >= this->end_dof())) &&
2711                   !_dof_constraints\&.count(constraining_dof))
2712                 dof_request_set\&.insert(constraining_dof);
2713             }
2714         }
2715 
2716 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2717       for (Node_RCSet::iterator i = unexpanded_nodes\&.begin();
2718            i != unexpanded_nodes\&.end(); ++i)
2719         {
2720           NodeConstraintRow &row = _node_constraints[*i]\&.first;
2721           for (NodeConstraintRow::iterator j = row\&.begin();
2722                j != row\&.end(); ++j)
2723             {
2724               const Node* const node = j->first;
2725               libmesh_assert(node);
2726 
2727               // If it's non-local and we haven't already got a
2728               // constraint for it, we might need to ask for one
2729               if ((node->processor_id() != this->processor_id()) &&
2730                   !_node_constraints\&.count(node))
2731                 node_request_set\&.insert(node);
2732             }
2733         }
2734 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2735 
2736       // Clear the unexpanded constraint sets; we're about to expand
2737       // them
2738       unexpanded_dofs\&.clear();
2739       unexpanded_nodes\&.clear();
2740 
2741       // Count requests by processor
2742       processor_id_type proc_id = 0;
2743       for (DoF_RCSet::iterator i = dof_request_set\&.begin();
2744            i != dof_request_set\&.end(); ++i)
2745         {
2746           while (*i >= _end_df[proc_id])
2747             proc_id++;
2748           dof_ids_on_proc[proc_id]++;
2749         }
2750 
2751       for (Node_RCSet::iterator i = node_request_set\&.begin();
2752            i != node_request_set\&.end(); ++i)
2753         {
2754           libmesh_assert(*i);
2755           libmesh_assert_less ((*i)->processor_id(), this->n_processors());
2756           node_ids_on_proc[(*i)->processor_id()]++;
2757         }
2758 
2759       for (processor_id_type p = 0; p != this->n_processors(); ++p)
2760         {
2761           requested_dof_ids[p]\&.reserve(dof_ids_on_proc[p]);
2762           requested_node_ids[p]\&.reserve(node_ids_on_proc[p]);
2763         }
2764 
2765       // Prepare each processor's request set
2766       proc_id = 0;
2767       for (DoF_RCSet::iterator i = dof_request_set\&.begin();
2768            i != dof_request_set\&.end(); ++i)
2769         {
2770           while (*i >= _end_df[proc_id])
2771             proc_id++;
2772           requested_dof_ids[proc_id]\&.push_back(*i);
2773         }
2774 
2775       for (Node_RCSet::iterator i = node_request_set\&.begin();
2776            i != node_request_set\&.end(); ++i)
2777         {
2778           requested_node_ids[(*i)->processor_id()]\&.push_back((*i)->id());
2779         }
2780 
2781       // Now request constraint rows from other processors
2782       for (processor_id_type p=1; p != this->n_processors(); ++p)
2783         {
2784           // Trade my requests with processor procup and procdown
2785           processor_id_type procup = (this->processor_id() + p) %
2786             this->n_processors();
2787           processor_id_type procdown = (this->n_processors() +
2788                                         this->processor_id() - p) %
2789             this->n_processors();
2790           std::vector<dof_id_type> dof_request_to_fill,
2791             node_request_to_fill;
2792           this->comm()\&.send_receive(procup, requested_dof_ids[procup],
2793                                     procdown, dof_request_to_fill);
2794           this->comm()\&.send_receive(procup, requested_node_ids[procup],
2795                                     procdown, node_request_to_fill);
2796 
2797           // Fill those requests
2798           std::vector<std::vector<dof_id_type> > dof_row_keys(dof_request_to_fill\&.size()),
2799             node_row_keys(node_request_to_fill\&.size());
2800 
2801           std::vector<std::vector<Real> > dof_row_vals(dof_request_to_fill\&.size()),
2802             node_row_vals(node_request_to_fill\&.size());
2803           std::vector<Number> dof_row_rhss(dof_request_to_fill\&.size());
2804           std::vector<Point>  node_row_rhss(node_request_to_fill\&.size());
2805           for (std::size_t i=0; i != dof_request_to_fill\&.size(); ++i)
2806             {
2807               dof_id_type constrained = dof_request_to_fill[i];
2808               if (_dof_constraints\&.count(constrained))
2809                 {
2810                   DofConstraintRow &row = _dof_constraints[constrained];
2811                   std::size_t row_size = row\&.size();
2812                   dof_row_keys[i]\&.reserve(row_size);
2813                   dof_row_vals[i]\&.reserve(row_size);
2814                   for (DofConstraintRow::iterator j = row\&.begin();
2815                        j != row\&.end(); ++j)
2816                     {
2817                       dof_row_keys[i]\&.push_back(j->first);
2818                       dof_row_vals[i]\&.push_back(j->second);
2819 
2820                       // We should never have a 0 constraint
2821                       // coefficient; that's implicit via sparse
2822                       // constraint storage
2823                       libmesh_assert(j->second);
2824                     }
2825                   DofConstraintValueMap::const_iterator rhsit =
2826                     _primal_constraint_values\&.find(constrained);
2827                   dof_row_rhss[i] = (rhsit == _primal_constraint_values\&.end()) ?
2828                     0 : rhsit->second;
2829                 }
2830             }
2831 
2832 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2833           // FIXME - this could be an unordered set, given a
2834           // hash<pointers> specialization
2835           std::set<const Node*> nodes_requested;
2836 
2837           for (std::size_t i=0; i != node_request_to_fill\&.size(); ++i)
2838             {
2839               dof_id_type constrained_id = node_request_to_fill[i];
2840               const Node *constrained_node = mesh\&.node_ptr(constrained_id);
2841               if (_node_constraints\&.count(constrained_node))
2842                 {
2843                   const NodeConstraintRow &row = _node_constraints[constrained_node]\&.first;
2844                   std::size_t row_size = row\&.size();
2845                   node_row_keys[i]\&.reserve(row_size);
2846                   node_row_vals[i]\&.reserve(row_size);
2847                   for (NodeConstraintRow::const_iterator j = row\&.begin();
2848                        j != row\&.end(); ++j)
2849                     {
2850                       const Node* node = j->first;
2851                       node_row_keys[i]\&.push_back(node->id());
2852                       node_row_vals[i]\&.push_back(j->second);
2853 
2854                       // If we're not sure whether our send
2855                       // destination already has this node, let's give
2856                       // it a copy\&.
2857                       if (node->processor_id() != procdown)
2858                         nodes_requested\&.insert(node);
2859 
2860                       // We can have 0 nodal constraint
2861                       // coefficients, where no Lagrange constrant
2862                       // exists but non-Lagrange basis constraints
2863                       // might\&.
2864                       // libmesh_assert(j->second);
2865                     }
2866                   node_row_rhss[i] = _node_constraints[constrained_node]\&.second;
2867                 }
2868             }
2869 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2870 
2871           // Trade back the results
2872           std::vector<std::vector<dof_id_type> > dof_filled_keys,
2873             node_filled_keys;
2874           std::vector<std::vector<Real> > dof_filled_vals,
2875             node_filled_vals;
2876           std::vector<Number> dof_filled_rhss;
2877           std::vector<Point> node_filled_rhss;
2878           this->comm()\&.send_receive(procdown, dof_row_keys,
2879                                     procup, dof_filled_keys);
2880           this->comm()\&.send_receive(procdown, dof_row_vals,
2881                                     procup, dof_filled_vals);
2882           this->comm()\&.send_receive(procdown, dof_row_rhss,
2883                                     procup, dof_filled_rhss);
2884 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2885           this->comm()\&.send_receive(procdown, node_row_keys,
2886                                     procup, node_filled_keys);
2887           this->comm()\&.send_receive(procdown, node_row_vals,
2888                                     procup, node_filled_vals);
2889           this->comm()\&.send_receive(procdown, node_row_rhss,
2890                                     procup, node_filled_rhss);
2891 
2892           // Constraining nodes might not even exist on our subset of
2893           // a distributed mesh, so let's make them exist\&.
2894           this->comm()\&.send_receive_packed_range
2895             (procdown, &mesh, nodes_requested\&.begin(), nodes_requested\&.end(),
2896              procup,   &mesh, mesh_inserter_iterator<Node>(mesh));
2897 
2898 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2899           libmesh_assert_equal_to (dof_filled_keys\&.size(), requested_dof_ids[procup]\&.size());
2900           libmesh_assert_equal_to (dof_filled_vals\&.size(), requested_dof_ids[procup]\&.size());
2901           libmesh_assert_equal_to (dof_filled_rhss\&.size(), requested_dof_ids[procup]\&.size());
2902           libmesh_assert_equal_to (node_filled_keys\&.size(), requested_node_ids[procup]\&.size());
2903           libmesh_assert_equal_to (node_filled_vals\&.size(), requested_node_ids[procup]\&.size());
2904           libmesh_assert_equal_to (node_filled_rhss\&.size(), requested_node_ids[procup]\&.size());
2905 
2906           // Add any new constraint rows we've found
2907           for (std::size_t i=0; i != requested_dof_ids[procup]\&.size(); ++i)
2908             {
2909               libmesh_assert_equal_to (dof_filled_keys[i]\&.size(), dof_filled_vals[i]\&.size());
2910               // FIXME - what about empty p constraints!?
2911               if (!dof_filled_keys[i]\&.empty())
2912                 {
2913                   dof_id_type constrained = requested_dof_ids[procup][i];
2914                   DofConstraintRow &row = _dof_constraints[constrained];
2915                   for (std::size_t j = 0; j != dof_filled_keys[i]\&.size(); ++j)
2916                     row[dof_filled_keys[i][j]] = dof_filled_vals[i][j];
2917                   if (dof_filled_rhss[i] != Number(0))
2918                     _primal_constraint_values[constrained] = dof_filled_rhss[i];
2919                   else
2920                     _primal_constraint_values\&.erase(constrained);
2921 
2922                   // And prepare to check for more recursive constraints
2923                   unexpanded_dofs\&.insert(constrained);
2924                 }
2925             }
2926 
2927 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
2928           for (std::size_t i=0; i != requested_node_ids[procup]\&.size(); ++i)
2929             {
2930               libmesh_assert_equal_to (node_filled_keys[i]\&.size(), node_filled_vals[i]\&.size());
2931               if (!node_filled_keys[i]\&.empty())
2932                 {
2933                   dof_id_type constrained_id = requested_node_ids[procup][i];
2934                   const Node* constrained_node = mesh\&.node_ptr(constrained_id);
2935                   NodeConstraintRow &row = _node_constraints[constrained_node]\&.first;
2936                   for (std::size_t j = 0; j != node_filled_keys[i]\&.size(); ++j)
2937                     {
2938                       const Node* key_node =
2939                         mesh\&.node_ptr(node_filled_keys[i][j]);
2940                       libmesh_assert(key_node);
2941                       row[key_node] = node_filled_vals[i][j];
2942                     }
2943                   _node_constraints[constrained_node]\&.second = node_filled_rhss[i];
2944 
2945                   // And prepare to check for more recursive constraints
2946                   unexpanded_nodes\&.insert(constrained_node);
2947                 }
2948             }
2949 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
2950         }
2951 
2952       // We have to keep recursing while the unexpanded set is
2953       // nonempty on *any* processor
2954       unexpanded_set_nonempty = !unexpanded_dofs\&.empty() ||
2955         !unexpanded_nodes\&.empty();
2956       this->comm()\&.max(unexpanded_set_nonempty);
2957     }
2958 }
.fi
.SS "void libMesh::DofMap::attach_extra_send_list_function (void(*)(std::vector< \fBdof_id_type\fP > &, void *)func, void *context = \fCNULL\fP)\fC [inline]\fP"
Attach a function pointer to use as a callback to populate the send_list with extra entries\&. 
.PP
Definition at line 298 of file dof_map\&.h\&.
.PP
References _extra_send_list_context, and _extra_send_list_function\&.
.PP
.nf
299   { _extra_send_list_function = func; _extra_send_list_context = context; }
.fi
.SS "void libMesh::DofMap::attach_extra_send_list_object (\fBDofMap::AugmentSendList\fP &asl)\fC [inline]\fP"
Attach an object to populate the send_list with extra entries\&. This should only add to the send list, but no checking is done to enforce this behavior\&.
.PP
This is an advanced function\&.\&.\&. use at your own peril! 
.PP
Definition at line 289 of file dof_map\&.h\&.
.PP
References _augment_send_list\&.
.PP
.nf
290   {
291     _augment_send_list = &asl;
292   }
.fi
.SS "void libMesh::DofMap::attach_extra_sparsity_function (void(*)(\fBSparsityPattern::Graph\fP &sparsity, std::vector< \fBdof_id_type\fP > &n_nz, std::vector< \fBdof_id_type\fP > &n_oz, void *)func, void *context = \fCNULL\fP)\fC [inline]\fP"
Attach a function pointer to use as a callback to populate the sparsity pattern with extra entries\&.
.PP
Care must be taken that when adding entries they are sorted into the Rows
.PP
Further, you \fImust\fP modify n_nz and n_oz properly!
.PP
This is an advanced function\&.\&.\&. use at your own peril! 
.PP
Definition at line 275 of file dof_map\&.h\&.
.PP
References _extra_sparsity_context, and _extra_sparsity_function\&.
.PP
.nf
280   { _extra_sparsity_function = func; _extra_sparsity_context = context; }
.fi
.SS "void libMesh::DofMap::attach_extra_sparsity_object (\fBDofMap::AugmentSparsityPattern\fP &asp)\fC [inline]\fP"
Attach an object to use to populate the sparsity pattern with extra entries\&.
.PP
Care must be taken that when adding entries they are sorted into the Rows
.PP
Further, you \fImust\fP modify n_nz and n_oz properly!
.PP
This is an advanced function\&.\&.\&. use at your own peril! 
.PP
Definition at line 260 of file dof_map\&.h\&.
.PP
References _augment_sparsity_pattern\&.
.PP
.nf
261   {
262     _augment_sparsity_pattern = &asp;
263   }
.fi
.SS "void libMesh::DofMap::attach_matrix (\fBSparseMatrix\fP< \fBNumber\fP > &matrix)"
Additional matrices may be handled with this \fC\fBDofMap\fP\fP\&. They are initialized to the same sparsity structure as the major matrix\&. 
.PP
Definition at line 225 of file dof_map\&.C\&.
.PP
References _matrices, _n_nz, _n_oz, _sp, libMesh::SparseMatrix< T >::attach_dof_map(), libMesh::ParallelObject::comm(), libMesh::AutoPtr< Tp >::get(), libMesh::libmesh_assert(), libMesh::Parallel::Communicator::max(), libMesh::SparseMatrix< T >::need_full_sparsity_pattern(), need_full_sparsity_pattern, libMesh::SparsityPattern::Build::sparsity_pattern, and libMesh::SparseMatrix< T >::update_sparsity_pattern()\&.
.PP
Referenced by libMesh::EigenSystem::init_matrices(), and libMesh::ImplicitSystem::init_matrices()\&.
.PP
.nf
226 {
227   parallel_object_only();
228 
229   // We shouldn't be trying to re-attach the same matrices repeatedly
230   libmesh_assert (std::find(_matrices\&.begin(), _matrices\&.end(),
231                             &matrix) == _matrices\&.end());
232 
233   _matrices\&.push_back(&matrix);
234 
235   matrix\&.attach_dof_map (*this);
236 
237   // If we've already computed sparsity, then it's too late
238   // to wait for "compute_sparsity" to help with sparse matrix
239   // initialization, and we need to handle this matrix individually
240   bool computed_sparsity_already =
241     ((_n_nz && !_n_nz->empty()) ||
242      (_n_oz && !_n_oz->empty()));
243   this->comm()\&.max(computed_sparsity_already);
244   if (computed_sparsity_already &&
245       matrix\&.need_full_sparsity_pattern())
246     {
247       // We'd better have already computed the full sparsity pattern
248       // if we need it here
249       libmesh_assert(need_full_sparsity_pattern);
250       libmesh_assert(_sp\&.get());
251 
252       matrix\&.update_sparsity_pattern (_sp->sparsity_pattern);
253     }
254 
255   if (matrix\&.need_full_sparsity_pattern())
256     need_full_sparsity_pattern = true;
257 }
.fi
.SS "unsigned int libMesh::DofMap::block_size () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the block size, if the variables are amenable to block storage\&. Otherwise 1\&. 
.RE
.PP

.PP
Definition at line 416 of file dof_map\&.h\&.
.PP
References has_blocked_representation(), and n_variables()\&.
.PP
.nf
417   {
418 #ifdef LIBMESH_ENABLE_BLOCKED_STORAGE
419     return (this->has_blocked_representation() ? this->n_variables() : 1);
420 #else
421     return 1;
422 #endif
423   }
.fi
.SS "void libMesh::DofMap::build_constraint_matrix (\fBDenseMatrix\fP< \fBNumber\fP > &C, std::vector< \fBdof_id_type\fP > &elem_dofs, const boolcalled_recursively = \fCfalse\fP) const\fC [private]\fP"
Build the constraint matrix C associated with the element degree of freedom indices elem_dofs\&. The optional parameter \fCcalled_recursively\fP should be left at the default value \fCfalse\fP\&. This is used to handle the special case of an element's degrees of freedom being constrained in terms of other, local degrees of freedom\&. The usual case is for an elements DOFs to be constrained by some other, external DOFs\&. 
.PP
Definition at line 2132 of file dof_map_constraints\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseMatrix< T >::resize(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
2135 {
2136   if (!called_recursively) START_LOG("build_constraint_matrix()", "DofMap");
2137 
2138   // Create a set containing the DOFs we already depend on
2139   typedef std::set<dof_id_type> RCSet;
2140   RCSet dof_set;
2141 
2142   bool we_have_constraints = false;
2143 
2144   // Next insert any other dofs the current dofs might be constrained
2145   // in terms of\&.  Note that in this case we may not be done: Those
2146   // may in turn depend on others\&.  So, we need to repeat this process
2147   // in that case until the system depends only on unconstrained
2148   // degrees of freedom\&.
2149   for (unsigned int i=0; i<elem_dofs\&.size(); i++)
2150     if (this->is_constrained_dof(elem_dofs[i]))
2151       {
2152         we_have_constraints = true;
2153 
2154         // If the DOF is constrained
2155         DofConstraints::const_iterator
2156           pos = _dof_constraints\&.find(elem_dofs[i]);
2157 
2158         libmesh_assert (pos != _dof_constraints\&.end());
2159 
2160         const DofConstraintRow& constraint_row = pos->second;
2161 
2162         // Constraint rows in p refinement may be empty
2163         //libmesh_assert (!constraint_row\&.empty());
2164 
2165         for (DofConstraintRow::const_iterator
2166                it=constraint_row\&.begin(); it != constraint_row\&.end();
2167              ++it)
2168           dof_set\&.insert (it->first);
2169       }
2170 
2171   // May be safe to return at this point
2172   // (but remember to stop the perflog)
2173   if (!we_have_constraints)
2174     {
2175       STOP_LOG("build_constraint_matrix()", "DofMap");
2176       return;
2177     }
2178 
2179   for (unsigned int i=0; i != elem_dofs\&.size(); ++i)
2180     dof_set\&.erase (elem_dofs[i]);
2181 
2182   // If we added any DOFS then we need to do this recursively\&.
2183   // It is possible that we just added a DOF that is also
2184   // constrained!
2185   //
2186   // Also, we need to handle the special case of an element having DOFs
2187   // constrained in terms of other, local DOFs
2188   if (!dof_set\&.empty() ||  // case 1: constrained in terms of other DOFs
2189       !called_recursively) // case 2: constrained in terms of our own DOFs
2190     {
2191       const unsigned int old_size =
2192         libmesh_cast_int<unsigned int>(elem_dofs\&.size());
2193 
2194       // Add new dependency dofs to the end of the current dof set
2195       elem_dofs\&.insert(elem_dofs\&.end(),
2196                        dof_set\&.begin(), dof_set\&.end());
2197 
2198       // Now we can build the constraint matrix\&.
2199       // Note that resize also zeros for a DenseMatrix<Number>\&.
2200       C\&.resize (old_size,
2201                 libmesh_cast_int<unsigned int>(elem_dofs\&.size()));
2202 
2203       // Create the C constraint matrix\&.
2204       for (unsigned int i=0; i != old_size; i++)
2205         if (this->is_constrained_dof(elem_dofs[i]))
2206           {
2207             // If the DOF is constrained
2208             DofConstraints::const_iterator
2209               pos = _dof_constraints\&.find(elem_dofs[i]);
2210 
2211             libmesh_assert (pos != _dof_constraints\&.end());
2212 
2213             const DofConstraintRow& constraint_row = pos->second;
2214 
2215             // p refinement creates empty constraint rows
2216             //    libmesh_assert (!constraint_row\&.empty());
2217 
2218             for (DofConstraintRow::const_iterator
2219                    it=constraint_row\&.begin(); it != constraint_row\&.end();
2220                  ++it)
2221               for (unsigned int j=0; j != elem_dofs\&.size(); j++)
2222                 if (elem_dofs[j] == it->first)
2223                   C(i,j) = it->second;
2224           }
2225         else
2226           {
2227             C(i,i) = 1\&.;
2228           }
2229 
2230       // May need to do this recursively\&.  It is possible
2231       // that we just replaced a constrained DOF with another
2232       // constrained DOF\&.
2233       DenseMatrix<Number> Cnew;
2234 
2235       this->build_constraint_matrix (Cnew, elem_dofs, true);
2236 
2237       if ((C\&.n() == Cnew\&.m()) &&
2238           (Cnew\&.n() == elem_dofs\&.size())) // If the constraint matrix
2239         C\&.right_multiply(Cnew);           // is constrained\&.\&.\&.
2240 
2241       libmesh_assert_equal_to (C\&.n(), elem_dofs\&.size());
2242     }
2243 
2244   if (!called_recursively) STOP_LOG("build_constraint_matrix()", "DofMap");
2245 }
.fi
.SS "void libMesh::DofMap::build_constraint_matrix_and_vector (\fBDenseMatrix\fP< \fBNumber\fP > &C, \fBDenseVector\fP< \fBNumber\fP > &H, std::vector< \fBdof_id_type\fP > &elem_dofs, intqoi_index = \fC-1\fP, const boolcalled_recursively = \fCfalse\fP) const\fC [private]\fP"
Build the constraint matrix C and the forcing vector H associated with the element degree of freedom indices elem_dofs\&. The optional parameter \fCcalled_recursively\fP should be left at the default value \fCfalse\fP\&. This is used to handle the special case of an element's degrees of freedom being constrained in terms of other, local degrees of freedom\&. The usual case is for an elements DOFs to be constrained by some other, external DOFs and/or Dirichlet conditions\&.
.PP
The forcing vector will depend on which solution's heterogenous constraints are being applied\&. For the default \fCqoi_index\fP this will be the primal solutoin; for \fCqoi_index\fP >= 0 the corresponding adjoint solution's constraints will be used\&. 
.PP
Definition at line 2250 of file dof_map_constraints\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::DenseMatrix< T >::vector_mult_add()\&.
.PP
Referenced by extract_local_vector()\&.
.PP
.nf
2255 {
2256   if (!called_recursively)
2257     START_LOG("build_constraint_matrix_and_vector()", "DofMap");
2258 
2259   // Create a set containing the DOFs we already depend on
2260   typedef std::set<dof_id_type> RCSet;
2261   RCSet dof_set;
2262 
2263   bool we_have_constraints = false;
2264 
2265   // Next insert any other dofs the current dofs might be constrained
2266   // in terms of\&.  Note that in this case we may not be done: Those
2267   // may in turn depend on others\&.  So, we need to repeat this process
2268   // in that case until the system depends only on unconstrained
2269   // degrees of freedom\&.
2270   for (unsigned int i=0; i<elem_dofs\&.size(); i++)
2271     if (this->is_constrained_dof(elem_dofs[i]))
2272       {
2273         we_have_constraints = true;
2274 
2275         // If the DOF is constrained
2276         DofConstraints::const_iterator
2277           pos = _dof_constraints\&.find(elem_dofs[i]);
2278 
2279         libmesh_assert (pos != _dof_constraints\&.end());
2280 
2281         const DofConstraintRow& constraint_row = pos->second;
2282 
2283         // Constraint rows in p refinement may be empty
2284         //libmesh_assert (!constraint_row\&.empty());
2285 
2286         for (DofConstraintRow::const_iterator
2287                it=constraint_row\&.begin(); it != constraint_row\&.end();
2288              ++it)
2289           dof_set\&.insert (it->first);
2290       }
2291 
2292   // May be safe to return at this point
2293   // (but remember to stop the perflog)
2294   if (!we_have_constraints)
2295     {
2296       STOP_LOG("build_constraint_matrix_and_vector()", "DofMap");
2297       return;
2298     }
2299 
2300   for (unsigned int i=0; i != elem_dofs\&.size(); ++i)
2301     dof_set\&.erase (elem_dofs[i]);
2302 
2303   // If we added any DOFS then we need to do this recursively\&.
2304   // It is possible that we just added a DOF that is also
2305   // constrained!
2306   //
2307   // Also, we need to handle the special case of an element having DOFs
2308   // constrained in terms of other, local DOFs
2309   if (!dof_set\&.empty() ||  // case 1: constrained in terms of other DOFs
2310       !called_recursively) // case 2: constrained in terms of our own DOFs
2311     {
2312       const DofConstraintValueMap *rhs_values = NULL;
2313       if (qoi_index < 0)
2314         rhs_values = &_primal_constraint_values;
2315       else
2316         {
2317           const AdjointDofConstraintValues::const_iterator
2318             it = _adjoint_constraint_values\&.find(qoi_index);
2319           if (it != _adjoint_constraint_values\&.end())
2320             rhs_values = &it->second;
2321         }
2322 
2323       const unsigned int old_size =
2324         libmesh_cast_int<unsigned int>(elem_dofs\&.size());
2325 
2326       // Add new dependency dofs to the end of the current dof set
2327       elem_dofs\&.insert(elem_dofs\&.end(),
2328                        dof_set\&.begin(), dof_set\&.end());
2329 
2330       // Now we can build the constraint matrix and vector\&.
2331       // Note that resize also zeros for a DenseMatrix and DenseVector
2332       C\&.resize (old_size,
2333                 libmesh_cast_int<unsigned int>(elem_dofs\&.size()));
2334       H\&.resize (old_size);
2335 
2336       // Create the C constraint matrix\&.
2337       for (unsigned int i=0; i != old_size; i++)
2338         if (this->is_constrained_dof(elem_dofs[i]))
2339           {
2340             // If the DOF is constrained
2341             DofConstraints::const_iterator
2342               pos = _dof_constraints\&.find(elem_dofs[i]);
2343 
2344             libmesh_assert (pos != _dof_constraints\&.end());
2345 
2346             const DofConstraintRow& constraint_row = pos->second;
2347 
2348             // p refinement creates empty constraint rows
2349             //    libmesh_assert (!constraint_row\&.empty());
2350 
2351             for (DofConstraintRow::const_iterator
2352                    it=constraint_row\&.begin(); it != constraint_row\&.end();
2353                  ++it)
2354               for (unsigned int j=0; j != elem_dofs\&.size(); j++)
2355                 if (elem_dofs[j] == it->first)
2356                   C(i,j) = it->second;
2357 
2358             if (rhs_values)
2359               {
2360                 DofConstraintValueMap::const_iterator rhsit =
2361                   rhs_values->find(elem_dofs[i]);
2362                 if (rhsit != rhs_values->end())
2363                   H(i) = rhsit->second;
2364               }
2365           }
2366         else
2367           {
2368             C(i,i) = 1\&.;
2369           }
2370 
2371       // May need to do this recursively\&.  It is possible
2372       // that we just replaced a constrained DOF with another
2373       // constrained DOF\&.
2374       DenseMatrix<Number> Cnew;
2375       DenseVector<Number> Hnew;
2376 
2377       this->build_constraint_matrix_and_vector (Cnew, Hnew, elem_dofs,
2378                                                 qoi_index, true);
2379 
2380       if ((C\&.n() == Cnew\&.m()) &&          // If the constraint matrix
2381           (Cnew\&.n() == elem_dofs\&.size())) // is constrained\&.\&.\&.
2382         {
2383           C\&.right_multiply(Cnew);
2384 
2385           // If x = Cy + h and y = Dz + g
2386           // Then x = (CD)z + (Cg + h)
2387           C\&.vector_mult_add(H, 1, Hnew);
2388         }
2389 
2390       libmesh_assert_equal_to (C\&.n(), elem_dofs\&.size());
2391     }
2392 
2393   if (!called_recursively)
2394     STOP_LOG("build_constraint_matrix_and_vector()", "DofMap");
2395 }
.fi
.SS "\fBAutoPtr\fP< \fBSparsityPattern::Build\fP > libMesh::DofMap::build_sparsity (const \fBMeshBase\fP &mesh) const\fC [private]\fP"
Builds a sparsity pattern 
.PP
Definition at line 55 of file dof_map\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::MeshBase::is_prepared(), libMesh::libmesh_assert(), libMesh::SparsityPattern::Build::n_nz, libMesh::SparsityPattern::Build::n_oz, libMesh::out, libMesh::Threads::parallel_reduce(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::ParallelObject::processor_id(), libMesh::SparsityPattern::Build::sparsity_pattern, libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
Referenced by compute_sparsity()\&.
.PP
.nf
56 {
57   libmesh_assert (mesh\&.is_prepared());
58 
59   START_LOG("build_sparsity()", "DofMap");
60 
61   // Compute the sparsity structure of the global matrix\&.  This can be
62   // fed into a PetscMatrix to allocate exacly the number of nonzeros
63   // necessary to store the matrix\&.  This algorithm should be linear
64   // in the (# of elements)*(# nodes per element)
65 
66   // We can be more efficient in the threaded sparsity pattern assembly
67   // if we don't need the exact pattern\&.  For some sparse matrix formats
68   // a good upper bound will suffice\&.
69 
70   // See if we need to include sparsity pattern entries for coupling
71   // between neighbor dofs
72   bool implicit_neighbor_dofs = this->use_coupled_neighbor_dofs(mesh);
73 
74   // We can compute the sparsity pattern in parallel on multiple
75   // threads\&.  The goal is for each thread to compute the full sparsity
76   // pattern for a subset of elements\&.  These sparsity patterns can
77   // be efficiently merged in the SparsityPattern::Build::join()
78   // method, especially if there is not too much overlap between them\&.
79   // Even better, if the full sparsity pattern is not needed then
80   // the number of nonzeros per row can be estimated from the
81   // sparsity patterns created on each thread\&.
82   AutoPtr<SparsityPattern::Build> sp
83     (new SparsityPattern::Build (mesh,
84                                  *this,
85                                  this->_dof_coupling,
86                                  implicit_neighbor_dofs,
87                                  need_full_sparsity_pattern));
88 
89   Threads::parallel_reduce (ConstElemRange (mesh\&.active_local_elements_begin(),
90                                             mesh\&.active_local_elements_end()), *sp);
91 
92   sp->parallel_sync();
93 
94 #ifndef NDEBUG
95   // Avoid declaring these variables unless asserts are enabled\&.
96   const processor_id_type proc_id        = mesh\&.processor_id();
97   const dof_id_type n_dofs_on_proc = this->n_dofs_on_processor(proc_id);
98 #endif
99   libmesh_assert_equal_to (sp->sparsity_pattern\&.size(), n_dofs_on_proc);
100 
101   STOP_LOG("build_sparsity()", "DofMap");
102 
103   // Check to see if we have any extra stuff to add to the sparsity_pattern
104   if (_extra_sparsity_function)
105     {
106       if (_augment_sparsity_pattern)
107         {
108           libmesh_here();
109           libMesh::out << "WARNING:  You have specified both an extra sparsity function and object\&.\n"
110                        << "          Are you sure this is what you meant to do??"
111                        << std::endl;
112         }
113 
114       _extra_sparsity_function
115         (sp->sparsity_pattern, sp->n_nz,
116          sp->n_oz, _extra_sparsity_context);
117     }
118 
119   if (_augment_sparsity_pattern)
120     _augment_sparsity_pattern->augment_sparsity_pattern
121       (sp->sparsity_pattern, sp->n_nz, sp->n_oz);
122 
123   return sp;
124 }
.fi
.SS "void libMesh::DofMap::clear ()"
Free all memory associated with the object, but keep the mesh pointer\&. 
.PP
Definition at line 808 of file dof_map\&.C\&.
.PP
References _adjoint_constraint_values, _dof_constraints, _end_df, _end_old_df, _first_df, _first_old_df, _matrices, _n_dfs, _n_old_dfs, _primal_constraint_values, _send_list, _variable_groups, _variables, clear_sparsity(), and need_full_sparsity_pattern\&.
.PP
Referenced by DofMap()\&.
.PP
.nf
809 {
810   // we don't want to clear
811   // the coupling matrix!
812   // It should not change\&.\&.\&.
813   //_dof_coupling->clear();
814 
815   _variables\&.clear();
816   _variable_groups\&.clear();
817   _first_df\&.clear();
818   _end_df\&.clear();
819   _send_list\&.clear();
820   this->clear_sparsity();
821   need_full_sparsity_pattern = false;
822 
823 #ifdef LIBMESH_ENABLE_AMR
824 
825   _dof_constraints\&.clear();
826   _primal_constraint_values\&.clear();
827   _adjoint_constraint_values\&.clear();
828   _n_old_dfs = 0;
829   _first_old_df\&.clear();
830   _end_old_df\&.clear();
831 
832 #endif
833 
834   _matrices\&.clear();
835 
836   _n_dfs = 0;
837 }
.fi
.SS "void libMesh::DofMap::clear_sparsity ()"
Clears the sparsity pattern 
.PP
Definition at line 1638 of file dof_map\&.C\&.
.PP
References _n_nz, _n_oz, _sp, libMesh::AutoPtr< Tp >::get(), libMesh::libmesh_assert(), libMesh::SparsityPattern::Build::n_nz, libMesh::SparsityPattern::Build::n_oz, need_full_sparsity_pattern, and libMesh::AutoPtr< Tp >::reset()\&.
.PP
Referenced by clear(), libMesh::ImplicitSystem::reinit(), and libMesh::EigenSystem::reinit()\&.
.PP
.nf
1639 {
1640   if (need_full_sparsity_pattern)
1641     {
1642       libmesh_assert(_sp\&.get());
1643       libmesh_assert(!_n_nz || _n_nz == &_sp->n_nz);
1644       libmesh_assert(!_n_oz || _n_oz == &_sp->n_oz);
1645       _sp\&.reset();
1646     }
1647   else
1648     {
1649       libmesh_assert(!_sp\&.get());
1650       delete _n_nz;
1651       delete _n_oz;
1652     }
1653   _n_nz = NULL;
1654   _n_oz = NULL;
1655 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "void libMesh::DofMap::compute_sparsity (const \fBMeshBase\fP &mesh)"
Computes the sparsity pattern for the matrices corresponding to \fCproc_id\fP and sends that data to \fBLinear\fP Algebra packages for preallocation of sparse matrices\&. 
.PP
Definition at line 1601 of file dof_map\&.C\&.
.PP
References _matrices, _n_nz, _n_oz, _sp, build_sparsity(), end, libMesh::SparsityPattern::Build::n_nz, libMesh::SparsityPattern::Build::n_oz, need_full_sparsity_pattern, libMesh::AutoPtr< Tp >::reset(), and libMesh::SparsityPattern::Build::sparsity_pattern\&.
.PP
Referenced by libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), libMesh::ImplicitSystem::reinit(), and libMesh::EigenSystem::reinit()\&.
.PP
.nf
1602 {
1603   _sp = this->build_sparsity(mesh);
1604 
1605   // It is possible that some \p SparseMatrix implementations want to
1606   // see it\&.  Let them see it before we throw it away\&.
1607   std::vector<SparseMatrix<Number>* >::const_iterator
1608     pos = _matrices\&.begin(),
1609     end = _matrices\&.end();
1610 
1611   // If we need the full sparsity pattern, then we share a view of its
1612   // arrays, and we pass it in to the matrices\&.
1613   if (need_full_sparsity_pattern)
1614     {
1615       _n_nz = &_sp->n_nz;
1616       _n_oz = &_sp->n_oz;
1617 
1618       for (; pos != end; ++pos)
1619         (*pos)->update_sparsity_pattern (_sp->sparsity_pattern);
1620     }
1621   // If we don't need the full sparsity pattern anymore, steal the
1622   // arrays we do need and free the rest of the memory
1623   else
1624     {
1625       if (!_n_nz)
1626         _n_nz = new std::vector<dof_id_type>();
1627       _n_nz->swap(_sp->n_nz);
1628       if (!_n_oz)
1629         _n_oz = new std::vector<dof_id_type>();
1630       _n_oz->swap(_sp->n_oz);
1631 
1632       _sp\&.reset();
1633     }
1634 }
.fi
.SS "void libMesh::DofMap::constrain_element_dyad_matrix (\fBDenseVector\fP< \fBNumber\fP > &v, \fBDenseVector\fP< \fBNumber\fP > &w, std::vector< \fBdof_id_type\fP > &row_dofs, boolasymmetric_constraint_rows = \fCtrue\fP) const\fC [inline]\fP"
Constrains a dyadic element matrix B = v w'\&. This method requires the element matrix to be square, in which case the elem_dofs correspond to the global DOF indices of both the rows and columns of the element matrix\&. For this case the rows and columns of the matrix necessarily correspond to variables of the same approximation order\&. 
.PP
Definition at line 1768 of file dof_map_constraints\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::DenseMatrix< T >::vector_mult_transpose()\&.
.PP
.nf
1772 {
1773   libmesh_assert_equal_to (v\&.size(), row_dofs\&.size());
1774   libmesh_assert_equal_to (w\&.size(), row_dofs\&.size());
1775 
1776   // check for easy return
1777   if (this->_dof_constraints\&.empty())
1778     return;
1779 
1780   // The constrained RHS is built up as R^T F\&.
1781   DenseMatrix<Number> R;
1782 
1783   this->build_constraint_matrix (R, row_dofs);
1784 
1785   START_LOG("cnstrn_elem_dyad_mat()", "DofMap");
1786 
1787   // It is possible that the vector is not constrained at all\&.
1788   if ((R\&.m() == v\&.size()) &&
1789       (R\&.n() == row_dofs\&.size())) // if the RHS is constrained
1790     {
1791       // Compute the matrix-vector products
1792       DenseVector<Number> old_v(v);
1793       DenseVector<Number> old_w(w);
1794 
1795       // compute matrix/vector product
1796       R\&.vector_mult_transpose(v, old_v);
1797       R\&.vector_mult_transpose(w, old_w);
1798 
1799       libmesh_assert_equal_to (row_dofs\&.size(), v\&.size());
1800       libmesh_assert_equal_to (row_dofs\&.size(), w\&.size());
1801 
1802       /* Constrain only v, not w\&.  */
1803 
1804       for (unsigned int i=0; i<row_dofs\&.size(); i++)
1805         if (this->is_constrained_dof(row_dofs[i]))
1806           {
1807             // If the DOF is constrained
1808             libmesh_assert (_dof_constraints\&.find(row_dofs[i]) != _dof_constraints\&.end());
1809 
1810             v(i) = 0;
1811           }
1812     } // end if the RHS is constrained\&.
1813 
1814   STOP_LOG("cnstrn_elem_dyad_mat()", "DofMap");
1815 }
.fi
.SS "void libMesh::DofMap::constrain_element_matrix (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, std::vector< \fBdof_id_type\fP > &elem_dofs, boolasymmetric_constraint_rows = \fCtrue\fP) const\fC [inline]\fP"
Constrains the element matrix\&. This method requires the element matrix to be square, in which case the elem_dofs correspond to the global DOF indices of both the rows and columns of the element matrix\&. For this case the rows and columns of the matrix necessarily correspond to variables of the same approximation order\&.
.PP
If \fCasymmetric_constraint_rows\fP is set to true (as it is by default), constraint row equations will be reinforced in a way which breaks matrix symmetry but makes inexact linear solver solutions more likely to satisfy hanging node constraints\&. 
.PP
Definition at line 1302 of file dof_map_constraints\&.C\&.
.PP
References libMesh::DenseMatrix< T >::left_multiply_transpose(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
1305 {
1306   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.m());
1307   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.n());
1308 
1309   // check for easy return
1310   if (this->_dof_constraints\&.empty())
1311     return;
1312 
1313   // The constrained matrix is built up as C^T K C\&.
1314   DenseMatrix<Number> C;
1315 
1316 
1317   this->build_constraint_matrix (C, elem_dofs);
1318 
1319   START_LOG("constrain_elem_matrix()", "DofMap");
1320 
1321   // It is possible that the matrix is not constrained at all\&.
1322   if ((C\&.m() == matrix\&.m()) &&
1323       (C\&.n() == elem_dofs\&.size())) // It the matrix is constrained
1324     {
1325       // Compute the matrix-matrix-matrix product C^T K C
1326       matrix\&.left_multiply_transpose  (C);
1327       matrix\&.right_multiply (C);
1328 
1329 
1330       libmesh_assert_equal_to (matrix\&.m(), matrix\&.n());
1331       libmesh_assert_equal_to (matrix\&.m(), elem_dofs\&.size());
1332       libmesh_assert_equal_to (matrix\&.n(), elem_dofs\&.size());
1333 
1334 
1335       for (unsigned int i=0; i<elem_dofs\&.size(); i++)
1336         // If the DOF is constrained
1337         if (this->is_constrained_dof(elem_dofs[i]))
1338           {
1339             for (unsigned int j=0; j<matrix\&.n(); j++)
1340               matrix(i,j) = 0\&.;
1341 
1342             matrix(i,i) = 1\&.;
1343 
1344             if (asymmetric_constraint_rows)
1345               {
1346                 DofConstraints::const_iterator
1347                   pos = _dof_constraints\&.find(elem_dofs[i]);
1348 
1349                 libmesh_assert (pos != _dof_constraints\&.end());
1350 
1351                 const DofConstraintRow& constraint_row = pos->second;
1352 
1353                 // This is an overzealous assertion in the presence of
1354                 // heterogenous constraints: we now can constrain "u_i = c"
1355                 // with no other u_j terms involved\&.
1356                 //
1357                 // libmesh_assert (!constraint_row\&.empty());
1358 
1359                 for (DofConstraintRow::const_iterator
1360                        it=constraint_row\&.begin(); it != constraint_row\&.end();
1361                      ++it)
1362                   for (unsigned int j=0; j<elem_dofs\&.size(); j++)
1363                     if (elem_dofs[j] == it->first)
1364                       matrix(i,j) = -it->second;
1365               }
1366           }
1367     } // end if is constrained\&.\&.\&.
1368 
1369   STOP_LOG("constrain_elem_matrix()", "DofMap");
1370 }
.fi
.SS "void libMesh::DofMap::constrain_element_matrix (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, std::vector< \fBdof_id_type\fP > &row_dofs, std::vector< \fBdof_id_type\fP > &col_dofs, boolasymmetric_constraint_rows = \fCtrue\fP) const\fC [inline]\fP"
Constrains the element matrix\&. This method allows the element matrix to be non-square, in which case the row_dofs and col_dofs may be of different size and correspond to variables approximated in different spaces\&. 
.PP
Definition at line 1643 of file dof_map_constraints\&.C\&.
.PP
References libMesh::DenseMatrix< T >::left_multiply_transpose(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
1647 {
1648   libmesh_assert_equal_to (row_dofs\&.size(), matrix\&.m());
1649   libmesh_assert_equal_to (col_dofs\&.size(), matrix\&.n());
1650 
1651   // check for easy return
1652   if (this->_dof_constraints\&.empty())
1653     return;
1654 
1655   // The constrained matrix is built up as R^T K C\&.
1656   DenseMatrix<Number> R;
1657   DenseMatrix<Number> C;
1658 
1659   // Safeguard against the user passing us the same
1660   // object for row_dofs and col_dofs\&.  If that is done
1661   // the calls to build_matrix would fail
1662   std::vector<dof_id_type> orig_row_dofs(row_dofs);
1663   std::vector<dof_id_type> orig_col_dofs(col_dofs);
1664 
1665   this->build_constraint_matrix (R, orig_row_dofs);
1666   this->build_constraint_matrix (C, orig_col_dofs);
1667 
1668   START_LOG("constrain_elem_matrix()", "DofMap");
1669 
1670   row_dofs = orig_row_dofs;
1671   col_dofs = orig_col_dofs;
1672 
1673 
1674   // It is possible that the matrix is not constrained at all\&.
1675   if ((R\&.m() == matrix\&.m()) &&
1676       (R\&.n() == row_dofs\&.size()) &&
1677       (C\&.m() == matrix\&.n()) &&
1678       (C\&.n() == col_dofs\&.size())) // If the matrix is constrained
1679     {
1680       // K_constrained = R^T K C
1681       matrix\&.left_multiply_transpose  (R);
1682       matrix\&.right_multiply (C);
1683 
1684 
1685       libmesh_assert_equal_to (matrix\&.m(), row_dofs\&.size());
1686       libmesh_assert_equal_to (matrix\&.n(), col_dofs\&.size());
1687 
1688 
1689       for (unsigned int i=0; i<row_dofs\&.size(); i++)
1690         if (this->is_constrained_dof(row_dofs[i]))
1691           {
1692             for (unsigned int j=0; j<matrix\&.n(); j++)
1693               {
1694                 if(row_dofs[i] != col_dofs[j])
1695                   matrix(i,j) = 0\&.;
1696                 else // If the DOF is constrained
1697                   matrix(i,j) = 1\&.;
1698               }
1699 
1700             if (asymmetric_constraint_rows)
1701               {
1702                 DofConstraints::const_iterator
1703                   pos = _dof_constraints\&.find(row_dofs[i]);
1704 
1705                 libmesh_assert (pos != _dof_constraints\&.end());
1706 
1707                 const DofConstraintRow& constraint_row = pos->second;
1708 
1709                 libmesh_assert (!constraint_row\&.empty());
1710 
1711                 for (DofConstraintRow::const_iterator
1712                        it=constraint_row\&.begin(); it != constraint_row\&.end();
1713                      ++it)
1714                   for (unsigned int j=0; j<col_dofs\&.size(); j++)
1715                     if (col_dofs[j] == it->first)
1716                       matrix(i,j) = -it->second;
1717               }
1718           }
1719     } // end if is constrained\&.\&.\&.
1720 
1721   STOP_LOG("constrain_elem_matrix()", "DofMap");
1722 }
.fi
.SS "void libMesh::DofMap::constrain_element_matrix_and_vector (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, boolasymmetric_constraint_rows = \fCtrue\fP) const\fC [inline]\fP"
Constrains the element matrix and vector\&. This method requires the element matrix to be square, in which case the elem_dofs correspond to the global DOF indices of both the rows and columns of the element matrix\&. For this case the rows and columns of the matrix necessarily correspond to variables of the same approximation order\&. 
.PP
Definition at line 1374 of file dof_map_constraints\&.C\&.
.PP
References libMesh::DenseMatrix< T >::left_multiply_transpose(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::DenseVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::DenseMatrix< T >::vector_mult_transpose()\&.
.PP
.nf
1378 {
1379   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.m());
1380   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.n());
1381   libmesh_assert_equal_to (elem_dofs\&.size(), rhs\&.size());
1382 
1383   // check for easy return
1384   if (this->_dof_constraints\&.empty())
1385     return;
1386 
1387   // The constrained matrix is built up as C^T K C\&.
1388   // The constrained RHS is built up as C^T F
1389   DenseMatrix<Number> C;
1390 
1391   this->build_constraint_matrix (C, elem_dofs);
1392 
1393   START_LOG("cnstrn_elem_mat_vec()", "DofMap");
1394 
1395   // It is possible that the matrix is not constrained at all\&.
1396   if ((C\&.m() == matrix\&.m()) &&
1397       (C\&.n() == elem_dofs\&.size())) // It the matrix is constrained
1398     {
1399       // Compute the matrix-matrix-matrix product C^T K C
1400       matrix\&.left_multiply_transpose  (C);
1401       matrix\&.right_multiply (C);
1402 
1403 
1404       libmesh_assert_equal_to (matrix\&.m(), matrix\&.n());
1405       libmesh_assert_equal_to (matrix\&.m(), elem_dofs\&.size());
1406       libmesh_assert_equal_to (matrix\&.n(), elem_dofs\&.size());
1407 
1408 
1409       for (unsigned int i=0; i<elem_dofs\&.size(); i++)
1410         if (this->is_constrained_dof(elem_dofs[i]))
1411           {
1412             for (unsigned int j=0; j<matrix\&.n(); j++)
1413               matrix(i,j) = 0\&.;
1414 
1415             // If the DOF is constrained
1416             matrix(i,i) = 1\&.;
1417 
1418             // This will put a nonsymmetric entry in the constraint
1419             // row to ensure that the linear system produces the
1420             // correct value for the constrained DOF\&.
1421             if (asymmetric_constraint_rows)
1422               {
1423                 DofConstraints::const_iterator
1424                   pos = _dof_constraints\&.find(elem_dofs[i]);
1425 
1426                 libmesh_assert (pos != _dof_constraints\&.end());
1427 
1428                 const DofConstraintRow& constraint_row = pos->second;
1429 
1430                 // p refinement creates empty constraint rows
1431                 //    libmesh_assert (!constraint_row\&.empty());
1432 
1433                 for (DofConstraintRow::const_iterator
1434                        it=constraint_row\&.begin(); it != constraint_row\&.end();
1435                      ++it)
1436                   for (unsigned int j=0; j<elem_dofs\&.size(); j++)
1437                     if (elem_dofs[j] == it->first)
1438                       matrix(i,j) = -it->second;
1439               }
1440           }
1441 
1442 
1443       // Compute the matrix-vector product C^T F
1444       DenseVector<Number> old_rhs(rhs);
1445 
1446       // compute matrix/vector product
1447       C\&.vector_mult_transpose(rhs, old_rhs);
1448     } // end if is constrained\&.\&.\&.
1449 
1450   STOP_LOG("cnstrn_elem_mat_vec()", "DofMap");
1451 }
.fi
.SS "void libMesh::DofMap::constrain_element_vector (\fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &dofs, boolasymmetric_constraint_rows = \fCtrue\fP) const\fC [inline]\fP"
Constrains the element vector\&. 
.PP
Definition at line 1726 of file dof_map_constraints\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::DenseMatrix< T >::vector_mult_transpose()\&.
.PP
.nf
1729 {
1730   libmesh_assert_equal_to (rhs\&.size(), row_dofs\&.size());
1731 
1732   // check for easy return
1733   if (this->_dof_constraints\&.empty())
1734     return;
1735 
1736   // The constrained RHS is built up as R^T F\&.
1737   DenseMatrix<Number> R;
1738 
1739   this->build_constraint_matrix (R, row_dofs);
1740 
1741   START_LOG("constrain_elem_vector()", "DofMap");
1742 
1743   // It is possible that the vector is not constrained at all\&.
1744   if ((R\&.m() == rhs\&.size()) &&
1745       (R\&.n() == row_dofs\&.size())) // if the RHS is constrained
1746     {
1747       // Compute the matrix-vector product
1748       DenseVector<Number> old_rhs(rhs);
1749       R\&.vector_mult_transpose(rhs, old_rhs);
1750 
1751       libmesh_assert_equal_to (row_dofs\&.size(), rhs\&.size());
1752 
1753       for (unsigned int i=0; i<row_dofs\&.size(); i++)
1754         if (this->is_constrained_dof(row_dofs[i]))
1755           {
1756             // If the DOF is constrained
1757             libmesh_assert (_dof_constraints\&.find(row_dofs[i]) != _dof_constraints\&.end());
1758 
1759             rhs(i) = 0;
1760           }
1761     } // end if the RHS is constrained\&.
1762 
1763   STOP_LOG("constrain_elem_vector()", "DofMap");
1764 }
.fi
.SS "void libMesh::DofMap::constrain_nothing (std::vector< \fBdof_id_type\fP > &dofs) const"
Does not actually constrain anything, but modifies \fCdofs\fP in the same way as any of the constrain functions would do, i\&.e\&. adds those dofs in terms of which any of the existing dofs is constrained\&. 
.PP
Definition at line 1819 of file dof_map_constraints\&.C\&.
.PP
.nf
1820 {
1821   // check for easy return
1822   if (this->_dof_constraints\&.empty())
1823     return;
1824 
1825   // All the work is done by \p build_constraint_matrix\&.  We just need
1826   // a dummy matrix\&.
1827   DenseMatrix<Number> R;
1828   this->build_constraint_matrix (R, dofs);
1829 }
.fi
.SS "void libMesh::DofMap::constrain_p_dofs (unsigned intvar, const \fBElem\fP *elem, unsigned ints, unsigned intp)"
Constrains degrees of freedom on side \fCs\fP of element \fCelem\fP which correspond to variable number \fCvar\fP and to p refinement levels above \fCp\fP\&. 
.PP
Definition at line 3525 of file dof_map_constraints\&.C\&.
.PP
References libMesh::Elem::dim(), libMesh::DofObject::dof_number(), libMesh::Elem::get_node(), libMesh::Elem::is_node_on_side(), libMesh::Elem::is_vertex(), libMesh::libmesh_assert_greater(), libMesh::DofObject::n_comp(), n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::Threads::spin_mtx, and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::compute_periodic_constraints(), and libMesh::FEGenericBase< T >::compute_proj_constraints()\&.
.PP
.nf
3529 {
3530   // We're constraining dofs on elem which correspond to p refinement
3531   // levels above p - this only makes sense if elem's p refinement
3532   // level is above p\&.
3533   libmesh_assert_greater (elem->p_level(), p);
3534   libmesh_assert_less (s, elem->n_sides());
3535 
3536   const unsigned int sys_num = this->sys_number();
3537   const unsigned int dim = elem->dim();
3538   ElemType type = elem->type();
3539   FEType low_p_fe_type = this->variable_type(var);
3540   FEType high_p_fe_type = this->variable_type(var);
3541   low_p_fe_type\&.order = static_cast<Order>(low_p_fe_type\&.order + p);
3542   high_p_fe_type\&.order = static_cast<Order>(high_p_fe_type\&.order +
3543                                             elem->p_level());
3544 
3545   const unsigned int n_nodes = elem->n_nodes();
3546   for (unsigned int n = 0; n != n_nodes; ++n)
3547     if (elem->is_node_on_side(n, s))
3548       {
3549         const Node * const node = elem->get_node(n);
3550         const unsigned int low_nc =
3551           FEInterface::n_dofs_at_node (dim, low_p_fe_type, type, n);
3552         const unsigned int high_nc =
3553           FEInterface::n_dofs_at_node (dim, high_p_fe_type, type, n);
3554 
3555         // since we may be running this method concurrently
3556         // on multiple threads we need to acquire a lock
3557         // before modifying the _dof_constraints object\&.
3558         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
3559 
3560         if (elem->is_vertex(n))
3561           {
3562             // Add "this is zero" constraint rows for high p vertex
3563             // dofs
3564             for (unsigned int i = low_nc; i != high_nc; ++i)
3565               {
3566                 _dof_constraints[node->dof_number(sys_num,var,i)]\&.clear();
3567                 _primal_constraint_values\&.erase(node->dof_number(sys_num,var,i));
3568               }
3569           }
3570         else
3571           {
3572             const unsigned int total_dofs = node->n_comp(sys_num, var);
3573             libmesh_assert_greater_equal (total_dofs, high_nc);
3574             // Add "this is zero" constraint rows for high p
3575             // non-vertex dofs, which are numbered in reverse
3576             for (unsigned int j = low_nc; j != high_nc; ++j)
3577               {
3578                 const unsigned int i = total_dofs - j - 1;
3579                 _dof_constraints[node->dof_number(sys_num,var,i)]\&.clear();
3580                 _primal_constraint_values\&.erase(node->dof_number(sys_num,var,i));
3581               }
3582           }
3583       }
3584 }
.fi
.SS "DofConstraints::const_iterator libMesh::DofMap::constraint_rows_begin () const\fC [inline]\fP"
Returns an iterator pointing to the first DoF constraint row 
.PP
Definition at line 659 of file dof_map\&.h\&.
.PP
References _dof_constraints\&.
.PP
.nf
660   { return _dof_constraints\&.begin(); }
.fi
.SS "DofConstraints::const_iterator libMesh::DofMap::constraint_rows_end () const\fC [inline]\fP"
Returns an iterator pointing just past the last DoF constraint row 
.PP
Definition at line 665 of file dof_map\&.h\&.
.PP
References _dof_constraints\&.
.PP
.nf
666   { return _dof_constraints\&.end(); }
.fi
.SS "void libMesh::DofMap::create_dof_constraints (const \fBMeshBase\fP &mesh, \fBReal\fPtime = \fC0\fP)"
Rebuilds the raw degree of freedom and \fBDofObject\fP constraints\&. A time is specified for use in building time-dependent Dirichlet constraints\&. 
.PP
Definition at line 941 of file dof_map_constraints\&.C\&.
.PP
References libMesh::comm, libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::StoredRange< iterator_type, object_type >::empty(), libMesh::MeshBase::is_prepared(), libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), libMesh::MeshBase::local_elements_begin(), libMesh::MeshBase::local_elements_end(), libMesh::MeshBase::mesh_dimension(), libMesh::Threads::parallel_for(), libMesh::StoredRange< iterator_type, object_type >::reset(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::verify()\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
942 {
943   parallel_object_only();
944 
945   START_LOG("create_dof_constraints()", "DofMap");
946 
947   libmesh_assert (mesh\&.is_prepared());
948 
949   // We might get constraint equations from AMR hanging nodes in 2D/3D
950   // or from boundary conditions in any dimension
951   const bool possible_local_constraints = false
952 #ifdef LIBMESH_ENABLE_AMR
953     || mesh\&.mesh_dimension() > 1
954 #endif
955 #ifdef LIBMESH_ENABLE_PERIODIC
956     || !_periodic_boundaries->empty()
957 #endif
958 #ifdef LIBMESH_ENABLE_DIRICHLET
959     || !_dirichlet_boundaries->empty()
960 #endif
961     ;
962 
963   // Even if we don't have constraints, another processor might\&.
964   bool possible_global_constraints = possible_local_constraints;
965 #if defined(LIBMESH_ENABLE_PERIODIC) || defined(LIBMESH_ENABLE_DIRICHLET) || defined(LIBMESH_ENABLE_AMR)
966   libmesh_assert(this->comm()\&.verify(mesh\&.is_serial()));
967 
968   if (!mesh\&.is_serial())
969     this->comm()\&.max(possible_global_constraints);
970 #endif
971 
972   if (!possible_global_constraints)
973     {
974       // Clear out any old constraints; maybe the user just deleted
975       // their last remaining dirichlet/periodic/user constraint?
976 #ifdef LIBMESH_ENABLE_CONSTRAINTS
977       _dof_constraints\&.clear();
978       _primal_constraint_values\&.clear();
979       _adjoint_constraint_values\&.clear();
980 #endif
981 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
982       _node_constraints\&.clear();
983 #endif
984 
985       // make sure we stop logging though
986       STOP_LOG("create_dof_constraints()", "DofMap");
987       return;
988     }
989 
990   // Here we build the hanging node constraints\&.  This is done
991   // by enforcing the condition u_a = u_b along hanging sides\&.
992   // u_a = u_b is collocated at the nodes of side a, which gives
993   // one row of the constraint matrix\&.
994 
995   // define the range of elements of interest
996   ConstElemRange range;
997   if (possible_local_constraints)
998     {
999       // With SerialMesh or a serial ParallelMesh, every processor
1000       // computes every constraint
1001       MeshBase::const_element_iterator
1002         elem_begin = mesh\&.elements_begin(),
1003         elem_end   = mesh\&.elements_end();
1004 
1005       // With a parallel ParallelMesh, processors compute only
1006       // their local constraints
1007       if (!mesh\&.is_serial())
1008         {
1009           elem_begin = mesh\&.local_elements_begin();
1010           elem_end   = mesh\&.local_elements_end();
1011         }
1012 
1013       // set the range to contain the specified elements
1014       range\&.reset (elem_begin, elem_end);
1015     }
1016   else
1017     range\&.reset (mesh\&.elements_end(), mesh\&.elements_end());
1018 
1019   // compute_periodic_constraints requires a point_locator() from our
1020   // Mesh, that point_locator() construction is threaded\&.  Rather than
1021   // nest threads within threads we'll make sure it's preconstructed\&.
1022 #ifdef LIBMESH_ENABLE_PERIODIC
1023   if (!_periodic_boundaries->empty() && !range\&.empty())
1024     mesh\&.sub_point_locator();
1025 #endif
1026 
1027 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
1028   // recalculate node constraints from scratch
1029   _node_constraints\&.clear();
1030 
1031   Threads::parallel_for (range,
1032                          ComputeNodeConstraints (_node_constraints,
1033                                                  *this,
1034 #ifdef LIBMESH_ENABLE_PERIODIC
1035                                                  *_periodic_boundaries,
1036 #endif
1037                                                  mesh));
1038 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
1039 
1040 
1041   // recalculate dof constraints from scratch
1042   _dof_constraints\&.clear();
1043   _primal_constraint_values\&.clear();
1044   _adjoint_constraint_values\&.clear();
1045 
1046   // Look at all the variables in the system\&.  Reset the element
1047   // range at each iteration -- there is no need to reconstruct it\&.
1048   for (unsigned int variable_number=0; variable_number<this->n_variables();
1049        ++variable_number, range\&.reset())
1050     Threads::parallel_for (range,
1051                            ComputeConstraints (_dof_constraints,
1052                                                *this,
1053 #ifdef LIBMESH_ENABLE_PERIODIC
1054                                                *_periodic_boundaries,
1055 #endif
1056                                                mesh,
1057                                                variable_number));
1058 
1059 #ifdef LIBMESH_ENABLE_DIRICHLET
1060   for (DirichletBoundaries::iterator
1061          i = _dirichlet_boundaries->begin();
1062        i != _dirichlet_boundaries->end(); ++i, range\&.reset())
1063     {
1064       Threads::parallel_for
1065         (range,
1066          ConstrainDirichlet(*this, mesh, time, **i,
1067                             AddPrimalConstraint(*this))
1068          );
1069     }
1070 
1071   for (unsigned int qoi_index = 0;
1072        qoi_index != _adjoint_dirichlet_boundaries\&.size();
1073        ++qoi_index)
1074     {
1075       for (DirichletBoundaries::iterator
1076              i = _adjoint_dirichlet_boundaries[qoi_index]->begin();
1077            i != _adjoint_dirichlet_boundaries[qoi_index]->end();
1078            ++i, range\&.reset())
1079         {
1080           Threads::parallel_for
1081             (range,
1082              ConstrainDirichlet(*this, mesh, time, **i,
1083                                 AddAdjointConstraint(*this, qoi_index))
1084              );
1085         }
1086     }
1087 
1088 #endif // LIBMESH_ENABLE_DIRICHLET
1089 
1090   STOP_LOG("create_dof_constraints()", "DofMap");
1091 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::DofMap::distribute_dofs (\fBMeshBase\fP &mesh)"
Distrubute dofs on the current mesh\&. Also builds the send list for processor \fCproc_id\fP, which defaults to 0 for ease of use in serial applications\&. 
.PP
Definition at line 841 of file dof_map\&.C\&.
.PP
References _end_df, _end_old_df, _first_df, _first_old_df, _n_dfs, _n_old_dfs, _send_list, add_neighbors_to_send_list(), libMesh::Parallel::Communicator::allgather(), libMesh::ParallelObject::comm(), distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), libMesh::DofObject::dof_number(), elem_ptr(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end_dof(), first_dof(), invalidate_dofs(), libMesh::MeshBase::is_prepared(), libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), mesh, libMesh::DofObject::n_comp(), libMesh::ParallelObject::n_processors(), libMesh::DofObject::n_vars(), node_ptr(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::on_command_line(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), reinit(), set_nonlocal_dof_objects(), libMesh::START_LOG(), libMesh::STOP_LOG(), and sys_number()\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
842 {
843   // This function must be run on all processors at once
844   parallel_object_only();
845 
846   // Log how long it takes to distribute the degrees of freedom
847   START_LOG("distribute_dofs()", "DofMap");
848 
849   libmesh_assert (mesh\&.is_prepared());
850 
851   const processor_id_type proc_id = this->processor_id();
852   const processor_id_type n_proc  = this->n_processors();
853 
854   //  libmesh_assert_greater (this->n_variables(), 0);
855   libmesh_assert_less (proc_id, n_proc);
856 
857   // re-init in case the mesh has changed
858   this->reinit(mesh);
859 
860   // By default distribute variables in a
861   // var-major fashion, but allow run-time
862   // specification
863   bool node_major_dofs = libMesh::on_command_line ("--node_major_dofs");
864 
865   // The DOF counter, will be incremented as we encounter
866   // new degrees of freedom
867   dof_id_type next_free_dof = 0;
868 
869   // Clear the send list before we rebuild it
870   _send_list\&.clear();
871 
872   // Set temporary DOF indices on this processor
873   if (node_major_dofs)
874     this->distribute_local_dofs_node_major (next_free_dof, mesh);
875   else
876     this->distribute_local_dofs_var_major (next_free_dof, mesh);
877 
878   // Get DOF counts on all processors
879   std::vector<dof_id_type> dofs_on_proc(n_proc, 0);
880   this->comm()\&.allgather(next_free_dof, dofs_on_proc);
881 
882   // Resize and fill the _first_df and _end_df arrays
883 #ifdef LIBMESH_ENABLE_AMR
884   _first_old_df = _first_df;
885   _end_old_df = _end_df;
886 #endif
887 
888   _first_df\&.resize(n_proc);
889   _end_df\&.resize (n_proc);
890 
891   // Get DOF offsets
892   _first_df[0] = 0;
893   for (processor_id_type i=1; i < n_proc; ++i)
894     _first_df[i] = _end_df[i-1] = _first_df[i-1] + dofs_on_proc[i-1];
895   _end_df[n_proc-1] = _first_df[n_proc-1] + dofs_on_proc[n_proc-1];
896 
897   // Clear all the current DOF indices
898   // (distribute_dofs expects them cleared!)
899   this->invalidate_dofs(mesh);
900 
901   next_free_dof = _first_df[proc_id];
902 
903   // Set permanent DOF indices on this processor
904   if (node_major_dofs)
905     this->distribute_local_dofs_node_major (next_free_dof, mesh);
906   else
907     this->distribute_local_dofs_var_major (next_free_dof, mesh);
908 
909   libmesh_assert_equal_to (next_free_dof, _end_df[proc_id]);
910 
911   //------------------------------------------------------------
912   // At this point, all n_comp and dof_number values on local
913   // DofObjects should be correct, but a ParallelMesh might have
914   // incorrect values on non-local DofObjects\&.  Let's request the
915   // correct values from each other processor\&.
916 
917   if (this->n_processors() > 1)
918     {
919       this->set_nonlocal_dof_objects(mesh\&.nodes_begin(),
920                                      mesh\&.nodes_end(),
921                                      mesh, &DofMap::node_ptr);
922 
923       this->set_nonlocal_dof_objects(mesh\&.elements_begin(),
924                                      mesh\&.elements_end(),
925                                      mesh, &DofMap::elem_ptr);
926     }
927 
928 #ifdef DEBUG
929   {
930     const unsigned int
931       sys_num = this->sys_number();
932 
933     // Processors should all agree on DoF ids
934     MeshTools::libmesh_assert_valid_dof_ids(mesh);
935 
936     // DoF processor ids should match DofObject processor ids
937     MeshBase::const_node_iterator       node_it  = mesh\&.nodes_begin();
938     const MeshBase::const_node_iterator node_end = mesh\&.nodes_end();
939     for ( ; node_it != node_end; ++node_it)
940       {
941         DofObject const * const dofobj = *node_it;
942         const processor_id_type proc_id = dofobj->processor_id();
943 
944         for (unsigned int v=0; v != dofobj->n_vars(sys_num); ++v)
945           for (unsigned int c=0; c != dofobj->n_comp(sys_num,v); ++c)
946             {
947               const dof_id_type dofid = dofobj->dof_number(sys_num,v,c);
948               libmesh_assert_greater_equal (dofid, this->first_dof(proc_id));
949               libmesh_assert_less (dofid, this->end_dof(proc_id));
950             }
951       }
952 
953     MeshBase::const_element_iterator       elem_it  = mesh\&.elements_begin();
954     const MeshBase::const_element_iterator elem_end = mesh\&.elements_end();
955     for ( ; elem_it != elem_end; ++elem_it)
956       {
957         DofObject const * const dofobj = *elem_it;
958         const processor_id_type proc_id = dofobj->processor_id();
959 
960         for (unsigned int v=0; v != dofobj->n_vars(sys_num); ++v)
961           for (unsigned int c=0; c != dofobj->n_comp(sys_num,v); ++c)
962             {
963               const dof_id_type dofid = dofobj->dof_number(sys_num,v,c);
964               libmesh_assert_greater_equal (dofid, this->first_dof(proc_id));
965               libmesh_assert_less (dofid, this->end_dof(proc_id));
966             }
967       }
968   }
969 #endif
970 
971   // Set the total number of degrees of freedom
972 #ifdef LIBMESH_ENABLE_AMR
973   _n_old_dfs = _n_dfs;
974 #endif
975   _n_dfs = _end_df[n_proc-1];
976 
977   STOP_LOG("distribute_dofs()", "DofMap");
978 
979   // Note that in the add_neighbors_to_send_list nodes on processor
980   // boundaries that are shared by multiple elements are added for
981   // each element\&.
982   this->add_neighbors_to_send_list(mesh);
983 
984   // Here we used to clean up that data structure; now System and
985   // EquationSystems call that for us, after we've added constraint
986   // dependencies to the send_list too\&.
987   // this->sort_send_list ();
988 }
.fi
.SS "void libMesh::DofMap::distribute_local_dofs_node_major (\fBdof_id_type\fP &next_free_dof, \fBMeshBase\fP &mesh)\fC [private]\fP"
Distributes the global degrees of freedom, for dofs on this processor\&. In this format all the degrees of freedom at a node/element are in contiguous blocks\&. Note in particular that the degrees of freedom for a given variable are not in contiguous blocks, as in the case of \fCdistribute_local_dofs_var_major\fP\&. Starts at index next_free_dof, and increments it to the post-final index\&. If build_send_list is true, builds the send list\&. If false, clears and reserves the send list 
.PP
Definition at line 1080 of file dof_map\&.C\&.
.PP
References _n_SCALAR_dofs, libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::Variable::active_on_subdomain(), libMesh::FEType::family, libMesh::Elem::get_node(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshBase::local_nodes_begin(), libMesh::MeshBase::local_nodes_end(), mesh, libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), n_nodes, libMesh::Elem::n_nodes(), libMesh::ParallelObject::n_processors(), libMesh::DofObject::n_var_groups(), n_variable_groups(), libMesh::VariableGroup::n_variables(), libMesh::FEType::order, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::SCALAR, libMesh::DofObject::set_vg_dof_base(), libMesh::Elem::subdomain_id(), sys_number(), libMesh::Variable::type(), variable_group(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
1082 {
1083   const unsigned int sys_num       = this->sys_number();
1084   const unsigned int n_var_groups  = this->n_variable_groups();
1085 
1086   //-------------------------------------------------------------------------
1087   // First count and assign temporary numbers to local dofs
1088   MeshBase::element_iterator       elem_it  = mesh\&.active_local_elements_begin();
1089   const MeshBase::element_iterator elem_end = mesh\&.active_local_elements_end();
1090 
1091   for ( ; elem_it != elem_end; ++elem_it)
1092     {
1093       // Only number dofs connected to active
1094       // elements on this processor\&.
1095       Elem* elem                 = *elem_it;
1096       const unsigned int n_nodes = elem->n_nodes();
1097 
1098       // First number the nodal DOFS
1099       for (unsigned int n=0; n<n_nodes; n++)
1100         {
1101           Node* node = elem->get_node(n);
1102 
1103           for (unsigned vg=0; vg<n_var_groups; vg++)
1104             {
1105               const VariableGroup &vg_description(this->variable_group(vg));
1106 
1107               if( (vg_description\&.type()\&.family != SCALAR) &&
1108                   (vg_description\&.active_on_subdomain(elem->subdomain_id())) )
1109                 {
1110                   // assign dof numbers (all at once) if this is
1111                   // our node and if they aren't already there
1112                   if ((node->n_comp_group(sys_num,vg) > 0) &&
1113                       (node->processor_id() == this->processor_id()) &&
1114                       (node->vg_dof_base(sys_num,vg) ==
1115                        DofObject::invalid_id))
1116                     {
1117                       node->set_vg_dof_base(sys_num,
1118                                             vg,
1119                                             next_free_dof);
1120                       next_free_dof += (vg_description\&.n_variables()*
1121                                         node->n_comp_group(sys_num,vg));
1122                       //node->debug_buffer();
1123                     }
1124                 }
1125             }
1126         }
1127 
1128       // Now number the element DOFS
1129       for (unsigned vg=0; vg<n_var_groups; vg++)
1130         {
1131           const VariableGroup &vg_description(this->variable_group(vg));
1132 
1133           if ( (vg_description\&.type()\&.family != SCALAR) &&
1134                (vg_description\&.active_on_subdomain(elem->subdomain_id())) )
1135             if (elem->n_comp_group(sys_num,vg) > 0)
1136               {
1137                 libmesh_assert_equal_to (elem->vg_dof_base(sys_num,vg),
1138                                          DofObject::invalid_id);
1139 
1140                 elem->set_vg_dof_base(sys_num,
1141                                       vg,
1142                                       next_free_dof);
1143 
1144                 next_free_dof += (vg_description\&.n_variables()*
1145                                   elem->n_comp(sys_num,vg));
1146               }
1147         }
1148     } // done looping over elements
1149 
1150 
1151   // we may have missed assigning DOFs to nodes that we own
1152   // but to which we have no connected elements matching our
1153   // variable restriction criterion\&.  this will happen, for example,
1154   // if variable V is restricted to subdomain S\&.  We may not own
1155   // any elements which live in S, but we may own nodes which are
1156   // *connected* to elements which do\&.  in this scenario these nodes
1157   // will presently have unnumbered DOFs\&. we need to take care of
1158   // them here since we own them and no other processor will touch them\&.
1159   {
1160     MeshBase::node_iterator       node_it  = mesh\&.local_nodes_begin();
1161     const MeshBase::node_iterator node_end = mesh\&.local_nodes_end();
1162 
1163     for (; node_it != node_end; ++node_it)
1164       {
1165         Node *node = *node_it;
1166         libmesh_assert(node);
1167 
1168         for (unsigned vg=0; vg<n_var_groups; vg++)
1169           {
1170             const VariableGroup &vg_description(this->variable_group(vg));
1171 
1172             if (node->n_comp_group(sys_num,vg))
1173               if (node->vg_dof_base(sys_num,vg) == DofObject::invalid_id)
1174                 {
1175                   node->set_vg_dof_base (sys_num,
1176                                          vg,
1177                                          next_free_dof);
1178 
1179                   next_free_dof += (vg_description\&.n_variables()*
1180                                     node->n_comp(sys_num,vg));
1181                 }
1182           }
1183       }
1184   }
1185 
1186   // Finally, count up the SCALAR dofs
1187   this->_n_SCALAR_dofs = 0;
1188   for (unsigned vg=0; vg<n_var_groups; vg++)
1189     {
1190       const VariableGroup &vg_description(this->variable_group(vg));
1191 
1192       if( vg_description\&.type()\&.family == SCALAR )
1193         {
1194           this->_n_SCALAR_dofs += (vg_description\&.n_variables()*
1195                                    vg_description\&.type()\&.order);
1196           continue;
1197         }
1198     }
1199 
1200   // Only increment next_free_dof if we're on the processor
1201   // that holds this SCALAR variable
1202   if ( this->processor_id() == (this->n_processors()-1) )
1203     next_free_dof += _n_SCALAR_dofs;
1204 
1205 #ifdef DEBUG
1206   {
1207     // libMesh::out << "next_free_dof=" << next_free_dof << std::endl
1208     //       << "_n_SCALAR_dofs=" << _n_SCALAR_dofs << std::endl;
1209 
1210     // Make sure we didn't miss any nodes
1211     MeshTools::libmesh_assert_valid_procids<Node>(mesh);
1212 
1213     MeshBase::node_iterator       node_it  = mesh\&.local_nodes_begin();
1214     const MeshBase::node_iterator node_end = mesh\&.local_nodes_end();
1215     for (; node_it != node_end; ++node_it)
1216       {
1217         Node *obj = *node_it;
1218         libmesh_assert(obj);
1219         unsigned int n_var_g = obj->n_var_groups(this->sys_number());
1220         for (unsigned int vg=0; vg != n_var_g; ++vg)
1221           {
1222             unsigned int n_comp_g =
1223               obj->n_comp_group(this->sys_number(), vg);
1224             dof_id_type my_first_dof = n_comp_g ?
1225               obj->vg_dof_base(this->sys_number(), vg) : 0;
1226             libmesh_assert_not_equal_to (my_first_dof, DofObject::invalid_id);
1227           }
1228       }
1229   }
1230 #endif // DEBUG
1231 }
.fi
.SS "void libMesh::DofMap::distribute_local_dofs_var_major (\fBdof_id_type\fP &next_free_dof, \fBMeshBase\fP &mesh)\fC [private]\fP"
Distributes the global degrees of freedom, for dofs on this processor\&. In this format the local degrees of freedom are in a contiguous block for each variable in the system\&. Starts at index next_free_dof, and increments it to the post-final index\&. 
.PP
Definition at line 1235 of file dof_map\&.C\&.
.PP
References _n_SCALAR_dofs, libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::Variable::active_on_subdomain(), libMesh::FEType::family, libMesh::Elem::get_node(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshBase::local_nodes_begin(), libMesh::MeshBase::local_nodes_end(), mesh, libMesh::DofObject::n_comp_group(), n_nodes, libMesh::Elem::n_nodes(), libMesh::ParallelObject::n_processors(), libMesh::DofObject::n_var_groups(), n_variable_groups(), libMesh::VariableGroup::n_variables(), libMesh::FEType::order, libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::SCALAR, libMesh::DofObject::set_vg_dof_base(), libMesh::Elem::subdomain_id(), sys_number(), libMesh::Variable::type(), variable_group(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
1237 {
1238   const unsigned int sys_num      = this->sys_number();
1239   const unsigned int n_var_groups = this->n_variable_groups();
1240 
1241   //-------------------------------------------------------------------------
1242   // First count and assign temporary numbers to local dofs
1243   for (unsigned vg=0; vg<n_var_groups; vg++)
1244     {
1245       const VariableGroup &vg_description(this->variable_group(vg));
1246 
1247       const unsigned int n_vars_in_group = vg_description\&.n_variables();
1248 
1249       // Skip the SCALAR dofs
1250       if (vg_description\&.type()\&.family == SCALAR)
1251         continue;
1252 
1253       MeshBase::element_iterator       elem_it  = mesh\&.active_local_elements_begin();
1254       const MeshBase::element_iterator elem_end = mesh\&.active_local_elements_end();
1255 
1256       for ( ; elem_it != elem_end; ++elem_it)
1257         {
1258           // Only number dofs connected to active
1259           // elements on this processor\&.
1260           Elem* elem  = *elem_it;
1261 
1262           // \&.\&.\&. and only variables which are active on
1263           // on this element's subdomain
1264           if (!vg_description\&.active_on_subdomain(elem->subdomain_id()))
1265             continue;
1266 
1267           const unsigned int n_nodes = elem->n_nodes();
1268 
1269           // First number the nodal DOFS
1270           for (unsigned int n=0; n<n_nodes; n++)
1271             {
1272               Node* node = elem->get_node(n);
1273 
1274               // assign dof numbers (all at once) if this is
1275               // our node and if they aren't already there
1276               if ((node->n_comp_group(sys_num,vg) > 0) &&
1277                   (node->processor_id() == this->processor_id()) &&
1278                   (node->vg_dof_base(sys_num,vg) ==
1279                    DofObject::invalid_id))
1280                 {
1281                   node->set_vg_dof_base(sys_num,
1282                                         vg,
1283                                         next_free_dof);
1284 
1285                   next_free_dof += (n_vars_in_group*
1286                                     node->n_comp_group(sys_num,vg));
1287                 }
1288             }
1289 
1290           // Now number the element DOFS
1291           if (elem->n_comp_group(sys_num,vg) > 0)
1292             {
1293               libmesh_assert_equal_to (elem->vg_dof_base(sys_num,vg),
1294                                        DofObject::invalid_id);
1295 
1296               elem->set_vg_dof_base(sys_num,
1297                                     vg,
1298                                     next_free_dof);
1299 
1300               next_free_dof += (n_vars_in_group*
1301                                 elem->n_comp_group(sys_num,vg));
1302             }
1303         } // end loop on elements
1304 
1305       // we may have missed assigning DOFs to nodes that we own
1306       // but to which we have no connected elements matching our
1307       // variable restriction criterion\&.  this will happen, for example,
1308       // if variable V is restricted to subdomain S\&.  We may not own
1309       // any elements which live in S, but we may own nodes which are
1310       // *connected* to elements which do\&.  in this scenario these nodes
1311       // will presently have unnumbered DOFs\&. we need to take care of
1312       // them here since we own them and no other processor will touch them\&.
1313       {
1314         MeshBase::node_iterator       node_it  = mesh\&.local_nodes_begin();
1315         const MeshBase::node_iterator node_end = mesh\&.local_nodes_end();
1316 
1317         for (; node_it != node_end; ++node_it)
1318           {
1319             Node *node = *node_it;
1320             libmesh_assert(node);
1321 
1322             if (node->n_comp_group(sys_num,vg))
1323               if (node->vg_dof_base(sys_num,vg) == DofObject::invalid_id)
1324                 {
1325                   node->set_vg_dof_base (sys_num,
1326                                          vg,
1327                                          next_free_dof);
1328 
1329                   next_free_dof += (n_vars_in_group*
1330                                     node->n_comp_group(sys_num,vg));
1331                 }
1332           }
1333       }
1334     } // end loop on variable groups
1335 
1336   // Finally, count up the SCALAR dofs
1337   this->_n_SCALAR_dofs = 0;
1338   for (unsigned vg=0; vg<n_var_groups; vg++)
1339     {
1340       const VariableGroup &vg_description(this->variable_group(vg));
1341 
1342       if( vg_description\&.type()\&.family == SCALAR )
1343         {
1344           this->_n_SCALAR_dofs += (vg_description\&.n_variables()*
1345                                    vg_description\&.type()\&.order);
1346           continue;
1347         }
1348     }
1349 
1350   // Only increment next_free_dof if we're on the processor
1351   // that holds this SCALAR variable
1352   if ( this->processor_id() == (this->n_processors()-1) )
1353     next_free_dof += _n_SCALAR_dofs;
1354 
1355 #ifdef DEBUG
1356   {
1357     // Make sure we didn't miss any nodes
1358     MeshTools::libmesh_assert_valid_procids<Node>(mesh);
1359 
1360     MeshBase::node_iterator       node_it  = mesh\&.local_nodes_begin();
1361     const MeshBase::node_iterator node_end = mesh\&.local_nodes_end();
1362     for (; node_it != node_end; ++node_it)
1363       {
1364         Node *obj = *node_it;
1365         libmesh_assert(obj);
1366         unsigned int n_var_g = obj->n_var_groups(this->sys_number());
1367         for (unsigned int vg=0; vg != n_var_g; ++vg)
1368           {
1369             unsigned int n_comp_g =
1370               obj->n_comp_group(this->sys_number(), vg);
1371             dof_id_type my_first_dof = n_comp_g ?
1372               obj->vg_dof_base(this->sys_number(), vg) : 0;
1373             libmesh_assert_not_equal_to (my_first_dof, DofObject::invalid_id);
1374           }
1375       }
1376   }
1377 #endif // DEBUG
1378 }
.fi
.SS "void libMesh::DofMap::dof_indices (const \fBElem\fP *constelem, std::vector< \fBdof_id_type\fP > &di) const"
Fills the vector \fCdi\fP with the global degree of freedom indices for the element\&. 
.PP
Definition at line 1745 of file dof_map\&.C\&.
.PP
References _dof_indices(), libMesh::Elem::dim(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::get_node(), libMesh::Tri3Subdivision::is_ghost(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_nodes(), n_variables(), libMesh::n_vars, libMesh::SCALAR, SCALAR_dof_indices(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TRI3SUBDIVISION, libMesh::Elem::type(), variable(), and variable_type()\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), add_neighbors_to_send_list(), libMesh::HPCoarsenTest::add_projection(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::System::local_dof_indices(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ProjectSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::ErrorVector::plot_error(), libMesh::FEMContext::pre_fe_reinit(), libMesh::HPCoarsenTest::select_refinement(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1747 {
1748   libmesh_assert(elem);
1749 
1750   // Clear the DOF indices vector
1751   di\&.clear();
1752 
1753   // Ghost subdivision elements have no real dofs
1754   if (elem->type() == TRI3SUBDIVISION)
1755     {
1756       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
1757       if (sd_elem->is_ghost())
1758         return;
1759     }
1760 
1761   START_LOG("dof_indices()", "DofMap");
1762 
1763   const unsigned int n_vars  = this->n_variables();
1764 
1765 #ifdef DEBUG
1766   // Check that sizes match in DEBUG mode
1767   unsigned int tot_size = 0;
1768 #endif
1769 
1770   // Create a vector to indicate which
1771   // SCALAR variables have been requested
1772   std::vector<unsigned int> SCALAR_var_numbers;
1773   SCALAR_var_numbers\&.clear();
1774 
1775   // Determine the nodes contributing to element elem
1776   std::vector<Node*> elem_nodes;
1777   if (elem->type() == TRI3SUBDIVISION)
1778     {
1779       // Subdivision surface FE require the 1-ring around elem
1780       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
1781       MeshTools::Subdivision::find_one_ring(sd_elem, elem_nodes);
1782     }
1783   else
1784     {
1785       // All other FE use only the nodes of elem itself
1786       elem_nodes\&.resize(elem->n_nodes(), NULL);
1787       for (unsigned int i=0; i<elem->n_nodes(); i++)
1788         elem_nodes[i] = elem->get_node(i);
1789     }
1790 
1791   // Get the dof numbers
1792   for (unsigned int v=0; v<n_vars; v++)
1793     {
1794       if(this->variable(v)\&.type()\&.family == SCALAR)
1795         {
1796           SCALAR_var_numbers\&.push_back(v);
1797 
1798 #ifdef DEBUG
1799           tot_size += FEInterface::n_dofs(elem->dim(),
1800                                           this->variable_type(v),
1801                                           elem->type());
1802 #endif
1803 
1804         }
1805       else
1806         _dof_indices(elem, di, v, elem_nodes
1807 #ifdef DEBUG
1808                      , tot_size
1809 #endif
1810                      );
1811     }
1812 
1813   // Finally append any SCALAR dofs that we asked for\&.
1814   std::vector<dof_id_type> di_new;
1815   std::vector<unsigned int>::iterator it           = SCALAR_var_numbers\&.begin();
1816   std::vector<unsigned int>::const_iterator it_end = SCALAR_var_numbers\&.end();
1817   for( ; it != it_end; ++it)
1818     {
1819       this->SCALAR_dof_indices(di_new,*it);
1820       di\&.insert( di\&.end(), di_new\&.begin(), di_new\&.end());
1821     }
1822 
1823 #ifdef DEBUG
1824   libmesh_assert_equal_to (tot_size, di\&.size());
1825 #endif
1826 
1827   STOP_LOG("dof_indices()", "DofMap");
1828 }
.fi
.SS "void libMesh::DofMap::dof_indices (const \fBElem\fP *constelem, std::vector< \fBdof_id_type\fP > &di, const unsigned intvn) const"
Fills the vector \fCdi\fP with the global degree of freedom indices for the element\&. For one variable 
.PP
Definition at line 1831 of file dof_map\&.C\&.
.PP
References _dof_indices(), libMesh::Elem::dim(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::get_node(), libMesh::Tri3Subdivision::is_ghost(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_nodes(), libMesh::SCALAR, SCALAR_dof_indices(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TRI3SUBDIVISION, libMesh::Elem::type(), variable(), and variable_type()\&.
.PP
.nf
1834 {
1835   libmesh_assert(elem);
1836 
1837   // Clear the DOF indices vector
1838   di\&.clear();
1839 
1840   // Ghost subdivision elements have no real dofs
1841   if (elem->type() == TRI3SUBDIVISION)
1842     {
1843       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
1844       if (sd_elem->is_ghost())
1845         return;
1846     }
1847 
1848   START_LOG("dof_indices()", "DofMap");
1849 
1850 #ifdef DEBUG
1851   // Check that sizes match in DEBUG mode
1852   unsigned int tot_size = 0;
1853 #endif
1854 
1855   // Create a vector to indicate which
1856   // SCALAR variables have been requested
1857   std::vector<unsigned int> SCALAR_var_numbers;
1858   SCALAR_var_numbers\&.clear();
1859 
1860   // Determine the nodes contributing to element elem
1861   std::vector<Node*> elem_nodes;
1862   if (elem->type() == TRI3SUBDIVISION)
1863     {
1864       // Subdivision surface FE require the 1-ring around elem
1865       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
1866       MeshTools::Subdivision::find_one_ring(sd_elem, elem_nodes);
1867     }
1868   else
1869     {
1870       // All other FE use only the nodes of elem itself
1871       elem_nodes\&.resize(elem->n_nodes(), NULL);
1872       for (unsigned int i=0; i<elem->n_nodes(); i++)
1873         elem_nodes[i] = elem->get_node(i);
1874     }
1875 
1876   // Get the dof numbers
1877   if(this->variable(vn)\&.type()\&.family == SCALAR)
1878     {
1879       SCALAR_var_numbers\&.push_back(vn);
1880 #ifdef DEBUG
1881       tot_size += FEInterface::n_dofs(elem->dim(),
1882                                       this->variable_type(vn),
1883                                       elem->type());
1884 #endif
1885     }
1886   else
1887     _dof_indices(elem, di, vn, elem_nodes
1888 #ifdef DEBUG
1889                  , tot_size
1890 #endif
1891                  );
1892 
1893   // Finally append any SCALAR dofs that we asked for\&.
1894   std::vector<dof_id_type> di_new;
1895   std::vector<unsigned int>::iterator it           = SCALAR_var_numbers\&.begin();
1896   std::vector<unsigned int>::const_iterator it_end = SCALAR_var_numbers\&.end();
1897   for( ; it != it_end; ++it)
1898     {
1899       this->SCALAR_dof_indices(di_new,*it);
1900       di\&.insert( di\&.end(), di_new\&.begin(), di_new\&.end());
1901     }
1902 
1903 #ifdef DEBUG
1904   libmesh_assert_equal_to (tot_size, di\&.size());
1905 #endif
1906 
1907   STOP_LOG("dof_indices()", "DofMap");
1908 }
.fi
.SS "\fBDofObject\fP * libMesh::DofMap::elem_ptr (\fBMeshBase\fP &mesh, \fBdof_id_type\fPi) const\fC [private]\fP"
An adapter function that returns \fBElem\fP pointers by index 
.PP
Definition at line 276 of file dof_map\&.C\&.
.PP
References libMesh::MeshBase::elem()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
277 {
278   return mesh\&.elem(i);
279 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::end_dof (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the first dof index that is after all indices local to subdomain \fCproc\fP\&. Analogous to the \fBend()\fP member function of STL containers\&. 
.PP
Definition at line 488 of file dof_map\&.h\&.
.PP
References _end_df\&.
.PP
Referenced by DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), libMesh::SystemSubsetBySubdomain::init(), libMesh::CondensedEigenSystem::initialize_condensed_dofs(), libMesh::SparsityPattern::Build::join(), libMesh::System::local_dof_indices(), libMesh::SparsityPattern::Build::operator()(), and libMesh::SparsityPattern::Build::parallel_sync()\&.
.PP
.nf
489   { libmesh_assert_less (proc, _end_df\&.size()); return _end_df[proc]; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::end_dof () const\fC [inline]\fP"

.PP
Definition at line 491 of file dof_map\&.h\&.
.PP
References libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by add_neighbors_to_send_list(), all_semilocal_indices(), distribute_dofs(), and local_variable_indices()\&.
.PP
.nf
492   { return this->end_dof(this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::end_old_dof (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the first old dof index that is after all indices local to subdomain \fCproc\fP\&. Analogous to the \fBend()\fP member function of STL containers\&. 
.PP
Definition at line 499 of file dof_map\&.h\&.
.PP
References _end_old_df\&.
.PP
.nf
500   { libmesh_assert_less (proc, _end_old_df\&.size()); return _end_old_df[proc]; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::end_old_dof () const\fC [inline]\fP"

.PP
Definition at line 502 of file dof_map\&.h\&.
.PP
References libMesh::ParallelObject::processor_id()\&.
.PP
.nf
503   { return this->end_old_dof(this->processor_id()); }
.fi
.SS "void libMesh::DofMap::enforce_adjoint_constraints_exactly (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned intq) const\fC [inline]\fP"
Heterogenously constrains the numeric vector \fCv\fP, which represents an adjoint solution defined on the mesh for quantity fo interest \fCq\fP\&. For homogeneous constraints, use \fCenforce_constraints_exactly\fP instead 
.PP
Definition at line 1939 of file dof_map_constraints\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::NumericVector< T >::closed(), libMesh::comm, libMesh::err, libMesh::AutoPtr< Tp >::get(), libMesh::GHOSTED, libMesh::libmesh_assert(), libMesh::NumericVector< T >::localize(), libMesh::PARALLEL, libMesh::SERIAL, libMesh::NumericVector< T >::set(), libMesh::NumericVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::NumericVector< T >::type()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve()\&.
.PP
.nf
1941 {
1942   parallel_object_only();
1943 
1944   if (!this->n_constrained_dofs())
1945     return;
1946 
1947   START_LOG("enforce_adjoint_constraints_exactly()","DofMap");
1948 
1949   NumericVector<Number> *v_local  = NULL; // will be initialized below
1950   NumericVector<Number> *v_global = NULL; // will be initialized below
1951   AutoPtr<NumericVector<Number> > v_built;
1952   if (v\&.type() == SERIAL)
1953     {
1954       v_built = NumericVector<Number>::build(this->comm());
1955       v_built->init(this->n_dofs(), this->n_local_dofs(), true, PARALLEL);
1956       v_built->close();
1957 
1958       for (dof_id_type i=v_built->first_local_index();
1959            i<v_built->last_local_index(); i++)
1960         v_built->set(i, v(i));
1961       v_built->close();
1962       v_global = v_built\&.get();
1963 
1964       v_local = &v;
1965       libmesh_assert (v_local->closed());
1966     }
1967   else if (v\&.type() == PARALLEL)
1968     {
1969       v_built = NumericVector<Number>::build(this->comm());
1970       v_built->init (v\&.size(), v\&.size(), true, SERIAL);
1971       v\&.localize(*v_built);
1972       v_built->close();
1973       v_local = v_built\&.get();
1974 
1975       v_global = &v;
1976     }
1977   else if (v\&.type() == GHOSTED)
1978     {
1979       v_local = &v;
1980       v_global = &v;
1981     }
1982   else // unknown v\&.type()
1983     {
1984       libMesh::err << "ERROR: Unknown v\&.type() == " << v\&.type()
1985                    << std::endl;
1986       libmesh_error();
1987     }
1988 
1989   // We should never hit these asserts because we should error-out in
1990   // else clause above\&.  Just to be sure we don't try to use v_local
1991   // and v_global uninitialized\&.\&.\&.
1992   libmesh_assert(v_local);
1993   libmesh_assert(v_global);
1994 
1995   // Do we have any non_homogeneous constraints?
1996   const AdjointDofConstraintValues::const_iterator
1997     adjoint_constraint_map_it = _adjoint_constraint_values\&.find(q);
1998   const DofConstraintValueMap *constraint_map =
1999     (adjoint_constraint_map_it == _adjoint_constraint_values\&.end()) ?
2000     NULL : &adjoint_constraint_map_it->second;
2001 
2002   DofConstraints::const_iterator c_it = _dof_constraints\&.begin();
2003   const DofConstraints::const_iterator c_end = _dof_constraints\&.end();
2004 
2005   for ( ; c_it != c_end; ++c_it)
2006     {
2007       dof_id_type constrained_dof = c_it->first;
2008       if (constrained_dof < this->first_dof() ||
2009           constrained_dof >= this->end_dof())
2010         continue;
2011 
2012       const DofConstraintRow constraint_row = c_it->second;
2013 
2014       Number exact_value = 0;
2015       if (constraint_map)
2016         {
2017           const DofConstraintValueMap::const_iterator
2018             adjoint_constraint_it =
2019             constraint_map->find(constrained_dof);
2020           if (adjoint_constraint_it != constraint_map->end())
2021             exact_value = adjoint_constraint_it->second;
2022         }
2023 
2024       for (DofConstraintRow::const_iterator
2025              j=constraint_row\&.begin(); j != constraint_row\&.end();
2026            ++j)
2027         exact_value += j->second * (*v_local)(j->first);
2028 
2029       v_global->set(constrained_dof, exact_value);
2030     }
2031 
2032   // If the old vector was serial, we probably need to send our values
2033   // to other processors
2034   if (v\&.type() == SERIAL)
2035     {
2036 #ifndef NDEBUG
2037       v_global->close();
2038 #endif
2039       v_global->localize (v);
2040     }
2041   v\&.close();
2042 
2043   STOP_LOG("enforce_adjoint_constraints_exactly()","DofMap");
2044 }
.fi
.SS "void libMesh::DofMap::enforce_constraints_exactly (const \fBSystem\fP &system, \fBNumericVector\fP< \fBNumber\fP > *v = \fCNULL\fP, boolhomogeneous = \fCfalse\fP) const\fC [inline]\fP"
Constrains the numeric vector \fCv\fP, which represents a solution defined on the mesh\&. This may need to be used after a linear solve, if your linear solver's solutions do not satisfy your DoF constraints to a tight enough tolerance\&.
.PP
If \fCv\fP == NULL, the system solution vector is constrained
.PP
If \fChomogeneous\fP == true, heterogeneous constraints are enforced as if they were homogeneous\&. This might be appropriate for e\&.g\&. a vector representing a difference between two heterogeneously-constrained solutions\&. 
.PP
Definition at line 1833 of file dof_map_constraints\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::NumericVector< T >::closed(), libMesh::comm, libMesh::err, libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::GHOSTED, libMesh::libmesh_assert(), libMesh::NumericVector< T >::localize(), libMesh::PARALLEL, libMesh::SERIAL, libMesh::NumericVector< T >::set(), libMesh::NumericVector< T >::size(), libMesh::System::solution, libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::NumericVector< T >::type()\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), DMlibMeshFunction(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::project_vector(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::NewtonSolver::solve(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
1836 {
1837   parallel_object_only();
1838 
1839   if (!this->n_constrained_dofs())
1840     return;
1841 
1842   START_LOG("enforce_constraints_exactly()","DofMap");
1843 
1844   if (!v)
1845     v = system\&.solution\&.get();
1846 
1847   NumericVector<Number> *v_local  = NULL; // will be initialized below
1848   NumericVector<Number> *v_global = NULL; // will be initialized below
1849   AutoPtr<NumericVector<Number> > v_built;
1850   if (v->type() == SERIAL)
1851     {
1852       v_built = NumericVector<Number>::build(this->comm());
1853       v_built->init(this->n_dofs(), this->n_local_dofs(), true, PARALLEL);
1854       v_built->close();
1855 
1856       for (dof_id_type i=v_built->first_local_index();
1857            i<v_built->last_local_index(); i++)
1858         v_built->set(i, (*v)(i));
1859       v_built->close();
1860       v_global = v_built\&.get();
1861 
1862       v_local = v;
1863       libmesh_assert (v_local->closed());
1864     }
1865   else if (v->type() == PARALLEL)
1866     {
1867       v_built = NumericVector<Number>::build(this->comm());
1868       v_built->init (v->size(), v->size(), true, SERIAL);
1869       v->localize(*v_built);
1870       v_built->close();
1871       v_local = v_built\&.get();
1872 
1873       v_global = v;
1874     }
1875   else if (v->type() == GHOSTED)
1876     {
1877       v_local = v;
1878       v_global = v;
1879     }
1880   else // unknown v->type()
1881     {
1882       libMesh::err << "ERROR: Unknown v->type() == " << v->type()
1883                    << std::endl;
1884       libmesh_error();
1885     }
1886 
1887   // We should never hit these asserts because we should error-out in
1888   // else clause above\&.  Just to be sure we don't try to use v_local
1889   // and v_global uninitialized\&.\&.\&.
1890   libmesh_assert(v_local);
1891   libmesh_assert(v_global);
1892   libmesh_assert_equal_to (this, &(system\&.get_dof_map()));
1893 
1894   DofConstraints::const_iterator c_it = _dof_constraints\&.begin();
1895   const DofConstraints::const_iterator c_end = _dof_constraints\&.end();
1896 
1897   for ( ; c_it != c_end; ++c_it)
1898     {
1899       dof_id_type constrained_dof = c_it->first;
1900       if (constrained_dof < this->first_dof() ||
1901           constrained_dof >= this->end_dof())
1902         continue;
1903 
1904       const DofConstraintRow constraint_row = c_it->second;
1905 
1906       Number exact_value = 0;
1907       if (!homogeneous)
1908         {
1909           DofConstraintValueMap::const_iterator rhsit =
1910             _primal_constraint_values\&.find(constrained_dof);
1911           if (rhsit != _primal_constraint_values\&.end())
1912             exact_value = rhsit->second;
1913         }
1914       for (DofConstraintRow::const_iterator
1915              j=constraint_row\&.begin(); j != constraint_row\&.end();
1916            ++j)
1917         exact_value += j->second * (*v_local)(j->first);
1918 
1919       v_global->set(constrained_dof, exact_value);
1920     }
1921 
1922   // If the old vector was serial, we probably need to send our values
1923   // to other processors
1924   if (v->type() == SERIAL)
1925     {
1926 #ifndef NDEBUG
1927       v_global->close();
1928 #endif
1929       v_global->localize (*v);
1930     }
1931   v->close();
1932 
1933   STOP_LOG("enforce_constraints_exactly()","DofMap");
1934 }
.fi
.SS "void libMesh::DofMap::extract_local_vector (const \fBNumericVector\fP< \fBNumber\fP > &Ug, const std::vector< \fBdof_id_type\fP > &dof_indices, \fBDenseVectorBase\fP< \fBNumber\fP > &Ue) const"
Builds the local element vector \fCUe\fP from the global vector \fCUg\fP, accounting for any constrained degrees of freedom\&. For an element without constrained degrees of freedom this is the trivial mapping $ Ue[i] = Ug[dof_indices[i]] $
.PP
Note that the user must ensure that the element vector \fCUe\fP is properly sized when calling this method\&. This is because there is no \fC\fBresize()\fP\fP method in the \fCDenseVectorBase<>\fP class\&. 
.PP
Definition at line 1659 of file dof_map\&.C\&.
.PP
References build_constraint_matrix_and_vector(), libMesh::DenseVectorBase< T >::el(), libMesh::NumericVector< T >::first_local_index(), is_constrained_dof(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseVectorBase< T >::size(), libMesh::NumericVector< T >::size(), and libMesh::DenseVectorBase< T >::zero()\&.
.PP
.nf
1662 {
1663 #ifdef LIBMESH_ENABLE_AMR
1664 
1665   // Trivial mapping
1666   libmesh_assert_equal_to (dof_indices_in\&.size(), Ue\&.size());
1667   bool has_constrained_dofs = false;
1668 
1669   for (unsigned int il=0;
1670        il != libmesh_cast_int<unsigned int>(dof_indices_in\&.size()); il++)
1671     {
1672       const dof_id_type ig = dof_indices_in[il];
1673 
1674       if (this->is_constrained_dof (ig)) has_constrained_dofs = true;
1675 
1676       libmesh_assert_less (ig, Ug\&.size());
1677 
1678       Ue\&.el(il) = Ug(ig);
1679     }
1680 
1681   // If the element has any constrained DOFs then we need
1682   // to account for them in the mapping\&.  This will handle
1683   // the case that the input vector is not constrained\&.
1684   if (has_constrained_dofs)
1685     {
1686       // Copy the input DOF indices\&.
1687       std::vector<dof_id_type> constrained_dof_indices(dof_indices_in);
1688 
1689       DenseMatrix<Number> C;
1690       DenseVector<Number> H;
1691 
1692       this->build_constraint_matrix_and_vector (C, H, constrained_dof_indices);
1693 
1694       libmesh_assert_equal_to (dof_indices_in\&.size(), C\&.m());
1695       libmesh_assert_equal_to (constrained_dof_indices\&.size(), C\&.n());
1696 
1697       // zero-out Ue
1698       Ue\&.zero();
1699 
1700       // compute Ue = C Ug, with proper mapping\&.
1701       const unsigned int n_original_dofs =
1702         libmesh_cast_int<unsigned int>(dof_indices_in\&.size());
1703       for (unsigned int i=0; i != n_original_dofs; i++)
1704         {
1705           Ue\&.el(i) = H(i);
1706 
1707           const unsigned int n_constrained =
1708             libmesh_cast_int<unsigned int>(constrained_dof_indices\&.size());
1709           for (unsigned int j=0; j<n_constrained; j++)
1710             {
1711               const dof_id_type jg = constrained_dof_indices[j];
1712 
1713               //          If Ug is a serial or ghosted vector, then this assert is
1714               //          overzealous\&.  If Ug is a parallel vector, then this assert
1715               //          is redundant\&.
1716               //    libmesh_assert ((jg >= Ug\&.first_local_index()) &&
1717               //    (jg <  Ug\&.last_local_index()));
1718 
1719               Ue\&.el(i) += C(i,j)*Ug(jg);
1720             }
1721         }
1722     }
1723 
1724 #else
1725 
1726   // Trivial mapping
1727 
1728   const unsigned int n_original_dofs =
1729     libmesh_cast_int<unsigned int>(dof_indices_in\&.size());
1730 
1731   libmesh_assert_equal_to (n_original_dofs, Ue\&.size());
1732 
1733   for (unsigned int il=0; il<n_original_dofs; il++)
1734     {
1735       const dof_id_type ig = dof_indices_in[il];
1736 
1737       libmesh_assert ((ig >= Ug\&.first_local_index()) && (ig <  Ug\&.last_local_index()));
1738 
1739       Ue\&.el(il) = Ug(ig);
1740     }
1741 
1742 #endif
1743 }
.fi
.SS "void libMesh::DofMap::find_connected_dof_objects (std::vector< const \fBDofObject\fP * > &objs) const\fC [private]\fP"
Finds all the DofObjects associated with the set in \fCobjs\fP\&. This will account for off-element couplings via hanging nodes\&. 
.SS "void libMesh::DofMap::find_connected_dofs (std::vector< \fBdof_id_type\fP > &elem_dofs) const\fC [private]\fP"
Finds all the DOFS associated with the element DOFs elem_dofs\&. This will account for off-element couplings via hanging nodes\&. 
.PP
Definition at line 2348 of file dof_map\&.C\&.
.PP
References _dof_constraints, is_constrained_dof(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::SparsityPattern::Build::operator()()\&.
.PP
.nf
2349 {
2350   typedef std::set<dof_id_type> RCSet;
2351 
2352   // First insert the DOFS we already depend on into the set\&.
2353   RCSet dof_set (elem_dofs\&.begin(), elem_dofs\&.end());
2354 
2355   bool done = true;
2356 
2357   // Next insert any dofs those might be constrained in terms
2358   // of\&.  Note that in this case we may not be done:  Those may
2359   // in turn depend on others\&.  So, we need to repeat this process
2360   // in that case until the system depends only on unconstrained
2361   // degrees of freedom\&.
2362   for (unsigned int i=0; i<elem_dofs\&.size(); i++)
2363     if (this->is_constrained_dof(elem_dofs[i]))
2364       {
2365         // If the DOF is constrained
2366         DofConstraints::const_iterator
2367           pos = _dof_constraints\&.find(elem_dofs[i]);
2368 
2369         libmesh_assert (pos != _dof_constraints\&.end());
2370 
2371         const DofConstraintRow& constraint_row = pos->second;
2372 
2373         // adaptive p refinement currently gives us lots of empty constraint
2374         // rows - we should optimize those DoFs away in the future\&.  [RHS]
2375         //libmesh_assert (!constraint_row\&.empty());
2376 
2377         DofConstraintRow::const_iterator it     = constraint_row\&.begin();
2378         DofConstraintRow::const_iterator it_end = constraint_row\&.end();
2379 
2380 
2381         // Add the DOFs this dof is constrained in terms of\&.
2382         // note that these dofs might also be constrained, so
2383         // we will need to call this function recursively\&.
2384         for ( ; it != it_end; ++it)
2385           if (!dof_set\&.count (it->first))
2386             {
2387               dof_set\&.insert (it->first);
2388               done = false;
2389             }
2390       }
2391 
2392 
2393   // If not done then we need to do more work
2394   // (obviously :-) )!
2395   if (!done)
2396     {
2397       // Fill the vector with the contents of the set
2398       elem_dofs\&.clear();
2399       elem_dofs\&.insert (elem_dofs\&.end(),
2400                         dof_set\&.begin(), dof_set\&.end());
2401 
2402 
2403       // May need to do this recursively\&.  It is possible
2404       // that we just replaced a constrained DOF with another
2405       // constrained DOF\&.
2406       this->find_connected_dofs (elem_dofs);
2407 
2408     } // end if (!done)
2409 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::first_dof (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the first dof index that is local to partition \fCproc\fP\&. 
.PP
Definition at line 452 of file dof_map\&.h\&.
.PP
References _first_df\&.
.PP
Referenced by DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), libMesh::SystemSubsetBySubdomain::init(), libMesh::SparsityPattern::Build::join(), libMesh::System::local_dof_indices(), libMesh::SparsityPattern::Build::operator()(), and libMesh::SparsityPattern::Build::parallel_sync()\&.
.PP
.nf
453   { libmesh_assert_less (proc, _first_df\&.size()); return _first_df[proc]; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::first_dof () const\fC [inline]\fP"

.PP
Definition at line 455 of file dof_map\&.h\&.
.PP
References libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by add_neighbors_to_send_list(), all_semilocal_indices(), distribute_dofs(), and local_variable_indices()\&.
.PP
.nf
456   { return this->first_dof(this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::first_old_dof (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the first old dof index that is local to partition \fCproc\fP\&. 
.PP
Definition at line 462 of file dof_map\&.h\&.
.PP
References _first_old_df\&.
.PP
.nf
463   { libmesh_assert_less (proc, _first_old_df\&.size()); return _first_old_df[proc]; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::first_old_dof () const\fC [inline]\fP"

.PP
Definition at line 465 of file dof_map\&.h\&.
.PP
References libMesh::ParallelObject::processor_id()\&.
.PP
.nf
466   { return this->first_old_dof(this->processor_id()); }
.fi
.SS "const \fBDirichletBoundaries\fP * libMesh::DofMap::get_adjoint_dirichlet_boundaries (unsigned intq) const"

.PP
Definition at line 3618 of file dof_map_constraints\&.C\&.
.PP
References libMesh::libmesh_assert_greater()\&.
.PP
.nf
3619 {
3620   libmesh_assert_greater(_adjoint_dirichlet_boundaries\&.size(),q);
3621   return _adjoint_dirichlet_boundaries[q];
3622 }
.fi
.SS "\fBDirichletBoundaries\fP * libMesh::DofMap::get_adjoint_dirichlet_boundaries (unsigned intq)"

.PP
Definition at line 3626 of file dof_map_constraints\&.C\&.
.PP
.nf
3627 {
3628   std::size_t old_size = _adjoint_dirichlet_boundaries\&.size();
3629   for (std::size_t i = old_size; i <= q; ++i)
3630     _adjoint_dirichlet_boundaries\&.push_back(new DirichletBoundaries());
3631 
3632   return _adjoint_dirichlet_boundaries[q];
3633 }
.fi
.SS "const \fBDirichletBoundaries\fP* libMesh::DofMap::get_dirichlet_boundaries () const\fC [inline]\fP"

.PP
Definition at line 955 of file dof_map\&.h\&.
.PP
References _dirichlet_boundaries\&.
.PP
.nf
956   {
957     return _dirichlet_boundaries;
958   }
.fi
.SS "\fBDirichletBoundaries\fP* libMesh::DofMap::get_dirichlet_boundaries ()\fC [inline]\fP"

.PP
Definition at line 960 of file dof_map\&.h\&.
.PP
References _dirichlet_boundaries\&.
.PP
.nf
961   {
962     return _dirichlet_boundaries;
963   }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::DofMap::get_info () const"
Gets summary info about the sparsity bandwidth and constraints\&. 
.PP
Definition at line 3051 of file dof_map\&.C\&.
.PP
References libMesh::comm, end, libMesh::libmesh_assert(), std::max(), libMesh::processor_id(), libMesh::DofObject::processor_id(), and libMesh::TypeVector< T >::size()\&.
.PP
Referenced by libMesh::System::get_info()\&.
.PP
.nf
3052 {
3053   std::ostringstream os;
3054 
3055   // If we didn't calculate the exact sparsity pattern, the threaded
3056   // sparsity pattern assembly may have just given us an upper bound
3057   // on sparsity\&.
3058   const char* may_equal = " <= ";
3059 
3060   // If we calculated the exact sparsity pattern, then we can report
3061   // exact bandwidth figures:
3062   std::vector<SparseMatrix<Number>* >::const_iterator
3063     pos = _matrices\&.begin(),
3064     end = _matrices\&.end();
3065 
3066   for (; pos != end; ++pos)
3067     if ((*pos)->need_full_sparsity_pattern())
3068       may_equal = " = ";
3069 
3070   dof_id_type max_n_nz = 0, max_n_oz = 0;
3071   long double avg_n_nz = 0, avg_n_oz = 0;
3072 
3073   if (_n_nz)
3074     {
3075       for (std::size_t i = 0; i != _n_nz->size(); ++i)
3076         {
3077           max_n_nz = std::max(max_n_nz, (*_n_nz)[i]);
3078           avg_n_nz += (*_n_nz)[i];
3079         }
3080 
3081       std::size_t n_nz_size = _n_nz->size();
3082 
3083       this->comm()\&.max(max_n_nz);
3084       this->comm()\&.sum(avg_n_nz);
3085       this->comm()\&.sum(n_nz_size);
3086 
3087       avg_n_nz /= std::max(n_nz_size,std::size_t(1));
3088 
3089       libmesh_assert(_n_oz);
3090 
3091       for (std::size_t i = 0; i != (*_n_oz)\&.size(); ++i)
3092         {
3093           max_n_oz = std::max(max_n_oz, (*_n_oz)[i]);
3094           avg_n_oz += (*_n_oz)[i];
3095         }
3096 
3097       std::size_t n_oz_size = _n_oz->size();
3098 
3099       this->comm()\&.max(max_n_oz);
3100       this->comm()\&.sum(avg_n_oz);
3101       this->comm()\&.sum(n_oz_size);
3102 
3103       avg_n_oz /= std::max(n_oz_size,std::size_t(1));
3104     }
3105 
3106   os << "    DofMap Sparsity\n      Average  On-Processor Bandwidth"
3107      << may_equal << avg_n_nz << '\n';
3108 
3109   os << "      Average Off-Processor Bandwidth"
3110      << may_equal << avg_n_oz << '\n';
3111 
3112   os << "      Maximum  On-Processor Bandwidth"
3113      << may_equal << max_n_nz << '\n';
3114 
3115   os << "      Maximum Off-Processor Bandwidth"
3116      << may_equal << max_n_oz << std::endl;
3117 
3118 #ifdef LIBMESH_ENABLE_CONSTRAINTS
3119 
3120   std::size_t n_constraints = 0, max_constraint_length = 0,
3121     n_rhss = 0;
3122   long double avg_constraint_length = 0\&.;
3123 
3124   for (DofConstraints::const_iterator it=_dof_constraints\&.begin();
3125        it != _dof_constraints\&.end(); ++it)
3126     {
3127       // Only count local constraints, then sum later
3128       const dof_id_type constrained_dof = it->first;
3129       if (constrained_dof < this->first_dof() ||
3130           constrained_dof >= this->end_dof())
3131         continue;
3132 
3133       const DofConstraintRow& row = it->second;
3134       std::size_t rowsize = row\&.size();
3135 
3136       max_constraint_length = std::max(max_constraint_length,
3137                                        rowsize);
3138       avg_constraint_length += rowsize;
3139       n_constraints++;
3140 
3141       if (_primal_constraint_values\&.count(constrained_dof))
3142         n_rhss++;
3143     }
3144 
3145   this->comm()\&.sum(n_constraints);
3146   this->comm()\&.sum(n_rhss);
3147   this->comm()\&.sum(avg_constraint_length);
3148   this->comm()\&.max(max_constraint_length);
3149 
3150   os << "    DofMap Constraints\n      Number of DoF Constraints = "
3151      << n_constraints;
3152   if (n_rhss)
3153     os << '\n'
3154        << "      Number of Heterogenous Constraints= " << n_rhss;
3155   if (n_constraints)
3156     {
3157       avg_constraint_length /= n_constraints;
3158 
3159       os << '\n'
3160          << "      Average DoF Constraint Length= " << avg_constraint_length;
3161     }
3162 
3163 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3164   std::size_t n_node_constraints = 0, max_node_constraint_length = 0,
3165     n_node_rhss = 0;
3166   long double avg_node_constraint_length = 0\&.;
3167 
3168   for (NodeConstraints::const_iterator it=_node_constraints\&.begin();
3169        it != _node_constraints\&.end(); ++it)
3170     {
3171       // Only count local constraints, then sum later
3172       const Node *node = it->first;
3173       if (node->processor_id() != this->processor_id())
3174         continue;
3175 
3176       const NodeConstraintRow& row = it->second\&.first;
3177       std::size_t rowsize = row\&.size();
3178 
3179       max_node_constraint_length = std::max(max_node_constraint_length,
3180                                             rowsize);
3181       avg_node_constraint_length += rowsize;
3182       n_node_constraints++;
3183 
3184       if (it->second\&.second != Point(0))
3185         n_node_rhss++;
3186     }
3187 
3188   this->comm()\&.sum(n_node_constraints);
3189   this->comm()\&.sum(n_node_rhss);
3190   this->comm()\&.sum(avg_node_constraint_length);
3191   this->comm()\&.max(max_node_constraint_length);
3192 
3193   os << "\n      Number of Node Constraints = " << n_node_constraints;
3194   if (n_node_rhss)
3195     os << '\n'
3196        << "      Number of Heterogenous Node Constraints= " << n_node_rhss;
3197   if (n_node_constraints)
3198     {
3199       avg_node_constraint_length /= n_node_constraints;
3200       os << "\n      Maximum Node Constraint Length= " << max_node_constraint_length
3201          << '\n'
3202          << "      Average Node Constraint Length= " << avg_node_constraint_length;
3203     }
3204 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3205 
3206   os << std::endl;
3207 
3208 #endif // LIBMESH_ENABLE_CONSTRAINTS
3209 
3210   return os\&.str();
3211 }
.fi
.SS "std::string libMesh::DofMap::get_local_constraints (boolprint_nonlocal = \fCfalse\fP) const"
Gets a string reporting all DoF and \fBNode\fP constraints local to this processor\&. If \fCprint_nonlocal\fP is true, then nonlocal constraints which are locally known are included\&. 
.PP
Definition at line 1188 of file dof_map_constraints\&.C\&.
.PP
References libMesh::for(), libMesh::DofObject::id(), libMesh::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
1189 {
1190   std::ostringstream os;
1191 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
1192   if (print_nonlocal)
1193     os << "All ";
1194   else
1195     os << "Local ";
1196 
1197   os << "Node Constraints:"
1198      << std::endl;
1199 
1200   for (NodeConstraints::const_iterator it=_node_constraints\&.begin();
1201        it != _node_constraints\&.end(); ++it)
1202     {
1203       const Node *node = it->first;
1204 
1205       // Skip non-local nodes if requested
1206       if (!print_nonlocal &&
1207           node->processor_id() != this->processor_id())
1208         continue;
1209 
1210       const NodeConstraintRow& row = it->second\&.first;
1211       const Point& offset = it->second\&.second;
1212 
1213       os << "Constraints for Node id " << node->id()
1214          << ": \t";
1215 
1216       for (NodeConstraintRow::const_iterator pos=row\&.begin();
1217            pos != row\&.end(); ++pos)
1218         os << " (" << pos->first->id() << ","
1219            << pos->second << ")\t";
1220 
1221       os << "rhs: " << offset;
1222 
1223       os << std::endl;
1224     }
1225 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
1226 
1227   if (print_nonlocal)
1228     os << "All ";
1229   else
1230     os << "Local ";
1231 
1232   os << "DoF Constraints:"
1233      << std::endl;
1234 
1235   for (DofConstraints::const_iterator it=_dof_constraints\&.begin();
1236        it != _dof_constraints\&.end(); ++it)
1237     {
1238       const dof_id_type i = it->first;
1239 
1240       // Skip non-local dofs if requested
1241       if (!print_nonlocal &&
1242           ((i < this->first_dof()) ||
1243            (i >= this->end_dof())))
1244         continue;
1245 
1246       const DofConstraintRow& row = it->second;
1247       DofConstraintValueMap::const_iterator rhsit =
1248         _primal_constraint_values\&.find(i);
1249       const Number rhs = (rhsit == _primal_constraint_values\&.end()) ?
1250         0 : rhsit->second;
1251 
1252       os << "Constraints for DoF " << i
1253          << ": \t";
1254 
1255       for (DofConstraintRow::const_iterator pos=row\&.begin();
1256            pos != row\&.end(); ++pos)
1257         os << " (" << pos->first << ","
1258            << pos->second << ")\t";
1259 
1260       os << "rhs: " << rhs;
1261 
1262       os << std::endl;
1263     }
1264 
1265   for (unsigned int qoi_index = 0;
1266        qoi_index != _adjoint_dirichlet_boundaries\&.size();
1267        ++qoi_index)
1268     {
1269       os << "Adjoint " << qoi_index << " DoF rhs values:"
1270          << std::endl;
1271 
1272       AdjointDofConstraintValues::const_iterator adjoint_map_it =
1273         _adjoint_constraint_values\&.find(qoi_index);
1274 
1275       if (adjoint_map_it != _adjoint_constraint_values\&.end())
1276         for (DofConstraintValueMap::const_iterator
1277                it=adjoint_map_it->second\&.begin();
1278              it != adjoint_map_it->second\&.end(); ++it)
1279           {
1280             const dof_id_type i = it->first;
1281 
1282             // Skip non-local dofs if requested
1283             if (!print_nonlocal &&
1284                 ((i < this->first_dof()) ||
1285                  (i >= this->end_dof())))
1286               continue;
1287 
1288             const Number rhs = it->second;
1289 
1290             os << "RHS for DoF " << i
1291                << ": " << rhs;
1292 
1293             os << std::endl;
1294           }
1295     }
1296 
1297   return os\&.str();
1298 }
.fi
.SS "const std::vector<\fBdof_id_type\fP>& libMesh::DofMap::get_n_nz () const\fC [inline]\fP"
Returns a constant reference to the \fC_n_nz\fP list for this processor\&. The vector contains the bandwidth of the on-processor coupling for each row of the global matrix that the current processor owns\&. This information can be used to preallocate space for a parallel sparse matrix\&. 
.PP
Definition at line 324 of file dof_map\&.h\&.
.PP
References _n_nz, and libMesh::libmesh_assert()\&.
.PP
.nf
324                                                  {
325     libmesh_assert(_n_nz);
326     return *_n_nz;
327   }
.fi
.SS "const std::vector<\fBdof_id_type\fP>& libMesh::DofMap::get_n_oz () const\fC [inline]\fP"
Returns a constant reference to the \fC_n_oz\fP list for this processor\&. The vector contains the bandwidth of the off-processor coupling for each row of the global matrix that the current processor owns\&. This information can be used to preallocate space for a parallel sparse matrix\&. 
.PP
Definition at line 335 of file dof_map\&.h\&.
.PP
References _n_oz, and libMesh::libmesh_assert()\&.
.PP
.nf
335                                                  {
336     libmesh_assert(_n_oz);
337     return *_n_oz;
338   }
.fi
.SS "\fBPeriodicBoundaries\fP* libMesh::DofMap::get_periodic_boundaries ()\fC [inline]\fP"

.PP
Definition at line 917 of file dof_map\&.h\&.
.PP
References _periodic_boundaries\&.
.PP
.nf
918   {
919     return _periodic_boundaries;
920   }
.fi
.SS "const std::vector<\fBdof_id_type\fP>& libMesh::DofMap::get_send_list () const\fC [inline]\fP"
Returns a constant reference to the \fC_send_list\fP for this processor\&. The \fC_send_list\fP contains the global indices of all the variables in the global solution vector that influence the current processor\&. This information can be used for gathers at each solution step to retrieve solution values needed for computation\&. 
.PP
Definition at line 316 of file dof_map\&.h\&.
.PP
References _send_list\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnsteadySolver::init_data(), libMesh::System::re_update(), libMesh::UnsteadySolver::reinit(), and libMesh::UnsteadySolver::retrieve_timestep()\&.
.PP
.nf
316 { return _send_list; }
.fi
.SS "bool libMesh::DofMap::has_adjoint_dirichlet_boundaries (unsigned intq) const"

.PP
Definition at line 3608 of file dof_map_constraints\&.C\&.
.PP
Referenced by libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
3609 {
3610   if (_adjoint_dirichlet_boundaries\&.size() > q)
3611     return true;
3612 
3613   return false;
3614 }
.fi
.SS "bool libMesh::DofMap::has_blocked_representation () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the variables are capable of being stored in a blocked form\&. Presently, this means that there can only be one variable group, and that the group has more than one variable\&. 
.RE
.PP

.PP
Definition at line 403 of file dof_map\&.h\&.
.PP
References n_variable_groups(), and n_variables()\&.
.PP
Referenced by block_size()\&.
.PP
.nf
404   {
405 #ifdef LIBMESH_ENABLE_BLOCKED_STORAGE
406     return ((this->n_variable_groups() == 1) && (this->n_variables() > 1));
407 #else
408     return false;
409 #endif
410   }
.fi
.SS "bool libMesh::DofMap::has_heterogenous_adjoint_constraint (const unsigned intqoi_num, const \fBdof_id_type\fPdof) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the degree of freedom \fCdof\fP has a heterogenous constraint for adjoint solution \fCqoi_num\fP, false otherwise\&. 
.RE
.PP

.PP
Definition at line 1469 of file dof_map\&.h\&.
.PP
References _adjoint_constraint_values\&.
.PP
.nf
1471 {
1472   AdjointDofConstraintValues::const_iterator it =
1473     _adjoint_constraint_values\&.find(qoi_num);
1474   if (it != _adjoint_constraint_values\&.end() &&
1475       it->second\&.count(dof))
1476     return true;
1477 
1478   return false;
1479 }
.fi
.SS "void libMesh::DofMap::heterogenously_constrain_element_matrix_and_vector (\fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, boolasymmetric_constraint_rows = \fCtrue\fP, intqoi_index = \fC-1\fP) const"
Constrains the element matrix and vector\&. This method requires the element matrix to be square, in which case the elem_dofs correspond to the global DOF indices of both the rows and columns of the element matrix\&. For this case the rows and columns of the matrix necessarily correspond to variables of the same approximation order\&.
.PP
The heterogenous version of this method creates linear systems in which heterogenously constrained degrees of freedom will solve to their correct offset values, as would be appropriate for finding a solution to a linear problem in a single algebraic solve\&. The non-heterogenous version of this method creates linear systems in which even heterogenously constrained degrees of freedom are solved without offset values taken into account, as would be appropriate for finding linearized updates to a solution in which heterogenous constraints are already satisfied\&.
.PP
By default, the constraints for the primal solution of this system are used\&. If a non-negative \fCqoi_index\fP is passed in, then the constraints for the corresponding adjoint solution are used instead\&. 
.PP
Definition at line 1456 of file dof_map_constraints\&.C\&.
.PP
References dof_id, libMesh::DenseMatrix< T >::left_multiply_transpose(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::DenseVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::DenseMatrix< T >::vector_mult(), and libMesh::DenseMatrix< T >::vector_mult_transpose()\&.
.PP
.nf
1461 {
1462   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.m());
1463   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.n());
1464   libmesh_assert_equal_to (elem_dofs\&.size(), rhs\&.size());
1465 
1466   // check for easy return
1467   if (this->_dof_constraints\&.empty())
1468     return;
1469 
1470   // The constrained matrix is built up as C^T K C\&.
1471   // The constrained RHS is built up as C^T (F - K H)
1472   DenseMatrix<Number> C;
1473   DenseVector<Number> H;
1474 
1475   this->build_constraint_matrix_and_vector (C, H, elem_dofs, qoi_index);
1476 
1477   START_LOG("hetero_cnstrn_elem_mat_vec()", "DofMap");
1478 
1479   // It is possible that the matrix is not constrained at all\&.
1480   if ((C\&.m() == matrix\&.m()) &&
1481       (C\&.n() == elem_dofs\&.size())) // It the matrix is constrained
1482     {
1483       // We may have rhs values to use later
1484       const DofConstraintValueMap *rhs_values = NULL;
1485       if (qoi_index < 0)
1486         rhs_values = &_primal_constraint_values;
1487       else
1488         {
1489           const AdjointDofConstraintValues::const_iterator
1490             it = _adjoint_constraint_values\&.find(qoi_index);
1491           if (it != _adjoint_constraint_values\&.end())
1492             rhs_values = &it->second;
1493         }
1494 
1495       // Compute matrix/vector product K H
1496       DenseVector<Number> KH;
1497       matrix\&.vector_mult(KH, H);
1498 
1499       // Compute the matrix-vector product C^T (F - KH)
1500       DenseVector<Number> F_minus_KH(rhs);
1501       F_minus_KH -= KH;
1502       C\&.vector_mult_transpose(rhs, F_minus_KH);
1503 
1504       // Compute the matrix-matrix-matrix product C^T K C
1505       matrix\&.left_multiply_transpose  (C);
1506       matrix\&.right_multiply (C);
1507 
1508       libmesh_assert_equal_to (matrix\&.m(), matrix\&.n());
1509       libmesh_assert_equal_to (matrix\&.m(), elem_dofs\&.size());
1510       libmesh_assert_equal_to (matrix\&.n(), elem_dofs\&.size());
1511 
1512       for (unsigned int i=0; i<elem_dofs\&.size(); i++)
1513         {
1514           const dof_id_type dof_id = elem_dofs[i];
1515 
1516           if (this->is_constrained_dof(dof_id))
1517             {
1518               for (unsigned int j=0; j<matrix\&.n(); j++)
1519                 matrix(i,j) = 0\&.;
1520 
1521               // If the DOF is constrained
1522               matrix(i,i) = 1\&.;
1523 
1524               // This will put a nonsymmetric entry in the constraint
1525               // row to ensure that the linear system produces the
1526               // correct value for the constrained DOF\&.
1527               if (asymmetric_constraint_rows)
1528                 {
1529                   DofConstraints::const_iterator
1530                     pos = _dof_constraints\&.find(dof_id);
1531 
1532                   libmesh_assert (pos != _dof_constraints\&.end());
1533 
1534                   const DofConstraintRow& constraint_row = pos->second;
1535 
1536                   for (DofConstraintRow::const_iterator
1537                          it=constraint_row\&.begin(); it != constraint_row\&.end();
1538                        ++it)
1539                     for (unsigned int j=0; j<elem_dofs\&.size(); j++)
1540                       if (elem_dofs[j] == it->first)
1541                         matrix(i,j) = -it->second;
1542 
1543                   if (rhs_values)
1544                     {
1545                       const DofConstraintValueMap::const_iterator valpos =
1546                         rhs_values->find(dof_id);
1547 
1548                       rhs(i) = (valpos == rhs_values->end()) ?
1549                         0 : valpos->second;
1550                     }
1551                 }
1552               else
1553                 rhs(i) = 0\&.;
1554             }
1555         }
1556 
1557     } // end if is constrained\&.\&.\&.
1558 
1559   STOP_LOG("hetero_cnstrn_elem_mat_vec()", "DofMap");
1560 }
.fi
.SS "void libMesh::DofMap::heterogenously_constrain_element_vector (const \fBDenseMatrix\fP< \fBNumber\fP > &matrix, \fBDenseVector\fP< \fBNumber\fP > &rhs, std::vector< \fBdof_id_type\fP > &elem_dofs, boolasymmetric_constraint_rows = \fCtrue\fP, intqoi_index = \fC-1\fP) const"
Constrains the element vector\&. This method requires the element matrix to be square and not-yet-constrained, in which case the elem_dofs correspond to the global DOF indices of both the rows and columns of the element matrix\&.
.PP
The heterogenous version of this method creates linear systems in which heterogenously constrained degrees of freedom will solve to their correct offset values, as would be appropriate for finding a solution to a linear problem in a single algebraic solve\&. The non-heterogenous version of this method creates linear systems in which even heterogenously constrained degrees of freedom are solved without offset values taken into account, as would be appropriate for finding linearized updates to a solution in which heterogenous constraints are already satisfied\&.
.PP
By default, the constraints for the primal solution of this system are used\&. If a non-negative \fCqoi_index\fP is passed in, then the constraints for the corresponding adjoint solution are used instead\&. 
.PP
Definition at line 1565 of file dof_map_constraints\&.C\&.
.PP
References dof_id, libMesh::DenseMatrixBase< T >::m(), libMesh::DenseMatrixBase< T >::n(), libMesh::DenseVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::DenseMatrix< T >::vector_mult(), and libMesh::DenseMatrix< T >::vector_mult_transpose()\&.
.PP
.nf
1570 {
1571   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.m());
1572   libmesh_assert_equal_to (elem_dofs\&.size(), matrix\&.n());
1573   libmesh_assert_equal_to (elem_dofs\&.size(), rhs\&.size());
1574 
1575   // check for easy return
1576   if (this->_dof_constraints\&.empty())
1577     return;
1578 
1579   // The constrained matrix is built up as C^T K C\&.
1580   // The constrained RHS is built up as C^T (F - K H)
1581   DenseMatrix<Number> C;
1582   DenseVector<Number> H;
1583 
1584   this->build_constraint_matrix_and_vector (C, H, elem_dofs, qoi_index);
1585 
1586   START_LOG("hetero_cnstrn_elem_vec()", "DofMap");
1587 
1588   // It is possible that the matrix is not constrained at all\&.
1589   if ((C\&.m() == matrix\&.m()) &&
1590       (C\&.n() == elem_dofs\&.size())) // It the matrix is constrained
1591     {
1592       // We may have rhs values to use later
1593       const DofConstraintValueMap *rhs_values = NULL;
1594       if (qoi_index < 0)
1595         rhs_values = &_primal_constraint_values;
1596       else
1597         {
1598           const AdjointDofConstraintValues::const_iterator
1599             it = _adjoint_constraint_values\&.find(qoi_index);
1600           if (it != _adjoint_constraint_values\&.end())
1601             rhs_values = &it->second;
1602         }
1603 
1604       // Compute matrix/vector product K H
1605       DenseVector<Number> KH;
1606       matrix\&.vector_mult(KH, H);
1607 
1608       // Compute the matrix-vector product C^T (F - KH)
1609       DenseVector<Number> F_minus_KH(rhs);
1610       F_minus_KH -= KH;
1611       C\&.vector_mult_transpose(rhs, F_minus_KH);
1612 
1613       for (unsigned int i=0; i<elem_dofs\&.size(); i++)
1614         {
1615           const dof_id_type dof_id = elem_dofs[i];
1616 
1617           if (this->is_constrained_dof(dof_id))
1618             {
1619               // This will put a nonsymmetric entry in the constraint
1620               // row to ensure that the linear system produces the
1621               // correct value for the constrained DOF\&.
1622               if (asymmetric_constraint_rows && rhs_values)
1623                 {
1624                   const DofConstraintValueMap::const_iterator valpos =
1625                     rhs_values->find(dof_id);
1626 
1627                   rhs(i) = (valpos == rhs_values->end()) ?
1628                     0 : valpos->second;
1629                 }
1630               else
1631                 rhs(i) = 0\&.;
1632             }
1633         }
1634 
1635     } // end if is constrained\&.\&.\&.
1636 
1637   STOP_LOG("hetero_cnstrn_elem_vec()", "DofMap");
1638 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::DofMap::invalidate_dofs (\fBMeshBase\fP &mesh) const\fC [private]\fP"
Invalidates all active \fBDofObject\fP dofs for this system 
.PP
Definition at line 787 of file dof_map\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), and sys_number()\&.
.PP
Referenced by distribute_dofs(), and reinit()\&.
.PP
.nf
788 {
789   const unsigned int sys_num = this->sys_number();
790 
791   // All the nodes
792   MeshBase::node_iterator       node_it  = mesh\&.nodes_begin();
793   const MeshBase::node_iterator node_end = mesh\&.nodes_end();
794 
795   for ( ; node_it != node_end; ++node_it)
796     (*node_it)->invalidate_dofs(sys_num);
797 
798   // All the elements
799   MeshBase::element_iterator       elem_it  = mesh\&.active_elements_begin();
800   const MeshBase::element_iterator elem_end = mesh\&.active_elements_end();
801 
802   for ( ; elem_it != elem_end; ++elem_it)
803     (*elem_it)->invalidate_dofs(sys_num);
804 }
.fi
.SS "bool libMesh::DofMap::is_attached (\fBSparseMatrix\fP< \fBNumber\fP > &matrix)"
Matrices should not be attached more than once\&. We can test for an already-attached matrix if necessary using \fCis_attached\fP 
.PP
Definition at line 261 of file dof_map\&.C\&.
.PP
References _matrices\&.
.PP
Referenced by libMesh::ImplicitSystem::init_matrices()\&.
.PP
.nf
262 {
263   return (std::find(_matrices\&.begin(), _matrices\&.end(),
264                     &matrix) != _matrices\&.end());
265 }
.fi
.SS "bool libMesh::DofMap::is_constrained_dof (const \fBdof_id_type\fPdof) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the degree of freedom dof is constrained, false otherwise\&. 
.RE
.PP

.PP
Definition at line 1460 of file dof_map\&.h\&.
.PP
References _dof_constraints\&.
.PP
Referenced by libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), extract_local_vector(), and find_connected_dofs()\&.
.PP
.nf
1461 {
1462   if (_dof_constraints\&.count(dof))
1463     return true;
1464 
1465   return false;
1466 }
.fi
.SS "bool libMesh::DofMap::is_constrained_node (const \fBNode\fP *node) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the \fBNode\fP is constrained, false otherwise\&. 
.RE
.PP

.PP
Definition at line 1443 of file dof_map\&.h\&.
.PP
References _node_constraints\&.
.PP
.nf
1448 {
1449 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
1450   if (_node_constraints\&.count(node))
1451     return true;
1452 #endif
1453 
1454   return false;
1455 }
.fi
.SS "bool libMesh::DofMap::is_periodic_boundary (const \fBboundary_id_type\fPboundaryid) const"

.PP
\fBReturns:\fP
.RS 4
true if the boundary given by \fCboundaryid\fP is periodic, false otherwise 
.RE
.PP

.PP
Definition at line 193 of file dof_map\&.C\&.
.PP
References _periodic_boundaries\&.
.PP
.nf
194 {
195   if (_periodic_boundaries->count(boundaryid) != 0)
196     return true;
197 
198   return false;
199 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::last_dof (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the last dof index that is local to processor \fCproc\fP\&. This function is now deprecated, because it returns nonsense in the rare case where \fCproc\fP has no local dof indices\&. Use \fBend_dof()\fP instead\&. 
.PP
Definition at line 475 of file dof_map\&.h\&.
.PP
References _end_df\&.
.PP
.nf
475                                                            {
476     libmesh_deprecated();
477     libmesh_assert_less (proc, _end_df\&.size());
478     return libmesh_cast_int<dof_id_type>(_end_df[proc] - 1);
479   }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::last_dof () const\fC [inline]\fP"

.PP
Definition at line 481 of file dof_map\&.h\&.
.PP
References libMesh::ParallelObject::processor_id()\&.
.PP
.nf
482   { return this->last_dof(this->processor_id()); }
.fi
.SS "void libMesh::DofMap::local_variable_indices (std::vector< \fBdof_id_type\fP > &idx, const \fBMeshBase\fP &mesh, unsigned intvar_num) const"
Fills an array of those dof indices which belong to the given variable number and live on the current processor\&. 
.PP
Definition at line 991 of file dof_map\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::DofObject::dof_number(), end_dof(), first_dof(), libMesh::Elem::get_node(), libMesh::libmesh_assert(), libMesh::MeshBase::local_nodes_begin(), libMesh::MeshBase::local_nodes_end(), libMesh::DofObject::n_comp(), n_nodes, libMesh::Elem::n_nodes(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::SCALAR, SCALAR_dof_indices(), sys_number(), and variable_type()\&.
.PP
Referenced by libMesh::petsc_auto_fieldsplit()\&.
.PP
.nf
994 {
995   const unsigned int sys_num       = this->sys_number();
996 
997   // If this isn't a SCALAR variable, we need to find all its field
998   // dofs on the mesh
999   if (this->variable_type(var_num)\&.family != SCALAR)
1000     {
1001       MeshBase::const_element_iterator       elem_it  = mesh\&.active_local_elements_begin();
1002       const MeshBase::const_element_iterator elem_end = mesh\&.active_local_elements_end();
1003 
1004       for ( ; elem_it != elem_end; ++elem_it)
1005         {
1006           // Only count dofs connected to active
1007           // elements on this processor\&.
1008           Elem* elem                 = *elem_it;
1009           const unsigned int n_nodes = elem->n_nodes();
1010 
1011           // First get any new nodal DOFS
1012           for (unsigned int n=0; n<n_nodes; n++)
1013             {
1014               Node* node = elem->get_node(n);
1015 
1016               if (node->processor_id() < this->processor_id())
1017                 continue;
1018 
1019               const unsigned int n_comp = node->n_comp(sys_num, var_num);
1020               for(unsigned int i=0; i<n_comp; i++)
1021                 {
1022                   const dof_id_type index = node->dof_number(sys_num,var_num,i);
1023                   libmesh_assert_greater_equal (index, this->first_dof());
1024                   libmesh_assert_less (index, this->end_dof());
1025 
1026                   if (idx\&.empty() || index > idx\&.back())
1027                     idx\&.push_back(index);
1028                 }
1029             }
1030 
1031           // Next get any new element DOFS
1032           const unsigned int n_comp = elem->n_comp(sys_num, var_num);
1033           for(unsigned int i=0; i<n_comp; i++)
1034             {
1035               const dof_id_type index = elem->dof_number(sys_num,var_num,i);
1036               if (idx\&.empty() || index > idx\&.back())
1037                     idx\&.push_back(index);
1038             }
1039         } // done looping over elements
1040 
1041 
1042       // we may have missed assigning DOFs to nodes that we own
1043       // but to which we have no connected elements matching our
1044       // variable restriction criterion\&.  this will happen, for example,
1045       // if variable V is restricted to subdomain S\&.  We may not own
1046       // any elements which live in S, but we may own nodes which are
1047       // *connected* to elements which do\&.  in this scenario these nodes
1048       // will presently have unnumbered DOFs\&. we need to take care of
1049       // them here since we own them and no other processor will touch them\&.
1050       {
1051         MeshBase::const_node_iterator       node_it  = mesh\&.local_nodes_begin();
1052         const MeshBase::const_node_iterator node_end = mesh\&.local_nodes_end();
1053 
1054         for (; node_it != node_end; ++node_it)
1055           {
1056             Node *node = *node_it;
1057             libmesh_assert(node);
1058 
1059             const unsigned int n_comp = node->n_comp(sys_num, var_num);
1060             for(unsigned int i=0; i<n_comp; i++)
1061               {
1062                 const dof_id_type index = node->dof_number(sys_num,var_num,i);
1063                 if (idx\&.empty() || index > idx\&.back())
1064                   idx\&.push_back(index);
1065               }
1066           }
1067       }
1068     }
1069   // Otherwise, count up the SCALAR dofs, if we're on the processor
1070   // that holds this SCALAR variable
1071   else if ( this->processor_id() == (this->n_processors()-1) )
1072     {
1073       std::vector<dof_id_type> di_scalar;
1074       this->SCALAR_dof_indices(di_scalar,var_num);
1075       idx\&.insert( idx\&.end(), di_scalar\&.begin(), di_scalar\&.end());
1076     }
1077 }
.fi
.SS "std::pair< \fBReal\fP, \fBReal\fP > libMesh::DofMap::max_constraint_error (const \fBSystem\fP &system, \fBNumericVector\fP< \fBNumber\fP > *v = \fCNULL\fP) const"
Tests the constrained degrees of freedom on the numeric vector \fCv\fP, which represents a solution defined on the mesh, returning a pair whose first entry is the maximum absolute error on a constrained DoF and whose second entry is the maximum relative error\&. Useful for debugging purposes\&.
.PP
If \fCv\fP == NULL, the system solution vector is tested\&. 
.PP
Definition at line 2049 of file dof_map_constraints\&.C\&.
.PP
References std::abs(), libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::NumericVector< T >::closed(), libMesh::NumericVector< T >::first_local_index(), libMesh::for(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), libMesh::DenseMatrixBase< T >::m(), std::max(), mesh, libMesh::DenseMatrixBase< T >::n(), libMesh::Real, and libMesh::System::solution\&.
.PP
.nf
2051 {
2052   if (!v)
2053     v = system\&.solution\&.get();
2054   NumericVector<Number> &vec = *v;
2055 
2056   // We'll assume the vector is closed
2057   libmesh_assert (vec\&.closed());
2058 
2059   Real max_absolute_error = 0\&., max_relative_error = 0\&.;
2060 
2061   const MeshBase &mesh = system\&.get_mesh();
2062 
2063   libmesh_assert_equal_to (this, &(system\&.get_dof_map()));
2064 
2065   // indices on each element
2066   std::vector<dof_id_type> local_dof_indices;
2067 
2068   MeshBase::const_element_iterator       elem_it  =
2069     mesh\&.active_local_elements_begin();
2070   const MeshBase::const_element_iterator elem_end =
2071     mesh\&.active_local_elements_end();
2072 
2073   for ( ; elem_it != elem_end; ++elem_it)
2074     {
2075       const Elem* elem = *elem_it;
2076 
2077       this->dof_indices(elem, local_dof_indices);
2078       std::vector<dof_id_type> raw_dof_indices = local_dof_indices;
2079 
2080       // Constraint matrix for each element
2081       DenseMatrix<Number> C;
2082 
2083       this->build_constraint_matrix (C, local_dof_indices);
2084 
2085       // Continue if the element is unconstrained
2086       if (!C\&.m())
2087         continue;
2088 
2089       libmesh_assert_equal_to (C\&.m(), raw_dof_indices\&.size());
2090       libmesh_assert_equal_to (C\&.n(), local_dof_indices\&.size());
2091 
2092       for (unsigned int i=0; i!=C\&.m(); ++i)
2093         {
2094           // Recalculate any constrained dof owned by this processor
2095           dof_id_type global_dof = raw_dof_indices[i];
2096           if (this->is_constrained_dof(global_dof) &&
2097               global_dof >= vec\&.first_local_index() &&
2098               global_dof < vec\&.last_local_index())
2099             {
2100               DofConstraints::const_iterator
2101                 pos = _dof_constraints\&.find(global_dof);
2102 
2103               libmesh_assert (pos != _dof_constraints\&.end());
2104 
2105               Number exact_value = 0;
2106               DofConstraintValueMap::const_iterator rhsit =
2107                 _primal_constraint_values\&.find(global_dof);
2108               if (rhsit != _primal_constraint_values\&.end())
2109                 exact_value = rhsit->second;
2110 
2111               for (unsigned int j=0; j!=C\&.n(); ++j)
2112                 {
2113                   if (local_dof_indices[j] != global_dof)
2114                     exact_value += C(i,j) *
2115                       vec(local_dof_indices[j]);
2116                 }
2117 
2118               max_absolute_error = std::max(max_absolute_error,
2119                                             std::abs(vec(global_dof) - exact_value));
2120               max_relative_error = std::max(max_relative_error,
2121                                             std::abs(vec(global_dof) - exact_value)
2122                                             / std::abs(exact_value));
2123             }
2124         }
2125     }
2126 
2127   return std::pair<Real, Real>(max_absolute_error, max_relative_error);
2128 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_constrained_dofs () const"

.PP
\fBReturns:\fP
.RS 4
the total number of constrained degrees of freedom in the problem\&. 
.RE
.PP

.PP
Definition at line 919 of file dof_map_constraints\&.C\&.
.PP
References libMesh::comm\&.
.PP
.nf
920 {
921   parallel_object_only();
922 
923   dof_id_type nc_dofs = this->n_local_constrained_dofs();
924   this->comm()\&.sum(nc_dofs);
925   return nc_dofs;
926 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_constrained_nodes () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of constrained Nodes in the mesh\&. 
.RE
.PP

.PP
Definition at line 591 of file dof_map\&.h\&.
.PP
References _node_constraints\&.
.PP
.nf
592   { return libmesh_cast_int<dof_id_type>(_node_constraints\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_dofs () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of degrees of freedom in the problem\&. 
.RE
.PP

.PP
Definition at line 428 of file dof_map\&.h\&.
.PP
References _n_dfs\&.
.PP
Referenced by libMesh::SparsityPattern::Build::join(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::SparsityPattern::Build::parallel_sync(), and SCALAR_dof_indices()\&.
.PP
.nf
428 { return _n_dfs; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_dofs_on_processor (const \fBprocessor_id_type\fPproc) const\fC [inline]\fP"
Returns the number of degrees of freedom on partition \fCproc\fP\&. 
.PP
Definition at line 444 of file dof_map\&.h\&.
.PP
References _end_df, and _first_df\&.
.PP
Referenced by libMesh::SparsityPattern::Build::join(), n_local_dofs(), libMesh::SparsityPattern::Build::operator()(), and libMesh::SparsityPattern::Build::parallel_sync()\&.
.PP
.nf
444                                                                       {
445     libmesh_assert_less (proc, _first_df\&.size());
446     return libmesh_cast_int<dof_id_type>(_end_df[proc] - _first_df[proc]);
447   }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_local_constrained_dofs () const"

.PP
\fBReturns:\fP
.RS 4
the number of constrained degrees of freedom on this processor\&. 
.RE
.PP

.PP
Definition at line 929 of file dof_map_constraints\&.C\&.
.PP
.nf
930 {
931   const DofConstraints::const_iterator lower =
932     _dof_constraints\&.lower_bound(this->first_dof()),
933     upper =
934     _dof_constraints\&.upper_bound(this->end_dof()-1);
935 
936   return std::distance(lower, upper);
937 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_local_dofs () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom on this processor\&. 
.RE
.PP

.PP
Definition at line 438 of file dof_map\&.h\&.
.PP
References n_dofs_on_processor(), and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
439   { return this->n_dofs_on_processor (this->processor_id()); }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_old_dofs () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of degrees of freedom on old_dof_objects 
.RE
.PP

.PP
Definition at line 1004 of file dof_map\&.h\&.
.PP
References _n_old_dfs\&.
.PP
Referenced by SCALAR_dof_indices()\&.
.PP
.nf
1004 { return _n_old_dfs; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), distribute_dofs(), distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::DofMap::n_SCALAR_dofs () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of SCALAR dofs\&. 
.RE
.PP

.PP
Definition at line 433 of file dof_map\&.h\&.
.PP
References _n_SCALAR_dofs\&.
.PP
Referenced by SCALAR_dof_indices()\&.
.PP
.nf
433 { return _n_SCALAR_dofs; }
.fi
.SS "unsigned int libMesh::DofMap::n_variable_groups () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of variables in the global solution vector\&. Defaults to 1, should be 1 for a scalar equation, 3 for 2D incompressible Navier Stokes (u,v,p), etc\&.\&.\&. 
.RE
.PP

.PP
Definition at line 387 of file dof_map\&.h\&.
.PP
References _variable_groups\&.
.PP
Referenced by distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), has_blocked_representation(), reinit(), and set_nonlocal_dof_objects()\&.
.PP
.nf
388   { return libmesh_cast_int<unsigned int>(_variable_groups\&.size()); }
.fi
.SS "unsigned int libMesh::DofMap::n_variables () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of variables in the global solution vector\&. Defaults to 1, should be 1 for a scalar equation, 3 for 2D incompressible Navier Stokes (u,v,p), etc\&.\&.\&. 
.RE
.PP

.PP
Definition at line 395 of file dof_map\&.h\&.
.PP
References _variables\&.
.PP
Referenced by block_size(), DMLibMeshSetSystem(), dof_indices(), has_blocked_representation(), old_dof_indices(), libMesh::SparsityPattern::Build::operator()(), SCALAR_dof_indices(), and use_coupled_neighbor_dofs()\&.
.PP
.nf
396   { return libmesh_cast_int<unsigned int>(_variables\&.size()); }
.fi
.SS "NodeConstraints::const_iterator libMesh::DofMap::node_constraint_rows_begin () const\fC [inline]\fP"
Returns an iterator pointing to the first \fBNode\fP constraint row 
.PP
Definition at line 672 of file dof_map\&.h\&.
.PP
References _node_constraints\&.
.PP
.nf
673   { return _node_constraints\&.begin(); }
.fi
.SS "NodeConstraints::const_iterator libMesh::DofMap::node_constraint_rows_end () const\fC [inline]\fP"
Returns an iterator pointing just past the last \fBNode\fP constraint row 
.PP
Definition at line 678 of file dof_map\&.h\&.
.PP
References _node_constraints\&.
.PP
.nf
679   { return _node_constraints\&.end(); }
.fi
.SS "\fBDofObject\fP * libMesh::DofMap::node_ptr (\fBMeshBase\fP &mesh, \fBdof_id_type\fPi) const\fC [private]\fP"
An adapter function that returns \fBNode\fP pointers by index 
.PP
Definition at line 269 of file dof_map\&.C\&.
.PP
References libMesh::MeshBase::node_ptr()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
270 {
271   return mesh\&.node_ptr(i);
272 }
.fi
.SS "void libMesh::DofMap::old_dof_indices (const \fBElem\fP *constelem, std::vector< \fBdof_id_type\fP > &di, const unsigned intvn = \fC\fBlibMesh::invalid_uint\fP\fP) const"
After a mesh is refined and repartitioned it is possible that the \fC_send_list\fP will need to be augmented\&. This is the case when an element is refined and its children end up on different processors than the parent\&. These children will need values from the parent when projecting the solution onto the refined mesh, hence the parent's DOF indices need to be included in the \fC_send_list\fP\&. Fills the vector di with the global degree of freedom indices for the element using the \fCDofMap::old_dof_object\fP\&. If no variable number is specified then all variables are returned\&. 
.PP
Definition at line 2113 of file dof_map\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::dim, libMesh::Elem::dim(), libMesh::DofObject::dof_number(), libMesh::FEInterface::extra_hanging_dofs(), libMesh::FEType::family, libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::get_node(), libMesh::DofObject::invalid_id, libMesh::invalid_uint, libMesh::Elem::is_vertex(), libMesh::Elem::JUST_COARSENED, libMesh::Elem::JUST_REFINED, libMesh::LAGRANGE, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::DofObject::n_comp(), libMesh::FEInterface::n_dofs_at_node(), libMesh::FEInterface::n_dofs_per_elem(), libMesh::Elem::n_nodes(), libMesh::DofObject::n_systems(), n_variables(), libMesh::n_vars, libMesh::DofObject::old_dof_object, libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::refinement_flag(), libMesh::SCALAR, SCALAR_dof_indices(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), sys_number(), libMesh::TRI3SUBDIVISION, libMesh::Elem::type(), variable(), and variable_type()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::coarsened_dof_values()\&.
.PP
.nf
2116 {
2117   START_LOG("old_dof_indices()", "DofMap");
2118 
2119   libmesh_assert(elem);
2120   libmesh_assert(elem->old_dof_object);
2121 
2122 
2123   const ElemType type        = elem->type();
2124   const unsigned int sys_num = this->sys_number();
2125   const unsigned int n_vars  = this->n_variables();
2126   const unsigned int dim     = elem->dim();
2127 
2128   // Clear the DOF indices vector\&.
2129   di\&.clear();
2130 
2131   // Create a vector to indicate which
2132   // SCALAR variables have been requested
2133   std::vector<unsigned int> SCALAR_var_numbers;
2134   SCALAR_var_numbers\&.clear();
2135 
2136   // Determine the nodes contributing to element elem
2137   std::vector<Node*> elem_nodes;
2138   if (elem->type() == TRI3SUBDIVISION)
2139     {
2140       // Subdivision surface FE require the 1-ring around elem
2141       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
2142       MeshTools::Subdivision::find_one_ring(sd_elem, elem_nodes);
2143     }
2144   else
2145     {
2146       // All other FE use only the nodes of elem itself
2147       elem_nodes\&.resize(elem->n_nodes(), NULL);
2148       for (unsigned int i=0; i<elem->n_nodes(); i++)
2149         elem_nodes[i] = elem->get_node(i);
2150     }
2151 
2152   // Get the dof numbers
2153   for (unsigned int v=0; v<n_vars; v++)
2154     if ((v == vn) || (vn == libMesh::invalid_uint))
2155       {
2156         if(this->variable(v)\&.type()\&.family == SCALAR)
2157           {
2158             // We asked for this variable, so add it to the vector\&.
2159             SCALAR_var_numbers\&.push_back(v);
2160           }
2161         else
2162           if (this->variable(v)\&.active_on_subdomain(elem->subdomain_id()))
2163             { // Do this for all the variables if one was not specified
2164               // or just for the specified variable
2165 
2166               // Increase the polynomial order on p refined elements,
2167               // but make sure you get the right polynomial order for
2168               // the OLD degrees of freedom
2169               int p_adjustment = 0;
2170               if (elem->p_refinement_flag() == Elem::JUST_REFINED)
2171                 {
2172                   libmesh_assert_greater (elem->p_level(), 0);
2173                   p_adjustment = -1;
2174                 }
2175               else if (elem->p_refinement_flag() == Elem::JUST_COARSENED)
2176                 {
2177                   p_adjustment = 1;
2178                 }
2179               FEType fe_type = this->variable_type(v);
2180               fe_type\&.order = static_cast<Order>(fe_type\&.order +
2181                                                  elem->p_level() +
2182                                                  p_adjustment);
2183 
2184               const bool extra_hanging_dofs =
2185                 FEInterface::extra_hanging_dofs(fe_type);
2186 
2187               // Get the node-based DOF numbers
2188               for (unsigned int n=0; n<elem_nodes\&.size(); n++)
2189                 {
2190                   const Node* node      = elem_nodes[n];
2191 
2192                   // There is a potential problem with h refinement\&.  Imagine a
2193                   // quad9 that has a linear FE on it\&.  Then, on the hanging side,
2194                   // it can falsely identify a DOF at the mid-edge node\&. This is why
2195                   // we call FEInterface instead of node->n_comp() directly\&.
2196                   const unsigned int nc = FEInterface::n_dofs_at_node (dim,
2197                                                                        fe_type,
2198                                                                        type,
2199                                                                        n);
2200                   libmesh_assert(node->old_dof_object);
2201 
2202                   // If this is a non-vertex on a hanging node with extra
2203                   // degrees of freedom, we use the non-vertex dofs (which
2204                   // come in reverse order starting from the end, to
2205                   // simplify p refinement)
2206                   if (extra_hanging_dofs && !elem->is_vertex(n))
2207                     {
2208                       const int dof_offset =
2209                         node->old_dof_object->n_comp(sys_num,v) - nc;
2210 
2211                       // We should never have fewer dofs than necessary on a
2212                       // node unless we're getting indices on a parent element
2213                       // or a just-coarsened element
2214                       if (dof_offset < 0)
2215                         {
2216                           libmesh_assert(!elem->active() || elem->refinement_flag() ==
2217                                          Elem::JUST_COARSENED);
2218                           di\&.resize(di\&.size() + nc, DofObject::invalid_id);
2219                         }
2220                       else
2221                         for (int i=node->old_dof_object->n_comp(sys_num,v)-1;
2222                              i>=dof_offset; i--)
2223                           {
2224                             libmesh_assert_not_equal_to (node->old_dof_object->dof_number(sys_num,v,i),
2225                                                          DofObject::invalid_id);
2226                             di\&.push_back(node->old_dof_object->dof_number(sys_num,v,i));
2227                           }
2228                     }
2229                   // If this is a vertex or an element without extra hanging
2230                   // dofs, our dofs come in forward order coming from the
2231                   // beginning
2232                   else
2233                     for (unsigned int i=0; i<nc; i++)
2234                       {
2235                         libmesh_assert_not_equal_to (node->old_dof_object->dof_number(sys_num,v,i),
2236                                                      DofObject::invalid_id);
2237                         di\&.push_back(node->old_dof_object->dof_number(sys_num,v,i));
2238                       }
2239                 }
2240 
2241               // If there are any element-based DOF numbers, get them
2242               const unsigned int nc = FEInterface::n_dofs_per_elem(dim,
2243                                                                    fe_type,
2244                                                                    type);
2245 
2246               // We should never have fewer dofs than necessary on an
2247               // element unless we're getting indices on a parent element
2248               // or a just-coarsened element
2249               if (nc != 0)
2250                 {
2251                   if (elem->old_dof_object->n_systems() > sys_num &&
2252                       nc <= elem->old_dof_object->n_comp(sys_num,v))
2253                     {
2254                       libmesh_assert(elem->old_dof_object);
2255 
2256                       for (unsigned int i=0; i<nc; i++)
2257                         {
2258                           libmesh_assert_not_equal_to (elem->old_dof_object->dof_number(sys_num,v,i),
2259                                                        DofObject::invalid_id);
2260 
2261                           di\&.push_back(elem->old_dof_object->dof_number(sys_num,v,i));
2262                         }
2263                     }
2264                   else
2265                     {
2266                       libmesh_assert(!elem->active() || fe_type\&.family == LAGRANGE ||
2267                                      elem->refinement_flag() == Elem::JUST_COARSENED);
2268                       di\&.resize(di\&.size() + nc, DofObject::invalid_id);
2269                     }
2270                 }
2271             }
2272       } // end loop over variables
2273 
2274   // Finally append any SCALAR dofs that we asked for\&.
2275   std::vector<dof_id_type> di_new;
2276   std::vector<unsigned int>::iterator it           = SCALAR_var_numbers\&.begin();
2277   std::vector<unsigned int>::const_iterator it_end = SCALAR_var_numbers\&.end();
2278   for( ; it != it_end; ++it)
2279     {
2280       this->SCALAR_dof_indices(di_new,*it,true);
2281       di\&.insert( di\&.end(), di_new\&.begin(), di_new\&.end());
2282     }
2283 
2284   STOP_LOG("old_dof_indices()", "DofMap");
2285 }
.fi
.SS "void libMesh::DofMap::prepare_send_list ()"
Takes the \fC_send_list\fP vector (which may have duplicate entries) and sorts it\&. The duplicate entries are then removed, resulting in a sorted \fC_send_list\fP with unique entries\&. Also calls any user-provided methods for adding to the send list\&. 
.PP
Definition at line 1517 of file dof_map\&.C\&.
.PP
References _augment_send_list, _extra_send_list_context, _extra_send_list_function, _send_list, libMesh::DofMap::AugmentSendList::augment_send_list(), libMesh::out, libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::swap()\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
1518 {
1519   START_LOG("prepare_send_list()", "DofMap");
1520 
1521   // Check to see if we have any extra stuff to add to the send_list
1522   if (_extra_send_list_function)
1523     {
1524       if (_augment_send_list)
1525         {
1526           libmesh_here();
1527           libMesh::out << "WARNING:  You have specified both an extra send list function and object\&.\n"
1528                        << "          Are you sure this is what you meant to do??"
1529                        << std::endl;
1530         }
1531 
1532       _extra_send_list_function(_send_list, _extra_send_list_context);
1533     }
1534 
1535   if (_augment_send_list)
1536     _augment_send_list->augment_send_list (_send_list);
1537 
1538   // First sort the send list\&.  After this
1539   // duplicated elements will be adjacent in the
1540   // vector
1541   std::sort(_send_list\&.begin(), _send_list\&.end());
1542 
1543   // Now use std::unique to remove duplicate entries
1544   std::vector<dof_id_type>::iterator new_end =
1545     std::unique (_send_list\&.begin(), _send_list\&.end());
1546 
1547   // Remove the end of the send_list\&.  Use the "swap trick"
1548   // from Effective STL
1549   std::vector<dof_id_type> (_send_list\&.begin(), new_end)\&.swap (_send_list);
1550 
1551   STOP_LOG("prepare_send_list()", "DofMap");
1552 }
.fi
.SS "void libMesh::DofMap::print_dof_constraints (std::ostream &os = \fC\fBlibMesh::out\fP\fP, boolprint_nonlocal = \fCfalse\fP) const"
Prints (from processor 0) all DoF and \fBNode\fP constraints\&. If \fCprint_nonlocal\fP is true, then each constraint is printed once for each processor that knows about it, which may be useful for \fC\fBParallelMesh\fP\fP debugging\&. 
.PP
Definition at line 1162 of file dof_map_constraints\&.C\&.
.PP
References libMesh::comm, libMesh::n_processors(), and libMesh::processor_id()\&.
.PP
.nf
1164 {
1165   parallel_object_only();
1166 
1167   std::string local_constraints =
1168     this->get_local_constraints(print_nonlocal);
1169 
1170   if (this->processor_id())
1171     {
1172       this->comm()\&.send(0, local_constraints);
1173     }
1174   else
1175     {
1176       os << "Processor 0:\n";
1177       os << local_constraints;
1178 
1179       for (processor_id_type i=1; i<this->n_processors(); ++i)
1180         {
1181           this->comm()\&.receive(i, local_constraints);
1182           os << "Processor " << i << ":\n";
1183           os << local_constraints;
1184         }
1185     }
1186 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::DofMap::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const"
Prints summary info about the sparsity bandwidth and constraints\&. 
.PP
Definition at line 3044 of file dof_map\&.C\&.
.PP
.nf
3045 {
3046   os << this->get_info();
3047 }
.fi
.SS "void libMesh::DofMap::process_constraints (\fBMeshBase\fP &mesh)"
Postprocesses any constrained degrees of freedom to be constrained only in terms of unconstrained dofs, then adds unconstrained dofs to the send_list and prepares that for use\&. This should be run after both system (create_dof_constraints) and user constraints have all been added\&. 
.PP
Definition at line 2962 of file dof_map_constraints\&.C\&.
.PP
References libMesh::for(), libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
2963 {
2964   // With a parallelized Mesh, we've computed our local constraints,
2965   // but they may depend on non-local constraints that we'll need to
2966   // take into account\&.
2967   if (!mesh\&.is_serial())
2968     this->allgather_recursive_constraints(mesh);
2969 
2970   // Create a set containing the DOFs we already depend on
2971   typedef std::set<dof_id_type> RCSet;
2972   RCSet unexpanded_set;
2973 
2974   for (DofConstraints::iterator i = _dof_constraints\&.begin();
2975        i != _dof_constraints\&.end(); ++i)
2976     unexpanded_set\&.insert(i->first);
2977 
2978   while (!unexpanded_set\&.empty())
2979     for (RCSet::iterator i = unexpanded_set\&.begin();
2980          i != unexpanded_set\&.end(); /* nothing */)
2981       {
2982         // If the DOF is constrained
2983         DofConstraints::iterator
2984           pos = _dof_constraints\&.find(*i);
2985 
2986         libmesh_assert (pos != _dof_constraints\&.end());
2987 
2988         DofConstraintRow& constraint_row = pos->second;
2989 
2990         DofConstraintValueMap::iterator rhsit =
2991           _primal_constraint_values\&.find(*i);
2992         Number constraint_rhs = (rhsit == _primal_constraint_values\&.end()) ?
2993           0 : rhsit->second;
2994 
2995         std::vector<dof_id_type> constraints_to_expand;
2996 
2997         for (DofConstraintRow::const_iterator
2998                it=constraint_row\&.begin(); it != constraint_row\&.end();
2999              ++it)
3000           if (it->first != *i && this->is_constrained_dof(it->first))
3001             {
3002               unexpanded_set\&.insert(it->first);
3003               constraints_to_expand\&.push_back(it->first);
3004             }
3005 
3006         for (std::size_t j = 0; j != constraints_to_expand\&.size();
3007              ++j)
3008           {
3009             dof_id_type expandable = constraints_to_expand[j];
3010 
3011             const Real this_coef = constraint_row[expandable];
3012 
3013             DofConstraints::const_iterator
3014               subpos = _dof_constraints\&.find(expandable);
3015 
3016             libmesh_assert (subpos != _dof_constraints\&.end());
3017 
3018             const DofConstraintRow& subconstraint_row = subpos->second;
3019 
3020             for (DofConstraintRow::const_iterator
3021                    it=subconstraint_row\&.begin();
3022                  it != subconstraint_row\&.end(); ++it)
3023               {
3024                 constraint_row[it->first] += it->second * this_coef;
3025               }
3026             DofConstraintValueMap::const_iterator subrhsit =
3027               _primal_constraint_values\&.find(expandable);
3028             if (subrhsit != _primal_constraint_values\&.end())
3029               constraint_rhs += subrhsit->second * this_coef;
3030 
3031             constraint_row\&.erase(expandable);
3032           }
3033 
3034         if (rhsit == _primal_constraint_values\&.end())
3035           {
3036             if (constraint_rhs != Number(0))
3037               _primal_constraint_values[*i] = constraint_rhs;
3038             else
3039               _primal_constraint_values\&.erase(*i);
3040           }
3041         else
3042           {
3043             if (constraint_rhs != Number(0))
3044               rhsit->second = constraint_rhs;
3045             else
3046               _primal_constraint_values\&.erase(rhsit);
3047           }
3048 
3049         if (constraints_to_expand\&.empty())
3050           unexpanded_set\&.erase(i++);
3051         else
3052           ++i;
3053       }
3054 
3055   // In parallel we can't guarantee that nodes/dofs which constrain
3056   // others are on processors which are aware of that constraint, yet
3057   // we need such awareness for sparsity pattern generation\&.  So send
3058   // other processors any constraints they might need to know about\&.
3059   if (!mesh\&.is_serial())
3060     this->scatter_constraints(mesh);
3061 
3062   // Now that we have our root constraint dependencies sorted out, add
3063   // them to the send_list
3064   this->add_constraints_to_send_list();
3065 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), distribute_dofs(), distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), end_dof(), end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), first_dof(), first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "void libMesh::DofMap::reinit (\fBMeshBase\fP &mesh)"
Reinitialize the underlying data strucures conformal to the current mesh\&. 
.PP
Definition at line 432 of file dof_map\&.C\&.
.PP
References _n_SCALAR_dofs, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::Variable::active_on_subdomain(), libMesh::dim, libMesh::Elem::dim(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::Utility::enum_to_string(), libMesh::err, libMesh::FEInterface::extra_hanging_dofs(), libMesh::FEType::family, libMesh::Elem::get_node(), libMesh::DofObject::has_dofs(), invalidate_dofs(), libMesh::MeshBase::is_prepared(), libMesh::Elem::is_vertex(), libMesh::Elem::JUST_REFINED, libMesh::libmesh_assert(), std::max(), libMesh::FEInterface::max_order(), libMesh::DofObject::n_comp_group(), libMesh::FEInterface::n_dofs_at_node(), libMesh::FEInterface::n_dofs_per_elem(), libMesh::Elem::n_nodes(), n_variable_groups(), libMesh::VariableGroup::n_variables(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::DofObject::old_dof_object, libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::Elem::refinement_flag(), libMesh::SCALAR, libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_old_dof_object(), libMesh::Elem::set_p_level(), libMesh::DofObject::set_vg_dof_base(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), sys_number(), libMesh::Variable::type(), libMesh::Elem::type(), variable_group(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
433 {
434   libmesh_assert (mesh\&.is_prepared());
435 
436   START_LOG("reinit()", "DofMap");
437 
438   const unsigned int
439     sys_num      = this->sys_number(),
440     n_var_groups = this->n_variable_groups();
441 
442   // The DofObjects need to know how many variable groups we have, and
443   // how many variables there are in each group\&.
444   std::vector<unsigned int> n_vars_per_group;  n_vars_per_group\&.reserve (n_var_groups);
445 
446   for (unsigned int vg=0; vg<n_var_groups; vg++)
447     n_vars_per_group\&.push_back (this->variable_group(vg)\&.n_variables());
448 
449 #ifdef LIBMESH_ENABLE_AMR
450 
451   //------------------------------------------------------------
452   // Clear the old_dof_objects for all the nodes
453   // and elements so that we can overwrite them
454   {
455     MeshBase::node_iterator       node_it  = mesh\&.nodes_begin();
456     const MeshBase::node_iterator node_end = mesh\&.nodes_end();
457 
458     for ( ; node_it != node_end; ++node_it)
459       {
460         (*node_it)->clear_old_dof_object();
461         libmesh_assert (!(*node_it)->old_dof_object);
462       }
463 
464     MeshBase::element_iterator       elem_it  = mesh\&.elements_begin();
465     const MeshBase::element_iterator elem_end = mesh\&.elements_end();
466 
467     for ( ; elem_it != elem_end; ++elem_it)
468       {
469         (*elem_it)->clear_old_dof_object();
470         libmesh_assert (!(*elem_it)->old_dof_object);
471       }
472   }
473 
474 
475   //------------------------------------------------------------
476   // Set the old_dof_objects for the elements that
477   // weren't just created, if these old dof objects
478   // had variables
479   {
480     MeshBase::element_iterator       elem_it  = mesh\&.elements_begin();
481     const MeshBase::element_iterator elem_end = mesh\&.elements_end();
482 
483     for ( ; elem_it != elem_end; ++elem_it)
484       {
485         Elem* elem = *elem_it;
486 
487         // Skip the elements that were just refined
488         if (elem->refinement_flag() == Elem::JUST_REFINED) continue;
489 
490         for (unsigned int n=0; n<elem->n_nodes(); n++)
491           {
492             Node* node = elem->get_node(n);
493 
494             if (node->old_dof_object == NULL)
495               if (node->has_dofs(sys_num))
496                 node->set_old_dof_object();
497           }
498 
499         libmesh_assert (!elem->old_dof_object);
500 
501         if (elem->has_dofs(sys_num))
502           elem->set_old_dof_object();
503       }
504   }
505 
506 #endif // #ifdef LIBMESH_ENABLE_AMR
507 
508 
509   //------------------------------------------------------------
510   // Then set the number of variables for each \p DofObject
511   // equal to n_variables() for this system\&.  This will
512   // handle new \p DofObjects that may have just been created
513   {
514     // All the nodes
515     MeshBase::node_iterator       node_it  = mesh\&.nodes_begin();
516     const MeshBase::node_iterator node_end = mesh\&.nodes_end();
517 
518     for ( ; node_it != node_end; ++node_it)
519       (*node_it)->set_n_vars_per_group(sys_num, n_vars_per_group);
520 
521     // All the elements
522     MeshBase::element_iterator       elem_it  = mesh\&.elements_begin();
523     const MeshBase::element_iterator elem_end = mesh\&.elements_end();
524 
525     for ( ; elem_it != elem_end; ++elem_it)
526       (*elem_it)->set_n_vars_per_group(sys_num, n_vars_per_group);
527   }
528 
529 
530   // Zero _n_SCALAR_dofs, it will be updated below\&.
531   this->_n_SCALAR_dofs = 0;
532 
533   //------------------------------------------------------------
534   // Next allocate space for the DOF indices
535   for (unsigned int vg=0; vg<n_var_groups; vg++)
536     {
537       const VariableGroup &vg_description = this->variable_group(vg);
538 
539       const unsigned int n_var_in_group = vg_description\&.n_variables();
540       const FEType& base_fe_type        = vg_description\&.type();
541 
542       // Don't need to loop over elements for a SCALAR variable
543       // Just increment _n_SCALAR_dofs
544       if(base_fe_type\&.family == SCALAR)
545         {
546           this->_n_SCALAR_dofs += base_fe_type\&.order*n_var_in_group;
547           continue;
548         }
549 
550       // This should be constant even on p-refined elements
551       const bool extra_hanging_dofs =
552         FEInterface::extra_hanging_dofs(base_fe_type);
553 
554       // For all the active elements
555       MeshBase::element_iterator       elem_it  = mesh\&.active_elements_begin();
556       const MeshBase::element_iterator elem_end = mesh\&.active_elements_end();
557 
558       // Count vertex degrees of freedom first
559       for ( ; elem_it != elem_end; ++elem_it)
560         {
561           Elem* elem  = *elem_it;
562           libmesh_assert(elem);
563 
564           // Skip the numbering if this variable is
565           // not active on this element's subdomain
566           if (!vg_description\&.active_on_subdomain(elem->subdomain_id()))
567             continue;
568 
569           const ElemType type = elem->type();
570           const unsigned int dim = elem->dim();
571 
572           FEType fe_type = base_fe_type;
573 
574 #ifdef LIBMESH_ENABLE_AMR
575           // Make sure we haven't done more p refinement than we can
576           // handle
577           if (elem->p_level() + base_fe_type\&.order >
578               FEInterface::max_order(base_fe_type, type))
579             {
580 #  ifdef DEBUG
581               if (FEInterface::max_order(base_fe_type,type) <
582                   static_cast<unsigned int>(base_fe_type\&.order))
583                 {
584                   libMesh::err
585                     << "ERROR: Finite element "
586                     << Utility::enum_to_string(base_fe_type\&.family)
587                     << " on geometric element "
588                     << Utility::enum_to_string(type) << std::endl
589                     << "only supports FEInterface::max_order = "
590                     << FEInterface::max_order(base_fe_type,type)
591                     << ", not fe_type\&.order = " << base_fe_type\&.order
592                     << std::endl;
593 
594                   libmesh_error();
595                 }
596 
597               libMesh::err
598                 << "WARNING: Finite element "
599                 << Utility::enum_to_string(base_fe_type\&.family)
600                 << " on geometric element "
601                 << Utility::enum_to_string(type) << std::endl
602                 << "could not be p refined past FEInterface::max_order = "
603                 << FEInterface::max_order(base_fe_type,type)
604                 << std::endl;
605 #  endif
606               elem->set_p_level(FEInterface::max_order(base_fe_type,type)
607                                 - base_fe_type\&.order);
608             }
609 #endif
610 
611           fe_type\&.order = static_cast<Order>(fe_type\&.order +
612                                              elem->p_level());
613 
614           // Allocate the vertex DOFs
615           for (unsigned int n=0; n<elem->n_nodes(); n++)
616             {
617               Node* node = elem->get_node(n);
618 
619               if (elem->is_vertex(n))
620                 {
621                   const unsigned int old_node_dofs =
622                     node->n_comp_group(sys_num, vg);
623 
624                   const unsigned int vertex_dofs =
625                     std::max(FEInterface::n_dofs_at_node(dim, fe_type,
626                                                          type, n),
627                              old_node_dofs);
628 
629                   // Some discontinuous FEs have no vertex dofs
630                   if (vertex_dofs > old_node_dofs)
631                     {
632                       node->set_n_comp_group(sys_num, vg,
633                                              vertex_dofs);
634 
635                       // Abusing dof_number to set a "this is a
636                       // vertex" flag
637                       node->set_vg_dof_base(sys_num, vg,
638                                             vertex_dofs);
639 
640                       // libMesh::out << "sys_num,vg,old_node_dofs,vertex_dofs="
641                       //       << sys_num << ","
642                       //       << vg << ","
643                       //       << old_node_dofs << ","
644                       //       << vertex_dofs << '\n',
645                       // node->debug_buffer();
646 
647                       // libmesh_assert_equal_to (vertex_dofs, node->n_comp(sys_num, vg));
648                       // libmesh_assert_equal_to (vertex_dofs, node->vg_dof_base(sys_num, vg));
649                     }
650                 }
651             }
652         } // done counting vertex dofs
653 
654       // count edge & face dofs next
655       elem_it = mesh\&.active_elements_begin();
656 
657       for ( ; elem_it != elem_end; ++elem_it)
658         {
659           Elem* elem = *elem_it;
660           libmesh_assert(elem);
661 
662           // Skip the numbering if this variable is
663           // not active on this element's subdomain
664           if (!vg_description\&.active_on_subdomain(elem->subdomain_id()))
665             continue;
666 
667           const ElemType type = elem->type();
668           const unsigned int dim = elem->dim();
669 
670           FEType fe_type = base_fe_type;
671           fe_type\&.order = static_cast<Order>(fe_type\&.order +
672                                              elem->p_level());
673 
674           // Allocate the edge and face DOFs
675           for (unsigned int n=0; n<elem->n_nodes(); n++)
676             {
677               Node* node = elem->get_node(n);
678 
679               const unsigned int old_node_dofs =
680                 node->n_comp_group(sys_num, vg);
681 
682               const unsigned int vertex_dofs = old_node_dofs?
683                 libmesh_cast_int<unsigned int>(node->vg_dof_base (sys_num,vg)):0;
684 
685               const unsigned int new_node_dofs =
686                 FEInterface::n_dofs_at_node(dim, fe_type, type, n);
687 
688               // We've already allocated vertex DOFs
689               if (elem->is_vertex(n))
690                 {
691                   libmesh_assert_greater_equal (old_node_dofs, vertex_dofs);
692                   // //if (vertex_dofs < new_node_dofs)
693                   //   libMesh::out << "sys_num,vg,old_node_dofs,vertex_dofs,new_node_dofs="
694                   //                << sys_num << ","
695                   //                << vg << ","
696                   //                << old_node_dofs << ","
697                   //                << vertex_dofs << ","
698                   //                << new_node_dofs << '\n',
699                   //     node->debug_buffer();
700 
701                   libmesh_assert_greater_equal (vertex_dofs,   new_node_dofs);
702                 }
703               // We need to allocate the rest
704               else
705                 {
706                   // If this has no dofs yet, it needs no vertex
707                   // dofs, so we just give it edge or face dofs
708                   if (!old_node_dofs)
709                     {
710                       node->set_n_comp_group(sys_num, vg,
711                                              new_node_dofs);
712                       // Abusing dof_number to set a "this has no
713                       // vertex dofs" flag
714                       if (new_node_dofs)
715                         node->set_vg_dof_base(sys_num, vg,
716                                               0);
717                     }
718 
719                   // If this has dofs, but has no vertex dofs,
720                   // it may still need more edge or face dofs if
721                   // we're p-refined\&.
722                   else if (vertex_dofs == 0)
723                     {
724                       if (new_node_dofs > old_node_dofs)
725                         {
726                           node->set_n_comp_group(sys_num, vg,
727                                                  new_node_dofs);
728 
729                           node->set_vg_dof_base(sys_num, vg,
730                                                 vertex_dofs);
731                         }
732                     }
733                   // If this is another element's vertex,
734                   // add more (non-overlapping) edge/face dofs if
735                   // necessary
736                   else if (extra_hanging_dofs)
737                     {
738                       if (new_node_dofs > old_node_dofs - vertex_dofs)
739                         {
740                           node->set_n_comp_group(sys_num, vg,
741                                                  vertex_dofs + new_node_dofs);
742 
743                           node->set_vg_dof_base(sys_num, vg,
744                                                 vertex_dofs);
745                         }
746                     }
747                   // If this is another element's vertex, add any
748                   // (overlapping) edge/face dofs if necessary
749                   else
750                     {
751                       libmesh_assert_greater_equal (old_node_dofs, vertex_dofs);
752                       if (new_node_dofs > old_node_dofs)
753                         {
754                           node->set_n_comp_group(sys_num, vg,
755                                                  new_node_dofs);
756 
757                           node->set_vg_dof_base (sys_num, vg,
758                                                  vertex_dofs);
759                         }
760                     }
761                 }
762             }
763           // Allocate the element DOFs
764           const unsigned int dofs_per_elem =
765             FEInterface::n_dofs_per_elem(dim, fe_type,
766                                          type);
767 
768           elem->set_n_comp_group(sys_num, vg, dofs_per_elem);
769 
770         }
771     } // end loop over variable groups
772 
773   // Calling DofMap::reinit() by itself makes little sense,
774   // so we won't bother with nonlocal DofObjects\&.
775   // Those will be fixed by distribute_dofs
776 
777   //------------------------------------------------------------
778   // Finally, clear all the current DOF indices
779   // (distribute_dofs expects them cleared!)
780   this->invalidate_dofs(mesh);
781 
782   STOP_LOG("reinit()", "DofMap");
783 }
.fi
.SS "void libMesh::DofMap::remove_adjoint_dirichlet_boundary (const \fBDirichletBoundary\fP &dirichlet_boundary, unsigned intq)"
Removes from the system the specified Dirichlet boundary for the adjoint equation defined by Quantity of interest index q 
.PP
Definition at line 3657 of file dof_map_constraints\&.C\&.
.PP
References libMesh::DirichletBoundary::b, end, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), and libMesh::DirichletBoundary::variables\&.
.PP
.nf
3659 {
3660   libmesh_assert_greater(_adjoint_dirichlet_boundaries\&.size(),
3661                          qoi_index);
3662 
3663   // Find a boundary condition matching the one to be removed
3664   std::vector<DirichletBoundary *>::iterator it =
3665     _adjoint_dirichlet_boundaries[qoi_index]->begin();
3666   std::vector<DirichletBoundary *>::iterator end =
3667     _adjoint_dirichlet_boundaries[qoi_index]->end();
3668   for (; it != end; ++it)
3669     {
3670       DirichletBoundary *bdy = *it;
3671 
3672       if ((bdy->b == boundary_to_remove\&.b) &&
3673           bdy->variables == boundary_to_remove\&.variables)
3674         break;
3675     }
3676 
3677   // Delete it and remove it
3678   libmesh_assert (it != end);
3679   delete *it;
3680   _adjoint_dirichlet_boundaries[qoi_index]->erase(it);
3681 }
.fi
.SS "void libMesh::DofMap::remove_dirichlet_boundary (const \fBDirichletBoundary\fP &dirichlet_boundary)"
Removes the specified Dirichlet boundary from the system\&. 
.PP
Definition at line 3636 of file dof_map_constraints\&.C\&.
.PP
References libMesh::DirichletBoundary::b, end, libMesh::libmesh_assert(), and libMesh::DirichletBoundary::variables\&.
.PP
.nf
3637 {
3638   // Find a boundary condition matching the one to be removed
3639   std::vector<DirichletBoundary *>::iterator it = _dirichlet_boundaries->begin();
3640   std::vector<DirichletBoundary *>::iterator end = _dirichlet_boundaries->end();
3641   for (; it != end; ++it)
3642     {
3643       DirichletBoundary *bdy = *it;
3644 
3645       if ((bdy->b == boundary_to_remove\&.b) &&
3646           bdy->variables == boundary_to_remove\&.variables)
3647         break;
3648     }
3649 
3650   // Delete it and remove it
3651   libmesh_assert (it != end);
3652   delete *it;
3653   _dirichlet_boundaries->erase(it);
3654 }
.fi
.SS "void libMesh::DofMap::SCALAR_dof_indices (std::vector< \fBdof_id_type\fP > &di, const unsigned intvn, const boolold_dofs = \fCfalse\fP) const"
Fills the vector \fCdi\fP with the global degree of freedom indices corresponding to the SCALAR variable vn\&. If old_dofs=true, the old SCALAR dof indices are returned\&. Note that we do not need to pass in an element since SCALARs are global variables\&. 
.PP
Definition at line 2025 of file dof_map\&.C\&.
.PP
References libMesh::err, libMesh::FEType::family, libMesh::libmesh_assert(), n_dofs(), n_old_dofs(), n_SCALAR_dofs(), n_variables(), libMesh::FEType::order, libMesh::SCALAR, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Variable::type(), and variable()\&.
.PP
Referenced by dof_indices(), local_variable_indices(), old_dof_indices(), libMesh::System::project_vector(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::write_parallel_data(), and libMesh::System::write_SCALAR_dofs()\&.
.PP
.nf
2033 {
2034   START_LOG("SCALAR_dof_indices()", "DofMap");
2035 
2036   if(this->variable(vn)\&.type()\&.family != SCALAR)
2037     {
2038       libMesh::err << "ERROR: SCALAR_dof_indices called for a non-SCALAR variable\&."
2039                    << std::endl;
2040     }
2041 
2042   // Clear the DOF indices vector
2043   di\&.clear();
2044 
2045   // First we need to find out the first dof
2046   // index for each SCALAR\&.
2047 #ifdef LIBMESH_ENABLE_AMR
2048   dof_id_type first_SCALAR_dof_index = (old_dofs ? n_old_dofs() : n_dofs()) - n_SCALAR_dofs();
2049 #else
2050   dof_id_type first_SCALAR_dof_index = n_dofs() - n_SCALAR_dofs();
2051 #endif
2052   std::map<unsigned int, dof_id_type> SCALAR_first_dof_index;
2053   SCALAR_first_dof_index\&.clear();
2054 
2055   // Iterate over _all_ of the SCALARs and store each one's first dof index
2056   // We need to do this since the SCALAR dofs are packed contiguously
2057   for (unsigned int v=0; v<this->n_variables(); v++)
2058     if(this->variable(v)\&.type()\&.family == SCALAR)
2059       {
2060         unsigned int current_n_SCALAR_dofs = this->variable(v)\&.type()\&.order;
2061         SCALAR_first_dof_index\&.insert(
2062                                       std::pair<unsigned int, dof_id_type>(v,first_SCALAR_dof_index) );
2063         first_SCALAR_dof_index += current_n_SCALAR_dofs;
2064       }
2065 
2066   // Now use vn to index into SCALAR_first_dof_index
2067   std::map<unsigned int, dof_id_type>::const_iterator iter =
2068     SCALAR_first_dof_index\&.find(vn);
2069 
2070 #ifdef DEBUG
2071   libmesh_assert (iter != SCALAR_first_dof_index\&.end());
2072 #endif
2073 
2074   dof_id_type current_first_SCALAR_dof_index = iter->second;
2075 
2076   // Also, get the number of SCALAR dofs from the variable order
2077   unsigned int current_n_SCALAR_dofs = this->variable(vn)\&.type()\&.order;
2078 
2079   for(unsigned int j=0; j<current_n_SCALAR_dofs; j++)
2080     {
2081       dof_id_type index = current_first_SCALAR_dof_index+j;
2082       di\&.push_back(index);
2083     }
2084 
2085   STOP_LOG("SCALAR_dof_indices()", "DofMap");
2086 }
.fi
.SS "void libMesh::DofMap::scatter_constraints (\fBMeshBase\fP &mesh)"
Sends constraint equations to constraining processors 
.PP
Definition at line 3068 of file dof_map_constraints\&.C\&.
.PP
References libMesh::MeshBase::active_not_local_elements_begin(), libMesh::MeshBase::active_not_local_elements_end(), libMesh::comm, end, libMesh::DofObject::id(), libMesh::libmesh_assert(), mesh, libMesh::n_processors(), libMesh::MeshBase::node_ptr(), libMesh::processor_id(), libMesh::DofObject::processor_id(), and libMesh::TypeVector< T >::size()\&.
.PP
.nf
3069 {
3070   // At this point each processor with a constrained node knows
3071   // the corresponding constraint row, but we also need each processor
3072   // with a constrainer node to know the corresponding row(s)\&.
3073 
3074   // This function must be run on all processors at once
3075   parallel_object_only();
3076 
3077   // Return immediately if there's nothing to gather
3078   if (this->n_processors() == 1)
3079     return;
3080 
3081   // We might get to return immediately if none of the processors
3082   // found any constraints
3083   unsigned int has_constraints = !_dof_constraints\&.empty()
3084 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3085     || !_node_constraints\&.empty()
3086 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3087     ;
3088   this->comm()\&.max(has_constraints);
3089   if (!has_constraints)
3090     return;
3091 
3092 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3093   std::vector<std::set<dof_id_type> > pushed_node_ids(this->n_processors());
3094 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3095 
3096   std::vector<std::set<dof_id_type> > pushed_ids(this->n_processors());
3097 
3098   // Collect the dof constraints I need to push to each processor
3099   dof_id_type constrained_proc_id = 0;
3100   for (DofConstraints::iterator i = _dof_constraints\&.begin();
3101        i != _dof_constraints\&.end(); ++i)
3102     {
3103       const dof_id_type constrained = i->first;
3104       while (constrained >= _end_df[constrained_proc_id])
3105         constrained_proc_id++;
3106 
3107       if (constrained_proc_id != this->processor_id())
3108         continue;
3109 
3110       DofConstraintRow &row = i->second;
3111       for (DofConstraintRow::iterator j = row\&.begin();
3112            j != row\&.end(); ++j)
3113         {
3114           const dof_id_type constraining = j->first;
3115 
3116           processor_id_type constraining_proc_id = 0;
3117           while (constraining >= _end_df[constraining_proc_id])
3118             constraining_proc_id++;
3119 
3120           if (constraining_proc_id != this->processor_id() &&
3121               constraining_proc_id != constrained_proc_id)
3122             pushed_ids[constraining_proc_id]\&.insert(constrained);
3123         }
3124     }
3125 
3126 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3127   // Collect the node constraints to push to each processor
3128   for (NodeConstraints::iterator i = _node_constraints\&.begin();
3129        i != _node_constraints\&.end(); ++i)
3130     {
3131       const Node *constrained = i->first;
3132 
3133       if (constrained->processor_id() != this->processor_id())
3134         continue;
3135 
3136       NodeConstraintRow &row = i->second\&.first;
3137       for (NodeConstraintRow::iterator j = row\&.begin();
3138            j != row\&.end(); ++j)
3139         {
3140           const Node *constraining = j->first;
3141 
3142           if (constraining->processor_id() != this->processor_id() &&
3143               constraining->processor_id() != constrained->processor_id())
3144             pushed_node_ids[constraining->processor_id()]\&.insert(constrained->id());
3145         }
3146     }
3147 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3148 
3149   // Now trade constraint rows
3150   for (processor_id_type p = 0; p != this->n_processors(); ++p)
3151     {
3152       // Push to processor procup while receiving from procdown
3153       processor_id_type procup = (this->processor_id() + p) %
3154         this->n_processors();
3155       processor_id_type procdown = (this->n_processors() +
3156                                     this->processor_id() - p) %
3157         this->n_processors();
3158 
3159       // Pack the dof constraint rows and rhs's to push to procup
3160       const std::size_t pushed_ids_size = pushed_ids[procup]\&.size();
3161       std::vector<std::vector<dof_id_type> > pushed_keys(pushed_ids_size);
3162       std::vector<std::vector<Real> > pushed_vals(pushed_ids_size);
3163       std::vector<Number> pushed_rhss(pushed_ids_size);
3164 
3165       std::set<dof_id_type>::const_iterator it;
3166       std::size_t push_i;
3167       for (push_i = 0, it = pushed_ids[procup]\&.begin();
3168            it != pushed_ids[procup]\&.end(); ++push_i, ++it)
3169         {
3170           const dof_id_type constrained = *it;
3171           DofConstraintRow &row = _dof_constraints[constrained];
3172           std::size_t row_size = row\&.size();
3173           pushed_keys[push_i]\&.reserve(row_size);
3174           pushed_vals[push_i]\&.reserve(row_size);
3175           for (DofConstraintRow::iterator j = row\&.begin();
3176                j != row\&.end(); ++j)
3177             {
3178               pushed_keys[push_i]\&.push_back(j->first);
3179               pushed_vals[push_i]\&.push_back(j->second);
3180             }
3181 
3182           DofConstraintValueMap::const_iterator rhsit =
3183             _primal_constraint_values\&.find(constrained);
3184           pushed_rhss[push_i] = (rhsit == _primal_constraint_values\&.end()) ?
3185             0 : rhsit->second;
3186         }
3187 
3188 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3189       // Pack the node constraint rows to push to procup
3190       const std::size_t pushed_node_ids_size = pushed_node_ids[procup]\&.size();
3191       std::vector<std::vector<dof_id_type> > pushed_node_keys(pushed_node_ids_size);
3192       std::vector<std::vector<Real> > pushed_node_vals(pushed_node_ids_size);
3193       std::vector<Point> pushed_node_offsets(pushed_node_ids_size);
3194       std::set<const Node*> pushed_nodes;
3195 
3196       for (push_i = 0, it = pushed_node_ids[procup]\&.begin();
3197            it != pushed_node_ids[procup]\&.end(); ++push_i, ++it)
3198         {
3199           const Node *constrained = mesh\&.node_ptr(*it);
3200 
3201           if (constrained->processor_id() != procdown)
3202             pushed_nodes\&.insert(constrained);
3203 
3204           NodeConstraintRow &row = _node_constraints[constrained]\&.first;
3205           std::size_t row_size = row\&.size();
3206           pushed_node_keys[push_i]\&.reserve(row_size);
3207           pushed_node_vals[push_i]\&.reserve(row_size);
3208           for (NodeConstraintRow::iterator j = row\&.begin();
3209                j != row\&.end(); ++j)
3210             {
3211               const Node* constraining = j->first;
3212 
3213               pushed_node_keys[push_i]\&.push_back(constraining->id());
3214               pushed_node_vals[push_i]\&.push_back(j->second);
3215 
3216               if (constraining->processor_id() != procup)
3217                 pushed_nodes\&.insert(constraining);
3218             }
3219           pushed_node_offsets[push_i] = _node_constraints[constrained]\&.second;
3220         }
3221 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3222 
3223       // Trade pushed dof constraint rows
3224       std::vector<dof_id_type> pushed_ids_from_me
3225         (pushed_ids[procup]\&.begin(), pushed_ids[procup]\&.end());
3226       std::vector<dof_id_type> pushed_ids_to_me;
3227       std::vector<std::vector<dof_id_type> > pushed_keys_to_me;
3228       std::vector<std::vector<Real> > pushed_vals_to_me;
3229       std::vector<Number> pushed_rhss_to_me;
3230       this->comm()\&.send_receive(procup, pushed_ids_from_me,
3231                                 procdown, pushed_ids_to_me);
3232       this->comm()\&.send_receive(procup, pushed_keys,
3233                                 procdown, pushed_keys_to_me);
3234       this->comm()\&.send_receive(procup, pushed_vals,
3235                                 procdown, pushed_vals_to_me);
3236       this->comm()\&.send_receive(procup, pushed_rhss,
3237                                 procdown, pushed_rhss_to_me);
3238       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_keys_to_me\&.size());
3239       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_vals_to_me\&.size());
3240       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_rhss_to_me\&.size());
3241 
3242 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3243       // Trade pushed node constraint rows
3244       std::vector<dof_id_type> pushed_node_ids_from_me
3245         (pushed_node_ids[procup]\&.begin(), pushed_node_ids[procup]\&.end());
3246       std::vector<dof_id_type> pushed_node_ids_to_me;
3247       std::vector<std::vector<dof_id_type> > pushed_node_keys_to_me;
3248       std::vector<std::vector<Real> > pushed_node_vals_to_me;
3249       std::vector<Point> pushed_node_offsets_to_me;
3250       this->comm()\&.send_receive(procup, pushed_node_ids_from_me,
3251                                 procdown, pushed_node_ids_to_me);
3252       this->comm()\&.send_receive(procup, pushed_node_keys,
3253                                 procdown, pushed_node_keys_to_me);
3254       this->comm()\&.send_receive(procup, pushed_node_vals,
3255                                 procdown, pushed_node_vals_to_me);
3256       this->comm()\&.send_receive(procup, pushed_node_offsets,
3257                                 procdown, pushed_node_offsets_to_me);
3258 
3259       // Constraining nodes might not even exist on our subset of
3260       // a distributed mesh, so let's make them exist\&.
3261       this->comm()\&.send_receive_packed_range
3262         (procup, &mesh, pushed_nodes\&.begin(), pushed_nodes\&.end(),
3263          procdown, &mesh, mesh_inserter_iterator<Node>(mesh));
3264 
3265       libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_keys_to_me\&.size());
3266       libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_vals_to_me\&.size());
3267       libmesh_assert_equal_to (pushed_node_ids_to_me\&.size(), pushed_node_offsets_to_me\&.size());
3268 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3269 
3270       // Add the dof constraints that I've been sent
3271       for (std::size_t i = 0; i != pushed_ids_to_me\&.size(); ++i)
3272         {
3273           libmesh_assert_equal_to (pushed_keys_to_me[i]\&.size(), pushed_vals_to_me[i]\&.size());
3274 
3275           dof_id_type constrained = pushed_ids_to_me[i];
3276 
3277           // If we don't already have a constraint for this dof,
3278           // add the one we were sent
3279           if (!this->is_constrained_dof(constrained))
3280             {
3281               DofConstraintRow &row = _dof_constraints[constrained];
3282               for (std::size_t j = 0; j != pushed_keys_to_me[i]\&.size(); ++j)
3283                 {
3284                   row[pushed_keys_to_me[i][j]] = pushed_vals_to_me[i][j];
3285                 }
3286               if (pushed_rhss_to_me[i] != Number(0))
3287                 _primal_constraint_values[constrained] = pushed_rhss_to_me[i];
3288               else
3289                 _primal_constraint_values\&.erase(constrained);
3290             }
3291         }
3292 
3293 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
3294       // Add the node constraints that I've been sent
3295       for (std::size_t i = 0; i != pushed_node_ids_to_me\&.size(); ++i)
3296         {
3297           libmesh_assert_equal_to (pushed_node_keys_to_me[i]\&.size(), pushed_node_vals_to_me[i]\&.size());
3298 
3299           dof_id_type constrained_id = pushed_node_ids_to_me[i];
3300 
3301           // If we don't already have a constraint for this node,
3302           // add the one we were sent
3303           const Node *constrained = mesh\&.node_ptr(constrained_id);
3304           if (!this->is_constrained_node(constrained))
3305             {
3306               NodeConstraintRow &row = _node_constraints[constrained]\&.first;
3307               for (std::size_t j = 0; j != pushed_node_keys_to_me[i]\&.size(); ++j)
3308                 {
3309                   const Node *key_node = mesh\&.node_ptr(pushed_node_keys_to_me[i][j]);
3310                   libmesh_assert(key_node);
3311                   row[key_node] = pushed_node_vals_to_me[i][j];
3312                 }
3313               _node_constraints[constrained]\&.second = pushed_node_offsets_to_me[i];
3314             }
3315         }
3316 #endif // LIBMESH_ENABLE_NODE_CONSTRAINTS
3317     }
3318 
3319   // Next we need to push constraints to processors which don't own
3320   // the constrained dof, don't own the constraining dof, but own an
3321   // element supporting the constraining dof\&.
3322   //
3323   // We need to be able to quickly look up constrained dof ids by what
3324   // constrains them, so that we can handle the case where we see a
3325   // foreign element containing one of our constraining DoF ids and we
3326   // need to push that constraint\&.
3327   //
3328   // Getting distributed adaptive sparsity patterns right is hard\&.
3329 
3330   typedef std::map<dof_id_type, std::set<dof_id_type> > DofConstrainsMap;
3331   DofConstrainsMap dof_id_constrains;
3332 
3333   for (DofConstraints::iterator i = _dof_constraints\&.begin();
3334        i != _dof_constraints\&.end(); ++i)
3335     {
3336       const dof_id_type constrained = i->first;
3337       DofConstraintRow &row = i->second;
3338       for (DofConstraintRow::iterator j = row\&.begin();
3339            j != row\&.end(); ++j)
3340         {
3341           const dof_id_type constraining = j->first;
3342 
3343           dof_id_type constraining_proc_id = 0;
3344           while (constraining >= _end_df[constraining_proc_id])
3345             constraining_proc_id++;
3346 
3347           if (constraining_proc_id == this->processor_id())
3348             dof_id_constrains[constraining]\&.insert(constrained);
3349         }
3350     }
3351 
3352   // Loop over all foreign elements, find any supporting our
3353   // constrained dof indices\&.
3354   pushed_ids\&.clear();
3355   pushed_ids\&.resize(this->n_processors());
3356 
3357   MeshBase::const_element_iterator it = mesh\&.active_not_local_elements_begin(),
3358     end = mesh\&.active_not_local_elements_end();
3359   for (; it != end; ++it)
3360     {
3361       const Elem *elem = *it;
3362 
3363       std::vector<dof_id_type> my_dof_indices;
3364       this->dof_indices (elem, my_dof_indices);
3365 
3366       for (std::size_t i=0; i != my_dof_indices\&.size(); ++i)
3367         {
3368           DofConstrainsMap::const_iterator dcmi =
3369             dof_id_constrains\&.find(my_dof_indices[i]);
3370           if (dcmi != dof_id_constrains\&.end())
3371             {
3372               for (DofConstrainsMap::mapped_type::const_iterator mti =
3373                      dcmi->second\&.begin();
3374                    mti != dcmi->second\&.end(); ++mti)
3375                 {
3376                   const dof_id_type constrained = *mti;
3377 
3378                   dof_id_type the_constrained_proc_id = 0;
3379                   while (constrained >= _end_df[the_constrained_proc_id])
3380                     the_constrained_proc_id++;
3381 
3382                   const dof_id_type elemproc = elem->processor_id();
3383                   if (elemproc != the_constrained_proc_id)
3384                     pushed_ids[elemproc]\&.insert(constrained);
3385                 }
3386             }
3387         }
3388     }
3389 
3390   // One last trade of constraint rows
3391   for (processor_id_type p = 0; p != this->n_processors(); ++p)
3392     {
3393       // Push to processor procup while receiving from procdown
3394       processor_id_type procup = (this->processor_id() + p) %
3395         this->n_processors();
3396       processor_id_type procdown = (this->n_processors() +
3397                                     this->processor_id() - p) %
3398         this->n_processors();
3399 
3400       // Pack the dof constraint rows and rhs's to push to procup
3401       const std::size_t pushed_ids_size = pushed_ids[procup]\&.size();
3402       std::vector<std::vector<dof_id_type> > pushed_keys(pushed_ids_size);
3403       std::vector<std::vector<Real> > pushed_vals(pushed_ids_size);
3404       std::vector<Number> pushed_rhss(pushed_ids_size);
3405 
3406       // As long as we're declaring them outside the loop, let's initialize them too!
3407       std::set<dof_id_type>::const_iterator pushed_ids_iter = pushed_ids[procup]\&.begin();
3408       std::size_t push_i = 0;
3409       for ( ; pushed_ids_iter != pushed_ids[procup]\&.end(); ++push_i, ++pushed_ids_iter)
3410         {
3411           const dof_id_type constrained = *pushed_ids_iter;
3412           DofConstraintRow &row = _dof_constraints[constrained];
3413           std::size_t row_size = row\&.size();
3414           pushed_keys[push_i]\&.reserve(row_size);
3415           pushed_vals[push_i]\&.reserve(row_size);
3416           for (DofConstraintRow::iterator j = row\&.begin();
3417                j != row\&.end(); ++j)
3418             {
3419               pushed_keys[push_i]\&.push_back(j->first);
3420               pushed_vals[push_i]\&.push_back(j->second);
3421             }
3422 
3423           DofConstraintValueMap::const_iterator rhsit =
3424             _primal_constraint_values\&.find(constrained);
3425           pushed_rhss[push_i] = (rhsit == _primal_constraint_values\&.end()) ?
3426             0 : rhsit->second;
3427         }
3428 
3429       // Trade pushed dof constraint rows
3430       std::vector<dof_id_type> pushed_ids_from_me
3431         (pushed_ids[procup]\&.begin(), pushed_ids[procup]\&.end());
3432       std::vector<dof_id_type> pushed_ids_to_me;
3433       std::vector<std::vector<dof_id_type> > pushed_keys_to_me;
3434       std::vector<std::vector<Real> > pushed_vals_to_me;
3435       std::vector<Number> pushed_rhss_to_me;
3436       this->comm()\&.send_receive(procup, pushed_ids_from_me,
3437                                 procdown, pushed_ids_to_me);
3438       this->comm()\&.send_receive(procup, pushed_keys,
3439                                 procdown, pushed_keys_to_me);
3440       this->comm()\&.send_receive(procup, pushed_vals,
3441                                 procdown, pushed_vals_to_me);
3442       this->comm()\&.send_receive(procup, pushed_rhss,
3443                                 procdown, pushed_rhss_to_me);
3444       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_keys_to_me\&.size());
3445       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_vals_to_me\&.size());
3446       libmesh_assert_equal_to (pushed_ids_to_me\&.size(), pushed_rhss_to_me\&.size());
3447 
3448       // Add the dof constraints that I've been sent
3449       for (std::size_t i = 0; i != pushed_ids_to_me\&.size(); ++i)
3450         {
3451           libmesh_assert_equal_to (pushed_keys_to_me[i]\&.size(), pushed_vals_to_me[i]\&.size());
3452 
3453           dof_id_type constrained = pushed_ids_to_me[i];
3454 
3455           // If we don't already have a constraint for this dof,
3456           // add the one we were sent
3457           if (!this->is_constrained_dof(constrained))
3458             {
3459               DofConstraintRow &row = _dof_constraints[constrained];
3460               for (std::size_t j = 0; j != pushed_keys_to_me[i]\&.size(); ++j)
3461                 {
3462                   row[pushed_keys_to_me[i][j]] = pushed_vals_to_me[i][j];
3463                 }
3464 
3465               if (pushed_rhss_to_me[i] != Number(0))
3466                 _primal_constraint_values[constrained] = pushed_rhss_to_me[i];
3467               else
3468                 _primal_constraint_values\&.erase(constrained);
3469             }
3470         }
3471     }
3472 }
.fi
.SS "template<typename iterator_type > void libMesh::DofMap::set_nonlocal_dof_objects (iterator_typeobjects_begin, iterator_typeobjects_end, \fBMeshBase\fP &mesh, \fBdofobject_accessor\fPobjects)\fC [private]\fP"
Helper function for distributing dofs in parallel 
.PP
Definition at line 284 of file dof_map\&.C\&.
.PP
References libMesh::Parallel::Communicator::allgather(), libMesh::ParallelObject::comm(), libMesh::DofObject::dof_number(), libMesh::DofObject::id(), libMesh::DofObject::invalid_id, libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::ParallelObject::n_processors(), libMesh::DofObject::n_var_groups(), n_variable_groups(), libMesh::DofObject::n_vars(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Parallel::Communicator::send_receive(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_vg_dof_base(), sys_number(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by distribute_dofs()\&.
.PP
.nf
288 {
289   // This function must be run on all processors at once
290   parallel_object_only();
291 
292   // First, iterate over local objects to find out how many
293   // are on each processor
294   std::vector<dof_id_type>
295     ghost_objects_from_proc(this->n_processors(), 0);
296 
297   iterator_type it  = objects_begin;
298 
299   for (; it != objects_end; ++it)
300     {
301       DofObject *obj = *it;
302 
303       if (obj)
304         {
305           processor_id_type obj_procid = obj->processor_id();
306           // We'd better be completely partitioned by now
307           libmesh_assert_not_equal_to (obj_procid, DofObject::invalid_processor_id);
308           ghost_objects_from_proc[obj_procid]++;
309         }
310     }
311 
312   std::vector<dof_id_type> objects_on_proc(this->n_processors(), 0);
313   this->comm()\&.allgather(ghost_objects_from_proc[this->processor_id()],
314                          objects_on_proc);
315 
316 #ifdef DEBUG
317   for (processor_id_type p=0; p != this->n_processors(); ++p)
318     libmesh_assert_less_equal (ghost_objects_from_proc[p], objects_on_proc[p]);
319 #endif
320 
321   // Request sets to send to each processor
322   std::vector<std::vector<dof_id_type> >
323     requested_ids(this->n_processors());
324 
325   // We know how many of our objects live on each processor, so
326   // reserve() space for requests from each\&.
327   for (processor_id_type p=0; p != this->n_processors(); ++p)
328     if (p != this->processor_id())
329       requested_ids[p]\&.reserve(ghost_objects_from_proc[p]);
330 
331   for (it = objects_begin; it != objects_end; ++it)
332     {
333       DofObject *obj = *it;
334       if (obj->processor_id() != DofObject::invalid_processor_id)
335         requested_ids[obj->processor_id()]\&.push_back(obj->id());
336     }
337 #ifdef DEBUG
338   for (processor_id_type p=0; p != this->n_processors(); ++p)
339     libmesh_assert_equal_to (requested_ids[p]\&.size(), ghost_objects_from_proc[p]);
340 #endif
341 
342   // Next set ghost object n_comps from other processors
343   for (processor_id_type p=1; p != this->n_processors(); ++p)
344     {
345       // Trade my requests with processor procup and procdown
346       processor_id_type procup = (this->processor_id() + p) %
347         this->n_processors();
348       processor_id_type procdown = (this->n_processors() +
349                                     this->processor_id() - p) %
350         this->n_processors();
351       std::vector<dof_id_type> request_to_fill;
352       this->comm()\&.send_receive(procup, requested_ids[procup],
353                                 procdown, request_to_fill);
354 
355       // Fill those requests
356       const unsigned int
357         sys_num      = this->sys_number(),
358         n_var_groups = this->n_variable_groups();
359 
360       std::vector<dof_id_type> ghost_data
361         (request_to_fill\&.size() * 2 * n_var_groups);
362 
363       for (std::size_t i=0; i != request_to_fill\&.size(); ++i)
364         {
365           DofObject *requested = (this->*objects)(mesh, request_to_fill[i]);
366           libmesh_assert(requested);
367           libmesh_assert_equal_to (requested->processor_id(), this->processor_id());
368           libmesh_assert_equal_to (requested->n_var_groups(sys_num), n_var_groups);
369           for (unsigned int vg=0; vg != n_var_groups; ++vg)
370             {
371               unsigned int n_comp_g =
372                 requested->n_comp_group(sys_num, vg);
373               ghost_data[i*2*n_var_groups+vg] = n_comp_g;
374               dof_id_type my_first_dof = n_comp_g ?
375                 requested->vg_dof_base(sys_num, vg) : 0;
376               libmesh_assert_not_equal_to (my_first_dof, DofObject::invalid_id);
377               ghost_data[i*2*n_var_groups+n_var_groups+vg] = my_first_dof;
378             }
379         }
380 
381       // Trade back the results
382       std::vector<dof_id_type> filled_request;
383       this->comm()\&.send_receive(procdown, ghost_data,
384                                 procup, filled_request);
385 
386       // And copy the id changes we've now been informed of
387       libmesh_assert_equal_to (filled_request\&.size(),
388                                requested_ids[procup]\&.size() * 2 * n_var_groups);
389       for (std::size_t i=0; i != requested_ids[procup]\&.size(); ++i)
390         {
391           DofObject *requested = (this->*objects)(mesh, requested_ids[procup][i]);
392           libmesh_assert(requested);
393           libmesh_assert_equal_to (requested->processor_id(), procup);
394           for (unsigned int vg=0; vg != n_var_groups; ++vg)
395             {
396               unsigned int n_comp_g =
397                 libmesh_cast_int<unsigned int>(filled_request[i*2*n_var_groups+vg]);
398               requested->set_n_comp_group(sys_num, vg, n_comp_g);
399               if (n_comp_g)
400                 {
401                   dof_id_type my_first_dof =
402                     filled_request[i*2*n_var_groups+n_var_groups+vg];
403                   libmesh_assert_not_equal_to (my_first_dof, DofObject::invalid_id);
404                   requested->set_vg_dof_base
405                     (sys_num, vg, my_first_dof);
406                 }
407             }
408         }
409     }
410 
411 #ifdef DEBUG
412   // Double check for invalid dofs
413   for (it = objects_begin; it != objects_end; ++it)
414     {
415       DofObject *obj = *it;
416       libmesh_assert (obj);
417       unsigned int num_variables = obj->n_vars(this->sys_number());
418       for (unsigned int v=0; v != num_variables; ++v)
419         {
420           unsigned int n_comp =
421             obj->n_comp(this->sys_number(), v);
422           dof_id_type my_first_dof = n_comp ?
423             obj->dof_number(this->sys_number(), v, 0) : 0;
424           libmesh_assert_not_equal_to (my_first_dof, DofObject::invalid_id);
425         }
426     }
427 #endif
428 }
.fi
.SS "unsigned int libMesh::DofMap::sys_number () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of the system we are responsible for\&. 
.RE
.PP

.PP
Definition at line 1375 of file dof_map\&.h\&.
.PP
References _sys_number\&.
.PP
Referenced by _dof_indices(), add_neighbors_to_send_list(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), distribute_dofs(), distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), invalidate_dofs(), local_variable_indices(), old_dof_indices(), reinit(), and set_nonlocal_dof_objects()\&.
.PP
.nf
1376 {
1377   return _sys_number;
1378 }
.fi
.SS "bool libMesh::DofMap::use_coupled_neighbor_dofs (const \fBMeshBase\fP &mesh) const"
Tells other library functions whether or not this problem includes coupling between dofs in neighboring cells, as can currently be specified on the command line or inferred from the use of all discontinuous variables\&. 
.PP
Definition at line 1556 of file dof_map\&.C\&.
.PP
References libMesh::FEAbstract::build(), libMesh::command_line_next(), libMesh::DISCONTINUOUS, libMesh::MeshBase::mesh_dimension(), n_variables(), libMesh::on_command_line(), and variable_type()\&.
.PP
.nf
1557 {
1558   // If we were asked on the command line, then we need to
1559   // include sensitivities between neighbor degrees of freedom
1560   bool implicit_neighbor_dofs =
1561     libMesh::on_command_line ("--implicit_neighbor_dofs");
1562 
1563   // If the user specifies --implicit_neighbor_dofs 0, then
1564   // presumably he knows what he is doing and we won't try to
1565   // automatically turn it on even when all the variables are
1566   // discontinuous\&.
1567   if (implicit_neighbor_dofs)
1568     {
1569       // No flag provided defaults to 'true'
1570       int flag = 1;
1571       flag = libMesh::command_line_next ("--implicit_neighbor_dofs", flag);
1572 
1573       if (!flag)
1574         {
1575           // The user said --implicit_neighbor_dofs 0, so he knows
1576           // what he is doing and really doesn't want it\&.
1577           return false;
1578         }
1579     }
1580 
1581   // look at all the variables in this system\&.  If every one is
1582   // discontinuous then the user must be doing DG/FVM, so be nice
1583   // and  force implicit_neighbor_dofs=true
1584   {
1585     bool all_discontinuous_dofs = true;
1586 
1587     for (unsigned int var=0; var<this->n_variables(); var++)
1588       if (FEAbstract::build (mesh\&.mesh_dimension(),
1589                              this->variable_type(var))->get_continuity() !=  DISCONTINUOUS)
1590         all_discontinuous_dofs = false;
1591 
1592     if (all_discontinuous_dofs)
1593       implicit_neighbor_dofs = true;
1594   }
1595 
1596   return implicit_neighbor_dofs;
1597 }
.fi
.SS "const \fBVariable\fP & libMesh::DofMap::variable (const unsigned intc) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the variable description object for variable \fCc\fP\&. 
.RE
.PP

.PP
Definition at line 1393 of file dof_map\&.h\&.
.PP
References _variables\&.
.PP
Referenced by _dof_indices(), DMLibMeshSetSystem(), dof_indices(), old_dof_indices(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), and SCALAR_dof_indices()\&.
.PP
.nf
1394 {
1395   libmesh_assert_less (c, _variables\&.size());
1396 
1397   return _variables[c];
1398 }
.fi
.SS "const \fBVariableGroup\fP & libMesh::DofMap::variable_group (const unsigned intc) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fC\fBVariableGroup\fP\fP description object for group \fCg\fP\&. 
.RE
.PP

.PP
Definition at line 1383 of file dof_map\&.h\&.
.PP
References _variable_groups\&.
.PP
Referenced by distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), libMesh::System::get_info(), and reinit()\&.
.PP
.nf
1384 {
1385   libmesh_assert_less (g, _variable_groups\&.size());
1386 
1387   return _variable_groups[g];
1388 }
.fi
.SS "\fBOrder\fP libMesh::DofMap::variable_group_order (const unsigned intvg) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order for \fC\fBVariableGroup\fP\fP \fCvg\fP\&. 
.RE
.PP

.PP
Definition at line 1413 of file dof_map\&.h\&.
.PP
References _variable_groups\&.
.PP
.nf
1414 {
1415   libmesh_assert_less (vg, _variable_groups\&.size());
1416 
1417   return _variable_groups[vg]\&.type()\&.order;
1418 }
.fi
.SS "const \fBFEType\fP & libMesh::DofMap::variable_group_type (const unsigned intvg) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type for \fC\fBVariableGroup\fP\fP \fCvg\fP\&. 
.RE
.PP

.PP
Definition at line 1433 of file dof_map\&.h\&.
.PP
References _variable_groups\&.
.PP
.nf
1434 {
1435   libmesh_assert_less (vg, _variable_groups\&.size());
1436 
1437   return _variable_groups[vg]\&.type();
1438 }
.fi
.SS "\fBOrder\fP libMesh::DofMap::variable_order (const unsigned intc) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order for variable \fCc\fP\&. 
.RE
.PP

.PP
Definition at line 1403 of file dof_map\&.h\&.
.PP
References _variables\&.
.PP
.nf
1404 {
1405   libmesh_assert_less (c, _variables\&.size());
1406 
1407   return _variables[c]\&.type()\&.order;
1408 }
.fi
.SS "const \fBFEType\fP & libMesh::DofMap::variable_type (const unsigned intc) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type for variable \fCc\fP\&. 
.RE
.PP

.PP
Definition at line 1423 of file dof_map\&.h\&.
.PP
References _variables\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), _dof_indices(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::System::calculate_norm(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEInterface::compute_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), dof_indices(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::for(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), local_variable_indices(), old_dof_indices(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::HPCoarsenTest::select_refinement(), and use_coupled_neighbor_dofs()\&.
.PP
.nf
1424 {
1425   libmesh_assert_less (c, _variables\&.size());
1426 
1427   return _variables[c]\&.type();
1428 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBSparsityPattern::Build\fP\fC [friend]\fP"

.PP
Definition at line 1368 of file dof_map\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBAdjointDofConstraintValues\fP libMesh::DofMap::_adjoint_constraint_values\fC [private]\fP"

.PP
Definition at line 1335 of file dof_map\&.h\&.
.PP
Referenced by clear(), and has_heterogenous_adjoint_constraint()\&.
.SS "std::vector<\fBDirichletBoundaries\fP *> libMesh::DofMap::_adjoint_dirichlet_boundaries\fC [private]\fP"
Data structure containing Dirichlet functions\&. The ith entry is the constraint matrix row for boundaryid i\&. 
.PP
Definition at line 1365 of file dof_map\&.h\&.
.PP
Referenced by DofMap()\&.
.SS "\fBAugmentSendList\fP* libMesh::DofMap::_augment_send_list\fC [private]\fP"
Function object to call to add extra entries to the send list 
.PP
Definition at line 1258 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_send_list_object(), and prepare_send_list()\&.
.SS "\fBAugmentSparsityPattern\fP* libMesh::DofMap::_augment_sparsity_pattern\fC [private]\fP"
Funtion object to call to add extra entries to the sparsity pattern 
.PP
Definition at line 1241 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_sparsity_object()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBDirichletBoundaries\fP* libMesh::DofMap::_dirichlet_boundaries\fC [private]\fP"
Data structure containing Dirichlet functions\&. The ith entry is the constraint matrix row for boundaryid i\&. 
.PP
Definition at line 1359 of file dof_map\&.h\&.
.PP
Referenced by DofMap(), and get_dirichlet_boundaries()\&.
.SS "\fBDofConstraints\fP libMesh::DofMap::_dof_constraints\fC [private]\fP"
Data structure containing DOF constraints\&. The ith entry is the constraint matrix row for DOF i\&. 
.PP
Definition at line 1331 of file dof_map\&.h\&.
.PP
Referenced by clear(), constraint_rows_begin(), constraint_rows_end(), find_connected_dofs(), and is_constrained_dof()\&.
.SS "\fBCouplingMatrix\fP* libMesh::DofMap::_dof_coupling"
Degree of freedom coupling\&. If left empty each DOF couples to all others\&. Can be used to reduce memory requirements for sparse matrices\&. DOF 0 might only couple to itself, in which case \fCdof_coupling(0,0)\fP should be 1 and \fCdof_coupling(0,j)\fP = 0 for j not equal to 0\&.
.PP
This variable is named as though it were class private, but it is in the public interface\&. Also there are no public methods for accessing it\&.\&.\&. This typically means you should only use it if you know what you are doing\&. 
.PP
Definition at line 1051 of file dof_map\&.h\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::DofMap::_end_df\fC [private]\fP"
Last DOF index (plus 1) on processor \fCp\fP\&. 
.PP
Definition at line 1230 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), end_dof(), last_dof(), and n_dofs_on_processor()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::DofMap::_end_old_df\fC [private]\fP"
Last old DOF index (plus 1) on processor \fCp\fP\&. 
.PP
Definition at line 1322 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), and end_old_dof()\&.
.SS "void* libMesh::DofMap::_extra_send_list_context\fC [private]\fP"
A pointer associcated with the extra send list that can optionally be passed in 
.PP
Definition at line 1268 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_send_list_function(), and prepare_send_list()\&.
.SS "void(* libMesh::DofMap::_extra_send_list_function)(std::vector< \fBdof_id_type\fP > &, void *)\fC [private]\fP"
A function pointer to a function to call to add extra entries to the send list 
.PP
Definition at line 1263 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_send_list_function(), and prepare_send_list()\&.
.SS "void* libMesh::DofMap::_extra_sparsity_context\fC [private]\fP"
A pointer associcated with the extra sparsity that can optionally be passed in 
.PP
Definition at line 1253 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_sparsity_function()\&.
.SS "void(* libMesh::DofMap::_extra_sparsity_function)(\fBSparsityPattern::Graph\fP &, std::vector< \fBdof_id_type\fP > &n_nz, std::vector< \fBdof_id_type\fP > &n_oz, void *)\fC [private]\fP"
A function pointer to a function to call to add extra entries to the sparsity pattern 
.PP
Definition at line 1246 of file dof_map\&.h\&.
.PP
Referenced by attach_extra_sparsity_function()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::DofMap::_first_df\fC [private]\fP"
First DOF index on processor \fCp\fP\&. 
.PP
Definition at line 1225 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), first_dof(), and n_dofs_on_processor()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::DofMap::_first_old_df\fC [private]\fP"
First old DOF index on processor \fCp\fP\&. 
.PP
Definition at line 1317 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), and first_old_dof()\&.
.SS "std::vector<\fBSparseMatrix\fP<\fBNumber\fP>* > libMesh::DofMap::_matrices\fC [private]\fP"
Additional matrices handled by this object\&. These pointers do \fInot\fP handle the memory, instead, \fC\fBSystem\fP\fP, who told \fC\fBDofMap\fP\fP about them, owns them\&. 
.PP
Definition at line 1220 of file dof_map\&.h\&.
.PP
Referenced by attach_matrix(), clear(), compute_sparsity(), and is_attached()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBdof_id_type\fP libMesh::DofMap::_n_dfs\fC [private]\fP"
Total number of degrees of freedom\&. 
.PP
Definition at line 1299 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), and n_dofs()\&.
.SS "std::vector<\fBdof_id_type\fP>* libMesh::DofMap::_n_nz\fC [private]\fP"
The number of on-processor nonzeros in my portion of the global matrix\&. If need_full_sparsity_pattern is true, this will just be a pointer into the corresponding sparsity pattern vector\&. Otherwise we have to new/delete it ourselves\&. 
.PP
Definition at line 1288 of file dof_map\&.h\&.
.PP
Referenced by attach_matrix(), clear_sparsity(), compute_sparsity(), and get_n_nz()\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBdof_id_type\fP libMesh::DofMap::_n_old_dfs\fC [private]\fP"
Total number of degrees of freedom on old dof objects 
.PP
Definition at line 1312 of file dof_map\&.h\&.
.PP
Referenced by clear(), distribute_dofs(), and n_old_dofs()\&.
.SS "std::vector<\fBdof_id_type\fP>* libMesh::DofMap::_n_oz\fC [private]\fP"
The number of off-processor nonzeros in my portion of the global matrix; allocated similar to _n_nz\&. 
.PP
Definition at line 1294 of file dof_map\&.h\&.
.PP
Referenced by attach_matrix(), clear_sparsity(), compute_sparsity(), and get_n_oz()\&.
.SS "\fBdof_id_type\fP libMesh::DofMap::_n_SCALAR_dofs\fC [private]\fP"
The total number of SCALAR dofs associated to all SCALAR variables\&. 
.PP
Definition at line 1305 of file dof_map\&.h\&.
.PP
Referenced by distribute_local_dofs_node_major(), distribute_local_dofs_var_major(), n_SCALAR_dofs(), and reinit()\&.
.SS "\fBNodeConstraints\fP libMesh::DofMap::_node_constraints\fC [private]\fP"
Data structure containing \fBDofObject\fP constraints\&. 
.PP
Definition at line 1342 of file dof_map\&.h\&.
.PP
Referenced by is_constrained_node(), n_constrained_nodes(), node_constraint_rows_begin(), and node_constraint_rows_end()\&.
.SS "\fBPeriodicBoundaries\fP* libMesh::DofMap::_periodic_boundaries\fC [private]\fP"
Data structure containing periodic boundaries\&. The ith entry is the constraint matrix row for boundaryid i\&. 
.PP
Definition at line 1351 of file dof_map\&.h\&.
.PP
Referenced by DofMap(), get_periodic_boundaries(), and is_periodic_boundary()\&.
.SS "\fBDofConstraintValueMap\fP libMesh::DofMap::_primal_constraint_values\fC [private]\fP"

.PP
Definition at line 1333 of file dof_map\&.h\&.
.PP
Referenced by clear()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::DofMap::_send_list\fC [private]\fP"
A list containing all the global DOF indicies that affect the solution on my subdomain\&. 
.PP
Definition at line 1236 of file dof_map\&.h\&.
.PP
Referenced by add_neighbors_to_send_list(), all_semilocal_indices(), clear(), distribute_dofs(), get_send_list(), and prepare_send_list()\&.
.SS "\fBAutoPtr\fP<\fBSparsityPattern::Build\fP> libMesh::DofMap::_sp\fC [private]\fP"
The sparsity pattern of the global matrix, kept around if it might be needed by future additions of the same type of matrix\&. 
.PP
Definition at line 1280 of file dof_map\&.h\&.
.PP
Referenced by attach_matrix(), clear_sparsity(), and compute_sparsity()\&.
.SS "const unsigned int libMesh::DofMap::_sys_number\fC [private]\fP"
The number of the system we manage DOFs for\&. 
.PP
Definition at line 1213 of file dof_map\&.h\&.
.PP
Referenced by sys_number()\&.
.SS "std::vector<\fBVariableGroup\fP> libMesh::DofMap::_variable_groups\fC [private]\fP"
The finite element type for each variable\&. 
.PP
Definition at line 1208 of file dof_map\&.h\&.
.PP
Referenced by add_variable_group(), clear(), n_variable_groups(), variable_group(), variable_group_order(), and variable_group_type()\&.
.SS "std::vector<\fBVariable\fP> libMesh::DofMap::_variables\fC [private]\fP"
The finite element type for each variable\&. 
.PP
Definition at line 1203 of file dof_map\&.h\&.
.PP
Referenced by add_variable_group(), clear(), n_variables(), variable(), variable_order(), and variable_type()\&.
.SS "bool libMesh::DofMap::need_full_sparsity_pattern\fC [private]\fP"
Default false; set to true if any attached matrix requires a full sparsity pattern\&. 
.PP
Definition at line 1274 of file dof_map\&.h\&.
.PP
Referenced by attach_matrix(), clear(), clear_sparsity(), and compute_sparsity()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
