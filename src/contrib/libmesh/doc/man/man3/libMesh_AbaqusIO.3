.TH "libMesh::AbaqusIO" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::AbaqusIO \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <abaqus_io\&.h>\fP
.PP
Inherits \fBlibMesh::MeshInput< MeshBase >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAbaqusIO\fP (\fBMeshBase\fP &\fBmesh\fP)"
.br
.ti -1c
.RI "virtual \fB~AbaqusIO\fP ()"
.br
.ti -1c
.RI "virtual void \fBread\fP (const std::string &name)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBbuild_sidesets_from_nodesets\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBMeshBase\fP & \fBmesh\fP ()"
.br
.ti -1c
.RI "void \fBskip_comment_lines\fP (std::istream &in, const char comment_start)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< bool > \fBelems_of_dimension\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::vector< \fBdof_id_type\fP > > \fBcontainer_t\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::vector< std::pair
.br
< \fBdof_id_type\fP, unsigned > > > \fBsideset_container_t\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBread_nodes\fP ()"
.br
.ti -1c
.RI "void \fBread_elements\fP (std::string upper)"
.br
.ti -1c
.RI "std::string \fBparse_label\fP (std::string line, std::string label_name)"
.br
.ti -1c
.RI "void \fBread_ids\fP (std::string set_name, \fBcontainer_t\fP &container)"
.br
.ti -1c
.RI "void \fBassign_subdomain_ids\fP ()"
.br
.ti -1c
.RI "void \fBread_sideset\fP (std::string sideset_name, \fBsideset_container_t\fP &container)"
.br
.ti -1c
.RI "void \fBassign_boundary_node_ids\fP ()"
.br
.ti -1c
.RI "void \fBassign_sideset_ids\fP ()"
.br
.ti -1c
.RI "void \fBprocess_and_discard_comments\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBcontainer_t\fP \fB_nodeset_ids\fP"
.br
.ti -1c
.RI "\fBcontainer_t\fP \fB_elemset_ids\fP"
.br
.ti -1c
.RI "\fBsideset_container_t\fP \fB_sideset_ids\fP"
.br
.ti -1c
.RI "std::ifstream \fB_in\fP"
.br
.ti -1c
.RI "std::set< \fBElemType\fP > \fB_elem_types\fP"
.br
.ti -1c
.RI "std::map< \fBdof_id_type\fP, 
.br
\fBdof_id_type\fP > \fB_abaqus_to_libmesh_elem_mapping\fP"
.br
.ti -1c
.RI "std::map< \fBdof_id_type\fP, 
.br
\fBdof_id_type\fP > \fB_abaqus_to_libmesh_node_mapping\fP"
.br
.ti -1c
.RI "bool \fB_already_seen_part\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBAbaqusIO\fP class is a preliminary implementation for reading Abaqus mesh files in ASCII format\&.
.PP
\fBAuthor:\fP
.RS 4
John W\&. Peterson, 2011\&. 
.RE
.PP

.PP
Definition at line 38 of file abaqus_io\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::vector<\fBdof_id_type\fP> > \fBlibMesh::AbaqusIO::container_t\fP\fC [private]\fP"
The type of data structure used to store \fBNode\fP and Elemset IDs\&. 
.PP
Definition at line 68 of file abaqus_io\&.h\&.
.SS "typedef std::map<std::string, std::vector<std::pair<\fBdof_id_type\fP, unsigned> > > \fBlibMesh::AbaqusIO::sideset_container_t\fP\fC [private]\fP"
Type of the data structure for storing the (elem ID, side) pairs defining sidesets\&. These come from the *Surface sections of the input file\&. 
.PP
Definition at line 75 of file abaqus_io\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::AbaqusIO::AbaqusIO (\fBMeshBase\fP &mesh)\fC [explicit]\fP"
Constructor\&. Takes a writeable reference to a mesh object\&. 
.PP
Definition at line 170 of file abaqus_io\&.C\&.
.PP
.nf
170                                      :
171   MeshInput<MeshBase> (mesh_in),
172   build_sidesets_from_nodesets(false),
173   _already_seen_part(false)
174 {
175 }
.fi
.SS "libMesh::AbaqusIO::~AbaqusIO ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 180 of file abaqus_io\&.C\&.
.PP
.nf
181 {
182 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::AbaqusIO::assign_boundary_node_ids ()\fC [private]\fP"
This function assigns boundary IDs to node sets based on the alphabetical order in which the sets are labelled in the Abaqus file\&. We choose the alphabetical ordering simply because Abaqus does not provide a numerical one within the file\&. 
.PP
Definition at line 822 of file abaqus_io\&.C\&.
.PP
References _abaqus_to_libmesh_node_mapping, _nodeset_ids, libMesh::MeshBase::boundary_info, libMesh::MeshInput< MT >::mesh(), libMesh::MeshBase::node_ptr(), and libMesh::out\&.
.PP
Referenced by read()\&.
.PP
.nf
823 {
824   // Get a reference to the mesh we are reading
825   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
826 
827   // Iterate over the container of nodesets
828   container_t::iterator it=_nodeset_ids\&.begin();
829   for (unsigned current_id=0; it != _nodeset_ids\&.end(); ++it, ++current_id)
830     {
831       libMesh::out << "Assigning node boundary ID " << current_id << " to nodeset '"
832                    << (*it)\&.first
833                    << "'\&." << std::endl;
834 
835       // Get a reference to the current vector of nodeset ID values
836       std::vector<dof_id_type>& nodeset_ids = (*it)\&.second;
837 
838       for (std::size_t i=0; i<nodeset_ids\&.size(); ++i)
839         {
840           // Map the Abaqus global node ID to the libmesh node ID
841           dof_id_type libmesh_global_node_id = _abaqus_to_libmesh_node_mapping[nodeset_ids[i]];
842 
843           // Get node pointer from the mesh
844           Node* node = the_mesh\&.node_ptr(libmesh_global_node_id);
845 
846           if (node == NULL)
847             libmesh_error_msg("Error! Mesh returned NULL node pointer!");
848 
849           // Add this node with the current_id (which is determined by the
850           // alphabetical ordering of the map) to the BoundaryInfo object
851           the_mesh\&.boundary_info->add_node(node, current_id);
852         }
853     }
854 
855 } // assign_boundary_node_ids()
.fi
.SS "void libMesh::AbaqusIO::assign_sideset_ids ()\fC [private]\fP"
Called at the end of the \fBread()\fP function, assigns any sideset IDs found when reading the file to the \fBBoundaryInfo\fP object\&. 
.PP
Definition at line 860 of file abaqus_io\&.C\&.
.PP
References _abaqus_to_libmesh_elem_mapping, _sideset_ids, libMesh::MeshBase::boundary_info, libMesh::MeshBase::elem(), libMesh::Utility::enum_to_string(), libMesh::MeshInput< MT >::mesh(), libMesh::out, and libMesh::Elem::type()\&.
.PP
Referenced by read()\&.
.PP
.nf
861 {
862   // Get a reference to the mesh we are reading
863   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
864 
865   // initialize the eletypes map (eletypes is a file-global variable)
866   init_eletypes();
867 
868   // Iterate over the container of sidesets
869   sideset_container_t::iterator it=_sideset_ids\&.begin();
870   for (unsigned current_id=0; it != _sideset_ids\&.end(); ++it, ++current_id)
871     {
872       libMesh::out << "Assigning sideset ID " << current_id << " to sideset '"
873                    << (*it)\&.first
874                    << "'\&." << std::endl;
875 
876       // Get a reference to the current vector of nodeset ID values
877       std::vector<std::pair<dof_id_type,unsigned> >& sideset_ids = (*it)\&.second;
878 
879       for (std::size_t i=0; i<sideset_ids\&.size(); ++i)
880         {
881           // sideset_ids is a vector of pairs (elem id, side id)\&.  Pull them out
882           // now to make the code below more readable\&.
883           dof_id_type  abaqus_elem_id = sideset_ids[i]\&.first;
884           unsigned abaqus_side_number = sideset_ids[i]\&.second;
885 
886           // Map the Abaqus element ID to LibMesh numbering
887           dof_id_type libmesh_elem_id = _abaqus_to_libmesh_elem_mapping[ abaqus_elem_id ];
888 
889           // Get pointer to that element
890           Elem* elem = the_mesh\&.elem(libmesh_elem_id);
891 
892           // Check that the pointer returned from the Mesh is non-NULL
893           if (elem == NULL)
894             libmesh_error_msg("Mesh returned NULL pointer for Elem " << libmesh_elem_id);
895 
896           // Grab a reference to the element definition for this element type
897           const ElementDefinition& eledef = eletypes[elem->type()];
898 
899           // If the element definition was not found, the call above would have
900           // created one with an uninitialized struct\&.  Check for that here\&.\&.\&.
901           if (eledef\&.abaqus_zero_based_side_id_to_libmesh_side_id\&.size() == 0)
902             libmesh_error_msg("No Abaqus->LibMesh mapping information for ElemType " \
903                               << Utility::enum_to_string(elem->type())  \
904                               << "!");
905 
906           // Add this node with the current_id (which is determined by the
907           // alphabetical ordering of the map)\&.  Side numbers in Abaqus are 1-based,
908           // so we subtract 1 here before passing the abaqus side number to the
909           // mapping array
910           the_mesh\&.boundary_info->add_side(elem,
911                                            eledef\&.abaqus_zero_based_side_id_to_libmesh_side_id[abaqus_side_number-1],
912                                            current_id);
913         }
914     }
915 } // assign_sideset_ids()
.fi
.SS "void libMesh::AbaqusIO::assign_subdomain_ids ()\fC [private]\fP"
This function is called after all the elements have been read and assigns element subdomain IDs\&.
.PP
The IDs are simply chosen in the order in which the elset labels are stored in the map (roughly alphabetically)\&. To make this easy on people who are planning to use Exodus output, we'll assign different geometric elements to different (but related) subdomains, i\&.e\&. assuming there are E elemsets:
.PP
Elemset 0, Geometric Type 0: ID 0 Elemset 0, Geometric Type 1: ID 0+E \&.\&.\&. 
.SS "Elemset 0, Geometric Type N: ID 0+N*E "
.PP
Elemset 1, Geometric Type 0: ID 1 Elemset 1, Geometric Type 1: ID 1+E \&.\&.\&. Elemset 1, Geometric Type N: ID 1+N*E etc\&. 
.PP
Definition at line 770 of file abaqus_io\&.C\&.
.PP
References _abaqus_to_libmesh_elem_mapping, _elem_types, _elemset_ids, libMesh::MeshBase::elem(), libMesh::MeshInput< MT >::mesh(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by read()\&.
.PP
.nf
771 {
772   // Get a reference to the mesh we are reading
773   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
774 
775   // The number of elemsets we've found while reading
776   std::size_t n_elemsets = _elemset_ids\&.size();
777 
778   // Fill in a temporary map with (ElemType, index) pairs based on the _elem_types set\&.  This
779   // will allow us to easily look up this index in the loop below\&.
780   std::map<ElemType, unsigned> elem_types_map;
781   {
782     unsigned ctr=0;
783     for (std::set<ElemType>::iterator it=_elem_types\&.begin(); it!=_elem_types\&.end(); ++it)
784       elem_types_map[*it] = ctr++;
785   }
786 
787   // Loop over each Elemset and assign subdomain IDs to Mesh elements
788   {
789     // The elemset_id counter assigns a logical numbering to the _elemset_ids keys
790     container_t::iterator it=_elemset_ids\&.begin();
791     for (unsigned elemset_id=0; it != _elemset_ids\&.end(); ++it, ++elemset_id)
792       {
793         // Grab a reference to the vector of IDs
794         std::vector<dof_id_type>& id_vector = (*it)\&.second;
795 
796         // Loop over this vector
797         for (std::size_t i=0; i<id_vector\&.size(); ++i)
798           {
799             // Map the id_vector[i]'th element ID (Abaqus numbering) to LibMesh numbering
800             dof_id_type libmesh_elem_id = _abaqus_to_libmesh_elem_mapping[ id_vector[i] ];
801 
802             // Get pointer to that element
803             Elem* elem = the_mesh\&.elem(libmesh_elem_id);
804 
805             if (elem == NULL)
806               libmesh_error_msg("Mesh returned NULL pointer for Elem " << libmesh_elem_id);
807 
808             // Compute the proper subdomain ID, based on the formula in the
809             // documentation for this function\&.
810             subdomain_id_type computed_id = elemset_id + (elem_types_map[elem->type()] * n_elemsets);
811 
812             // Assign this ID to the element in question
813             elem->subdomain_id() = computed_id;
814           }
815       }
816   }
817 } // assign_subdomain_ids()
.fi
.SS "\fBMeshBase\fP & \fBlibMesh::MeshInput\fP< \fBMeshBase\fP  >::mesh ()\fC [protected]\fP, \fC [inherited]\fP"
Returns the object as a writeable reference\&. 
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::VTKIO::cells_to_vtk(), libMesh::TetGenIO::element_in(), libMesh::UNVIO::element_in(), libMesh::UNVIO::element_out(), libMesh::TetGenIO::node_in(), libMesh::UNVIO::node_in(), libMesh::UNVIO::node_out(), libMesh::VTKIO::nodes_to_vtk(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::VTKIO::read(), libMesh::LegacyXdrIO::read_ascii(), libMesh::CheckpointIO::read_bcs(), libMesh::CheckpointIO::read_connectivity(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::CheckpointIO::read_nodes(), libMesh::CheckpointIO::read_nodesets(), libMesh::XdrIO::read_serialized_bcs(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::CheckpointIO::read_subdomain_names(), libMesh::TetGenIO::write(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::CheckpointIO::write_bcs(), libMesh::GMVIO::write_binary(), libMesh::CheckpointIO::write_connectivity(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::UCDIO::write_implementation(), libMesh::UNVIO::write_implementation(), libMesh::GmshIO::write_mesh(), libMesh::UCDIO::write_nodal_data(), libMesh::VTKIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::CheckpointIO::write_nodes(), libMesh::CheckpointIO::write_nodesets(), libMesh::XdrIO::write_parallel(), libMesh::GmshIO::write_post(), libMesh::XdrIO::write_serialized_bcs(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), and libMesh::CheckpointIO::write_subdomain_names()\&.
.SS "std::string libMesh::AbaqusIO::parse_label (std::stringline, std::stringlabel_name)\fC [private]\fP"
This function parses a label of the form foo=bar from a comma-delimited line of the form \&.\&.\&., foo=bar, \&.\&.\&. The input to the function in this case would be foo, the output would be bar 
.PP
Definition at line 650 of file abaqus_io\&.C\&.
.PP
References end\&.
.PP
Referenced by read(), and read_elements()\&.
.PP
.nf
651 {
652   // Do all string comparisons in upper-case
653   std::string upper_line(line), upper_label_name(label_name);
654   std::transform(upper_line\&.begin(), upper_line\&.end(), upper_line\&.begin(), ::toupper);
655   std::transform(upper_label_name\&.begin(), upper_label_name\&.end(), upper_label_name\&.begin(), ::toupper);
656 
657   // Get index of start of "label="
658   size_t label_index = upper_line\&.find(upper_label_name + "=");
659 
660   if (label_index != std::string::npos)
661     {
662       // Location of the first comma following "label="
663       size_t comma_index = upper_line\&.find(",", label_index);
664 
665       // Construct iterators from which to build the sub-string\&.
666       // Note the +1 is to skip past the "=" which follows the label name
667       std::string::iterator
668         beg = line\&.begin() + label_name\&.size() + 1 + label_index,
669         end = (comma_index == std::string::npos) ? line\&.end() : line\&.begin()+comma_index;
670 
671       return std::string(beg, end);
672     }
673 
674   // The label index was not found, return the empty string
675   return std::string("");
676 } // parse_label()
.fi
.SS "void libMesh::AbaqusIO::process_and_discard_comments ()\fC [private]\fP"
Any of the various sections can start with some number of lines of comments, which start with '**'\&. This function discards any lines of comments that it finds from the stream, leaving trailing data intact\&. 
.PP
Definition at line 919 of file abaqus_io\&.C\&.
.PP
References _in\&.
.PP
Referenced by read()\&.
.PP
.nf
920 {
921   std::string dummy;
922   while (true)
923     {
924       // We assume we are at the beginning of a line that may be
925       // comments or may be data\&.  We need to only discard the line if
926       // it begins with **, but we must avoid calling std::getline()
927       // since there's no way to put that back\&.
928       if (_in\&.peek() == '*')
929         {
930           // The first character was a star, so actually read it from the stream\&.
931           _in\&.get();
932 
933           // Peek at the next character\&.\&.\&.
934           if (_in\&.peek() == '*')
935             {
936               // OK, second character was star also, by definition this
937               // line must be a comment!  Read the rest of the line and discard!
938               std::getline(_in, dummy);
939 
940               // Debugging:
941               // libMesh::out << "Read comment line: " << dummy << std::endl;
942             }
943           else
944             {
945               // The second character was _not_ a star, so put back the first star
946               // we pulled out so that the line can be parsed correctly by somebody
947               // else!
948               _in\&.unget();
949 
950               // Finally, break out of the while loop, we are done parsing comments
951               break;
952             }
953         }
954       else
955         {
956           // First character was not *, so this line must be data! Break out of the
957           // while loop!
958           break;
959         }
960     }
961 
962 } // process_and_discard_comments()
.fi
.SS "void libMesh::AbaqusIO::read (const std::string &name)\fC [virtual]\fP"
This method implements reading a mesh from a specified file\&. 
.PP
Implements \fBlibMesh::MeshInput< MeshBase >\fP\&.
.PP
Definition at line 187 of file abaqus_io\&.C\&.
.PP
References _already_seen_part, _elemset_ids, _in, _nodeset_ids, _sideset_ids, assign_boundary_node_ids(), assign_sideset_ids(), assign_subdomain_ids(), libMesh::MeshBase::boundary_info, build_sidesets_from_nodesets, libMesh::MeshBase::clear(), libMesh::libmesh_assert(), libMesh::MeshInput< MT >::mesh(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::out, parse_label(), process_and_discard_comments(), read_elements(), read_ids(), read_nodes(), and read_sideset()\&.
.PP
Referenced by libMesh::UnstructuredMesh::read()\&.
.PP
.nf
188 {
189   // Get a reference to the mesh we are reading
190   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
191 
192   // Clear any existing mesh data
193   the_mesh\&.clear();
194 
195   // Open stream for reading
196   _in\&.open(fname\&.c_str());
197   libmesh_assert(_in\&.good());
198 
199   // Read file line-by-line\&.\&.\&. this is based on a set of different
200   // test input files\&.  I have not looked at the full input file
201   // specs for Abaqus\&.
202   std::string s;
203   while (true)
204     {
205       // Try to read something\&.  This may set EOF!
206       std::getline(_in, s);
207 
208       if (_in)
209         {
210           // Process s\&.\&.\&.
211           //
212           // There are many sections in Abaqus files, we read some
213           // but others are just ignored\&.\&.\&.  Some sections may occur
214           // more than once\&.  For example for a hybrid grid, you
215           // will have multiple *Element sections\&.\&.\&.
216 
217           // Some Abaqus files use all upper-case for section names,
218           // so we will just convert s to uppercase
219           std::string upper(s);
220           std::transform(upper\&.begin(), upper\&.end(), upper\&.begin(), ::toupper);
221 
222           // 0\&.) Look for the "*Part" section
223           if (upper\&.find("*PART") == 0)
224             {
225               // libMesh::out << "Found parts section!" << std::endl;
226 
227               if (_already_seen_part)
228                 libmesh_error_msg("We currently don't support reading Abaqus files with multiple PART sections");
229 
230               _already_seen_part = true;
231             }
232 
233           // 1\&.) Look for the "*Nodes" section
234           if (upper\&.find("*NODE") == 0)
235             {
236               // Process any lines of comments that may be present
237               this->process_and_discard_comments();
238 
239               // Read a block of nodes
240               this->read_nodes();
241             }
242 
243 
244 
245           // 2\&.) Look for the "*Element" section
246           else if (upper\&.find("*ELEMENT,") == 0)
247             {
248               // Process any lines of comments that may be present
249               this->process_and_discard_comments();
250 
251               // Read a block of elements
252               this->read_elements(upper);
253             }
254 
255 
256 
257           // 3\&.) Look for a Nodeset section
258           else if (upper\&.find("*NSET") == 0)
259             {
260               std::string nset_name = this->parse_label(s, "nset");
261 
262               // I haven't seen an unnamed elset yet, but let's detect it
263               // just in case\&.\&.\&.
264               if (nset_name == "")
265                 libmesh_error_msg("Unnamed nset encountered!");
266 
267               // Process any lines of comments that may be present
268               this->process_and_discard_comments();
269 
270               // Read the IDs, storing them in _nodeset_ids
271               this->read_ids(nset_name, _nodeset_ids);
272             } // *Nodeset
273 
274 
275 
276           // 4\&.) Look for an Elset section
277           else if (upper\&.find("*ELSET") == 0)
278             {
279               std::string elset_name = this->parse_label(s, "elset");
280 
281               // I haven't seen an unnamed elset yet, but let's detect it
282               // just in case\&.\&.\&.
283               if (elset_name == "")
284                 libmesh_error_msg("Unnamed elset encountered!");
285 
286               // Debugging
287               // libMesh::out << "Processing ELSET: " << elset_name << std::endl;
288 
289               // Process any lines of comments that may be present
290               this->process_and_discard_comments();
291 
292               // Read the IDs, storing them in _elemset_ids
293               this->read_ids(elset_name, _elemset_ids);
294             } // *Elset
295 
296 
297 
298           // 5\&.) Look for a Surface section\&.  Need to be a little
299           // careful, since there are also "surface interaction"
300           // sections we don't want to read here\&.
301           else if (upper\&.find("*SURFACE,") == 0)
302             {
303               // libMesh::out << "Found SURFACE section: " << s << std::endl;
304 
305               // Get the name from the Name=Foo label\&.  This will be the map key\&.
306               std::string sideset_name = this->parse_label(s, "name");
307 
308               // Print name of section we just found
309               // libMesh::out << "Found surface section named: " << sideset_name << std::endl;
310 
311               // Process any lines of comments that may be present
312               this->process_and_discard_comments();
313 
314               // Read the sideset IDs
315               this->read_sideset(sideset_name, _sideset_ids);
316 
317               // Debugging: print status of most recently read sideset
318               // libMesh::out << "Read " << _sideset_ids[sideset_name]\&.size() << " sides in " << sideset_name << std::endl;
319             }
320 
321           continue;
322         } // if (_in)
323 
324       // If !file, check to see if EOF was set\&.  If so, break out
325       // of while loop\&.
326       if (_in\&.eof())
327         break;
328 
329       // If !in and !in\&.eof(), stream is in a bad state!
330       libmesh_error_msg("Stream is bad! Perhaps the file: " << fname << " does not exist?");
331     } // while
332 
333 
334   //
335   // We've read everything we can from the file at this point\&.  Now
336   // do some more processing\&.
337   //
338   libMesh::out << "Mesh contains "
339                << the_mesh\&.n_elem()
340                << " elements, and "
341                << the_mesh\&.n_nodes()
342                << " nodes\&." << std::endl;
343 
344   // TODO: Remove these or write a function to do it?
345   //    {
346   //      container_t::iterator it=_nodeset_ids\&.begin();
347   //      for (; it != _nodeset_ids\&.end(); ++it)
348   //{
349   //  libMesh::out << "Node set '" << (*it)\&.first << "' contains " << (*it)\&.second\&.size() << " ID(s)\&." << std::endl;
350   //}
351   //    }
352   //
353   //    {
354   //      container_t::iterator it=_elemset_ids\&.begin();
355   //      for (; it != _elemset_ids\&.end(); ++it)
356   //{
357   //  libMesh::out << "Elem set '" << (*it)\&.first << "' contains " << (*it)\&.second\&.size() << " ID(s)\&." << std::endl;
358   //}
359   //    }
360 
361 
362   // Set element IDs based on the element sets\&.
363   this->assign_subdomain_ids();
364 
365   // Assign nodeset values to the BoundaryInfo object
366   this->assign_boundary_node_ids();
367 
368   // Assign sideset values in the BoundaryInfo object
369   this->assign_sideset_ids();
370 
371   // Abaqus files only contain nodesets by default\&.  To be useful in
372   // applying most types of BCs in libmesh, we will definitely need
373   // sidesets\&.  So we can call the new BoundaryInfo function which
374   // generates sidesets from nodesets\&.
375   if (build_sidesets_from_nodesets)
376     the_mesh\&.boundary_info->build_side_list_from_node_list();
377 
378 } // read()
.fi
.SS "void libMesh::AbaqusIO::read_elements (std::stringupper)\fC [private]\fP"
This function parses a block of elements in the Abaqus file\&. You must pass it an upper-cased version of the string declaring this section, which is typically something like: *ELEMENT, TYPE=CPS3 so that it can determine the type of elements to read\&. 
.PP
Definition at line 467 of file abaqus_io\&.C\&.
.PP
References _abaqus_to_libmesh_elem_mapping, _abaqus_to_libmesh_node_mapping, _elem_types, _elemset_ids, _in, libMesh::MeshBase::add_elem(), libMesh::Elem::build(), libMesh::Utility::enum_to_string(), libMesh::HEX20, libMesh::HEX8, libMesh::DofObject::id(), libMesh::INVALID_ELEM, libMesh::MeshInput< MT >::mesh(), libMesh::MeshBase::node_ptr(), parse_label(), libMesh::PRISM15, libMesh::PRISM6, libMesh::QUAD4, libMesh::MeshBase::set_mesh_dimension(), libMesh::Elem::set_node(), libMesh::TET10, libMesh::TET4, and libMesh::TRI3\&.
.PP
Referenced by read()\&.
.PP
.nf
468 {
469   // Some *Element sections also specify an Elset name on the same line\&.
470   // Look for one here\&.
471   std::string elset_name = this->parse_label(upper, "elset");
472 
473   // Get a reference to the mesh we are reading
474   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
475 
476   // initialize the eletypes map (eletypes is a file-global variable)
477   init_eletypes();
478 
479   ElemType elem_type = INVALID_ELEM;
480   unsigned n_nodes_per_elem = 0;
481 
482   // Within s, we should have "type=XXXX"
483   if (upper\&.find("CPE4") != std::string::npos ||
484       upper\&.find("CPS4") != std::string::npos)
485     {
486       elem_type = QUAD4;
487       n_nodes_per_elem = 4;
488       the_mesh\&.set_mesh_dimension(2);
489     }
490   else if (upper\&.find("CPS3") != std::string::npos)
491     {
492       elem_type = TRI3;
493       n_nodes_per_elem = 3;
494       the_mesh\&.set_mesh_dimension(2);
495     }
496   else if (upper\&.find("C3D8") != std::string::npos)
497     {
498       elem_type = HEX8;
499       n_nodes_per_elem = 8;
500       the_mesh\&.set_mesh_dimension(3);
501     }
502   else if (upper\&.find("C3D4") != std::string::npos)
503     {
504       elem_type = TET4;
505       n_nodes_per_elem = 4;
506       the_mesh\&.set_mesh_dimension(3);
507     }
508   else if (upper\&.find("C3D20") != std::string::npos)
509     {
510       elem_type = HEX20;
511       n_nodes_per_elem = 20;
512       the_mesh\&.set_mesh_dimension(3);
513     }
514   else if (upper\&.find("C3D6") != std::string::npos)
515     {
516       elem_type = PRISM6;
517       n_nodes_per_elem = 6;
518       the_mesh\&.set_mesh_dimension(3);
519     }
520   else if (upper\&.find("C3D15") != std::string::npos)
521     {
522       elem_type = PRISM15;
523       n_nodes_per_elem = 15;
524       the_mesh\&.set_mesh_dimension(3);
525     }
526   else if (upper\&.find("C3D10") != std::string::npos)
527     {
528       elem_type = TET10;
529       n_nodes_per_elem = 10;
530       the_mesh\&.set_mesh_dimension(3);
531     }
532   else
533     libmesh_error_msg("Unrecognized element type: " << upper);
534 
535   // Insert the elem type we detected into the set of all elem types for this mesh
536   _elem_types\&.insert(elem_type);
537 
538   // Grab a reference to the element definition for this element type
539   const ElementDefinition& eledef = eletypes[elem_type];
540 
541   // If the element definition was not found, the call above would have
542   // created one with an uninitialized struct\&.  Check for that here\&.\&.\&.
543   if (eledef\&.abaqus_zero_based_node_id_to_libmesh_node_id\&.size() == 0)
544     libmesh_error_msg("No Abaqus->LibMesh mapping information for ElemType " \
545                       << Utility::enum_to_string(elem_type)             \
546                       << "!");
547 
548   // We will read elements until the next line begins with *, since that will be the
549   // next section\&.
550   while (_in\&.peek() != '*' && _in\&.peek() != EOF)
551     {
552       // Read the element ID, it is the first number on each line\&.  It is
553       // followed by a comma, so read that also\&.  We will need this ID later
554       // when we try to assign subdomain IDs
555       dof_id_type abaqus_elem_id = 0;
556       char c;
557       _in >> abaqus_elem_id >> c;
558 
559       // Debugging:
560       // libMesh::out << "Reading data for element " << abaqus_elem_id << std::endl;
561 
562       // Add an element of the appropriate type to the Mesh\&.
563       Elem* elem = the_mesh\&.add_elem(Elem::build(elem_type)\&.release());
564 
565       // Associate the ID returned from libmesh with the abaqus element ID
566       //_libmesh_to_abaqus_elem_mapping[elem->id()] = abaqus_elem_id;
567       _abaqus_to_libmesh_elem_mapping[abaqus_elem_id] = elem->id();
568 
569       // The count of the total number of IDs read for the current element\&.
570       unsigned id_count=0;
571 
572       // Continue reading line-by-line until we have read enough nodes for this element
573       while (id_count < n_nodes_per_elem)
574         {
575           // Read entire line (up to carriage return) of comma-separated values
576           std::string csv_line;
577           std::getline(_in, csv_line);
578 
579           // Create a stream object out of the current line
580           std::stringstream line_stream(csv_line);
581 
582           // Process the comma-separated values
583           std::string cell;
584           while (std::getline(line_stream, cell, ','))
585             {
586               // FIXME: factor out this strtol stuff into a utility function\&.
587               char* endptr;
588               long abaqus_global_node_id = std::strtol(cell\&.c_str(), &endptr, /*base=*/10);
589 
590               if (abaqus_global_node_id!=0 || cell\&.c_str() != endptr)
591                 {
592                   // Use the global node number mapping to determine the corresponding libmesh global node id
593                   dof_id_type libmesh_global_node_id = _abaqus_to_libmesh_node_mapping[abaqus_global_node_id];
594 
595                   // Grab the node pointer from the mesh for this ID
596                   Node* node = the_mesh\&.node_ptr(libmesh_global_node_id);
597 
598                   // Debugging:
599                   // libMesh::out << "Assigning global node id: " << abaqus_global_node_id
600                   //              << "(Abaqus), " << node->id() << "(LibMesh)" << std::endl;
601 
602                   // If node_ptr() returns NULL, it may mean we have not yet read the
603                   // *Nodes section, though I assumed that always came before the *Elements section\&.\&.\&.
604                   if (node == NULL)
605                     libmesh_error_msg("Error!  Mesh returned NULL Node pointer\&.  Either no node exists with ID " \
606                                       << libmesh_global_node_id         \
607                                       << " or perhaps this input file has *Elements defined before *Nodes?");
608 
609                   // Note: id_count is the zero-based abaqus (elem local) node index\&.  We therefore map
610                   // it to a libmesh elem local node index using the element definition map
611                   unsigned libmesh_elem_local_node_id =
612                     eledef\&.abaqus_zero_based_node_id_to_libmesh_node_id[id_count];
613 
614                   // Set this node pointer within the element\&.
615                   elem->set_node(libmesh_elem_local_node_id) = node;
616 
617                   // Debugging:
618                   // libMesh::out << "Setting elem " << elem->id()
619                   //              << ", local node " << libmesh_elem_local_node_id
620                   //              << " to global node " << node->id() << std::endl;
621 
622                   // Increment the count of IDs read for this element
623                   id_count++;
624                 } // end if strtol success
625             } // end while getline(',')
626         } // end while (id_count)
627 
628       // Ensure that we read *exactly* as many nodes as we were expecting to, no more\&.
629       if (id_count != n_nodes_per_elem)
630         libmesh_error_msg("Error: Needed to read " \
631                           << n_nodes_per_elem      \
632                           << " nodes, but read "   \
633                           << id_count              \
634                           << " instead!");
635 
636       // If we are recording Elset IDs, add this element to the correct set for later processing\&.
637       // Make sure to add it with the Abaqus ID, not the libmesh one!
638       if (elset_name != "")
639         {
640           // Debugging:
641           // libMesh::out << "Adding Elem " << abaqus_elem_id << " to Elmset " << elset_name << std::endl;
642           _elemset_ids[elset_name]\&.push_back(abaqus_elem_id);
643         }
644     } // end while (peek)
645 } // read_elements()
.fi
.SS "void libMesh::AbaqusIO::read_ids (std::stringset_name, \fBcontainer_t\fP &container)\fC [private]\fP"
This function reads all the IDs for the current node or element set of the given name, storing them in the passed map using the name as key\&. 
.PP
Definition at line 681 of file abaqus_io\&.C\&.
.PP
References _in\&.
.PP
Referenced by read()\&.
.PP
.nf
682 {
683   // Debugging
684   // libMesh::out << "Reading ids for set: " << set_name << std::endl;
685 
686   // Grab a reference to a vector that will hold all the IDs
687   std::vector<dof_id_type>& id_storage = container[set_name];
688 
689   // Read until the start of another section is detected, or EOF is encountered
690   while (_in\&.peek() != '*' && _in\&.peek() != EOF)
691     {
692       // Read entire comma-separated line into a string
693       std::string csv_line;
694       std::getline(_in, csv_line);
695 
696       // On that line, use std::getline again to parse each
697       // comma-separated entry\&.
698       std::string cell;
699       std::stringstream line_stream(csv_line);
700       while (std::getline(line_stream, cell, ','))
701         {
702           // If no conversion can be performed by strtol, 0 is returned\&.
703           //
704           // If endptr is not NULL, strtol() stores the address of the
705           // first invalid character in *endptr\&.  If there were no
706           // digits at all, however, strtol() stores the original
707           // value of str in *endptr\&.
708           char* endptr;
709 
710           // FIXME - this needs to be updated for 64-bit inputs
711           long id = std::strtol(cell\&.c_str(), &endptr, /*base=*/10);
712 
713           // Note that lists of comma-separated values in abaqus also
714           // *end* with a comma, so the last call to getline on a given
715           // line will get an empty string, which we must detect\&.
716           if (id!=0 || cell\&.c_str() != endptr)
717             {
718               // Debugging
719               // libMesh::out << "Read id: " << id << std::endl;
720 
721               // 'cell' is now a string with an integer id in it
722               id_storage\&.push_back( id );
723             }
724         }
725     }
726 
727   // Status message
728   // libMesh::out << "Read " << id_storage\&.size() << " ID(s) for the set " << set_name << std::endl;
729 } // read_ids()
.fi
.SS "void libMesh::AbaqusIO::read_nodes ()\fC [private]\fP"
This function parses a block of nodes in the Abaqus file once such a block has been found\&. 
.PP
Definition at line 386 of file abaqus_io\&.C\&.
.PP
References _abaqus_to_libmesh_node_mapping, _in, libMesh::MeshBase::add_point(), libMesh::MeshInput< MT >::mesh(), libMesh::Real, and libMesh::x\&.
.PP
Referenced by read()\&.
.PP
.nf
387 {
388   // Get a reference to the mesh we are reading
389   MeshBase& the_mesh = MeshInput<MeshBase>::mesh();
390 
391   // Debugging: print node count
392   // libMesh::out << "Before read_nodes(), mesh contains "
393   //  << the_mesh\&.n_elem()
394   //  << " elements, and "
395   //  << the_mesh\&.n_nodes()
396   //  << " nodes\&." << std::endl;
397 
398   // In the input file I have, Abaqus neither tells what
399   // the mesh dimension is nor how many nodes it has\&.\&.\&.
400 
401   // The node line format is:
402   // id, x, y, z
403   // and you do have to parse out the commas\&.
404   // The z-coordinate will only be present for 3D meshes
405 
406   // Temporary variables for parsing lines of text
407   char c;
408   std::string dummy;
409 
410   // Defines the sequential node numbering used by libmesh
411   dof_id_type libmesh_node_id = 0;
412 
413   // We will read nodes until the next line begins with *, since that will be the
414   // next section\&.
415   // TODO: Is Abaqus guaranteed to start the line with '*' or can there be leading white space?
416   while (_in\&.peek() != '*' && _in\&.peek() != EOF)
417     {
418       // Re-Initialize variables to be read in from file
419       dof_id_type abaqus_node_id=0;
420       Real x=0, y=0, z=0;
421 
422       // Note: we assume *at least* 2D points here, should we worry about
423       // trying to read 1D Abaqus meshes?
424       _in >> abaqus_node_id >> c >> x >> c >> y;
425 
426       // Peek at the next character\&.  If it is a comma, then there is another
427       // value to read!
428       if (_in\&.peek() == ',')
429         _in >> c >> z;
430 
431       // Debugging: Print what we just read in\&.
432       // libMesh::out << "node_id=" << node_id
433       //      << ", x=" << x
434       //      << ", y=" << y
435       //      << ", z=" << z
436       //      << std::endl;
437 
438       // Read (and discard) the rest of the line, including the newline\&.
439       // This is required so that our 'peek()' at the beginning of this
440       // loop doesn't read the newline character, for example\&.
441       std::getline(_in, dummy);
442 
443       // Set up the abaqus -> libmesh node mapping\&.  This is usually just the
444       // "off-by-one" map\&.
445       _abaqus_to_libmesh_node_mapping[abaqus_node_id] = libmesh_node_id;
446 
447       // Add the point to the mesh using libmesh's numbering,
448       // and post-increment the libmesh node counter\&.
449       the_mesh\&.add_point(Point(x,y,z), libmesh_node_id++);
450     } // while
451 
452   // Debugging: print node count\&.  Note: in serial mesh, this count may
453   // be off by one, since Abaqus uses one-based numbering, and libmesh
454   // just reports the length of its _nodes vector for the number of nodes\&.
455   // libMesh::out << "After read_nodes(), mesh contains "
456   //              << the_mesh\&.n_elem()
457   //              << " elements, and "
458   //              << the_mesh\&.n_nodes()
459   //              << " nodes\&." << std::endl;
460 
461 } // read_nodes()
.fi
.SS "void libMesh::AbaqusIO::read_sideset (std::stringsideset_name, \fBsideset_container_t\fP &container)\fC [private]\fP"
This function reads a sideset from the input file\&. This is defined by a '*Surface' section in the file, and then a list of element ID and side IDs for the set\&. 
.PP
Definition at line 734 of file abaqus_io\&.C\&.
.PP
References _in\&.
.PP
Referenced by read()\&.
.PP
.nf
735 {
736   // Grab a reference to a vector that will hold all the IDs
737   std::vector<std::pair<dof_id_type, unsigned> >& id_storage = container[sideset_name];
738 
739   // Variables for storing values read in from file
740   dof_id_type elem_id=0;
741   unsigned side_id=0;
742   char c;
743   std::string dummy;
744 
745   // Read until the start of another section is detected, or EOF is encountered
746   while (_in\&.peek() != '*' && _in\&.peek() != EOF)
747     {
748       // The strings are of the form: "391, S2"
749 
750       // Read the element ID and the leading comma
751       _in >> elem_id >> c;
752 
753       // Read another character (the 'S') and finally the side ID
754       _in >> c >> side_id;
755 
756       // Debugging: print status
757       // libMesh::out << "Read elem_id=" << elem_id << ", side_id=" << side_id << std::endl;
758 
759       // Store this pair of data in the vector
760       id_storage\&.push_back( std::make_pair(elem_id, side_id) );
761 
762       // Extract remaining characters on line including newline
763       std::getline(_in, dummy);
764     } // while
765 }
.fi
.SS "void \fBlibMesh::MeshInput\fP< \fBMeshBase\fP  >::skip_comment_lines (std::istream &in, const charcomment_start)\fC [protected]\fP, \fC [inherited]\fP"
Reads input from \fCin\fP, skipping all the lines that start with the character \fCcomment_start\fP\&. 
.PP
Referenced by libMesh::TetGenIO::read(), and libMesh::UCDIO::read_implementation()\&.
.SH "Member Data Documentation"
.PP 
.SS "std::map<\fBdof_id_type\fP, \fBdof_id_type\fP> libMesh::AbaqusIO::_abaqus_to_libmesh_elem_mapping\fC [private]\fP"
Map from libmesh element number -> abaqus element number, and the converse\&. 
.PP
Definition at line 185 of file abaqus_io\&.h\&.
.PP
Referenced by assign_sideset_ids(), assign_subdomain_ids(), and read_elements()\&.
.SS "std::map<\fBdof_id_type\fP, \fBdof_id_type\fP> libMesh::AbaqusIO::_abaqus_to_libmesh_node_mapping\fC [private]\fP"
Map from abaqus node number -> sequential, 0-based libmesh node numbering\&. Note that in every Abaqus file I've ever seen the node numbers were 1-based, sequential, and all in order, so that this map is probably overkill\&. Nevertheless, it is the most general solution in case we come across a weird Abaqus file some day\&. 
.PP
Definition at line 194 of file abaqus_io\&.h\&.
.PP
Referenced by assign_boundary_node_ids(), read_elements(), and read_nodes()\&.
.SS "bool libMesh::AbaqusIO::_already_seen_part\fC [private]\fP"
This flag gets set to true after the first '*PART' section we see\&. If it is still true when we see a second PART section, we will print an error message\&.\&.\&. we don't currently handle input files with multiple parts\&. 
.PP
Definition at line 202 of file abaqus_io\&.h\&.
.PP
Referenced by read()\&.
.SS "std::set<\fBElemType\fP> libMesh::AbaqusIO::_elem_types\fC [private]\fP"
A set of the different geometric element types detected when reading the mesh\&. 
.PP
Definition at line 178 of file abaqus_io\&.h\&.
.PP
Referenced by assign_subdomain_ids(), and read_elements()\&.
.SS "\fBcontainer_t\fP libMesh::AbaqusIO::_elemset_ids\fC [private]\fP"

.PP
Definition at line 166 of file abaqus_io\&.h\&.
.PP
Referenced by assign_subdomain_ids(), read(), and read_elements()\&.
.SS "std::ifstream libMesh::AbaqusIO::_in\fC [private]\fP"
Stream object used to interact with the file 
.PP
Definition at line 172 of file abaqus_io\&.h\&.
.PP
Referenced by process_and_discard_comments(), read(), read_elements(), read_ids(), read_nodes(), and read_sideset()\&.
.SS "\fBcontainer_t\fP libMesh::AbaqusIO::_nodeset_ids\fC [private]\fP"
Abaqus writes nodesets and elemsets with labels\&. As we read them in, we'll use these maps to provide a natural ordering for them\&. 
.PP
Definition at line 165 of file abaqus_io\&.h\&.
.PP
Referenced by assign_boundary_node_ids(), and read()\&.
.SS "\fBsideset_container_t\fP libMesh::AbaqusIO::_sideset_ids\fC [private]\fP"

.PP
Definition at line 167 of file abaqus_io\&.h\&.
.PP
Referenced by assign_sideset_ids(), and read()\&.
.SS "bool libMesh::AbaqusIO::build_sidesets_from_nodesets"
Default false\&. Abaqus files have only nodesets in them by default\&. Set this flag to true if you want libmesh to automatically generate sidesets from Abaqus' nodesets\&. 
.PP
Definition at line 62 of file abaqus_io\&.h\&.
.PP
Referenced by read()\&.
.SS "std::vector<bool> \fBlibMesh::MeshInput\fP< \fBMeshBase\fP  >::elems_of_dimension\fC [protected]\fP, \fC [inherited]\fP"
A vector of bools describing what dimension elements have been encountered when reading a mesh\&. 
.PP
Definition at line 93 of file mesh_input\&.h\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::UNVIO::element_in(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::UCDIO::read_implementation(), libMesh::UNVIO::read_implementation(), libMesh::LegacyXdrIO::read_mesh(), and libMesh::XdrIO::read_serialized_connectivity()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
