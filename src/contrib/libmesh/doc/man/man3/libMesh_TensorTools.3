.TH "libMesh::TensorTools" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::TensorTools \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBIncrementRank\fP"
.br
.ti -1c
.RI "struct \fBIncrementRank< VectorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBIncrementRank< TypeVector< T > >\fP"
.br
.ti -1c
.RI "struct \fBIncrementRank< TypeTensor< T > >\fP"
.br
.ti -1c
.RI "struct \fBIncrementRank< TensorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBIncrementRank< TypeNTensor< N, T > >\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank< VectorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank< TypeVector< T > >\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank< TensorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank< TypeTensor< T > >\fP"
.br
.ti -1c
.RI "struct \fBDecrementRank< TypeNTensor< N, T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< std::complex< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< TypeVector< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< VectorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< TypeTensor< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< TensorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeNumber< TypeNTensor< N, T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< std::complex< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< TypeVector< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< VectorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< TypeTensor< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< TensorValue< T > >\fP"
.br
.ti -1c
.RI "struct \fBMakeReal< TypeNTensor< N, T > >\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBNumber\fP \fBcurl_from_grad\fP (const \fBVectorValue\fP< \fBNumber\fP > &)"
.br
.ti -1c
.RI "\fBVectorValue\fP< \fBNumber\fP > \fBcurl_from_grad\fP (const \fBTensorValue\fP< \fBNumber\fP > &grad)"
.br
.RI "\fIComputes the curl of a vector given the gradient of that vector\&. \fP"
.ti -1c
.RI "\fBTensorValue\fP< \fBNumber\fP > \fBcurl_from_grad\fP (const \fBTypeNTensor\fP< 3, \fBNumber\fP > &)"
.br
.ti -1c
.RI "\fBNumber\fP \fBdiv_from_grad\fP (const \fBVectorValue\fP< \fBNumber\fP > &grad)"
.br
.RI "\fIDummy\&. Divgerence of a scalar not defined, but is needed for \fBExactSolution\fP to compile\&. \fP"
.ti -1c
.RI "\fBNumber\fP \fBdiv_from_grad\fP (const \fBTensorValue\fP< \fBNumber\fP > &grad)"
.br
.RI "\fIComputes the divergence of a vector given the gradient of that vector\&. \fP"
.ti -1c
.RI "\fBVectorValue\fP< \fBNumber\fP > \fBdiv_from_grad\fP (const \fBTypeNTensor\fP< 3, \fBNumber\fP > &)"
.br
.ti -1c
.RI "template<typename T , typename T2 > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< T >::value 
.br
&&\fBScalarTraits\fP< T2 >::value, 
.br
typename \fBCompareTypes\fP< T, T2 >
.br
::supertype >::type \fBinner_product\fP (const T &a, const T2 &b)"
.br
.ti -1c
.RI "template<typename T , typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBinner_product\fP (const \fBTypeVector\fP< T > &a, const \fBTypeVector\fP< T2 > &b)"
.br
.ti -1c
.RI "template<typename T , typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBinner_product\fP (const \fBTypeTensor\fP< T > &a, const \fBTypeTensor\fP< T2 > &b)"
.br
.ti -1c
.RI "template<unsigned int N, typename T , typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBinner_product\fP (const \fBTypeNTensor\fP< N, T > &a, const \fBTypeNTensor\fP< N, T2 > &b)"
.br
.ti -1c
.RI "template<typename T > T \fBnorm_sq\fP (T a)"
.br
.ti -1c
.RI "template<typename T > T \fBnorm_sq\fP (std::complex< T > a)"
.br
.ti -1c
.RI "template<typename T > \fBReal\fP \fBnorm_sq\fP (const \fBTypeVector\fP< T > &a)"
.br
.ti -1c
.RI "template<typename T > \fBReal\fP \fBnorm_sq\fP (const \fBVectorValue\fP< T > &a)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBNumber\fP libMesh::TensorTools::curl_from_grad (const VectorValue< Number > &)"

.PP
Definition at line 28 of file tensor_tools\&.C\&.
.PP
References libMesh::err\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error()\&.
.PP
.nf
29 {
30   libMesh::err << "Operation not defined for scalar quantities\&." << std::endl;
31   libmesh_error();
32 }
.fi
.SS "\fBVectorValue\fP< \fBNumber\fP > libMesh::TensorTools::curl_from_grad (const TensorValue< Number > &grad)"

.PP
Computes the curl of a vector given the gradient of that vector\&. 
.PP
Definition at line 34 of file tensor_tools\&.C\&.
.PP
.nf
35 {
36   const Number duz_dy = grad(2,1);
37   const Number duy_dz = grad(1,2);
38   const Number dux_dz = grad(0,2);
39   const Number duz_dx = grad(2,0);
40   const Number duy_dx = grad(1,0);
41   const Number dux_dy = grad(0,1);
42 
43   return VectorValue<Number>( duz_dy - duy_dz, dux_dz - duz_dx, duy_dx - dux_dy);
44 }
.fi
.SS "\fBTensorValue\fP< \fBNumber\fP > libMesh::TensorTools::curl_from_grad (const TypeNTensor< 3, Number > &grad)"
Place holder needed for \fBExactSolution\fP to compile\&. Will compute the curl of a tensor given the gradient of that tensor\&. 
.PP
Definition at line 47 of file tensor_tools\&.C\&.
.PP
.nf
48 {
49   libmesh_not_implemented();
50 }
.fi
.SS "\fBNumber\fP libMesh::TensorTools::div_from_grad (const VectorValue< Number > &)"

.PP
Dummy\&. Divgerence of a scalar not defined, but is needed for \fBExactSolution\fP to compile\&. 
.PP
Definition at line 53 of file tensor_tools\&.C\&.
.PP
References libMesh::err\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error()\&.
.PP
.nf
54 {
55   libMesh::err << "Operation not defined for scalar quantities\&." << std::endl;
56   libmesh_error();
57 }
.fi
.SS "\fBNumber\fP libMesh::TensorTools::div_from_grad (const TensorValue< Number > &grad)"

.PP
Computes the divergence of a vector given the gradient of that vector\&. 
.PP
Definition at line 59 of file tensor_tools\&.C\&.
.PP
.nf
60 {
61   const Number dux_dx = grad(0,0);
62   const Number duy_dy = grad(1,1);
63   const Number duz_dz = grad(2,2);
64 
65   return dux_dx + duy_dy + duz_dz;
66 }
.fi
.SS "\fBVectorValue\fP< \fBNumber\fP > libMesh::TensorTools::div_from_grad (const TypeNTensor< 3, Number > &grad)"
Place holder needed for \fBExactSolution\fP to compile\&. Will compute the divergence of a tensor given the gradient of that tensor\&. 
.PP
Definition at line 69 of file tensor_tools\&.C\&.
.PP
.nf
70 {
71   libmesh_not_implemented();
72 }
.fi
.SS "template<typename T , typename T2 > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<T>::value && \fBScalarTraits\fP<T2>::value, typename \fBCompareTypes\fP<T, T2>::supertype>::type libMesh::TensorTools::inner_product (const T &a, const T2 &b)\fC [inline]\fP"

.PP
Definition at line 48 of file tensor_tools\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), and libMesh::FEGenericBase< T >::compute_proj_constraints()\&.
.PP
.nf
49 { return a * b; }
.fi
.SS "template<typename T , typename T2 > \fBCompareTypes\fP<T, T2>::supertype libMesh::TensorTools::inner_product (const TypeVector< T > &a, const TypeVector< T2 > &b)\fC [inline]\fP"

.PP
Definition at line 54 of file tensor_tools\&.h\&.
.PP
.nf
55 { return a * b; }
.fi
.SS "template<typename T , typename T2 > \fBCompareTypes\fP<T, T2>::supertype libMesh::TensorTools::inner_product (const TypeTensor< T > &a, const TypeTensor< T2 > &b)\fC [inline]\fP"

.PP
Definition at line 60 of file tensor_tools\&.h\&.
.PP
References libMesh::TypeTensor< T >::contract()\&.
.PP
.nf
61 { return a\&.contract(b); }
.fi
.SS "template<unsigned int N, typename T , typename T2 > \fBCompareTypes\fP<T, T2>::supertype libMesh::TensorTools::inner_product (const TypeNTensor< N, T > &a, const TypeNTensor< N, T2 > &b)\fC [inline]\fP"

.PP
Definition at line 66 of file tensor_tools\&.h\&.
.PP
References libMesh::TypeNTensor< N, T >::contract()\&.
.PP
.nf
67 { return a\&.contract(b); }
.fi
.SS "template<typename T > T libMesh::TensorTools::norm_sq (Ta)\fC [inline]\fP"

.PP
Definition at line 71 of file tensor_tools\&.h\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DiscontinuityMeasure::boundary_side_integration(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::System::calculate_norm(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::LaplacianErrorEstimator::internal_side_integration(), libMesh::DiscontinuityMeasure::internal_side_integration(), libMesh::KellyErrorEstimator::internal_side_integration(), libMesh::DenseVector< T >::l2_norm(), libMesh::DistributedVector< T >::l2_norm(), libMesh::DenseVector< T >::linfty_norm(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::HPCoarsenTest::select_refinement(), libMesh::TypeVector< T >::size_sq(), libMesh::TypeTensor< T >::size_sq(), and libMesh::NumericVector< T >::subset_l2_norm()\&.
.PP
.nf
71 { return a*a; }
.fi
.SS "template<typename T > T libMesh::TensorTools::norm_sq (std::complex< T >a)\fC [inline]\fP"

.PP
Definition at line 75 of file tensor_tools\&.h\&.
.PP
.nf
75 { return std::norm(a); }
.fi
.SS "template<typename T > \fBReal\fP libMesh::TensorTools::norm_sq (const TypeVector< T > &a)\fC [inline]\fP"

.PP
Definition at line 79 of file tensor_tools\&.h\&.
.PP
References libMesh::TypeVector< T >::size_sq()\&.
.PP
.nf
80 {return a\&.size_sq();}
.fi
.SS "template<typename T > \fBReal\fP libMesh::TensorTools::norm_sq (const VectorValue< T > &a)\fC [inline]\fP"

.PP
Definition at line 84 of file tensor_tools\&.h\&.
.PP
References libMesh::TypeVector< T >::size_sq()\&.
.PP
.nf
85 {return a\&.size_sq();}
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
