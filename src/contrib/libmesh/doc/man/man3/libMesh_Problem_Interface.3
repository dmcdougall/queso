.TH "libMesh::Problem_Interface" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Problem_Interface \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits Required, Jacobian, and Preconditioner\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBProblem_Interface\fP (\fBNoxNonlinearSolver\fP< \fBNumber\fP > *\fBsolver\fP)"
.br
.ti -1c
.RI "\fB~Problem_Interface\fP ()"
.br
.ti -1c
.RI "bool \fBcomputeF\fP (const Epetra_Vector &\fBx\fP, Epetra_Vector &FVec, NOX::Epetra::Interface::Required::FillType fillType)"
.br
.RI "\fICompute and return F\&. \fP"
.ti -1c
.RI "bool \fBcomputeJacobian\fP (const Epetra_Vector &\fBx\fP, Epetra_Operator &\fBJac\fP)"
.br
.RI "\fICompute an explicit Jacobian\&. \fP"
.ti -1c
.RI "bool \fBcomputePrecMatrix\fP (const Epetra_Vector &\fBx\fP, Epetra_RowMatrix &M)"
.br
.RI "\fICompute the Epetra_RowMatrix M, that will be used by the Aztec preconditioner instead of the Jacobian\&. This is used when there is no explicit Jacobian present (i\&.e\&. Matrix-Free Newton-Krylov)\&. This MUST BE an Epetra_RowMatrix since the Aztec preconditioners need to know the sparsity pattern of the matrix\&. Returns true if computation was successful\&. \fP"
.ti -1c
.RI "bool \fBcomputePreconditioner\fP (const Epetra_Vector &\fBx\fP, Epetra_Operator &Prec, Teuchos::ParameterList *p)"
.br
.RI "\fIComputes a user supplied preconditioner based on input vector x\&. Returns true if computation was successful\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBNoxNonlinearSolver\fP< \fBNumber\fP > * \fB_solver\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 53 of file trilinos_nox_nonlinear_solver\&.C\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Problem_Interface::Problem_Interface (\fBNoxNonlinearSolver\fP< \fBNumber\fP > *solver)\fC [explicit]\fP"

.PP
Definition at line 81 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
.nf
81                                                                         :
82   _solver(solver)
83 { }
.fi
.SS "libMesh::Problem_Interface::~Problem_Interface ()"

.PP
Definition at line 85 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
.nf
86 { }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool libMesh::Problem_Interface::computeF (const Epetra_Vector &x, Epetra_Vector &FVec, NOX::Epetra::Interface::Required::FillTypefillType)"

.PP
Compute and return F\&. 
.PP
Definition at line 88 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
References _solver, libMesh::ParallelObject::comm(), libMesh::System::current_local_solution, libMesh::DofMap::enforce_constraints_exactly(), libMesh::err, libMesh::System::get_dof_map(), libMesh::NonlinearSolver< T >::matvec, libMesh::NonlinearImplicitSystem::ComputeResidual::residual(), libMesh::NonlinearSolver< T >::residual, libMesh::NonlinearImplicitSystem::ComputeResidualandJacobian::residual_and_jacobian(), libMesh::NonlinearSolver< T >::residual_and_jacobian_object, libMesh::NonlinearSolver< T >::residual_object, libMesh::ExplicitSystem::rhs, libMesh::System::solution, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::sys, libMesh::NonlinearSolver< T >::system(), libMesh::System::update(), libMesh::X_global(), and libMesh::X_sys\&.
.PP
.nf
90 {
91   START_LOG("residual()", "TrilinosNoxNonlinearSolver");
92 
93   NonlinearImplicitSystem &sys = _solver->system();
94 
95   EpetraVector<Number> X_global(*const_cast<Epetra_Vector *>(&x), sys\&.comm()), R(r, sys\&.comm());
96   EpetraVector<Number>& X_sys = *libmesh_cast_ptr<EpetraVector<Number>*>(sys\&.solution\&.get());
97   EpetraVector<Number>& R_sys = *libmesh_cast_ptr<EpetraVector<Number>*>(sys\&.rhs);
98 
99   // Use the systems update() to get a good local version of the parallel solution
100   X_global\&.swap(X_sys);
101   R\&.swap(R_sys);
102 
103   sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
104   sys\&.update();
105 
106   // Swap back
107   X_global\&.swap(X_sys);
108   R\&.swap(R_sys);
109 
110   R\&.zero();
111 
112   //-----------------------------------------------------------------------------
113   // if the user has provided both function pointers and objects only the pointer
114   // will be used, so catch that as an error
115 
116   if (_solver->residual && _solver->residual_object)
117     {
118       libMesh::err << "ERROR: cannot specifiy both a function and object to compute the Residual!" << std::endl;
119       libmesh_error();
120     }
121 
122   if (_solver->matvec && _solver->residual_and_jacobian_object)
123     {
124       libMesh::err << "ERROR: cannot specifiy both a function and object to compute the combined Residual & Jacobian!" << std::endl;
125       libmesh_error();
126     }
127   //-----------------------------------------------------------------------------
128 
129   if      (_solver->residual != NULL)                     _solver->residual                                            (*sys\&.current_local_solution\&.get(), R, sys);
130   else if (_solver->residual_object != NULL)              _solver->residual_object->residual                           (*sys\&.current_local_solution\&.get(), R, sys);
131   else if (_solver->matvec   != NULL)                     _solver->matvec                                              (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
132   else if (_solver->residual_and_jacobian_object != NULL) _solver->residual_and_jacobian_object->residual_and_jacobian (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
133   else return false;
134 
135   R\&.close();
136   X_global\&.close();
137 
138   STOP_LOG("residual()", "TrilinosNoxNonlinearSolver");
139 
140   return true;
141 }
.fi
.SS "bool libMesh::Problem_Interface::computeJacobian (const Epetra_Vector &x, Epetra_Operator &Jac)"

.PP
Compute an explicit Jacobian\&. 
.PP
Definition at line 143 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
References _solver, libMesh::ParallelObject::comm(), libMesh::System::current_local_solution, libMesh::DofMap::enforce_constraints_exactly(), libMesh::err, libMesh::System::get_dof_map(), libMesh::Jac(), libMesh::NonlinearImplicitSystem::ComputeJacobian::jacobian(), libMesh::NonlinearSolver< T >::jacobian, libMesh::NonlinearSolver< T >::jacobian_object, libMesh::NonlinearSolver< T >::matvec, libMesh::NonlinearImplicitSystem::ComputeResidualandJacobian::residual_and_jacobian(), libMesh::NonlinearSolver< T >::residual_and_jacobian_object, libMesh::System::solution, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::sys, libMesh::NonlinearSolver< T >::system(), libMesh::System::update(), libMesh::X_global(), and libMesh::X_sys\&.
.PP
.nf
145 {
146   START_LOG("jacobian()", "TrilinosNoxNonlinearSolver");
147 
148   NonlinearImplicitSystem &sys = _solver->system();
149 
150   EpetraMatrix<Number> Jac(&dynamic_cast<Epetra_FECrsMatrix &>(jac), sys\&.comm());
151   EpetraVector<Number>& X_sys = *libmesh_cast_ptr<EpetraVector<Number>*>(sys\&.solution\&.get());
152   EpetraVector<Number> X_global(*const_cast<Epetra_Vector *>(&x), sys\&.comm());
153 
154   // Set the dof maps
155   Jac\&.attach_dof_map(sys\&.get_dof_map());
156 
157   // Use the systems update() to get a good local version of the parallel solution
158   X_global\&.swap(X_sys);
159 
160   sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
161   sys\&.update();
162 
163   X_global\&.swap(X_sys);
164 
165   //-----------------------------------------------------------------------------
166   // if the user has provided both function pointers and objects only the pointer
167   // will be used, so catch that as an error
168   if (_solver->jacobian && _solver->jacobian_object)
169     {
170       libMesh::err << "ERROR: cannot specify both a function and object to compute the Jacobian!" << std::endl;
171       libmesh_error();
172     }
173 
174   if (_solver->matvec && _solver->residual_and_jacobian_object)
175     {
176       libMesh::err << "ERROR: cannot specify both a function and object to compute the combined Residual & Jacobian!" << std::endl;
177       libmesh_error();
178     }
179   //-----------------------------------------------------------------------------
180 
181   if      (_solver->jacobian != NULL)                     _solver->jacobian                                            (*sys\&.current_local_solution\&.get(), Jac, sys);
182   else if (_solver->jacobian_object != NULL)              _solver->jacobian_object->jacobian                           (*sys\&.current_local_solution\&.get(), Jac, sys);
183   else if (_solver->matvec   != NULL)                     _solver->matvec                                              (*sys\&.current_local_solution\&.get(), NULL, &Jac, sys);
184   else if (_solver->residual_and_jacobian_object != NULL) _solver->residual_and_jacobian_object->residual_and_jacobian (*sys\&.current_local_solution\&.get(), NULL, &Jac, sys);
185   else libmesh_error();
186 
187   Jac\&.close();
188   X_global\&.close();
189 
190   STOP_LOG("jacobian()", "TrilinosNoxNonlinearSolver");
191 
192   return true;
193 }
.fi
.SS "bool libMesh::Problem_Interface::computePrecMatrix (const Epetra_Vector &x, Epetra_RowMatrix &M)"

.PP
Compute the Epetra_RowMatrix M, that will be used by the Aztec preconditioner instead of the Jacobian\&. This is used when there is no explicit Jacobian present (i\&.e\&. Matrix-Free Newton-Krylov)\&. This MUST BE an Epetra_RowMatrix since the Aztec preconditioners need to know the sparsity pattern of the matrix\&. Returns true if computation was successful\&. 
.PP
Definition at line 195 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
.nf
196 {
197   //   libMesh::out << "ERROR: Problem_Interface::preconditionVector() - Use Explicit Jacobian only for this test problem!" << endl;
198   throw 1;
199 }
.fi
.SS "bool libMesh::Problem_Interface::computePreconditioner (const Epetra_Vector &x, Epetra_Operator &Prec, Teuchos::ParameterList *p)"

.PP
Computes a user supplied preconditioner based on input vector x\&. Returns true if computation was successful\&. 
.PP
Definition at line 201 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
References _solver, libMesh::ParallelObject::comm(), libMesh::TrilinosPreconditioner< T >::compute(), libMesh::System::current_local_solution, libMesh::DofMap::enforce_constraints_exactly(), libMesh::err, libMesh::System::get_dof_map(), libMesh::Jac(), libMesh::NonlinearImplicitSystem::ComputeJacobian::jacobian(), libMesh::NonlinearSolver< T >::jacobian, libMesh::NonlinearSolver< T >::jacobian_object, libMesh::TrilinosPreconditioner< T >::mat(), libMesh::NonlinearSolver< T >::matvec, libMesh::NonlinearImplicitSystem::ComputeResidualandJacobian::residual_and_jacobian(), libMesh::NonlinearSolver< T >::residual_and_jacobian_object, libMesh::System::solution, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::sys, libMesh::NonlinearSolver< T >::system(), libMesh::System::update(), libMesh::X_global(), and libMesh::X_sys\&.
.PP
.nf
204 {
205   START_LOG("preconditioner()", "TrilinosNoxNonlinearSolver");
206 
207   NonlinearImplicitSystem &sys = _solver->system();
208   TrilinosPreconditioner<Number> & tpc = dynamic_cast<TrilinosPreconditioner<Number> &>(prec);
209 
210   EpetraMatrix<Number> Jac(dynamic_cast<Epetra_FECrsMatrix *>(tpc\&.mat()),sys\&.comm());
211   EpetraVector<Number>& X_sys = *libmesh_cast_ptr<EpetraVector<Number>*>(sys\&.solution\&.get());
212   EpetraVector<Number> X_global(*const_cast<Epetra_Vector *>(&x), sys\&.comm());
213 
214   // Set the dof maps
215   Jac\&.attach_dof_map(sys\&.get_dof_map());
216 
217   // Use the systems update() to get a good local version of the parallel solution
218   X_global\&.swap(X_sys);
219 
220   sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
221   sys\&.update();
222 
223   X_global\&.swap(X_sys);
224 
225   //-----------------------------------------------------------------------------
226   // if the user has provided both function pointers and objects only the pointer
227   // will be used, so catch that as an error
228   if (_solver->jacobian && _solver->jacobian_object)
229     {
230       libMesh::err << "ERROR: cannot specify both a function and object to compute the Jacobian!" << std::endl;
231       libmesh_error();
232     }
233 
234   if (_solver->matvec && _solver->residual_and_jacobian_object)
235     {
236       libMesh::err << "ERROR: cannot specify both a function and object to compute the combined Residual & Jacobian!" << std::endl;
237       libmesh_error();
238     }
239   //-----------------------------------------------------------------------------
240 
241   if      (_solver->jacobian != NULL)                     _solver->jacobian                                            (*sys\&.current_local_solution\&.get(), Jac, sys);
242   else if (_solver->jacobian_object != NULL)              _solver->jacobian_object->jacobian                           (*sys\&.current_local_solution\&.get(), Jac, sys);
243   else if (_solver->matvec   != NULL)                     _solver->matvec                                              (*sys\&.current_local_solution\&.get(), NULL, &Jac, sys);
244   else if (_solver->residual_and_jacobian_object != NULL) _solver->residual_and_jacobian_object->residual_and_jacobian (*sys\&.current_local_solution\&.get(), NULL, &Jac, sys);
245   else libmesh_error();
246 
247   Jac\&.close();
248   X_global\&.close();
249 
250   tpc\&.compute();
251 
252   STOP_LOG("preconditioner()", "TrilinosNoxNonlinearSolver");
253 
254   return true;
255 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBNoxNonlinearSolver\fP<\fBNumber\fP>* libMesh::Problem_Interface::_solver"

.PP
Definition at line 77 of file trilinos_nox_nonlinear_solver\&.C\&.
.PP
Referenced by computeF(), computeJacobian(), and computePreconditioner()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
