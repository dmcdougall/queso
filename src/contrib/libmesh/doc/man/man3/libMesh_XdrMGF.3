.TH "libMesh::XdrMGF" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::XdrMGF \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <xdr_mgf\&.h>\fP
.PP
Inherited by \fBlibMesh::XdrMESH\fP, and \fBlibMesh::XdrSOLN\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBXdrIO_TYPE\fP { \fBUNKNOWN\fP = -1, \fBENCODE\fP =0, \fBDECODE\fP, \fBW_ASCII\fP, \fBR_ASCII\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBXdrMGF\fP ()"
.br
.ti -1c
.RI "\fBXdrMGF\fP ()"
.br
.ti -1c
.RI "void \fBinit\fP (\fBXdrIO_TYPE\fP t, const char *fn, const char *type, int icnt)"
.br
.ti -1c
.RI "virtual \fB~XdrMGF\fP ()"
.br
.ti -1c
.RI "void \fBfini\fP ()"
.br
.ti -1c
.RI "int \fBdataBlk\fP (int *array, int numvar, int size)"
.br
.ti -1c
.RI "int \fBdataBlk\fP (\fBReal\fP *array, int numvar, int size)"
.br
.ti -1c
.RI "\fBLegacyXdrIO::FileFormat\fP \fBget_orig_flag\fP () const "
.br
.ti -1c
.RI "void \fBset_orig_flag\fP (\fBLegacyXdrIO::FileFormat\fP in_orig_flag)"
.br
.ti -1c
.RI "void \fBset_num_levels\fP (unsigned int num_levels)"
.br
.ti -1c
.RI "unsigned int \fBget_num_levels\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "unsigned int \fB_num_levels\fP"
.br
.ti -1c
.RI "\fBXdrIO_TYPE\fP \fBm_type\fP"
.br
.ti -1c
.RI "XDR * \fBmp_xdr_handle\fP"
.br
.ti -1c
.RI "\fBLegacyXdrIO::FileFormat\fP \fBorig_flag\fP"
.br
.ti -1c
.RI "std::ifstream \fBmp_in\fP"
.br
.ti -1c
.RI "std::ofstream \fBmp_out\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBtokenize_first_line\fP (const char *p)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::FILE * \fBmp_fp\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class is taken directly from MGF\&. It facilitates reading and writing binary solution/mesh files using the \fCxdr\fP binary format, which allows for portable binary files across various platforms\&. For more information on the \fCxdr\fP format, see the standard C include file \fCrpc/rpc\&.h\fP\&.
.PP
\fBAuthor:\fP
.RS 4
Bill Barth, Robert McLay\&.
.RE
.PP
There are essentially two inheritance trees and six classes: \fBXdrMGF\fP \fBXdrHEAD\fP ^ ^ ^ ^ | | | | \fBXdrMESH\fP \fBXdrSOLN\fP \fBXdrMHEAD\fP \fBXdrSHEAD\fP
.PP
\fBXdrHEAD\fP, \fBXdrMHEAD\fP, and \fBXdrSHEAD\fP just read the headers of solution and mesh files\&.
.PP
\fBXdrMGF\fP, \fBXdrMESH\fP, and \fBXdrSOLN\fP handle the 'meat' of the files: everything other than the headers\&. 
.PP
Definition at line 85 of file xdr_mgf\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBlibMesh::XdrMGF::XdrIO_TYPE\fP"
This enum specifies the access permission which will be acquired for the current \fCxdr\fP file\&. Note that it is only possible to read (\fCDECODE\fP) or write (\fCENCODE\fP) but not both\&. For ASCII type files, use WRITE or READ instead! 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
.TP
\fB\fIENCODE \fP\fP
.TP
\fB\fIDECODE \fP\fP
.TP
\fB\fIW_ASCII \fP\fP
.TP
\fB\fIR_ASCII \fP\fP
.PP
Definition at line 98 of file xdr_mgf\&.h\&.
.PP
.nf
98                   {UNKNOWN = -1, ENCODE=0, DECODE,
99                    W_ASCII , R_ASCII};
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::XdrMGF::XdrMGF ()\fC [inline]\fP"
Constructor\&. Intializes the access type, \fCxdr\fP file handle, \fCxdr\fP file pointer, and originator flag\&. Zero is a good default value for the flag, since that is the DEAL identifier\&. The \fCxdr\fP file handle is a struct defined in the standard C header \fCrpc/rpc\&.h\fP\&. 
.PP
Definition at line 115 of file xdr_mgf\&.h\&.
.PP
.nf
115 : _num_levels(0), m_type(UNKNOWN), mp_xdr_handle(0), orig_flag(LegacyXdrIO::LIBM), mp_fp(0) {}
.fi
.SS "libMesh::XdrMGF::XdrMGF ()\fC [inline]\fP"

.PP
Definition at line 117 of file xdr_mgf\&.h\&.
.PP
.nf
117 : _num_levels(0), m_type(UNKNOWN), orig_flag(LegacyXdrIO::LIBM), mp_fp(0) {}
.fi
.SS "libMesh::XdrMGF::~XdrMGF ()\fC [virtual]\fP"
Destructor\&. Frees the memory which was allocated to contain several strings\&. 
.PP
Definition at line 28 of file xdr_mgf\&.C\&.
.PP
References fini()\&.
.PP
.nf
29 {
30   this->fini();
31 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "int libMesh::XdrMGF::dataBlk (int *array, intnumvar, intsize)"
Reads/Writes a block of \fCints\fP to/from the current \fCxdr\fP file/file handle\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP Pointer to data to be read/written 
.br
\fInumvar\fP The total number of variables (size of the array) 
.br
\fIsize\fP The size of each individual variable in the array 
.RE
.PP

.PP
Definition at line 278 of file xdr_mgf\&.C\&.
.PP
References DECODE, ENCODE, libMesh::libmesh_assert(), m_type, mp_in, mp_out, mp_xdr_handle, R_ASCII, and W_ASCII\&.
.PP
Referenced by libMesh::XdrMESH::BC(), libMesh::XdrMESH::coord(), libMesh::XdrMESH::Icon(), and libMesh::XdrSOLN::values()\&.
.PP
.nf
279 {
280   int totalSize = numvar*size;
281 
282   switch (m_type)
283     {
284 
285 #ifdef LIBMESH_HAVE_XDR
286 
287     case (XdrMGF::DECODE):
288     case (XdrMGF::ENCODE):
289       {
290         xdr_vector(mp_xdr_handle,
291                    (char *) &array[0],
292                    totalSize,
293                    sizeof(int),
294                    (xdrproc_t) xdr_int);
295         break;
296       }
297 
298 #endif
299 
300     case (XdrMGF::W_ASCII):
301       {
302         for (int i=0; i<size; i++)
303           {
304             for (int j=0; j<numvar; j++)
305               mp_out << array[i*numvar + j] << " ";
306 
307             mp_out << '\n';
308           }
309 
310         mp_out\&.flush();
311         break;
312       }
313 
314     case (XdrMGF::R_ASCII):
315       {
316         libmesh_assert (mp_in\&.good());
317 
318         for (int i=0; i<size; i++)
319           {
320             for (int j=0; j<numvar; j++)
321               {
322                 mp_in >> array[i*numvar + j];
323               }
324 
325             mp_in\&.ignore(); // Read newline
326           }
327 
328         break;
329       }
330 
331     default:
332       // Unknown access type
333       libmesh_error();
334     }
335 
336   return totalSize;
337 }
.fi
.SS "int libMesh::XdrMGF::dataBlk (\fBReal\fP *array, intnumvar, intsize)"
Read/Writes a block of \fCReals\fP to/from the current \fCxdr\fP file/file handle\&. 
.PP
Definition at line 341 of file xdr_mgf\&.C\&.
.PP
References DECODE, ENCODE, libMesh::libmesh_assert(), m_type, mp_in, mp_out, mp_xdr_handle, R_ASCII, libMesh::Real, and W_ASCII\&.
.PP
.nf
342 {
343   int totalSize = numvar*size;
344 
345   // If this function is called by coord(),
346   // numvar is the problem dimension, and
347   // size is the number of nodes in the problem\&.
348 
349   //libMesh::out << "Total amount of data to be written: " << totalSize << std::endl;
350 
351   switch (m_type)
352     {
353 
354 #ifdef LIBMESH_HAVE_XDR
355 
356     case (XdrMGF::DECODE):
357     case (XdrMGF::ENCODE):
358       {
359         // FIXME - this is probably broken for Real == long double
360         // RHS
361         xdr_vector(mp_xdr_handle,
362                    (char *) &array[0],
363                    totalSize,
364                    sizeof(Real),
365                    (xdrproc_t) xdr_REAL);
366       }
367 
368 #endif
369 
370     case (XdrMGF::W_ASCII):
371       {
372         // Save stream flags
373         std::ios_base::fmtflags out_flags = mp_out\&.flags();
374 
375         // We will use scientific notation with a precision of 16
376         // digits in the following output\&.  The desired precision and
377         // format will automatically determine the width\&.
378         mp_out << std::scientific
379                << std::setprecision(16);
380 
381         for (int i=0; i<size; i++)
382           {
383             for (int j=0; j<numvar; j++)
384               mp_out << array[i*numvar + j] << " \t";
385 
386             mp_out << '\n';
387           }
388 
389         // Restore stream flags
390         mp_out\&.flags(out_flags);
391 
392         mp_out\&.flush();
393         break;
394       }
395 
396     case (XdrMGF::R_ASCII):
397       {
398         libmesh_assert (mp_in\&.good());
399 
400         for (int i=0; i<size; i++)
401           {
402             libmesh_assert (mp_in\&.good());
403 
404             for (int j=0; j<numvar; j++)
405               mp_in >> array[i*numvar + j];
406 
407             mp_in\&.ignore(); // Read newline
408           }
409 
410         break;
411       }
412 
413     default:
414       // Unknown access type
415       libmesh_error();
416     }
417 
418   return totalSize;
419 }
.fi
.SS "void libMesh::XdrMGF::fini ()"
Finalizes operations on the current \fCxdr\fP file handle, and closes the \fCxdr\fP file\&.
.PP
Uses \fCxdr_destroy\fP found in \fCrpc/rpc\&.h\fP\&. 
.PP
Definition at line 35 of file xdr_mgf\&.C\&.
.PP
References mp_fp, and mp_xdr_handle\&.
.PP
Referenced by init(), and ~XdrMGF()\&.
.PP
.nf
36 {
37 
38 #ifdef LIBMESH_HAVE_XDR
39 
40   if (mp_xdr_handle)
41     {
42       //libMesh::out << "Destroying XDR file handle\&." << std::endl;
43       xdr_destroy(mp_xdr_handle);
44     }
45 
46   //libMesh::out << "Deleting the file handle pointer\&." << std::endl;
47   delete mp_xdr_handle;
48 
49   mp_xdr_handle = NULL;
50 
51 #endif
52 
53   if (mp_fp)
54     {
55       //libMesh::out << "Closing file\&." << std::endl;
56       std::fflush(mp_fp);
57       std::fclose(mp_fp);
58     }
59 
60   mp_fp = NULL;
61 }
.fi
.SS "unsigned int libMesh::XdrMGF::get_num_levels ()\fC [inline]\fP"
Get number of levels 
.PP
Definition at line 190 of file xdr_mgf\&.h\&.
.PP
References _num_levels\&.
.PP
Referenced by libMesh::XdrMESH::header(), init(), and libMesh::LegacyXdrIO::read_mesh()\&.
.PP
.nf
190 { return _num_levels; }
.fi
.SS "\fBLegacyXdrIO::FileFormat\fP libMesh::XdrMGF::get_orig_flag () const\fC [inline]\fP"
Get the originator flag\&. 
.PP
Definition at line 174 of file xdr_mgf\&.h\&.
.PP
References orig_flag\&.
.PP
Referenced by init(), libMesh::LegacyXdrIO::read_mesh(), and libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
174 { return orig_flag; }
.fi
.SS "void libMesh::XdrMGF::init (\fBXdrMGF::XdrIO_TYPE\fPt, const char *fn, const char *type, inticnt)"
Initialization of the \fCxdr\fP file\&. This function performs the following operations: {itemize}  Closes the old \fCxdr\fP file if necessary\&.
.PP
Creates a new \fCxdr\fP file name and opens this file\&.
.PP
Opens the appropriate \fCxdr\fP file handle\&.
.PP
Reads/Writes a signature to the file\&.
.PP
{itemize} 
.PP
Definition at line 68 of file xdr_mgf\&.C\&.
.PP
References libMesh::LegacyXdrIO::DEAL, DECODE, ENCODE, libMesh::err, fini(), get_num_levels(), get_orig_flag(), libMesh::LegacyXdrIO::LIBM, m_type, libMesh::LegacyXdrIO::MGF, mp_fp, mp_in, mp_out, mp_xdr_handle, libMesh::Quality::name(), orig_flag, libMesh::out, R_ASCII, tokenize_first_line(), and W_ASCII\&.
.PP
Referenced by libMesh::XdrSOLN::init(), and libMesh::XdrMESH::init()\&.
.PP
.nf
69 {
70   m_type=t;
71 
72   // Close old file if necessary
73   if (mp_fp) this->fini();
74 
75 
76   // Open file
77   switch (m_type)
78     {
79 
80 #ifdef LIBMESH_HAVE_XDR
81 
82     case (XdrMGF::ENCODE):
83     case (XdrMGF::DECODE):
84       {
85         mp_fp = fopen (fn, (m_type == ENCODE) ? "w" : "r");
86 
87         // Make sure the file is ready for use
88         if (!mp_fp)
89           {
90             libMesh::err << "XDR Error: Accessing file: "
91                          << fn
92                          << " failed\&."
93                          << std::endl;
94             libmesh_error();
95           }
96 
97         // Create the XDR handle
98         mp_xdr_handle = new XDR;
99         xdrstdio_create(mp_xdr_handle,
100                         mp_fp,
101                         ((m_type == ENCODE) ? XDR_ENCODE : XDR_DECODE));
102 
103         break;
104       }
105 
106 #endif
107 
108     case (XdrMGF::R_ASCII):
109       {
110         mp_in\&.open(fn, std::ios::in);
111 
112         // Make sure it opened correctly
113         if (!mp_in\&.good())
114           libmesh_file_error(fn);
115 
116         break;
117       }
118 
119     case (XdrMGF::W_ASCII):
120       {
121         mp_out\&.open(fn, std::ios::out);
122 
123         // Make sure it opened correctly
124         if (!mp_out\&.good())
125           libmesh_file_error(fn);
126 
127         break;
128       }
129 
130     default:
131       {
132         libMesh::out << "Unrecognized file access type!" << std::endl;
133         libmesh_error();
134       }
135     }
136 
137 
138 
139 
140 
141   // Read/Write the file signature
142   const int  bufLen = 12;
143   char       buf[bufLen+1];
144 
145   switch (m_type)
146     {
147 
148 #ifdef LIBMESH_HAVE_XDR
149 
150     case (XdrMGF::ENCODE):
151       {
152         char* p = &buf[0];
153         const LegacyXdrIO::FileFormat orig = this->get_orig_flag();
154 
155         std::ostringstream name;
156         if (orig == LegacyXdrIO::DEAL)
157           name << "DEAL 003:003";
158 
159         else if (orig == LegacyXdrIO::MGF)
160           name << "MGF  002:000";
161 
162         else if (orig == LegacyXdrIO::LIBM)
163           name << "LIBM " << this->get_num_levels();
164 
165         else
166           libmesh_error();
167 
168         // Fill the buffer
169         std::sprintf(&buf[0], "%s", name\&.str()\&.c_str());
170 
171         xdr_string(mp_xdr_handle, &p, bufLen);  // Writes binary signature
172 
173         break;
174       }
175 
176     case (XdrMGF::DECODE):
177       {
178         char* p = &buf[0];
179         xdr_string(mp_xdr_handle, &p, bufLen); // Reads binary signature
180 
181         // Set the number of levels used in the mesh
182         this->tokenize_first_line(p);
183 
184         break;
185       }
186 
187 #endif
188 
189     case (XdrMGF::W_ASCII):
190       {
191         const LegacyXdrIO::FileFormat orig = this->get_orig_flag();
192 
193         if (orig == LegacyXdrIO::DEAL)
194           std::sprintf(&buf[0], "%s %03d:%03d", "DEAL", 3, 3);
195 
196         else if (orig == LegacyXdrIO::MGF)
197           std::sprintf(&buf[0], "%s %03d:%03d", "MGF ", 2, 0);
198 
199         else if (orig == LegacyXdrIO::LIBM)
200           std::sprintf(&buf[0], "%s %d", "LIBM", this->get_num_levels());
201 
202         mp_out << buf << '\n';
203 
204         break;
205       }
206 
207     case (XdrMGF::R_ASCII):
208       {
209 
210 #ifdef __HP_aCC
211         // weirdly, _only_ here aCC
212         // is not fond of mp_in\&.getline()
213         // however, using mp_in\&.getline()
214         // further below is ok\&.\&.\&.
215         std::string buf_buf;
216         std::getline (mp_in, buf_buf, '\n');
217         libmesh_assert_less_equal (buf_buf\&.size(), bufLen);
218 
219         buf_buf\&.copy (buf, std::string::npos);
220 #else
221 
222         // Here we first use getline() to grab the very
223         // first line of the file into a char buffer\&.  Then
224         // this line is tokenized to look for:
225         // 1\&.) The name LIBM, which specifies the new Mesh style\&.
226         // 2\&.) The number of levels in the Mesh which is being read\&.
227         // Note that "buf" will be further processed below, here we
228         // are just attempting to get the number of levels\&.
229         mp_in\&.getline(buf, bufLen+1);
230 
231 #endif
232 
233         // Determine the number of levels in this mesh
234         this->tokenize_first_line(buf);
235 
236         break;
237       }
238 
239     default:
240       libmesh_error();
241     }
242 
243 
244 
245   // If you are reading or decoding, process the signature
246   if ((m_type == R_ASCII) || (m_type == DECODE))
247     {
248       char name[5];
249       std::strncpy(name, &buf[0], 4);
250       name[4] = '\0';
251 
252       if (std::strcmp (name, "DEAL") == 0)
253         {
254           this->orig_flag = LegacyXdrIO::DEAL; // 0 is the DEAL identifier by definition
255         }
256       else if (std::strcmp (name, "MGF ") == 0)
257         {
258           this->orig_flag = LegacyXdrIO::MGF; // 1 is the MGF identifier by definition
259         }
260       else if (std::strcmp (name, "LIBM") == 0)
261         {
262           this->orig_flag = LegacyXdrIO::LIBM; // the New and Improved XDA
263         }
264 
265       else
266         {
267           libMesh::err <<
268             "No originating software can be determined for header string '" <<
269             name << "'\&. Error\&." << std::endl;
270           libmesh_error();
271         }
272     }
273 
274 }
.fi
.SS "void libMesh::XdrMGF::set_num_levels (unsigned intnum_levels)\fC [inline]\fP"
Set number of levels 
.PP
Definition at line 185 of file xdr_mgf\&.h\&.
.PP
References _num_levels\&.
.PP
Referenced by libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
185 { _num_levels = num_levels; }
.fi
.SS "void libMesh::XdrMGF::set_orig_flag (\fBLegacyXdrIO::FileFormat\fPin_orig_flag)\fC [inline]\fP"
Set the originator flag\&. 
.PP
Definition at line 179 of file xdr_mgf\&.h\&.
.PP
References orig_flag\&.
.PP
Referenced by libMesh::LegacyXdrIO::read_mesh(), and libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
179 { orig_flag = in_orig_flag; }
.fi
.SS "void libMesh::XdrMGF::tokenize_first_line (const char *p)\fC [inline]\fP, \fC [private]\fP"
This function allows us to set the number of levels in the mesh when reading\&. 
.PP
Definition at line 258 of file xdr_mgf\&.h\&.
.PP
References _num_levels\&.
.PP
Referenced by init()\&.
.PP
.nf
259   {
260     std::string buf_str(p);
261     std::stringstream ss(buf_str);
262 
263     char token[256];
264     ss >> token;
265     if(std::strcmp(token,"LIBM") == 0)
266       {
267         ss >> token;
268         _num_levels = std::atoi(token);
269       }
270 
271   }
.fi
.SH "Member Data Documentation"
.PP 
.SS "unsigned int libMesh::XdrMGF::_num_levels\fC [protected]\fP"
Number of levels of refinement in the mesh 
.PP
Definition at line 197 of file xdr_mgf\&.h\&.
.PP
Referenced by get_num_levels(), set_num_levels(), and tokenize_first_line()\&.
.SS "\fBXdrIO_TYPE\fP libMesh::XdrMGF::m_type\fC [protected]\fP"
Specifies the read/write permission for the current \fCxdr\fP file\&. Possibilities are: {itemize}  \fCUNKNOWN\fP = -1  \fCENCODE\fP = 0  \fCDECODE\fP = 1 {itemize} 
.PP
Definition at line 210 of file xdr_mgf\&.h\&.
.PP
Referenced by dataBlk(), libMesh::XdrSOLN::header(), libMesh::XdrMESH::header(), and init()\&.
.SS "std::FILE* libMesh::XdrMGF::mp_fp\fC [private]\fP"

.PP
Definition at line 252 of file xdr_mgf\&.h\&.
.PP
Referenced by fini(), and init()\&.
.SS "std::ifstream libMesh::XdrMGF::mp_in\fC [protected]\fP"
An input file stream object 
.PP
Definition at line 244 of file xdr_mgf\&.h\&.
.PP
Referenced by dataBlk(), libMesh::XdrSOLN::header(), libMesh::XdrMESH::header(), and init()\&.
.SS "std::ofstream libMesh::XdrMGF::mp_out\fC [protected]\fP"
An output file stream object\&. 
.PP
Definition at line 249 of file xdr_mgf\&.h\&.
.PP
Referenced by dataBlk(), libMesh::XdrSOLN::header(), libMesh::XdrMESH::header(), and init()\&.
.SS "XDR* libMesh::XdrMGF::mp_xdr_handle\fC [protected]\fP"
Pointer to the standard \fC\fP{xdr} struct\&. See the standard header file \fCrpc/rpc\&.h\fP for more information\&. 
.PP
Definition at line 220 of file xdr_mgf\&.h\&.
.PP
Referenced by dataBlk(), fini(), libMesh::XdrSOLN::header(), libMesh::XdrMESH::header(), and init()\&.
.SS "\fBLegacyXdrIO::FileFormat\fP libMesh::XdrMGF::orig_flag\fC [protected]\fP"
Flag indicating how much checking we need to do\&. We can read in mgf meshes more quickly because there is only one type of element in these meshes\&. Deal meshes on the other hand will require a check for each element to find out what type it is\&. Possible values are: {itemize}  0: It's an DEAL style mesh  1: It's a MGF style mesh {itemize} 
.PP
Definition at line 239 of file xdr_mgf\&.h\&.
.PP
Referenced by get_orig_flag(), libMesh::XdrMESH::header(), init(), and set_orig_flag()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
