.TH "libMesh::FEGenericBase< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FEGenericBase< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <exact_error_estimator\&.h>\fP
.PP
Inherits \fBlibMesh::FEAbstract\fP\&.
.PP
Inherited by \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef OutputType \fBOutputShape\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputGradient\fP >::type \fBOutputTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputDivergence\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::MakeNumber\fP
.br
< \fBOutputShape\fP >::type \fBOutputNumber\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumberGradient\fP >::type \fBOutputNumberTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberDivergence\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~FEGenericBase\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputGradient\fP > > & \fBget_dphi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_curl_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputDivergence\fP > > & \fBget_div_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidx\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidy\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidxi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphideta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputTensor\fP > > & \fBget_d2phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidx2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdy\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidy2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidydz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidz2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phideta2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector
.br
< \fBOutputGradient\fP > & \fBget_dphase\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_Sobolev_weight\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_Sobolev_dweight\fP () const "
.br
.ti -1c
.RI "void \fBprint_phi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_dphi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_d2phi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP
.br
< \fBRealGradient\fP > > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP
.br
< \fBRealGradient\fP > > \fBbuild_InfFE\fP (const unsigned int, const \fBFEType\fP &)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const unsigned int \fBside\fP, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *pts=NULL, const std::vector< \fBReal\fP > *weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *elem, const \fBElem\fP *\fBside\fP, const unsigned int s, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)=0"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)=0"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const =0"
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const =0"
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static void \fBcompute_proj_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcoarsened_dof_values\fP (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &\fBdof_map\fP, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned int var, const bool use_old_dof_indices=false)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBFEGenericBase\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "virtual void \fBinit_base_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)=0"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)"
.br
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const =0"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBFETransformationBase\fP
.br
< OutputType > > \fB_fe_trans\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputGradient\fP > > \fBdphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBcurl_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputDivergence\fP > > \fBdiv_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidxi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidx\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputTensor\fP > > \fBd2phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxi2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phideta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidetadzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidzeta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidx2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidy2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidydz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidz2\fP"
.br
.ti -1c
.RI "std::vector< \fBOutputGradient\fP > \fBdphase\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdweight\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBweight\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> class \fBInfFE\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::FEGenericBase< T >"
This class forms the foundation from which generic finite elements may be derived\&. In the current implementation the templated derived class \fC\fBFE\fP\fP offers a wide variety of commonly used finite element concepts\&. Check there for details\&.
.PP
Use the \fC\fBFEGenericBase<OutputType>::build()\fP\fP method to create an object of any of the derived classes which is compatible with OutputType\&.
.PP
Note that the amount of virtual members is kept to a minimum, and the sophisticated template scheme of \fC\fBFE\fP\fP is quite likely to offer acceptably fast code\&.
.PP
All calls to static members of the \fC\fBFE\fP\fP classes should be requested through the \fC\fBFEInterface\fP\fP\&. This interface class offers sort-of runtime polymorphism for the templated finite element classes\&. Even internal library classes, like \fC\fBDofMap\fP\fP, request the number of dof's through this interface class\&. Note that this also enables the co-existence of various element-based schemes\&. This class is well 'at the heart' of the library, so things in here should better remain unchanged\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2002 
.RE
.PP

.PP
Definition at line 37 of file exact_error_estimator\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::DecrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputDivergence\fP"

.PP
Definition at line 138 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputGradient\fP"

.PP
Definition at line 136 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::MakeNumber\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumber\fP"

.PP
Definition at line 139 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::DecrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberDivergence\fP"

.PP
Definition at line 142 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberGradient\fP"

.PP
Definition at line 140 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumberGradient\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberTensor\fP"

.PP
Definition at line 141 of file fe_base\&.h\&.
.SS "template<typename T> typedef OutputType \fBlibMesh::FEGenericBase\fP< T >::\fBOutputShape\fP"
Convenient typedefs for gradients of output, hessians of output, and potentially-complex-valued versions of same\&. 
.PP
Definition at line 135 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputGradient\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputTensor\fP"

.PP
Definition at line 137 of file fe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename OutputType > \fBlibMesh::FEGenericBase\fP< OutputType >::\fBFEGenericBase\fP (const unsigned intdim, const \fBFEType\fP &fet)\fC [inline]\fP, \fC [protected]\fP"
Constructor\&. Optionally initializes required data structures\&. Protected so that this base class cannot be explicitly instantiated\&. 
.PP
Definition at line 672 of file fe_base\&.h\&.
.PP
.nf
673                                                             :
674   FEAbstract(d,fet),
675   _fe_trans( FETransformationBase<OutputType>::build(fet) ),
676   phi(),
677   dphi(),
678   curl_phi(),
679   div_phi(),
680   dphidxi(),
681   dphideta(),
682   dphidzeta(),
683   dphidx(),
684   dphidy(),
685   dphidz()
686 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
687   ,d2phi(),
688   d2phidxi2(),
689   d2phidxideta(),
690   d2phidxidzeta(),
691   d2phideta2(),
692   d2phidetadzeta(),
693   d2phidzeta2(),
694   d2phidx2(),
695   d2phidxdy(),
696   d2phidxdz(),
697   d2phidy2(),
698   d2phidydz(),
699   d2phidz2()
700 #endif
701 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
702   ,dphase(),
703   dweight(),
704   weight()
705 #endif
706 {
707 }
708 
709 
710 
711 template <typename OutputType>
712 inline
713 FEGenericBase<OutputType>::~FEGenericBase()
714 {
715 }
.fi
.SS "template<typename T> virtual \fBlibMesh::FEGenericBase\fP< T >::~\fBFEGenericBase\fP ()\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "virtual void libMesh::FEAbstract::attach_quadrature_rule (\fBQBase\fP *q)\fC [pure virtual]\fP, \fC [inherited]\fP"
Provides the class with the quadrature rule\&. Implement this in derived classes\&. 
.PP
Implemented in \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "template<typename T> static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< T >::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputType of this class is not compatible with the output required for the requested \fCtype\fP 
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::calculate_norm(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::for(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_face_shape_functions(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::HPCoarsenTest::select_refinement(), and libMesh::Elem::volume()\&.
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBlibMesh::FEGenericBase\fP< \fBReal\fP >::build (const unsigned intdim, const \fBFEType\fP &fet)"

.PP
Definition at line 184 of file fe_base\&.C\&.
.PP
References libMesh::BERNSTEIN, libMesh::CLOUGH, libMesh::FEType::family, libMesh::HERMITE, libMesh::HIERARCHIC, libMesh::L2_HIERARCHIC, libMesh::L2_LAGRANGE, libMesh::LAGRANGE, libMesh::MONOMIAL, libMesh::out, libMesh::SCALAR, libMesh::SUBDIVISION, libMesh::SZABAB, and libMesh::XYZ\&.
.PP
.nf
186 {
187   // The stupid AutoPtr<FEBase> ap(); return ap;
188   // construct is required to satisfy IBM's xlC
189 
190   switch (dim)
191     {
192       // 0D
193     case 0:
194       {
195         switch (fet\&.family)
196           {
197           case CLOUGH:
198             {
199               AutoPtr<FEBase> ap(new FE<0,CLOUGH>(fet));
200               return ap;
201             }
202 
203           case HERMITE:
204             {
205               AutoPtr<FEBase> ap(new FE<0,HERMITE>(fet));
206               return ap;
207             }
208 
209           case LAGRANGE:
210             {
211               AutoPtr<FEBase> ap(new FE<0,LAGRANGE>(fet));
212               return ap;
213             }
214 
215           case L2_LAGRANGE:
216             {
217               AutoPtr<FEBase> ap(new FE<0,L2_LAGRANGE>(fet));
218               return ap;
219             }
220 
221           case HIERARCHIC:
222             {
223               AutoPtr<FEBase> ap(new FE<0,HIERARCHIC>(fet));
224               return ap;
225             }
226 
227           case L2_HIERARCHIC:
228             {
229               AutoPtr<FEBase> ap(new FE<0,L2_HIERARCHIC>(fet));
230               return ap;
231             }
232 
233           case MONOMIAL:
234             {
235               AutoPtr<FEBase> ap(new FE<0,MONOMIAL>(fet));
236               return ap;
237             }
238 
239 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
240           case SZABAB:
241             {
242               AutoPtr<FEBase> ap(new FE<0,SZABAB>(fet));
243               return ap;
244             }
245 
246           case BERNSTEIN:
247             {
248               AutoPtr<FEBase> ap(new FE<0,BERNSTEIN>(fet));
249               return ap;
250             }
251 #endif
252 
253           case XYZ:
254             {
255               AutoPtr<FEBase> ap(new FEXYZ<0>(fet));
256               return ap;
257             }
258 
259           case SCALAR:
260             {
261               AutoPtr<FEBase> ap(new FEScalar<0>(fet));
262               return ap;
263             }
264 
265           default:
266             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
267             libmesh_error();
268           }
269       }
270       // 1D
271     case 1:
272       {
273         switch (fet\&.family)
274           {
275           case CLOUGH:
276             {
277               AutoPtr<FEBase> ap(new FE<1,CLOUGH>(fet));
278               return ap;
279             }
280 
281           case HERMITE:
282             {
283               AutoPtr<FEBase> ap(new FE<1,HERMITE>(fet));
284               return ap;
285             }
286 
287           case LAGRANGE:
288             {
289               AutoPtr<FEBase> ap(new FE<1,LAGRANGE>(fet));
290               return ap;
291             }
292 
293           case L2_LAGRANGE:
294             {
295               AutoPtr<FEBase> ap(new FE<1,L2_LAGRANGE>(fet));
296               return ap;
297             }
298 
299           case HIERARCHIC:
300             {
301               AutoPtr<FEBase> ap(new FE<1,HIERARCHIC>(fet));
302               return ap;
303             }
304 
305           case L2_HIERARCHIC:
306             {
307               AutoPtr<FEBase> ap(new FE<1,L2_HIERARCHIC>(fet));
308               return ap;
309             }
310 
311           case MONOMIAL:
312             {
313               AutoPtr<FEBase> ap(new FE<1,MONOMIAL>(fet));
314               return ap;
315             }
316 
317 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
318           case SZABAB:
319             {
320               AutoPtr<FEBase> ap(new FE<1,SZABAB>(fet));
321               return ap;
322             }
323 
324           case BERNSTEIN:
325             {
326               AutoPtr<FEBase> ap(new FE<1,BERNSTEIN>(fet));
327               return ap;
328             }
329 #endif
330 
331           case XYZ:
332             {
333               AutoPtr<FEBase> ap(new FEXYZ<1>(fet));
334               return ap;
335             }
336 
337           case SCALAR:
338             {
339               AutoPtr<FEBase> ap(new FEScalar<1>(fet));
340               return ap;
341             }
342 
343           default:
344             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
345             libmesh_error();
346           }
347       }
348 
349 
350       // 2D
351     case 2:
352       {
353         switch (fet\&.family)
354           {
355           case CLOUGH:
356             {
357               AutoPtr<FEBase> ap(new FE<2,CLOUGH>(fet));
358               return ap;
359             }
360 
361           case HERMITE:
362             {
363               AutoPtr<FEBase> ap(new FE<2,HERMITE>(fet));
364               return ap;
365             }
366 
367           case LAGRANGE:
368             {
369               AutoPtr<FEBase> ap(new FE<2,LAGRANGE>(fet));
370               return ap;
371             }
372 
373           case L2_LAGRANGE:
374             {
375               AutoPtr<FEBase> ap(new FE<2,L2_LAGRANGE>(fet));
376               return ap;
377             }
378 
379           case HIERARCHIC:
380             {
381               AutoPtr<FEBase> ap(new FE<2,HIERARCHIC>(fet));
382               return ap;
383             }
384 
385           case L2_HIERARCHIC:
386             {
387               AutoPtr<FEBase> ap(new FE<2,L2_HIERARCHIC>(fet));
388               return ap;
389             }
390 
391           case MONOMIAL:
392             {
393               AutoPtr<FEBase> ap(new FE<2,MONOMIAL>(fet));
394               return ap;
395             }
396 
397 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
398           case SZABAB:
399             {
400               AutoPtr<FEBase> ap(new FE<2,SZABAB>(fet));
401               return ap;
402             }
403 
404           case BERNSTEIN:
405             {
406               AutoPtr<FEBase> ap(new FE<2,BERNSTEIN>(fet));
407               return ap;
408             }
409 #endif
410 
411           case XYZ:
412             {
413               AutoPtr<FEBase> ap(new FEXYZ<2>(fet));
414               return ap;
415             }
416 
417           case SCALAR:
418             {
419               AutoPtr<FEBase> ap(new FEScalar<2>(fet));
420               return ap;
421             }
422 
423           case SUBDIVISION:
424             {
425               AutoPtr<FEBase> ap(new FESubdivision(fet));
426               return ap;
427             }
428 
429           default:
430             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
431             libmesh_error();
432           }
433       }
434 
435 
436       // 3D
437     case 3:
438       {
439         switch (fet\&.family)
440           {
441           case CLOUGH:
442             {
443               libMesh::out << "ERROR: Clough-Tocher elements currently only support 1D and 2D"
444                            << std::endl;
445               libmesh_error();
446             }
447 
448           case HERMITE:
449             {
450               AutoPtr<FEBase> ap(new FE<3,HERMITE>(fet));
451               return ap;
452             }
453 
454           case LAGRANGE:
455             {
456               AutoPtr<FEBase> ap(new FE<3,LAGRANGE>(fet));
457               return ap;
458             }
459 
460           case L2_LAGRANGE:
461             {
462               AutoPtr<FEBase> ap(new FE<3,L2_LAGRANGE>(fet));
463               return ap;
464             }
465 
466           case HIERARCHIC:
467             {
468               AutoPtr<FEBase> ap(new FE<3,HIERARCHIC>(fet));
469               return ap;
470             }
471 
472           case L2_HIERARCHIC:
473             {
474               AutoPtr<FEBase> ap(new FE<3,L2_HIERARCHIC>(fet));
475               return ap;
476             }
477 
478           case MONOMIAL:
479             {
480               AutoPtr<FEBase> ap(new FE<3,MONOMIAL>(fet));
481               return ap;
482             }
483 
484 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
485           case SZABAB:
486             {
487               AutoPtr<FEBase> ap(new FE<3,SZABAB>(fet));
488               return ap;
489             }
490 
491           case BERNSTEIN:
492             {
493               AutoPtr<FEBase> ap(new FE<3,BERNSTEIN>(fet));
494               return ap;
495             }
496 #endif
497 
498           case XYZ:
499             {
500               AutoPtr<FEBase> ap(new FEXYZ<3>(fet));
501               return ap;
502             }
503 
504           case SCALAR:
505             {
506               AutoPtr<FEBase> ap(new FEScalar<3>(fet));
507               return ap;
508             }
509 
510           default:
511             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
512             libmesh_error();
513           }
514       }
515 
516     default:
517       libmesh_error();
518     }
519 
520   libmesh_error();
521   AutoPtr<FEBase> ap(NULL);
522   return ap;
523 }
.fi
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBRealGradient\fP > > \fBlibMesh::FEGenericBase\fP< \fBRealGradient\fP >::build (const unsigned intdim, const \fBFEType\fP &fet)"

.PP
Definition at line 529 of file fe_base\&.C\&.
.PP
References libMesh::FEType::family, libMesh::LAGRANGE_VEC, libMesh::NEDELEC_ONE, and libMesh::out\&.
.PP
.nf
531 {
532   // The stupid AutoPtr<FEBase> ap(); return ap;
533   // construct is required to satisfy IBM's xlC
534 
535   switch (dim)
536     {
537       // 0D
538     case 0:
539       {
540         switch (fet\&.family)
541           {
542           case LAGRANGE_VEC:
543             {
544               AutoPtr<FEVectorBase> ap( new FELagrangeVec<0>(fet) );
545               return ap;
546             }
547           default:
548             {
549               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
550               libmesh_error();
551             }
552           }
553       }
554     case 1:
555       {
556         switch (fet\&.family)
557           {
558           case LAGRANGE_VEC:
559             {
560               AutoPtr<FEVectorBase> ap( new FELagrangeVec<1>(fet) );
561               return ap;
562             }
563           default:
564             {
565               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
566               libmesh_error();
567             }
568           }
569       }
570     case 2:
571       {
572         switch (fet\&.family)
573           {
574           case LAGRANGE_VEC:
575             {
576               AutoPtr<FEVectorBase> ap( new FELagrangeVec<2>(fet) );
577               return ap;
578             }
579           case NEDELEC_ONE:
580             {
581               AutoPtr<FEVectorBase> ap( new FENedelecOne<2>(fet) );
582               return ap;
583             }
584           default:
585             {
586               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
587               libmesh_error();
588             }
589           }
590       }
591     case 3:
592       {
593         switch (fet\&.family)
594           {
595           case LAGRANGE_VEC:
596             {
597               AutoPtr<FEVectorBase> ap( new FELagrangeVec<3>(fet) );
598               return ap;
599             }
600           case NEDELEC_ONE:
601             {
602               AutoPtr<FEVectorBase> ap( new FENedelecOne<3>(fet) );
603               return ap;
604             }
605           default:
606             {
607               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
608               libmesh_error();
609             }
610           }
611       }
612 
613     default:
614       libmesh_error();
615 
616     } // switch(dim)
617 
618   libmesh_error();
619   AutoPtr<FEVectorBase> ap(NULL);
620   return ap;
621 }
.fi
.SS "template<typename T> static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< T >::build_InfFE (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP"
Builds a specific infinite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputShape of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBlibMesh::FEGenericBase\fP< \fBReal\fP >::build_InfFE (const unsigned intdim, const \fBFEType\fP &fet)"

.PP
Definition at line 634 of file fe_base\&.C\&.
.PP
References libMesh::CARTESIAN, libMesh::err, libMesh::FEType::inf_map, libMesh::INFINITE_MAP, libMesh::JACOBI_20_00, libMesh::JACOBI_30_00, libMesh::LAGRANGE, libMesh::LEGENDRE, and libMesh::FEType::radial_family\&.
.PP
.nf
636 {
637   // The stupid AutoPtr<FEBase> ap(); return ap;
638   // construct is required to satisfy IBM's xlC
639 
640   switch (dim)
641     {
642 
643       // 1D
644     case 1:
645       {
646         switch (fet\&.radial_family)
647           {
648           case INFINITE_MAP:
649             {
650               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
651                            << " with FEFamily = " << fet\&.radial_family << std::endl;
652               libmesh_error();
653             }
654 
655           case JACOBI_20_00:
656             {
657               switch (fet\&.inf_map)
658                 {
659                 case CARTESIAN:
660                   {
661                     AutoPtr<FEBase> ap(new InfFE<1,JACOBI_20_00,CARTESIAN>(fet));
662                     return ap;
663                   }
664                 default:
665                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
666                                << " with InfMapType = " << fet\&.inf_map << std::endl;
667                   libmesh_error();
668                 }
669             }
670 
671           case JACOBI_30_00:
672             {
673               switch (fet\&.inf_map)
674                 {
675                 case CARTESIAN:
676                   {
677                     AutoPtr<FEBase> ap(new InfFE<1,JACOBI_30_00,CARTESIAN>(fet));
678                     return ap;
679                   }
680                 default:
681                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
682                                << " with InfMapType = " << fet\&.inf_map << std::endl;
683                   libmesh_error();
684                 }
685             }
686 
687           case LEGENDRE:
688             {
689               switch (fet\&.inf_map)
690                 {
691                 case CARTESIAN:
692                   {
693                     AutoPtr<FEBase> ap(new InfFE<1,LEGENDRE,CARTESIAN>(fet));
694                     return ap;
695                   }
696                 default:
697                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
698                                << " with InfMapType = " << fet\&.inf_map << std::endl;
699                   libmesh_error();
700                 }
701             }
702 
703           case LAGRANGE:
704             {
705               switch (fet\&.inf_map)
706                 {
707                 case CARTESIAN:
708                   {
709                     AutoPtr<FEBase> ap(new InfFE<1,LAGRANGE,CARTESIAN>(fet));
710                     return ap;
711                   }
712                 default:
713                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
714                                << " with InfMapType = " << fet\&.inf_map << std::endl;
715                   libmesh_error();
716                 }
717             }
718 
719 
720 
721           default:
722             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
723             libmesh_error();
724           }
725 
726       }
727 
728 
729 
730 
731       // 2D
732     case 2:
733       {
734         switch (fet\&.radial_family)
735           {
736           case INFINITE_MAP:
737             {
738               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
739                            << " with FEFamily = " << fet\&.radial_family << std::endl;
740               libmesh_error();
741             }
742 
743           case JACOBI_20_00:
744             {
745               switch (fet\&.inf_map)
746                 {
747                 case CARTESIAN:
748                   {
749                     AutoPtr<FEBase> ap(new InfFE<2,JACOBI_20_00,CARTESIAN>(fet));
750                     return ap;
751                   }
752                 default:
753                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
754                                << " with InfMapType = " << fet\&.inf_map << std::endl;
755                   libmesh_error();
756                 }
757             }
758 
759           case JACOBI_30_00:
760             {
761               switch (fet\&.inf_map)
762                 {
763                 case CARTESIAN:
764                   {
765                     AutoPtr<FEBase> ap(new InfFE<2,JACOBI_30_00,CARTESIAN>(fet));
766                     return ap;
767                   }
768                 default:
769                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
770                                << " with InfMapType = " << fet\&.inf_map << std::endl;
771                   libmesh_error();
772                 }
773             }
774 
775           case LEGENDRE:
776             {
777               switch (fet\&.inf_map)
778                 {
779                 case CARTESIAN:
780                   {
781                     AutoPtr<FEBase> ap(new InfFE<2,LEGENDRE,CARTESIAN>(fet));
782                     return ap;
783                   }
784                 default:
785                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
786                                << " with InfMapType = " << fet\&.inf_map << std::endl;
787                   libmesh_error();
788                 }
789             }
790 
791           case LAGRANGE:
792             {
793               switch (fet\&.inf_map)
794                 {
795                 case CARTESIAN:
796                   {
797                     AutoPtr<FEBase> ap(new InfFE<2,LAGRANGE,CARTESIAN>(fet));
798                     return ap;
799                   }
800                 default:
801                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
802                                << " with InfMapType = " << fet\&.inf_map << std::endl;
803                   libmesh_error();
804                 }
805             }
806 
807 
808 
809           default:
810             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
811             libmesh_error();
812           }
813 
814       }
815 
816 
817 
818 
819       // 3D
820     case 3:
821       {
822         switch (fet\&.radial_family)
823           {
824           case INFINITE_MAP:
825             {
826               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
827                            << " with FEFamily = " << fet\&.radial_family << std::endl;
828               libmesh_error();
829             }
830 
831           case JACOBI_20_00:
832             {
833               switch (fet\&.inf_map)
834                 {
835                 case CARTESIAN:
836                   {
837                     AutoPtr<FEBase> ap(new InfFE<3,JACOBI_20_00,CARTESIAN>(fet));
838                     return ap;
839                   }
840                 default:
841                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
842                                << " with InfMapType = " << fet\&.inf_map << std::endl;
843                   libmesh_error();
844                 }
845             }
846 
847           case JACOBI_30_00:
848             {
849               switch (fet\&.inf_map)
850                 {
851                 case CARTESIAN:
852                   {
853                     AutoPtr<FEBase> ap(new InfFE<3,JACOBI_30_00,CARTESIAN>(fet));
854                     return ap;
855                   }
856                 default:
857                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
858                                << " with InfMapType = " << fet\&.inf_map << std::endl;
859                   libmesh_error();
860                 }
861             }
862 
863           case LEGENDRE:
864             {
865               switch (fet\&.inf_map)
866                 {
867                 case CARTESIAN:
868                   {
869                     AutoPtr<FEBase> ap(new InfFE<3,LEGENDRE,CARTESIAN>(fet));
870                     return ap;
871                   }
872                 default:
873                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
874                                << " with InfMapType = " << fet\&.inf_map << std::endl;
875                   libmesh_error();
876                 }
877             }
878 
879           case LAGRANGE:
880             {
881               switch (fet\&.inf_map)
882                 {
883                 case CARTESIAN:
884                   {
885                     AutoPtr<FEBase> ap(new InfFE<3,LAGRANGE,CARTESIAN>(fet));
886                     return ap;
887                   }
888                 default:
889                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
890                                << " with InfMapType = " << fet\&.inf_map << std::endl;
891                   libmesh_error();
892                 }
893             }
894 
895 
896 
897           default:
898             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
899             libmesh_error();
900           }
901       }
902 
903     default:
904       libmesh_error();
905     }
906 
907   libmesh_error();
908   AutoPtr<FEBase> ap(NULL);
909   return ap;
910 }
.fi
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBRealGradient\fP > > \fBlibMesh::FEGenericBase\fP< \fBRealGradient\fP >::build_InfFE (const unsignedint, const \fBFEType\fP &)"

.PP
Definition at line 916 of file fe_base\&.C\&.
.PP
.nf
918 {
919   // No vector types defined\&.\&.\&. YET\&.
920   libmesh_error();
921   AutoPtr<FEVectorBase> ap(NULL);
922   return ap;
923 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::coarsened_dof_values (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &dof_map, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned intvar, const booluse_old_dof_indices = \fCfalse\fP)\fC [static]\fP"
Creates a local projection on \fCcoarse_elem\fP, based on the DoF values in \fCglobal_vector\fP for it's children\&. 
.PP
Definition at line 1036 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::C_ONE, libMesh::Elem::child(), libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::FEType::default_quadrature_rule(), libMesh::dim, libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::FEInterface::dofs_on_edge(), libMesh::FEInterface::dofs_on_side(), libMesh::TensorTools::inner_product(), libMesh::FEInterface::inverse_map(), libMesh::Elem::is_child_on_edge(), libMesh::Elem::is_child_on_side(), libMesh::Elem::is_vertex(), libMesh::libmesh_assert(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::n_children(), libMesh::FEInterface::n_dofs(), libMesh::FEInterface::n_dofs_at_node(), libMesh::Elem::n_edges(), n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::DofMap::old_dof_indices(), libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::TOLERANCE, libMesh::Elem::type(), libMesh::DofMap::variable_type(), libMesh::DenseMatrix< T >::zero(), libMesh::DenseVector< T >::zero(), and libMesh::zero\&.
.PP
Referenced by libMesh::JumpErrorEstimator::estimate_error(), and libMesh::for()\&.
.PP
.nf
1042 {
1043   // Side/edge local DOF indices
1044   std::vector<unsigned int> new_side_dofs, old_side_dofs;
1045 
1046   // FIXME: what about 2D shells in 3D space?
1047   unsigned int dim = elem->dim();
1048 
1049   // We use local FE objects for now
1050   // FIXME: we should use more, external objects instead for efficiency
1051   const FEType& base_fe_type = dof_map\&.variable_type(var);
1052   AutoPtr<FEGenericBase<OutputShape> > fe
1053     (FEGenericBase<OutputShape>::build(dim, base_fe_type));
1054   AutoPtr<FEGenericBase<OutputShape> > fe_coarse
1055     (FEGenericBase<OutputShape>::build(dim, base_fe_type));
1056 
1057   AutoPtr<QBase> qrule     (base_fe_type\&.default_quadrature_rule(dim));
1058   AutoPtr<QBase> qedgerule (base_fe_type\&.default_quadrature_rule(1));
1059   AutoPtr<QBase> qsiderule (base_fe_type\&.default_quadrature_rule(dim-1));
1060   std::vector<Point> coarse_qpoints;
1061 
1062   // The values of the shape functions at the quadrature
1063   // points
1064   const std::vector<std::vector<OutputShape> >& phi_values =
1065     fe->get_phi();
1066   const std::vector<std::vector<OutputShape> >& phi_coarse =
1067     fe_coarse->get_phi();
1068 
1069   // The gradients of the shape functions at the quadrature
1070   // points on the child element\&.
1071   const std::vector<std::vector<OutputGradient> > *dphi_values =
1072     NULL;
1073   const std::vector<std::vector<OutputGradient> > *dphi_coarse =
1074     NULL;
1075 
1076   const FEContinuity cont = fe->get_continuity();
1077 
1078   if (cont == C_ONE)
1079     {
1080       const std::vector<std::vector<OutputGradient> >&
1081         ref_dphi_values = fe->get_dphi();
1082       dphi_values = &ref_dphi_values;
1083       const std::vector<std::vector<OutputGradient> >&
1084         ref_dphi_coarse = fe_coarse->get_dphi();
1085       dphi_coarse = &ref_dphi_coarse;
1086     }
1087 
1088   // The Jacobian * quadrature weight at the quadrature points
1089   const std::vector<Real>& JxW =
1090     fe->get_JxW();
1091 
1092   // The XYZ locations of the quadrature points on the
1093   // child element
1094   const std::vector<Point>& xyz_values =
1095     fe->get_xyz();
1096 
1097 
1098 
1099   FEType fe_type = base_fe_type, temp_fe_type;
1100   const ElemType elem_type = elem->type();
1101   fe_type\&.order = static_cast<Order>(fe_type\&.order +
1102                                      elem->max_descendant_p_level());
1103 
1104   // Number of nodes on parent element
1105   const unsigned int n_nodes = elem->n_nodes();
1106 
1107   // Number of dofs on parent element
1108   const unsigned int new_n_dofs =
1109     FEInterface::n_dofs(dim, fe_type, elem_type);
1110 
1111   // Fixed vs\&. free DoFs on edge/face projections
1112   std::vector<char> dof_is_fixed(new_n_dofs, false); // bools
1113   std::vector<int> free_dof(new_n_dofs, 0);
1114 
1115   DenseMatrix<Real> Ke;
1116   DenseVector<Number> Fe;
1117   Ue\&.resize(new_n_dofs); Ue\&.zero();
1118 
1119 
1120   // When coarsening, in general, we need a series of
1121   // projections to ensure a unique and continuous
1122   // solution\&.  We start by interpolating nodes, then
1123   // hold those fixed and project edges, then
1124   // hold those fixed and project faces, then
1125   // hold those fixed and project interiors
1126 
1127   // Copy node values first
1128   {
1129     std::vector<dof_id_type> node_dof_indices;
1130     if (use_old_dof_indices)
1131       dof_map\&.old_dof_indices (elem, node_dof_indices, var);
1132     else
1133       dof_map\&.dof_indices (elem, node_dof_indices, var);
1134 
1135     unsigned int current_dof = 0;
1136     for (unsigned int n=0; n!= n_nodes; ++n)
1137       {
1138         // FIXME: this should go through the DofMap,
1139         // not duplicate dof_indices code badly!
1140         const unsigned int my_nc =
1141           FEInterface::n_dofs_at_node (dim, fe_type,
1142                                        elem_type, n);
1143         if (!elem->is_vertex(n))
1144           {
1145             current_dof += my_nc;
1146             continue;
1147           }
1148 
1149         temp_fe_type = base_fe_type;
1150         // We're assuming here that child n shares vertex n,
1151         // which is wrong on non-simplices right now
1152         // \&.\&.\&. but this code isn't necessary except on elements
1153         // where p refinement creates more vertex dofs; we have
1154         // no such elements yet\&.
1155         /*
1156           if (elem->child(n)->p_level() < elem->p_level())
1157           {
1158           temp_fe_type\&.order =
1159           static_cast<Order>(temp_fe_type\&.order +
1160           elem->child(n)->p_level());
1161           }
1162         */
1163         const unsigned int nc =
1164           FEInterface::n_dofs_at_node (dim, temp_fe_type,
1165                                        elem_type, n);
1166         for (unsigned int i=0; i!= nc; ++i)
1167           {
1168             Ue(current_dof) =
1169               old_vector(node_dof_indices[current_dof]);
1170             dof_is_fixed[current_dof] = true;
1171             current_dof++;
1172           }
1173       }
1174   }
1175 
1176   // In 3D, project any edge values next
1177   if (dim > 2 && cont != DISCONTINUOUS)
1178     for (unsigned int e=0; e != elem->n_edges(); ++e)
1179       {
1180         FEInterface::dofs_on_edge(elem, dim, fe_type,
1181                                   e, new_side_dofs);
1182 
1183         // Some edge dofs are on nodes and already
1184         // fixed, others are free to calculate
1185         unsigned int free_dofs = 0;
1186         for (unsigned int i=0; i !=
1187                new_side_dofs\&.size(); ++i)
1188           if (!dof_is_fixed[new_side_dofs[i]])
1189             free_dof[free_dofs++] = i;
1190         Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1191         Fe\&.resize (free_dofs); Fe\&.zero();
1192         // The new edge coefficients
1193         DenseVector<Number> Uedge(free_dofs);
1194 
1195         // Add projection terms from each child sharing
1196         // this edge
1197         for (unsigned int c=0; c != elem->n_children();
1198              ++c)
1199           {
1200             if (!elem->is_child_on_edge(c,e))
1201               continue;
1202             Elem *child = elem->child(c);
1203 
1204             std::vector<dof_id_type> child_dof_indices;
1205             if (use_old_dof_indices)
1206               dof_map\&.old_dof_indices (child,
1207                                        child_dof_indices, var);
1208             else
1209               dof_map\&.dof_indices (child,
1210                                    child_dof_indices, var);
1211             const unsigned int child_n_dofs =
1212               libmesh_cast_int<unsigned int>
1213               (child_dof_indices\&.size());
1214 
1215             temp_fe_type = base_fe_type;
1216             temp_fe_type\&.order =
1217               static_cast<Order>(temp_fe_type\&.order +
1218                                  child->p_level());
1219 
1220             FEInterface::dofs_on_edge(child, dim,
1221                                       temp_fe_type, e, old_side_dofs);
1222 
1223             // Initialize both child and parent FE data
1224             // on the child's edge
1225             fe->attach_quadrature_rule (qedgerule\&.get());
1226             fe->edge_reinit (child, e);
1227             const unsigned int n_qp = qedgerule->n_points();
1228 
1229             FEInterface::inverse_map (dim, fe_type, elem,
1230                                       xyz_values, coarse_qpoints);
1231 
1232             fe_coarse->reinit(elem, &coarse_qpoints);
1233 
1234             // Loop over the quadrature points
1235             for (unsigned int qp=0; qp<n_qp; qp++)
1236               {
1237                 // solution value at the quadrature point
1238                 OutputNumber fineval = libMesh::zero;
1239                 // solution grad at the quadrature point
1240                 OutputNumberGradient finegrad;
1241 
1242                 // Sum the solution values * the DOF
1243                 // values at the quadrature point to
1244                 // get the solution value and gradient\&.
1245                 for (unsigned int i=0; i<child_n_dofs;
1246                      i++)
1247                   {
1248                     fineval +=
1249                       (old_vector(child_dof_indices[i])*
1250                        phi_values[i][qp]);
1251                     if (cont == C_ONE)
1252                       finegrad += (*dphi_values)[i][qp] *
1253                         old_vector(child_dof_indices[i]);
1254                   }
1255 
1256                 // Form edge projection matrix
1257                 for (unsigned int sidei=0, freei=0;
1258                      sidei != new_side_dofs\&.size();
1259                      ++sidei)
1260                   {
1261                     unsigned int i = new_side_dofs[sidei];
1262                     // fixed DoFs aren't test functions
1263                     if (dof_is_fixed[i])
1264                       continue;
1265                     for (unsigned int sidej=0, freej=0;
1266                          sidej != new_side_dofs\&.size();
1267                          ++sidej)
1268                       {
1269                         unsigned int j =
1270                           new_side_dofs[sidej];
1271                         if (dof_is_fixed[j])
1272                           Fe(freei) -=
1273                             TensorTools::inner_product(phi_coarse[i][qp],
1274                                                        phi_coarse[j][qp]) *
1275                             JxW[qp] * Ue(j);
1276                         else
1277                           Ke(freei,freej) +=
1278                             TensorTools::inner_product(phi_coarse[i][qp],
1279                                                        phi_coarse[j][qp]) *
1280                             JxW[qp];
1281                         if (cont == C_ONE)
1282                           {
1283                             if (dof_is_fixed[j])
1284                               Fe(freei) -=
1285                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1286                                                            (*dphi_coarse)[j][qp]) *
1287                                 JxW[qp] * Ue(j);
1288                             else
1289                               Ke(freei,freej) +=
1290                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1291                                                            (*dphi_coarse)[j][qp]) *
1292                                 JxW[qp];
1293                           }
1294                         if (!dof_is_fixed[j])
1295                           freej++;
1296                       }
1297                     Fe(freei) += TensorTools::inner_product(phi_coarse[i][qp],
1298                                                             fineval) * JxW[qp];
1299                     if (cont == C_ONE)
1300                       Fe(freei) +=
1301                         TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1302                     freei++;
1303                   }
1304               }
1305           }
1306         Ke\&.cholesky_solve(Fe, Uedge);
1307 
1308         // Transfer new edge solutions to element
1309         for (unsigned int i=0; i != free_dofs; ++i)
1310           {
1311             Number &ui = Ue(new_side_dofs[free_dof[i]]);
1312             libmesh_assert(std::abs(ui) < TOLERANCE ||
1313                            std::abs(ui - Uedge(i)) < TOLERANCE);
1314             ui = Uedge(i);
1315             dof_is_fixed[new_side_dofs[free_dof[i]]] =
1316               true;
1317           }
1318       }
1319 
1320   // Project any side values (edges in 2D, faces in 3D)
1321   if (dim > 1 && cont != DISCONTINUOUS)
1322     for (unsigned int s=0; s != elem->n_sides(); ++s)
1323       {
1324         FEInterface::dofs_on_side(elem, dim, fe_type,
1325                                   s, new_side_dofs);
1326 
1327         // Some side dofs are on nodes/edges and already
1328         // fixed, others are free to calculate
1329         unsigned int free_dofs = 0;
1330         for (unsigned int i=0; i !=
1331                new_side_dofs\&.size(); ++i)
1332           if (!dof_is_fixed[new_side_dofs[i]])
1333             free_dof[free_dofs++] = i;
1334         Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1335         Fe\&.resize (free_dofs); Fe\&.zero();
1336         // The new side coefficients
1337         DenseVector<Number> Uside(free_dofs);
1338 
1339         // Add projection terms from each child sharing
1340         // this side
1341         for (unsigned int c=0; c != elem->n_children();
1342              ++c)
1343           {
1344             if (!elem->is_child_on_side(c,s))
1345               continue;
1346             Elem *child = elem->child(c);
1347 
1348             std::vector<dof_id_type> child_dof_indices;
1349             if (use_old_dof_indices)
1350               dof_map\&.old_dof_indices (child,
1351                                        child_dof_indices, var);
1352             else
1353               dof_map\&.dof_indices (child,
1354                                    child_dof_indices, var);
1355             const unsigned int child_n_dofs =
1356               libmesh_cast_int<unsigned int>
1357               (child_dof_indices\&.size());
1358 
1359             temp_fe_type = base_fe_type;
1360             temp_fe_type\&.order =
1361               static_cast<Order>(temp_fe_type\&.order +
1362                                  child->p_level());
1363 
1364             FEInterface::dofs_on_side(child, dim,
1365                                       temp_fe_type, s, old_side_dofs);
1366 
1367             // Initialize both child and parent FE data
1368             // on the child's side
1369             fe->attach_quadrature_rule (qsiderule\&.get());
1370             fe->reinit (child, s);
1371             const unsigned int n_qp = qsiderule->n_points();
1372 
1373             FEInterface::inverse_map (dim, fe_type, elem,
1374                                       xyz_values, coarse_qpoints);
1375 
1376             fe_coarse->reinit(elem, &coarse_qpoints);
1377 
1378             // Loop over the quadrature points
1379             for (unsigned int qp=0; qp<n_qp; qp++)
1380               {
1381                 // solution value at the quadrature point
1382                 OutputNumber fineval = libMesh::zero;
1383                 // solution grad at the quadrature point
1384                 OutputNumberGradient finegrad;
1385 
1386                 // Sum the solution values * the DOF
1387                 // values at the quadrature point to
1388                 // get the solution value and gradient\&.
1389                 for (unsigned int i=0; i<child_n_dofs;
1390                      i++)
1391                   {
1392                     fineval +=
1393                       old_vector(child_dof_indices[i]) *
1394                       phi_values[i][qp];
1395                     if (cont == C_ONE)
1396                       finegrad += (*dphi_values)[i][qp] *
1397                         old_vector(child_dof_indices[i]);
1398                   }
1399 
1400                 // Form side projection matrix
1401                 for (unsigned int sidei=0, freei=0;
1402                      sidei != new_side_dofs\&.size();
1403                      ++sidei)
1404                   {
1405                     unsigned int i = new_side_dofs[sidei];
1406                     // fixed DoFs aren't test functions
1407                     if (dof_is_fixed[i])
1408                       continue;
1409                     for (unsigned int sidej=0, freej=0;
1410                          sidej != new_side_dofs\&.size();
1411                          ++sidej)
1412                       {
1413                         unsigned int j =
1414                           new_side_dofs[sidej];
1415                         if (dof_is_fixed[j])
1416                           Fe(freei) -=
1417                             TensorTools::inner_product(phi_coarse[i][qp],
1418                                                        phi_coarse[j][qp]) *
1419                             JxW[qp] * Ue(j);
1420                         else
1421                           Ke(freei,freej) +=
1422                             TensorTools::inner_product(phi_coarse[i][qp],
1423                                                        phi_coarse[j][qp]) *
1424                             JxW[qp];
1425                         if (cont == C_ONE)
1426                           {
1427                             if (dof_is_fixed[j])
1428                               Fe(freei) -=
1429                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1430                                                            (*dphi_coarse)[j][qp]) *
1431                                 JxW[qp] * Ue(j);
1432                             else
1433                               Ke(freei,freej) +=
1434                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1435                                                            (*dphi_coarse)[j][qp]) *
1436                                 JxW[qp];
1437                           }
1438                         if (!dof_is_fixed[j])
1439                           freej++;
1440                       }
1441                     Fe(freei) += TensorTools::inner_product(fineval, phi_coarse[i][qp]) * JxW[qp];
1442                     if (cont == C_ONE)
1443                       Fe(freei) +=
1444                         TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1445                     freei++;
1446                   }
1447               }
1448           }
1449         Ke\&.cholesky_solve(Fe, Uside);
1450 
1451         // Transfer new side solutions to element
1452         for (unsigned int i=0; i != free_dofs; ++i)
1453           {
1454             Number &ui = Ue(new_side_dofs[free_dof[i]]);
1455             libmesh_assert(std::abs(ui) < TOLERANCE ||
1456                            std::abs(ui - Uside(i)) < TOLERANCE);
1457             ui = Uside(i);
1458             dof_is_fixed[new_side_dofs[free_dof[i]]] =
1459               true;
1460           }
1461       }
1462 
1463   // Project the interior values, finally
1464 
1465   // Some interior dofs are on nodes/edges/sides and
1466   // already fixed, others are free to calculate
1467   unsigned int free_dofs = 0;
1468   for (unsigned int i=0; i != new_n_dofs; ++i)
1469     if (!dof_is_fixed[i])
1470       free_dof[free_dofs++] = i;
1471   Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1472   Fe\&.resize (free_dofs); Fe\&.zero();
1473   // The new interior coefficients
1474   DenseVector<Number> Uint(free_dofs);
1475 
1476   // Add projection terms from each child
1477   for (unsigned int c=0; c != elem->n_children(); ++c)
1478     {
1479       Elem *child = elem->child(c);
1480 
1481       std::vector<dof_id_type> child_dof_indices;
1482       if (use_old_dof_indices)
1483         dof_map\&.old_dof_indices (child,
1484                                  child_dof_indices, var);
1485       else
1486         dof_map\&.dof_indices (child,
1487                              child_dof_indices, var);
1488       const unsigned int child_n_dofs =
1489         libmesh_cast_int<unsigned int>
1490         (child_dof_indices\&.size());
1491 
1492       // Initialize both child and parent FE data
1493       // on the child's quadrature points
1494       fe->attach_quadrature_rule (qrule\&.get());
1495       fe->reinit (child);
1496       const unsigned int n_qp = qrule->n_points();
1497 
1498       FEInterface::inverse_map (dim, fe_type, elem,
1499                                 xyz_values, coarse_qpoints);
1500 
1501       fe_coarse->reinit(elem, &coarse_qpoints);
1502 
1503       // Loop over the quadrature points
1504       for (unsigned int qp=0; qp<n_qp; qp++)
1505         {
1506           // solution value at the quadrature point
1507           OutputNumber fineval = libMesh::zero;
1508           // solution grad at the quadrature point
1509           OutputNumberGradient finegrad;
1510 
1511           // Sum the solution values * the DOF
1512           // values at the quadrature point to
1513           // get the solution value and gradient\&.
1514           for (unsigned int i=0; i<child_n_dofs; i++)
1515             {
1516               fineval +=
1517                 (old_vector(child_dof_indices[i]) *
1518                  phi_values[i][qp]);
1519               if (cont == C_ONE)
1520                 finegrad += (*dphi_values)[i][qp] *
1521                   old_vector(child_dof_indices[i]);
1522             }
1523 
1524           // Form interior projection matrix
1525           for (unsigned int i=0, freei=0;
1526                i != new_n_dofs; ++i)
1527             {
1528               // fixed DoFs aren't test functions
1529               if (dof_is_fixed[i])
1530                 continue;
1531               for (unsigned int j=0, freej=0; j !=
1532                      new_n_dofs; ++j)
1533                 {
1534                   if (dof_is_fixed[j])
1535                     Fe(freei) -=
1536                       TensorTools::inner_product(phi_coarse[i][qp],
1537                                                  phi_coarse[j][qp]) *
1538                       JxW[qp] * Ue(j);
1539                   else
1540                     Ke(freei,freej) +=
1541                       TensorTools::inner_product(phi_coarse[i][qp],
1542                                                  phi_coarse[j][qp]) *
1543                       JxW[qp];
1544                   if (cont == C_ONE)
1545                     {
1546                       if (dof_is_fixed[j])
1547                         Fe(freei) -=
1548                           TensorTools::inner_product((*dphi_coarse)[i][qp],
1549                                                      (*dphi_coarse)[j][qp]) *
1550                           JxW[qp] * Ue(j);
1551                       else
1552                         Ke(freei,freej) +=
1553                           TensorTools::inner_product((*dphi_coarse)[i][qp],
1554                                                      (*dphi_coarse)[j][qp]) *
1555                           JxW[qp];
1556                     }
1557                   if (!dof_is_fixed[j])
1558                     freej++;
1559                 }
1560               Fe(freei) += TensorTools::inner_product(phi_coarse[i][qp], fineval) *
1561                 JxW[qp];
1562               if (cont == C_ONE)
1563                 Fe(freei) += TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1564               freei++;
1565             }
1566         }
1567     }
1568   Ke\&.cholesky_solve(Fe, Uint);
1569 
1570   // Transfer new interior solutions to element
1571   for (unsigned int i=0; i != free_dofs; ++i)
1572     {
1573       Number &ui = Ue(free_dof[i]);
1574       libmesh_assert(std::abs(ui) < TOLERANCE ||
1575                      std::abs(ui - Uint(i)) < TOLERANCE);
1576       ui = Uint(i);
1577       // We should be fixing all dofs by now; no need to keep track of
1578       // that unless we're debugging
1579 #ifndef NDEBUG
1580       dof_is_fixed[free_dof[i]] = true;
1581 #endif
1582     }
1583 
1584 #ifndef NDEBUG
1585   // Make sure every DoF got reached!
1586   for (unsigned int i=0; i != new_n_dofs; ++i)
1587     libmesh_assert(dof_is_fixed[i]);
1588 #endif
1589 }
.fi
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::compute_periodic_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP"
Computes the constraint matrix contributions (for meshes with periodic boundary conditions) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.PP
Definition at line 1877 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::TypeVector< T >::absolute_fuzzy_equals(), libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::C_ONE, libMesh::C_ZERO, libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::DofMap::constrain_p_dofs(), libMesh::FEType::default_quadrature_order(), libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::DofObject::dof_number(), libMesh::FEInterface::dofs_on_side(), libMesh::err, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::Elem::get_node(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::TensorTools::inner_product(), libMesh::DofObject::invalid_id, libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::DofMap::is_constrained_dof(), libMesh::Elem::is_edge(), libMesh::Elem::is_face(), libMesh::PeriodicBoundaryBase::is_my_variable(), libMesh::Elem::is_node_on_edge(), libMesh::Elem::is_node_on_side(), libMesh::Elem::is_vertex(), libMesh::Elem::level(), libMesh::libmesh_assert(), std::min(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::DofObject::n_comp(), libMesh::Elem::n_edges(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::Elem::p_level(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::Threads::spin_mtx, libMesh::swap(), libMesh::DofMap::sys_number(), libMesh::TOLERANCE, and libMesh::DofMap::variable_type()\&.
.PP
Referenced by libMesh::FEInterface::compute_periodic_constraints()\&.
.PP
.nf
1884 {
1885   // Only bother if we truly have periodic boundaries
1886   if (boundaries\&.empty())
1887     return;
1888 
1889   libmesh_assert(elem);
1890 
1891   // Only constrain active elements with this method
1892   if (!elem->active())
1893     return;
1894 
1895   const unsigned int Dim = elem->dim();
1896 
1897   // We need sys_number and variable_number for DofObject methods
1898   // later
1899   const unsigned int sys_number = dof_map\&.sys_number();
1900 
1901   const FEType& base_fe_type = dof_map\&.variable_type(variable_number);
1902 
1903   // Construct FE objects for this element and its pseudo-neighbors\&.
1904   AutoPtr<FEGenericBase<OutputShape> > my_fe
1905     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1906   const FEContinuity cont = my_fe->get_continuity();
1907 
1908   // We don't need to constrain discontinuous elements
1909   if (cont == DISCONTINUOUS)
1910     return;
1911   libmesh_assert (cont == C_ZERO || cont == C_ONE);
1912 
1913   // We'll use element size to generate relative tolerances later
1914   const Real primary_hmin = elem->hmin();
1915 
1916   AutoPtr<FEGenericBase<OutputShape> > neigh_fe
1917     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1918 
1919   QGauss my_qface(Dim-1, base_fe_type\&.default_quadrature_order());
1920   my_fe->attach_quadrature_rule (&my_qface);
1921   std::vector<Point> neigh_qface;
1922 
1923   const std::vector<Real>& JxW = my_fe->get_JxW();
1924   const std::vector<Point>& q_point = my_fe->get_xyz();
1925   const std::vector<std::vector<OutputShape> >& phi = my_fe->get_phi();
1926   const std::vector<std::vector<OutputShape> >& neigh_phi =
1927     neigh_fe->get_phi();
1928   const std::vector<Point> *face_normals = NULL;
1929   const std::vector<std::vector<OutputGradient> > *dphi = NULL;
1930   const std::vector<std::vector<OutputGradient> > *neigh_dphi = NULL;
1931   std::vector<dof_id_type> my_dof_indices, neigh_dof_indices;
1932   std::vector<unsigned int> my_side_dofs, neigh_side_dofs;
1933 
1934   if (cont != C_ZERO)
1935     {
1936       const std::vector<Point>& ref_face_normals =
1937         my_fe->get_normals();
1938       face_normals = &ref_face_normals;
1939       const std::vector<std::vector<OutputGradient> >& ref_dphi =
1940         my_fe->get_dphi();
1941       dphi = &ref_dphi;
1942       const std::vector<std::vector<OutputGradient> >& ref_neigh_dphi =
1943         neigh_fe->get_dphi();
1944       neigh_dphi = &ref_neigh_dphi;
1945     }
1946 
1947   DenseMatrix<Real> Ke;
1948   DenseVector<Real> Fe;
1949   std::vector<DenseVector<Real> > Ue;
1950 
1951   // Look at the element faces\&.  Check to see if we need to
1952   // build constraints\&.
1953   for (unsigned int s=0; s<elem->n_sides(); s++)
1954     {
1955       if (elem->neighbor(s))
1956         continue;
1957 
1958       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1959       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1960         {
1961           const boundary_id_type boundary_id = *id_it;
1962           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1963           if (periodic && periodic->is_my_variable(variable_number))
1964             {
1965               libmesh_assert(point_locator);
1966 
1967               // Get pointers to the element's neighbor\&.
1968               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1969 
1970               if (neigh == NULL)
1971                 {
1972                   libMesh::err << "PeriodicBoundaries point locator object returned NULL!" << std::endl;
1973                   libmesh_error();
1974                 }
1975 
1976               // periodic (and possibly h refinement) constraints:
1977               // constrain dofs shared between
1978               // this element and ones as coarse
1979               // as or coarser than this element\&.
1980               if (neigh->level() <= elem->level())
1981                 {
1982                   unsigned int s_neigh =
1983                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1984                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1985 
1986 #ifdef LIBMESH_ENABLE_AMR
1987                   // Find the minimum p level; we build the h constraint
1988                   // matrix with this and then constrain away all higher p
1989                   // DoFs\&.
1990                   libmesh_assert(neigh->active());
1991                   const unsigned int min_p_level =
1992                     std::min(elem->p_level(), neigh->p_level());
1993 
1994                   // we may need to make the FE objects reinit with the
1995                   // minimum shared p_level
1996                   // FIXME - I hate using const_cast<> and avoiding
1997                   // accessor functions; there's got to be a
1998                   // better way to do this!
1999                   const unsigned int old_elem_level = elem->p_level();
2000                   if (old_elem_level != min_p_level)
2001                     (const_cast<Elem *>(elem))->hack_p_level(min_p_level);
2002                   const unsigned int old_neigh_level = neigh->p_level();
2003                   if (old_neigh_level != min_p_level)
2004                     (const_cast<Elem *>(neigh))->hack_p_level(min_p_level);
2005 #endif // #ifdef LIBMESH_ENABLE_AMR
2006 
2007                   // We can do a projection with a single integration,
2008                   // due to the assumption of nested finite element
2009                   // subspaces\&.
2010                   // FIXME: it might be more efficient to do nodes,
2011                   // then edges, then side, to reduce the size of the
2012                   // Cholesky factorization(s)
2013                   my_fe->reinit(elem, s);
2014 
2015                   dof_map\&.dof_indices (elem, my_dof_indices,
2016                                        variable_number);
2017                   dof_map\&.dof_indices (neigh, neigh_dof_indices,
2018                                        variable_number);
2019 
2020                   const unsigned int n_qp = my_qface\&.n_points();
2021 
2022                   // Translate the quadrature points over to the
2023                   // neighbor's boundary
2024                   std::vector<Point> neigh_point(q_point\&.size());
2025                   for (unsigned int i=0; i != neigh_point\&.size(); ++i)
2026                     neigh_point[i] = periodic->get_corresponding_pos(q_point[i]);
2027 
2028                   FEInterface::inverse_map (Dim, base_fe_type, neigh,
2029                                             neigh_point, neigh_qface);
2030 
2031                   neigh_fe->reinit(neigh, &neigh_qface);
2032 
2033                   // We're only concerned with DOFs whose values (and/or first
2034                   // derivatives for C1 elements) are supported on side nodes
2035                   FEInterface::dofs_on_side(elem, Dim, base_fe_type, s, my_side_dofs);
2036                   FEInterface::dofs_on_side(neigh, Dim, base_fe_type, s_neigh, neigh_side_dofs);
2037 
2038                   // We're done with functions that examine Elem::p_level(),
2039                   // so let's unhack those levels
2040 #ifdef LIBMESH_ENABLE_AMR
2041                   if (elem->p_level() != old_elem_level)
2042                     (const_cast<Elem *>(elem))->hack_p_level(old_elem_level);
2043                   if (neigh->p_level() != old_neigh_level)
2044                     (const_cast<Elem *>(neigh))->hack_p_level(old_neigh_level);
2045 #endif // #ifdef LIBMESH_ENABLE_AMR
2046 
2047                   const unsigned int n_side_dofs =
2048                     libmesh_cast_int<unsigned int>
2049                     (my_side_dofs\&.size());
2050                   libmesh_assert_equal_to (n_side_dofs, neigh_side_dofs\&.size());
2051 
2052                   Ke\&.resize (n_side_dofs, n_side_dofs);
2053                   Ue\&.resize(n_side_dofs);
2054 
2055                   // Form the projection matrix, (inner product of fine basis
2056                   // functions against fine test functions)
2057                   for (unsigned int is = 0; is != n_side_dofs; ++is)
2058                     {
2059                       const unsigned int i = my_side_dofs[is];
2060                       for (unsigned int js = 0; js != n_side_dofs; ++js)
2061                         {
2062                           const unsigned int j = my_side_dofs[js];
2063                           for (unsigned int qp = 0; qp != n_qp; ++qp)
2064                             {
2065                               Ke(is,js) += JxW[qp] *
2066                                 TensorTools::inner_product(phi[i][qp],
2067                                                            phi[j][qp]);
2068                               if (cont != C_ZERO)
2069                                 Ke(is,js) += JxW[qp] *
2070                                   TensorTools::inner_product((*dphi)[i][qp] *
2071                                                              (*face_normals)[qp],
2072                                                              (*dphi)[j][qp] *
2073                                                              (*face_normals)[qp]);
2074                             }
2075                         }
2076                     }
2077 
2078                   // Form the right hand sides, (inner product of coarse basis
2079                   // functions against fine test functions)
2080                   for (unsigned int is = 0; is != n_side_dofs; ++is)
2081                     {
2082                       const unsigned int i = neigh_side_dofs[is];
2083                       Fe\&.resize (n_side_dofs);
2084                       for (unsigned int js = 0; js != n_side_dofs; ++js)
2085                         {
2086                           const unsigned int j = my_side_dofs[js];
2087                           for (unsigned int qp = 0; qp != n_qp; ++qp)
2088                             {
2089                               Fe(js) += JxW[qp] *
2090                                 TensorTools::inner_product(neigh_phi[i][qp],
2091                                                            phi[j][qp]);
2092                               if (cont != C_ZERO)
2093                                 Fe(js) += JxW[qp] *
2094                                   TensorTools::inner_product((*neigh_dphi)[i][qp] *
2095                                                              (*face_normals)[qp],
2096                                                              (*dphi)[j][qp] *
2097                                                              (*face_normals)[qp]);
2098                             }
2099                         }
2100                       Ke\&.cholesky_solve(Fe, Ue[is]);
2101                     }
2102 
2103                   // Make sure we're not adding recursive constraints
2104                   // due to the redundancy in the way we add periodic
2105                   // boundary constraints
2106                   //
2107                   // In order for this to work while threaded or on
2108                   // distributed meshes, we need a rigorous way to
2109                   // avoid recursive constraints\&.  Here it is:
2110                   //
2111                   // For vertex DoFs, if there is a "prior" element
2112                   // (i\&.e\&. a coarser element or an equally refined
2113                   // element with a lower id) on this boundary which
2114                   // contains the vertex point, then we will avoid
2115                   // generating constraints; the prior element (or
2116                   // something prior to it) may do so\&.  If we are the
2117                   // most prior (or "primary") element on this
2118                   // boundary sharing this point, then we look at the
2119                   // boundary periodic to us, we find the primary
2120                   // element there, and if that primary is coarser or
2121                   // equal-but-lower-id, then our vertex dofs are
2122                   // constrained in terms of that element\&.
2123                   //
2124                   // For edge DoFs, if there is a coarser element
2125                   // on this boundary sharing this edge, then we will
2126                   // avoid generating constraints (we will be
2127                   // constrained indirectly via AMR constraints
2128                   // connecting us to the coarser element's DoFs)\&.  If
2129                   // we are the coarsest element sharing this edge,
2130                   // then we generate constraints if and only if we
2131                   // are finer than the coarsest element on the
2132                   // boundary periodic to us sharing the corresponding
2133                   // periodic edge, or if we are at equal level but
2134                   // our edge nodes have higher ids than the periodic
2135                   // edge nodes (sorted from highest to lowest, then
2136                   // compared lexicographically)
2137                   //
2138                   // For face DoFs, we generate constraints if we are
2139                   // finer than our periodic neighbor, or if we are at
2140                   // equal level but our element id is higher than its
2141                   // element id\&.
2142                   //
2143                   // If the primary neighbor is also the current elem
2144                   // (a 1-element-thick mesh) then we choose which
2145                   // vertex dofs to constrain via lexicographic
2146                   // ordering on point locations
2147 
2148                   // FIXME: This code doesn't yet properly handle
2149                   // cases where multiple different periodic BCs
2150                   // intersect\&.
2151                   std::set<dof_id_type> my_constrained_dofs;
2152 
2153                   for (unsigned int n = 0; n != elem->n_nodes(); ++n)
2154                     {
2155                       if (!elem->is_node_on_side(n,s))
2156                         continue;
2157 
2158                       const Node* my_node = elem->get_node(n);
2159 
2160                       if (elem->is_vertex(n))
2161                         {
2162                           // Find all boundary ids that include this
2163                           // point and have periodic boundary
2164                           // conditions for this variable
2165                           std::set<boundary_id_type> point_bcids;
2166 
2167                           for (unsigned int new_s = 0; new_s !=
2168                                  elem->n_sides(); ++new_s)
2169                             {
2170                               if (!elem->is_node_on_side(n,new_s))
2171                                 continue;
2172 
2173                               const std::vector<boundary_id_type>
2174                                 new_bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
2175                               for (std::vector<boundary_id_type>::const_iterator
2176                                      new_id_it=new_bc_ids\&.begin(); new_id_it!=new_bc_ids\&.end(); ++new_id_it)
2177                                 {
2178                                   const boundary_id_type new_boundary_id = *new_id_it;
2179                                   const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2180                                   if (new_periodic && new_periodic->is_my_variable(variable_number))
2181                                     {
2182                                       point_bcids\&.insert(new_boundary_id);
2183                                     }
2184                                 }
2185                             }
2186 
2187                           // See if this vertex has point neighbors to
2188                           // defer to
2189                           if (primary_boundary_point_neighbor
2190                               (elem, *my_node, *mesh\&.boundary_info, point_bcids) != elem)
2191                             continue;
2192 
2193                           // Find the complementary boundary id set
2194                           std::set<boundary_id_type> point_pairedids;
2195                           for (std::set<boundary_id_type>::const_iterator i =
2196                                  point_bcids\&.begin(); i != point_bcids\&.end(); ++i)
2197                             {
2198                               const boundary_id_type new_boundary_id = *i;
2199                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2200                               point_pairedids\&.insert(new_periodic->pairedboundary);
2201                             }
2202 
2203                           // What do we want to constrain against?
2204                           const Elem* primary_elem = NULL;
2205                           const Elem* main_neigh = NULL;
2206                           Point main_pt = *my_node,
2207                             primary_pt = *my_node;
2208 
2209                           for (std::set<boundary_id_type>::const_iterator i =
2210                                  point_bcids\&.begin(); i != point_bcids\&.end(); ++i)
2211                             {
2212                               // Find the corresponding periodic point and
2213                               // its primary neighbor
2214                               const boundary_id_type new_boundary_id = *i;
2215                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2216 
2217                               const Point neigh_pt =
2218                                 new_periodic->get_corresponding_pos(*my_node);
2219 
2220                               // If the point is getting constrained
2221                               // to itself by this PBC then we don't
2222                               // generate any constraints
2223                               if (neigh_pt\&.absolute_fuzzy_equals
2224                                   (*my_node, primary_hmin*TOLERANCE))
2225                                 continue;
2226 
2227                               // Otherwise we'll have a constraint in
2228                               // one direction or another
2229                               if (!primary_elem)
2230                                 primary_elem = elem;
2231 
2232                               const Elem *primary_neigh = primary_boundary_point_neighbor
2233                                 (neigh, neigh_pt, *mesh\&.boundary_info,
2234                                  point_pairedids);
2235 
2236                               libmesh_assert(primary_neigh);
2237 
2238                               if (new_boundary_id == boundary_id)
2239                                 {
2240                                   main_neigh = primary_neigh;
2241                                   main_pt = neigh_pt;
2242                                 }
2243 
2244                               // Finer elements will get constrained in
2245                               // terms of coarser neighbors, not the
2246                               // other way around
2247                               if ((primary_neigh->level() > primary_elem->level()) ||
2248 
2249                                   // For equal-level elements, the one with
2250                                   // higher id gets constrained in terms of
2251                                   // the one with lower id
2252                                   (primary_neigh->level() == primary_elem->level() &&
2253                                    primary_neigh->id() > primary_elem->id()) ||
2254 
2255                                   // On a one-element-thick mesh, we compare
2256                                   // points to see what side gets constrained
2257                                   (primary_neigh == primary_elem &&
2258                                    (neigh_pt > primary_pt)))
2259                                 continue;
2260 
2261                               primary_elem = primary_neigh;
2262                               primary_pt = neigh_pt;
2263                             }
2264 
2265                           if (!primary_elem ||
2266                               primary_elem != main_neigh ||
2267                               primary_pt != main_pt)
2268                             continue;
2269                         }
2270                       else if (elem->is_edge(n))
2271                         {
2272                           // Find which edge we're on
2273                           unsigned int e=0;
2274                           for (; e != elem->n_edges(); ++e)
2275                             {
2276                               if (elem->is_node_on_edge(n,e))
2277                                 break;
2278                             }
2279                           libmesh_assert_less (e, elem->n_edges());
2280 
2281                           // Find the edge end nodes
2282                           Node *e1 = NULL,
2283                             *e2 = NULL;
2284                           for (unsigned int nn = 0; nn != elem->n_nodes(); ++nn)
2285                             {
2286                               if (nn == n)
2287                                 continue;
2288 
2289                               if (elem->is_node_on_edge(nn, e))
2290                                 {
2291                                   if (e1 == NULL)
2292                                     {
2293                                       e1 = elem->get_node(nn);
2294                                     }
2295                                   else
2296                                     {
2297                                       e2 = elem->get_node(nn);
2298                                       break;
2299                                     }
2300                                 }
2301                             }
2302                           libmesh_assert (e1 && e2);
2303 
2304                           // Find all boundary ids that include this
2305                           // edge and have periodic boundary
2306                           // conditions for this variable
2307                           std::set<boundary_id_type> edge_bcids;
2308 
2309                           for (unsigned int new_s = 0; new_s !=
2310                                  elem->n_sides(); ++new_s)
2311                             {
2312                               if (!elem->is_node_on_side(n,new_s))
2313                                 continue;
2314 
2315                               const std::vector<boundary_id_type>&
2316                                 new_bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
2317                               for (std::vector<boundary_id_type>::const_iterator
2318                                      new_id_it=new_bc_ids\&.begin(); new_id_it!=new_bc_ids\&.end(); ++new_id_it)
2319                                 {
2320                                   const boundary_id_type new_boundary_id = *new_id_it;
2321                                   const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2322                                   if (new_periodic && new_periodic->is_my_variable(variable_number))
2323                                     {
2324                                       edge_bcids\&.insert(new_boundary_id);
2325                                     }
2326                                 }
2327                             }
2328 
2329 
2330                           // See if this edge has neighbors to defer to
2331                           if (primary_boundary_edge_neighbor
2332                               (elem, *e1, *e2, *mesh\&.boundary_info, edge_bcids) != elem)
2333                             continue;
2334 
2335                           // Find the complementary boundary id set
2336                           std::set<boundary_id_type> edge_pairedids;
2337                           for (std::set<boundary_id_type>::const_iterator i =
2338                                  edge_bcids\&.begin(); i != edge_bcids\&.end(); ++i)
2339                             {
2340                               const boundary_id_type new_boundary_id = *i;
2341                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2342                               edge_pairedids\&.insert(new_periodic->pairedboundary);
2343                             }
2344 
2345                           // What do we want to constrain against?
2346                           const Elem* primary_elem = NULL;
2347                           const Elem* main_neigh = NULL;
2348                           Point main_pt1 = *e1,
2349                             main_pt2 = *e2,
2350                             primary_pt1 = *e1,
2351                             primary_pt2 = *e2;
2352 
2353                           for (std::set<boundary_id_type>::const_iterator i =
2354                                  edge_bcids\&.begin(); i != edge_bcids\&.end(); ++i)
2355                             {
2356                               // Find the corresponding periodic edge and
2357                               // its primary neighbor
2358                               const boundary_id_type new_boundary_id = *i;
2359                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2360 
2361                               Point neigh_pt1 = new_periodic->get_corresponding_pos(*e1),
2362                                 neigh_pt2 = new_periodic->get_corresponding_pos(*e2);
2363 
2364                               // If the edge is getting constrained
2365                               // to itself by this PBC then we don't
2366                               // generate any constraints
2367                               if (neigh_pt1\&.absolute_fuzzy_equals
2368                                   (*e1, primary_hmin*TOLERANCE) &&
2369                                   neigh_pt2\&.absolute_fuzzy_equals
2370                                   (*e2, primary_hmin*TOLERANCE))
2371                                 continue;
2372 
2373                               // Otherwise we'll have a constraint in
2374                               // one direction or another
2375                               if (!primary_elem)
2376                                 primary_elem = elem;
2377 
2378                               const Elem *primary_neigh = primary_boundary_edge_neighbor
2379                                 (neigh, neigh_pt1, neigh_pt2, *mesh\&.boundary_info,
2380                                  edge_pairedids);
2381 
2382                               libmesh_assert(primary_neigh);
2383 
2384                               if (new_boundary_id == boundary_id)
2385                                 {
2386                                   main_neigh = primary_neigh;
2387                                   main_pt1 = neigh_pt1;
2388                                   main_pt2 = neigh_pt2;
2389                                 }
2390 
2391                               // If we have a one-element thick mesh,
2392                               // we'll need to sort our points to get a
2393                               // consistent ordering rule
2394                               //
2395                               // Use >= in this test to make sure that,
2396                               // for angular constraints, no node gets
2397                               // constrained to itself\&.
2398                               if (primary_neigh == primary_elem)
2399                                 {
2400                                   if (primary_pt1 > primary_pt2)
2401                                     std::swap(primary_pt1, primary_pt2);
2402                                   if (neigh_pt1 > neigh_pt2)
2403                                     std::swap(neigh_pt1, neigh_pt2);
2404 
2405                                   if (neigh_pt2 >= primary_pt2)
2406                                     continue;
2407                                 }
2408 
2409                               // Otherwise:
2410                               // Finer elements will get constrained in
2411                               // terms of coarser ones, not the other way
2412                               // around
2413                               if ((primary_neigh->level() > primary_elem->level()) ||
2414 
2415                                   // For equal-level elements, the one with
2416                                   // higher id gets constrained in terms of
2417                                   // the one with lower id
2418                                   (primary_neigh->level() == primary_elem->level() &&
2419                                    primary_neigh->id() > primary_elem->id()))
2420                                 continue;
2421 
2422                               primary_elem = primary_neigh;
2423                               primary_pt1 = neigh_pt1;
2424                               primary_pt2 = neigh_pt2;
2425                             }
2426 
2427                           if (!primary_elem ||
2428                               primary_elem != main_neigh ||
2429                               primary_pt1 != main_pt1 ||
2430                               primary_pt2 != main_pt2)
2431                             continue;
2432                         }
2433                       else if (elem->is_face(n))
2434                         {
2435                           // If we have a one-element thick mesh,
2436                           // use the ordering of the face node and its
2437                           // periodic counterpart to determine what
2438                           // gets constrained
2439                           if (neigh == elem)
2440                             {
2441                               const Point neigh_pt =
2442                                 periodic->get_corresponding_pos(*my_node);
2443                               if (neigh_pt > *my_node)
2444                                 continue;
2445                             }
2446 
2447                           // Otherwise:
2448                           // Finer elements will get constrained in
2449                           // terms of coarser ones, not the other way
2450                           // around
2451                           if ((neigh->level() > elem->level()) ||
2452 
2453                               // For equal-level elements, the one with
2454                               // higher id gets constrained in terms of
2455                               // the one with lower id
2456                               (neigh->level() == elem->level() &&
2457                                neigh->id() > elem->id()))
2458                             continue;
2459                         }
2460 
2461                       // If we made it here without hitting a continue
2462                       // statement, then we're at a node whose dofs
2463                       // should be constrained by this element's
2464                       // calculations\&.
2465                       const unsigned int n_comp =
2466                         my_node->n_comp(sys_number, variable_number);
2467 
2468                       for (unsigned int i=0; i != n_comp; ++i)
2469                         my_constrained_dofs\&.insert
2470                           (my_node->dof_number
2471                            (sys_number, variable_number, i));
2472                     }
2473 
2474                   // FIXME: old code for disambiguating periodic BCs:
2475                   // this is not threadsafe nor safe to run on a
2476                   // non-serialized mesh\&.
2477                   /*
2478                     std::vector<bool> recursive_constraint(n_side_dofs, false);
2479 
2480                     for (unsigned int is = 0; is != n_side_dofs; ++is)
2481                     {
2482                     const unsigned int i = neigh_side_dofs[is];
2483                     const dof_id_type their_dof_g = neigh_dof_indices[i];
2484                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
2485 
2486                     {
2487                     Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
2488 
2489                     if (!dof_map\&.is_constrained_dof(their_dof_g))
2490                     continue;
2491                     }
2492 
2493                     DofConstraintRow& their_constraint_row =
2494                     constraints[their_dof_g]\&.first;
2495 
2496                     for (unsigned int js = 0; js != n_side_dofs; ++js)
2497                     {
2498                     const unsigned int j = my_side_dofs[js];
2499                     const dof_id_type my_dof_g = my_dof_indices[j];
2500                     libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
2501 
2502                     if (their_constraint_row\&.count(my_dof_g))
2503                     recursive_constraint[js] = true;
2504                     }
2505                     }
2506                   */
2507 
2508                   for (unsigned int js = 0; js != n_side_dofs; ++js)
2509                     {
2510                       // FIXME: old code path
2511                       // if (recursive_constraint[js])
2512                       //  continue;
2513 
2514                       const unsigned int j = my_side_dofs[js];
2515                       const dof_id_type my_dof_g = my_dof_indices[j];
2516                       libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
2517 
2518                       // FIXME: new code path
2519                       if (!my_constrained_dofs\&.count(my_dof_g))
2520                         continue;
2521 
2522                       DofConstraintRow* constraint_row;
2523 
2524                       // we may be running constraint methods concurretly
2525                       // on multiple threads, so we need a lock to
2526                       // ensure that this constraint is "ours"
2527                       {
2528                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
2529 
2530                         if (dof_map\&.is_constrained_dof(my_dof_g))
2531                           continue;
2532 
2533                         constraint_row = &(constraints[my_dof_g]);
2534                         libmesh_assert(constraint_row->empty());
2535                       }
2536 
2537                       for (unsigned int is = 0; is != n_side_dofs; ++is)
2538                         {
2539                           const unsigned int i = neigh_side_dofs[is];
2540                           const dof_id_type their_dof_g = neigh_dof_indices[i];
2541                           libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
2542 
2543                           // Periodic constraints should never be
2544                           // self-constraints
2545                           // libmesh_assert_not_equal_to (their_dof_g, my_dof_g);
2546 
2547                           const Real their_dof_value = Ue[is](js);
2548 
2549                           if (their_dof_g == my_dof_g)
2550                             {
2551                               libmesh_assert_less (std::abs(their_dof_value-1\&.), 1\&.e-5);
2552                               for (unsigned int k = 0; k != n_side_dofs; ++k)
2553                                 libmesh_assert(k == is || std::abs(Ue[k](js)) < 1\&.e-5);
2554                               continue;
2555                             }
2556 
2557                           if (std::abs(their_dof_value) < 10*TOLERANCE)
2558                             continue;
2559 
2560                           constraint_row->insert(std::make_pair(their_dof_g,
2561                                                                 their_dof_value));
2562                         }
2563                     }
2564                 }
2565               // p refinement constraints:
2566               // constrain dofs shared between
2567               // active elements and neighbors with
2568               // lower polynomial degrees
2569 #ifdef LIBMESH_ENABLE_AMR
2570               const unsigned int min_p_level =
2571                 neigh->min_p_level_by_neighbor(elem, elem->p_level());
2572               if (min_p_level < elem->p_level())
2573                 {
2574                   // Adaptive p refinement of non-hierarchic bases will
2575                   // require more coding
2576                   libmesh_assert(my_fe->is_hierarchic());
2577                   dof_map\&.constrain_p_dofs(variable_number, elem,
2578                                            s, min_p_level);
2579                 }
2580 #endif // #ifdef LIBMESH_ENABLE_AMR
2581             }
2582         }
2583     }
2584 }
.fi
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::compute_proj_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.PP
Definition at line 1595 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::Elem::active(), libMesh::C_ONE, libMesh::C_ZERO, libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::DofMap::constrain_p_dofs(), libMesh::FEType::default_quadrature_order(), libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::FEInterface::dofs_on_side(), libMesh::TensorTools::inner_product(), libMesh::DofObject::invalid_id, libMesh::FEInterface::inverse_map(), libMesh::DofMap::is_constrained_dof(), libMesh::Elem::level(), libMesh::libmesh_assert(), std::min(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::n_neighbors(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::p_level(), libMesh::Real, libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::Threads::spin_mtx, libMesh::TOLERANCE, libMesh::DofMap::variable_type(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
Referenced by libMesh::FE< Dim, T >::compute_constraints()\&.
.PP
.nf
1599 {
1600   libmesh_assert(elem);
1601 
1602   const unsigned int Dim = elem->dim();
1603 
1604   // Only constrain elements in 2,3D\&.
1605   if (Dim == 1)
1606     return;
1607 
1608   // Only constrain active elements with this method
1609   if (!elem->active())
1610     return;
1611 
1612   const FEType& base_fe_type = dof_map\&.variable_type(variable_number);
1613 
1614   // Construct FE objects for this element and its neighbors\&.
1615   AutoPtr<FEGenericBase<OutputShape> > my_fe
1616     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1617   const FEContinuity cont = my_fe->get_continuity();
1618 
1619   // We don't need to constrain discontinuous elements
1620   if (cont == DISCONTINUOUS)
1621     return;
1622   libmesh_assert (cont == C_ZERO || cont == C_ONE);
1623 
1624   AutoPtr<FEGenericBase<OutputShape> > neigh_fe
1625     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1626 
1627   QGauss my_qface(Dim-1, base_fe_type\&.default_quadrature_order());
1628   my_fe->attach_quadrature_rule (&my_qface);
1629   std::vector<Point> neigh_qface;
1630 
1631   const std::vector<Real>& JxW = my_fe->get_JxW();
1632   const std::vector<Point>& q_point = my_fe->get_xyz();
1633   const std::vector<std::vector<OutputShape> >& phi = my_fe->get_phi();
1634   const std::vector<std::vector<OutputShape> >& neigh_phi =
1635     neigh_fe->get_phi();
1636   const std::vector<Point> *face_normals = NULL;
1637   const std::vector<std::vector<OutputGradient> > *dphi = NULL;
1638   const std::vector<std::vector<OutputGradient> > *neigh_dphi = NULL;
1639 
1640   std::vector<dof_id_type> my_dof_indices, neigh_dof_indices;
1641   std::vector<unsigned int> my_side_dofs, neigh_side_dofs;
1642 
1643   if (cont != C_ZERO)
1644     {
1645       const std::vector<Point>& ref_face_normals =
1646         my_fe->get_normals();
1647       face_normals = &ref_face_normals;
1648       const std::vector<std::vector<OutputGradient> >& ref_dphi =
1649         my_fe->get_dphi();
1650       dphi = &ref_dphi;
1651       const std::vector<std::vector<OutputGradient> >& ref_neigh_dphi =
1652         neigh_fe->get_dphi();
1653       neigh_dphi = &ref_neigh_dphi;
1654     }
1655 
1656   DenseMatrix<Real> Ke;
1657   DenseVector<Real> Fe;
1658   std::vector<DenseVector<Real> > Ue;
1659 
1660   // Look at the element faces\&.  Check to see if we need to
1661   // build constraints\&.
1662   for (unsigned int s=0; s<elem->n_sides(); s++)
1663     if (elem->neighbor(s) != NULL)
1664       {
1665         // Get pointers to the element's neighbor\&.
1666         const Elem* neigh = elem->neighbor(s);
1667 
1668         // h refinement constraints:
1669         // constrain dofs shared between
1670         // this element and ones coarser
1671         // than this element\&.
1672         if (neigh->level() < elem->level())
1673           {
1674             unsigned int s_neigh = neigh->which_neighbor_am_i(elem);
1675             libmesh_assert_less (s_neigh, neigh->n_neighbors());
1676 
1677             // Find the minimum p level; we build the h constraint
1678             // matrix with this and then constrain away all higher p
1679             // DoFs\&.
1680             libmesh_assert(neigh->active());
1681             const unsigned int min_p_level =
1682               std::min(elem->p_level(), neigh->p_level());
1683 
1684             // we may need to make the FE objects reinit with the
1685             // minimum shared p_level
1686             // FIXME - I hate using const_cast<> and avoiding
1687             // accessor functions; there's got to be a
1688             // better way to do this!
1689             const unsigned int old_elem_level = elem->p_level();
1690             if (old_elem_level != min_p_level)
1691               (const_cast<Elem *>(elem))->hack_p_level(min_p_level);
1692             const unsigned int old_neigh_level = neigh->p_level();
1693             if (old_neigh_level != min_p_level)
1694               (const_cast<Elem *>(neigh))->hack_p_level(min_p_level);
1695 
1696             my_fe->reinit(elem, s);
1697 
1698             // This function gets called element-by-element, so there
1699             // will be a lot of memory allocation going on\&.  We can
1700             // at least minimize this for the case of the dof indices
1701             // by efficiently preallocating the requisite storage\&.
1702             // n_nodes is not necessarily n_dofs, but it is better
1703             // than nothing!
1704             my_dof_indices\&.reserve    (elem->n_nodes());
1705             neigh_dof_indices\&.reserve (neigh->n_nodes());
1706 
1707             dof_map\&.dof_indices (elem, my_dof_indices,
1708                                  variable_number);
1709             dof_map\&.dof_indices (neigh, neigh_dof_indices,
1710                                  variable_number);
1711 
1712             const unsigned int n_qp = my_qface\&.n_points();
1713 
1714             FEInterface::inverse_map (Dim, base_fe_type, neigh,
1715                                       q_point, neigh_qface);
1716 
1717             neigh_fe->reinit(neigh, &neigh_qface);
1718 
1719             // We're only concerned with DOFs whose values (and/or first
1720             // derivatives for C1 elements) are supported on side nodes
1721             FEInterface::dofs_on_side(elem,  Dim, base_fe_type, s,       my_side_dofs);
1722             FEInterface::dofs_on_side(neigh, Dim, base_fe_type, s_neigh, neigh_side_dofs);
1723 
1724             // We're done with functions that examine Elem::p_level(),
1725             // so let's unhack those levels
1726             if (elem->p_level() != old_elem_level)
1727               (const_cast<Elem *>(elem))->hack_p_level(old_elem_level);
1728             if (neigh->p_level() != old_neigh_level)
1729               (const_cast<Elem *>(neigh))->hack_p_level(old_neigh_level);
1730 
1731             const unsigned int n_side_dofs =
1732               libmesh_cast_int<unsigned int>(my_side_dofs\&.size());
1733             libmesh_assert_equal_to (n_side_dofs, neigh_side_dofs\&.size());
1734 
1735             Ke\&.resize (n_side_dofs, n_side_dofs);
1736             Ue\&.resize(n_side_dofs);
1737 
1738             // Form the projection matrix, (inner product of fine basis
1739             // functions against fine test functions)
1740             for (unsigned int is = 0; is != n_side_dofs; ++is)
1741               {
1742                 const unsigned int i = my_side_dofs[is];
1743                 for (unsigned int js = 0; js != n_side_dofs; ++js)
1744                   {
1745                     const unsigned int j = my_side_dofs[js];
1746                     for (unsigned int qp = 0; qp != n_qp; ++qp)
1747                       {
1748                         Ke(is,js) += JxW[qp] * TensorTools::inner_product(phi[i][qp], phi[j][qp]);
1749                         if (cont != C_ZERO)
1750                           Ke(is,js) += JxW[qp] *
1751                             TensorTools::inner_product((*dphi)[i][qp] *
1752                                                        (*face_normals)[qp],
1753                                                        (*dphi)[j][qp] *
1754                                                        (*face_normals)[qp]);
1755                       }
1756                   }
1757               }
1758 
1759             // Form the right hand sides, (inner product of coarse basis
1760             // functions against fine test functions)
1761             for (unsigned int is = 0; is != n_side_dofs; ++is)
1762               {
1763                 const unsigned int i = neigh_side_dofs[is];
1764                 Fe\&.resize (n_side_dofs);
1765                 for (unsigned int js = 0; js != n_side_dofs; ++js)
1766                   {
1767                     const unsigned int j = my_side_dofs[js];
1768                     for (unsigned int qp = 0; qp != n_qp; ++qp)
1769                       {
1770                         Fe(js) += JxW[qp] *
1771                           TensorTools::inner_product(neigh_phi[i][qp],
1772                                                      phi[j][qp]);
1773                         if (cont != C_ZERO)
1774                           Fe(js) += JxW[qp] *
1775                             TensorTools::inner_product((*neigh_dphi)[i][qp] *
1776                                                        (*face_normals)[qp],
1777                                                        (*dphi)[j][qp] *
1778                                                        (*face_normals)[qp]);
1779                       }
1780                   }
1781                 Ke\&.cholesky_solve(Fe, Ue[is]);
1782               }
1783 
1784             for (unsigned int js = 0; js != n_side_dofs; ++js)
1785               {
1786                 const unsigned int j = my_side_dofs[js];
1787                 const dof_id_type my_dof_g = my_dof_indices[j];
1788                 libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
1789 
1790                 // Hunt for "constraining against myself" cases before
1791                 // we bother creating a constraint row
1792                 bool self_constraint = false;
1793                 for (unsigned int is = 0; is != n_side_dofs; ++is)
1794                   {
1795                     const unsigned int i = neigh_side_dofs[is];
1796                     const dof_id_type their_dof_g = neigh_dof_indices[i];
1797                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
1798 
1799                     if (their_dof_g == my_dof_g)
1800                       {
1801 #ifndef NDEBUG
1802                         const Real their_dof_value = Ue[is](js);
1803                         libmesh_assert_less (std::abs(their_dof_value-1\&.),
1804                                              10*TOLERANCE);
1805 
1806                         for (unsigned int k = 0; k != n_side_dofs; ++k)
1807                           libmesh_assert(k == is ||
1808                                          std::abs(Ue[k](js)) <
1809                                          10*TOLERANCE);
1810 #endif
1811 
1812                         self_constraint = true;
1813                         break;
1814                       }
1815                   }
1816 
1817                 if (self_constraint)
1818                   continue;
1819 
1820                 DofConstraintRow* constraint_row;
1821 
1822                 // we may be running constraint methods concurrently
1823                 // on multiple threads, so we need a lock to
1824                 // ensure that this constraint is "ours"
1825                 {
1826                   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1827 
1828                   if (dof_map\&.is_constrained_dof(my_dof_g))
1829                     continue;
1830 
1831                   constraint_row = &(constraints[my_dof_g]);
1832                   libmesh_assert(constraint_row->empty());
1833                 }
1834 
1835                 for (unsigned int is = 0; is != n_side_dofs; ++is)
1836                   {
1837                     const unsigned int i = neigh_side_dofs[is];
1838                     const dof_id_type their_dof_g = neigh_dof_indices[i];
1839                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
1840                     libmesh_assert_not_equal_to (their_dof_g, my_dof_g);
1841 
1842                     const Real their_dof_value = Ue[is](js);
1843 
1844                     if (std::abs(their_dof_value) < 10*TOLERANCE)
1845                       continue;
1846 
1847                     constraint_row->insert(std::make_pair(their_dof_g,
1848                                                           their_dof_value));
1849                   }
1850               }
1851           }
1852         // p refinement constraints:
1853         // constrain dofs shared between
1854         // active elements and neighbors with
1855         // lower polynomial degrees
1856         const unsigned int min_p_level =
1857           neigh->min_p_level_by_neighbor(elem, elem->p_level());
1858         if (min_p_level < elem->p_level())
1859           {
1860             // Adaptive p refinement of non-hierarchic bases will
1861             // require more coding
1862             libmesh_assert(my_fe->is_hierarchic());
1863             dof_map\&.constrain_p_dofs(variable_number, elem,
1864                                      s, min_p_level);
1865           }
1866       }
1867 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::compute_shape_functions (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)\fC [protected]\fP, \fC [virtual]\fP"
After having updated the jacobian and the transformation from local to global coordinates in \fCFEAbstract::compute_map()\fP, the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx\fP, \fCdphidy\fP, and \fCdphidz\fP\&. This method should rarely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP\&.
.PP
Definition at line 929 of file fe_base\&.C\&.
.PP
References libMesh::dim, libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
931 {
932   //-------------------------------------------------------------------------
933   // Compute the shape function values (and derivatives)
934   // at the Quadrature points\&.  Note that the actual values
935   // have already been computed via init_shape_functions
936 
937   // Start logging the shape function computation
938   START_LOG("compute_shape_functions()", "FE");
939 
940   calculations_started = true;
941 
942   // If the user forgot to request anything, we'll be safe and
943   // calculate everything:
944 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
945   if (!calculate_phi && !calculate_dphi && !calculate_d2phi && !calculate_curl_phi && !calculate_div_phi)
946     {
947       calculate_phi = calculate_dphi = calculate_d2phi = true;
948       // Only compute curl, div for vector-valued elements
949       if( TypesEqual<OutputType,RealGradient>::value )
950         {
951           calculate_curl_phi = true;
952           calculate_div_phi  = true;
953         }
954     }
955 #else
956   if (!calculate_phi && !calculate_dphi && !calculate_curl_phi && !calculate_div_phi)
957     {
958       calculate_phi = calculate_dphi = true;
959       // Only compute curl for vector-valued elements
960       if( TypesEqual<OutputType,RealGradient>::value )
961         {
962           calculate_curl_phi = true;
963           calculate_div_phi  = true;
964         }
965     }
966 #endif // LIBMESH_ENABLE_SECOND_DERIVATIVES
967 
968 
969   if( calculate_phi )
970     this->_fe_trans->map_phi( this->dim, elem, qp, (*this), this->phi );
971 
972   if( calculate_dphi )
973     this->_fe_trans->map_dphi( this->dim, elem, qp, (*this), this->dphi,
974                                this->dphidx, this->dphidy, this->dphidz );
975 
976 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
977   if( calculate_d2phi )
978     this->_fe_trans->map_d2phi( this->dim, elem, qp, (*this), this->d2phi,
979                                 this->d2phidx2, this->d2phidxdy, this->d2phidxdz,
980                                 this->d2phidy2, this->d2phidydz, this->d2phidz2 );
981 #endif //LIBMESH_ENABLE_SECOND_DERIVATIVES
982 
983   // Only compute curl for vector-valued elements
984   if( calculate_curl_phi && TypesEqual<OutputType,RealGradient>::value )
985     this->_fe_trans->map_curl( this->dim, elem, qp, (*this), this->curl_phi );
986 
987   // Only compute div for vector-valued elements
988   if( calculate_div_phi && TypesEqual<OutputType,RealGradient>::value )
989     this->_fe_trans->map_div( this->dim, elem, qp, (*this), this->div_phi );
990 
991   // Stop logging the shape function computation
992   STOP_LOG("compute_shape_functions()", "FE");
993 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "virtual void libMesh::FEAbstract::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *pts = \fCNULL\fP, const std::vector< \fBReal\fP > *weights = \fCNULL\fP)\fC [pure virtual]\fP, \fC [inherited]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP of the element \fCelem\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fCinverse_map()\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference \fIedge\fP element may be specified in the optional argument \fCpts\fP\&. 
.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual \fBFEContinuity\fP libMesh::FEAbstract::get_continuity () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.PP
Referenced by libMesh::ProjectFEMSolution::operator()()\&.
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_curl_phi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the curl of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 225 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEMContext::interior_curl()\&.
.PP
.nf
226   { libmesh_assert(!calculations_started || calculate_curl_phi);
227     calculate_curl_phi = calculate_dphiref = true; return curl_phi; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputTensor\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_interior_hessian(), libMesh::FEMContext::fixed_side_hessian(), libMesh::FEMContext::interior_hessian(), libMesh::FEMContext::interior_hessians(), libMesh::FEMContext::side_hessian(), and libMesh::FEMContext::side_hessians()\&.
.PP
.nf
292   { libmesh_assert(!calculations_started || calculate_d2phi);
293     calculate_d2phi = calculate_dphiref = true; return d2phi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phideta2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 371 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
372   { libmesh_assert(!calculations_started || calculate_d2phi);
373     calculate_d2phi = calculate_dphiref = true; return d2phideta2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidetadzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 379 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
380   { libmesh_assert(!calculations_started || calculate_d2phi);
381     calculate_d2phi = calculate_dphiref = true; return d2phidetadzeta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidx2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_base\&.h\&.
.PP
.nf
300   { libmesh_assert(!calculations_started || calculate_d2phi);
301     calculate_d2phi = calculate_dphiref = true; return d2phidx2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxdy () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 307 of file fe_base\&.h\&.
.PP
.nf
308   { libmesh_assert(!calculations_started || calculate_d2phi);
309     calculate_d2phi = calculate_dphiref = true; return d2phidxdy; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxdz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 315 of file fe_base\&.h\&.
.PP
.nf
316   { libmesh_assert(!calculations_started || calculate_d2phi);
317     calculate_d2phi = calculate_dphiref = true; return d2phidxdz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxi2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 347 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
348   { libmesh_assert(!calculations_started || calculate_d2phi);
349     calculate_d2phi = calculate_dphiref = true; return d2phidxi2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxideta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 355 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
356   { libmesh_assert(!calculations_started || calculate_d2phi);
357     calculate_d2phi = calculate_dphiref = true; return d2phidxideta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxidzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 363 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
364   { libmesh_assert(!calculations_started || calculate_d2phi);
365     calculate_d2phi = calculate_dphiref = true; return d2phidxidzeta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidy2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 323 of file fe_base\&.h\&.
.PP
.nf
324   { libmesh_assert(!calculations_started || calculate_d2phi);
325     calculate_d2phi =  calculate_dphiref = true; return d2phidy2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidydz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 331 of file fe_base\&.h\&.
.PP
.nf
332   { libmesh_assert(!calculations_started || calculate_d2phi);
333     calculate_d2phi = calculate_dphiref = true; return d2phidydz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidz2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 339 of file fe_base\&.h\&.
.PP
.nf
340   { libmesh_assert(!calculations_started || calculate_d2phi);
341     calculate_d2phi = calculate_dphiref = true; return d2phidz2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidzeta2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 387 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
388   { libmesh_assert(!calculations_started || calculate_d2phi);
389     calculate_d2phi = calculate_dphiref = true; return d2phidzeta2; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputDivergence\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_div_phi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the divergence of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 233 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEMContext::interior_div()\&.
.PP
.nf
234   { libmesh_assert(!calculations_started || calculate_div_phi);
235     calculate_div_phi = calculate_dphiref = true; return div_phi; }
.fi
.SS "template<typename T> const std::vector<\fBOutputGradient\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_dphase () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the global first derivative of the phase term which is used in infinite elements, evaluated at the quadrature points\&.
.RE
.PP
In case of the general finite element class \fC\fBFE\fP\fP this field is initialized to all zero, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 405 of file fe_base\&.h\&.
.PP
.nf
406   { return dphase; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputGradient\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 217 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_side_gradient(), libMesh::FEMContext::interior_gradient(), libMesh::FEMContext::interior_gradients(), libMesh::ProjectFEMSolution::operator()(), libMesh::FEMContext::side_gradient(), and libMesh::FEMContext::side_gradients()\&.
.PP
.nf
218   { libmesh_assert(!calculations_started || calculate_dphi);
219     calculate_dphi = calculate_dphiref = true; return dphi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphideta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function eta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 273 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
274   { libmesh_assert(!calculations_started || calculate_dphiref);
275     calculate_dphiref = true; return dphideta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidx () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function x-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_base\&.h\&.
.PP
.nf
242   { libmesh_assert(!calculations_started || calculate_dphi);
243     calculate_dphi = calculate_dphiref = true; return dphidx; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidxi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function xi-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 265 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
266   { libmesh_assert(!calculations_started || calculate_dphiref);
267     calculate_dphiref = true; return dphidxi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidy () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function y-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 249 of file fe_base\&.h\&.
.PP
.nf
250   { libmesh_assert(!calculations_started || calculate_dphi);
251     calculate_dphi = calculate_dphiref = true; return dphidy; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function z-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_base\&.h\&.
.PP
.nf
258   { libmesh_assert(!calculations_started || calculate_dphi);
259     calculate_dphi = calculate_dphiref = true; return dphidz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function zeta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 281 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
282   { libmesh_assert(!calculations_started || calculate_dphiref);
283     calculate_dphiref = true; return dphidzeta; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level, libMesh::FEAbstract::fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_phi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function values at the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 209 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_interior_value(), libMesh::FEMContext::fixed_side_value(), libMesh::FEMSystem::init_context(), libMesh::FEMContext::interior_value(), libMesh::FEMContext::interior_values(), libMesh::ProjectFEMSolution::operator()(), libMesh::FEMContext::side_value(), and libMesh::FEMContext::side_values()\&.
.PP
.nf
210   { libmesh_assert(!calculations_started || calculate_phi);
211     calculate_phi = true; return phi; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP, \fC [inherited]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "template<typename T> const std::vector<\fBRealGradient\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_Sobolev_dweight () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the first global derivative of the multiplicative weight at each quadrature point\&. See \fC\fBget_Sobolev_weight()\fP\fP for details\&. In case of \fC\fBFE\fP\fP initialized to all zero\&. 
.RE
.PP

.PP
Definition at line 429 of file fe_base\&.h\&.
.PP
.nf
430   { return dweight; }
.fi
.SS "template<typename T> const std::vector<\fBReal\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_Sobolev_weight () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the multiplicative weight at each quadrature point\&. This weight is used for certain infinite element weak formulations, so that \fIweighted\fP Sobolev spaces are used for the trial function space\&. This renders the variational form easily computable\&.
.RE
.PP
In case of the general finite element class \fC\fBFE\fP\fP this field is initialized to all ones, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 421 of file fe_base\&.h\&.
.PP
.nf
422   { return weight; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<typename T> virtual void \fBlibMesh::FEGenericBase\fP< T >::init_base_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [pure virtual]\fP"
Initialize the data fields for the base of an an infinite element\&. Implement this in the derived class \fCFE<Dim,T>\fP\&. 
.PP
Implemented in \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "virtual bool libMesh::FEAbstract::is_hierarchic () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "virtual unsigned int libMesh::FEAbstract::n_quadrature_points () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Useful during matrix assembly\&. Implement this in derived classes\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "virtual unsigned int libMesh::FEAbstract::n_shape_functions () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of approximation shape functions for the current element\&. Useful during matrix assembly\&. Implement this in derived classes\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_d2phi (std::ostream &os) const\fC [virtual]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1021 of file fe_base\&.C\&.
.PP
.nf
1022 {
1023   for (unsigned int i=0; i<dphi\&.size(); ++i)
1024     for (unsigned int j=0; j<dphi[i]\&.size(); ++j)
1025       os << " d2phi[" << i << "][" << j << "]=" << d2phi[i][j];
1026 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_dphi (std::ostream &os) const\fC [virtual]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1008 of file fe_base\&.C\&.
.PP
.nf
1009 {
1010   for (unsigned int i=0; i<dphi\&.size(); ++i)
1011     for (unsigned int j=0; j<dphi[i]\&.size(); ++j)
1012       os << " dphi[" << i << "][" << j << "]=" << dphi[i][j];
1013 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const\fC [inherited]\fP"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_dphi(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_phi(), and libMesh::FEAbstract::print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_phi (std::ostream &os) const\fC [virtual]\fP"
Prints the value of each shape function at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 997 of file fe_base\&.C\&.
.PP
.nf
998 {
999   for (unsigned int i=0; i<phi\&.size(); ++i)
1000     for (unsigned int j=0; j<phi[i]\&.size(); ++j)
1001       os << " phi[" << i << "][" << j << "]=" << phi[i][j] << std::endl;
1002 }
.fi
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "virtual void libMesh::FEAbstract::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [pure virtual]\fP, \fC [inherited]\fP"
This is at the core of this class\&. Use this for each new element in the mesh\&. Reinitializes the requested physical element-dependent data based on the current element \fCelem\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference element may be specified in the optional argument \fCpts\fP\&.
.PP
Note that the \fBFE\fP classes decide which data to initialize based on which accessor functions such as \fCget_phi()\fP or \fCget_d2phi()\fP have been called, so all such accessors should be called before the first \fC\fBreinit()\fP\fP\&. 
.PP
Implemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error()\&.
.SS "virtual void libMesh::FEAbstract::reinit (const \fBElem\fP *elem, const unsigned intside, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [pure virtual]\fP, \fC [inherited]\fP"
Reinitializes all the physical element-dependent data based on the \fCside\fP of the element \fCelem\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fCinverse_map()\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference \fIside\fP element may be specified in the optional argument \fCpts\fP\&. 
.PP
Implemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "virtual bool libMesh::FEAbstract::shapes_need_reinit () const\fC [protected]\fP, \fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.SS "virtual void libMesh::FEAbstract::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigned ints, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [pure virtual]\fP, \fC [inherited]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename T> template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> friend class \fBInfFE\fP\fC [friend]\fP"
Make all \fCInfFE<Dim,T_radial,T_map>\fP classes friends so that they can safely used \fC\fBFE\fP<Dim-1\fP,T_base> through a \fCFEGenericBase*\fP as base approximation\&. 
.PP
Definition at line 653 of file fe_base\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_curvatures(), libMesh::FEAbstract::get_d2xyzdeta2(), libMesh::FEAbstract::get_d2xyzdetadzeta(), libMesh::FEAbstract::get_d2xyzdxi2(), libMesh::FEAbstract::get_d2xyzdxideta(), libMesh::FEAbstract::get_d2xyzdxidzeta(), libMesh::FEAbstract::get_d2xyzdzeta2(), libMesh::FEAbstract::get_detadx(), libMesh::FEAbstract::get_detady(), libMesh::FEAbstract::get_detadz(), libMesh::FEAbstract::get_dxidx(), libMesh::FEAbstract::get_dxidy(), libMesh::FEAbstract::get_dxidz(), libMesh::FEAbstract::get_dxyzdeta(), libMesh::FEAbstract::get_dxyzdxi(), libMesh::FEAbstract::get_dxyzdzeta(), libMesh::FEAbstract::get_dzetadx(), libMesh::FEAbstract::get_dzetady(), libMesh::FEAbstract::get_dzetadz(), libMesh::FEAbstract::get_fe_map(), libMesh::FEAbstract::get_JxW(), libMesh::FEAbstract::get_normals(), libMesh::FEAbstract::get_tangents(), libMesh::FEAbstract::get_xyz(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_xyz(), and libMesh::FESubdivision::reinit()\&.
.SS "template<typename T> \fBAutoPtr\fP<\fBFETransformationBase\fP<OutputType> > \fBlibMesh::FEGenericBase\fP< T >::_fe_trans\fC [protected]\fP"
Object that handles computing shape function values, gradients, etc in the physical domain\&. 
.PP
Definition at line 489 of file fe_base\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP, \fC [inherited]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_order(), and libMesh::FEAbstract::get_p_level()\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::curl_phi\fC [protected]\fP"
Shape function curl values\&. Only defined for vector types\&. 
.PP
Definition at line 504 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputTensor\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phi\fC [protected]\fP"
Shape function second derivative values\&. 
.PP
Definition at line 547 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phideta2\fC [protected]\fP"
Shape function second derivatives in the eta direction\&. 
.PP
Definition at line 567 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidetadzeta\fC [protected]\fP"
Shape function second derivatives in the eta-zeta direction\&. 
.PP
Definition at line 572 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidx2\fC [protected]\fP"
Shape function second derivatives in the x direction\&. 
.PP
Definition at line 582 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxdy\fC [protected]\fP"
Shape function second derivatives in the x-y direction\&. 
.PP
Definition at line 587 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxdz\fC [protected]\fP"
Shape function second derivatives in the x-z direction\&. 
.PP
Definition at line 592 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxi2\fC [protected]\fP"
Shape function second derivatives in the xi direction\&. 
.PP
Definition at line 552 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxideta\fC [protected]\fP"
Shape function second derivatives in the xi-eta direction\&. 
.PP
Definition at line 557 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxidzeta\fC [protected]\fP"
Shape function second derivatives in the xi-zeta direction\&. 
.PP
Definition at line 562 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidy2\fC [protected]\fP"
Shape function second derivatives in the y direction\&. 
.PP
Definition at line 597 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidydz\fC [protected]\fP"
Shape function second derivatives in the y-z direction\&. 
.PP
Definition at line 602 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidz2\fC [protected]\fP"
Shape function second derivatives in the z direction\&. 
.PP
Definition at line 607 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidzeta2\fC [protected]\fP"
Shape function second derivatives in the zeta direction\&. 
.PP
Definition at line 577 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2()\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP, \fC [inherited]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputDivergence\fP> > \fBlibMesh::FEGenericBase\fP< T >::div_phi\fC [protected]\fP"
Shape function divergence values\&. Only defined for vector types\&. 
.PP
Definition at line 509 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "template<typename T> std::vector<\fBOutputGradient\fP> \fBlibMesh::FEGenericBase\fP< T >::dphase\fC [protected]\fP"
Used for certain \fIinfinite\fP element families: the first derivatives of the phase term in global coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 625 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphase()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputGradient\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphi\fC [protected]\fP"
Shape function derivative values\&. 
.PP
Definition at line 499 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphideta\fC [protected]\fP"
Shape function derivatives in the eta direction\&. 
.PP
Definition at line 519 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidx\fC [protected]\fP"
Shape function derivatives in the x direction\&. 
.PP
Definition at line 529 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidxi\fC [protected]\fP"
Shape function derivatives in the xi direction\&. 
.PP
Definition at line 514 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidy\fC [protected]\fP"
Shape function derivatives in the y direction\&. 
.PP
Definition at line 534 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidz\fC [protected]\fP"
Shape function derivatives in the z direction\&. 
.PP
Definition at line 539 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidzeta\fC [protected]\fP"
Shape function derivatives in the zeta direction\&. 
.PP
Definition at line 524 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "template<typename T> std::vector<\fBRealGradient\fP> \fBlibMesh::FEGenericBase\fP< T >::dweight\fC [protected]\fP"
Used for certain \fIinfinite\fP element families: the global derivative of the additional radial weight $ 1/{r^2} $, over \fIall\fP quadrature points\&. 
.PP
Definition at line 632 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_Sobolev_dweight()\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP, \fC [inherited]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FEAbstract::get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP, \fC [inherited]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::compute_node_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEAbstract::get_family(), libMesh::FEAbstract::get_fe_type(), libMesh::FEAbstract::get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::phi\fC [protected]\fP"
Shape function values\&. 
.PP
Definition at line 494 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP, \fC [inherited]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FESubdivision::reinit()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP, \fC [inherited]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "template<typename T> std::vector<\fBReal\fP> \fBlibMesh::FEGenericBase\fP< T >::weight\fC [protected]\fP"
Used for certain \fIinfinite\fP element families: the additional radial weight $ 1/{r^2} $ in local coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 639 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_Sobolev_weight()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
