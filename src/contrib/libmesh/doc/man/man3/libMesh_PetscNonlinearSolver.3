.TH "libMesh::PetscNonlinearSolver< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::PetscNonlinearSolver< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <petsc_nonlinear_solver\&.h>\fP
.PP
Inherits \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Inherited by \fBlibMesh::PetscDMNonlinearSolver< T >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBNonlinearImplicitSystem\fP \fBsys_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPetscNonlinearSolver\fP (\fBsys_type\fP &\fBsystem\fP)"
.br
.ti -1c
.RI "\fB~PetscNonlinearSolver\fP ()"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit\fP (const char *name=NULL)"
.br
.ti -1c
.RI "SNES \fBsnes\fP ()"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBsolve\fP (\fBSparseMatrix\fP< T > &, \fBNumericVector\fP< T > &, \fBNumericVector\fP< T > &, const double, const unsigned int)"
.br
.ti -1c
.RI "virtual void \fBprint_converged_reason\fP ()"
.br
.ti -1c
.RI "SNESConvergedReason \fBget_converged_reason\fP ()"
.br
.ti -1c
.RI "virtual int \fBget_total_linear_iterations\fP ()"
.br
.ti -1c
.RI "virtual unsigned \fBget_current_nonlinear_iteration_number\fP () const "
.br
.ti -1c
.RI "void \fBset_residual_zero_out\fP (bool state)"
.br
.ti -1c
.RI "void \fBset_jacobian_zero_out\fP (bool state)"
.br
.ti -1c
.RI "void \fBuse_default_monitor\fP (bool state)"
.br
.ti -1c
.RI "bool \fBinitialized\fP () const "
.br
.ti -1c
.RI "const \fBsys_type\fP & \fBsystem\fP () const "
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "void \fBattach_preconditioner\fP (\fBPreconditioner\fP< T > *preconditioner)"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP
.br
< \fBNonlinearSolver\fP< T > > \fBbuild\fP (\fBsys_type\fP &s, const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "void(* \fBresidual\fP )(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBNumericVector\fP< \fBNumber\fP > &R, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeResidual\fP * \fBresidual_object\fP"
.br
.ti -1c
.RI "void(* \fBjacobian\fP )(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBSparseMatrix\fP< \fBNumber\fP > &J, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeJacobian\fP * \fBjacobian_object\fP"
.br
.ti -1c
.RI "void(* \fBmatvec\fP )(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBNumericVector\fP< \fBNumber\fP > *R, \fBSparseMatrix\fP< \fBNumber\fP > *J, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeResidualandJacobian\fP * \fBresidual_and_jacobian_object\fP"
.br
.ti -1c
.RI "void(* \fBbounds\fP )(\fBNumericVector\fP< \fBNumber\fP > &XL, \fBNumericVector\fP< \fBNumber\fP > &XU, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeBounds\fP * \fBbounds_object\fP"
.br
.ti -1c
.RI "void(* \fBnullspace\fP )(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &sp, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeVectorSubspace\fP * \fBnullspace_object\fP"
.br
.ti -1c
.RI "void(* \fBnearnullspace\fP )(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &sp, \fBsys_type\fP &S)"
.br
.ti -1c
.RI "\fBNonlinearImplicitSystem::ComputeVectorSubspace\fP * \fBnearnullspace_object\fP"
.br
.ti -1c
.RI "void(* \fBuser_presolve\fP )(\fBsys_type\fP &S)"
.br
.ti -1c
.RI "unsigned int \fBmax_nonlinear_iterations\fP"
.br
.ti -1c
.RI "unsigned int \fBmax_function_evaluations\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBabsolute_residual_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBrelative_residual_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBabsolute_step_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBrelative_step_tolerance\fP"
.br
.ti -1c
.RI "unsigned int \fBmax_linear_iterations\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBinitial_linear_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBminimum_linear_tolerance\fP"
.br
.ti -1c
.RI "bool \fBconverged\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "SNES \fB_snes\fP"
.br
.ti -1c
.RI "SNESConvergedReason \fB_reason\fP"
.br
.ti -1c
.RI "\fBPetscInt\fP \fB_n_linear_iterations\fP"
.br
.ti -1c
.RI "unsigned \fB_current_nonlinear_iteration_number\fP"
.br
.ti -1c
.RI "bool \fB_zero_out_residual\fP"
.br
.ti -1c
.RI "bool \fB_zero_out_jacobian\fP"
.br
.ti -1c
.RI "bool \fB_default_monitor\fP"
.br
.ti -1c
.RI "\fBsys_type\fP & \fB_system\fP"
.br
.ti -1c
.RI "bool \fB_is_initialized\fP"
.br
.ti -1c
.RI "\fBPreconditioner\fP< T > * \fB_preconditioner\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBbuild_mat_null_space\fP (\fBNonlinearImplicitSystem::ComputeVectorSubspace\fP *computeSubspaceObject, void(*)(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &, \fBsys_type\fP &), MatNullSpace *)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_residual\fP (SNES \fBsnes\fP, Vec \fBx\fP, Vec r, void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_jacobian\fP (SNES \fBsnes\fP, Vec \fBx\fP, Mat *\fBjac\fP, Mat *\fBpc\fP, MatStructure *msflag, void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_jacobian\fP (SNES \fBsnes\fP, Vec \fBx\fP, Mat \fBjac\fP, Mat \fBpc\fP, void *ctx)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::PetscNonlinearSolver< T >"
This class provides an interface to PETSc iterative solvers that is compatible with the \fC\fBlibMesh\fP\fP \fCNonlinearSolver<>\fP 
.PP
\fBAuthor:\fP
.RS 4
Benjamin Kirk, 2002-2007 
.RE
.PP

.PP
Definition at line 63 of file petsc_nonlinear_solver\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "template<typename T> typedef \fBNonlinearImplicitSystem\fP \fBlibMesh::PetscNonlinearSolver\fP< T >::\fBsys_type\fP"
The type of system 
.PP
Definition at line 69 of file petsc_nonlinear_solver\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T> \fBlibMesh::PetscNonlinearSolver\fP< T >::\fBPetscNonlinearSolver\fP (\fBsys_type\fP &system)\fC [explicit]\fP"
Constructor\&. Initializes Petsc data structures 
.SS "template<typename T > \fBlibMesh::PetscNonlinearSolver\fP< T >::~\fBPetscNonlinearSolver\fP ()"
Destructor\&. 
.PP
Definition at line 267 of file petsc_nonlinear_solver\&.C\&.
.PP
.nf
268 {
269   this->clear ();
270 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T> void \fBlibMesh::NonlinearSolver\fP< T >::attach_preconditioner (\fBPreconditioner\fP< T > *preconditioner)\fC [inherited]\fP"
Attaches a \fBPreconditioner\fP object to be used during the linear solves\&. 
.PP
Definition at line 91 of file nonlinear_solver\&.C\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, and libMesh::err\&.
.PP
.nf
92 {
93   if(this->_is_initialized)
94     {
95       libMesh::err << "Preconditioner must be attached before the solver is initialized!"<<std::endl;
96       libmesh_error();
97     }
98 
99   _preconditioner = preconditioner;
100 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNonlinearSolver\fP< T > > \fBlibMesh::NonlinearSolver\fP< T >::build (\fBsys_type\fP &s, const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBNonlinearSolver\fP\fP using the nonlinear solver package specified by \fCsolver_package\fP 
.PP
Definition at line 38 of file nonlinear_solver\&.C\&.
.PP
References libMesh::err, libMesh::on_command_line(), libMesh::PETSC_SOLVERS, libMesh::AutoPtr< Tp >::reset(), and libMesh::TRILINOS_SOLVERS\&.
.PP
.nf
39 {
40   AutoPtr<NonlinearSolver<T> > ap;
41 
42   // Build the appropriate solver
43   switch (solver_package)
44     {
45 
46 #ifdef LIBMESH_HAVE_PETSC
47     case PETSC_SOLVERS:
48 #if PETSC_VERSION_LESS_THAN(3,3,0)
49       ap\&.reset(new PetscNonlinearSolver<T>(s));
50       break;
51 #else
52       if (libMesh::on_command_line ("--use-petsc-dm")){
53         ap\&.reset(new PetscDMNonlinearSolver<T>(s));
54       }
55       else {
56         ap\&.reset(new PetscNonlinearSolver<T>(s));
57       }
58       break;
59 #endif
60 #endif // LIBMESH_HAVE_PETSC
61 
62 #ifdef LIBMESH_HAVE_NOX
63     case TRILINOS_SOLVERS:
64       ap\&.reset(new NoxNonlinearSolver<T>(s));
65       break;
66 #endif
67 
68     default:
69       libMesh::err << "ERROR:  Unrecognized solver package: "
70                    << solver_package
71                    << std::endl;
72       libmesh_error();
73     }
74 
75   return ap;
76 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscNonlinearSolver\fP< T >::build_mat_null_space (\fBNonlinearImplicitSystem::ComputeVectorSubspace\fP *computeSubspaceObject, void(*)(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &, \fBsys_type\fP &)computeSubspace, MatNullSpace *msp)\fC [private]\fP"

.PP
Definition at line 369 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::comm, ierr, and libMesh::PetscVector< T >::vec()\&.
.PP
.nf
372 {
373   PetscErrorCode ierr;
374   std::vector<NumericVector<Number>* > sp;
375   if (computeSubspaceObject)
376     (*computeSubspaceObject)(sp, this->system());
377   else
378     (*computeSubspace)(sp, this->system());
379 
380   *msp = PETSC_NULL;
381   if (sp\&.size())
382     {
383       Vec *modes;
384       PetscScalar *dots;
385       PetscInt nmodes = sp\&.size();
386 
387 #if PETSC_RELEASE_LESS_THAN(3,5,0)
388       ierr = PetscMalloc2(nmodes,Vec,&modes,nmodes,PetscScalar,&dots);
389 #else
390       ierr = PetscMalloc2(nmodes,&modes,nmodes,&dots);
391 #endif
392       LIBMESH_CHKERRABORT(ierr);
393 
394       for (PetscInt i=0; i<nmodes; ++i)
395         {
396           PetscVector<T>* pv = libmesh_cast_ptr<PetscVector<T>*>(sp[i]);
397           Vec v = pv->vec();
398 
399           ierr = VecDuplicate(v, modes+i);
400           LIBMESH_CHKERRABORT(ierr);
401 
402           ierr = VecCopy(v,modes[i]);
403           LIBMESH_CHKERRABORT(ierr);
404         }
405 
406       // Normalize\&.
407       ierr = VecNormalize(modes[0],PETSC_NULL);
408       LIBMESH_CHKERRABORT(ierr);
409 
410       for (PetscInt i=1; i<nmodes; i++)
411         {
412           // Orthonormalize vec[i] against vec[0:i-1]
413           ierr = VecMDot(modes[i],i,modes,dots);
414           LIBMESH_CHKERRABORT(ierr);
415 
416           for (PetscInt j=0; j<i; j++)
417             dots[j] *= -1\&.;
418 
419           ierr = VecMAXPY(modes[i],i,dots,modes);
420           LIBMESH_CHKERRABORT(ierr);
421 
422           ierr = VecNormalize(modes[i],PETSC_NULL);
423           LIBMESH_CHKERRABORT(ierr);
424         }
425 
426       ierr = MatNullSpaceCreate(this->comm()\&.get(), PETSC_FALSE, nmodes, modes, msp);
427       LIBMESH_CHKERRABORT(ierr);
428 
429       for (PetscInt i=0; i<nmodes; ++i)
430         {
431           ierr = VecDestroy(modes+i);
432           LIBMESH_CHKERRABORT(ierr);
433         }
434 
435       ierr = PetscFree2(modes,dots);
436       LIBMESH_CHKERRABORT(ierr);
437     }
438 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscNonlinearSolver\fP< T >::clear ()\fC [virtual]\fP"
Release all memory and clear data structures\&. 
.PP
Reimplemented from \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Definition at line 275 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::_current_nonlinear_iteration_number, libMesh::libMeshPrivateData::_is_initialized, and libMesh::initialized()\&.
.PP
.nf
276 {
277   if (this->initialized())
278     {
279       this->_is_initialized = false;
280 
281       PetscErrorCode ierr=0;
282 
283       ierr = LibMeshSNESDestroy(&_snes);
284       LIBMESH_CHKERRABORT(ierr);
285 
286       // Reset the nonlinear iteration counter\&.  This information is only relevant
287       // *during* the solve()\&.  After the solve is completed it should return to
288       // the default value of 0\&.
289       _current_nonlinear_iteration_number = 0;
290     }
291 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "template<typename T > SNESConvergedReason \fBlibMesh::PetscNonlinearSolver\fP< T >::get_converged_reason ()"
Returns the currently-available (or most recently obtained, if the SNES object has been destroyed) convergence reason\&. Refer to PETSc docs for the meaning of different SNESConvergedReasons\&. 
.PP
Definition at line 593 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::initialized()\&.
.PP
.nf
594 {
595   PetscErrorCode ierr=0;
596 
597   if (this->initialized())
598     {
599       ierr = SNESGetConvergedReason(_snes, &_reason);
600       LIBMESH_CHKERRABORT(ierr);
601     }
602 
603   return _reason;
604 }
.fi
.SS "template<typename T> virtual unsigned \fBlibMesh::PetscNonlinearSolver\fP< T >::get_current_nonlinear_iteration_number () const\fC [inline]\fP, \fC [virtual]\fP"
If called \fIduring\fP the \fBsolve()\fP, for example by the user-specified residual or Jacobian function, returns the current nonlinear iteration number\&. 
.PP
Implements \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Definition at line 131 of file petsc_nonlinear_solver\&.h\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_current_nonlinear_iteration_number\&.
.PP
.nf
131 { return _current_nonlinear_iteration_number; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "template<typename T > int \fBlibMesh::PetscNonlinearSolver\fP< T >::get_total_linear_iterations ()\fC [virtual]\fP"
Get the total number of linear iterations done in the last solve 
.PP
Implements \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Definition at line 607 of file petsc_nonlinear_solver\&.C\&.
.PP
.nf
608 {
609   return _n_linear_iterations;
610 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscNonlinearSolver\fP< T >::init (const char *name = \fCNULL\fP)\fC [virtual]\fP"
Initialize data structures if not done so already\&. May assign a name to the solver in some implementations 
.PP
Implements \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Reimplemented in \fBlibMesh::PetscDMNonlinearSolver< T >\fP\&.
.PP
Definition at line 296 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::__libmesh_petsc_preconditioner_apply(), libMesh::__libmesh_petsc_preconditioner_setup(), libMesh::__libmesh_petsc_snes_monitor(), libMesh::libMeshPrivateData::_is_initialized, libMesh::comm, libMesh::initialized(), and pc\&.
.PP
Referenced by libMesh::PetscDMNonlinearSolver< T >::init(), and libMesh::PetscNonlinearSolver< T >::snes()\&.
.PP
.nf
297 {
298   // Initialize the data structures if not done so already\&.
299   if (!this->initialized())
300     {
301       this->_is_initialized = true;
302 
303       PetscErrorCode ierr=0;
304 
305 #if PETSC_VERSION_LESS_THAN(2,1,2)
306       // At least until Petsc 2\&.1\&.1, the SNESCreate had a different calling syntax\&.
307       // The second argument was of type SNESProblemType, and could have a value of
308       // either SNES_NONLINEAR_EQUATIONS or SNES_UNCONSTRAINED_MINIMIZATION\&.
309       ierr = SNESCreate(this->comm()\&.get(), SNES_NONLINEAR_EQUATIONS, &_snes);
310       LIBMESH_CHKERRABORT(ierr);
311 
312 #else
313 
314       ierr = SNESCreate(this->comm()\&.get(),&_snes);
315       LIBMESH_CHKERRABORT(ierr);
316 
317 #endif
318 
319       if (name)
320         {
321           ierr = SNESSetOptionsPrefix(_snes, name);
322           LIBMESH_CHKERRABORT(ierr);
323         }
324 
325       if (_default_monitor)
326         {
327 #if PETSC_VERSION_LESS_THAN(2,3,3)
328           ierr = SNESSetMonitor (_snes, __libmesh_petsc_snes_monitor,
329                                  this, PETSC_NULL);
330 #else
331           // API name change in PETSc 2\&.3\&.3
332           ierr = SNESMonitorSet (_snes, __libmesh_petsc_snes_monitor,
333                                  this, PETSC_NULL);
334 #endif
335           LIBMESH_CHKERRABORT(ierr);
336         }
337 
338 #if PETSC_VERSION_LESS_THAN(3,1,0)
339       // Cannot call SNESSetOptions before SNESSetFunction when using
340       // any matrix free options with PETSc 3\&.1\&.0+
341       ierr = SNESSetFromOptions(_snes);
342       LIBMESH_CHKERRABORT(ierr);
343 #endif
344 
345       if(this->_preconditioner)
346         {
347           KSP ksp;
348           ierr = SNESGetKSP (_snes, &ksp);
349           LIBMESH_CHKERRABORT(ierr);
350           PC pc;
351           ierr = KSPGetPC(ksp,&pc);
352           LIBMESH_CHKERRABORT(ierr);
353 
354           this->_preconditioner->init();
355 
356           PCSetType(pc, PCSHELL);
357           PCShellSetContext(pc,(void*)this->_preconditioner);
358 
359           //Re-Use the shell functions from petsc_linear_solver
360           PCShellSetSetUp(pc,__libmesh_petsc_preconditioner_setup);
361           PCShellSetApply(pc,__libmesh_petsc_preconditioner_apply);
362         }
363     }
364 }
.fi
.SS "template<typename T> bool \fBlibMesh::NonlinearSolver\fP< T >::initialized () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the data structures are initialized, false otherwise\&. 
.RE
.PP

.PP
Definition at line 86 of file nonlinear_solver\&.h\&.
.PP
.nf
86 { return _is_initialized; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "template<typename T > void \fBlibMesh::PetscNonlinearSolver\fP< T >::print_converged_reason ()\fC [virtual]\fP"
Prints a useful message about why the latest nonlinear solve con(di)verged\&. 
.PP
Reimplemented from \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Definition at line 583 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::out\&.
.PP
.nf
584 {
585 
586   libMesh::out << "Nonlinear solver convergence/divergence reason: "
587                << SNESConvergedReasons[this->get_converged_reason()] << std::endl;
588 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "template<typename T> void \fBlibMesh::PetscNonlinearSolver\fP< T >::set_jacobian_zero_out (boolstate)\fC [inline]\fP"
Set if the jacobian should be zeroed out in the callback 
.PP
Definition at line 141 of file petsc_nonlinear_solver\&.h\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_zero_out_jacobian\&.
.PP
.nf
141 { _zero_out_jacobian = state; }
.fi
.SS "template<typename T> void \fBlibMesh::PetscNonlinearSolver\fP< T >::set_residual_zero_out (boolstate)\fC [inline]\fP"
Set if the residual should be zeroed out in the callback 
.PP
Definition at line 136 of file petsc_nonlinear_solver\&.h\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_zero_out_residual\&.
.PP
.nf
136 { _zero_out_residual = state; }
.fi
.SS "template<typename T> SNES \fBlibMesh::PetscNonlinearSolver\fP< T >::snes ()\fC [inline]\fP"
Returns the raw PETSc snes context pointer\&. 
.PP
Definition at line 96 of file petsc_nonlinear_solver\&.h\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_snes, and libMesh::PetscNonlinearSolver< T >::init()\&.
.PP
.nf
96 { this->init(); return _snes; }
.fi
.SS "template<typename T > std::pair< unsigned int, \fBReal\fP > \fBlibMesh::PetscNonlinearSolver\fP< T >::solve (\fBSparseMatrix\fP< T > &jac_in, \fBNumericVector\fP< T > &x_in, \fBNumericVector\fP< T > &r_in, const double, const unsignedint)\fC [virtual]\fP"
Call the Petsc solver\&. It calls the method below, using the same matrix for the system and preconditioner matrices\&. 
.PP
Implements \fBlibMesh::NonlinearSolver< T >\fP\&.
.PP
Reimplemented in \fBlibMesh::PetscDMNonlinearSolver< T >\fP\&.
.PP
Definition at line 443 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::__libmesh_petsc_snes_jacobian(), libMesh::__libmesh_petsc_snes_residual(), libMesh::TriangleWrapper::init(), libMesh::PetscMatrix< T >::mat(), libMesh::Real, libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
448 {
449   START_LOG("solve()", "PetscNonlinearSolver");
450   this->init ();
451 
452   // Make sure the data passed in are really of Petsc types
453   PetscMatrix<T>* jac = libmesh_cast_ptr<PetscMatrix<T>*>(&jac_in);
454   PetscVector<T>* x   = libmesh_cast_ptr<PetscVector<T>*>(&x_in);
455   PetscVector<T>* r   = libmesh_cast_ptr<PetscVector<T>*>(&r_in);
456 
457   PetscErrorCode ierr=0;
458   PetscInt n_iterations =0;
459   // Should actually be a PetscReal, but I don't know which version of PETSc first introduced PetscReal
460   Real final_residual_norm=0\&.;
461 
462   ierr = SNESSetFunction (_snes, r->vec(), __libmesh_petsc_snes_residual, this);
463   LIBMESH_CHKERRABORT(ierr);
464 
465   // Only set the jacobian function if we've been provided with something to call\&.
466   // This allows a user to set their own jacobian function if they want to
467   if (this->jacobian || this->jacobian_object || this->residual_and_jacobian_object)
468     {
469       ierr = SNESSetJacobian (_snes, jac->mat(), jac->mat(), __libmesh_petsc_snes_jacobian, this);
470       LIBMESH_CHKERRABORT(ierr);
471     }
472 #if !PETSC_VERSION_LESS_THAN(3,3,0)
473   // Only set the nullspace if we have a way of computing it and the result is non-empty\&.
474   if (this->nullspace || this->nullspace_object)
475     {
476       MatNullSpace msp;
477       this->build_mat_null_space(this->nullspace_object, this->nullspace, &msp);
478       if (msp)
479         {
480           ierr = MatSetNullSpace(jac->mat(), msp);
481           LIBMESH_CHKERRABORT(ierr);
482 
483           ierr = MatNullSpaceDestroy(&msp);
484           LIBMESH_CHKERRABORT(ierr);
485         }
486     }
487 
488   // Only set the nearnullspace if we have a way of computing it and the result is non-empty\&.
489   if (this->nearnullspace || this->nearnullspace_object)
490     {
491       MatNullSpace msp = PETSC_NULL;
492       this->build_mat_null_space(this->nearnullspace_object, this->nearnullspace, &msp);
493 
494       if(msp) {
495         ierr = MatSetNearNullSpace(jac->mat(), msp);
496         LIBMESH_CHKERRABORT(ierr);
497 
498         ierr = MatNullSpaceDestroy(&msp);
499         LIBMESH_CHKERRABORT(ierr);
500       }
501     }
502 #endif
503   // Have the Krylov subspace method use our good initial guess rather than 0
504   KSP ksp;
505   ierr = SNESGetKSP (_snes, &ksp);
506   LIBMESH_CHKERRABORT(ierr);
507 
508   // Set the tolerances for the iterative solver\&.  Use the user-supplied
509   // tolerance for the relative residual & leave the others at default values
510   ierr = KSPSetTolerances (ksp, this->initial_linear_tolerance, PETSC_DEFAULT,
511                            PETSC_DEFAULT, this->max_linear_iterations);
512   LIBMESH_CHKERRABORT(ierr);
513 
514   // Set the tolerances for the non-linear solver\&.
515   ierr = SNESSetTolerances(_snes, this->absolute_residual_tolerance, this->relative_residual_tolerance,
516                            this->relative_step_tolerance, this->max_nonlinear_iterations, this->max_function_evaluations);
517   LIBMESH_CHKERRABORT(ierr);
518 
519   //Pull in command-line options
520   KSPSetFromOptions(ksp);
521   SNESSetFromOptions(_snes);
522 
523   if (this->user_presolve)
524     this->user_presolve(this->system());
525 
526   //Set the preconditioning matrix
527   if(this->_preconditioner)
528     {
529       this->_preconditioner->set_matrix(jac_in);
530       this->_preconditioner->init();
531     }
532 
533   //    ierr = KSPSetInitialGuessNonzero (ksp, PETSC_TRUE);
534   //           LIBMESH_CHKERRABORT(ierr);
535 
536   // Older versions (at least up to 2\&.1\&.5) of SNESSolve took 3 arguments,
537   // the last one being a pointer to an int to hold the number of iterations required\&.
538 # if PETSC_VERSION_LESS_THAN(2,2,0)
539 
540   ierr = SNESSolve (_snes, x->vec(), &n_iterations);
541   LIBMESH_CHKERRABORT(ierr);
542 
543   // 2\&.2\&.x style
544 #elif PETSC_VERSION_LESS_THAN(2,3,0)
545 
546   ierr = SNESSolve (_snes, x->vec());
547   LIBMESH_CHKERRABORT(ierr);
548 
549   // 2\&.3\&.x & newer style
550 #else
551 
552   ierr = SNESSolve (_snes, PETSC_NULL, x->vec());
553   LIBMESH_CHKERRABORT(ierr);
554 
555   ierr = SNESGetIterationNumber(_snes,&n_iterations);
556   LIBMESH_CHKERRABORT(ierr);
557 
558   ierr = SNESGetLinearSolveIterations(_snes, &_n_linear_iterations);
559   LIBMESH_CHKERRABORT(ierr);
560 
561   ierr = SNESGetFunctionNorm(_snes,&final_residual_norm);
562   LIBMESH_CHKERRABORT(ierr);
563 
564 #endif
565 
566   // Get and store the reason for convergence
567   SNESGetConvergedReason(_snes, &_reason);
568 
569   //Based on Petsc 2\&.3\&.3 documentation all diverged reasons are negative
570   this->converged = (_reason >= 0);
571 
572   this->clear();
573 
574   STOP_LOG("solve()", "PetscNonlinearSolver");
575 
576   // return the # of its\&. and the final residual norm\&.
577   return std::make_pair(n_iterations, final_residual_norm);
578 }
.fi
.SS "template<typename T> const \fBsys_type\fP& \fBlibMesh::NonlinearSolver\fP< T >::system () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 220 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.PP
.nf
220 { return _system; }
.fi
.SS "template<typename T> \fBsys_type\fP& \fBlibMesh::NonlinearSolver\fP< T >::system ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 225 of file nonlinear_solver\&.h\&.
.PP
.nf
225 { return _system; }
.fi
.SS "template<typename T> void \fBlibMesh::PetscNonlinearSolver\fP< T >::use_default_monitor (boolstate)\fC [inline]\fP"
Set to true to use the libMeash's default monitor, set to false to use your own 
.PP
Definition at line 146 of file petsc_nonlinear_solver\&.h\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_default_monitor\&.
.PP
.nf
146 { _default_monitor = state; }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename T> \fBPetscErrorCode\fP __libmesh_petsc_snes_jacobian (SNESsnes, Vecx, Mat *jac, Mat *pc, MatStructure *msflag, void *ctx)\fC [friend]\fP"

.SS "template<typename T> \fBPetscErrorCode\fP __libmesh_petsc_snes_jacobian (SNESsnes, Vecx, Matjac, Matpc, void *ctx)\fC [friend]\fP"

.SS "template<typename T> \fBPetscErrorCode\fP __libmesh_petsc_snes_residual (SNESsnes, Vecx, Vecr, void *ctx)\fC [friend]\fP"

.PP
Definition at line 78 of file petsc_nonlinear_solver\&.C\&.
.PP
.nf
79   {
80     START_LOG("residual()", "PetscNonlinearSolver");
81 
82     PetscErrorCode ierr=0;
83 
84     libmesh_assert(x);
85     libmesh_assert(r);
86     libmesh_assert(ctx);
87 
88     PetscNonlinearSolver<Number>* solver =
89       static_cast<PetscNonlinearSolver<Number>*> (ctx);
90 
91     // Get the current iteration number from the snes object,
92     // store it in the PetscNonlinearSolver object for possible use
93     // by the user's residual function\&.
94     {
95       PetscInt n_iterations = 0;
96       ierr = SNESGetIterationNumber(snes, &n_iterations);
97       CHKERRABORT(solver->comm()\&.get(),ierr);
98       solver->_current_nonlinear_iteration_number = static_cast<unsigned>(n_iterations);
99     }
100 
101     NonlinearImplicitSystem &sys = solver->system();
102 
103     PetscVector<Number>& X_sys = *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.solution\&.get());
104     PetscVector<Number>& R_sys = *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.rhs);
105     PetscVector<Number> X_global(x, sys\&.comm()), R(r, sys\&.comm());
106 
107     // Use the systems update() to get a good local version of the parallel solution
108     X_global\&.swap(X_sys);
109     R\&.swap(R_sys);
110 
111     sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
112 
113     sys\&.update();
114 
115     //Swap back
116     X_global\&.swap(X_sys);
117     R\&.swap(R_sys);
118 
119     if (solver->_zero_out_residual)
120       R\&.zero();
121 
122     //-----------------------------------------------------------------------------
123     // if the user has provided both function pointers and objects only the pointer
124     // will be used, so catch that as an error
125     if (solver->residual && solver->residual_object)
126       {
127         libMesh::err << "ERROR: cannot specifiy both a function and object to compute the Residual!" << std::endl;
128         libmesh_error();
129       }
130 
131     if (solver->matvec && solver->residual_and_jacobian_object)
132       {
133         libMesh::err << "ERROR: cannot specifiy both a function and object to compute the combined Residual & Jacobian!" << std::endl;
134         libmesh_error();
135       }
136     //-----------------------------------------------------------------------------
137 
138     if      (solver->residual != NULL)                     solver->residual                                            (*sys\&.current_local_solution\&.get(), R, sys);
139     else if (solver->residual_object != NULL)              solver->residual_object->residual                           (*sys\&.current_local_solution\&.get(), R, sys);
140     else if (solver->matvec   != NULL)                     solver->matvec                                              (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
141     else if (solver->residual_and_jacobian_object != NULL) solver->residual_and_jacobian_object->residual_and_jacobian (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
142     else libmesh_error();
143 
144     R\&.close();
145     X_global\&.close();
146 
147     STOP_LOG("residual()", "PetscNonlinearSolver");
148 
149     return ierr;
150   }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "template<typename T> unsigned \fBlibMesh::PetscNonlinearSolver\fP< T >::_current_nonlinear_iteration_number\fC [protected]\fP"
Stores the current nonlinear iteration number 
.PP
Definition at line 171 of file petsc_nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), and libMesh::PetscNonlinearSolver< T >::get_current_nonlinear_iteration_number()\&.
.SS "template<typename T> bool \fBlibMesh::PetscNonlinearSolver\fP< T >::_default_monitor\fC [protected]\fP"
true if we want the default monitor to be set, false for no monitor (i\&.e\&. user code can use their own) 
.PP
Definition at line 186 of file petsc_nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::use_default_monitor()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "template<typename T> bool \fBlibMesh::NonlinearSolver\fP< T >::_is_initialized\fC [protected]\fP, \fC [inherited]\fP"
Flag indicating if the data structures have been initialized\&. 
.PP
Definition at line 301 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::NonlinearSolver< Number >::initialized()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "template<typename T> \fBPetscInt\fP \fBlibMesh::PetscNonlinearSolver\fP< T >::_n_linear_iterations\fC [protected]\fP"
Stores the total number of linear iterations from the last solve\&. 
.PP
Definition at line 166 of file petsc_nonlinear_solver\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "template<typename T> \fBPreconditioner\fP<T>* \fBlibMesh::NonlinearSolver\fP< T >::_preconditioner\fC [protected]\fP, \fC [inherited]\fP"
Holds the \fBPreconditioner\fP object to be used for the linear solves\&. 
.PP
Definition at line 306 of file nonlinear_solver\&.h\&.
.SS "template<typename T> SNESConvergedReason \fBlibMesh::PetscNonlinearSolver\fP< T >::_reason\fC [protected]\fP"
Store the reason for SNES convergence/divergence for use even after the _snes has been cleared\&. Note that \fBprint_converged_reason()\fP will always \fItry\fP to get the current reason with SNESGetConvergedReason(), but if the SNES object has already been cleared, it will fall back on this stored value\&. Note that this value is therefore necessarily \fInot\fP cleared by the \fBclear()\fP function\&. 
.PP
Definition at line 161 of file petsc_nonlinear_solver\&.h\&.
.SS "template<typename T> SNES \fBlibMesh::PetscNonlinearSolver\fP< T >::_snes\fC [protected]\fP"
Nonlinear solver context 
.PP
Definition at line 152 of file petsc_nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::snes()\&.
.SS "template<typename T> \fBsys_type\fP& \fBlibMesh::NonlinearSolver\fP< T >::_system\fC [protected]\fP, \fC [inherited]\fP"
A reference to the system we are solving\&. 
.PP
Definition at line 296 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::NonlinearSolver< Number >::system()\&.
.SS "template<typename T> bool \fBlibMesh::PetscNonlinearSolver\fP< T >::_zero_out_jacobian\fC [protected]\fP"
true to zero out jacobian before going into application level call-back, otherwise false 
.PP
Definition at line 181 of file petsc_nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::set_jacobian_zero_out()\&.
.SS "template<typename T> bool \fBlibMesh::PetscNonlinearSolver\fP< T >::_zero_out_residual\fC [protected]\fP"
true to zero out residual before going into application level call-back, otherwise false 
.PP
Definition at line 176 of file petsc_nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), and libMesh::PetscNonlinearSolver< T >::set_residual_zero_out()\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::absolute_residual_tolerance\fC [inherited]\fP"
The \fBNonlinearSolver\fP should exit after the residual is reduced to either less than absolute_residual_tolerance or less than relative_residual_tolerance times the initial residual\&.
.PP
Users should increase any of these tolerances that they want to use for a stopping condition\&. 
.PP
Definition at line 252 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::absolute_step_tolerance\fC [inherited]\fP"
The \fBNonlinearSolver\fP should exit after the full nonlinear step norm is reduced to either less than absolute_step_tolerance or less than relative_step_tolerance times the largest nonlinear solution which has been seen so far\&.
.PP
Users should increase any of these tolerances that they want to use for a stopping condition\&.
.PP
Note that not all NonlinearSolvers support relative_step_tolerance! 
.PP
Definition at line 266 of file nonlinear_solver\&.h\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::bounds)(\fBNumericVector\fP< \fBNumber\fP > &XL, \fBNumericVector\fP< \fBNumber\fP > &XU, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes the lower and upper bounds \fCXL\fP and \fCXU\fP on the solution of the nonlinear system\&. 
.PP
Definition at line 176 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeBounds\fP* \fBlibMesh::NonlinearSolver\fP< T >::bounds_object\fC [inherited]\fP"
Object that computes the bounds vectors $ XL $ and $ XU $\&. 
.PP
Definition at line 182 of file nonlinear_solver\&.h\&.
.SS "template<typename T> bool \fBlibMesh::NonlinearSolver\fP< T >::converged\fC [inherited]\fP"
After a call to solve this will reflect whether or not the nonlinear solve was successful\&. 
.PP
Definition at line 290 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::initial_linear_tolerance\fC [inherited]\fP"
Any required linear solves will at first be done with this tolerance; the \fBNonlinearSolver\fP may tighten the tolerance for later solves\&. 
.PP
Definition at line 279 of file nonlinear_solver\&.h\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::jacobian)(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBSparseMatrix\fP< \fBNumber\fP > &J, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes the Jacobian \fCJ(X)\fP of the nonlinear system at the input iterate \fCX\fP\&. 
.PP
Definition at line 144 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeJacobian\fP* \fBlibMesh::NonlinearSolver\fP< T >::jacobian_object\fC [inherited]\fP"
Object that computes the Jacobian \fCJ(X)\fP of the nonlinear system at the input iterate \fCX\fP\&. 
.PP
Definition at line 152 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::matvec)(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBNumericVector\fP< \fBNumber\fP > *R, \fBSparseMatrix\fP< \fBNumber\fP > *J, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes either the residual $ R(X) $ or the Jacobian $ J(X) $ of the nonlinear system at the input iterate $ X $\&. Note that either \fCR\fP or \fCJ\fP could be \fCXSNULL\fP\&. 
.PP
Definition at line 160 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.SS "template<typename T> unsigned int \fBlibMesh::NonlinearSolver\fP< T >::max_function_evaluations\fC [inherited]\fP"
Maximum number of function evaluations\&. 
.PP
Definition at line 240 of file nonlinear_solver\&.h\&.
.SS "template<typename T> unsigned int \fBlibMesh::NonlinearSolver\fP< T >::max_linear_iterations\fC [inherited]\fP"
Each linear solver step should exit after \fCmax_linear_iterations\fP is exceeded\&. 
.PP
Definition at line 273 of file nonlinear_solver\&.h\&.
.SS "template<typename T> unsigned int \fBlibMesh::NonlinearSolver\fP< T >::max_nonlinear_iterations\fC [inherited]\fP"
Maximum number of non-linear iterations\&. 
.PP
Definition at line 235 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::minimum_linear_tolerance\fC [inherited]\fP"
The tolerance for linear solves is kept above this minimum 
.PP
Definition at line 284 of file nonlinear_solver\&.h\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::nearnullspace)(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &sp, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes a basis for the Jacobian's near nullspace -- the set of 'low energy modes' -- that can be used for AMG coarsening, if the solver supports it (e\&.g\&., ML, PETSc's GAMG)\&. 
.PP
Definition at line 205 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeVectorSubspace\fP* \fBlibMesh::NonlinearSolver\fP< T >::nearnullspace_object\fC [inherited]\fP"
A callable object that computes a basis for the Jacobian's near nullspace -- the set of 'low energy modes' -- that can be used for AMG coarsening, if the solver supports it (e\&.g\&., ML, PETSc's GAMG)\&. 
.PP
Definition at line 212 of file nonlinear_solver\&.h\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::nullspace)(std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &sp, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes a basis for the Jacobian's nullspace -- the kernel or the 'zero energy modes' -- that can be used in solving a degenerate problem iteratively, if the solver supports it (e\&.g\&., PETSc's KSP)\&. 
.PP
Definition at line 190 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeVectorSubspace\fP* \fBlibMesh::NonlinearSolver\fP< T >::nullspace_object\fC [inherited]\fP"
A callable object that computes a basis for the Jacobian's nullspace -- the kernel or the 'zero energy modes' -- that can be used in solving a degenerate problem iteratively, if the solver supports it (e\&.g\&., PETSc's KSP)\&. 
.PP
Definition at line 198 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::relative_residual_tolerance\fC [inherited]\fP"

.PP
Definition at line 253 of file nonlinear_solver\&.h\&.
.SS "template<typename T> \fBReal\fP \fBlibMesh::NonlinearSolver\fP< T >::relative_step_tolerance\fC [inherited]\fP"

.PP
Definition at line 267 of file nonlinear_solver\&.h\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::residual)(const \fBNumericVector\fP< \fBNumber\fP > &X, \fBNumericVector\fP< \fBNumber\fP > &R, \fBsys_type\fP &S)\fC [inherited]\fP"
Function that computes the residual \fCR(X)\fP of the nonlinear system at the input iterate \fCX\fP\&. 
.PP
Definition at line 130 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), and libMesh::Problem_Interface::computeF()\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeResidualandJacobian\fP* \fBlibMesh::NonlinearSolver\fP< T >::residual_and_jacobian_object\fC [inherited]\fP"
Object that computes either the residual $ R(X) $ or the Jacobian $ J(X) $ of the nonlinear system at the input iterate $ X $\&. Note that either \fCR\fP or \fCJ\fP could be \fCXSNULL\fP\&. 
.PP
Definition at line 171 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.SS "template<typename T> \fBNonlinearImplicitSystem::ComputeResidual\fP* \fBlibMesh::NonlinearSolver\fP< T >::residual_object\fC [inherited]\fP"
Object that computes the residual \fCR(X)\fP of the nonlinear system at the input iterate \fCX\fP\&. 
.PP
Definition at line 138 of file nonlinear_solver\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), and libMesh::Problem_Interface::computeF()\&.
.SS "template<typename T> void(*  \fBlibMesh::NonlinearSolver\fP< T >::user_presolve)(\fBsys_type\fP &S)\fC [inherited]\fP"

.PP
Definition at line 215 of file nonlinear_solver\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
