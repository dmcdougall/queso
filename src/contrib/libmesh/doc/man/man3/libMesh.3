.TH "libMesh" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh \- 
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "\fBboostcopy\fP"
.br
.ti -1c
.RI "\fBDenseMatrices\fP"
.br
.ti -1c
.RI "\fBElementTypes\fP"
.br
.ti -1c
.RI "\fBexII\fP"
.br
.ti -1c
.RI "\fBFiniteElements\fP"
.br
.ti -1c
.RI "\fBlibMeshPrivateData\fP"
.br
.ti -1c
.RI "\fBMacroFunctions\fP"
.br
.ti -1c
.RI "\fBMeshTools\fP"
.br
.ti -1c
.RI "\fBNemesis\fP"
.br
.ti -1c
.RI "\fBParallel\fP"
.br
.ti -1c
.RI "\fBPredicates\fP"
.br
.ti -1c
.RI "\fBQuadratureRules\fP"
.br
.ti -1c
.RI "\fBQuality\fP"
.br
.ti -1c
.RI "\fBReferenceElem\fP"
.br
.ti -1c
.RI "\fBSparsityPattern\fP"
.br
.ti -1c
.RI "\fBTensorTools\fP"
.br
.ti -1c
.RI "\fBThreads\fP"
.br
.ti -1c
.RI "\fBTrees\fP"
.br
.ti -1c
.RI "\fBTriangleWrapper\fP"
.br
.ti -1c
.RI "\fBUtility\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBProblem_Interface\fP"
.br
.ti -1c
.RI "class \fBProjectVector\fP"
.br
.ti -1c
.RI "class \fBBuildProjectionList\fP"
.br
.ti -1c
.RI "class \fBProjectSolution\fP"
.br
.ti -1c
.RI "class \fBProjectFEMSolution\fP"
.br
.ti -1c
.RI "class \fBBoundaryProjectSolution\fP"
.br
.ti -1c
.RI "class \fBAbaqusIO\fP"
.br
.ti -1c
.RI "class \fBAdaptiveTimeSolver\fP"
.br
.ti -1c
.RI "class \fBAdjointRefinementEstimator\fP"
.br
.ti -1c
.RI "class \fBAdjointResidualErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBDenseVector\fP"
.br
.ti -1c
.RI "class \fBAnalyticFunction\fP"
.br
.ti -1c
.RI "struct \fBAutoPtrRef\fP"
.br
.ti -1c
.RI "class \fBAutoPtr\fP"
.br
.RI "\fIA simple smart pointer providing strict ownership semantics\&. \fP"
.ti -1c
.RI "class \fBBoundaryInfo\fP"
.br
.ti -1c
.RI "class \fBBoundaryMesh\fP"
.br
.ti -1c
.RI "class \fBCell\fP"
.br
.ti -1c
.RI "class \fBHex\fP"
.br
.ti -1c
.RI "class \fBHex20\fP"
.br
.ti -1c
.RI "class \fBHex27\fP"
.br
.ti -1c
.RI "class \fBHex8\fP"
.br
.ti -1c
.RI "class \fBInfCell\fP"
.br
.ti -1c
.RI "class \fBInfHex\fP"
.br
.ti -1c
.RI "class \fBInfHex16\fP"
.br
.ti -1c
.RI "class \fBInfHex18\fP"
.br
.ti -1c
.RI "class \fBInfHex8\fP"
.br
.ti -1c
.RI "class \fBInfPrism\fP"
.br
.ti -1c
.RI "class \fBInfPrism12\fP"
.br
.ti -1c
.RI "class \fBInfPrism6\fP"
.br
.ti -1c
.RI "class \fBPrism\fP"
.br
.ti -1c
.RI "class \fBPrism15\fP"
.br
.ti -1c
.RI "class \fBPrism18\fP"
.br
.ti -1c
.RI "class \fBPrism6\fP"
.br
.ti -1c
.RI "class \fBPyramid\fP"
.br
.ti -1c
.RI "class \fBPyramid13\fP"
.br
.ti -1c
.RI "class \fBPyramid14\fP"
.br
.ti -1c
.RI "class \fBPyramid5\fP"
.br
.ti -1c
.RI "class \fBTet\fP"
.br
.ti -1c
.RI "class \fBTet10\fP"
.br
.ti -1c
.RI "class \fBTet4\fP"
.br
.ti -1c
.RI "class \fBCentroidPartitioner\fP"
.br
.ti -1c
.RI "class \fBCheckpointIO\fP"
.br
.ti -1c
.RI "struct \fBTypesEqual\fP"
.br
.ti -1c
.RI "struct \fBTypesEqual< T, T >\fP"
.br
.ti -1c
.RI "struct \fBScalarTraits\fP"
.br
.ti -1c
.RI "struct \fBScalarTraits< std::complex< T > >\fP"
.br
.ti -1c
.RI "struct \fBCompareTypes\fP"
.br
.ti -1c
.RI "struct \fBCompareTypes< T, T >\fP"
.br
.ti -1c
.RI "struct \fBCompareTypes< T, std::complex< T > >\fP"
.br
.ti -1c
.RI "struct \fBCompareTypes< std::complex< T >, T >\fP"
.br
.ti -1c
.RI "class \fBCondensedEigenSystem\fP"
.br
.ti -1c
.RI "class \fBConstFEMFunction\fP"
.br
.ti -1c
.RI "class \fBConstFunction\fP"
.br
.ti -1c
.RI "class \fBLinearSolver\fP"
.br
.ti -1c
.RI "class \fBContinuationSystem\fP"
.br
.ti -1c
.RI "class \fBCouplingMatrix\fP"
.br
.ti -1c
.RI "class \fBDenseMatrix\fP"
.br
.ti -1c
.RI "class \fBDenseVectorBase\fP"
.br
.ti -1c
.RI "class \fBDenseMatrixBase\fP"
.br
.ti -1c
.RI "class \fBDenseSubMatrix\fP"
.br
.ti -1c
.RI "class \fBDenseSubVector\fP"
.br
.ti -1c
.RI "class \fBDerivedRBConstruction\fP"
.br
.ti -1c
.RI "class \fBDerivedRBEvaluation\fP"
.br
.ti -1c
.RI "class \fBDGFEMContext\fP"
.br
.ti -1c
.RI "class \fBNumericVector\fP"
.br
.ti -1c
.RI "class \fBDiffContext\fP"
.br
.ti -1c
.RI "class \fBDifferentiablePhysics\fP"
.br
.ti -1c
.RI "class \fBDifferentiableQoI\fP"
.br
.ti -1c
.RI "class \fBLinearSolutionMonitor\fP"
.br
.ti -1c
.RI "class \fBDiffSolver\fP"
.br
.ti -1c
.RI "class \fBDifferentiableSystem\fP"
.br
.ti -1c
.RI "class \fBDirectSolutionTransfer\fP"
.br
.ti -1c
.RI "class \fBDirichletBoundary\fP"
.br
.ti -1c
.RI "class \fBDirichletBoundaries\fP"
.br
.ti -1c
.RI "class \fBDiscontinuityMeasure\fP"
.br
.ti -1c
.RI "class \fBDistributedVector\fP"
.br
.ti -1c
.RI "class \fBDivaIO\fP"
.br
.ti -1c
.RI "class \fBSparseMatrix\fP"
.br
.ti -1c
.RI "class \fBDofConstraints\fP"
.br
.ti -1c
.RI "class \fBDofConstraintValueMap\fP"
.br
.ti -1c
.RI "class \fBAdjointDofConstraintValues\fP"
.br
.ti -1c
.RI "class \fBNodeConstraints\fP"
.br
.ti -1c
.RI "class \fBDofMap\fP"
.br
.ti -1c
.RI "class \fBDofObject\fP"
.br
.ti -1c
.RI "class \fBDTKAdapter\fP"
.br
.ti -1c
.RI "class \fBDTKEvaluator\fP"
.br
.ti -1c
.RI "class \fBDTKSolutionTransfer\fP"
.br
.ti -1c
.RI "class \fBEdge\fP"
.br
.ti -1c
.RI "class \fBEdge2\fP"
.br
.ti -1c
.RI "class \fBEdge3\fP"
.br
.ti -1c
.RI "class \fBEdge4\fP"
.br
.ti -1c
.RI "class \fBInfEdge2\fP"
.br
.ti -1c
.RI "class \fBShellMatrix\fP"
.br
.ti -1c
.RI "class \fBEigenPreconditioner\fP"
.br
.ti -1c
.RI "class \fBEigenSolver\fP"
.br
.ti -1c
.RI "class \fBEigenSparseLinearSolver\fP"
.br
.ti -1c
.RI "class \fBEigenSparseVector\fP"
.br
.ti -1c
.RI "class \fBEigenSparseMatrix\fP"
.br
.ti -1c
.RI "class \fBEigenSystem\fP"
.br
.ti -1c
.RI "class \fBEigenTimeSolver\fP"
.br
.ti -1c
.RI "class \fBElem\fP"
.br
.ti -1c
.RI "class \fBElemAssembly\fP"
.br
.ti -1c
.RI "class \fBEnsightIO\fP"
.br
.ti -1c
.RI "class \fBEquationSystems\fP"
.br
.ti -1c
.RI "class \fBErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBErrorVector\fP"
.br
.ti -1c
.RI "class \fBEuler2Solver\fP"
.br
.ti -1c
.RI "class \fBEulerSolver\fP"
.br
.ti -1c
.RI "class \fBFEGenericBase\fP"
.br
.ti -1c
.RI "class \fBTensorValue\fP"
.br
.ti -1c
.RI "class \fBVectorValue\fP"
.br
.ti -1c
.RI "class \fBExactErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBFunctionBase\fP"
.br
.ti -1c
.RI "class \fBExactSolution\fP"
.br
.ti -1c
.RI "class \fBExodusII_IO\fP"
.br
.ti -1c
.RI "class \fBExodusII_IO_Helper\fP"
.br
.ti -1c
.RI "class \fBExplicitSystem\fP"
.br
.ti -1c
.RI "class \fBFace\fP"
.br
.ti -1c
.RI "class \fBInfQuad\fP"
.br
.ti -1c
.RI "class \fBInfQuad4\fP"
.br
.ti -1c
.RI "class \fBInfQuad6\fP"
.br
.ti -1c
.RI "class \fBQuad\fP"
.br
.ti -1c
.RI "class \fBQuad4\fP"
.br
.ti -1c
.RI "class \fBQuad8\fP"
.br
.ti -1c
.RI "class \fBQuad9\fP"
.br
.ti -1c
.RI "class \fBTri\fP"
.br
.ti -1c
.RI "class \fBTri3\fP"
.br
.ti -1c
.RI "class \fBTri3Subdivision\fP"
.br
.ti -1c
.RI "class \fBTri6\fP"
.br
.ti -1c
.RI "class \fBFactory\fP"
.br
.ti -1c
.RI "class \fBFactoryImp\fP"
.br
.ti -1c
.RI "class \fBInfFE\fP"
.br
.ti -1c
.RI "struct \fBFEOutputType\fP"
.br
.ti -1c
.RI "struct \fBFEOutputType< LAGRANGE_VEC >\fP"
.br
.ti -1c
.RI "struct \fBFEOutputType< NEDELEC_ONE >\fP"
.br
.ti -1c
.RI "class \fBFE\fP"
.br
.ti -1c
.RI "class \fBFEClough\fP"
.br
.ti -1c
.RI "class \fBFEHermite\fP"
.br
.ti -1c
.RI "class \fBFESubdivision\fP"
.br
.ti -1c
.RI "class \fBFEHierarchic\fP"
.br
.ti -1c
.RI "class \fBFEL2Hierarchic\fP"
.br
.ti -1c
.RI "class \fBFELagrange\fP"
.br
.ti -1c
.RI "class \fBFEL2Lagrange\fP"
.br
.ti -1c
.RI "class \fBFEMonomial\fP"
.br
.ti -1c
.RI "class \fBFEScalar\fP"
.br
.ti -1c
.RI "class \fBFEXYZ\fP"
.br
.ti -1c
.RI "class \fBFELagrangeVec\fP"
.br
.ti -1c
.RI "class \fBFENedelecOne\fP"
.br
.ti -1c
.RI "class \fBFEAbstract\fP"
.br
.ti -1c
.RI "class \fBFETransformationBase\fP"
.br
.ti -1c
.RI "class \fBFEComputeData\fP"
.br
.ti -1c
.RI "class \fBFEInterface\fP"
.br
.ti -1c
.RI "class \fBFEMap\fP"
.br
.ti -1c
.RI "class \fBH1FETransformation\fP"
.br
.ti -1c
.RI "class \fBHCurlFETransformation\fP"
.br
.ti -1c
.RI "class \fBFEType\fP"
.br
.ti -1c
.RI "class \fBFEXYZMap\fP"
.br
.ti -1c
.RI "class \fBFEMContext\fP"
.br
.ti -1c
.RI "class \fBFEMFunctionBase\fP"
.br
.ti -1c
.RI "class \fBFEMPhysics\fP"
.br
.ti -1c
.RI "class \fBFEMSystem\fP"
.br
.ti -1c
.RI "class \fBLaplacianErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBFrequencySystem\fP"
.br
.ti -1c
.RI "class \fBFroIO\fP"
.br
.ti -1c
.RI "class \fBGmshIO\fP"
.br
.ti -1c
.RI "class \fBGMVIO\fP"
.br
.ti -1c
.RI "class \fBGnuPlotIO\fP"
.br
.ti -1c
.RI "class \fBHilbertSFCPartitioner\fP"
.br
.ti -1c
.RI "class \fBHPCoarsenTest\fP"
.br
.ti -1c
.RI "class \fBHPSelector\fP"
.br
.ti -1c
.RI "class \fBHPSingularity\fP"
.br
.ti -1c
.RI "class \fBTestClass\fP"
.br
.ti -1c
.RI "class \fBImplicitSystem\fP"
.br
.ti -1c
.RI "class \fBInfElemBuilder\fP"
.br
.ti -1c
.RI "class \fBJumpErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBKellyErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBLaspackLinearSolver\fP"
.br
.ti -1c
.RI "class \fBLaspackVector\fP"
.br
.ti -1c
.RI "class \fBLaspackMatrix\fP"
.br
.ti -1c
.RI "class \fBLegacyXdrIO\fP"
.br
.ti -1c
.RI "class \fBLibMeshInit\fP"
.br
.ti -1c
.RI "class \fBLogicError\fP"
.br
.ti -1c
.RI "class \fBNotImplemented\fP"
.br
.ti -1c
.RI "class \fBFileError\fP"
.br
.ti -1c
.RI "class \fBConvergenceFailure\fP"
.br
.ti -1c
.RI "class \fBDynamicCastFailure\fP"
.br
.ti -1c
.RI "class \fBFloatingPointException\fP"
.br
.ti -1c
.RI "class \fBSingleton\fP"
.br
.ti -1c
.RI "class \fBLinear\fP"
.br
.ti -1c
.RI "class \fBLinearImplicitSystem\fP"
.br
.ti -1c
.RI "class \fBLinearPartitioner\fP"
.br
.ti -1c
.RI "class \fBPreconditioner\fP"
.br
.ti -1c
.RI "class \fBLocationMap\fP"
.br
.ti -1c
.RI "class \fBmapvector\fP"
.br
.ti -1c
.RI "class \fBMatlabIO\fP"
.br
.ti -1c
.RI "class \fBMEDITIO\fP"
.br
.ti -1c
.RI "class \fBMemorySolutionHistory\fP"
.br
.ti -1c
.RI "class \fBMesh\fP"
.br
.ti -1c
.RI "class \fBMeshBase\fP"
.br
.ti -1c
.RI "class \fBMeshCommunication\fP"
.br
.ti -1c
.RI "class \fBMeshData\fP"
.br
.ti -1c
.RI "class \fBMeshDataUnvHeader\fP"
.br
.ti -1c
.RI "class \fBMeshFunction\fP"
.br
.ti -1c
.RI "class \fBMeshInput\fP"
.br
.ti -1c
.RI "struct \fBmesh_inserter_iterator\fP"
.br
.ti -1c
.RI "class \fBMeshOutput\fP"
.br
.ti -1c
.RI "class \fBMeshRefinement\fP"
.br
.ti -1c
.RI "class \fBMeshSerializer\fP"
.br
.ti -1c
.RI "class \fBMeshSmoother\fP"
.br
.ti -1c
.RI "class \fBLaplaceMeshSmoother\fP"
.br
.ti -1c
.RI "class \fBVariationalMeshSmoother\fP"
.br
.ti -1c
.RI "class \fBTetGenMeshInterface\fP"
.br
.ti -1c
.RI "class \fBTetGenWrapper\fP"
.br
.ti -1c
.RI "class \fBTriangleInterface\fP"
.br
.ti -1c
.RI "class \fBMeshfreeInterpolation\fP"
.br
.ti -1c
.RI "class \fBInverseDistanceInterpolation\fP"
.br
.ti -1c
.RI "class \fBMeshfreeSolutionTransfer\fP"
.br
.ti -1c
.RI "class \fBMeshFunctionSolutionTransfer\fP"
.br
.ti -1c
.RI "class \fBMETIS_CSR_Graph\fP"
.br
.ti -1c
.RI "class \fBMetisPartitioner\fP"
.br
.ti -1c
.RI "class \fBMortonSFCPartitioner\fP"
.br
.ti -1c
.RI "class \fBNemesis_IO\fP"
.br
.ti -1c
.RI "class \fBNemesis_IO_Helper\fP"
.br
.ti -1c
.RI "class \fBNewmarkSystem\fP"
.br
.ti -1c
.RI "class \fBNewtonSolver\fP"
.br
.ti -1c
.RI "class \fBNoSolutionHistory\fP"
.br
.ti -1c
.RI "class \fBNode\fP"
.br
.ti -1c
.RI "class \fBNodeElem\fP"
.br
.ti -1c
.RI "class \fBNonlinearSolver\fP"
.br
.ti -1c
.RI "class \fBNonlinearImplicitSystem\fP"
.br
.ti -1c
.RI "struct \fBnull_output_iterator\fP"
.br
.ti -1c
.RI "class \fBOFFIO\fP"
.br
.ti -1c
.RI "class \fBBasicOStreamProxy\fP"
.br
.ti -1c
.RI "struct \fBSyncNodalPositions\fP"
.br
.ti -1c
.RI "class \fBParallelMesh\fP"
.br
.ti -1c
.RI "class \fBParallelObject\fP"
.br
.ti -1c
.RI "class \fBParameterVector\fP"
.br
.ti -1c
.RI "class \fBParameters\fP"
.br
.ti -1c
.RI "class \fBParmetisPartitioner\fP"
.br
.ti -1c
.RI "class \fBParsedFunction\fP"
.br
.ti -1c
.RI "class \fBPartitioner\fP"
.br
.ti -1c
.RI "class \fBPatch\fP"
.br
.ti -1c
.RI "class \fBPatchRecoveryErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBPerfData\fP"
.br
.ti -1c
.RI "class \fBPerfLog\fP"
.br
.ti -1c
.RI "class \fBPerfMon\fP"
.br
.ti -1c
.RI "class \fBPeriodicBoundaries\fP"
.br
.ti -1c
.RI "class \fBPeriodicBoundary\fP"
.br
.ti -1c
.RI "class \fBPeriodicBoundaryBase\fP"
.br
.ti -1c
.RI "class \fBPetscDiffSolver\fP"
.br
.ti -1c
.RI "class \fBPetscDMNonlinearSolver\fP"
.br
.ti -1c
.RI "class \fBPetscMatrix\fP"
.br
.ti -1c
.RI "class \fBPetscLinearSolver\fP"
.br
.ti -1c
.RI "class \fBPetscNonlinearSolver\fP"
.br
.ti -1c
.RI "class \fBPetscPreconditioner\fP"
.br
.ti -1c
.RI "class \fBPetscVector\fP"
.br
.ti -1c
.RI "class \fBPlane\fP"
.br
.ti -1c
.RI "class \fBPltLoader\fP"
.br
.ti -1c
.RI "class \fBPoint\fP"
.br
.ti -1c
.RI "class \fBPointLocatorBase\fP"
.br
.ti -1c
.RI "class \fBPointLocatorList\fP"
.br
.ti -1c
.RI "class \fBPointLocatorTree\fP"
.br
.ti -1c
.RI "class \fBPoolAllocator\fP"
.br
.ti -1c
.RI "class \fBFastPoolAllocator\fP"
.br
.ti -1c
.RI "class \fBPostscriptIO\fP"
.br
.ti -1c
.RI "class \fBQoISet\fP"
.br
.ti -1c
.RI "class \fBQBase\fP"
.br
.ti -1c
.RI "class \fBQClough\fP"
.br
.ti -1c
.RI "class \fBQConical\fP"
.br
.ti -1c
.RI "class \fBQGauss\fP"
.br
.ti -1c
.RI "class \fBQGrundmann_Moller\fP"
.br
.ti -1c
.RI "class \fBQGrid\fP"
.br
.ti -1c
.RI "class \fBQJacobi\fP"
.br
.ti -1c
.RI "class \fBQMonomial\fP"
.br
.ti -1c
.RI "class \fBQSimpson\fP"
.br
.ti -1c
.RI "class \fBQTrap\fP"
.br
.ti -1c
.RI "class \fBWendlandRBF\fP"
.br
.ti -1c
.RI "class \fBRadialBasisInterpolation\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< Number >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< Gradient >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< Tensor >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< TypeNTensor< 3, Number > >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< Real >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< RealGradient >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< RealTensor >\fP"
.br
.ti -1c
.RI "struct \fBRawFieldType< TypeNTensor< 3, Real > >\fP"
.br
.ti -1c
.RI "class \fBRawAccessor\fP"
.br
.ti -1c
.RI "class \fBRawAccessor< TypeNTensor< N, ScalarType > >\fP"
.br
.ti -1c
.RI "class \fBRBAssemblyExpansion\fP"
.br
.ti -1c
.RI "class \fBRBConstruction\fP"
.br
.ti -1c
.RI "class \fBRBConstructionBase\fP"
.br
.ti -1c
.RI "class \fBRBEIMAssembly\fP"
.br
.ti -1c
.RI "class \fBRBEIMConstruction\fP"
.br
.ti -1c
.RI "class \fBRBEIMEvaluation\fP"
.br
.ti -1c
.RI "class \fBRBEIMTheta\fP"
.br
.ti -1c
.RI "class \fBRBEvaluation\fP"
.br
.ti -1c
.RI "class \fBRBParameters\fP"
.br
.ti -1c
.RI "class \fBRBParametrized\fP"
.br
.ti -1c
.RI "class \fBRBParametrizedFunction\fP"
.br
.ti -1c
.RI "class \fBRBSCMConstruction\fP"
.br
.ti -1c
.RI "class \fBRBSCMEvaluation\fP"
.br
.ti -1c
.RI "class \fBRBTemporalDiscretization\fP"
.br
.ti -1c
.RI "class \fBRBTheta\fP"
.br
.ti -1c
.RI "class \fBRBThetaExpansion\fP"
.br
.ti -1c
.RI "class \fBReferenceCountedObject\fP"
.br
.ti -1c
.RI "class \fBReferenceCounter\fP"
.br
.ti -1c
.RI "class \fBRefinementSelector\fP"
.br
.ti -1c
.RI "class \fBRemoteElem\fP"
.br
.ti -1c
.RI "class \fBSensitivityData\fP"
.br
.ti -1c
.RI "class \fBSerialMesh\fP"
.br
.ti -1c
.RI "class \fBSFCPartitioner\fP"
.br
.ti -1c
.RI "class \fBSide\fP"
.br
.ti -1c
.RI "class \fBSideEdge\fP"
.br
.ti -1c
.RI "class \fBSlepcEigenSolver\fP"
.br
.ti -1c
.RI "class \fBSolutionHistory\fP"
.br
.ti -1c
.RI "class \fBSolutionTransfer\fP"
.br
.ti -1c
.RI "class \fBSolver\fP"
.br
.ti -1c
.RI "class \fBSparseShellMatrix\fP"
.br
.ti -1c
.RI "class \fBSphere\fP"
.br
.ti -1c
.RI "class \fBStatisticsVector\fP"
.br
.ti -1c
.RI "class \fBSteadySolver\fP"
.br
.ti -1c
.RI "class \fBStoredRange\fP"
.br
.ti -1c
.RI "class \fBSumShellMatrix\fP"
.br
.ti -1c
.RI "class \fBSurface\fP"
.br
.ti -1c
.RI "class \fBSystem\fP"
.br
.ti -1c
.RI "class \fBSystemNorm\fP"
.br
.ti -1c
.RI "class \fBSystemSubset\fP"
.br
.ti -1c
.RI "class \fBSystemSubsetBySubdomain\fP"
.br
.ti -1c
.RI "class \fBTecplotIO\fP"
.br
.ti -1c
.RI "class \fBTensorShellMatrix\fP"
.br
.ti -1c
.RI "class \fBTypeVector\fP"
.br
.ti -1c
.RI "class \fBTypeTensor\fP"
.br
.ti -1c
.RI "class \fBTypeNTensor\fP"
.br
.ti -1c
.RI "class \fBTetGenIO\fP"
.br
.ti -1c
.RI "class \fBTimeSolver\fP"
.br
.ti -1c
.RI "class \fBTransientRBAssemblyExpansion\fP"
.br
.ti -1c
.RI "class \fBTransientRBConstruction\fP"
.br
.ti -1c
.RI "class \fBTransientRBEvaluation\fP"
.br
.ti -1c
.RI "class \fBTransientRBThetaExpansion\fP"
.br
.ti -1c
.RI "class \fBTransientSystem\fP"
.br
.ti -1c
.RI "class \fBTree\fP"
.br
.ti -1c
.RI "class \fBTreeBase\fP"
.br
.ti -1c
.RI "class \fBTreeNode\fP"
.br
.ti -1c
.RI "class \fBAztecLinearSolver\fP"
.br
.ti -1c
.RI "class \fBEpetraMatrix\fP"
.br
.ti -1c
.RI "class \fBEpetraVector\fP"
.br
.ti -1c
.RI "class \fBNoxNonlinearSolver\fP"
.br
.ti -1c
.RI "class \fBTrilinosPreconditioner\fP"
.br
.ti -1c
.RI "class \fBTwostepTimeSolver\fP"
.br
.ti -1c
.RI "class \fBTypeTensorColumn\fP"
.br
.ti -1c
.RI "class \fBConstTypeTensorColumn\fP"
.br
.ti -1c
.RI "class \fBUCDIO\fP"
.br
.ti -1c
.RI "class \fBUniformRefinementEstimator\fP"
.br
.ti -1c
.RI "class \fBUnsteadySolver\fP"
.br
.ti -1c
.RI "class \fBUnstructuredMesh\fP"
.br
.ti -1c
.RI "class \fBUNVIO\fP"
.br
.ti -1c
.RI "class \fBVariable\fP"
.br
.ti -1c
.RI "class \fBVariableGroup\fP"
.br
.ti -1c
.RI "class \fBvectormap\fP"
.br
.ti -1c
.RI "class \fBVTKIO\fP"
.br
.ti -1c
.RI "class \fBWeightedPatchRecoveryErrorEstimator\fP"
.br
.ti -1c
.RI "class \fBWrappedFunction\fP"
.br
.ti -1c
.RI "class \fBXdr\fP"
.br
.ti -1c
.RI "class \fBXdrHEAD\fP"
.br
.ti -1c
.RI "class \fBXdrIO\fP"
.br
.ti -1c
.RI "class \fBXdrMESH\fP"
.br
.ti -1c
.RI "class \fBXdrMGF\fP"
.br
.ti -1c
.RI "class \fBXdrMHEAD\fP"
.br
.ti -1c
.RI "class \fBXdrSHEAD\fP"
.br
.ti -1c
.RI "class \fBXdrSOLN\fP"
.br
.ti -1c
.RI "class \fBZeroFunction\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBPetscErrorCode\fP"
.br
.ti -1c
.RI "typedef int \fBPetscInt\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBPoint\fP >
.br
::const_iterator \fBconst_list_iterator\fP"
.br
.ti -1c
.RI "typedef \fBDerivedRBConstruction\fP
.br
< \fBRBConstruction\fP > \fBSteadyDerivedRBConstruction\fP"
.br
.ti -1c
.RI "typedef \fBDerivedRBEvaluation\fP
.br
< \fBRBEvaluation\fP > \fBSteadyDerivedRBEvaluation\fP"
.br
.ti -1c
.RI "typedef std::map< \fBdof_id_type\fP, 
.br
\fBReal\fP, std::less< \fBdof_id_type\fP >
.br
, \fBThreads::scalable_allocator\fP
.br
< std::pair< const \fBdof_id_type\fP, 
.br
\fBReal\fP > > > \fBDofConstraintRow\fP"
.br
.ti -1c
.RI "typedef std::map< const \fBNode\fP 
.br
*, \fBReal\fP, std::less< const \fBNode\fP * >
.br
, \fBThreads::scalable_allocator\fP
.br
< std::pair< const \fBNode\fP *const, 
.br
\fBReal\fP > > > \fBNodeConstraintRow\fP"
.br
.ti -1c
.RI "typedef int32_t \fBeigen_idx_type\fP"
.br
.ti -1c
.RI "typedef Eigen::SparseMatrix
.br
< \fBNumber\fP, Eigen::RowMajor, 
.br
\fBeigen_idx_type\fP > \fBEigenSM\fP"
.br
.ti -1c
.RI "typedef Eigen::Matrix< \fBNumber\fP, 
.br
Eigen::Dynamic, 1 > \fBEigenSV\fP"
.br
.ti -1c
.RI "typedef \fBStoredRange\fP
.br
< \fBMeshBase::element_iterator\fP, 
.br
\fBElem\fP * > \fBElemRange\fP"
.br
.ti -1c
.RI "typedef \fBStoredRange\fP
.br
< \fBMeshBase::const_element_iterator\fP, 
.br
const \fBElem\fP * > \fBConstElemRange\fP"
.br
.ti -1c
.RI "typedef \fBFEGenericBase\fP< \fBReal\fP > \fBFEBase\fP"
.br
.ti -1c
.RI "typedef \fBTensorValue\fP< \fBNumber\fP > \fBNumberTensorValue\fP"
.br
.ti -1c
.RI "typedef \fBNumberTensorValue\fP \fBTensor\fP"
.br
.ti -1c
.RI "typedef \fBVectorValue\fP< \fBNumber\fP > \fBNumberVectorValue\fP"
.br
.ti -1c
.RI "typedef \fBNumberVectorValue\fP \fBGradient\fP"
.br
.ti -1c
.RI "typedef \fBFEGenericBase\fP
.br
< \fBRealGradient\fP > \fBFEVectorBase\fP"
.br
.ti -1c
.RI "typedef \fBVectorValue\fP< \fBReal\fP > \fBRealVectorValue\fP"
.br
.ti -1c
.RI "typedef \fBTensorValue\fP< \fBReal\fP > \fBRealTensorValue\fP"
.br
.ti -1c
.RI "typedef \fBRealVectorValue\fP \fBRealGradient\fP"
.br
.ti -1c
.RI "typedef \fBRealTensorValue\fP \fBRealTensor\fP"
.br
.ti -1c
.RI "typedef \fBTestClass\fP \fBsubdomain_id_type\fP"
.br
.ti -1c
.RI "typedef int8_t \fBboundary_id_type\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBdof_id_type\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBunique_id_type\fP"
.br
.ti -1c
.RI "typedef \fBdof_id_type\fP \fBnumeric_index_type\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBprocessor_id_type\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBlargest_id_type\fP"
.br
.ti -1c
.RI "typedef std::complex< \fBReal\fP > \fBComplex\fP"
.br
.ti -1c
.RI "typedef std::complex< \fBReal\fP > \fBCOMPLEX\fP"
.br
.ti -1c
.RI "typedef \fBReal\fP \fBNumber\fP"
.br
.ti -1c
.RI "typedef \fBParallelMesh\fP \fBDefaultMesh\fP"
.br
.ti -1c
.RI "typedef double * \fBLPDOUBLE\fP"
.br
.ti -1c
.RI "typedef \fBLPDOUBLE\fP * \fBLPLPDOUBLE\fP"
.br
.ti -1c
.RI "typedef \fBLPLPDOUBLE\fP * \fBLPLPLPDOUBLE\fP"
.br
.ti -1c
.RI "typedef void * \fBLPVOID\fP"
.br
.ti -1c
.RI "typedef \fBLPVOID\fP * \fBLPLPVOID\fP"
.br
.ti -1c
.RI "typedef int * \fBLPINT\fP"
.br
.ti -1c
.RI "typedef \fBLPINT\fP * \fBLPLPINT\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBuint\fP"
.br
.ti -1c
.RI "typedef \fBReal\fP \fBREAL\fP"
.br
.ti -1c
.RI "typedef \fBStoredRange\fP
.br
< \fBMeshBase::node_iterator\fP, 
.br
\fBNode\fP * > \fBNodeRange\fP"
.br
.ti -1c
.RI "typedef \fBStoredRange\fP
.br
< \fBMeshBase::const_node_iterator\fP, 
.br
const \fBNode\fP * > \fBConstNodeRange\fP"
.br
.ti -1c
.RI "typedef \fBBasicOStreamProxy\fP \fBOStreamProxy\fP"
.br
.ti -1c
.RI "typedef \fBLinearImplicitSystem\fP \fBSteadyLinearSystem\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP
.br
< \fBLinearImplicitSystem\fP > \fBTransientImplicitSystem\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP
.br
< \fBLinearImplicitSystem\fP > \fBTransientLinearImplicitSystem\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP
.br
< \fBNonlinearImplicitSystem\fP > \fBTransientNonlinearImplicitSystem\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP
.br
< \fBExplicitSystem\fP > \fBTransientExplicitSystem\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP< \fBSystem\fP > \fBTransientBaseSystem\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBLinearConvergenceReason\fP { \fBCONVERGED_RTOL_NORMAL\fP = 1, \fBCONVERGED_ATOL_NORMAL\fP = 9, \fBCONVERGED_RTOL\fP = 2, \fBCONVERGED_ATOL\fP = 3, \fBCONVERGED_ITS\fP = 4, \fBCONVERGED_CG_NEG_CURVE\fP = 5, \fBCONVERGED_CG_CONSTRAINED\fP = 6, \fBCONVERGED_STEP_LENGTH\fP = 7, \fBCONVERGED_HAPPY_BREAKDOWN\fP = 8, \fBDIVERGED_NULL\fP = -2, \fBDIVERGED_ITS\fP = -3, \fBDIVERGED_DTOL\fP = -4, \fBDIVERGED_BREAKDOWN\fP = -5, \fBDIVERGED_BREAKDOWN_BICG\fP = -6, \fBDIVERGED_NONSYMMETRIC\fP = -7, \fBDIVERGED_INDEFINITE_PC\fP = -8, \fBDIVERGED_NAN\fP = -9, \fBDIVERGED_INDEFINITE_MAT\fP = -10, \fBCONVERGED_ITERATING\fP = 0, \fBUNKNOWN_FLAG\fP = -128 }"
.br
.ti -1c
.RI "enum \fBEigenSolverType\fP { \fBPOWER\fP =0, \fBLAPACK\fP, \fBSUBSPACE\fP, \fBARNOLDI\fP, \fBLANCZOS\fP, \fBKRYLOVSCHUR\fP, \fBINVALID_EIGENSOLVER\fP }"
.br
.ti -1c
.RI "enum \fBEigenProblemType\fP { \fBNHEP\fP =0, \fBHEP\fP, \fBGNHEP\fP, \fBGHEP\fP, \fBINVALID_EIGENPROBLEMTYPE\fP }"
.br
.ti -1c
.RI "enum \fBPositionOfSpectrum\fP { \fBLARGEST_MAGNITUDE\fP =0, \fBSMALLEST_MAGNITUDE\fP, \fBLARGEST_REAL\fP, \fBSMALLEST_REAL\fP, \fBLARGEST_IMAGINARY\fP, \fBSMALLEST_IMAGINARY\fP, \fBINVALID_Postion_of_Spectrum\fP }"
.br
.ti -1c
.RI "enum \fBElemQuality\fP { \fBASPECT_RATIO\fP =0, \fBSKEW\fP, \fBSHEAR\fP, \fBSHAPE\fP, \fBMAX_ANGLE\fP, \fBMIN_ANGLE\fP, \fBCONDITION\fP, \fBDISTORTION\fP, \fBTAPER\fP, \fBWARP\fP, \fBSTRETCH\fP, \fBDIAGONAL\fP, \fBASPECT_RATIO_BETA\fP, \fBASPECT_RATIO_GAMMA\fP, \fBSIZE\fP, \fBJACOBIAN\fP }"
.br
.ti -1c
.RI "enum \fBElemType\fP { \fBEDGE2\fP =0, \fBEDGE3\fP, \fBEDGE4\fP, \fBTRI3\fP, \fBTRI6\fP, \fBQUAD4\fP, \fBQUAD8\fP, \fBQUAD9\fP, \fBTET4\fP, \fBTET10\fP, \fBHEX8\fP, \fBHEX20\fP, \fBHEX27\fP, \fBPRISM6\fP, \fBPRISM15\fP, \fBPRISM18\fP, \fBPYRAMID5\fP, \fBPYRAMID13\fP, \fBPYRAMID14\fP, \fBINFEDGE2\fP, \fBINFQUAD4\fP, \fBINFQUAD6\fP, \fBINFHEX8\fP, \fBINFHEX16\fP, \fBINFHEX18\fP, \fBINFPRISM6\fP, \fBINFPRISM12\fP, \fBNODEELEM\fP, \fBREMOTEELEM\fP, \fBTRI3SUBDIVISION\fP, \fBINVALID_ELEM\fP }"
.br
.ti -1c
.RI "enum \fBFEFamily\fP { \fBLAGRANGE\fP = 0, \fBHIERARCHIC\fP = 1, \fBMONOMIAL\fP = 2, \fBL2_HIERARCHIC\fP = 6, \fBL2_LAGRANGE\fP = 7, \fBBERNSTEIN\fP = 3, \fBSZABAB\fP = 4, \fBXYZ\fP = 5, \fBINFINITE_MAP\fP = 11, \fBJACOBI_20_00\fP = 12, \fBJACOBI_30_00\fP = 13, \fBLEGENDRE\fP = 14, \fBCLOUGH\fP = 21, \fBHERMITE\fP = 22, \fBSUBDIVISION\fP = 23, \fBSCALAR\fP = 31, \fBLAGRANGE_VEC\fP = 41, \fBNEDELEC_ONE\fP = 42, \fBINVALID_FE\fP = 99 }"
.br
.ti -1c
.RI "enum \fBFEContinuity\fP { \fBDISCONTINUOUS\fP, \fBC_ZERO\fP, \fBC_ONE\fP, \fBH_CURL\fP }"
.br
.ti -1c
.RI "enum \fBFEFieldType\fP { \fBTYPE_SCALAR\fP = 0, \fBTYPE_VECTOR\fP }"
.br
.ti -1c
.RI "enum \fBInfMapType\fP { \fBCARTESIAN\fP =0, \fBSPHERICAL\fP, \fBELLIPSOIDAL\fP, \fBINVALID_INF_MAP\fP }"
.br
.ti -1c
.RI "enum \fBIOPackage\fP { \fBTECPLOT\fP, \fBGMV\fP, \fBGMSH\fP, \fBVTK\fP, \fBDIVA\fP, \fBTETGEN\fP, \fBUCD\fP, \fBLIBMESH\fP, \fBINVALID_IO_PACKAGE\fP }"
.br
.ti -1c
.RI "enum \fBFEMNormType\fP { \fBL2\fP = 0, \fBH1\fP = 1, \fBH2\fP = 2, \fBHCURL\fP = 3, \fBHDIV\fP = 4, \fBL1\fP = 5, \fBL_INF\fP = 6, \fBH1_SEMINORM\fP = 10, \fBH2_SEMINORM\fP = 11, \fBHCURL_SEMINORM\fP = 12, \fBHDIV_SEMINORM\fP = 13, \fBW1_INF_SEMINORM\fP = 15, \fBW2_INF_SEMINORM\fP = 16, \fBDISCRETE_L1\fP = 20, \fBDISCRETE_L2\fP = 21, \fBDISCRETE_L_INF\fP = 22, \fBH1_X_SEMINORM\fP = 31, \fBH1_Y_SEMINORM\fP = 32, \fBH1_Z_SEMINORM\fP = 33, \fBINVALID_NORM\fP = 42 }"
.br
.ti -1c
.RI "enum \fBOrder\fP { \fBCONSTANT\fP = 0, \fBFIRST\fP = 1, \fBSECOND\fP = 2, \fBTHIRD\fP = 3, \fBFOURTH\fP = 4, \fBFIFTH\fP = 5, \fBSIXTH\fP = 6, \fBSEVENTH\fP = 7, \fBEIGHTH\fP = 8, \fBNINTH\fP = 9, \fBTENTH\fP = 10, \fBELEVENTH\fP = 11, \fBTWELFTH\fP = 12, \fBTHIRTEENTH\fP = 13, \fBFOURTEENTH\fP = 14, \fBFIFTEENTH\fP = 15, \fBSIXTEENTH\fP = 16, \fBSEVENTEENTH\fP = 17, \fBEIGHTTEENTH\fP = 18, \fBNINTEENTH\fP = 19, \fBTWENTIETH\fP = 20, \fBTWENTYFIRST\fP = 21, \fBTWENTYSECOND\fP = 22, \fBTWENTYTHIRD\fP = 23, \fBTWENTYFOURTH\fP = 24, \fBTWENTYFIFTH\fP = 25, \fBTWENTYSIXTH\fP = 26, \fBTWENTYSEVENTH\fP = 27, \fBTWENTYEIGHTH\fP = 28, \fBTWENTYNINTH\fP = 29, \fBTHIRTIETH\fP = 30, \fBTHIRTYFIRST\fP = 31, \fBTHIRTYSECOND\fP = 32, \fBTHIRTYTHIRD\fP = 33, \fBTHIRTYFOURTH\fP = 34, \fBTHIRTYFIFTH\fP = 35, \fBTHIRTYSIXTH\fP = 36, \fBTHIRTYSEVENTH\fP = 37, \fBTHIRTYEIGHTH\fP = 38, \fBTHIRTYNINTH\fP = 39, \fBFORTIETH\fP = 40, \fBFORTYFIRST\fP = 41, \fBFORTYSECOND\fP = 42, \fBFORTYTHIRD\fP = 43, \fBINVALID_ORDER\fP }"
.br
.ti -1c
.RI "enum \fBParallelType\fP { \fBAUTOMATIC\fP =0, \fBSERIAL\fP, \fBPARALLEL\fP, \fBGHOSTED\fP, \fBINVALID_PARALLELIZATION\fP }"
.br
.ti -1c
.RI "enum \fBPointLocatorType\fP { \fBTREE\fP = 0, \fBLIST\fP, \fBINVALID_LOCATOR\fP }"
.br
.ti -1c
.RI "enum \fBPreconditionerType\fP { \fBIDENTITY_PRECOND\fP =0, \fBJACOBI_PRECOND\fP, \fBBLOCK_JACOBI_PRECOND\fP, \fBSOR_PRECOND\fP, \fBSSOR_PRECOND\fP, \fBEISENSTAT_PRECOND\fP, \fBASM_PRECOND\fP, \fBCHOLESKY_PRECOND\fP, \fBICC_PRECOND\fP, \fBILU_PRECOND\fP, \fBLU_PRECOND\fP, \fBUSER_PRECOND\fP, \fBSHELL_PRECOND\fP, \fBAMG_PRECOND\fP, \fBINVALID_PRECONDITIONER\fP }"
.br
.ti -1c
.RI "enum \fBQuadratureType\fP { \fBQGAUSS\fP = 0, \fBQJACOBI_1_0\fP = 1, \fBQJACOBI_2_0\fP = 2, \fBQSIMPSON\fP = 3, \fBQTRAP\fP = 4, \fBQGRID\fP = 5, \fBQGRUNDMANN_MOLLER\fP = 6, \fBQMONOMIAL\fP = 7, \fBQCONICAL\fP = 8, \fBQCLOUGH\fP = 21, \fBINVALID_Q_RULE\fP = 127 }"
.br
.ti -1c
.RI "enum \fBSolverPackage\fP { \fBPETSC_SOLVERS\fP =0, \fBSLEPC_SOLVERS\fP }"
.br
.ti -1c
.RI "enum \fBSolverType\fP { \fBCG\fP =0, \fBCGN\fP, \fBCGS\fP, \fBCR\fP, \fBQMR\fP, \fBTCQMR\fP, \fBTFQMR\fP, \fBBICG\fP, \fBBICGSTAB\fP, \fBMINRES\fP, \fBGMRES\fP, \fBLSQR\fP, \fBJACOBI\fP, \fBSOR_FORWARD\fP, \fBSOR_BACKWARD\fP, \fBSSOR\fP, \fBRICHARDSON\fP, \fBCHEBYSHEV\fP, \fBINVALID_SOLVER\fP }"
.br
.ti -1c
.RI "enum \fBSubsetSolveMode\fP { \fBSUBSET_ZERO\fP = 0, \fBSUBSET_COPY_RHS\fP, \fBSUBSET_DONT_TOUCH\fP }"
.br
.ti -1c
.RI "enum \fBXdrMODE\fP { \fBUNKNOWN\fP = -1, \fBENCODE\fP =0, \fBDECODE\fP, \fBWRITE\fP, \fBREAD\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const \fBNumber\fP \fBimaginary\fP (0\&., 1\&.)"
.br
.ti -1c
.RI "bool \fBinitialized\fP ()"
.br
.ti -1c
.RI "bool \fBclosed\fP ()"
.br
.ti -1c
.RI "void \fBlibmesh_terminate_handler\fP ()"
.br
.ti -1c
.RI "\fBomp_set_num_threads\fP (\fBlibMesh::libMeshPrivateData::_n_threads\fP)"
.br
.ti -1c
.RI "task_scheduler \fBreset\fP (new \fBThreads::task_scheduler_init\fP(\fBlibMesh::n_threads\fP()))"
.br
.ti -1c
.RI "\fBlibmesh_assert\fP (\fBremote_elem\fP)"
.br
.ti -1c
.RI "\fBif\fP (!\fBlibMesh::on_command_line\fP('--disable-mpi'))"
.br
.ti -1c
.RI "\fBlibmesh_assert_greater\fP (\fBlibMeshPrivateData::_n_processors\fP, 0)"
.br
.ti -1c
.RI "\fBlibmesh_parallel_only\fP (this->\fBcomm\fP())"
.br
.ti -1c
.RI "\fBif\fP (!\fBlibMesh::on_command_line\fP('--disable-petsc')#if defined(LIBMESH_HAVE_MPI)&&!\fBlibMesh::on_command_line\fP('--disable-mpi')#endif)"
.br
.ti -1c
.RI "command_line \fBparse_command_line\fP (argc, argv)"
.br
.ti -1c
.RI "if(!\fBlibMesh::on_command_line\fP('--sync-with-stdio')) 
.br
std \fBif\fP (\fBlibMesh::on_command_line\fP('--separate-libmeshout'))"
.br
.ti -1c
.RI "\fBif\fP (\fBlibMesh::on_command_line\fP('--redirect-stdout'))"
.br
.ti -1c
.RI "\fBif\fP (\fBlibMesh::global_processor_id\fP()!=0)"
.br
.ti -1c
.RI "void \fBenableFPE\fP (bool on)"
.br
.ti -1c
.RI "bool \fBon_command_line\fP (const std::string &arg)"
.br
.ti -1c
.RI "template<typename T > T \fBcommand_line_value\fP (const std::string &name, T value)"
.br
.ti -1c
.RI "template<typename T > T \fBcommand_line_value\fP (const std::vector< std::string > &name, T value)"
.br
.ti -1c
.RI "template<typename T > T \fBcommand_line_next\fP (const std::string &name, T value)"
.br
.ti -1c
.RI "template<typename T > void \fBcommand_line_vector\fP (const std::string &name, std::vector< T > &vec)"
.br
.ti -1c
.RI "\fBSolverPackage\fP \fBdefault_solver_package\fP ()"
.br
.ti -1c
.RI "template int \fBcommand_line_value< int >\fP (const std::string &, int)"
.br
.ti -1c
.RI "template float \fBcommand_line_value< float >\fP (const std::string &, float)"
.br
.ti -1c
.RI "template double \fBcommand_line_value< double >\fP (const std::string &, double)"
.br
.ti -1c
.RI "template long double \fBcommand_line_value< long double >\fP (const std::string &, long double)"
.br
.ti -1c
.RI "template std::string \fBcommand_line_value< std::string >\fP (const std::string &, std::string)"
.br
.ti -1c
.RI "template int \fBcommand_line_next< int >\fP (const std::string &, int)"
.br
.ti -1c
.RI "template float \fBcommand_line_next< float >\fP (const std::string &, float)"
.br
.ti -1c
.RI "template double \fBcommand_line_next< double >\fP (const std::string &, double)"
.br
.ti -1c
.RI "template long double \fBcommand_line_next< long double >\fP (const std::string &, long double)"
.br
.ti -1c
.RI "template std::string \fBcommand_line_next< std::string >\fP (const std::string &, std::string)"
.br
.ti -1c
.RI "template void \fBcommand_line_vector< int >\fP (const std::string &, std::vector< int > &)"
.br
.ti -1c
.RI "template void \fBcommand_line_vector< float >\fP (const std::string &, std::vector< float > &)"
.br
.ti -1c
.RI "template void \fBcommand_line_vector< double >\fP (const std::string &, std::vector< double > &)"
.br
.ti -1c
.RI "template void \fBcommand_line_vector< long double >\fP (const std::string &, std::vector< long double > &)"
.br
.ti -1c
.RI "std::string \fBprocess_trace\fP (const char *name)"
.br
.ti -1c
.RI "std::string \fBdemangle\fP (const char *name)"
.br
.ti -1c
.RI "void \fBprint_trace\fP (std::ostream &\fBout\fP)"
.br
.ti -1c
.RI "void \fBwrite_traceout\fP ()"
.br
.ti -1c
.RI "error_per_cell \fBresize\fP (mesh\&.max_elem_id())"
.br
.ti -1c
.RI "\fBif\fP (solution_vector &&solution_vector!=system\&.solution\&.get())"
.br
.ti -1c
.RI "\fBfor\fP (unsigned int var=0;var< \fBn_vars\fP;var++)"
.br
.ti -1c
.RI "this \fBreduce_error\fP (error_per_cell, system\&.comm())"
.br
.ti -1c
.RI "\fBSTART_LOG\fP ('std::sqrt()','\fBExactErrorEstimator\fP')"
.br
.ti -1c
.RI "\fBSTOP_LOG\fP ('std::sqrt()','\fBExactErrorEstimator\fP')"
.br
.ti -1c
.RI "\fBINSTANTIATE_FE\fP (0)"
.br
.ti -1c
.RI "\fBINSTANTIATE_FE\fP (1)"
.br
.ti -1c
.RI "\fBINSTANTIATE_FE\fP (2)"
.br
.ti -1c
.RI "\fBINSTANTIATE_FE\fP (3)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBFEAbstract\fP &fe)"
.br
.ti -1c
.RI "\fBREINIT_ERROR\fP (REINIT_ERROR(0, REINIT_ERROR(\fBCLOUGH\fP, reinit)"
.br
.ti -1c
.RI "\fBINSTANTIATE_ALL_MAPS\fP (0)"
.br
.ti -1c
.RI "\fBINSTANTIATE_ALL_MAPS\fP (1)"
.br
.ti -1c
.RI "\fBINSTANTIATE_ALL_MAPS\fP (2)"
.br
.ti -1c
.RI "\fBINSTANTIATE_ALL_MAPS\fP (3)"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, \fBElem\fP *, Base::build_elem(const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, \fBElem\fP *, Base::build_elem(const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, \fBElem\fP *, Base::build_elem(const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, \fBElemType\fP, Base::get_elem_type(const \fBElemType\fP type))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, \fBElemType\fP, Base::get_elem_type(const \fBElemType\fP type))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, \fBElemType\fP, Base::get_elem_type(const \fBElemType\fP type))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, unsigned int, Base::n_base_mapping_sf(const \fBElemType\fP, const \fBOrder\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, unsigned int, Base::n_base_mapping_sf(const \fBElemType\fP, const \fBOrder\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, unsigned int, Base::n_base_mapping_sf(const \fBElemType\fP, const \fBOrder\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, unsigned int, Radial::n_dofs_at_node(const \fBOrder\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, unsigned int, Radial::n_dofs_at_node(const \fBOrder\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, unsigned int, Radial::n_dofs_at_node(const \fBOrder\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, edge_reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, edge_reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, edge_reinit(const \fBElem\fP *, const unsigned int, const \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, init_face_shape_functions(const std::vector< \fBPoint\fP > &, const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, init_face_shape_functions(const std::vector< \fBPoint\fP > &, const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, init_face_shape_functions(const std::vector< \fBPoint\fP > &, const \fBElem\fP *))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, \fBPoint\fP, inverse_map(const \fBElem\fP *, const \fBPoint\fP &, const \fBReal\fP, const bool, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, \fBPoint\fP, inverse_map(const \fBElem\fP *, const \fBPoint\fP &, const \fBReal\fP, const bool, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, \fBPoint\fP, inverse_map(const \fBElem\fP *, const \fBPoint\fP &, const \fBReal\fP, const bool, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, inverse_map(const \fBElem\fP *, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &, const \fBReal\fP, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, inverse_map(const \fBElem\fP *, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &, const \fBReal\fP, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, inverse_map(const \fBElem\fP *, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &, const \fBReal\fP, const bool))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, unsigned int, n_dofs(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, unsigned int, n_dofs(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, unsigned int, n_dofs(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, unsigned int, n_dofs_per_elem(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, unsigned int, n_dofs_per_elem(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, unsigned int, n_dofs_per_elem(const \fBFEType\fP &, const \fBElemType\fP))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, unsigned int, n_dofs_at_node(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, unsigned int, n_dofs_at_node(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, unsigned int, n_dofs_at_node(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, compute_shape_indices(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, compute_shape_indices(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, compute_shape_indices(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, compute_node_indices(const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, compute_node_indices(const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, compute_node_indices(const \fBElemType\fP, const unsigned int, unsigned int &, unsigned int &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElem\fP *, const unsigned int, const \fBPoint\fP &p))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElem\fP *, const unsigned int, const \fBPoint\fP &p))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElem\fP *, const unsigned int, const \fBPoint\fP &p))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, const \fBPoint\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, const \fBPoint\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, \fBReal\fP, shape(const \fBFEType\fP &, const \fBElemType\fP, const unsigned int, const \fBPoint\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, compute_data(const \fBFEType\fP &, const \fBElem\fP *, \fBFEComputeData\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, compute_data(const \fBFEType\fP &, const \fBElem\fP *, \fBFEComputeData\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, compute_data(const \fBFEType\fP &, const \fBElem\fP *, \fBFEComputeData\fP &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (1, \fBCARTESIAN\fP, void, nodal_soln(const \fBFEType\fP &, const \fBElem\fP *, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (2, \fBCARTESIAN\fP, void, nodal_soln(const \fBFEType\fP &, const \fBElem\fP *, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &))"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE_MBRF\fP (3, \fBCARTESIAN\fP, void, nodal_soln(const \fBFEType\fP &, const \fBElem\fP *, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &))"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBMeshBase\fP &m)"
.br
.ti -1c
.RI "template void \fBMeshCommunication::find_global_indices< MeshBase::const_node_iterator >\fP (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::const_node_iterator\fP &, const \fBMeshBase::const_node_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const "
.br
.ti -1c
.RI "template void \fBMeshCommunication::find_global_indices< MeshBase::const_element_iterator >\fP (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::const_element_iterator\fP &, const \fBMeshBase::const_element_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const "
.br
.ti -1c
.RI "template void \fBMeshCommunication::find_global_indices< MeshBase::node_iterator >\fP (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::node_iterator\fP &, const \fBMeshBase::node_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const "
.br
.ti -1c
.RI "template void \fBMeshCommunication::find_global_indices< MeshBase::element_iterator >\fP (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::element_iterator\fP &, const \fBMeshBase::element_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const "
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBMeshData\fP &m)"
.br
.ti -1c
.RI "bool \fBis_between\fP (\fBReal\fP min, \fBReal\fP check, \fBReal\fP max)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, int, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, float, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, double, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, int, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, int, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, int, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, float, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, float, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, float, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, std::complex< float >, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, std::complex< float >, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, std::complex< float >, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, double, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, double, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, double, \fBReal\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBReal\fP, std::complex< double >, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, std::complex< double >, \fBComplex\fP)"
.br
.ti -1c
.RI "\fBLIBMESH_VMA_INSTANTIATE\fP (\fBComplex\fP, std::complex< double >, \fBReal\fP)"
.br
.ti -1c
.RI "\fBPetscObjectGetComm\fP ((PetscObject) \fBpc\fP,&\fBcomm\fP)"
.br
.ti -1c
.RI "\fBCHKERRABORT\fP (\fBcomm\fP, \fBierr\fP)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBQBase\fP &q)"
.br
.ti -1c
.RI "template<typename T > T \fBSIGN\fP (T a, T b)"
.br
.ti -1c
.RI "void \fBpetsc_auto_fieldsplit\fP (\fBPC\fP my_pc, const \fBSystem\fP &\fBsys\fP)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_diff_solver_monitor\fP (SNES snes, \fBPetscInt\fP its, PetscReal fnorm, void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_diff_solver_residual\fP (SNES, Vec \fBx\fP, Vec r, void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_diff_solver_jacobian\fP (SNES, Vec \fBx\fP, Mat *\fBlibmesh_dbg_var\fP(j), Mat *\fBpc\fP, MatStructure *msflag, void *ctx) \fBPetscErrorCode\fP __libmesh_petsc_diff_solver_jacobian(SNES"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec Mat \fBlibmesh_dbg_var\fP (j)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec Mat Mat 
.br
void *ctx \fBlibmesh_assert\fP (\fBx\fP)"
.br
.ti -1c
.RI "\fBlibmesh_assert\fP (j)"
.br
.ti -1c
.RI "\fBlibmesh_assert\fP (ctx)"
.br
.ti -1c
.RI "\fBPetscVector\fP< \fBNumber\fP > \fBX_input\fP (\fBx\fP, sys\&.comm())"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > \fBJ_input\fP * \fBpc\fP ()"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > \fBJ_input\fP (\fBpc\fP, sys\&.comm())"
.br
.ti -1c
.RI "\fBX_input\fP \fBswap\fP (\fBX_system\fP)"
.br
.ti -1c
.RI "\fBJ_input\fP \fBswap\fP (\fBJ_system\fP)"
.br
.ti -1c
.RI "\fBsys\fP \fBget_dof_map\fP ()"
.br
.ti -1c
.RI "\fBDiffSolver::SolveResult\fP \fBconvert_solve_result\fP (SNESConvergedReason r)"
.br
.ti -1c
.RI "void \fBPetscDMRegister\fP ()"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_preconditioner_setup\fP (void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_preconditioner_apply\fP (void *ctx, Vec \fBx\fP, Vec y)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_preconditioner_setup\fP (\fBPC\fP \fBpc\fP)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_preconditioner_apply\fP (\fBPC\fP \fBpc\fP, Vec \fBx\fP, Vec y)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_monitor\fP (SNES, \fBPetscInt\fP its, PetscReal fnorm, void *)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_residual\fP (SNES snes, Vec \fBx\fP, Vec r, void *ctx)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_jacobian\fP (SNES snes, Vec \fBx\fP, Mat *\fBjac\fP, Mat *\fBpc\fP, MatStructure *msflag, void *ctx) \fBPetscErrorCode\fP __libmesh_petsc_snes_jacobian(SNES snes"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec Mat Mat 
.br
void *ctx \fBSTART_LOG\fP ('jacobian()','\fBPetscNonlinearSolver\fP')"
.br
.ti -1c
.RI "\fBCHKERRABORT\fP (\fBsolver\fP->\fBcomm\fP()\&.get(), \fBierr\fP)"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > \fBJac\fP * \fBjac\fP ()"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > \fBPC\fP (\fBpc\fP, sys\&.comm())"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > \fBJac\fP (\fBjac\fP, sys\&.comm())"
.br
.ti -1c
.RI "\fBPetscVector\fP< \fBNumber\fP > \fBX_global\fP (\fBx\fP, sys\&.comm())"
.br
.ti -1c
.RI "\fBPC\fP \fBattach_dof_map\fP (\fBsys\&.get_dof_map\fP())"
.br
.ti -1c
.RI "\fBX_global\fP \fBswap\fP (\fBX_sys\fP)"
.br
.ti -1c
.RI "\fBJac\fP \fBswap\fP (\fBJac_sys\fP)"
.br
.ti -1c
.RI "\fBif\fP (\fBsolver\fP->matvec &&\fBsolver\fP->residual_and_jacobian_object)"
.br
.ti -1c
.RI "\fBif\fP (\fBsolver\fP->jacobian!=NULL)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBEquationSystems\fP &es)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::complex< float > >\fP (std::complex< float > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::complex< double > >\fP (std::complex< double > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::complex< long double > >\fP (std::complex< long double > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::string >\fP (std::string &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< int > >\fP (std::vector< int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< unsigned int > >\fP (std::vector< unsigned int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< short int > >\fP (std::vector< short int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< unsigned short int > >\fP (std::vector< unsigned short int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< long int > >\fP (std::vector< long int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< unsigned long int > >\fP (std::vector< unsigned long int > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< unsigned long long > >\fP (std::vector< unsigned long long > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< char > >\fP (std::vector< char > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< signed char > >\fP (std::vector< signed char > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< unsigned char > >\fP (std::vector< unsigned char > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< float > >\fP (std::vector< float > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< double > >\fP (std::vector< double > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< long double > >\fP (std::vector< long double > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< std::complex< float > > >\fP (std::vector< std::complex< float > > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< std::complex< double > > >\fP (std::vector< std::complex< double > > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< std::complex< long double > > >\fP (std::vector< std::complex< long double > > &, const char *)"
.br
.ti -1c
.RI "template void \fBXdr::data< std::vector< std::string > >\fP (std::vector< std::string > &, const char *)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (char)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (short)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (int)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (long)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (unsigned char)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (float)"
.br
.ti -1c
.RI "\fBScalarTraits_true\fP (double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (unsigned char, short)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (unsigned char, int)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (unsigned char, float)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (unsigned char, double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (unsigned char, long double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (char, short)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (char, int)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (char, float)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (char, double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (char, long double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (short, int)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (short, float)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (short, double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (short, long double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (int, float)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (int, double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (int, long double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (float, double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (float, long double)"
.br
.ti -1c
.RI "\fBSUPERTYPE\fP (double, long double)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBElem\fP &e)"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE\fP (1, \fBCARTESIAN\fP)"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE\fP (2, \fBCARTESIAN\fP)"
.br
.ti -1c
.RI "\fBINSTANTIATE_INF_FE\fP (3, \fBCARTESIAN\fP)"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP ()"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP ()"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBglobal_n_processors\fP ()"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBglobal_processor_id\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_threads\fP ()"
.br
.ti -1c
.RI "template<typename T > T \fBlibmesh_real\fP (T a)"
.br
.ti -1c
.RI "template<typename T > T \fBlibmesh_conj\fP (T a)"
.br
.ti -1c
.RI "template<typename T > T \fBlibmesh_real\fP (std::complex< T > a)"
.br
.ti -1c
.RI "template<typename T > std::complex< T > \fBlibmesh_conj\fP (std::complex< T > a)"
.br
.ti -1c
.RI "bool \fBlibmesh_isnan\fP (float a)"
.br
.ti -1c
.RI "bool \fBlibmesh_isnan\fP (double a)"
.br
.ti -1c
.RI "bool \fBlibmesh_isnan\fP (long double a)"
.br
.ti -1c
.RI "template<typename T > bool \fBlibmesh_isnan\fP (std::complex< T > a)"
.br
.ti -1c
.RI "template<typename Tnew , typename Told > Tnew \fBlibmesh_cast_ref\fP (Told &oldvar)"
.br
.ti -1c
.RI "template<typename Tnew , typename Told > Tnew \fBlibmesh_cast_ptr\fP (Told *oldvar)"
.br
.ti -1c
.RI "template<typename Tnew , typename Told > Tnew \fBlibmesh_cast_int\fP (Told oldvar)"
.br
.ti -1c
.RI "template<class T > void \fBlibmesh_ignore\fP (const T &)"
.br
.ti -1c
.RI "void \fBlibmesh_version_stdout\fP ()"
.br
.ti -1c
.RI "int \fBget_libmesh_version\fP ()"
.br
.ti -1c
.RI "std::string \fBget_io_compatibility_version\fP ()"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBNode\fP &n)"
.br
.ti -1c
.RI "template<typename P > void \fBprint_helper\fP (std::ostream &os, const P *param)"
.br
.ti -1c
.RI "template<typename P > void \fBprint_helper\fP (std::ostream &os, const std::vector< P > *param)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBParameters\fP &p)"
.br
.ti -1c
.RI "void \fBPetscDMSetSystem\fP (DM, \fBNonlinearImplicitSystem\fP &)"
.br
.ti -1c
.RI "void \fBPetscDMGetSystem\fP (DM, \fBNonlinearImplicitSystem\fP *&)"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP \fB__libmesh_petsc_snes_jacobian\fP (SNES, Vec \fBx\fP, Mat \fBjac\fP, Mat \fBpc\fP, void *ctx)"
.br
.ti -1c
.RI "template<typename T > std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBSparseMatrix\fP< T > &m)"
.br
.ti -1c
.RI "template<typename T , typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeTensor\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar factor, const \fBTypeTensor\fP< T > &t)"
.br
.ti -1c
.RI "template<typename T , typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar factor, const \fBTypeVector\fP< T > &v)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "DIE \fBA\fP HORRIBLE DEATH HERE 
.br
typedef 
.br
LIBMESH_DEFAULT_SCALAR_TYPE \fBReal\fP"
.br
.ti -1c
.RI "DIE \fBA\fP HORRIBLE DEATH HERE 
.br
typedef float \fBErrorVectorReal\fP"
.br
.ti -1c
.RI "MPI_Comm \fBCOMM_WORLD\fP = MPI_COMM_NULL"
.br
.ti -1c
.RI "MPI_Comm \fBGLOBAL_COMM_WORLD\fP = MPI_COMM_NULL"
.br
.ti -1c
.RI "\fBParallel::FakeCommunicator\fP \fBCommWorld\fP"
.br
.ti -1c
.RI "\fBOStreamProxy\fP \fBout\fP (std::cout)"
.br
.ti -1c
.RI "\fBOStreamProxy\fP \fBerr\fP (std::cerr)"
.br
.ti -1c
.RI "\fBPerfLog\fP \fBperflog\fP ('libMesh',#ifdef LIBMESH_ENABLE_PERFORMANCE_LOGGING true#else false#endif)"
.br
.ti -1c
.RI "MPI_Errhandler \fBlibmesh_errhandler\fP"
.br
.ti -1c
.RI "\fBTRILINOS_SOLVERS\fP"
.br
.ti -1c
.RI "\fBEIGEN_SOLVERS\fP"
.br
.ti -1c
.RI "\fBLASPACK_SOLVERS\fP"
.br
.ti -1c
.RI "\fBINVALID_SOLVER_PACKAGE\fP"
.br
.ti -1c
.RI "std::terminate_handler \fBold_terminate_handler\fP"
.br
.ti -1c
.RI "\fBLibMeshInit::LibMeshInit\fP(int 
.br
argc, const char *const *argv) 
.br
\fBLibMeshInit\fP command_lin \fBreset\fP )(new GetPot(argc, argv))"
.br
.ti -1c
.RI "\fBn_threads\fP [0] = '--n_threads'"
.br
.ti -1c
.RI "void 
.br
\fBExactErrorEstimator::estimate_error\fP(const 
.br
\fBSystem\fP &system, \fBErrorVector\fP 
.br
&error_per_cell, const 
.br
\fBNumericVector\fP< \fBNumber\fP >
.br
 *solution_vector, bool 
.br
estimate_parent_error) void 
.br
\fBExactErrorEstimator\fP const 
.br
unsigned in \fBdim\fP ) = mesh\&.mesh_dimension()"
.br
.ti -1c
.RI "const unsigned int \fBn_vars\fP = system\&.n_vars()"
.br
.ti -1c
.RI "const \fBDofMap\fP & \fBdof_map\fP = \fBsystem\&.get_dof_map\fP()"
.br
.ti -1c
.RI "\fBINSTANTIATE_SUBDIVISION_FE\fP"
.br
.ti -1c
.RI "\fBINSTANTIATE_SUBDIVISION_MAPS\fP"
.br
.ti -1c
.RI "const \fBRemoteElem\fP * \fBremote_elem\fP"
.br
.ti -1c
.RI "template<typename T > void \fBPetscPreconditioner\fP< T >
.br
::set_petsc_subpreconditioner_type(PCType 
.br
type, \fBPC\fP &\fBpc\fP) void 
.br
\fBPetscPreconditioner\fP< T >
.br
 \fBParallel::communicator\fP \fBcomm\fP"
.br
.ti -1c
.RI "\fBParallel::Communicator\fP \fBcommunicator\fP (\fBcomm\fP)"
.br
.ti -1c
.RI "\fBierr\fP = PCSetUp(\fBpc\fP)"
.br
.ti -1c
.RI "KSP * \fBsubksps\fP"
.br
.ti -1c
.RI "\fBPetscInt\fP \fBn_local\fP"
.br
.ti -1c
.RI "const unsigned int \fBMIN_ELEM_PER_PROC\fP = 4"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec \fBx\fP"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec Mat Mat \fBpc\fP"
.br
.ti -1c
.RI "\fBPetscDiffSolver\fP & \fBsolver\fP"
.br
.ti -1c
.RI "\fBImplicitSystem\fP & \fBsys\fP = solver\&.system()"
.br
.ti -1c
.RI "\fBif\fP(solver\&.verbose) libMesh 
.br
\fBPetscVector\fP< \fBNumber\fP > & \fBX_system\fP"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > & \fBJ_system\fP"
.br
.ti -1c
.RI "\fBPetscBool\fP \fBPetscDMRegistered\fP = PETSC_FALSE"
.br
.ti -1c
.RI "\fBPetscErrorCode\fP Vec Mat \fBjac\fP"
.br
.ti -1c
.RI "\fBsolver\fP \fB_current_nonlinear_iteration_number\fP = static_cast<unsigned>(n_iterations)"
.br
.ti -1c
.RI "\fBPetscVector\fP< \fBNumber\fP > & \fBX_sys\fP = *\fBlibmesh_cast_ptr\fP<\fBPetscVector\fP<\fBNumber\fP>*>(sys\&.solution\&.get())"
.br
.ti -1c
.RI "\fBPetscMatrix\fP< \fBNumber\fP > & \fBJac_sys\fP = *\fBlibmesh_cast_ptr\fP<\fBPetscMatrix\fP<\fBNumber\fP>*>(sys\&.matrix)"
.br
.ti -1c
.RI "const unsigned char \fBtriangular_number_row\fP []"
.br
.ti -1c
.RI "const unsigned char \fBtriangular_number_column\fP []"
.br
.ti -1c
.RI "const unsigned char \fBsquare_number_column\fP []"
.br
.ti -1c
.RI "const unsigned char \fBsquare_number_row\fP []"
.br
.ti -1c
.RI "const unsigned char \fBcube_number_column\fP []"
.br
.ti -1c
.RI "const unsigned char \fBcube_number_row\fP []"
.br
.ti -1c
.RI "const unsigned char \fBcube_number_page\fP []"
.br
.ti -1c
.RI "const \fBNumber\fP \fBimaginary\fP"
.br
.ti -1c
.RI "const \fBReal\fP \fBpi\fP"
.br
.ti -1c
.RI "const \fBNumber\fP \fBzero\fP = 0\&."
.br
.ti -1c
.RI "const unsigned int \fBinvalid_uint\fP = static_cast<unsigned int>(-1)"
.br
.ti -1c
.RI "static const \fBReal\fP \fBTOLERANCE\fP = 1\&.e-8"
.br
.in -1c
.SH "Detailed Description"
.PP 
Sanity check, \fIwithout\fP prior inclusion of \fBlibmesh_config\&.h\fP\&.
.PP
This file is no typical header file\&. It is only to be included at the \fIend\fP of an implementation file, so that the proper variations of the \fBInfFE\fP class are instantiated\&.
.PP
The \fC\fBlibMesh\fP\fP namespace provides an interface to certain functionality in the library\&. It provides a uniform \fC\fBinit()\fP\fP method that initializes any other dependent libraries (e\&.g\&. MPI or PETSC), and a \fCclose()\fP method for closing those libraries\&. It also provides a centralized place for performance logging and other functionality\&.
.PP
Petsc include files\&.
.PP
SLEPc include files\&.
.PP
Trilinos include files\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef int16_t \fBlibMesh::boundary_id_type\fP"

.PP
Definition at line 47 of file id_types\&.h\&.
.SS "typedef std::complex<\fBReal\fP> \fBlibMesh::Complex\fP"

.PP
Definition at line 143 of file libmesh_common\&.h\&.
.SS "typedef std::complex<\fBReal\fP> \fBlibMesh::COMPLEX\fP"

.PP
Definition at line 144 of file libmesh_common\&.h\&.
.SS "typedef std::vector<\fBPoint\fP>::const_iterator \fBlibMesh::const_list_iterator\fP"

.PP
Definition at line 33 of file point_locator_list\&.C\&.
.SS "typedef \fBStoredRange\fP<\fBMeshBase::const_element_iterator\fP, const \fBElem\fP*> \fBlibMesh::ConstElemRange\fP"

.PP
Definition at line 32 of file elem_range\&.h\&.
.SS "typedef \fBStoredRange\fP<\fBMeshBase::const_node_iterator\fP, const \fBNode\fP*> \fBlibMesh::ConstNodeRange\fP"

.PP
Definition at line 34 of file node_range\&.h\&.
.SS "typedef \fBSerialMesh\fP \fBlibMesh::DefaultMesh\fP"

.PP
Definition at line 27 of file mesh\&.h\&.
.SS "typedef uint32_t \fBlibMesh::dof_id_type\fP"

.PP
Definition at line 58 of file id_types\&.h\&.
.SS "typedef std::map<\fBdof_id_type\fP, \fBReal\fP, std::less<\fBdof_id_type\fP>, \fBThreads::scalable_allocator\fP<std::pair<const \fBdof_id_type\fP, \fBReal\fP> > > \fBlibMesh::DofConstraintRow\fP"
A row of the Dof constraint matrix\&. 
.PP
Definition at line 87 of file dof_map\&.h\&.
.SS "typedef int32_t \fBlibMesh::eigen_idx_type\fP"

.PP
Definition at line 59 of file eigen_core_support\&.h\&.
.SS "typedef Eigen::SparseMatrix<\fBNumber\fP, Eigen::RowMajor, \fBeigen_idx_type\fP> \fBlibMesh::EigenSM\fP"

.PP
Definition at line 71 of file eigen_core_support\&.h\&.
.SS "typedef Eigen::Matrix<\fBNumber\fP, Eigen::Dynamic, 1> \fBlibMesh::EigenSV\fP"

.PP
Definition at line 72 of file eigen_core_support\&.h\&.
.SS "typedef \fBStoredRange\fP<\fBMeshBase::element_iterator\fP, \fBElem\fP*> \fBlibMesh::ElemRange\fP"

.PP
Definition at line 31 of file elem_range\&.h\&.
.SS "typedef \fBFEGenericBase\fP< \fBReal\fP > \fBlibMesh::FEBase\fP"

.PP
Definition at line 37 of file exact_error_estimator\&.h\&.
.SS "typedef \fBFEGenericBase\fP<\fBRealGradient\fP> \fBlibMesh::FEVectorBase\fP"

.PP
Definition at line 663 of file fe_base\&.h\&.
.SS "typedef \fBNumberVectorValue\fP \fBlibMesh::Gradient\fP"

.PP
Definition at line 52 of file exact_error_estimator\&.h\&.
.SS "typedef uint8_t \fBlibMesh::largest_id_type\fP"

.PP
Definition at line 121 of file id_types\&.h\&.
.SS "typedef double* \fBlibMesh::LPDOUBLE\fP"

.PP
Definition at line 39 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef int* \fBlibMesh::LPINT\fP"

.PP
Definition at line 44 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef \fBLPDOUBLE\fP* \fBlibMesh::LPLPDOUBLE\fP"

.PP
Definition at line 40 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef \fBLPINT\fP* \fBlibMesh::LPLPINT\fP"

.PP
Definition at line 45 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef \fBLPLPDOUBLE\fP* \fBlibMesh::LPLPLPDOUBLE\fP"

.PP
Definition at line 41 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef \fBLPVOID\fP* \fBlibMesh::LPLPVOID\fP"

.PP
Definition at line 43 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef void* \fBlibMesh::LPVOID\fP"

.PP
Definition at line 42 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef std::map<const \fBNode\fP *, \fBReal\fP, std::less<const \fBNode\fP *>, \fBThreads::scalable_allocator\fP<std::pair<const \fBNode\fP * const, \fBReal\fP> > > \fBlibMesh::NodeConstraintRow\fP"
A row of the \fBNode\fP constraint mapping\&. Currently this just stores the topology of the constrained Nodes, but for forward compatibility we also include coefficients, so we could add Lagrange-positioned-node constraints later\&. 
.PP
Definition at line 135 of file dof_map\&.h\&.
.SS "typedef \fBStoredRange\fP<\fBMeshBase::node_iterator\fP, \fBNode\fP*> \fBlibMesh::NodeRange\fP"

.PP
Definition at line 33 of file node_range\&.h\&.
.SS "typedef \fBComplex\fP \fBlibMesh::Number\fP"

.PP
Definition at line 172 of file libmesh_common\&.h\&.
.SS "typedef \fBTensorValue\fP< \fBNumber\fP > \fBlibMesh::NumberTensorValue\fP"

.PP
Definition at line 48 of file exact_error_estimator\&.h\&.
.SS "typedef \fBVectorValue\fP< \fBNumber\fP > \fBlibMesh::NumberVectorValue\fP"

.PP
Definition at line 51 of file exact_error_estimator\&.h\&.
.SS "typedef \fBdof_id_type\fP \fBlibMesh::numeric_index_type\fP"

.PP
Definition at line 82 of file id_types\&.h\&.
.SS "typedef \fBBasicOStreamProxy\fP \fBlibMesh::OStreamProxy\fP"

.PP
Definition at line 239 of file ostream_proxy\&.h\&.
.SS "typedef int \fBlibMesh::PetscErrorCode\fP"

.PP
Definition at line 44 of file petsc_diff_solver\&.C\&.
.SS "typedef int \fBlibMesh::PetscInt\fP"

.PP
Definition at line 45 of file petsc_diff_solver\&.C\&.
.SS "typedef uint16_t \fBlibMesh::processor_id_type\fP"

.PP
Definition at line 89 of file id_types\&.h\&.
.SS "typedef \fBReal\fP \fBlibMesh::REAL\fP"

.PP
Definition at line 36 of file mesh_triangle_wrapper\&.h\&.
.SS "typedef \fBRealVectorValue\fP \fBlibMesh::RealGradient\fP"

.PP
Definition at line 50 of file hp_coarsentest\&.h\&.
.SS "typedef \fBRealTensorValue\fP \fBlibMesh::RealTensor\fP"

.PP
Definition at line 51 of file hp_coarsentest\&.h\&.
.SS "typedef \fBTensorValue\fP< \fBReal\fP > \fBlibMesh::RealTensorValue\fP"
Useful typedefs to allow transparent switching between Real and Complex data types\&. 
.PP
Definition at line 49 of file hp_coarsentest\&.h\&.
.SS "typedef \fBVectorValue\fP< \fBReal\fP > \fBlibMesh::RealVectorValue\fP"
Useful typedefs to allow transparent switching between Real and Complex data types\&. 
.PP
Definition at line 47 of file hp_coarsentest\&.h\&.
.SS "typedef \fBDerivedRBConstruction\fP<\fBRBConstruction\fP> \fBlibMesh::SteadyDerivedRBConstruction\fP"

.PP
Definition at line 174 of file derived_rb_construction\&.h\&.
.SS "typedef \fBDerivedRBEvaluation\fP<\fBRBEvaluation\fP> \fBlibMesh::SteadyDerivedRBEvaluation\fP"

.PP
Definition at line 118 of file derived_rb_evaluation\&.h\&.
.SS "typedef \fBLinearImplicitSystem\fP \fBlibMesh::SteadyLinearSystem\fP"

.PP
Definition at line 34 of file steady_system\&.h\&.
.SS "typedef uint16_t \fBlibMesh::subdomain_id_type\fP"
Note: subdomain_id_types are positive integers - however limitation in the exodusII API force us to use a signed integer here to represent subdomains\&. This gives us 2^31 possible unique blocks
.PP
Based on the 4-byte comment warning above, this probably doesn't work with exodusII \fIat all\fP\&.\&.\&. 
.PP
Definition at line 43 of file id_types\&.h\&.
.SS "typedef \fBNumberTensorValue\fP \fBlibMesh::Tensor\fP"

.PP
Definition at line 50 of file exact_error_estimator\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBSystem\fP> \fBlibMesh::TransientBaseSystem\fP"

.PP
Definition at line 152 of file transient_system\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBExplicitSystem\fP> \fBlibMesh::TransientExplicitSystem\fP"

.PP
Definition at line 151 of file transient_system\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBLinearImplicitSystem\fP> \fBlibMesh::TransientImplicitSystem\fP"

.PP
Definition at line 148 of file transient_system\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBLinearImplicitSystem\fP> \fBlibMesh::TransientLinearImplicitSystem\fP"

.PP
Definition at line 149 of file transient_system\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBNonlinearImplicitSystem\fP> \fBlibMesh::TransientNonlinearImplicitSystem\fP"

.PP
Definition at line 150 of file transient_system\&.h\&.
.SS "typedef unsigned int \fBlibMesh::uint\fP"

.PP
Definition at line 46 of file mesh_smoother_vsmoother\&.h\&.
.SS "typedef uint64_t \fBlibMesh::unique_id_type\fP"

.PP
Definition at line 69 of file id_types\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBlibMesh::EigenProblemType\fP"
Defines an \fCenum\fP for eigenproblem types\&. This can be Hermitian (HEP), generalized Hermitian (GHEP), non-Hermitian (NHEP), and generalized non-Hermitian (GNHEP) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINHEP \fP\fP
.TP
\fB\fIHEP \fP\fP
.TP
\fB\fIGNHEP \fP\fP
.TP
\fB\fIGHEP \fP\fP
.TP
\fB\fIINVALID_EIGENPROBLEMTYPE \fP\fP
.PP
Definition at line 50 of file enum_eigen_solver_type\&.h\&.
.PP
.nf
50                       {NHEP=0,
51                        HEP,
52                        GNHEP,
53                        GHEP,
54 
55                        INVALID_EIGENPROBLEMTYPE};
.fi
.SS "enum \fBlibMesh::EigenSolverType\fP"
Defines an \fCenum\fP for iterative eigenproblem solver types 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPOWER \fP\fP
.TP
\fB\fILAPACK \fP\fP
.TP
\fB\fISUBSPACE \fP\fP
.TP
\fB\fIARNOLDI \fP\fP
.TP
\fB\fILANCZOS \fP\fP
.TP
\fB\fIKRYLOVSCHUR \fP\fP
.TP
\fB\fIINVALID_EIGENSOLVER \fP\fP
.PP
Definition at line 30 of file enum_eigen_solver_type\&.h\&.
.PP
.nf
30                      {POWER=0,
31                       LAPACK,
32                       SUBSPACE,
33                       ARNOLDI,
34                       LANCZOS,
35                       KRYLOVSCHUR,
36                       // SLEPc optional packages
37                       // EPSARPACK,
38                       // EPSLAPACK,
39                       // EPSBLZPACK,
40                       // EPSPLANSO,
41                       // EPSTRLAN,
42 
43                       INVALID_EIGENSOLVER};
.fi
.SS "enum \fBlibMesh::ElemQuality\fP"
Defines an \fCenum\fP for element quality metrics\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIASPECT_RATIO \fP\fP
.TP
\fB\fISKEW \fP\fP
.TP
\fB\fISHEAR \fP\fP
.TP
\fB\fISHAPE \fP\fP
.TP
\fB\fIMAX_ANGLE \fP\fP
.TP
\fB\fIMIN_ANGLE \fP\fP
.TP
\fB\fICONDITION \fP\fP
.TP
\fB\fIDISTORTION \fP\fP
.TP
\fB\fITAPER \fP\fP
.TP
\fB\fIWARP \fP\fP
.TP
\fB\fISTRETCH \fP\fP
.TP
\fB\fIDIAGONAL \fP\fP
.TP
\fB\fIASPECT_RATIO_BETA \fP\fP
.TP
\fB\fIASPECT_RATIO_GAMMA \fP\fP
.TP
\fB\fISIZE \fP\fP
.TP
\fB\fIJACOBIAN \fP\fP
.PP
Definition at line 30 of file enum_elem_quality\&.h\&.
.PP
.nf
30                  {ASPECT_RATIO=0,
31                   SKEW,
32                   SHEAR,
33                   SHAPE,
34                   MAX_ANGLE,
35                   MIN_ANGLE,
36                   CONDITION,
37                   DISTORTION,
38                   TAPER,
39                   WARP,
40                   STRETCH,
41                   DIAGONAL,
42                   ASPECT_RATIO_BETA,
43                   ASPECT_RATIO_GAMMA,
44                   SIZE,
45                   JACOBIAN};
.fi
.SS "enum \fBlibMesh::ElemType\fP"
Defines an \fCenum\fP for geometric element types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIEDGE2 \fP\fP
.TP
\fB\fIEDGE3 \fP\fP
.TP
\fB\fIEDGE4 \fP\fP
.TP
\fB\fITRI3 \fP\fP
.TP
\fB\fITRI6 \fP\fP
.TP
\fB\fIQUAD4 \fP\fP
.TP
\fB\fIQUAD8 \fP\fP
.TP
\fB\fIQUAD9 \fP\fP
.TP
\fB\fITET4 \fP\fP
.TP
\fB\fITET10 \fP\fP
.TP
\fB\fIHEX8 \fP\fP
.TP
\fB\fIHEX20 \fP\fP
.TP
\fB\fIHEX27 \fP\fP
.TP
\fB\fIPRISM6 \fP\fP
.TP
\fB\fIPRISM15 \fP\fP
.TP
\fB\fIPRISM18 \fP\fP
.TP
\fB\fIPYRAMID5 \fP\fP
.TP
\fB\fIPYRAMID13 \fP\fP
.TP
\fB\fIPYRAMID14 \fP\fP
.TP
\fB\fIINFEDGE2 \fP\fP
.TP
\fB\fIINFQUAD4 \fP\fP
.TP
\fB\fIINFQUAD6 \fP\fP
.TP
\fB\fIINFHEX8 \fP\fP
.TP
\fB\fIINFHEX16 \fP\fP
.TP
\fB\fIINFHEX18 \fP\fP
.TP
\fB\fIINFPRISM6 \fP\fP
.TP
\fB\fIINFPRISM12 \fP\fP
.TP
\fB\fINODEELEM \fP\fP
.TP
\fB\fIREMOTEELEM \fP\fP
.TP
\fB\fITRI3SUBDIVISION \fP\fP
.TP
\fB\fIINVALID_ELEM \fP\fP
.PP
Definition at line 30 of file enum_elem_type\&.h\&.
.PP
.nf
30               {EDGE2=0,         // 0
31                EDGE3,           // 1
32                EDGE4,           // 2
33 
34                TRI3,            // 3
35                TRI6,            // 4
36 
37                QUAD4,           // 5
38                QUAD8,           // 6
39                QUAD9,           // 7
40 
41                TET4,            // 8
42                TET10,           // 9
43 
44                HEX8,            // 10
45                HEX20,           // 11
46                HEX27,           // 12
47 
48                PRISM6,          // 13
49                PRISM15,         // 14
50                PRISM18,         // 15
51 
52                PYRAMID5,        // 16
53                PYRAMID13,       // 17
54                PYRAMID14,       // 18
55 
56                INFEDGE2,        // 19
57 
58                INFQUAD4,        // 20
59                INFQUAD6,        // 21
60 
61                INFHEX8,         // 22
62                INFHEX16,        // 23
63                INFHEX18,        // 24
64 
65                INFPRISM6,       // 25
66                INFPRISM12,      // 26
67 
68                NODEELEM,        // 27
69 
70                REMOTEELEM,      // 28
71 
72                TRI3SUBDIVISION, // 29
73 
74                INVALID_ELEM};   // 30 - should always be last
.fi
.SS "enum \fBlibMesh::FEContinuity\fP"
defines an \fCenum\fP for finite element types to libmesh_assert a certain level (or type? Hcurl?) of continuity\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDISCONTINUOUS \fP\fP
.TP
\fB\fIC_ZERO \fP\fP
.TP
\fB\fIC_ONE \fP\fP
.TP
\fB\fIH_CURL \fP\fP
.PP
Definition at line 72 of file enum_fe_family\&.h\&.
.PP
.nf
72                   {DISCONTINUOUS,
73                    C_ZERO,
74                    C_ONE,
75                    H_CURL};
.fi
.SS "enum \fBlibMesh::FEFamily\fP"
defines an \fCenum\fP for finite element families\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILAGRANGE \fP\fP
.TP
\fB\fIHIERARCHIC \fP\fP
.TP
\fB\fIMONOMIAL \fP\fP
.TP
\fB\fIL2_HIERARCHIC \fP\fP
.TP
\fB\fIL2_LAGRANGE \fP\fP
.TP
\fB\fIBERNSTEIN \fP\fP
.TP
\fB\fISZABAB \fP\fP
.TP
\fB\fIXYZ \fP\fP
.TP
\fB\fIINFINITE_MAP \fP\fP
.TP
\fB\fIJACOBI_20_00 \fP\fP
.TP
\fB\fIJACOBI_30_00 \fP\fP
.TP
\fB\fILEGENDRE \fP\fP
.TP
\fB\fICLOUGH \fP\fP
.TP
\fB\fIHERMITE \fP\fP
.TP
\fB\fISUBDIVISION \fP\fP
.TP
\fB\fISCALAR \fP\fP
.TP
\fB\fILAGRANGE_VEC \fP\fP
.TP
\fB\fINEDELEC_ONE \fP\fP
.TP
\fB\fIINVALID_FE \fP\fP
.PP
Definition at line 32 of file enum_fe_family\&.h\&.
.PP
.nf
32               {LAGRANGE     = 0,
33                HIERARCHIC   = 1,
34 
35                // discontinuous, in local coordinates
36                MONOMIAL      = 2,
37                L2_HIERARCHIC = 6,
38                L2_LAGRANGE   = 7,
39 
40                // higher-order
41                BERNSTEIN    = 3,
42                SZABAB       = 4,
43 
44                // discontinuous, in global coordinates
45                XYZ          = 5,
46 
47                // infinite element stuff
48                INFINITE_MAP = 11,     //   for 1/r-map
49                JACOBI_20_00 = 12,     //   i_max = 19
50                JACOBI_30_00 = 13,     //   i_max = 19
51                LEGENDRE     = 14,     //   i_max = 19
52 
53                // C1 elements
54                CLOUGH       = 21,
55                HERMITE      = 22,
56                SUBDIVISION  = 23,
57 
58                // A scalar variable that couples to
59                // all other DOFs in the system
60                SCALAR       = 31,
61 
62                // Vector-valued elements
63                LAGRANGE_VEC = 41,
64                NEDELEC_ONE  = 42,
65 
66                INVALID_FE   = 99};
.fi
.SS "enum \fBlibMesh::FEFieldType\fP"
defines an \fCenum\fP for finite element field types - i\&.e\&. is it a scalar element, vector, tensor, etc\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fITYPE_SCALAR \fP\fP
.TP
\fB\fITYPE_VECTOR \fP\fP
.PP
Definition at line 81 of file enum_fe_family\&.h\&.
.PP
.nf
81                  {TYPE_SCALAR = 0,
82                   TYPE_VECTOR};
.fi
.SS "enum \fBlibMesh::FEMNormType\fP"
defines an \fCenum\fP for norms defined on vectors of finite element coefficients 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIL2 \fP\fP
.TP
\fB\fIH1 \fP\fP
.TP
\fB\fIH2 \fP\fP
.TP
\fB\fIHCURL \fP\fP
.TP
\fB\fIHDIV \fP\fP
.TP
\fB\fIL1 \fP\fP
.TP
\fB\fIL_INF \fP\fP
.TP
\fB\fIH1_SEMINORM \fP\fP
.TP
\fB\fIH2_SEMINORM \fP\fP
.TP
\fB\fIHCURL_SEMINORM \fP\fP
.TP
\fB\fIHDIV_SEMINORM \fP\fP
.TP
\fB\fIW1_INF_SEMINORM \fP\fP
.TP
\fB\fIW2_INF_SEMINORM \fP\fP
.TP
\fB\fIDISCRETE_L1 \fP\fP
.TP
\fB\fIDISCRETE_L2 \fP\fP
.TP
\fB\fIDISCRETE_L_INF \fP\fP
.TP
\fB\fIH1_X_SEMINORM \fP\fP
.TP
\fB\fIH1_Y_SEMINORM \fP\fP
.TP
\fB\fIH1_Z_SEMINORM \fP\fP
.TP
\fB\fIINVALID_NORM \fP\fP
.PP
Definition at line 32 of file enum_norm_type\&.h\&.
.PP
.nf
32                  {L2              = 0,
33                   H1              = 1,
34                   H2              = 2,
35                   HCURL           = 3,
36                   HDIV            = 4,
37 
38                   L1              = 5,
39                   L_INF           = 6,
40 
41                   H1_SEMINORM     = 10,
42 
43                   H2_SEMINORM     = 11,
44 
45                   HCURL_SEMINORM  = 12,
46 
47                   HDIV_SEMINORM   = 13,
48 
49                   W1_INF_SEMINORM = 15,
50                   W2_INF_SEMINORM = 16,
51 
52                   // discrete norms on coefficient vectors
53                   DISCRETE_L1     = 20,
54                   DISCRETE_L2     = 21,
55                   DISCRETE_L_INF  = 22,
56 
57                   // Seminorms based on only individual gradient
58                   // directional components
59                   H1_X_SEMINORM    = 31,
60                   H1_Y_SEMINORM    = 32,
61                   H1_Z_SEMINORM    = 33,
62 
63                   INVALID_NORM    = 42};
.fi
.SS "enum \fBlibMesh::InfMapType\fP"
defines an \fCenum\fP for the types of coordinate mappings available in infinite elements\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICARTESIAN \fP\fP
.TP
\fB\fISPHERICAL \fP\fP
.TP
\fB\fIELLIPSOIDAL \fP\fP
.TP
\fB\fIINVALID_INF_MAP \fP\fP
.PP
Definition at line 31 of file enum_inf_map_type\&.h\&.
.PP
.nf
31                 {CARTESIAN=0,
32                  SPHERICAL,
33                  ELLIPSOIDAL,
34                  INVALID_INF_MAP};
.fi
.SS "enum \fBlibMesh::IOPackage\fP"
\fBlibMesh\fP interfaces with several different software packages for the purposes of creating, reading, and writing mesh files\&. These enumerations give an easy way of selecting one or the other\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fITECPLOT \fP\fP
.TP
\fB\fIGMV \fP\fP
.TP
\fB\fIGMSH \fP\fP
.TP
\fB\fIVTK \fP\fP
.TP
\fB\fIDIVA \fP\fP
.TP
\fB\fITETGEN \fP\fP
.TP
\fB\fIUCD \fP\fP
.TP
\fB\fILIBMESH \fP\fP
.TP
\fB\fIINVALID_IO_PACKAGE \fP\fP
.PP
Definition at line 34 of file enum_io_package\&.h\&.
.PP
.nf
35   {
36     TECPLOT,
37     GMV,
38     GMSH,
39     VTK,
40     DIVA,
41     TETGEN,
42     UCD,
43     LIBMESH,
44     INVALID_IO_PACKAGE
45   };
.fi
.SS "enum \fBlibMesh::LinearConvergenceReason\fP"
\fBLinear\fP solver convergence flags (taken from the PETSc flags) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICONVERGED_RTOL_NORMAL \fP\fP
.TP
\fB\fICONVERGED_ATOL_NORMAL \fP\fP
.TP
\fB\fICONVERGED_RTOL \fP\fP
.TP
\fB\fICONVERGED_ATOL \fP\fP
.TP
\fB\fICONVERGED_ITS \fP\fP
.TP
\fB\fICONVERGED_CG_NEG_CURVE \fP\fP
.TP
\fB\fICONVERGED_CG_CONSTRAINED \fP\fP
.TP
\fB\fICONVERGED_STEP_LENGTH \fP\fP
.TP
\fB\fICONVERGED_HAPPY_BREAKDOWN \fP\fP
.TP
\fB\fIDIVERGED_NULL \fP\fP
.TP
\fB\fIDIVERGED_ITS \fP\fP
.TP
\fB\fIDIVERGED_DTOL \fP\fP
.TP
\fB\fIDIVERGED_BREAKDOWN \fP\fP
.TP
\fB\fIDIVERGED_BREAKDOWN_BICG \fP\fP
.TP
\fB\fIDIVERGED_NONSYMMETRIC \fP\fP
.TP
\fB\fIDIVERGED_INDEFINITE_PC \fP\fP
.TP
\fB\fIDIVERGED_NAN \fP\fP
.TP
\fB\fIDIVERGED_INDEFINITE_MAT \fP\fP
.TP
\fB\fICONVERGED_ITERATING \fP\fP
.TP
\fB\fIUNKNOWN_FLAG \fP\fP
.PP
Definition at line 30 of file enum_convergence_flags\&.h\&.
.PP
.nf
30                              {
31   /* converged */
32   CONVERGED_RTOL_NORMAL        =  1,
33   CONVERGED_ATOL_NORMAL        =  9,
34   CONVERGED_RTOL               =  2,
35   CONVERGED_ATOL               =  3,
36   CONVERGED_ITS                =  4,
37   CONVERGED_CG_NEG_CURVE       =  5,
38   CONVERGED_CG_CONSTRAINED     =  6,
39   CONVERGED_STEP_LENGTH        =  7,
40   CONVERGED_HAPPY_BREAKDOWN    =  8,
41   /* diverged */
42   DIVERGED_NULL                = -2,
43   DIVERGED_ITS                 = -3,
44   DIVERGED_DTOL                = -4,
45   DIVERGED_BREAKDOWN           = -5,
46   DIVERGED_BREAKDOWN_BICG      = -6,
47   DIVERGED_NONSYMMETRIC        = -7,
48   DIVERGED_INDEFINITE_PC       = -8,
49   DIVERGED_NAN                 = -9,
50   DIVERGED_INDEFINITE_MAT      = -10,
51 
52   CONVERGED_ITERATING          =  0,
53 
54   UNKNOWN_FLAG                 = -128};
.fi
.SS "enum \fBlibMesh::Order\fP"
defines an \fCenum\fP for polynomial orders\&. Fixing each label to a specific int, since \fC\fBInfFE\fP\fP and p refinement may cast between them 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICONSTANT \fP\fP
.TP
\fB\fIFIRST \fP\fP
.TP
\fB\fISECOND \fP\fP
.TP
\fB\fITHIRD \fP\fP
.TP
\fB\fIFOURTH \fP\fP
.TP
\fB\fIFIFTH \fP\fP
.TP
\fB\fISIXTH \fP\fP
.TP
\fB\fISEVENTH \fP\fP
.TP
\fB\fIEIGHTH \fP\fP
.TP
\fB\fININTH \fP\fP
.TP
\fB\fITENTH \fP\fP
.TP
\fB\fIELEVENTH \fP\fP
.TP
\fB\fITWELFTH \fP\fP
.TP
\fB\fITHIRTEENTH \fP\fP
.TP
\fB\fIFOURTEENTH \fP\fP
.TP
\fB\fIFIFTEENTH \fP\fP
.TP
\fB\fISIXTEENTH \fP\fP
.TP
\fB\fISEVENTEENTH \fP\fP
.TP
\fB\fIEIGHTTEENTH \fP\fP
.TP
\fB\fININTEENTH \fP\fP
.TP
\fB\fITWENTIETH \fP\fP
.TP
\fB\fITWENTYFIRST \fP\fP
.TP
\fB\fITWENTYSECOND \fP\fP
.TP
\fB\fITWENTYTHIRD \fP\fP
.TP
\fB\fITWENTYFOURTH \fP\fP
.TP
\fB\fITWENTYFIFTH \fP\fP
.TP
\fB\fITWENTYSIXTH \fP\fP
.TP
\fB\fITWENTYSEVENTH \fP\fP
.TP
\fB\fITWENTYEIGHTH \fP\fP
.TP
\fB\fITWENTYNINTH \fP\fP
.TP
\fB\fITHIRTIETH \fP\fP
.TP
\fB\fITHIRTYFIRST \fP\fP
.TP
\fB\fITHIRTYSECOND \fP\fP
.TP
\fB\fITHIRTYTHIRD \fP\fP
.TP
\fB\fITHIRTYFOURTH \fP\fP
.TP
\fB\fITHIRTYFIFTH \fP\fP
.TP
\fB\fITHIRTYSIXTH \fP\fP
.TP
\fB\fITHIRTYSEVENTH \fP\fP
.TP
\fB\fITHIRTYEIGHTH \fP\fP
.TP
\fB\fITHIRTYNINTH \fP\fP
.TP
\fB\fIFORTIETH \fP\fP
.TP
\fB\fIFORTYFIRST \fP\fP
.TP
\fB\fIFORTYSECOND \fP\fP
.TP
\fB\fIFORTYTHIRD \fP\fP
.TP
\fB\fIINVALID_ORDER \fP\fP
.PP
Definition at line 32 of file enum_order\&.h\&.
.PP
.nf
32            {CONSTANT     =  0,
33             FIRST        =  1,
34             SECOND       =  2,
35             THIRD        =  3,
36             FOURTH       =  4,
37             FIFTH        =  5,
38             SIXTH        =  6,
39             SEVENTH      =  7,
40             EIGHTH       =  8,
41             NINTH        =  9,
42             TENTH        = 10,
43 
44             ELEVENTH     = 11,
45             TWELFTH      = 12,
46             THIRTEENTH   = 13,
47             FOURTEENTH   = 14,
48             FIFTEENTH    = 15,
49             SIXTEENTH    = 16,
50             SEVENTEENTH  = 17,
51             EIGHTTEENTH  = 18,
52             NINTEENTH    = 19,
53             TWENTIETH    = 20,
54 
55             TWENTYFIRST   = 21,
56             TWENTYSECOND  = 22,
57             TWENTYTHIRD   = 23,
58             TWENTYFOURTH  = 24,
59             TWENTYFIFTH   = 25,
60             TWENTYSIXTH   = 26,
61             TWENTYSEVENTH = 27,
62             TWENTYEIGHTH  = 28,
63             TWENTYNINTH   = 29,
64             THIRTIETH     = 30,
65 
66             THIRTYFIRST   = 31,
67             THIRTYSECOND  = 32,
68             THIRTYTHIRD   = 33,
69             THIRTYFOURTH  = 34,
70             THIRTYFIFTH   = 35,
71             THIRTYSIXTH   = 36,
72             THIRTYSEVENTH = 37,
73             THIRTYEIGHTH  = 38,
74             THIRTYNINTH   = 39,
75             FORTIETH     = 40,
76 
77             FORTYFIRST   = 41,
78             FORTYSECOND  = 42,
79             FORTYTHIRD   = 43,
80 
81             INVALID_ORDER};
.fi
.SS "enum \fBlibMesh::ParallelType\fP"
Defines an \fCenum\fP for parallel data structure types 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIAUTOMATIC \fP\fP
.TP
\fB\fISERIAL \fP\fP
.TP
\fB\fIPARALLEL \fP\fP
.TP
\fB\fIGHOSTED \fP\fP
.TP
\fB\fIINVALID_PARALLELIZATION \fP\fP
.PP
Definition at line 30 of file enum_parallel_type\&.h\&.
.PP
.nf
30                   {AUTOMATIC=0,
31                    SERIAL,
32                    PARALLEL,
33                    GHOSTED,
34 
35                    INVALID_PARALLELIZATION};
.fi
.SS "enum \fBlibMesh::PointLocatorType\fP"
defines an \fCenum\fP for the types of point locators (given a point with global coordinates, locate the corresponding element in space) available in \fBlibMesh\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fITREE \fP\fP
.TP
\fB\fILIST \fP\fP
.TP
\fB\fIINVALID_LOCATOR \fP\fP
.PP
Definition at line 32 of file enum_point_locator_type\&.h\&.
.PP
.nf
32                       {TREE = 0,
33                        LIST,
34                        INVALID_LOCATOR};
.fi
.SS "enum \fBlibMesh::PositionOfSpectrum\fP"
Defines an \fCenum\fP for the position of the spectrum, i\&.e\&. the eigenvalues to be computed\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILARGEST_MAGNITUDE \fP\fP
.TP
\fB\fISMALLEST_MAGNITUDE \fP\fP
.TP
\fB\fILARGEST_REAL \fP\fP
.TP
\fB\fISMALLEST_REAL \fP\fP
.TP
\fB\fILARGEST_IMAGINARY \fP\fP
.TP
\fB\fISMALLEST_IMAGINARY \fP\fP
.TP
\fB\fIINVALID_Postion_of_Spectrum \fP\fP
.PP
Definition at line 63 of file enum_eigen_solver_type\&.h\&.
.PP
.nf
63                         {LARGEST_MAGNITUDE=0,
64                          SMALLEST_MAGNITUDE,
65                          LARGEST_REAL,
66                          SMALLEST_REAL,
67                          LARGEST_IMAGINARY,
68                          SMALLEST_IMAGINARY,
69 
70                          INVALID_Postion_of_Spectrum};
.fi
.SS "enum \fBlibMesh::PreconditionerType\fP"
Defines an \fCenum\fP for preconditioner types 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIIDENTITY_PRECOND \fP\fP
.TP
\fB\fIJACOBI_PRECOND \fP\fP
.TP
\fB\fIBLOCK_JACOBI_PRECOND \fP\fP
.TP
\fB\fISOR_PRECOND \fP\fP
.TP
\fB\fISSOR_PRECOND \fP\fP
.TP
\fB\fIEISENSTAT_PRECOND \fP\fP
.TP
\fB\fIASM_PRECOND \fP\fP
.TP
\fB\fICHOLESKY_PRECOND \fP\fP
.TP
\fB\fIICC_PRECOND \fP\fP
.TP
\fB\fIILU_PRECOND \fP\fP
.TP
\fB\fILU_PRECOND \fP\fP
.TP
\fB\fIUSER_PRECOND \fP\fP
.TP
\fB\fISHELL_PRECOND \fP\fP
.TP
\fB\fIAMG_PRECOND \fP\fP
.TP
\fB\fIINVALID_PRECONDITIONER \fP\fP
.PP
Definition at line 30 of file enum_preconditioner_type\&.h\&.
.PP
.nf
30                         {IDENTITY_PRECOND =0,
31                          JACOBI_PRECOND,
32                          BLOCK_JACOBI_PRECOND,
33                          SOR_PRECOND,
34                          SSOR_PRECOND,
35                          EISENSTAT_PRECOND,
36                          ASM_PRECOND,
37                          CHOLESKY_PRECOND,
38                          ICC_PRECOND,
39                          ILU_PRECOND,
40                          LU_PRECOND,
41                          USER_PRECOND,
42                          SHELL_PRECOND,
43                          AMG_PRECOND,
44 
45                          INVALID_PRECONDITIONER};
.fi
.SS "enum \fBlibMesh::QuadratureType\fP"
Defines an \fCenum\fP for currently available quadrature rules\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIQGAUSS \fP\fP
.TP
\fB\fIQJACOBI_1_0 \fP\fP
.TP
\fB\fIQJACOBI_2_0 \fP\fP
.TP
\fB\fIQSIMPSON \fP\fP
.TP
\fB\fIQTRAP \fP\fP
.TP
\fB\fIQGRID \fP\fP
.TP
\fB\fIQGRUNDMANN_MOLLER \fP\fP
.TP
\fB\fIQMONOMIAL \fP\fP
.TP
\fB\fIQCONICAL \fP\fP
.TP
\fB\fIQCLOUGH \fP\fP
.TP
\fB\fIINVALID_Q_RULE \fP\fP
.PP
Definition at line 30 of file enum_quadrature_type\&.h\&.
.PP
.nf
30                     {QGAUSS            = 0,
31 
32                      QJACOBI_1_0       = 1,
33                      QJACOBI_2_0       = 2,
34 
35                      QSIMPSON          = 3,
36                      QTRAP             = 4,
37                      QGRID             = 5,
38                      QGRUNDMANN_MOLLER = 6,
39                      QMONOMIAL         = 7,
40                      QCONICAL          = 8,
41 
42                      QCLOUGH           = 21,
43 
44                      INVALID_Q_RULE    = 127};
.fi
.SS "enum \fBlibMesh::SolverPackage\fP"
Defines an \fCenum\fP for various linear solver packages\&. This allows for run-time switching between solver packages 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPETSC_SOLVERS \fP\fP
.TP
\fB\fISLEPC_SOLVERS \fP\fP
.PP
Definition at line 32 of file enum_solver_package\&.h\&.
.PP
.nf
33   {
34     PETSC_SOLVERS=0,
35     TRILINOS_SOLVERS,
36     LASPACK_SOLVERS,
37     SLEPC_SOLVERS,
38     EIGEN_SOLVERS,
39 
40     INVALID_SOLVER_PACKAGE
41   };
.fi
.SS "enum \fBlibMesh::SolverType\fP"
Defines an \fCenum\fP for iterative solver types 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICG \fP\fP
.TP
\fB\fICGN \fP\fP
.TP
\fB\fICGS \fP\fP
.TP
\fB\fICR \fP\fP
.TP
\fB\fIQMR \fP\fP
.TP
\fB\fITCQMR \fP\fP
.TP
\fB\fITFQMR \fP\fP
.TP
\fB\fIBICG \fP\fP
.TP
\fB\fIBICGSTAB \fP\fP
.TP
\fB\fIMINRES \fP\fP
.TP
\fB\fIGMRES \fP\fP
.TP
\fB\fILSQR \fP\fP
.TP
\fB\fIJACOBI \fP\fP
.TP
\fB\fISOR_FORWARD \fP\fP
.TP
\fB\fISOR_BACKWARD \fP\fP
.TP
\fB\fISSOR \fP\fP
.TP
\fB\fIRICHARDSON \fP\fP
.TP
\fB\fICHEBYSHEV \fP\fP
.TP
\fB\fIINVALID_SOLVER \fP\fP
.PP
Definition at line 30 of file enum_solver_type\&.h\&.
.PP
.nf
30                 {CG=0,
31                  CGN,
32                  CGS,
33                  CR,
34                  QMR,
35                  TCQMR,
36                  TFQMR,
37                  BICG,
38                  BICGSTAB,
39                  MINRES,
40                  GMRES,
41                  LSQR,
42                  JACOBI,
43                  SOR_FORWARD,
44                  SOR_BACKWARD,
45                  SSOR,
46                  RICHARDSON,
47                  CHEBYSHEV,
48 
49                  INVALID_SOLVER};
.fi
.SS "enum \fBlibMesh::SubsetSolveMode\fP"
defines an \fCenum\fP for the question what happens to the dofs outside the given subset when a system is solved on a subset\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISUBSET_ZERO \fP\fP
Set dofs outside the subset to zero\&. 
.TP
\fB\fISUBSET_COPY_RHS \fP\fP
Set dofs outside the subset to the value of the corresponding dofs of the right hand side\&. 
.TP
\fB\fISUBSET_DONT_TOUCH \fP\fP
Leaves dofs outside the subset unchanged\&. This is fastest, but also most confusing because it abandons the property that the solution vector is (theoretically) independent of the initial guess\&. 
.PP
Definition at line 32 of file enum_subset_solve_mode\&.h\&.
.PP
.nf
32                      {
33   SUBSET_ZERO = 0, 
34   SUBSET_COPY_RHS, 
35   SUBSET_DONT_TOUCH 
36 };
.fi
.SS "enum \fBlibMesh::XdrMODE\fP"
Defines an \fCenum\fP for read/write mode in \fBXdr\fP format\&. \fCREAD\fP, \fCWRITE\fP perform reading and writing in ASCII format, and \fCDECODE\fP, \fCENCODE\fP do the same in binary format\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
.TP
\fB\fIENCODE \fP\fP
.TP
\fB\fIDECODE \fP\fP
.TP
\fB\fIWRITE \fP\fP
.TP
\fB\fIREAD \fP\fP
.PP
Definition at line 32 of file enum_xdr_mode\&.h\&.
.PP
.nf
33   {
34     UNKNOWN = -1, ENCODE=0, DECODE, WRITE, READ
35   };
.fi
.SH "Function Documentation"
.PP 
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_diff_solver_jacobian (SNES, Vecx, Mat *libmesh_dbg_varj, Mat *pc, MatStructure *msflag, void *ctx)"

.PP
Referenced by libMesh::PetscDiffSolver::solve()\&.
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_diff_solver_monitor (SNESsnes, \fBPetscInt\fPits, PetscRealfnorm, void *ctx)"

.PP
Definition at line 51 of file petsc_diff_solver\&.C\&.
.PP
References CHKERRABORT(), libMesh::PetscVector< T >::close(), libMesh::ParallelObject::comm(), libMesh::Parallel::Communicator::get(), ierr, libMesh::DiffSolver::linear_solution_monitor, out, solver, and libMesh::DiffSolver::verbose\&.
.PP
Referenced by libMesh::PetscDiffSolver::init()\&.
.PP
.nf
53   {
54     PetscDiffSolver& solver =
55       *(static_cast<PetscDiffSolver*> (ctx));
56 
57     if (solver\&.verbose)
58       libMesh::out << "  PetscDiffSolver step " << its
59                    << ", |residual|_2 = " << fnorm << std::endl;
60     if (solver\&.linear_solution_monitor\&.get()) {
61       int ierr = 0;
62 
63       Vec petsc_delta_u;
64       ierr = SNESGetSolutionUpdate(snes, &petsc_delta_u);
65       CHKERRABORT(solver\&.comm()\&.get(), ierr);
66       PetscVector<Number> delta_u(petsc_delta_u, solver\&.comm());
67       delta_u\&.close();
68 
69       Vec petsc_u;
70       ierr = SNESGetSolution(snes, &petsc_u);
71       CHKERRABORT(solver\&.comm()\&.get(), ierr);
72       PetscVector<Number> u(petsc_u, solver\&.comm());
73       u\&.close();
74 
75       Vec petsc_res;
76       ierr = SNESGetFunction(snes, &petsc_res, NULL, NULL);
77       CHKERRABORT(solver\&.comm()\&.get(), ierr);
78       PetscVector<Number> res(petsc_res, solver\&.comm());
79       res\&.close();
80 
81       (*solver\&.linear_solution_monitor)(
82                                         delta_u, delta_u\&.l2_norm(),
83                                         u, u\&.l2_norm(),
84                                         res, res\&.l2_norm(), its);
85     }
86     return 0;
87   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_diff_solver_residual (SNES, Vecx, Vecr, void *ctx)"

.PP
Definition at line 92 of file petsc_diff_solver\&.C\&.
.PP
References libMesh::ImplicitSystem::assembly(), libMesh::ParallelObject::comm(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::System::get_dof_map(), libmesh_assert(), out, libMesh::ExplicitSystem::rhs, libMesh::System::solution, solver, sys, libMesh::DiffSolver::system(), libMesh::System::update(), libMesh::DiffSolver::verbose, X_input(), and X_system\&.
.PP
Referenced by libMesh::PetscDiffSolver::solve()\&.
.PP
.nf
93   {
94     libmesh_assert(x);
95     libmesh_assert(r);
96     libmesh_assert(ctx);
97 
98     PetscDiffSolver& solver =
99       *(static_cast<PetscDiffSolver*> (ctx));
100     ImplicitSystem &sys = solver\&.system();
101 
102     if (solver\&.verbose)
103       libMesh::out << "Assembling the residual" << std::endl;
104 
105     PetscVector<Number>& X_system =
106       *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.solution\&.get());
107     PetscVector<Number>& R_system =
108       *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.rhs);
109     PetscVector<Number> X_input(x, sys\&.comm()), R_input(r, sys\&.comm());
110 
111     // DiffSystem assembles from the solution and into the rhs, so swap
112     // those with our input vectors before assembling\&.  They'll probably
113     // already be references to the same vectors, but PETSc might do
114     // something tricky\&.
115     X_input\&.swap(X_system);
116     R_input\&.swap(R_system);
117 
118     // We may need to correct a non-conforming solution
119     sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
120 
121     // We may need to localize a parallel solution
122     sys\&.update();
123 
124     // Do DiffSystem assembly
125     sys\&.assembly(true, false);
126     R_system\&.close();
127 
128     // Swap back
129     X_input\&.swap(X_system);
130     R_input\&.swap(R_system);
131 
132     // No errors, we hope
133     return 0;
134   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_preconditioner_apply (void *ctx, Vecx, Vecy)"
This function is called by PETSc to acctually apply the preconditioner\&. ctx will hold the \fBPreconditioner\fP\&. 
.PP
Definition at line 66 of file petsc_linear_solver\&.C\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::init(), and libMesh::PetscLinearSolver< T >::init()\&.
.PP
.nf
67   {
68     Preconditioner<Number> * preconditioner = static_cast<Preconditioner<Number>*>(ctx);
69 
70     PetscVector<Number> x_vec(x, preconditioner->comm());
71     PetscVector<Number> y_vec(y, preconditioner->comm());
72 
73     preconditioner->apply(x_vec,y_vec);
74 
75     return 0;
76   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_preconditioner_apply (PCpc, Vecx, Vecy)"

.PP
Definition at line 95 of file petsc_linear_solver\&.C\&.
.PP
References CHKERRQ(), and ierr\&.
.PP
.nf
96   {
97     void *ctx;
98     PetscErrorCode ierr = PCShellGetContext(pc,&ctx);CHKERRQ(ierr);
99     Preconditioner<Number> * preconditioner = static_cast<Preconditioner<Number>*>(ctx);
100 
101     PetscVector<Number> x_vec(x, preconditioner->comm());
102     PetscVector<Number> y_vec(y, preconditioner->comm());
103 
104     preconditioner->apply(x_vec,y_vec);
105 
106     return 0;
107   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_preconditioner_setup (void *ctx)"
This function is called by PETSc to initialize the preconditioner\&. ctx will hold the \fBPreconditioner\fP\&. 
.PP
Definition at line 50 of file petsc_linear_solver\&.C\&.
.PP
References err\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::init(), and libMesh::PetscLinearSolver< T >::init()\&.
.PP
.nf
51   {
52     Preconditioner<Number> * preconditioner = static_cast<Preconditioner<Number>*>(ctx);
53 
54     if(!preconditioner->initialized())
55       {
56         err<<"Preconditioner not initialized!  Make sure you call init() before solve!"<<std::endl;
57         libmesh_error();
58       }
59 
60     preconditioner->setup();
61 
62     return 0;
63   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_preconditioner_setup (PCpc)"

.PP
Definition at line 78 of file petsc_linear_solver\&.C\&.
.PP
References CHKERRQ(), err, and ierr\&.
.PP
.nf
79   {
80     void *ctx;
81     PetscErrorCode ierr = PCShellGetContext(pc,&ctx);CHKERRQ(ierr);
82     Preconditioner<Number> * preconditioner = static_cast<Preconditioner<Number>*>(ctx);
83 
84     if(!preconditioner->initialized())
85       {
86         err<<"Preconditioner not initialized!  Make sure you call init() before solve!"<<std::endl;
87         libmesh_error();
88       }
89 
90     preconditioner->setup();
91 
92     return 0;
93   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_snes_jacobian (SNES, Vecx, Matjac, Matpc, void *ctx)"

.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_snes_jacobian (SNESsnes, Vecx, Mat *jac, Mat *pc, MatStructure *msflag, void *ctx)"

.PP
Referenced by libMesh::PetscNonlinearSolver< T >::solve()\&.
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_snes_monitor (SNES, \fBPetscInt\fPits, PetscRealfnorm, void *)"

.PP
Definition at line 58 of file petsc_nonlinear_solver\&.C\&.
.PP
References out\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::init()\&.
.PP
.nf
59   {
60     //PetscErrorCode ierr=0;
61 
62     //if (its > 0)
63     libMesh::out << "  NL step "
64                  << std::setw(2) << its
65                  << std::scientific
66                  << ", |residual|_2 = " << fnorm
67                  << std::endl;
68 
69     //return ierr;
70     return 0;
71   }
.fi
.SS "\fBPetscErrorCode\fP libMesh::__libmesh_petsc_snes_residual (SNESsnes, Vecx, Vecr, void *ctx)"

.PP
Definition at line 78 of file petsc_nonlinear_solver\&.C\&.
.PP
References libMesh::PetscNonlinearSolver< T >::_current_nonlinear_iteration_number, libMesh::PetscNonlinearSolver< T >::_zero_out_residual, CHKERRABORT(), libMesh::ParallelObject::comm(), libMesh::System::current_local_solution, libMesh::DofMap::enforce_constraints_exactly(), err, libMesh::Parallel::Communicator::get(), libMesh::System::get_dof_map(), ierr, libmesh_assert(), libMesh::NonlinearSolver< T >::matvec, libMesh::NonlinearImplicitSystem::ComputeResidual::residual(), libMesh::NonlinearSolver< T >::residual, libMesh::NonlinearImplicitSystem::ComputeResidualandJacobian::residual_and_jacobian(), libMesh::NonlinearSolver< T >::residual_and_jacobian_object, libMesh::NonlinearSolver< T >::residual_object, libMesh::ExplicitSystem::rhs, libMesh::System::solution, solver, START_LOG(), STOP_LOG(), sys, libMesh::NonlinearSolver< T >::system(), libMesh::System::update(), X_global(), and X_sys\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::solve()\&.
.PP
.nf
79   {
80     START_LOG("residual()", "PetscNonlinearSolver");
81 
82     PetscErrorCode ierr=0;
83 
84     libmesh_assert(x);
85     libmesh_assert(r);
86     libmesh_assert(ctx);
87 
88     PetscNonlinearSolver<Number>* solver =
89       static_cast<PetscNonlinearSolver<Number>*> (ctx);
90 
91     // Get the current iteration number from the snes object,
92     // store it in the PetscNonlinearSolver object for possible use
93     // by the user's residual function\&.
94     {
95       PetscInt n_iterations = 0;
96       ierr = SNESGetIterationNumber(snes, &n_iterations);
97       CHKERRABORT(solver->comm()\&.get(),ierr);
98       solver->_current_nonlinear_iteration_number = static_cast<unsigned>(n_iterations);
99     }
100 
101     NonlinearImplicitSystem &sys = solver->system();
102 
103     PetscVector<Number>& X_sys = *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.solution\&.get());
104     PetscVector<Number>& R_sys = *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.rhs);
105     PetscVector<Number> X_global(x, sys\&.comm()), R(r, sys\&.comm());
106 
107     // Use the systems update() to get a good local version of the parallel solution
108     X_global\&.swap(X_sys);
109     R\&.swap(R_sys);
110 
111     sys\&.get_dof_map()\&.enforce_constraints_exactly(sys);
112 
113     sys\&.update();
114 
115     //Swap back
116     X_global\&.swap(X_sys);
117     R\&.swap(R_sys);
118 
119     if (solver->_zero_out_residual)
120       R\&.zero();
121 
122     //-----------------------------------------------------------------------------
123     // if the user has provided both function pointers and objects only the pointer
124     // will be used, so catch that as an error
125     if (solver->residual && solver->residual_object)
126       {
127         libMesh::err << "ERROR: cannot specifiy both a function and object to compute the Residual!" << std::endl;
128         libmesh_error();
129       }
130 
131     if (solver->matvec && solver->residual_and_jacobian_object)
132       {
133         libMesh::err << "ERROR: cannot specifiy both a function and object to compute the combined Residual & Jacobian!" << std::endl;
134         libmesh_error();
135       }
136     //-----------------------------------------------------------------------------
137 
138     if      (solver->residual != NULL)                     solver->residual                                            (*sys\&.current_local_solution\&.get(), R, sys);
139     else if (solver->residual_object != NULL)              solver->residual_object->residual                           (*sys\&.current_local_solution\&.get(), R, sys);
140     else if (solver->matvec   != NULL)                     solver->matvec                                              (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
141     else if (solver->residual_and_jacobian_object != NULL) solver->residual_and_jacobian_object->residual_and_jacobian (*sys\&.current_local_solution\&.get(), &R, NULL, sys);
142     else libmesh_error();
143 
144     R\&.close();
145     X_global\&.close();
146 
147     STOP_LOG("residual()", "PetscNonlinearSolver");
148 
149     return ierr;
150   }
.fi
.SS "\fBJac\fP attach_dof_map (sys\&.get_dof_map())"

.SS "libMesh::CHKERRABORT (solver->comm)\&.get(, \fBierr\fP)"

.SS "libMesh::CHKERRABORT (comm, \fBierr\fP)"

.PP
Referenced by __libmesh_petsc_diff_solver_monitor(), __libmesh_petsc_snes_residual(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), if(), EXTERN_C_FOR_PETSC_END::indices_to_fieldsplit(), libMesh::PetscVector< T >::init(), PetscDMRegister(), and libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type()\&.
.SS "bool libMesh::closed ()"
Checks that the library has been closed\&. This should always return false when called from a library object\&. It is useful to \fClibmesh_assert\fP(!libMesh\fBclosed()\fP) in library object destructors\&. 
.PP
Definition at line 256 of file libmesh\&.C\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized\&.
.PP
Referenced by libMesh::LaspackVector< T >::l1_norm(), libMesh::EigenSparseVector< T >::l1_norm(), libMesh::EpetraVector< T >::l1_norm(), libMesh::PetscVector< T >::l1_norm(), libMesh::PetscMatrix< T >::l1_norm(), libMesh::LaspackVector< T >::l2_norm(), libMesh::EigenSparseVector< T >::l2_norm(), libMesh::EpetraVector< T >::l2_norm(), libMesh::PetscVector< T >::l2_norm(), libMesh::LaspackVector< T >::linfty_norm(), libMesh::EigenSparseVector< T >::linfty_norm(), libMesh::EpetraVector< T >::linfty_norm(), libMesh::PetscVector< T >::linfty_norm(), libMesh::PetscMatrix< T >::linfty_norm(), libMesh::PetscMatrix< T >::operator()(), libMesh::DistributedVector< T >::operator+=(), libMesh::LaspackVector< T >::operator+=(), libMesh::EigenSparseVector< T >::operator+=(), libMesh::EpetraVector< T >::operator+=(), libMesh::PetscVector< T >::operator+=(), libMesh::DistributedVector< T >::operator-=(), libMesh::LaspackVector< T >::operator-=(), libMesh::EigenSparseVector< T >::operator-=(), libMesh::EpetraVector< T >::operator-=(), libMesh::PetscVector< T >::operator-=(), libMesh::EigenSparseVector< T >::operator/=(), libMesh::EpetraVector< T >::operator/=(), libMesh::LaspackVector< T >::operator=(), libMesh::EigenSparseVector< T >::operator=(), libMesh::PetscVector< T >::operator=(), libMesh::PetscVector< T >::print_matlab(), libMesh::LaspackVector< T >::sum(), libMesh::EigenSparseVector< T >::sum(), libMesh::EpetraVector< T >::sum(), libMesh::PetscVector< T >::sum(), libMesh::LaspackVector< T >::zero(), libMesh::EigenSparseVector< T >::zero(), libMesh::EpetraVector< T >::zero(), libMesh::PetscVector< T >::zero(), libMesh::MeshBase::~MeshBase(), libMesh::System::~System(), and libMesh::UnstructuredMesh::~UnstructuredMesh()\&.
.PP
.nf
257 {
258   return !libMeshPrivateData::_is_initialized;
259 }
.fi
.SS "template<typename T > T libMesh::command_line_next (const std::string &, T)"
Use GetPot's search()/next() functions to get following arguments from the command line\&. 
.PP
Definition at line 799 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::command_line, and libmesh_assert()\&.
.PP
Referenced by libMesh::DofMap::use_coupled_neighbor_dofs()\&.
.PP
.nf
800 {
801   // Make sure the command line parser is ready for use
802   libmesh_assert(command_line\&.get());
803 
804   if (command_line->search(1, name\&.c_str()))
805     value = command_line->next(value);
806 
807   return value;
808 }
.fi
.SS "template double \fBlibMesh::command_line_next\fP< double > (const std::string &, double)"

.SS "template float \fBlibMesh::command_line_next\fP< float > (const std::string &, float)"

.SS "template int \fBlibMesh::command_line_next\fP< int > (const std::string &, int)"

.SS "template long double \fBlibMesh::command_line_next\fP< long double > (const std::string &, longdouble)"

.SS "template std::string \fBlibMesh::command_line_next\fP< std::string > (const std::string &, std::string)"

.SS "template<typename T > T libMesh::command_line_value (const std::string &, T)"

.PP
\fBReturns:\fP
.RS 4
the value associated with name on the command line if it is specified, otherwise return the default, provided value\&. A second template function is provided to support recognizing multiple variations of a given option 
.RE
.PP

.PP
Definition at line 767 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::command_line, and libmesh_assert()\&.
.PP
Referenced by petsc_auto_fieldsplit()\&.
.PP
.nf
768 {
769   // Make sure the command line parser is ready for use
770   libmesh_assert(command_line\&.get());
771 
772   // only if the variable exists in the file
773   if (command_line->have_variable(name\&.c_str()))
774     value = (*command_line)(name\&.c_str(), value);
775 
776   return value;
777 }
.fi
.SS "template<typename T > T libMesh::command_line_value (const std::vector< std::string > &name, Tvalue)"

.PP
Definition at line 780 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::command_line, and libmesh_assert()\&.
.PP
.nf
781 {
782   // Make sure the command line parser is ready for use
783   libmesh_assert(command_line\&.get());
784 
785   // Check for multiple options (return the first that matches)
786   for (std::vector<std::string>::const_iterator i=name\&.begin(); i != name\&.end(); ++i)
787     if (command_line->have_variable(i->c_str()))
788       {
789         value = (*command_line)(i->c_str(), value);
790         break;
791       }
792 
793   return value;
794 }
.fi
.SS "template double \fBlibMesh::command_line_value\fP< double > (const std::string &, double)"

.SS "template float \fBlibMesh::command_line_value\fP< float > (const std::string &, float)"

.SS "template int \fBlibMesh::command_line_value\fP< int > (const std::string &, int)"

.SS "template long double \fBlibMesh::command_line_value\fP< long double > (const std::string &, longdouble)"

.SS "template std::string \fBlibMesh::command_line_value\fP< std::string > (const std::string &, std::string)"

.SS "template<typename T > void libMesh::command_line_vector (const std::string &, std::vector< T > &)"

.PP
\fBReturns:\fP
.RS 4
the array of values associated with name on the command line if it is specified, otherwise return the default, provided array\&. 
.RE
.PP

.PP
Definition at line 813 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::command_line, and libmesh_assert()\&.
.PP
.nf
814 {
815   // Make sure the command line parser is ready for use
816   libmesh_assert(command_line\&.get());
817 
818   // only if the variable exists on the command line
819   if (command_line->have_variable(name\&.c_str()))
820     {
821       unsigned size = command_line->vector_variable_size(name\&.c_str());
822       vec\&.resize(size);
823 
824       for (unsigned i=0; i<size; ++i)
825         vec[i] = (*command_line)(name\&.c_str(), vec[i], i);
826     }
827 }
.fi
.SS "template void \fBlibMesh::command_line_vector\fP< double > (const std::string &, std::vector< double > &)"

.SS "template void \fBlibMesh::command_line_vector\fP< float > (const std::string &, std::vector< float > &)"

.SS "template void \fBlibMesh::command_line_vector\fP< int > (const std::string &, std::vector< int > &)"

.SS "template void \fBlibMesh::command_line_vector\fP< long double > (const std::string &, std::vector< long double > &)"

.SS "\fBDiffSolver::SolveResult\fP libMesh::convert_solve_result (SNESConvergedReasonr)"

.PP
Definition at line 297 of file petsc_diff_solver\&.C\&.
.PP
Referenced by libMesh::PetscDiffSolver::solve()\&.
.PP
.nf
298 {
299   switch (r)
300     {
301     case SNES_CONVERGED_FNORM_ABS:
302       return DiffSolver::CONVERGED_ABSOLUTE_RESIDUAL;
303     case SNES_CONVERGED_FNORM_RELATIVE:
304       return DiffSolver::CONVERGED_RELATIVE_RESIDUAL;
305 #if PETSC_VERSION_LESS_THAN(3,2,1)
306     case SNES_CONVERGED_PNORM_RELATIVE:
307 #else
308     case SNES_CONVERGED_SNORM_RELATIVE:
309 #endif
310       return DiffSolver::CONVERGED_RELATIVE_STEP;
311 #if !PETSC_VERSION_LESS_THAN(2,3,3)
312     case SNES_CONVERGED_ITS:
313 #endif
314     case SNES_CONVERGED_TR_DELTA:
315       return DiffSolver::CONVERGED_NO_REASON;
316     case SNES_DIVERGED_FUNCTION_DOMAIN:
317     case SNES_DIVERGED_FUNCTION_COUNT:
318     case SNES_DIVERGED_FNORM_NAN:
319 #if !PETSC_VERSION_LESS_THAN(3,3,0)
320     case SNES_DIVERGED_INNER:
321 #endif
322 #if !PETSC_VERSION_LESS_THAN(2,3,2)
323     case SNES_DIVERGED_LINEAR_SOLVE:
324 #endif
325     case SNES_DIVERGED_LOCAL_MIN:
326       return DiffSolver::DIVERGED_NO_REASON;
327     case SNES_DIVERGED_MAX_IT:
328       return DiffSolver::DIVERGED_MAX_NONLINEAR_ITERATIONS;
329 #if PETSC_VERSION_LESS_THAN(3,2,0)
330     case SNES_DIVERGED_LS_FAILURE:
331 #else
332     case SNES_DIVERGED_LINE_SEARCH:
333 #endif
334       return DiffSolver::DIVERGED_BACKTRACKING_FAILURE;
335       // In PETSc, SNES_CONVERGED_ITERATING means
336       // the solve is still iterating, but by the
337       // time we get here, we must have either
338       // converged or diverged, so
339       // SNES_CONVERGED_ITERATING is invalid\&.
340     case SNES_CONVERGED_ITERATING:
341       return DiffSolver::INVALID_SOLVE_RESULT;
342     }
343   return DiffSolver::INVALID_SOLVE_RESULT;
344 }
.fi
.SS "\fBSolverPackage\fP libMesh::default_solver_package ()"

.PP
\fBReturns:\fP
.RS 4
the default solver interface to use\&. The value depends on which solver packages were available when the library was configured\&. The command-line is also checked, allowing the user to override the compiled default\&. For example, \fC--use-petsc\fP will force the use of PETSc solvers, and \fC--use-laspack\fP will force the use of LASPACK solvers\&. 
.RE
.PP

.PP
Definition at line 830 of file libmesh\&.C\&.
.PP
References libMesh::libMeshPrivateData::_solver_package, EIGEN_SOLVERS, initialized(), INVALID_SOLVER_PACKAGE, LASPACK_SOLVERS, libmesh_assert(), on_command_line(), PETSC_SOLVERS, and TRILINOS_SOLVERS\&.
.PP
.nf
831 {
832   libmesh_assert (libMesh::initialized());
833 
834   static bool called = false;
835 
836   // Check the command line\&.  Since the command line is
837   // unchanging it is sufficient to do this only once\&.
838   if (!called)
839     {
840       called = true;
841 
842 #ifdef LIBMESH_HAVE_PETSC
843       if (libMesh::on_command_line ("--use-petsc"))
844         libMeshPrivateData::_solver_package = PETSC_SOLVERS;
845 #endif
846 
847 #ifdef LIBMESH_HAVE_TRILINOS
848       if (libMesh::on_command_line ("--use-trilinos") ||
849           libMesh::on_command_line ("--disable-petsc"))
850         libMeshPrivateData::_solver_package = TRILINOS_SOLVERS;
851 #endif
852 
853 #ifdef LIBMESH_HAVE_EIGEN
854       if (libMesh::on_command_line ("--use-eigen"  ) ||
855 #if defined(LIBMESH_HAVE_MPI)
856           // If the user bypassed MPI, we disable PETSc and Trilinos
857           // too
858           libMesh::on_command_line ("--disable-mpi") ||
859 #endif
860           libMesh::on_command_line ("--disable-petsc"))
861         libMeshPrivateData::_solver_package = EIGEN_SOLVERS;
862 #endif
863 
864 #ifdef LIBMESH_HAVE_LASPACK
865       if (libMesh::on_command_line ("--use-laspack"  ) ||
866 #if defined(LIBMESH_HAVE_MPI)
867           // If the user bypassed MPI, we disable PETSc and Trilinos
868           // too
869           libMesh::on_command_line ("--disable-mpi") ||
870 #endif
871           libMesh::on_command_line ("--disable-petsc"))
872         libMeshPrivateData::_solver_package = LASPACK_SOLVERS;
873 #endif
874 
875       if (libMesh::on_command_line ("--disable-laspack") &&
876           libMesh::on_command_line ("--disable-trilinos") &&
877           libMesh::on_command_line ("--disable-eigen") &&
878           (
879 #if defined(LIBMESH_HAVE_MPI)
880            // If the user bypassed MPI, we disable PETSc too
881            libMesh::on_command_line ("--disable-mpi") ||
882 #endif
883            libMesh::on_command_line ("--disable-petsc")))
884         libMeshPrivateData::_solver_package = INVALID_SOLVER_PACKAGE;
885     }
886 
887 
888   return libMeshPrivateData::_solver_package;
889 }
.fi
.SS "std::string libMesh::demangle (const char *name)"

.PP
Definition at line 97 of file print_trace\&.C\&.
.PP
References libMesh::Quality::name()\&.
.PP
Referenced by libMesh::Parameters::get(), process_trace(), and libMesh::Parameters::Parameter< T >::type()\&.
.PP
.nf
98 {
99   int status = 0;
100   char *d = 0;
101   std::string ret = name;
102   try { if ( (d = abi::__cxa_demangle(name, 0, 0, &status)) ) ret = d; }
103   catch(\&.\&.\&.) {  }
104   std::free(d);
105   return ret;
106 }
.fi
.SS "void libMesh::enableFPE (boolon)"
Toggle floating point exceptions -- courtesy of Cody Permann & MOOSE team
.PP
Toggle hardware trap floating point exceptions 
.PP
Definition at line 712 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::libmesh_handleFPE()\&.
.PP
.nf
713 {
714 #if !defined(LIBMESH_HAVE_FEENABLEEXCEPT) && defined(LIBMESH_HAVE_XMMINTRIN_H) && !defined(__SUNPRO_CC)
715   static int flags = 0;
716 #endif
717 
718   if (on)
719     {
720       struct sigaction new_action, old_action;
721 
722 #ifdef LIBMESH_HAVE_FEENABLEEXCEPT
723       feenableexcept(FE_DIVBYZERO | FE_INVALID);
724 #elif  LIBMESH_HAVE_XMMINTRIN_H
725 #  ifndef __SUNPRO_CC
726       flags = _MM_GET_EXCEPTION_MASK();           // store the flags
727       _MM_SET_EXCEPTION_MASK(flags & ~_MM_MASK_INVALID);
728 #  endif
729 #endif
730 
731 
732       // Set up the structure to specify the new action\&.
733       new_action\&.sa_sigaction = libmesh_handleFPE;
734       sigemptyset (&new_action\&.sa_mask);
735       new_action\&.sa_flags = SA_SIGINFO;
736 
737       sigaction (SIGFPE, NULL, &old_action);
738       if (old_action\&.sa_handler != SIG_IGN)
739         sigaction (SIGFPE, &new_action, NULL);
740     }
741   else
742     {
743 #ifdef LIBMESH_HAVE_FEDISABLEEXCEPT
744       fedisableexcept(FE_DIVBYZERO | FE_INVALID);
745 #elif  LIBMESH_HAVE_XMMINTRIN_H
746 #  ifndef __SUNPRO_CC
747       _MM_SET_EXCEPTION_MASK(flags);
748 #  endif
749 #endif
750       signal(SIGFPE, 0);
751     }
752 }
.fi
.SS "libMesh::for ()"

.PP
Definition at line 241 of file exact_error_estimator\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::NumericVector< T >::build(), libMesh::FEGenericBase< T >::build(), libMesh::Elem::child(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::ParallelObject::comm(), libMesh::System::current_local_solution, libMesh::System::current_solution(), libMesh::FEType::default_quadrature_rule(), libMesh::DofMap::dof_indices(), ErrorVectorReal, libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::DofObject::id(), libMesh::Elem::n_children(), libMesh::System::name(), libMesh::Elem::parent(), SERIAL, libMesh::System::update_global_solution(), libMesh::System::variable_name(), libMesh::System::variable_number(), and libMesh::DofMap::variable_type()\&.
.PP
Referenced by libMesh::DofMap::get_local_constraints(), libMesh::DofMap::max_constraint_error(), and libMesh::DofMap::process_constraints()\&.
.PP
.nf
242     {
243       // Possibly skip this variable
244       if (error_norm\&.weight(var) == 0\&.0) continue;
245 
246       // The (string) name of this variable
247       const std::string& var_name = system\&.variable_name(var);
248 
249       // The type of finite element to use for this variable
250       const FEType& fe_type = dof_map\&.variable_type (var);
251 
252       AutoPtr<FEBase> fe (FEBase::build (dim, fe_type));
253 
254       // Build an appropriate Gaussian quadrature rule
255       AutoPtr<QBase> qrule =
256         fe_type\&.default_quadrature_rule (dim,
257                                          _extra_order);
258 
259       fe->attach_quadrature_rule (qrule\&.get());
260 
261       // Prepare a global solution and a MeshFunction of the fine system if we need one
262       AutoPtr<MeshFunction> fine_values;
263       AutoPtr<NumericVector<Number> > fine_soln = NumericVector<Number>::build(system\&.comm());
264       if (_equation_systems_fine)
265         {
266           const System& fine_system = _equation_systems_fine->get_system(system\&.name());
267 
268           std::vector<Number> global_soln;
269           // FIXME - we're assuming that the fine system solution gets
270           // used even when a different vector is used for the coarse
271           // system
272           fine_system\&.update_global_solution(global_soln);
273           fine_soln->init (global_soln\&.size(), true, SERIAL);
274           (*fine_soln) = global_soln;
275 
276           fine_values = AutoPtr<MeshFunction>
277             (new MeshFunction(*_equation_systems_fine,
278                               *fine_soln,
279                               fine_system\&.get_dof_map(),
280                               fine_system\&.variable_number(var_name)));
281           fine_values->init();
282         } else {
283         // Initialize functors if we're using them
284         for (unsigned int i=0; i != _exact_values\&.size(); ++i)
285           if (_exact_values[i])
286             _exact_values[i]->init();
287 
288         for (unsigned int i=0; i != _exact_derivs\&.size(); ++i)
289           if (_exact_derivs[i])
290             _exact_derivs[i]->init();
291 
292         for (unsigned int i=0; i != _exact_hessians\&.size(); ++i)
293           if (_exact_hessians[i])
294             _exact_hessians[i]->init();
295       }
296 
297       // Request the data we'll need to compute with
298       fe->get_JxW();
299       fe->get_phi();
300       fe->get_dphi();
301 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
302       fe->get_d2phi();
303 #endif
304       fe->get_xyz();
305 
306 #ifdef LIBMESH_ENABLE_AMR
307       // If we compute on parent elements, we'll want to do so only
308       // once on each, so we need to keep track of which we've done\&.
309       std::vector<bool> computed_var_on_parent;
310 
311       if (estimate_parent_error)
312         computed_var_on_parent\&.resize(error_per_cell\&.size(), false);
313 #endif
314 
315       // TODO: this ought to be threaded (and using subordinate
316       // MeshFunction objects in each thread rather than a single
317       // master)
318 
319       // Iterate over all the active elements in the mesh
320       // that live on this processor\&.
321       MeshBase::const_element_iterator
322         elem_it  = mesh\&.active_local_elements_begin();
323       const MeshBase::const_element_iterator
324         elem_end = mesh\&.active_local_elements_end();
325 
326       for (;elem_it != elem_end; ++elem_it)
327         {
328           // e is necessarily an active element on the local processor
329           const Elem* elem = *elem_it;
330           const dof_id_type e_id = elem->id();
331 
332 #ifdef LIBMESH_ENABLE_AMR
333           // See if the parent of element e has been examined yet;
334           // if not, we may want to compute the estimator on it
335           const Elem* parent = elem->parent();
336 
337           // We only can compute and only need to compute on
338           // parents with all active children
339           bool compute_on_parent = true;
340           if (!parent || !estimate_parent_error)
341             compute_on_parent = false;
342           else
343             for (unsigned int c=0; c != parent->n_children(); ++c)
344               if (!parent->child(c)->active())
345                 compute_on_parent = false;
346 
347           if (compute_on_parent &&
348               !computed_var_on_parent[parent->id()])
349             {
350               computed_var_on_parent[parent->id()] = true;
351 
352               // Compute a projection onto the parent
353               DenseVector<Number> Uparent;
354               FEBase::coarsened_dof_values(*(system\&.current_local_solution),
355                                            dof_map, parent, Uparent,
356                                            var, false);
357 
358               error_per_cell[parent->id()] +=
359                 static_cast<ErrorVectorReal>
360                 (find_squared_element_error(system, var_name,
361                                             parent, Uparent,
362                                             fe\&.get(),
363                                             fine_values\&.get()));
364             }
365 #endif
366 
367           // Get the local to global degree of freedom maps
368           std::vector<dof_id_type> dof_indices;
369           dof_map\&.dof_indices (elem, dof_indices, var);
370           const unsigned int n_dofs =
371             libmesh_cast_int<unsigned int>(dof_indices\&.size());
372           DenseVector<Number> Uelem(n_dofs);
373           for (unsigned int i=0; i != n_dofs; ++i)
374             Uelem(i) = system\&.current_solution(dof_indices[i]);
375 
376           error_per_cell[e_id] +=
377             static_cast<ErrorVectorReal>
378             (find_squared_element_error(system, var_name, elem,
379                                         Uelem, fe\&.get(),
380                                         fine_values\&.get()));
381 
382         } // End loop over active local elements
383     } // End loop over variables
.fi
.SS "\fBsys\fP libMesh::get_dof_map ()"

.PP
Definition at line 179 of file petsc_diff_solver\&.C\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_qoi_parameter_sensitivity(), libMesh::System::boundary_project_vector(), libMesh::TransientSystem< Base >::init_data(), libMesh::TransientSystem< Base >::old_solution(), libMesh::TransientSystem< Base >::older_solution(), and libMesh::TransientSystem< Base >::re_update()\&.
.PP
.nf
203   : Parent(s)
204 {
205 }
.fi
.SS "std::string libMesh::get_io_compatibility_version ()"
Specifier for I/O file compatibility features\&. This only needs to be changed when new restart file functionality is added\&. 
.PP
Definition at line 77 of file libmesh_version\&.C\&.
.PP
Referenced by libMesh::EquationSystems::write()\&.
.PP
.nf
78 {
79   std::string retval(LIBMESH_IO_COMPATIBILITY_VERSION);
80   return retval;
81 }
.fi
.SS "int libMesh::get_libmesh_version ()"

.PP
Definition at line 43 of file libmesh_version\&.C\&.
.PP
Referenced by libmesh_version_stdout()\&.
.PP
.nf
44 {
45   /* Note: return format follows the versioning convention xx\&.yy\&.zz where
46 
47      xx = major version number
48      yy = minor version number
49      zz = micro version number
50 
51      For example:
52      v\&.   0\&.23  -> 002300 = 2300
53      v   0\&.23\&.1 -> 002301 = 2301
54      v\&. 10\&.23\&.2 -> 102302         */
55 
56   int major_version = 0;
57   int minor_version = 0;
58   int micro_version = 0;
59 
60 #ifdef LIBMESH_MAJOR_VERSION
61   major_version = LIBMESH_MAJOR_VERSION;
62 #endif
63 
64 #ifdef LIBMESH_MINOR_VERSION
65   minor_version = LIBMESH_MINOR_VERSION;
66 #endif
67 
68 #ifdef LIBMESH_MICRO_VERSION
69   micro_version = LIBMESH_MICRO_VERSION;
70 #endif
71 
72   return major_version*10000 + minor_version*100 + micro_version;
73 }
.fi
.SS "\fBlibMesh::processor_id_type\fP libMesh::global_n_processors ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors \fBlibMesh\fP was initialized with\&. 
.RE
.PP

.PP
Definition at line 104 of file libmesh_base\&.h\&.
.PP
References libMesh::libMeshPrivateData::_n_processors\&.
.PP
Referenced by libMesh::PerfLog::get_info_header(), n_processors(), libMesh::Elem::PackedElem::processor_id(), libMesh::MacroFunctions::report_error(), libMesh::MacroFunctions::stop(), and libMesh::Node::PackedNode::unpack()\&.
.PP
.nf
105 {
106 #ifdef LIBMESH_HAVE_MPI
107   return libMeshPrivateData::_n_processors;
108 #else
109   return 1;
110 #endif
111 }
.fi
.SS "\fBlibMesh::processor_id_type\fP libMesh::global_processor_id ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the local processor with respect to the original MPI pool \fBlibMesh\fP was initialized with\&. 
.RE
.PP

.PP
Definition at line 114 of file libmesh_base\&.h\&.
.PP
References libMesh::libMeshPrivateData::_processor_id\&.
.PP
Referenced by libMesh::PerfLog::get_info_header(), libMesh::MacroFunctions::here(), if(), processor_id(), and write_traceout()\&.
.PP
.nf
115 {
116 #ifdef LIBMESH_HAVE_MPI
117   return libMeshPrivateData::_processor_id;
118 #else
119   return 0;
120 #endif
121 }
.fi
.SS "libMesh::if (solver->matvec &&solver->residual_and_jacobian_object)"

.PP
Definition at line 221 of file petsc_nonlinear_solver\&.C\&.
.PP
References err\&.
.PP
.nf
222       {
223         libMesh::err << "ERROR: cannot specify both a function and object to compute the combined Residual & Jacobian!" << std::endl;
224         libmesh_error();
225       }
.fi
.SS "libMesh::if (solver->jacobian! = \fCNULL\fP)"

.PP
Definition at line 228 of file petsc_nonlinear_solver\&.C\&.
.PP
.nf
253                                                                   :
254   NonlinearSolver<T>(system_in),
255   _reason(SNES_CONVERGED_ITERATING/*==0*/), // Arbitrary initial value\&.\&.\&.
256   _n_linear_iterations(0),
257   _current_nonlinear_iteration_number(0),
258   _zero_out_residual(true),
259   _zero_out_jacobian(true),
260   _default_monitor(true)
261 {
262 }
.fi
.SS "libMesh::if (solution_vector &&solution_vector! = \fCsystem\&.solution\&.get()\fP)"

.PP
Definition at line 231 of file exact_error_estimator\&.C\&.
.PP
References libMesh::NumericVector< T >::swap(), and sys\&.
.PP
.nf
232     {
233       NumericVector<Number>* newsol =
234         const_cast<NumericVector<Number>*>(solution_vector);
235       System &sys = const_cast<System&>(system);
236       newsol->swap(*sys\&.solution);
237       sys\&.update();
238     }
.fi
.SS "libMesh::if (!libMesh::on_command_line'--disable-mpi')"

.PP
Definition at line 363 of file libmesh\&.C\&.
.PP
References libMesh::libMeshPrivateData::_n_processors, libMesh::libMeshPrivateData::_n_threads, libMesh::libMeshPrivateData::_processor_id, comm, COMM_WORLD, libMesh::Parallel::Communicator_World, GLOBAL_COMM_WORLD, libmesh_errhandler, EXTERN_C_FOR_PETSC_END::libmesh_initialized_mpi, libMesh_MPI_Handler(), n_threads, and on_command_line()\&.
.PP
.nf
364     {
365       // Check whether the calling program has already initialized
366       // MPI, and avoid duplicate Init/Finalize
367       int flag;
368       MPI_Initialized (&flag);
369 
370       if (!flag)
371         {
372 #if MPI_VERSION > 1
373           int mpi_thread_provided;
374           const int mpi_thread_requested = libMesh::n_threads() > 1 ?
375                                            MPI_THREAD_FUNNELED :
376                                            MPI_THREAD_SINGLE;
377 
378           MPI_Init_thread (&argc, const_cast<char***>(&argv),
379                            mpi_thread_requested, &mpi_thread_provided);
380 
381           if ((libMesh::n_threads() > 1) &&
382               (mpi_thread_provided < MPI_THREAD_FUNNELED))
383             {
384               libmesh_warning("Warning: MPI failed to guarantee MPI_THREAD_FUNNELED\n" << 
385                               "for a threaded run\&.\n" <<
386                               "Be sure your library is funneled-thread-safe\&.\&.\&." <<
387                                std::endl);
388 
389               // Ideally, if an MPI stack tells us it's unsafe for us
390               // to use threads, we shouldn't use threads\&.
391               // In practice, we've encountered one MPI stack (an
392               // mvapich2 configuration) that returned
393               // MPI_THREAD_SINGLE as a proper warning, two stacks
394               // that handle MPI_THREAD_FUNNELED properly, and two
395               // current stacks plus a couple old stacks that return
396               // MPI_THREAD_SINGLE but support libMesh threaded runs
397               // anyway\&.
398 
399               // libMesh::libMeshPrivateData::_n_threads = 1;
400               // task_scheduler\&.reset (new Threads::task_scheduler_init(libMesh::n_threads()));
401             }
402 #else
403           if (libMesh::libMeshPrivateData::_n_threads > 1)
404             {
405               libmesh_warning("Warning: using MPI1 for threaded code\&.\n" <<
406                               "Be sure your library is funneled-thread-safe\&.\&.\&." <<
407                               std::endl);
408             }
409 
410           MPI_Init (&argc, const_cast<char***>(&argv));
411 #endif
412           libmesh_initialized_mpi = true;
413         }
414 
415       // Duplicate the input communicator for internal use
416       // And get a Parallel::Communicator copy too, to use
417       // as a default for that API
418       this->_comm = COMM_WORLD_IN;
419 
420       libMesh::GLOBAL_COMM_WORLD = COMM_WORLD_IN;
421 
422 #ifndef LIBMESH_DISABLE_COMMWORLD
423       libMesh::COMM_WORLD = COMM_WORLD_IN;
424       Parallel::Communicator_World = COMM_WORLD_IN;
425 #endif
426 
427       //MPI_Comm_set_name not supported in at least SGI MPT's MPI implementation
428       //MPI_Comm_set_name (libMesh::COMM_WORLD, "libMesh::COMM_WORLD");
429 
430       libMeshPrivateData::_processor_id =
431         libmesh_cast_int<processor_id_type>(this->comm()\&.rank());
432       libMeshPrivateData::_n_processors =
433         libmesh_cast_int<processor_id_type>(this->comm()\&.size());
434 
435       // Set up an MPI error handler if requested\&.  This helps us get
436       // into a debugger with a proper stack when an MPI error occurs\&.
437       if (libMesh::on_command_line ("--handle-mpi-errors"))
438         {
439 #if MPI_VERSION > 1
440           MPI_Comm_create_errhandler(libMesh_MPI_Handler, &libmesh_errhandler);
441           MPI_Comm_set_errhandler(libMesh::GLOBAL_COMM_WORLD, libmesh_errhandler);
442           MPI_Comm_set_errhandler(MPI_COMM_WORLD, libmesh_errhandler);
443 #else
444           MPI_Errhandler_create(libMesh_MPI_Handler, &libmesh_errhandler);
445           MPI_Errhandler_set(libMesh::GLOBAL_COMM_WORLD, libmesh_errhandler);
446           MPI_Errhandler_set(MPI_COMM_WORLD, libmesh_errhandler);
447 #endif // #if MPI_VERSION > 1
448         }
449     }
.fi
.SS "libMesh::if (!\fBlibMesh::on_command_line\fP('--disable-petsc')#if defined(LIBMESH_HAVE_MPI)&&!\fBlibMesh::on_command_line\fP('--disable-mpi')#endif)"

.PP
Definition at line 465 of file libmesh\&.C\&.
.PP
References CHKERRABORT(), GLOBAL_COMM_WORLD, ierr, EXTERN_C_FOR_PETSC_END::libmesh_initialized_petsc, EXTERN_C_FOR_PETSC_END::libmesh_initialized_slepc, and PetscBool\&.
.PP
.nf
474     {
475       int ierr=0;
476 
477       PETSC_COMM_WORLD = libMesh::GLOBAL_COMM_WORLD;
478 
479       // Check whether the calling program has already initialized
480       // PETSc, and avoid duplicate Initialize/Finalize
481       PetscBool petsc_already_initialized;
482       ierr = PetscInitialized(&petsc_already_initialized);
483       CHKERRABORT(libMesh::GLOBAL_COMM_WORLD,ierr);
484       if (petsc_already_initialized != PETSC_TRUE)
485         libmesh_initialized_petsc = true;
486 # if defined(LIBMESH_HAVE_SLEPC)
487 
488       // If SLEPc allows us to check whether the calling program
489       // has already initialized it, we do that, and avoid
490       // duplicate Initialize/Finalize\&.
491       // We assume that SLEPc will handle PETSc appropriately,
492       // which it does in the versions we've checked\&.
493 #  if !SLEPC_VERSION_LESS_THAN(2,3,3)
494       if (!SlepcInitializeCalled)
495 #  endif
496         {
497           ierr = SlepcInitialize  (&argc, const_cast<char***>(&argv), NULL, NULL);
498           CHKERRABORT(libMesh::GLOBAL_COMM_WORLD,ierr);
499           libmesh_initialized_slepc = true;
500         }
501 # else
502       if (libmesh_initialized_petsc)
503         {
504           ierr = PetscInitialize (&argc, const_cast<char***>(&argv), NULL, NULL);
505           CHKERRABORT(libMesh::GLOBAL_COMM_WORLD,ierr);
506         }
507 # endif
508     }
.fi
.SS "if (!\fBlibMesh::on_command_line\fP ('--sync-with-stdio')) std libMesh::if (libMesh::on_command_line'--separate-libmeshout')"

.PP
Definition at line 529 of file libmesh\&.C\&.
.PP
References err, and out\&.
.PP
.nf
530     {
531       // Redirect\&.  We'll share streambufs with cout/cerr for now, but
532       // presumably anyone using this option will want to replace the
533       // bufs later\&.
534       std::ostream* newout = new std::ostream(std::cout\&.rdbuf());
535       libMesh::out = *newout;
536       std::ostream* newerr = new std::ostream(std::cerr\&.rdbuf());
537       libMesh::err = *newerr;
538     }
.fi
.SS "libMesh::if (libMesh::on_command_line'--redirect-stdout')"

.PP
Definition at line 544 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::_ofstream, err, EXTERN_C_FOR_PETSC_END::err_buf(), global_processor_id(), out, EXTERN_C_FOR_PETSC_END::out_buf(), and libMesh::BasicOStreamProxy< charT, traits >::rdbuf()\&.
.PP
.nf
545     {
546       std::ostringstream filename;
547       filename << "stdout\&.processor\&." << libMesh::global_processor_id();
548       _ofstream\&.reset (new std::ofstream (filename\&.str()\&.c_str()));
549       // Redirect, saving the original streambufs!
550       out_buf = libMesh::out\&.rdbuf (_ofstream->rdbuf());
551       err_buf = libMesh::err\&.rdbuf (_ofstream->rdbuf());
552     }
.fi
.SS "libMesh::if (\fBlibMesh::global_processor_id\fP()! = \fC0\fP)"

.PP
Definition at line 557 of file libmesh\&.C\&.
.PP
.nf
590 {
591   // We can't delete, finalize, etc\&. more than once without
592   // reinitializing in between
593   libmesh_exceptionless_assert(!libMesh::closed());
594 
595   // Delete reference counted singleton(s)
596   Singleton::cleanup();
597 
598   // Clear the thread task manager we started
599   task_scheduler\&.reset();
600 
601   // Let's be sure we properly close on every processor at once:
602   libmesh_parallel_only(this->comm());
603 
604 
605   // Force the \p ReferenceCounter to print
606   // its reference count information\&.  This allows
607   // us to find memory leaks\&.  By default the
608   // \p ReferenceCounter only prints its information
609   // when the last created object has been destroyed\&.
610   // That does no good if we are leaking memory!
611   ReferenceCounter::print_info ();
612 
613 
614   // Print an informative message if we detect a memory leak
615   if (ReferenceCounter::n_objects() != 0)
616     {
617       libMesh::err << "Memory leak detected!"
618                    << std::endl;
619 
620 #if !defined(LIBMESH_ENABLE_REFERENCE_COUNTING) || defined(NDEBUG)
621 
622       libMesh::err << "Compile in DEBUG mode with --enable-reference-counting"
623                    << std::endl
624                    << "for more information"
625                    << std::endl;
626 #endif
627 
628     }
629 
630   //  print the perflog to individual processor's file\&.
631   libMesh::perflog\&.print_log();
632 
633   // Now clear the logging object, we don't want it to print
634   // a second time during the PerfLog destructor\&.
635   libMesh::perflog\&.clear();
636 
637   // Reconnect the output streams
638   // (don't do this, or we will get messages from objects
639   //  that go out of scope after the following return)
640   //std::cout\&.rdbuf(std::cerr\&.rdbuf());
641 
642 
643   // Set the initialized() flag to false
644   libMeshPrivateData::_is_initialized = false;
645 
646   if (libMesh::on_command_line ("--redirect-stdout"))
647     {
648       // If stdout/stderr were redirected to files, reset them now\&.
649       libMesh::out\&.rdbuf (out_buf);
650       libMesh::err\&.rdbuf (err_buf);
651     }
652 
653   // If we built our own output streams, we want to clean them up\&.
654   if (libMesh::on_command_line ("--separate-libmeshout"))
655     {
656       delete libMesh::out\&.get();
657       delete libMesh::err\&.get();
658 
659       libMesh::out\&.reset(std::cout);
660       libMesh::err\&.reset(std::cerr);
661     }
662 
663 #ifdef LIBMESH_ENABLE_EXCEPTIONS
664   // Reset the old terminate handler; maybe the user code wants to
665   // keep doing C++ stuff after closing libMesh stuff\&.
666   std::set_terminate(old_terminate_handler);
667 #endif
668 
669 
670   if (libMesh::on_command_line("--enable-fpe"))
671     libMesh::enableFPE(false);
672 
673 #if defined(LIBMESH_HAVE_PETSC)
674   // Allow the user to bypass PETSc finalization
675   if (!libMesh::on_command_line ("--disable-petsc")
676 #if defined(LIBMESH_HAVE_MPI)
677       && !libMesh::on_command_line ("--disable-mpi")
678 #endif
679       )
680     {
681 # if defined(LIBMESH_HAVE_SLEPC)
682       if (libmesh_initialized_slepc)
683         SlepcFinalize();
684 # else
685       if (libmesh_initialized_petsc)
686         PetscFinalize();
687 # endif
688     }
689 #endif
690 
691 
692 #if defined(LIBMESH_HAVE_MPI)
693   // Allow the user to bypass MPI finalization
694   if (!libMesh::on_command_line ("--disable-mpi"))
695     {
696       this->_comm\&.clear();
697 #ifndef LIBMESH_DISABLE_COMMWORLD
698       Parallel::Communicator_World\&.clear();
699 #endif
700 
701       if (libmesh_initialized_mpi)
702         MPI_Finalize();
703     }
704 #endif
705 }
.fi
.SS "const \fBNumber\fP libMesh::imaginary (0\&., 1\&.)"

.SS "bool libMesh::initialized ()"
Checks that library initialization has been done\&. If it hasn't an error message is printed and the code aborts\&. It is useful to \fClibmesh_assert\fP(\fBlibMesh::initialized()\fP) in library object constructors\&. 
.PP
Definition at line 249 of file libmesh\&.C\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized\&.
.PP
Referenced by libMesh::PetscVector< T >::_get_array(), libMesh::PetscVector< T >::_restore_array(), libMesh::LaspackVector< T >::abs(), libMesh::DistributedVector< T >::abs(), libMesh::EigenSparseVector< T >::abs(), libMesh::EigenSparseMatrix< T >::add(), libMesh::LaspackMatrix< T >::add(), libMesh::EpetraMatrix< T >::add(), libMesh::PetscMatrix< T >::add(), libMesh::LaspackVector< T >::add(), libMesh::DistributedVector< T >::add(), libMesh::EigenSparseVector< T >::add(), libMesh::PetscMatrix< T >::add_block_matrix(), libMesh::EigenSparseMatrix< T >::add_matrix(), libMesh::LaspackMatrix< T >::add_matrix(), libMesh::EpetraMatrix< T >::add_matrix(), libMesh::PetscMatrix< T >::add_matrix(), libMesh::DistributedVector< T >::add_vector(), libMesh::EigenSparseLinearSolver< T >::clear(), libMesh::AztecLinearSolver< T >::clear(), libMesh::LaspackLinearSolver< T >::clear(), libMesh::SlepcEigenSolver< T >::clear(), libMesh::PetscNonlinearSolver< T >::clear(), libMesh::LaspackVector< T >::clear(), libMesh::PetscLinearSolver< T >::clear(), libMesh::EpetraVector< T >::clear(), libMesh::PetscVector< T >::clear(), libMesh::LaspackMatrix< T >::clear(), libMesh::EpetraMatrix< T >::clear(), libMesh::PetscMatrix< T >::clear(), libMesh::DistributedVector< T >::close(), libMesh::LaspackVector< T >::close(), libMesh::EigenSparseVector< T >::close(), libMesh::EpetraVector< T >::close(), libMesh::EpetraMatrix< T >::closed(), libMesh::PetscMatrix< T >::closed(), libMesh::NumericVector< T >::compare(), default_solver_package(), libMesh::LaspackVector< T >::dot(), libMesh::EigenSparseVector< T >::dot(), libMesh::DistributedVector< T >::first_local_index(), libMesh::LaspackVector< T >::first_local_index(), libMesh::EigenSparseVector< T >::first_local_index(), libMesh::EpetraVector< T >::first_local_index(), libMesh::PetscVector< T >::first_local_index(), libMesh::PetscNonlinearSolver< T >::get_converged_reason(), libMesh::NumericVector< T >::global_relative_compare(), libMesh::EigenSparseLinearSolver< T >::init(), libMesh::AztecLinearSolver< T >::init(), libMesh::LaspackLinearSolver< T >::init(), libMesh::SlepcEigenSolver< T >::init(), libMesh::NoxNonlinearSolver< T >::init(), libMesh::PetscNonlinearSolver< T >::init(), libMesh::EigenSparseMatrix< T >::init(), libMesh::EpetraMatrix< T >::init(), libMesh::PetscLinearSolver< T >::init(), libMesh::LaspackMatrix< T >::init(), libMesh::PetscMatrix< T >::init(), libMesh::DistributedVector< T >::init(), libMesh::PetscVector< T >::init(), libMesh::DistributedVector< T >::insert(), libMesh::DistributedVector< T >::l1_norm(), libMesh::EigenSparseVector< T >::l1_norm(), libMesh::EpetraMatrix< T >::l1_norm(), libMesh::PetscMatrix< T >::l1_norm(), libMesh::DistributedVector< T >::l2_norm(), libMesh::EigenSparseVector< T >::l2_norm(), libMesh::DistributedVector< T >::last_local_index(), libMesh::LaspackVector< T >::last_local_index(), libMesh::EigenSparseVector< T >::last_local_index(), libMesh::EpetraVector< T >::last_local_index(), libMesh::PetscVector< T >::last_local_index(), libMesh::DistributedVector< T >::linfty_norm(), libMesh::EigenSparseVector< T >::linfty_norm(), libMesh::EpetraMatrix< T >::linfty_norm(), libMesh::PetscMatrix< T >::linfty_norm(), libMesh::NumericVector< T >::local_relative_compare(), libMesh::DistributedVector< T >::local_size(), libMesh::LaspackVector< T >::local_size(), libMesh::EigenSparseVector< T >::local_size(), libMesh::EpetraVector< T >::local_size(), libMesh::PetscVector< T >::local_size(), libMesh::DistributedVector< T >::localize(), libMesh::DistributedVector< T >::localize_to_one(), libMesh::EigenSparseMatrix< T >::m(), libMesh::LaspackMatrix< T >::m(), libMesh::EpetraMatrix< T >::m(), libMesh::PetscMatrix< T >::m(), libMesh::PetscVector< T >::map_global_to_local_index(), libMesh::DistributedVector< T >::max(), libMesh::LaspackVector< T >::max(), libMesh::EigenSparseVector< T >::max(), libMesh::EpetraVector< T >::max(), libMesh::MeshBase::MeshBase(), libMesh::DistributedVector< T >::min(), libMesh::LaspackVector< T >::min(), libMesh::EigenSparseVector< T >::min(), libMesh::EpetraVector< T >::min(), libMesh::EigenSparseMatrix< T >::n(), libMesh::LaspackMatrix< T >::n(), libMesh::EpetraMatrix< T >::n(), libMesh::PetscMatrix< T >::n(), libMesh::AnalyticFunction< Output >::operator()(), libMesh::EigenSparseMatrix< T >::operator()(), libMesh::LaspackMatrix< T >::operator()(), libMesh::EpetraMatrix< T >::operator()(), libMesh::DistributedVector< T >::operator()(), libMesh::LaspackVector< T >::operator()(), libMesh::EigenSparseVector< T >::operator()(), libMesh::EpetraVector< T >::operator()(), libMesh::PetscMatrix< T >::operator()(), libMesh::DistributedVector< T >::operator+=(), libMesh::DistributedVector< T >::operator-=(), libMesh::DistributedVector< T >::operator=(), libMesh::LaspackVector< T >::operator=(), libMesh::EigenSparseVector< T >::operator=(), libMesh::SparseMatrix< T >::print(), libMesh::NumericVector< T >::print(), libMesh::NumericVector< T >::print_global(), libMesh::PetscMatrix< T >::print_matlab(), libMesh::EpetraMatrix< T >::print_personal(), libMesh::PetscMatrix< T >::print_personal(), libMesh::EpetraMatrix< T >::row_start(), libMesh::PetscMatrix< T >::row_start(), libMesh::EpetraMatrix< T >::row_stop(), libMesh::PetscMatrix< T >::row_stop(), libMesh::LaspackVector< T >::scale(), libMesh::DistributedVector< T >::scale(), libMesh::EigenSparseVector< T >::scale(), libMesh::EigenSparseMatrix< T >::set(), libMesh::LaspackMatrix< T >::set(), libMesh::EpetraMatrix< T >::set(), libMesh::PetscMatrix< T >::set(), libMesh::DistributedVector< T >::set(), libMesh::LaspackVector< T >::set(), libMesh::EigenSparseVector< T >::set(), libMesh::DistributedVector< T >::size(), libMesh::LaspackVector< T >::size(), libMesh::EigenSparseVector< T >::size(), libMesh::EpetraVector< T >::size(), libMesh::PetscVector< T >::size(), libMesh::DistributedVector< T >::sum(), libMesh::EigenSparseVector< T >::sum(), libMesh::UnstructuredMesh::UnstructuredMesh(), libMesh::LaspackMatrix< T >::update_sparsity_pattern(), libMesh::EpetraMatrix< T >::update_sparsity_pattern(), libMesh::DistributedVector< T >::zero(), libMesh::LaspackVector< T >::zero(), libMesh::EigenSparseVector< T >::zero(), libMesh::EpetraVector< T >::zero(), libMesh::EpetraMatrix< T >::zero(), libMesh::PetscMatrix< T >::zero(), and libMesh::PetscMatrix< T >::zero_rows()\&.
.PP
.nf
250 {
251   return libMeshPrivateData::_is_initialized;
252 }
.fi
.SS "libMesh::INSTANTIATE_ALL_MAPS (0)"

.SS "libMesh::INSTANTIATE_ALL_MAPS (1)"

.SS "libMesh::INSTANTIATE_ALL_MAPS (2)"

.SS "libMesh::INSTANTIATE_ALL_MAPS (3)"

.SS "libMesh::INSTANTIATE_FE (0)"

.SS "libMesh::INSTANTIATE_FE (1)"

.SS "libMesh::INSTANTIATE_FE (2)"

.SS "libMesh::INSTANTIATE_FE (3)"

.SS "libMesh::INSTANTIATE_INF_FE (1, CARTESIAN)"
Collect all 1D explicit instantiations for class \fBInfFE\fP 
.SS "libMesh::INSTANTIATE_INF_FE (2, CARTESIAN)"
Collect all 2D explicit instantiations for class \fBInfFE\fP 
.SS "libMesh::INSTANTIATE_INF_FE (3, CARTESIAN)"
Collect all 3D explicit instantiations for class \fBInfFE\fP 
.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, Elem *, Base::build_elemconst Elem *)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, Elem *, Base::build_elemconst Elem *)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, Elem *, Base::build_elemconst Elem *)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, ElemType, Base::get_elem_typeconst ElemType type)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, ElemType, Base::get_elem_typeconst ElemType type)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, ElemType, Base::get_elem_typeconst ElemType type)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, unsignedint, Base::n_base_mapping_sfconst ElemType, const Order)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, unsignedint, Base::n_base_mapping_sfconst ElemType, const Order)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, unsignedint, Base::n_base_mapping_sfconst ElemType, const Order)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, unsignedint, Radial::n_dofs_at_nodeconst Order, const unsigned int)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, unsignedint, Radial::n_dofs_at_nodeconst Order, const unsigned int)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, unsignedint, Radial::n_dofs_at_nodeconst Order, const unsigned int)"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, edge_reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, edge_reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, edge_reinit(const Elem *, const unsigned int, const Real, const std::vector< Point > *const, const std::vector< Real > *const))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, init_face_shape_functions(const std::vector< Point > &, const Elem *))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, init_face_shape_functions(const std::vector< Point > &, const Elem *))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, init_face_shape_functions(const std::vector< Point > &, const Elem *))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, Point, inverse_map(const Elem *, const Point &, const Real, const bool, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, Point, inverse_map(const Elem *, const Point &, const Real, const bool, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, Point, inverse_map(const Elem *, const Point &, const Real, const bool, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, inverse_map(const Elem *, const std::vector< Point > &, std::vector< Point > &, const Real, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, inverse_map(const Elem *, const std::vector< Point > &, std::vector< Point > &, const Real, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, inverse_map(const Elem *, const std::vector< Point > &, std::vector< Point > &, const Real, const bool))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, unsignedint, n_dofs(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, unsignedint, n_dofs(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, unsignedint, n_dofs(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, unsignedint, n_dofs_per_elem(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, unsignedint, n_dofs_per_elem(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, unsignedint, n_dofs_per_elem(const FEType &, const ElemType))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, unsignedint, n_dofs_at_node(const FEType &, const ElemType, const unsigned int))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, unsignedint, n_dofs_at_node(const FEType &, const ElemType, const unsigned int))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, unsignedint, n_dofs_at_node(const FEType &, const ElemType, const unsigned int))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, compute_shape_indices(const FEType &, const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, compute_shape_indices(const FEType &, const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, compute_shape_indices(const FEType &, const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, compute_node_indices(const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, compute_node_indices(const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, compute_node_indices(const ElemType, const unsigned int, unsigned int &, unsigned int &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, Real, shape(const FEType &, const Elem *, const unsigned int, const Point &p))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, Real, shape(const FEType &, const Elem *, const unsigned int, const Point &p))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, Real, shape(const FEType &, const Elem *, const unsigned int, const Point &p))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, Real, shape(const FEType &, const ElemType, const unsigned int, const Point &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, Real, shape(const FEType &, const ElemType, const unsigned int, const Point &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, Real, shape(const FEType &, const ElemType, const unsigned int, const Point &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, compute_data(const FEType &, const Elem *, FEComputeData &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, compute_data(const FEType &, const Elem *, FEComputeData &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, compute_data(const FEType &, const Elem *, FEComputeData &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (1, CARTESIAN, void, nodal_soln(const FEType &, const Elem *, const std::vector< Number > &, std::vector< Number > &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (2, CARTESIAN, void, nodal_soln(const FEType &, const Elem *, const std::vector< Number > &, std::vector< Number > &))"

.SS "libMesh::INSTANTIATE_INF_FE_MBRF (3, CARTESIAN, void, nodal_soln(const FEType &, const Elem *, const std::vector< Number > &, std::vector< Number > &))"

.SS "bool libMesh::is_between (Realmin, Realcheck, Realmax)"

.PP
Definition at line 239 of file mesh_tools\&.C\&.
.PP
References std::max()\&.
.PP
Referenced by libMesh::MeshTools::BoundingBox::contains_point(), and libMesh::MeshTools::BoundingBox::intersect()\&.
.PP
.nf
240 {
241   return min <= check && check <= max;
242 }
.fi
.SS "\fBPetscMatrix\fP<\fBNumber\fP> libMesh::J_input (\fBpc\fP, sys\&.comm())"

.SS "\fBPetscMatrix\fP<\fBNumber\fP> \fBJac\fP* libMesh::jac ()"

.SS "\fBPetscMatrix\fP<\fBNumber\fP> libMesh::Jac (\fBjac\fP, sys\&.comm())"

.PP
Referenced by libMesh::Problem_Interface::computeJacobian(), and libMesh::Problem_Interface::computePreconditioner()\&.
.SS "\fBPetscErrorCode\fP Vec Mat Mat void* ctx libMesh::libmesh_assert (\fBx\fP)"

.SS "libMesh::libmesh_assert (j)"

.SS "libMesh::libmesh_assert (ctx)"

.SS "libMesh::libmesh_assert (remote_elem)"

.PP
Referenced by __libmesh_petsc_diff_solver_residual(), __libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::PetscLinearSolver< T >::_create_complement_is(), libMesh::FEMContext::_do_elem_position_set(), libMesh::MetisPartitioner::_do_partition(), libMesh::DofMap::_dof_indices(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::PetscVector< T >::_get_array(), libMesh::EquationSystems::_read_impl(), libMesh::GMVIO::_read_one_cell(), libMesh::PetscVector< T >::_restore_array(), libMesh::PetscLinearSolver< T >::_restrict_solve_to_is_local_size(), libMesh::LaspackVector< T >::abs(), libMesh::DistributedVector< T >::abs(), libMesh::EigenSparseVector< T >::abs(), libMesh::Elem::active_family_tree(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::active_family_tree_by_side(), libMesh::EigenSparseMatrix< T >::add(), libMesh::LaspackMatrix< T >::add(), libMesh::EpetraMatrix< T >::add(), libMesh::PetscMatrix< T >::add(), libMesh::DistributedVector< T >::add(), libMesh::EigenSparseVector< T >::add(), libMesh::LaspackVector< T >::add(), libMesh::PetscMatrix< T >::add_block_matrix(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::GMVIO::add_cell_centered_data(), libMesh::Elem::add_child(), libMesh::BoundaryInfo::add_edge(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::MeshRefinement::add_elem(), libMesh::MeshData::add_foreign_elem_id(), libMesh::MeshData::add_foreign_node_id(), libMesh::EigenSparseMatrix< T >::add_matrix(), libMesh::LaspackMatrix< T >::add_matrix(), libMesh::EpetraMatrix< T >::add_matrix(), libMesh::PetscMatrix< T >::add_matrix(), libMesh::BoundaryInfo::add_node(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::DofMap::add_periodic_boundary(), libMesh::SerialMesh::add_point(), libMesh::ParallelMesh::add_point(), libMesh::MeshRefinement::add_point(), libMesh::HPCoarsenTest::add_projection(), libMesh::EnsightIO::add_scalar(), libMesh::BoundaryInfo::add_side(), libMesh::ImplicitSystem::add_system_matrix(), libMesh::ExplicitSystem::add_system_rhs(), libMesh::EnsightIO::add_vector(), libMesh::DistributedVector< T >::add_vector(), libMesh::LaspackVector< T >::add_vector(), libMesh::EigenSparseVector< T >::add_vector(), libMesh::EigenSparseVector< T >::add_vector_transpose(), libMesh::EquationSystems::adjoint_solve(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::Parallel::Communicator::allgather(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::Parallel::Communicator::alltoall(), libMesh::AnalyticFunction< Output >::AnalyticFunction(), libMesh::Utility::do_pow< N, T >::apply(), libMesh::ImplicitSystem::assemble(), libMesh::FrequencySystem::assemble(), libMesh::FEMSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::MeshData::assign(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::System::attach_assemble_function(), libMesh::System::attach_constraint_function(), libMesh::ExactErrorEstimator::attach_exact_deriv(), libMesh::ExactSolution::attach_exact_deriv(), libMesh::ExactErrorEstimator::attach_exact_hessian(), libMesh::ExactSolution::attach_exact_hessian(), libMesh::System::attach_init_function(), libMesh::DofMap::attach_matrix(), libMesh::System::attach_QOI_derivative(), libMesh::System::attach_QOI_function(), libMesh::FE< Dim, T >::attach_quadrature_rule(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::attach_quadrature_rule(), libMesh::FESubdivision::attach_quadrature_rule(), libMesh::ExactSolution::attach_reference_solution(), libMesh::ExactErrorEstimator::attach_reference_solution(), libMesh::FrequencySystem::attach_solve_function(), libMesh::UNVIO::beginning_of_dataset(), libMesh::Parallel::BinSorter< KeyType, IdxType >::BinSorter(), libMesh::Threads::BoolAcquire::BoolAcquire(), libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::BoundaryProjectSolution::BoundaryProjectSolution(), libMesh::TreeNode< N >::bounds_node(), libMesh::Parallel::Communicator::broadcast(), libMesh::Patch::build_around_element(), libMesh::DofMap::build_constraint_matrix(), libMesh::DofMap::build_constraint_matrix_and_vector(), libMesh::FEMSystem::build_context(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ParmetisPartitioner::build_graph(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::build_sparsity(), libMesh::EquationSystems::build_variable_names(), libMesh::Elem::child(), libMesh::Singleton::cleanup(), libMesh::Parallel::Request::cleanup(), libMesh::EpetraMatrix< T >::clear(), libMesh::Parallel::Communicator::clear(), libMesh::DofObject::clear_dofs(), libMesh::DofMap::clear_sparsity(), libMesh::Parameters::Parameter< T >::clone(), libMesh::DistributedVector< T >::close(), libMesh::LaspackVector< T >::close(), libMesh::EigenSparseVector< T >::close(), libMesh::EpetraVector< T >::close(), libMesh::EpetraMatrix< T >::close(), libMesh::MeshData::close_foreign_id_maps(), libMesh::EpetraMatrix< T >::closed(), libMesh::PetscMatrix< T >::closed(), libMesh::Elem::coarsen(), libMesh::MeshRefinement::coarsen_elements(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::combine_base_radial(), command_line_next(), command_line_value(), command_line_vector(), libMesh::Xdr::comment(), libMesh::System::compare(), libMesh::NumericVector< T >::compare(), libMesh::WrappedFunction< Output >::component(), libMesh::FEMap::compute_affine_map(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::FEInterface::compute_constraints(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::FEMap::compute_edge_map(), libMesh::ExactSolution::compute_error(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEXYZ< Dim >::compute_face_values(), libMesh::Elem::compute_key(), libMesh::FEMap::compute_map(), libMesh::FEAbstract::compute_node_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_shape_functions(), libMesh::FEXYZ< Dim >::compute_shape_functions(), libMesh::FEMap::compute_single_point_map(), libMesh::Prism6::connectivity(), libMesh::Pyramid5::connectivity(), libMesh::Hex8::connectivity(), libMesh::InfPrism6::connectivity(), libMesh::InfPrism12::connectivity(), libMesh::InfHex8::connectivity(), libMesh::Tet4::connectivity(), libMesh::Tet10::connectivity(), libMesh::InfHex16::connectivity(), libMesh::Hex20::connectivity(), libMesh::Pyramid13::connectivity(), libMesh::Prism15::connectivity(), libMesh::Pyramid14::connectivity(), libMesh::InfHex18::connectivity(), libMesh::Hex27::connectivity(), libMesh::Prism18::connectivity(), libMesh::DofMap::constrain_element_dyad_matrix(), libMesh::DofMap::constrain_element_matrix(), libMesh::DofMap::constrain_element_matrix_and_vector(), libMesh::DofMap::constrain_element_vector(), libMesh::UnstructuredMesh::contract(), libMesh::Elem::contract(), libMesh::GMVIO::copy_nodal_solution(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::vectormap< dof_id_type, dof_id_type >::count(), libMesh::DofMap::create_dof_constraints(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::UnstructuredMesh::create_submesh(), libMesh::UNVIO::D_to_e(), libMesh::Xdr::data(), libMesh::Xdr::data_stream(), libMesh::XdrMGF::dataBlk(), default_solver_package(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::Parallel::Communicator::dereference_unique_tag(), libMesh::DGFEMContext::DGFEMContext(), libMesh::DirichletBoundary::DirichletBoundary(), libMesh::MeshFunction::disable_out_of_mesh_mode(), libMesh::MeshTools::Modification::distort(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), DMlibMeshFunction(), libMesh::Xdr::do_read(), libMesh::Xdr::do_write(), libMesh::DofMap::dof_indices(), libMesh::FE< Dim, T >::dofs_on_edge(), libMesh::FE< Dim, T >::dofs_on_side(), libMesh::LaspackVector< T >::dot(), libMesh::EigenSparseVector< T >::dot(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::FE< Dim, T >::edge_reinit(), libMesh::SerialMesh::elem(), libMesh::ParallelMesh::elem(), libMesh::FEMContext::elem_position_get(), libMesh::MeshData::elem_to_foreign_id(), libMesh::TetGenIO::element_in(), libMesh::UNVIO::element_in(), libMesh::UNVIO::element_out(), libMesh::SteadySolver::element_residual(), libMesh::AdaptiveTimeSolver::element_residual(), libMesh::EigenTimeSolver::element_residual(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::MeshFunction::enable_out_of_mesh_mode(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::ExactSolution::error_norm(), libMesh::AdaptiveTimeSolver::error_order(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::DofMap::extract_local_vector(), libMesh::Factory< Base >::Factory(), libMesh::Elem::family_tree(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::FEMContext::FEMContext(), libMesh::DofMap::find_connected_dofs(), libMesh::Elem::find_edge_neighbors(), libMesh::TreeNode< N >::find_element_in_children(), libMesh::MeshCommunication::find_global_indices(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::find_point_neighbors(), libMesh::MemorySolutionHistory::find_stored_entry(), libMesh::DistributedVector< T >::first_local_index(), libMesh::LaspackVector< T >::first_local_index(), libMesh::EigenSparseVector< T >::first_local_index(), libMesh::EpetraVector< T >::first_local_index(), libMesh::PetscVector< T >::first_local_index(), libMesh::FEMContext::fixed_interior_hessian(), libMesh::FEMContext::fixed_interior_value(), libMesh::FEMContext::fixed_point_gradient(), libMesh::FEMContext::fixed_point_hessian(), libMesh::FEMContext::fixed_point_value(), libMesh::FEMContext::fixed_side_gradient(), libMesh::FEMContext::fixed_side_hessian(), libMesh::FEMContext::fixed_side_value(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshData::foreign_id_to_elem(), libMesh::MeshData::foreign_id_to_node(), libMesh::Parallel::Communicator::gather(), libMesh::Parameters::get(), libMesh::ReferenceElem::get(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::MeshData::get_data(), libMesh::DiffContext::get_deltat_value(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::TetGenWrapper::get_element_attribute(), libMesh::DofMap::get_info(), libMesh::DifferentiableSystem::get_linear_solve_parameters(), libMesh::DifferentiableSystem::get_linear_solver(), libMesh::DiffContext::get_localized_subvector(), libMesh::DiffContext::get_localized_vector(), libMesh::EquationSystems::get_mesh_data(), libMesh::DofMap::get_n_nz(), libMesh::DofMap::get_n_oz(), libMesh::Elem::get_node(), libMesh::Tri3Subdivision::get_ordered_node(), libMesh::Tri3Subdivision::get_ordered_valence(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), libMesh::MeshFunction::get_point_locator(), libMesh::DenseMatrix< T >::get_principal_submatrix(), libMesh::EquationSystems::get_solution(), libMesh::DifferentiableSystem::get_time_solver(), libMesh::Parallel::Communicator::get_unique_tag(), libMesh::MeshData::get_unv_header(), libMesh::System::get_vector(), libMesh::NumericVector< T >::global_relative_compare(), libMesh::MeshFunction::gradient(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::MeshData::has_data(), libMesh::MeshRefinement::has_topological_neighbor(), libMesh::XdrSOLN::header(), libMesh::XdrMESH::header(), libMesh::MeshFunction::hessian(), libMesh::DofMap::heterogenously_constrain_element_matrix_and_vector(), libMesh::Parallel::Histogram< KeyType, IdxType >::Histogram(), libMesh::StatisticsVector< T >::histogram(), libMesh::DofObject::id(), libMesh::AdaptiveTimeSolver::init(), libMesh::AnalyticFunction< Output >::init(), libMesh::PointLocatorTree::init(), libMesh::PointLocatorList::init(), libMesh::MeshFunction::init(), libMesh::EigenSparseMatrix< T >::init(), libMesh::EpetraMatrix< T >::init(), libMesh::LaspackMatrix< T >::init(), libMesh::DistributedVector< T >::init(), libMesh::PetscMatrix< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::init(), libMesh::DifferentiableSystem::init_data(), libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_face_shape_functions(), libMesh::ImplicitSystem::init_matrices(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_radial_shape_functions(), libMesh::FE< Dim, T >::init_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_shape_functions(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEXYZ< Dim >::init_shape_functions(), libMesh::ParmetisPartitioner::initialize(), libMesh::ContinuationSystem::initialize_tangent(), libMesh::EpetraVector< T >::inputValues(), libMesh::TreeNode< N >::insert(), libMesh::DistributedVector< T >::insert(), libMesh::LaspackVector< T >::insert(), libMesh::EigenSparseVector< T >::insert(), libMesh::MeshData::insert_elem_data(), libMesh::MeshData::insert_node_data(), libMesh::FEMContext::interior_curl(), libMesh::FEMContext::interior_div(), libMesh::FEMContext::interior_gradient(), libMesh::FEMContext::interior_hessian(), libMesh::Elem::interior_parent(), libMesh::FEMContext::interior_value(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::ErrorVector::is_active_elem(), libMesh::SystemNorm::is_discrete(), libMesh::SparsityPattern::Build::join(), libMesh::DistributedVector< T >::l1_norm(), libMesh::LaspackVector< T >::l1_norm(), libMesh::EigenSparseVector< T >::l1_norm(), libMesh::EpetraVector< T >::l1_norm(), libMesh::PetscVector< T >::l1_norm(), libMesh::EpetraMatrix< T >::l1_norm(), libMesh::DenseMatrix< T >::l1_norm(), libMesh::PetscMatrix< T >::l1_norm(), libMesh::DistributedVector< T >::l2_norm(), libMesh::LaspackVector< T >::l2_norm(), libMesh::EigenSparseVector< T >::l2_norm(), libMesh::EpetraVector< T >::l2_norm(), libMesh::PetscVector< T >::l2_norm(), libMesh::DistributedVector< T >::last_local_index(), libMesh::LaspackVector< T >::last_local_index(), libMesh::EigenSparseVector< T >::last_local_index(), libMesh::EpetraVector< T >::last_local_index(), libMesh::PetscVector< T >::last_local_index(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::Elem::libmesh_assert_valid_node_pointers(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::DistributedVector< T >::linfty_norm(), libMesh::LaspackVector< T >::linfty_norm(), libMesh::EigenSparseVector< T >::linfty_norm(), libMesh::EpetraVector< T >::linfty_norm(), libMesh::PetscVector< T >::linfty_norm(), libMesh::EpetraMatrix< T >::linfty_norm(), libMesh::DenseMatrix< T >::linfty_norm(), libMesh::PetscMatrix< T >::linfty_norm(), libMesh::NumericVector< T >::local_relative_compare(), libMesh::DistributedVector< T >::local_size(), libMesh::LaspackVector< T >::local_size(), libMesh::EigenSparseVector< T >::local_size(), libMesh::EpetraVector< T >::local_size(), libMesh::PetscVector< T >::local_size(), libMesh::DofMap::local_variable_indices(), libMesh::DistributedVector< T >::localize(), libMesh::LaspackVector< T >::localize(), libMesh::EigenSparseVector< T >::localize(), libMesh::EpetraVector< T >::localize(), libMesh::PetscVector< T >::localize(), libMesh::DistributedVector< T >::localize_to_one(), libMesh::EpetraVector< T >::localize_to_one(), libMesh::SumShellMatrix< T >::m(), libMesh::EigenSparseMatrix< T >::m(), libMesh::LaspackMatrix< T >::m(), libMesh::EpetraMatrix< T >::m(), libMesh::PetscMatrix< T >::m(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FE< Dim, T >::map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::PetscVector< T >::map_global_to_local_index(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), libMesh::EpetraMatrix< T >::mat(), libMesh::PetscMatrix< T >::mat(), libMesh::DenseVector< T >::max(), libMesh::DistributedVector< T >::max(), libMesh::LaspackVector< T >::max(), libMesh::EigenSparseVector< T >::max(), libMesh::EpetraVector< T >::max(), libMesh::DenseMatrix< T >::max(), libMesh::Parallel::Communicator::max(), libMesh::DofMap::max_constraint_error(), libMesh::Elem::max_descendant_p_level(), libMesh::Parallel::Communicator::maxloc(), libMesh::MeshOutput< MT >::mesh(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshBase::MeshBase(), libMesh::DenseVector< T >::min(), libMesh::DistributedVector< T >::min(), libMesh::LaspackVector< T >::min(), libMesh::EigenSparseVector< T >::min(), libMesh::EpetraVector< T >::min(), libMesh::DenseMatrix< T >::min(), libMesh::Parallel::Communicator::min(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Parallel::Communicator::minloc(), libMesh::SumShellMatrix< T >::n(), libMesh::EigenSparseMatrix< T >::n(), libMesh::LaspackMatrix< T >::n(), libMesh::EpetraMatrix< T >::n(), libMesh::PetscMatrix< T >::n(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::MeshData::n_elem_data(), libMesh::MeshBase::n_elem_on_proc(), libMesh::FrequencySystem::n_frequencies(), libMesh::MeshData::n_node_data(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::QBase::n_points(), libMesh::FE< Dim, T >::n_quadrature_points(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_quadrature_points(), libMesh::MeshData::n_val_per_elem(), libMesh::MeshData::n_val_per_node(), libMesh::PeriodicBoundaries::neighbor(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::nodal_soln(), libMesh::FE< Dim, T >::nodal_soln(), libMesh::Elem::node(), libMesh::SerialMesh::node(), libMesh::ParallelMesh::node(), libMesh::TetGenIO::node_in(), libMesh::UNVIO::node_in(), libMesh::UNVIO::node_out(), libMesh::SerialMesh::node_ptr(), libMesh::ParallelMesh::node_ptr(), libMesh::MeshData::node_to_foreign_id(), libMesh::DofMap::old_dof_indices(), on_command_line(), libMesh::Xdr::open(), libMesh::Predicates::abstract_multi_predicate< T >::operator()(), libMesh::WrappedFunction< Output >::operator()(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::AnalyticFunction< Output >::operator()(), libMesh::PointLocatorList::operator()(), libMesh::PointLocatorTree::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::MeshData::operator()(), libMesh::EigenSparseMatrix< T >::operator()(), libMesh::LaspackMatrix< T >::operator()(), libMesh::EpetraMatrix< T >::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::DistributedVector< T >::operator()(), libMesh::LaspackVector< T >::operator()(), libMesh::EigenSparseVector< T >::operator()(), Pred< IterType, PredType >::operator()(), libMesh::EpetraVector< T >::operator()(), libMesh::PetscMatrix< T >::operator()(), libMesh::DistributedVector< T >::operator+=(), libMesh::LaspackVector< T >::operator+=(), libMesh::EigenSparseVector< T >::operator+=(), libMesh::EpetraVector< T >::operator+=(), libMesh::PetscVector< T >::operator+=(), libMesh::DistributedVector< T >::operator-=(), libMesh::LaspackVector< T >::operator-=(), libMesh::EigenSparseVector< T >::operator-=(), libMesh::EpetraVector< T >::operator-=(), libMesh::PetscVector< T >::operator-=(), libMesh::EigenSparseVector< T >::operator/=(), libMesh::EpetraVector< T >::operator/=(), libMesh::Xdr::operator<<(), libMesh::DistributedVector< T >::operator=(), libMesh::LaspackVector< T >::operator=(), libMesh::EigenSparseVector< T >::operator=(), libMesh::PetscVector< T >::operator=(), libMesh::Xdr::operator>>(), libMesh::vectormap< dof_id_type, dof_id_type >::operator[](), libMesh::Hex::opposite_node(), libMesh::Quad::opposite_node(), libMesh::Edge::opposite_node(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::ParsedFunction< Output >::ParsedFunction(), libMesh::Elem::point(), libMesh::SerialMesh::point(), libMesh::ParallelMesh::point(), libMesh::FEMContext::point_curl(), libMesh::FEMContext::point_gradient(), libMesh::System::point_gradient(), libMesh::FEMContext::point_hessian(), libMesh::System::point_hessian(), libMesh::MeshBase::point_locator(), libMesh::FEMContext::point_value(), libMesh::System::point_value(), libMesh::PerfLog::pop(), libMesh::LaspackMatrix< T >::pos(), libMesh::METIS_CSR_Graph::prepare_for_use(), libMesh::MeshBase::prepare_for_use(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::SparseMatrix< T >::print(), libMesh::NumericVector< T >::print(), libMesh::NumericVector< T >::print_global(), libMesh::QBase::print_info(), libMesh::PetscMatrix< T >::print_matlab(), libMesh::PetscVector< T >::print_matlab(), libMesh::EpetraMatrix< T >::print_personal(), libMesh::PetscMatrix< T >::print_personal(), libMesh::DofMap::process_constraints(), libMesh::System::project_vector(), libMesh::ProjectFEMSolution::ProjectFEMSolution(), libMesh::ProjectSolution::ProjectSolution(), libMesh::SerialMesh::query_elem(), libMesh::ParallelMesh::query_elem(), libMesh::SerialMesh::query_node_ptr(), libMesh::ParallelMesh::query_node_ptr(), libMesh::BoundaryInfo::raw_boundary_ids(), libMesh::BoundaryInfo::raw_edge_boundary_ids(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::MeshData::read(), libMesh::PltLoader::read_block_data(), libMesh::CheckpointIO::read_connectivity(), libMesh::PltLoader::read_data(), libMesh::PltLoader::read_feblock_data(), libMesh::PltLoader::read_fepoint_data(), libMesh::PltLoader::read_header(), libMesh::System::read_header(), libMesh::UCDIO::read_implementation(), libMesh::System::read_legacy_data(), libMesh::GmshIO::read_mesh(), libMesh::System::read_parallel_data(), libMesh::PltLoader::read_point_data(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::MeshData::read_unv(), libMesh::MeshData::read_unv_implementation(), libMesh::MeshData::read_xdr(), libMesh::VariationalMeshSmoother::readgr(), libMesh::Parallel::Communicator::receive(), libMesh::MeshTools::Modification::redistribute(), libMesh::Parallel::Communicator::reference_unique_tag(), libMesh::TreeNode< N >::refine(), libMesh::Elem::refine(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::AdaptiveTimeSolver::reinit(), libMesh::DifferentiableSystem::reinit(), libMesh::TimeSolver::reinit(), libMesh::FE< Dim, T >::reinit(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::FESubdivision::reinit(), libMesh::FEXYZ< Dim >::reinit(), libMesh::DofMap::reinit(), REINIT_ERROR(), libMesh::BoundaryInfo::remove(), libMesh::DofMap::remove_adjoint_dirichlet_boundary(), libMesh::DofMap::remove_dirichlet_boundary(), libMesh::BoundaryInfo::remove_edge(), libMesh::BoundaryInfo::remove_side(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::SerialMesh::renumber_elem(), libMesh::ParallelMesh::renumber_elem(), libMesh::SerialMesh::renumber_node(), libMesh::ParallelMesh::renumber_node(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::Elem::replace_child(), libMesh::EpetraMatrix< T >::row_start(), libMesh::PetscMatrix< T >::row_start(), libMesh::EpetraMatrix< T >::row_stop(), libMesh::PetscMatrix< T >::row_stop(), libMesh::DofMap::SCALAR_dof_indices(), libMesh::DistributedVector< T >::scale(), libMesh::LaspackVector< T >::scale(), libMesh::EigenSparseVector< T >::scale(), libMesh::DofMap::scatter_constraints(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Parallel::Communicator::send(), libMesh::EquationSystems::sensitivity_solve(), libMesh::EigenSparseMatrix< T >::set(), libMesh::LaspackMatrix< T >::set(), libMesh::EpetraMatrix< T >::set(), libMesh::PetscMatrix< T >::set(), libMesh::DistributedVector< T >::set(), libMesh::LaspackVector< T >::set(), libMesh::EigenSparseVector< T >::set(), libMesh::Elem::set_child(), libMesh::DofObject::set_dof_number(), libMesh::FrequencySystem::set_frequencies(), libMesh::Elem::set_interior_parent(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::SystemNorm::set_off_diagonal_weight(), libMesh::DofObject::set_old_dof_object(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::SFCPartitioner::set_sfc_type(), libMesh::SystemNorm::set_type(), libMesh::MeshData::set_unv_header(), libMesh::SystemNorm::set_weight(), libMesh::Singleton::setup(), libMesh::FE< Dim, T >::shape(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::Side< SideType, ParentType >::Side(), libMesh::FEMContext::side_gradient(), libMesh::FEMContext::side_hessian(), libMesh::SteadySolver::side_residual(), libMesh::AdaptiveTimeSolver::side_residual(), libMesh::EigenTimeSolver::side_residual(), libMesh::FEMContext::side_value(), libMesh::SideEdge< EdgeType, ParentType >::SideEdge(), libMesh::DistributedVector< T >::size(), libMesh::LaspackVector< T >::size(), libMesh::EigenSparseVector< T >::size(), libMesh::EpetraVector< T >::size(), libMesh::PetscVector< T >::size(), libMesh::MeshData::slim(), libMesh::TwostepTimeSolver::solve(), libMesh::NewtonSolver::solve(), libMesh::CondensedEigenSystem::solve(), libMesh::EigenSystem::solve(), libMesh::TimeSolver::solve(), libMesh::FrequencySystem::solve(), libMesh::PetscLinearSolver< T >::solve(), libMesh::EquationSystems::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::Parallel::StandardType< std::pair< T1, T2 > >::StandardType(), libMesh::MemorySolutionHistory::store(), libMesh::MeshBase::sub_point_locator(), libMesh::DistributedVector< T >::sum(), libMesh::LaspackVector< T >::sum(), libMesh::EigenSparseVector< T >::sum(), libMesh::EpetraVector< T >::sum(), libMesh::PetscVector< T >::sum(), libMesh::Parallel::Communicator::sum(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_dofobject_data_by_xyz(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Parallel::Request::test(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::Elem::top_parent(), libMesh::MeshRefinement::topological_neighbor(), libMesh::MeshData::translate(), libMesh::TreeNode< N >::TreeNode(), libMesh::SystemNorm::type(), libMesh::DofObject::unique_id(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::DofObject::unpack_indexing(), libMesh::Parallel::unpack_range(), libMesh::DofObject::unpackable_indexing_size(), libMesh::UnstructuredMesh::UnstructuredMesh(), libMesh::System::update(), libMesh::ContinuationSystem::update_solution(), libMesh::LaspackMatrix< T >::update_sparsity_pattern(), libMesh::EpetraMatrix< T >::update_sparsity_pattern(), libMesh::EpetraVector< T >::vec(), libMesh::PetscVector< T >::vec(), libMesh::System::vector_name(), libMesh::Edge3::volume(), libMesh::Prism6::volume(), libMesh::Hex8::volume(), libMesh::Parallel::Request::wait(), libMesh::SystemNorm::weight(), libMesh::SystemNorm::weight_sq(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::Elem::which_child_am_i(), libMesh::Elem::which_neighbor_am_i(), libMesh::Elem::which_side_am_i(), libMesh::FroIO::write(), libMesh::ExodusII_IO::write(), libMesh::XdrIO::write(), libMesh::MeshData::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::CheckpointIO::write_bcs(), libMesh::GMVIO::write_binary(), libMesh::CheckpointIO::write_connectivity(), libMesh::Elem::write_connectivity(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::MeshOutput< MT >::write_equation_systems(), libMesh::UCDIO::write_header(), libMesh::System::write_header(), libMesh::UCDIO::write_implementation(), libMesh::UCDIO::write_interior_elems(), libMesh::GmshIO::write_mesh(), libMesh::LegacyXdrIO::write_mesh(), libMesh::UCDIO::write_nodal_data(), libMesh::UCDIO::write_nodes(), libMesh::CheckpointIO::write_nodesets(), libMesh::XdrIO::write_parallel(), libMesh::System::write_parallel_data(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::UCDIO::write_soln(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), libMesh::TypeVector< T >::write_unformatted(), libMesh::TypeTensor< T >::write_unformatted(), libMesh::MeshData::write_unv(), libMesh::MeshData::write_unv_implementation(), libMesh::MeshData::write_xdr(), libMesh::DistributedVector< T >::zero(), libMesh::LaspackVector< T >::zero(), libMesh::EigenSparseVector< T >::zero(), libMesh::EpetraVector< T >::zero(), libMesh::PetscVector< T >::zero(), libMesh::EpetraMatrix< T >::zero(), libMesh::PetscMatrix< T >::zero(), and libMesh::PetscMatrix< T >::zero_rows()\&.
.SS "libMesh::libmesh_assert_greater (libMeshPrivateData::_n_processors, 0)"

.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::CentroidPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::Sphere::above_surface(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::Sphere::below_surface(), libMesh::Sphere::closest_point(), libMesh::QGrundmann_Moller::compose_all(), libMesh::FEMap::compute_edge_map(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::DofMap::constrain_p_dofs(), libMesh::Sphere::create_from_center_radius(), libMesh::Sphere::distance(), libMesh::PltLoader::elem_type(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::FEMContext::fixed_interior_hessian(), libMesh::FEMContext::fixed_interior_value(), libMesh::FEMContext::fixed_point_gradient(), libMesh::FEMContext::fixed_point_hessian(), libMesh::FEMContext::fixed_point_value(), libMesh::FEMContext::fixed_side_gradient(), libMesh::FEMContext::fixed_side_hessian(), libMesh::FEMContext::fixed_side_value(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::DofMap::get_adjoint_dirichlet_boundaries(), libMesh::PerfLog::get_info_header(), libMesh::EigenSparseMatrix< T >::init(), libMesh::MeshFunction::init(), libMesh::FrequencySystem::init_data(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEMContext::interior_curl(), libMesh::FEMContext::interior_div(), libMesh::FEMContext::interior_gradient(), libMesh::FEMContext::interior_gradients(), libMesh::FEMContext::interior_hessian(), libMesh::FEMContext::interior_hessians(), libMesh::FEMContext::interior_value(), libMesh::FEMContext::interior_values(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::DistributedVector< T >::localize(), libMesh::EpetraVector< T >::localize(), libMesh::FESubdivision::loop_subdivision_mask(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Tri3::min_and_max_angle(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::PltLoader::n_elem(), libMesh::PltLoader::n_nodes(), libMesh::DofMap::old_dof_indices(), libMesh::Sphere::on_surface(), libMesh::METIS_CSR_Graph::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ParameterVector::operator[](), libMesh::FEMContext::point_curl(), libMesh::FEMContext::point_gradient(), libMesh::FEMContext::point_hessian(), libMesh::Elem::point_test(), libMesh::FEMContext::point_value(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::MatlabIO::read_stream(), libMesh::DofMap::remove_adjoint_dirichlet_boundary(), libMesh::QBase::scale(), libMesh::FrequencySystem::set_frequencies_by_range(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FEMContext::side_gradient(), libMesh::FEMContext::side_gradients(), libMesh::FEMContext::side_hessian(), libMesh::FEMContext::side_hessians(), libMesh::FEMContext::side_value(), libMesh::FEMContext::side_values(), libMesh::VariationalMeshSmoother::smooth(), libMesh::FrequencySystem::solve(), libMesh::Sphere::Sphere(), libMesh::Sphere::unit_normal(), and libMesh::PostscriptIO::write()\&.
.SS "template<typename Tnew , typename Told > Tnew libMesh::libmesh_cast_int (Toldoldvar)\fC [inline]\fP"

.PP
Definition at line 484 of file libmesh_common\&.h\&.
.PP
.nf
485 {
486   libmesh_assert_equal_to
487     (oldvar, static_cast<Told>(static_cast<Tnew>(oldvar)));
488 
489   return(static_cast<Tnew>(oldvar));
490 }
.fi
.SS "template<typename Tnew , typename Told > Tnew libMesh::libmesh_cast_ptr (Told *oldvar)\fC [inline]\fP"

.PP
Definition at line 455 of file libmesh_common\&.h\&.
.PP
References err, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::Parameters::have_parameter()\&.
.PP
.nf
456 {
457 #if !defined(NDEBUG) && defined(LIBMESH_HAVE_RTTI)
458   Tnew newvar = dynamic_cast<Tnew>(oldvar);
459   if (!newvar)
460     {
461       libMesh::err << "Failed to convert " << typeid(Told)\&.name()
462                    << " pointer to " << typeid(Tnew)\&.name()
463                    << std::endl;
464       libMesh::err << "The " << typeid(Told)\&.name()
465                    << " appears to be a "
466                    << typeid(*oldvar)\&.name() << std::endl;
467       libmesh_error();
468     }
469   return newvar;
470 #else
471   return(static_cast<Tnew>(oldvar));
472 #endif
473 }
.fi
.SS "template<typename Tnew , typename Told > Tnew libMesh::libmesh_cast_ref (Told &oldvar)\fC [inline]\fP"

.PP
Definition at line 429 of file libmesh_common\&.h\&.
.PP
References err, and libMesh::Quality::name()\&.
.PP
.nf
430 {
431 #if !defined(NDEBUG) && defined(LIBMESH_HAVE_RTTI)
432   try
433     {
434       Tnew newvar = dynamic_cast<Tnew>(oldvar);
435       return newvar;
436     }
437   catch (std::bad_cast)
438     {
439       libMesh::err << "Failed to convert " << typeid(Told)\&.name()
440                    << " reference to " << typeid(Tnew)\&.name()
441                    << std::endl;
442       libMesh::err << "The " << typeid(Told)\&.name()
443                    << " appears to be a "
444                    << typeid(*(&oldvar))\&.name() << std::endl;
445       libmesh_error();
446     }
447 #else
448   return(static_cast<Tnew>(oldvar));
449 #endif
450 }
.fi
.SS "template<typename T > T libMesh::libmesh_conj (Ta)\fC [inline]\fP"

.PP
Definition at line 150 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::DistributedVector< T >::conjugate(), libMesh::LaspackVector< T >::conjugate(), and libMesh::DenseVector< T >::dot()\&.
.PP
.nf
150 { return a; }
.fi
.SS "template<typename T > std::complex<T> libMesh::libmesh_conj (std::complex< T >a)\fC [inline]\fP"

.PP
Definition at line 156 of file libmesh_common\&.h\&.
.PP
.nf
156 { return std::conj(a); }
.fi
.SS "\fBPetscErrorCode\fP Vec Mat libMesh::libmesh_dbg_var (j)"

.SS "template<class T > void libMesh::libmesh_ignore (const T &)\fC [inline]\fP"

.PP
Definition at line 530 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::PetscMatrix< T >::init()\&.
.PP
.nf
530 { }
.fi
.SS "bool libMesh::libmesh_isnan (floata)\fC [inline]\fP"

.PP
Definition at line 160 of file libmesh_common\&.h\&.
.PP
References libmesh_C_isnan_float()\&.
.PP
Referenced by libmesh_isnan(), libMesh::NewtonSolver::line_search(), and libMesh::NewtonSolver::solve()\&.
.PP
.nf
160 { return libmesh_C_isnan_float(a); }
.fi
.SS "bool libMesh::libmesh_isnan (doublea)\fC [inline]\fP"

.PP
Definition at line 161 of file libmesh_common\&.h\&.
.PP
References libmesh_C_isnan_double()\&.
.PP
.nf
161 { return libmesh_C_isnan_double(a); }
.fi
.SS "bool libMesh::libmesh_isnan (long doublea)\fC [inline]\fP"

.PP
Definition at line 162 of file libmesh_common\&.h\&.
.PP
References libmesh_C_isnan_longdouble()\&.
.PP
.nf
162 { return libmesh_C_isnan_longdouble(a); }
.fi
.SS "template<typename T > bool libMesh::libmesh_isnan (std::complex< T >a)\fC [inline]\fP"

.PP
Definition at line 165 of file libmesh_common\&.h\&.
.PP
References libmesh_isnan()\&.
.PP
.nf
165 { return (libmesh_isnan(std::real(a)) || libmesh_isnan(std::imag(a))); }
.fi
.SS "libMesh::libmesh_parallel_only (this->comm())"

.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::MeshTools::bounding_box(), libMesh::MeshTools::correct_node_proc_ids(), DMLibMeshSetSystem(), libMesh::LocationMap< T >::init(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshSerializer::MeshSerializer(), libMesh::MeshTools::n_active_levels(), libMesh::MeshTools::n_levels(), libMesh::MeshTools::n_p_levels(), libMesh::Partitioner::partition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_dofobject_data_by_xyz(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshTools::total_weight(), and libMesh::LegacyXdrIO::write_mesh()\&.
.SS "template<typename T > T libMesh::libmesh_real (Ta)\fC [inline]\fP"

.PP
Definition at line 149 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::FEMContext::_do_elem_position_set(), libMesh::ContinuationSystem::continuation_solve(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::DenseVector< T >::max(), libMesh::DistributedVector< T >::max(), libMesh::LaspackVector< T >::max(), libMesh::EigenSparseVector< T >::max(), libMesh::DenseMatrix< T >::max(), libMesh::DenseVector< T >::min(), libMesh::DistributedVector< T >::min(), libMesh::LaspackVector< T >::min(), libMesh::EigenSparseVector< T >::min(), libMesh::DenseMatrix< T >::min(), libMesh::FEMSystem::numerical_jacobian(), libMesh::ContinuationSystem::solve_tangent(), libMesh::GmshIO::write_post(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
149 { return a; }
.fi
.SS "template<typename T > T libMesh::libmesh_real (std::complex< T >a)\fC [inline]\fP"

.PP
Definition at line 153 of file libmesh_common\&.h\&.
.PP
.nf
153 { return std::real(a); }
.fi
.SS "void libMesh::libmesh_terminate_handler ()"

.PP
Definition at line 265 of file libmesh\&.C\&.
.PP
References GLOBAL_COMM_WORLD, old_terminate_handler, and write_traceout()\&.
.PP
.nf
266 {
267   // If this got called then we're probably crashing; let's print a
268   // stack trace\&.  The trace files that are ultimately written depend on:
269   // 1\&.) Who throws the exception\&.
270   // 2\&.) Whether the C++ runtime unwinds the stack before the
271   //     terminate_handler is called (this is implementation defined)\&.
272   //
273   // The various cases are summarized in the table below:
274   //
275   //                        | libmesh exception | other exception
276   //                        -------------------------------------
277   // stack unwinds          |        A          |       B
278   // stack does not unwind  |        C          |       D
279   //
280   // Case A: There will be two stack traces in the file: one "useful"
281   //         one, and one nearly empty one due to stack unwinding\&.
282   // Case B: You will get one nearly empty stack trace (not great, Bob!)
283   // Case C: You will get two nearly identical stack traces, ignore one of them\&.
284   // Case D: You will get one useful stack trace\&.
285   //
286   // Cases A and B (where the stack unwinds when an exception leaves
287   // main) appear to be non-existent in practice\&.  I don't have a
288   // definitive list, but the stack does not unwind for GCC on either
289   // Mac or Linux\&.  I think there's good reasons for this behavior too:
290   // it's much easier to get a stack trace when the stack doesn't
291   // unwind, for example\&.
292   libMesh::write_traceout();
293 
294   // If we have MPI and it has been initialized, we need to be sure
295   // and call MPI_Abort instead of std::abort, so that the parallel
296   // job can die nicely\&.
297 #if defined(LIBMESH_HAVE_MPI)
298   int mpi_initialized;
299   MPI_Initialized (&mpi_initialized);
300 
301   if (mpi_initialized)
302     MPI_Abort(libMesh::GLOBAL_COMM_WORLD, 1);
303   else
304 #endif
305     // The system terminate_handler may do useful things like printing
306     // uncaught exception information, or the user may have created
307     // their own terminate handler that we want to call\&.
308     old_terminate_handler();
309 }
.fi
.SS "void libMesh::libmesh_version_stdout ()"

.PP
Definition at line 20 of file libmesh_version\&.C\&.
.PP
References get_libmesh_version()\&.
.PP
.nf
21 {
22   std::cout << "--------------------------------------------------------" << std::endl;
23   std::cout << "libMesh Library: Version = " << LIBMESH_LIB_VERSION;
24   std::cout << " (" << get_libmesh_version() << ")" << std::endl << std::endl;
25 
26   std::cout << LIBMESH_LIB_RELEASE << std::endl << std::endl;
27 
28   std::cout << "Build Date   = " << LIBMESH_BUILD_DATE     << std::endl;
29   std::cout << "Build Host   = " << LIBMESH_BUILD_HOST     << std::endl;
30   std::cout << "Build User   = " << LIBMESH_BUILD_USER     << std::endl;
31   std::cout << "Build Arch   = " << LIBMESH_BUILD_ARCH     << std::endl;
32   std::cout << "Build Rev    = " << LIBMESH_BUILD_VERSION  << std::endl << std::endl;
33 
34   // CXXFLAGS is ambiguous wth multiple methods - could add all three but why not libmesh-config?
35   //std::cout << "C++ Config   = " << LIBMESH_CXX << " " << LIBMESH_CXXFLAGS << std::endl;
36   std::cout << "--------------------------------------------------------" << std::endl;
37 
38   return;
39 }
.fi
.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, int, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, float, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, double, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, int, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, int, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, int, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, float, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, float, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, float, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, std::complex< float >, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, std::complex< float >, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, std::complex< float >, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, double, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, double, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, double, Real)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Real, std::complex< double >, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, std::complex< double >, Complex)"

.SS "libMesh::LIBMESH_VMA_INSTANTIATE (Complex, std::complex< double >, Real)"

.SS "template void \fBlibMesh::MeshCommunication::find_global_indices\fP< \fBMeshBase::const_element_iterator\fP > (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::const_element_iterator\fP &, const \fBMeshBase::const_element_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const"

.SS "template void \fBlibMesh::MeshCommunication::find_global_indices\fP< \fBMeshBase::const_node_iterator\fP > (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::const_node_iterator\fP &, const \fBMeshBase::const_node_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const"

.SS "template void \fBlibMesh::MeshCommunication::find_global_indices\fP< \fBMeshBase::element_iterator\fP > (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::element_iterator\fP &, const \fBMeshBase::element_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const"

.SS "template void \fBlibMesh::MeshCommunication::find_global_indices\fP< \fBMeshBase::node_iterator\fP > (const \fBParallel::Communicator\fP &, const \fBMeshTools::BoundingBox\fP &, const \fBMeshBase::node_iterator\fP &, const \fBMeshBase::node_iterator\fP &, std::vector< \fBdof_id_type\fP > &) const"

.SS "\fBlibMesh::processor_id_type\fP libMesh::n_processors ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors used in the current simulation\&. 
.RE
.PP

.PP
Definition at line 88 of file libmesh_base\&.h\&.
.PP
References global_n_processors()\&.
.PP
Referenced by libMesh::DofMap::add_constraints_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::AztecLinearSolver< T >::clear(), libMesh::PetscLinearSolver< T >::clear(), libMesh::DistributedVector< T >::init(), libMesh::PetscVector< T >::localize(), libMesh::EpetraVector< T >::localize_to_one(), libMesh::PetscVector< T >::localize_to_one(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::SparseMatrix< T >::print(), libMesh::DofMap::print_dof_constraints(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::DofMap::scatter_constraints(), libMesh::Parallel::Sort< KeyType, IdxType >::sort(), libMesh::Parallel::unpack(), and libMesh::VTKIO::write_nodal_data()\&.
.PP
.nf
89 {
90   return libMesh::global_n_processors();
91 }
.fi
.SS "unsigned int libMesh::n_threads ()"

.PP
\fBReturns:\fP
.RS 4
the maximum number of threads used in the simulation\&. 
.RE
.PP

.SS "libMesh::omp_set_num_threads (\fBlibMesh::libMeshPrivateData::_n_threads\fP)"

.SS "bool libMesh::on_command_line (const std::string &arg)"

.PP
\fBReturns:\fP
.RS 4
true if the argument \fCarg\fP was specified on the command line, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 756 of file libmesh\&.C\&.
.PP
References EXTERN_C_FOR_PETSC_END::command_line, and libmesh_assert()\&.
.PP
Referenced by libMesh::NonlinearSolver< T >::build(), libMesh::ContinuationSystem::ContinuationSystem(), default_solver_package(), libMesh::DofMap::distribute_dofs(), libMesh::ImplicitSystem::get_linear_solver(), if(), libMesh::NewtonSolver::init(), libMesh::PetscDiffSolver::init(), libMesh::TimeSolver::init_data(), petsc_auto_fieldsplit(), libMesh::System::read_header(), libMesh::TimeSolver::reinit(), libMesh::LinearImplicitSystem::solve(), libMesh::NonlinearImplicitSystem::solve(), and libMesh::DofMap::use_coupled_neighbor_dofs()\&.
.PP
.nf
757 {
758   // Make sure the command line parser is ready for use
759   libmesh_assert(command_line\&.get());
760 
761   return command_line->search (arg);
762 }
.fi
.SS "template<typename T , typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeVector\fP<typename \fBCompareTypes\fP<T, Scalar>::supertype> >::type libMesh::operator* (const Scalarfactor, const TypeVector< T > &v)\fC [inline]\fP"

.PP
Definition at line 679 of file type_vector\&.h\&.
.PP
.nf
681 {
682   return v * factor;
683 }
.fi
.SS "template<typename T , typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeTensor\fP<typename \fBCompareTypes\fP<T, Scalar>::supertype> >::type libMesh::operator* (const Scalarfactor, const TypeTensor< T > &t)\fC [inline]\fP"

.PP
Definition at line 869 of file type_tensor\&.h\&.
.PP
.nf
871 {
872   return t * factor;
873 }
.fi
.SS "template<typename T > std::ostream & libMesh::operator<< (std::ostream &os, const SparseMatrix< T > &m)"
Same as the print method above, but allows you to print to a stream in the standard syntax\&.
.PP
template <typename u>=''> friend std::ostream& operator << (std::ostream& os, const SparseMatrix<U>& m);
.PP
Obscure C++ note 1: the above syntax, which does not require any prior declaration of operator<<, declares \fIany\fP instantiation of SparseMatrix<X> is friend to \fIany\fP instantiation of operator<<(ostream&, SparseMatrix<Y>&)\&. It would not happen in practice, but in principle it means that SparseMatrix<Complex> would be friend to operator<<(ostream&, SparseMatrix<Real>)\&.
.PP
Obscure C++ note 2: The form below, which requires a previous declaration of the operator<<(stream&, SparseMatrix<T>&) function (see top of this file), means that any instantiation of SparseMatrix<T> is friend to the specialization operator<<(ostream&, SparseMatrix<T>&), but e\&.g\&. SparseMatrix<U> is \fInot\fP friend to the same function\&. So this is slightly different to the form above\&.\&.\&.
.PP
This method seems to be the 'preferred' technique, see http://www.parashift.com/c++-faq-lite/template-friends.html 
.PP
Definition at line 456 of file sparse_matrix\&.h\&.
.PP
.nf
457 {
458   m\&.print(os);
459   return os;
460 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const QBase &q)"
Same as above, but allows you to use the stream syntax\&. 
.PP
Definition at line 197 of file quadrature\&.C\&.
.PP
References libMesh::QBase::print_info()\&.
.PP
.nf
198 {
199   q\&.print_info(os);
200   return os;
201 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const Node &n)\fC [inline]\fP"

.PP
Definition at line 271 of file node\&.h\&.
.PP
References libMesh::Node::print_info()\&.
.PP
.nf
272 {
273   n\&.print_info(os);
274   return os;
275 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const MeshBase &m)"
Equivalent to calling print_info() above, but now you can write: \fBMesh\fP mesh; \fBlibMesh::out\fP << mesh << std::endl; 
.PP
Definition at line 337 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::print_info()\&.
.PP
.nf
338 {
339   m\&.print_info(os);
340   return os;
341 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const MeshData &m)"
Same as above, but allows you to use the stream syntax\&. 
.PP
Definition at line 374 of file mesh_data\&.C\&.
.PP
References libMesh::MeshData::print_info()\&.
.PP
.nf
375 {
376   m\&.print_info(os);
377   return os;
378 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const Parameters &p)\fC [inline]\fP"

.PP
Definition at line 404 of file parameters\&.h\&.
.PP
References libMesh::Parameters::print()\&.
.PP
.nf
405 {
406   p\&.print(os);
407   return os;
408 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const FEAbstract &fe)"
Same as above, but allows you to print to a stream\&. 
.PP
Definition at line 943 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_info()\&.
.PP
.nf
944 {
945   fe\&.print_info(os);
946   return os;
947 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const EquationSystems &es)"
Same as above, but allows you to also use stream syntax\&. 
.PP
Definition at line 1255 of file equation_systems\&.C\&.
.PP
References libMesh::EquationSystems::print_info()\&.
.PP
.nf
1256 {
1257   es\&.print_info(os);
1258   return os;
1259 }
.fi
.SS "std::ostream& libMesh::operator<< (std::ostream &os, const Elem &e)\fC [inline]\fP"

.PP
Definition at line 1257 of file elem\&.h\&.
.PP
References libMesh::Elem::print_info()\&.
.PP
.nf
1258 {
1259   e\&.print_info(os);
1260   return os;
1261 }
.fi
.SS "command_line libMesh::parse_command_line (argc, argv)"

.SS "\fBPetscMatrix\fP<\fBNumber\fP> \fBJ_input\fP* libMesh::pc ()"

.SS "\fBPetscMatrix\fP<\fBNumber\fP> libMesh::PC (\fBpc\fP, sys\&.comm())"

.PP
Referenced by libMesh::PetscDiffSolver::init(), and libMesh::PetscDiffSolver::reinit()\&.
.SS "void libMesh::petsc_auto_fieldsplit (PCmy_pc, const System &sys)"

.PP
Definition at line 59 of file petsc_auto_fieldsplit\&.C\&.
.PP
References libMesh::ParallelObject::comm(), command_line_value(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), EXTERN_C_FOR_PETSC_END::indices_to_fieldsplit(), libMesh::DofMap::local_variable_indices(), libMesh::System::n_vars(), libMesh::System::name(), on_command_line(), and libMesh::System::variable_name()\&.
.PP
Referenced by libMesh::PetscDiffSolver::init(), libMesh::PetscLinearSolver< T >::init_names(), and libMesh::PetscDiffSolver::reinit()\&.
.PP
.nf
61 {
62   std::string sys_prefix = "--solver_group_";
63 
64   if (libMesh::on_command_line("--solver_system_names"))
65     {
66       sys_prefix = sys_prefix + sys\&.name() + "_";
67     }
68 
69   std::map<std::string, std::vector<dof_id_type> > group_indices;
70 
71   if (libMesh::on_command_line("--solver_variable_names"))
72     {
73       for (unsigned int v = 0; v != sys\&.n_vars(); ++v)
74         {
75           const std::string& var_name = sys\&.variable_name(v);
76 
77           std::vector<dof_id_type> var_idx;
78           sys\&.get_dof_map()\&.local_variable_indices
79             (var_idx, sys\&.get_mesh(), v);
80 
81           std::string group_command = sys_prefix + var_name;
82 
83           const std::string empty_string;
84 
85           std::string group_name = libMesh::command_line_value
86             (group_command, empty_string);
87 
88           if (group_name != empty_string)
89             {
90               std::vector<dof_id_type> &indices =
91                 group_indices[group_name];
92               const bool prior_indices = !indices\&.empty();
93               indices\&.insert(indices\&.end(), var_idx\&.begin(),
94                              var_idx\&.end());
95               if (prior_indices)
96                 std::sort(indices\&.begin(), indices\&.end());
97             }
98           else
99             {
100               indices_to_fieldsplit (sys\&.comm(), var_idx, my_pc, var_name);
101             }
102         }
103     }
104 
105   for (std::map<std::string, std::vector<dof_id_type> >::const_iterator
106          i = group_indices\&.begin(); i != group_indices\&.end(); ++i)
107     {
108       indices_to_fieldsplit(sys\&.comm(), i->second, my_pc, i->first);
109     }
110 }
.fi
.SS "void libMesh::PetscDMGetSystem (DM, NonlinearImplicitSystem *&)"

.SS "void libMesh::PetscDMRegister ()"

.PP
Definition at line 51 of file petsc_dm_nonlinear_solver\&.C\&.
.PP
References CHKERRABORT(), DMCreate_libMesh(), GLOBAL_COMM_WORLD, ierr, and PetscDMRegistered\&.
.PP
Referenced by libMesh::PetscDMNonlinearSolver< T >::PetscDMNonlinearSolver()\&.
.PP
.nf
52 {
53   if (PetscDMRegistered)
54     return;
55 
56   PetscErrorCode ierr;
57 #if PETSC_RELEASE_LESS_THAN(3,4,0)
58   ierr = DMRegister(DMLIBMESH, PETSC_NULL, "DMCreate_libMesh", DMCreate_libMesh); CHKERRABORT(libMesh::GLOBAL_COMM_WORLD,ierr);
59 #else
60   ierr = DMRegister(DMLIBMESH, DMCreate_libMesh); CHKERRABORT(libMesh::GLOBAL_COMM_WORLD,ierr);
61 #endif
62   PetscDMRegistered = PETSC_TRUE;
63 }
.fi
.SS "void libMesh::PetscDMSetSystem (DM, NonlinearImplicitSystem &)"

.SS "libMesh::PetscObjectGetComm ((PetscObject)pc, &comm)"

.PP
Referenced by libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), and libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type()\&.
.SS "template<typename P > void libMesh::print_helper (std::ostream &os, const P *param)"
Helper functions for printing scalar and vector types\&. Called from \fBParameters::Parameter<T>::print\fP(\&.\&.\&.)\&. 
.PP
Definition at line 539 of file parameters\&.h\&.
.PP
Referenced by libMesh::Parameters::Parameter< T >::print()\&.
.PP
.nf
540 {
541   os << *param;
542 }
.fi
.SS "template<typename P > void libMesh::print_helper (std::ostream &os, const std::vector< P > *param)"

.PP
Definition at line 546 of file parameters\&.h\&.
.PP
.nf
547 {
548   for (unsigned int i=0; i<param->size(); ++i)
549     os << (*param)[i] << " ";
550 }
.fi
.SS "void libMesh::print_trace (std::ostream &out)"

.PP
Definition at line 108 of file print_trace\&.C\&.
.PP
References process_trace()\&.
.PP
Referenced by libMesh::MacroFunctions::report_error(), and write_traceout()\&.
.PP
.nf
109 {
110   void *addresses[40];
111   char **strings;
112 
113   int size = backtrace(addresses, 40);
114   strings = backtrace_symbols(addresses, size);
115   out << "Stack frames: " << size << std::endl;
116   for(int i = 0; i < size; i++)
117     out << i << ": " << process_trace(strings[i]) << std::endl;
118   std::free(strings);
119 }
.fi
.SS "std::string libMesh::process_trace (const char *name)"
The Apple backtrace function returns more information than the Linux version\&. We need to pass only the function name to the demangler or it won't decode it for us\&.
.PP
lineno: stackframeno address functionname + offset
.PP
Definition at line 47 of file print_trace\&.C\&.
.PP
References demangle(), and libMesh::Quality::name()\&.
.PP
Referenced by print_trace()\&.
.PP
.nf
48 {
49   std::string fullname = name;
50   std::string saved_begin, saved_end;
51   size_t namestart, nameend;
52 
60 #ifdef __APPLE__
61   namestart = fullname\&.find("0x");
62   if (namestart != std::string::npos)
63     {
64       namestart = fullname\&.find(' ', namestart) + 1;
65       saved_begin = fullname\&.substr(0, namestart);
66     }
67   else
68     namestart = 0;
69   nameend = fullname\&.find('+');
70   if (nameend == std::string::npos ||
71       nameend <= namestart)
72     nameend = fullname\&.size();
73   else
74     {
75       nameend -= 1;
76       saved_end = fullname\&.substr(nameend, fullname\&.length());
77     }
78 #else
79   namestart = fullname\&.find('(');
80   if (namestart == std::string::npos)
81     return fullname;
82   else
83     namestart++;
84   nameend = fullname\&.find('+');
85   if (nameend == std::string::npos ||
86       nameend <= namestart)
87     return fullname;
88 #endif
89 
90   std::string type_name = fullname\&.substr(namestart, nameend - namestart);
91 
92   // Try to demangle now
93   return saved_begin + demangle(type_name\&.c_str()) + saved_end;
94 }
.fi
.SS "\fBlibMesh::processor_id_type\fP libMesh::processor_id ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the local processor\&. 
.RE
.PP

.PP
Definition at line 96 of file libmesh_base\&.h\&.
.PP
References global_processor_id()\&.
.PP
Referenced by libMesh::DofMap::allgather_recursive_constraints(), libMesh::DofMap::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::DistributedVector< T >::init(), libMesh::PetscMatrix< T >::init(), libMesh::SparsityPattern::Build::join(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::PetscVector< T >::localize_to_one(), libMesh::MeshInput< MT >::MeshInput(), libMesh::MeshOutput< MT >::MeshOutput(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::SparseMatrix< T >::print(), libMesh::DofMap::print_dof_constraints(), libMesh::NumericVector< T >::print_global(), libMesh::PetscMatrix< T >::print_personal(), libMesh::TetGenIO::read(), libMesh::GMVIO::read(), libMesh::LegacyXdrIO::read(), libMesh::VTKIO::read(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::DofMap::scatter_constraints(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::VTKIO::system_vectors_to_vtk(), libMesh::Parallel::unpack(), libMesh::EpetraMatrix< T >::update_sparsity_pattern(), libMesh::FroIO::write(), libMesh::TecplotIO::write(), libMesh::PostscriptIO::write(), libMesh::MEDITIO::write(), libMesh::GmshIO::write(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::TecplotIO::write_nodal_data(), libMesh::MEDITIO::write_nodal_data(), libMesh::VTKIO::write_nodal_data(), libMesh::GmshIO::write_nodal_data(), libMesh::GmshIO::write_post(), and libMesh::GnuPlotIO::write_solution()\&.
.PP
.nf
97 {
98   return libMesh::global_processor_id();
99 }
.fi
.SS "this libMesh::reduce_error (error_per_cell, system\&.comm())"

.SS "libMesh::REINIT_ERROR (REINIT_ERROR(0, REINIT_ERROR(CLOUGH, reinit)"

.PP
Definition at line 76 of file fe_boundary\&.C\&.
.PP
References libMesh::Elem::build_side(), libmesh_assert(), std::max(), libMesh::Elem::neighbor(), libMesh::Elem::p_level(), side, and libMesh::Elem::type()\&.
.PP
.nf
145 {
146   libmesh_assert(elem);
147   libmesh_assert (this->qrule != NULL || pts != NULL);
148   // We now do this for 1D elements!
149   // libmesh_assert_not_equal_to (Dim, 1);
150 
151   // Build the side of interest
152   const AutoPtr<Elem> side(elem->build_side(s));
153 
154   // Find the max p_level to select
155   // the right quadrature rule for side integration
156   unsigned int side_p_level = elem->p_level();
157   if (elem->neighbor(s) != NULL)
158     side_p_level = std::max(side_p_level, elem->neighbor(s)->p_level());
159 
160   // Initialize the shape functions at the user-specified
161   // points
162   if (pts != NULL)
163     {
164       // The shape functions do not correspond to the qrule
165       this->shapes_on_quadrature = false;
166 
167       // Initialize the face shape functions
168       this->_fe_map->template init_face_shape_functions<Dim>(*pts, side\&.get());
169 
170       // Compute the Jacobian*Weight on the face for integration
171       if (weights != NULL)
172         {
173           this->_fe_map->compute_face_map (Dim, *weights, side\&.get());
174         }
175       else
176         {
177           std::vector<Real> dummy_weights (pts->size(), 1\&.);
178           this->_fe_map->compute_face_map (Dim, dummy_weights, side\&.get());
179         }
180     }
181   // If there are no user specified points, we use the
182   // quadrature rule
183   else
184     {
185       // initialize quadrature rule
186       this->qrule->init(side->type(), side_p_level);
187 
188       if(this->qrule->shapes_need_reinit())
189         this->shapes_on_quadrature = false;
190 
191       // FIXME - could this break if the same FE object was used
192       // for both volume and face integrals? - RHS
193       // We might not need to reinitialize the shape functions
194       if ((this->get_type() != elem->type())    ||
195           (side->type() != last_side)           ||
196           (this->get_p_level() != side_p_level) ||
197           this->shapes_need_reinit()            ||
198           !this->shapes_on_quadrature)
199         {
200           // Set the element type and p_level
201           this->elem_type = elem->type();
202 
203           // Set the last_side
204           last_side = side->type();
205 
206           // Set the last p level
207           this->_p_level = side_p_level;
208 
209           // Initialize the face shape functions
210           this->_fe_map->template init_face_shape_functions<Dim>(this->qrule->get_points(),  side\&.get());
211         }
212 
213       // Compute the Jacobian*Weight on the face for integration
214       this->_fe_map->compute_face_map (Dim, this->qrule->get_weights(), side\&.get());
215 
216       // The shape functions correspond to the qrule
217       this->shapes_on_quadrature = true;
218     }
219 
220   // make a copy of the Jacobian for integration
221   const std::vector<Real> JxW_int(this->_fe_map->get_JxW());
222 
223   // make a copy of shape on quadrature info
224   bool shapes_on_quadrature_side = this->shapes_on_quadrature;
225 
226   // Find where the integration points are located on the
227   // full element\&.
228   const std::vector<Point>* ref_qp;
229   if (pts != NULL)
230     ref_qp = pts;
231   else
232     ref_qp = &this->qrule->get_points();
233 
234   std::vector<Point> qp;
235   this->side_map(elem, side\&.get(), s, *ref_qp, qp);
236 
237   // compute the shape function and derivative values
238   // at the points qp
239   this->reinit  (elem, &qp);
240 
241   this->shapes_on_quadrature = shapes_on_quadrature_side;
242 
243   // copy back old data
244   this->_fe_map->get_JxW() = JxW_int;
245 }
.fi
.SS "task_scheduler libMesh::reset (new Threads::task_scheduler_initlibMesh::n_threads())"

.SS "error_per_cell libMesh::resize (mesh\&.max_elem_id())"

.PP
Referenced by libMesh::SensitivityData::allocate_hessian_data(), libMesh::TetGenIO::element_in(), libMesh::DenseMatrix< T >::left_multiply(), libMesh::DenseMatrix< T >::left_multiply_transpose(), libMesh::TetGenIO::node_in(), libMesh::DenseMatrix< T >::operator=(), libMesh::FEMContext::pre_fe_reinit(), libMesh::DenseMatrix< T >::right_multiply(), libMesh::DenseMatrix< T >::right_multiply_transpose(), libMesh::PltLoader::set_n_vars(), and libMesh::PltLoader::set_n_zones()\&.
.SS "libMesh::ScalarTraits_true (char)"

.SS "libMesh::ScalarTraits_true (short)"

.SS "libMesh::ScalarTraits_true (int)"

.SS "libMesh::ScalarTraits_true (long)"

.SS "libMesh::ScalarTraits_true (unsignedchar)"

.SS "libMesh::ScalarTraits_true (float)"

.SS "libMesh::ScalarTraits_true (double)"

.SS "template<typename T > T libMesh::SIGN (Ta, Tb)\fC [inline]\fP"

.PP
Definition at line 33 of file newton_solver\&.C\&.
.PP
References std::abs()\&.
.PP
Referenced by libMesh::NewtonSolver::line_search()\&.
.PP
.nf
34 {
35   return b >= 0 ? std::abs(a) : -std::abs(a);
36 }
.fi
.SS "\fBPetscErrorCode\fP Vec Mat Mat void* ctx libMesh::START_LOG ('jacobian()', 'PetscNonlinearSolver')"

.SS "libMesh::START_LOG ('std::sqrt()', 'ExactErrorEstimator')"

.PP
Referenced by __libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::SlepcEigenSolver< T >::_solve_generalized_helper(), libMesh::SlepcEigenSolver< T >::_solve_standard_helper(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::MeshRefinement::add_point(), libMesh::EigenSparseLinearSolver< T >::adjoint_solve(), libMesh::LaspackLinearSolver< T >::adjoint_solve(), libMesh::LinearSolver< T >::adjoint_solve(), libMesh::PetscLinearSolver< T >::adjoint_solve(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::Parallel::Communicator::allgather(), libMesh::Parallel::Communicator::alltoall(), libMesh::FrequencySystem::assemble(), libMesh::System::assemble(), libMesh::FEMSystem::assemble_qoi(), libMesh::System::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::System::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::MeshCommunication::assign_global_indices(), libMesh::Parallel::Communicator::barrier(), libMesh::System::boundary_project_vector(), libMesh::Parallel::Communicator::broadcast(), libMesh::DofMap::build_constraint_matrix(), libMesh::DofMap::build_constraint_matrix_and_vector(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::build_sparsity(), libMesh::System::calculate_norm(), libMesh::PetscDiffSolver::clear(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::combine_base_radial(), libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEXYZ< Dim >::compute_face_values(), libMesh::FEMap::compute_map(), libMesh::FEGenericBase< T >::compute_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_shape_functions(), libMesh::FEXYZ< Dim >::compute_shape_functions(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::DofMap::constrain_element_dyad_matrix(), libMesh::DofMap::constrain_element_matrix(), libMesh::DofMap::constrain_element_matrix_and_vector(), libMesh::DofMap::constrain_element_vector(), libMesh::UnstructuredMesh::contract(), libMesh::UNVIO::count_elements(), libMesh::UNVIO::count_nodes(), libMesh::DofMap::create_dof_constraints(), libMesh::ErrorVector::cut_above(), libMesh::StatisticsVector< T >::cut_above(), libMesh::ErrorVector::cut_below(), libMesh::StatisticsVector< T >::cut_below(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshTools::Modification::distort(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::dof_indices(), libMesh::UNVIO::element_in(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::UniformRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::UniformRefinementEstimator::estimate_errors(), libMesh::LocationMap< T >::find(), libMesh::MeshCommunication::find_global_indices(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Parallel::Communicator::gather(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::DofMap::heterogenously_constrain_element_matrix_and_vector(), libMesh::DofMap::heterogenously_constrain_element_vector(), libMesh::StatisticsVector< T >::histogram(), libMesh::LocationMap< T >::init(), libMesh::PetscDiffSolver::init(), libMesh::PointLocatorTree::init(), libMesh::PointLocatorList::init(), libMesh::FrequencySystem::init_data(), libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_radial_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FE< Dim, T >::init_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_shape_functions(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEXYZ< Dim >::init_shape_functions(), libMesh::NewmarkSystem::initial_conditions(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Parallel::Communicator::max(), libMesh::StatisticsVector< T >::maximum(), libMesh::Parallel::Communicator::maxloc(), libMesh::ErrorVector::mean(), libMesh::StatisticsVector< T >::mean(), libMesh::StatisticsVector< T >::median(), libMesh::Parallel::Communicator::min(), libMesh::ErrorVector::minimum(), libMesh::StatisticsVector< T >::minimum(), libMesh::Parallel::Communicator::minloc(), libMesh::UNVIO::node_in(), libMesh::FEMSystem::numerical_elem_jacobian(), libMesh::FEMSystem::numerical_side_jacobian(), libMesh::DofMap::old_dof_indices(), libMesh::PointLocatorList::operator()(), libMesh::PointLocatorTree::operator()(), libMesh::FEMSystem::postprocess(), libMesh::DofMap::prepare_send_list(), libMesh::Parallel::Communicator::probe(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::MeshData::read(), libMesh::LegacyXdrIO::read_mesh(), libMesh::Parallel::Communicator::receive(), libMesh::MeshTools::Modification::redistribute(), libMesh::FESubdivision::reinit(), libMesh::DofMap::reinit(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::DofMap::SCALAR_dof_indices(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Parallel::Communicator::send(), libMesh::Parallel::Communicator::send_receive(), libMesh::Parallel::Communicator::send_receive_packed_range(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::Partitioner::single_partition(), libMesh::EigenSparseLinearSolver< T >::solve(), libMesh::NewtonSolver::solve(), libMesh::LaspackLinearSolver< T >::solve(), libMesh::PetscDMNonlinearSolver< T >::solve(), libMesh::CondensedEigenSystem::solve(), libMesh::PetscDiffSolver::solve(), libMesh::AztecLinearSolver< T >::solve(), libMesh::PetscNonlinearSolver< T >::solve(), libMesh::FrequencySystem::solve(), libMesh::PetscLinearSolver< T >::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::SerialMesh::stitch_meshes(), libMesh::Parallel::Communicator::sum(), libMesh::BoundaryInfo::sync(), libMesh::MeshData::translate(), libMesh::EquationSystems::update(), libMesh::NewmarkSystem::update_rhs(), libMesh::NewmarkSystem::update_u_v_a(), libMesh::ErrorVector::variance(), libMesh::StatisticsVector< T >::variance(), libMesh::Parallel::Request::wait(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::ImplicitSystem::weighted_sensitivity_solve(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::MeshData::write(), libMesh::EquationSystems::write(), libMesh::MeshOutput< MT >::write_equation_systems(), libMesh::LegacyXdrIO::write_mesh(), libMesh::TecplotIO::write_nodal_data(), libMesh::GnuPlotIO::write_nodal_data(), libMesh::MEDITIO::write_nodal_data(), libMesh::GmshIO::write_nodal_data(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::GMVIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.SS "libMesh::STOP_LOG ('std::sqrt()', 'ExactErrorEstimator')"

.PP
Referenced by __libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::SlepcEigenSolver< T >::_solve_generalized_helper(), libMesh::SlepcEigenSolver< T >::_solve_standard_helper(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::MeshRefinement::add_point(), libMesh::EigenSparseLinearSolver< T >::adjoint_solve(), libMesh::LaspackLinearSolver< T >::adjoint_solve(), libMesh::LinearSolver< T >::adjoint_solve(), libMesh::PetscLinearSolver< T >::adjoint_solve(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::Parallel::Communicator::allgather(), libMesh::Parallel::Communicator::alltoall(), libMesh::FrequencySystem::assemble(), libMesh::System::assemble(), libMesh::FEMSystem::assemble_qoi(), libMesh::System::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::System::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::MeshCommunication::assign_global_indices(), libMesh::Parallel::Communicator::barrier(), libMesh::System::boundary_project_vector(), libMesh::Parallel::Communicator::broadcast(), libMesh::DofMap::build_constraint_matrix(), libMesh::DofMap::build_constraint_matrix_and_vector(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::build_sparsity(), libMesh::System::calculate_norm(), libMesh::PetscDiffSolver::clear(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::combine_base_radial(), libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEXYZ< Dim >::compute_face_values(), libMesh::FEMap::compute_map(), libMesh::FEGenericBase< T >::compute_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_shape_functions(), libMesh::FEXYZ< Dim >::compute_shape_functions(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::DofMap::constrain_element_dyad_matrix(), libMesh::DofMap::constrain_element_matrix(), libMesh::DofMap::constrain_element_matrix_and_vector(), libMesh::DofMap::constrain_element_vector(), libMesh::UnstructuredMesh::contract(), libMesh::UNVIO::count_elements(), libMesh::UNVIO::count_nodes(), libMesh::DofMap::create_dof_constraints(), libMesh::ErrorVector::cut_above(), libMesh::StatisticsVector< T >::cut_above(), libMesh::ErrorVector::cut_below(), libMesh::StatisticsVector< T >::cut_below(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshTools::Modification::distort(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::dof_indices(), libMesh::UNVIO::element_in(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::UniformRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::UniformRefinementEstimator::estimate_errors(), libMesh::LocationMap< T >::find(), libMesh::MeshCommunication::find_global_indices(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Parallel::Communicator::gather(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::DofMap::heterogenously_constrain_element_matrix_and_vector(), libMesh::DofMap::heterogenously_constrain_element_vector(), libMesh::StatisticsVector< T >::histogram(), libMesh::LocationMap< T >::init(), libMesh::PetscDiffSolver::init(), libMesh::PointLocatorTree::init(), libMesh::PointLocatorList::init(), libMesh::FrequencySystem::init_data(), libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_radial_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FE< Dim, T >::init_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_shape_functions(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEXYZ< Dim >::init_shape_functions(), libMesh::NewmarkSystem::initial_conditions(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Parallel::Communicator::max(), libMesh::StatisticsVector< T >::maximum(), libMesh::Parallel::Communicator::maxloc(), libMesh::ErrorVector::mean(), libMesh::StatisticsVector< T >::mean(), libMesh::StatisticsVector< T >::median(), libMesh::Parallel::Communicator::min(), libMesh::ErrorVector::minimum(), libMesh::StatisticsVector< T >::minimum(), libMesh::Parallel::Communicator::minloc(), libMesh::UNVIO::node_in(), libMesh::FEMSystem::numerical_elem_jacobian(), libMesh::FEMSystem::numerical_side_jacobian(), libMesh::DofMap::old_dof_indices(), libMesh::PointLocatorList::operator()(), libMesh::PointLocatorTree::operator()(), libMesh::FEMSystem::postprocess(), libMesh::DofMap::prepare_send_list(), libMesh::Parallel::Communicator::probe(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::MeshData::read(), libMesh::LegacyXdrIO::read_mesh(), libMesh::Parallel::Communicator::receive(), libMesh::MeshTools::Modification::redistribute(), libMesh::FESubdivision::reinit(), libMesh::DofMap::reinit(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::DofMap::SCALAR_dof_indices(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Parallel::Communicator::send(), libMesh::Parallel::Communicator::send_receive(), libMesh::Parallel::Communicator::send_receive_packed_range(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::Partitioner::single_partition(), libMesh::EigenSparseLinearSolver< T >::solve(), libMesh::NewtonSolver::solve(), libMesh::LaspackLinearSolver< T >::solve(), libMesh::PetscDMNonlinearSolver< T >::solve(), libMesh::CondensedEigenSystem::solve(), libMesh::PetscDiffSolver::solve(), libMesh::AztecLinearSolver< T >::solve(), libMesh::PetscNonlinearSolver< T >::solve(), libMesh::FrequencySystem::solve(), libMesh::PetscLinearSolver< T >::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::SerialMesh::stitch_meshes(), libMesh::Parallel::Communicator::sum(), libMesh::BoundaryInfo::sync(), libMesh::MeshData::translate(), libMesh::EquationSystems::update(), libMesh::NewmarkSystem::update_rhs(), libMesh::NewmarkSystem::update_u_v_a(), libMesh::ErrorVector::variance(), libMesh::StatisticsVector< T >::variance(), libMesh::Parallel::Request::wait(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::ImplicitSystem::weighted_sensitivity_solve(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::MeshData::write(), libMesh::EquationSystems::write(), libMesh::MeshOutput< MT >::write_equation_systems(), libMesh::LegacyXdrIO::write_mesh(), libMesh::TecplotIO::write_nodal_data(), libMesh::GnuPlotIO::write_nodal_data(), libMesh::MEDITIO::write_nodal_data(), libMesh::GmshIO::write_nodal_data(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::GMVIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), and libMesh::ExodusII_IO::write_nodal_data_discontinuous()\&.
.SS "libMesh::SUPERTYPE (unsignedchar, short)"

.SS "libMesh::SUPERTYPE (unsignedchar, int)"

.SS "libMesh::SUPERTYPE (unsignedchar, float)"

.SS "libMesh::SUPERTYPE (unsignedchar, double)"

.SS "libMesh::SUPERTYPE (unsignedchar, longdouble)"

.SS "libMesh::SUPERTYPE (char, short)"

.SS "libMesh::SUPERTYPE (char, int)"

.SS "libMesh::SUPERTYPE (char, float)"

.SS "libMesh::SUPERTYPE (char, double)"

.SS "libMesh::SUPERTYPE (char, longdouble)"

.SS "libMesh::SUPERTYPE (short, int)"

.SS "libMesh::SUPERTYPE (short, float)"

.SS "libMesh::SUPERTYPE (short, double)"

.SS "libMesh::SUPERTYPE (short, longdouble)"

.SS "libMesh::SUPERTYPE (int, float)"

.SS "libMesh::SUPERTYPE (int, double)"

.SS "libMesh::SUPERTYPE (int, longdouble)"

.SS "libMesh::SUPERTYPE (float, double)"

.SS "libMesh::SUPERTYPE (float, longdouble)"

.SS "libMesh::SUPERTYPE (double, longdouble)"

.SS "\fBX_input\fP libMesh::swap (X_system)"

.PP
Referenced by libMesh::DenseMatrix< T >::_lu_back_substitute(), libMesh::DenseMatrix< T >::_lu_decompose(), libMesh::DenseMatrix< T >::_multiply_blas(), libMesh::Elem::compute_key(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::Utility::deallocate(), libMesh::SystemSubsetBySubdomain::init(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::Utility::ReverseBytes::operator()(), operator=(), libMesh::PeriodicBoundary::PeriodicBoundary(), libMesh::DofMap::prepare_send_list(), libMesh::TreeNode< N >::refine(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::DenseMatrix< T >::swap(), libMesh::EpetraMatrix< T >::swap(), libMesh::PetscMatrix< T >::swap(), swap(), libMesh::DistributedVector< T >::swap(), libMesh::LaspackVector< T >::swap(), libMesh::EigenSparseVector< T >::swap(), libMesh::EpetraVector< T >::swap(), libMesh::PetscVector< T >::swap(), libMesh::NumericVector< T >::swap(), libMesh::TreeNode< N >::transform_nodes_to_elements(), and libMesh::BuildProjectionList::unique()\&.
.SS "\fBJ_input\fP libMesh::swap (J_system)"

.SS "\fBX_global\fP libMesh::swap (\fBX_sys\fP)"

.SS "\fBJac\fP libMesh::swap (\fBJac_sys\fP)"

.SS "void libMesh::write_traceout ()"
Writes a stack trace to a uniquely named file if --enable-tracefiles has been set by configure, otherwise does nothing\&. Note that we append to the trace file rather than overwriting it\&. This allows multiple traces to be written to the same file\&. 
.PP
Definition at line 137 of file print_trace\&.C\&.
.PP
References global_processor_id(), and print_trace()\&.
.PP
Referenced by libmesh_terminate_handler(), and libMesh::MacroFunctions::report_error()\&.
.PP
.nf
138 {
139 #ifdef LIBMESH_ENABLE_TRACEFILES
140   std::stringstream outname;
141   outname << "traceout_" << static_cast<std::size_t>(libMesh::global_processor_id()) << '_' << getpid() << "\&.txt";
142   std::ofstream traceout(outname\&.str()\&.c_str(), std::ofstream::app);
143   libMesh::print_trace(traceout);
144 #endif
145 }
.fi
.SS "\fBPetscVector\fP<\fBNumber\fP> libMesh::X_global (\fBx\fP, sys\&.comm())"

.PP
Referenced by __libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), and DMlibMeshFunction()\&.
.SS "\fBPetscVector\fP<\fBNumber\fP> libMesh::X_input (\fBx\fP, sys\&.comm())"

.PP
Referenced by __libmesh_petsc_diff_solver_residual()\&.
.SS "template void \fBlibMesh::Xdr::data\fP< std::complex< double > > (std::complex< double > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::complex< float > > (std::complex< float > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::complex< long double > > (std::complex< long double > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::string > (std::string &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< char > > (std::vector< char > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< double > > (std::vector< double > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< float > > (std::vector< float > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< int > > (std::vector< int > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< long double > > (std::vector< long double > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< long int > > (std::vector< long int > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< short int > > (std::vector< short int > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< signed char > > (std::vector< signed char > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< std::complex< double > > > (std::vector< std::complex< double > > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< std::complex< float > > > (std::vector< std::complex< float > > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< std::complex< long double > > > (std::vector< std::complex< long double > > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< std::string > > (std::vector< std::string > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< unsigned char > > (std::vector< unsigned char > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< unsigned int > > (std::vector< unsigned int > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< unsigned long int > > (std::vector< unsigned long int > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< unsigned long long > > (std::vector< unsigned long long > &, const char *)"

.SS "template void \fBlibMesh::Xdr::data\fP< std::vector< unsigned short int > > (std::vector< unsigned short int > &, const char *)"

.SH "Variable Documentation"
.PP 
.SS "\fBsolver\fP libMesh::_current_nonlinear_iteration_number = static_cast<unsigned>(n_iterations)"

.PP
Definition at line 180 of file petsc_nonlinear_solver\&.C\&.
.PP
Referenced by libMesh::PetscNonlinearSolver< T >::clear()\&.
.SS "template<typename T > void \fBPetscPreconditioner\fP<T>::set_petsc_subpreconditioner_type (PCType type, \fBPC\fP& \fBpc\fP) void \fBPetscPreconditioner\fP<T> \fBParallel::communicator\fP libMesh::comm"

.PP
Definition at line 248 of file petsc_preconditioner\&.C\&.
.PP
Referenced by libMesh::PetscMatrix< T >::_get_submatrix(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::SlepcEigenSolver< T >::_solve_generalized_helper(), libMesh::SlepcEigenSolver< T >::_solve_standard_helper(), libMesh::DofMap::add_constraints_to_send_list(), libMesh::EigenSparseLinearSolver< T >::adjoint_solve(), libMesh::PetscLinearSolver< T >::adjoint_solve(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::Parallel::Communicator::assign(), libMesh::Parallel::BinSorter< KeyType, IdxType >::binsort(), libMesh::Parallel::Sort< KeyType, IdxType >::binsort(), libMesh::Preconditioner< T >::build(), libMesh::Parallel::Histogram< KeyType, IdxType >::build_histogram(), libMesh::PetscNonlinearSolver< T >::build_mat_null_space(), libMesh::DistributedVector< T >::clone(), libMesh::LaspackVector< T >::clone(), libMesh::EigenSparseVector< T >::clone(), libMesh::EpetraVector< T >::clone(), libMesh::PetscVector< T >::clone(), libMesh::EpetraVector< T >::close(), libMesh::Parallel::Sort< KeyType, IdxType >::communicate_bins(), libMesh::NumericVector< T >::compare(), libMesh::DofMap::create_dof_constraints(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::PetscVector< T >::create_subvector(), DMCreateDomainDecomposition_libMesh(), DMCreateDomainDecompositionDM_libMesh(), DMCreateFieldDecomposition_libMesh(), DMCreateFieldDecompositionDM_libMesh(), DMCreateGlobalVector_libMesh(), DMLibMeshCreateDomainDecompositionDM(), DMLibMeshCreateFieldDecompositionDM(), DMLibMeshGetBlocks(), DMLibMeshGetSystem(), DMLibMeshGetVariables(), DMLibMeshParseDecompositionDescriptor_Private(), DMLibMeshSetSystem(), DMSetUp_libMesh(), DMVariableBounds_libMesh(), DMView_libMesh(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::DofMap::get_info(), libMesh::NumericVector< T >::global_relative_compare(), if(), libMesh::SlepcEigenSolver< T >::init(), libMesh::PetscDiffSolver::init(), libMesh::PetscDMNonlinearSolver< T >::init(), libMesh::PetscPreconditioner< T >::init(), libMesh::PetscNonlinearSolver< T >::init(), libMesh::EpetraMatrix< T >::init(), libMesh::PetscLinearSolver< T >::init(), libMesh::PetscMatrix< T >::init(), libMesh::DistributedVector< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::init(), libMesh::DistributedVector< T >::l1_norm(), libMesh::DistributedVector< T >::l2_norm(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::DistributedVector< T >::linfty_norm(), libMesh::NumericVector< T >::local_relative_compare(), libMesh::DistributedVector< T >::localize(), libMesh::EpetraVector< T >::localize(), libMesh::PetscVector< T >::localize(), libMesh::DistributedVector< T >::localize_to_one(), libMesh::EpetraVector< T >::localize_to_one(), libMesh::PetscVector< T >::localize_to_one(), libMesh::DistributedVector< T >::max(), libMesh::DistributedVector< T >::min(), libMesh::DofMap::n_constrained_dofs(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::SparseMatrix< T >::print(), libMesh::DofMap::print_dof_constraints(), libMesh::PetscMatrix< T >::print_matlab(), libMesh::PetscVector< T >::print_matlab(), libMesh::PetscMatrix< T >::print_personal(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::PetscLinearSolver< T >::restrict_solve_to(), libMesh::DofMap::scatter_constraints(), libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type(), libMesh::PetscLinearSolver< T >::solve(), libMesh::SlepcEigenSolver< T >::solve_generalized(), libMesh::SlepcEigenSolver< T >::solve_standard(), libMesh::Parallel::Sort< KeyType, IdxType >::sort(), libMesh::NumericVector< T >::subset_l1_norm(), libMesh::NumericVector< T >::subset_l2_norm(), libMesh::NumericVector< T >::subset_linfty_norm(), libMesh::DistributedVector< T >::sum(), libMesh::EpetraVector< T >::sum(), libMesh::EpetraMatrix< T >::update_sparsity_pattern(), libMesh::DistributedVector< T >::zero_clone(), libMesh::LaspackVector< T >::zero_clone(), libMesh::EigenSparseVector< T >::zero_clone(), libMesh::EpetraVector< T >::zero_clone(), and libMesh::PetscVector< T >::zero_clone()\&.
.SS "int libMesh::COMM_WORLD = MPI_COMM_NULL"
MPI Communicator to be used in the library\&.
.PP
Something to use with CHKERRABORT if we're just using PETSc's MPI 'uni' stub\&. 
.PP
Definition at line 173 of file libmesh\&.C\&.
.PP
Referenced by if()\&.
.SS "\fBParallel::Communicator\fP libMesh::communicator(\fBcomm\fP)"

.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::MeshCommunication::assign_global_indices(), and libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type()\&.
.SS "\fBParallel::Communicator\fP libMesh::CommWorld"
The default \fBlibMesh\fP communicator\&.
.PP
If this communicator is disabled, we also disable it as a default argument to functions which accept a default communicator argument\&. This should expose implicit uses of the default communicator as compile-time rather than run-time errors\&.
.PP
The macro LIBMESH_CAN_DEFAULT_TO_COMMWORLD effects this functionality; it is empty (and so leaves arguments with no default value) if the default is disabled, and it sets something equal to the default otherwise\&. 
.PP
Definition at line 184 of file libmesh\&.C\&.
.PP
Referenced by libMesh::NumericVector< T >::build()\&.
.SS "const unsigned char libMesh::cube_number_column"

.PP
Definition at line 85 of file number_lookups\&.C\&.
.SS "const unsigned char libMesh::cube_number_page"

.PP
Definition at line 309 of file number_lookups\&.C\&.
.SS "const unsigned char libMesh::cube_number_row"

.PP
Definition at line 197 of file number_lookups\&.C\&.
.SS "void \fBExactErrorEstimator::estimate_error\fP (const \fBSystem\fP& system, \fBErrorVector\fP& error_per_cell, const \fBNumericVector\fP<\fBNumber\fP>* solution_vector, bool estimate_parent_error) void \fBExactErrorEstimator\fP const unsigned in libMesh::dim) = mesh\&.mesh_dimension()"

.PP
Definition at line 216 of file exact_error_estimator\&.C\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::DofMap::_dof_indices(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::EquationSystems::build_variable_names(), libMesh::System::calculate_norm(), libMesh::JumpErrorEstimator::coarse_n_flux_faces_increment(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEXYZ< Dim >::compute_face_values(), libMesh::FEGenericBase< T >::compute_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_shape_functions(), libMesh::FEXYZ< Dim >::compute_shape_functions(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::QGrundmann_Moller::gm_rule(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::XdrMESH::init(), libMesh::TreeNode< N >::insert(), libMesh::LaplacianErrorEstimator::internal_side_integration(), libMesh::DofMap::old_dof_indices(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::MeshFunction::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::MeshBase::prepare_for_use(), libMesh::FE< Dim, T >::reinit(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::DofMap::reinit(), libMesh::HPCoarsenTest::select_refinement(), libMesh::FEInterface::shape(), libMesh::Side< SideType, ParentType >::Side(), libMesh::SideEdge< EdgeType, ParentType >::SideEdge(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.SS "const \fBDofMap\fP& libMesh::dof_map = \fBsystem\&.get_dof_map\fP()"

.PP
Definition at line 222 of file exact_error_estimator\&.C\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::EquationSystems::allgather(), libMesh::SparseMatrix< Number >::attach_dof_map(), libMesh::EquationSystems::build_solution_vector(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::EquationSystems::get_solution(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), libMesh::SparsityPattern::Build::join(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::parallel_sync(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::ImplicitSystem::reinit(), libMesh::EigenSystem::reinit(), libMesh::HPCoarsenTest::select_refinement(), libMesh::System::write_parallel_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::System::write_SCALAR_dofs(), and libMesh::EnsightIO::write_vector_ascii()\&.
.SS "libMesh::EIGEN_SOLVERS"

.PP
Definition at line 237 of file libmesh\&.C\&.
.PP
Referenced by libMesh::LinearSolver< T >::build(), libMesh::Preconditioner< T >::build(), libMesh::SparseMatrix< T >::build(), libMesh::NumericVector< T >::build(), and default_solver_package()\&.
.SS "\fBOStreamProxy\fP libMesh::err"

.PP
Definition at line 223 of file libmesh_common\&.h\&.
.PP
Referenced by __libmesh_petsc_preconditioner_setup(), __libmesh_petsc_snes_residual(), libMesh::ExactSolution::_check_inputs(), libMesh::DenseMatrix< T >::_cholesky_decompose(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::SparseMatrix< Number >::_get_submatrix(), libMesh::GMVIO::_gmv_elem_to_libmesh_elem(), libMesh::SyncNodalPositions::act_on_data(), libMesh::MeshData::activate(), libMesh::DofMap::add_adjoint_constraint_row(), libMesh::Elem::add_child(), libMesh::DofMap::add_constraint_row(), libMesh::BoundaryInfo::add_edge(), libMesh::ImplicitSystem::add_matrix(), libMesh::BoundaryInfo::add_node(), libMesh::BoundaryInfo::add_side(), libMesh::EquationSystems::add_system(), libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::System::add_vector(), libMesh::LaspackLinearSolver< T >::adjoint_solve(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::TetGenWrapper::allocate_facet_polygonlist(), libMesh::TetGenWrapper::allocate_facetlist(), libMesh::TetGenWrapper::allocate_pointlist(), libMesh::TetGenWrapper::allocate_polygon_vertexlist(), libMesh::TetGenWrapper::allocate_regionlist(), libMesh::FrequencySystem::assemble(), libMesh::FEMSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::ExodusII_IO_Helper::ElementMaps::assign_conversion(), libMesh::MeshCommunication::assign_global_indices(), libMesh::TetGenMeshInterface::assign_nodes_to_elem(), libMesh::LinearSolver< T >::attach_preconditioner(), libMesh::NonlinearSolver< T >::attach_preconditioner(), libMesh::Factory< Base >::build(), libMesh::EigenSolver< T >::build(), libMesh::LinearSolver< T >::build(), libMesh::NonlinearSolver< T >::build(), libMesh::Preconditioner< T >::build(), libMesh::PointLocatorBase::build(), libMesh::QBase::build(), libMesh::SparseMatrix< T >::build(), libMesh::Elem::build(), libMesh::Patch::build_around_element(), libMesh::MeshTools::Generation::build_cube(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::FEGenericBase< T >::build_InfFE(), libMesh::EquationSystems::build_variable_names(), libMesh::VTKIO::cells_to_vtk(), libMesh::ExodusII_IO_Helper::check_existing_vars(), libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::Xdr::close(), libMesh::WrappedFunction< Output >::component(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_node_indices(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_node_indices_fast(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEMap::compute_single_point_map(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::Elem::contains_point(), libMesh::ContinuationSystem::continuation_solve(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), libMesh::TriangleWrapper::copy_tri_to_mesh(), libMesh::UNVIO::count_elements(), libMesh::UNVIO::count_nodes(), libMesh::TreeNode< N >::create_bounding_box(), libMesh::NumericVector< Number >::create_subvector(), libMesh::TensorTools::curl_from_grad(), libMesh::Xdr::data(), libMesh::Xdr::data_stream(), libMesh::EquationSystems::delete_system(), libMesh::DenseMatrix< T >::det(), libMesh::TensorTools::div_from_grad(), DMlibMeshFunction(), libMesh::QGauss::dunavant_rule(), libMesh::QGauss::dunavant_rule2(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::edge_reinit(), libMesh::TecplotIO::elem_dimension(), libMesh::MeshData::elem_to_foreign_id(), libMesh::TetGenIO::element_in(), libMesh::UNVIO::element_in(), libMesh::UNVIO::element_out(), libMesh::MeshData::enable_compatibility_mode(), libMesh::PointLocatorTree::enable_out_of_mesh_mode(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::ExactSolution::error_norm(), libMesh::ParsedFunction< Output >::eval(), libMesh::FEInterface::FEInterface(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshData::foreign_id_to_elem(), libMesh::MeshData::foreign_id_to_node(), libMesh::SyncNodalPositions::gather_data(), libMesh::Parameters::get(), libMesh::ExodusII_IO_Helper::NamesData::get_char_star(), libMesh::PetscLinearSolver< T >::get_converged_reason(), libMesh::MeshData::get_data(), get_dof_map(), libMesh::VTKIO::get_elem_type(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::Base::get_elem_type(), libMesh::BoundaryInfo::get_id_by_name(), libMesh::MeshBase::get_id_by_name(), libMesh::PetscLinearSolver< T >::get_initial_residual(), libMesh::ImplicitSystem::get_matrix(), libMesh::ExodusII_IO::get_num_time_steps(), libMesh::TetGenWrapper::get_output_node(), libMesh::FEAbstract::get_refspace_nodes(), libMesh::EquationSystems::get_system(), libMesh::ExodusII_IO::get_time_steps(), libMesh::System::get_vector(), libMesh::ParsedFunction< Output >::getVarAddress(), libMesh::MeshFunction::gradient(), libMesh::XdrMESH::header(), libMesh::MacroFunctions::here(), libMesh::MeshFunction::hessian(), libMesh::MeshTools::Generation::Private::idx(), if(), if(), libMesh::FEInterface::ifem_inverse_map(), libMesh::FEInterface::ifem_nodal_soln(), libMesh::LaplaceMeshSmoother::init(), libMesh::PetscPreconditioner< T >::init(), libMesh::TrilinosPreconditioner< T >::init(), libMesh::PointLocatorTree::init(), libMesh::PointLocatorList::init(), libMesh::MeshFunction::init(), libMesh::XdrMGF::init(), libMesh::DistributedVector< T >::init(), libMesh::QGauss::init_1D(), libMesh::QJacobi::init_1D(), libMesh::QTrap::init_2D(), libMesh::QClough::init_2D(), libMesh::QGauss::init_2D(), libMesh::QSimpson::init_2D(), libMesh::QConical::init_2D(), libMesh::QGrid::init_2D(), libMesh::QTrap::init_3D(), libMesh::QClough::init_3D(), libMesh::QGauss::init_3D(), libMesh::QSimpson::init_3D(), libMesh::QGrid::init_3D(), libMesh::QConical::init_3D(), libMesh::QGrundmann_Moller::init_3D(), libMesh::FrequencySystem::init_data(), libMesh::System::init_data(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_shape_functions(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::EpetraVector< T >::inputNonlocalValues(), libMesh::MeshData::insert_elem_data(), libMesh::SerialMesh::insert_node(), libMesh::MeshData::insert_node_data(), libMesh::FEInterface::inverse_map(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::Xdr::is_open(), libMesh::InverseDistanceInterpolation< KDDim >::PointListAdaptor< KDDim >::kdtree_distance(), libMesh::QGauss::keast_rule(), libMesh::QMonomial::kim_rule(), libmesh_cast_ptr(), libmesh_cast_ref(), EXTERN_C_FOR_PETSC_END::libmesh_handleFPE(), libMesh::DenseMatrix< T >::lu_solve(), libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::HCurlFETransformation< T >::map_d2phi(), libMesh::HCurlFETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_div(), libMesh::HCurlFETransformation< T >::map_dphi(), libMesh::PetscVector< T >::map_global_to_local_index(), libMesh::HCurlFETransformation< T >::map_phi(), libMesh::ElementTypes::name(), libMesh::QuadratureRules::name(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::nodal_soln(), libMesh::UNVIO::node_in(), libMesh::MeshData::node_to_foreign_id(), libMesh::FEAbstract::on_reference_element(), libMesh::Xdr::open(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::MeshDataUnvHeader::operator=(), libMesh::ErrorVector::plot_error(), libMesh::PerfLog::pop(), libMesh::TetGenMeshInterface::process_hull_integrity_result(), libMesh::System::project_vector(), libMesh::Elem::quality(), libMesh::UCDIO::read(), libMesh::PltLoader::read(), libMesh::TetGenIO::read(), libMesh::UNVIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::VTKIO::read(), libMesh::MeshData::read(), libMesh::LegacyXdrIO::read_binary(), libMesh::PltLoader::read_block_data(), libMesh::PltLoader::read_data(), libMesh::ExodusII_IO_Helper::read_elemental_var_values(), libMesh::PltLoader::read_feblock_data(), libMesh::PltLoader::read_fepoint_data(), libMesh::PltLoader::read_header(), libMesh::UCDIO::read_implementation(), libMesh::UNVIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::ExodusII_IO_Helper::read_nodal_var_values(), libMesh::PltLoader::read_point_data(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::MeshData::read_tetgen(), libMesh::MeshData::read_unv(), libMesh::MeshData::read_unv_implementation(), libMesh::ExodusII_IO_Helper::read_var_names(), libMesh::MeshData::read_xdr(), libMesh::EpetraVector< T >::reciprocal(), libMesh::FEXYZ< Dim >::reinit(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::DofMap::reinit(), libMesh::System::restrict_vectors(), libMesh::DofMap::SCALAR_dof_indices(), libMesh::HPCoarsenTest::select_refinement(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), libMesh::FrequencySystem::set_frequencies_by_steps(), libMesh::LaspackLinearSolver< T >::set_laspack_preconditioner_type(), libMesh::DofObject::set_n_comp_group(), libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type(), libMesh::PetscLinearSolver< T >::set_petsc_solver_type(), libMesh::TrilinosPreconditioner< T >::set_preconditioner_type(), libMesh::SlepcEigenSolver< T >::set_slepc_position_of_spectrum(), libMesh::SlepcEigenSolver< T >::set_slepc_problem_type(), libMesh::SlepcEigenSolver< T >::set_slepc_solver_type(), libMesh::AztecLinearSolver< T >::set_solver_type(), libMesh::TetGenWrapper::set_switches(), libMesh::Node::set_valence(), libMesh::FE< Dim, T >::shape(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::MeshData::slim(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::EigenSparseLinearSolver< T >::solve(), libMesh::LaspackLinearSolver< T >::solve(), libMesh::QMonomial::stroud_rule(), libMesh::VTKIO::system_vectors_to_vtk(), libMesh::TriangleInterface::triangulate(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::System::variable_number(), libMesh::Elem::which_child_am_i(), libMesh::FroIO::write(), libMesh::UCDIO::write(), libMesh::TetGenIO::write(), libMesh::UNVIO::write(), libMesh::UnstructuredMesh::write(), libMesh::MeshData::write(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::LegacyXdrIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::PltLoader::write_dat(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::Nemesis_IO::write_global_data(), libMesh::ExodusII_IO::write_global_data(), libMesh::UCDIO::write_implementation(), libMesh::UNVIO::write_implementation(), libMesh::Nemesis_IO::write_information_records(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::UCDIO::write_interior_elems(), libMesh::VTKIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::GmshIO::write_post(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), libMesh::MeshData::write_unv(), libMesh::MeshData::write_unv_implementation(), libMesh::ExodusII_IO_Helper::write_var_names(), and libMesh::EnsightIO::write_vector_ascii()\&.
.SS "DIE \fBA\fP HORRIBLE DEATH HERE typedef float libMesh::ErrorVectorReal"

.PP
Definition at line 183 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), for(), libMesh::ErrorVector::minimum(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), and libMesh::HPCoarsenTest::select_refinement()\&.
.SS "int libMesh::GLOBAL_COMM_WORLD = MPI_COMM_NULL"
MPI Communicator used to initialize \fBlibMesh\fP\&.
.PP
Something to use with CHKERRABORT if we're just using PETSc's MPI 'uni' stub\&. 
.PP
Definition at line 175 of file libmesh\&.C\&.
.PP
Referenced by if(), libmesh_terminate_handler(), and PetscDMRegister()\&.
.SS "\fBPetscErrorCode\fP ierr = PCSetUp(\fBpc\fP)"

.PP
Definition at line 268 of file petsc_preconditioner\&.C\&.
.PP
Referenced by __libmesh_petsc_diff_solver_monitor(), __libmesh_petsc_preconditioner_apply(), __libmesh_petsc_preconditioner_setup(), __libmesh_petsc_snes_residual(), libMesh::PetscLinearSolver< T >::_create_complement_is(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::PetscLinearSolver< T >::_restrict_solve_to_is_local_size(), libMesh::SlepcEigenSolver< T >::_solve_generalized_helper(), libMesh::SlepcEigenSolver< T >::_solve_standard_helper(), libMesh::PetscVector< T >::add(), libMesh::PetscVector< T >::add_vector(), libMesh::PetscVector< T >::add_vector_transpose(), libMesh::PetscLinearSolver< T >::adjoint_solve(), libMesh::Parallel::Communicator::allgather(), libMesh::Parallel::Communicator::alltoall(), libMesh::PetscPreconditioner< T >::apply(), libMesh::SlepcEigenSolver< T >::attach_deflation_space(), libMesh::Parallel::Communicator::broadcast(), libMesh::SlepcEigenSolver< T >::clear(), libMesh::PetscPreconditioner< T >::clear(), libMesh::PetscLinearSolver< T >::clear(), libMesh::PetscVector< T >::conjugate(), DMCreate_libMesh(), DMCreateDomainDecomposition_libMesh(), DMCreateDomainDecompositionDM_libMesh(), DMCreateFieldDecomposition_libMesh(), DMCreateFieldDecompositionDM_libMesh(), DMCreateGlobalVector_libMesh(), DMCreateLibMesh(), DMDestroy_libMesh(), DMLibMeshCreateDomainDecompositionDM(), DMLibMeshCreateFieldDecompositionDM(), DMlibMeshFunction(), DMLibMeshGetBlocks(), DMLibMeshGetSystem(), DMLibMeshGetVariables(), DMLibMeshParseDecompositionDescriptor_Private(), DMLibMeshSetSystem(), DMLibMeshSetUpName_Private(), DMSetUp_libMesh(), DMVariableBounds_libMesh(), DMView_libMesh(), libMesh::Parallel::Communicator::gather(), libMesh::SlepcEigenSolver< T >::get_eigenpair(), libMesh::SlepcEigenSolver< T >::get_eigenvalue(), libMesh::PetscLinearSolver< T >::get_initial_residual(), libMesh::SlepcEigenSolver< T >::get_relative_error(), libMesh::PetscLinearSolver< T >::get_residual_history(), if(), libMesh::SlepcEigenSolver< T >::init(), libMesh::PetscDMNonlinearSolver< T >::init(), libMesh::PetscPreconditioner< T >::init(), libMesh::PetscLinearSolver< T >::init(), libMesh::PetscVector< T >::l1_norm(), libMesh::PetscVector< T >::l2_norm(), libMesh::PetscVector< T >::linfty_norm(), PetscDMRegister(), libMesh::GMVIO::read(), libMesh::Parallel::Communicator::receive(), libMesh::PetscVector< T >::reciprocal(), libMesh::PetscLinearSolver< T >::restrict_solve_to(), libMesh::Parallel::Communicator::send(), libMesh::PetscVector< T >::set(), libMesh::PetscPreconditioner< T >::set_petsc_preconditioner_type(), libMesh::PetscLinearSolver< T >::set_petsc_solver_type(), libMesh::SlepcEigenSolver< T >::set_slepc_position_of_spectrum(), libMesh::SlepcEigenSolver< T >::set_slepc_problem_type(), libMesh::SlepcEigenSolver< T >::set_slepc_solver_type(), SNESFunction_DMlibMesh(), libMesh::PetscDMNonlinearSolver< T >::solve(), libMesh::PetscLinearSolver< T >::solve(), libMesh::SlepcEigenSolver< T >::solve_generalized(), libMesh::SlepcEigenSolver< T >::solve_standard(), libMesh::PetscVector< T >::sum(), and libMesh::TecplotIO::write_binary()\&.
.SS "const \fBNumber\fP libMesh::imaginary"
The imaginary unit, $ \sqrt{-1} $\&. 
.SS "libMesh::INSTANTIATE_SUBDIVISION_FE"

.PP
Definition at line 557 of file fe\&.C\&.
.SS "libMesh::INSTANTIATE_SUBDIVISION_MAPS"

.PP
Definition at line 1402 of file fe_map\&.C\&.
.SS "libMesh::INVALID_SOLVER_PACKAGE"

.PP
Definition at line 241 of file libmesh\&.C\&.
.PP
Referenced by default_solver_package()\&.
.SS "const unsigned int libMesh::invalid_uint = static_cast<unsigned int>(-1)"
A number which is used quite often to represent an invalid or uninitialized value\&. 
.PP
Definition at line 165 of file libmesh\&.h\&.
.PP
Referenced by libMesh::FEMContext::_do_elem_position_set(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_node_indices_fast(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_shape_indices(), libMesh::Xdr::data_stream(), libMesh::FEMContext::elem_position_get(), libMesh::TreeNode< N >::find_element_in_children(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::Elem::get_node_index(), libMesh::DofObject::has_dofs(), libMesh::MeshTools::Generation::Private::idx(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::Elem::local_node(), libMesh::FEMSystem::mesh_position_get(), libMesh::DofObject::n_dofs(), libMesh::Quad9::n_second_order_adjacent_vertices(), libMesh::Hex27::n_second_order_adjacent_vertices(), libMesh::InfHex18::n_second_order_adjacent_vertices(), libMesh::FEMSystem::numerical_jacobian(), libMesh::DofMap::old_dof_indices(), libMesh::MeshDataUnvHeader::read(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::BoundaryInfo::side_with_boundary_id(), libMesh::Node::valence(), libMesh::Elem::which_child_am_i(), libMesh::Elem::which_neighbor_am_i(), libMesh::Elem::which_side_am_i(), and libMesh::System::write_serialized_blocked_dof_objects()\&.
.SS "\fBPetscMatrix\fP<\fBNumber\fP>& libMesh::J_system"
\fBInitial value:\fP
.PP
.nf
=
    *libmesh_cast_ptr<PetscMatrix<Number>*>(sys\&.matrix)
.fi
.PP
Definition at line 168 of file petsc_diff_solver\&.C\&.
.SS "\fBPetscErrorCode\fP Vec Mat libMesh::jac"

.PP
Definition at line 161 of file petsc_nonlinear_solver\&.C\&.
.SS "\fBPetscMatrix\fP<\fBNumber\fP>& libMesh::Jac_sys = *\fBlibmesh_cast_ptr\fP<\fBPetscMatrix\fP<\fBNumber\fP>*>(sys\&.matrix)"

.PP
Definition at line 192 of file petsc_nonlinear_solver\&.C\&.
.SS "libMesh::LASPACK_SOLVERS"

.PP
Definition at line 239 of file libmesh\&.C\&.
.PP
Referenced by libMesh::LinearSolver< T >::build(), libMesh::SparseMatrix< T >::build(), libMesh::NumericVector< T >::build(), and default_solver_package()\&.
.SS "MPI_Errhandler libMesh::libmesh_errhandler"

.PP
Definition at line 224 of file libmesh\&.C\&.
.PP
Referenced by if()\&.
.SS "const unsigned int libMesh::MIN_ELEM_PER_PROC = 4"

.PP
Definition at line 52 of file parmetis_partitioner\&.C\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition()\&.
.SS "\fBPetscInt\fP libMesh::n_local"

.PP
Definition at line 275 of file petsc_preconditioner\&.C\&.
.PP
Referenced by libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::PetscMatrix< T >::init(), libMesh::DistributedVector< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::init(), libMesh::ParallelMesh::parallel_n_elem(), and libMesh::ParallelMesh::parallel_n_nodes()\&.
.SS "unsigned int libMesh::n_threads = '--n_threads'\fC [inline]\fP"

.PP
Definition at line 340 of file libmesh\&.C\&.
.PP
Referenced by libMesh::FEMContext::_do_elem_position_set(), libMesh::FEMContext::elem_position_get(), libMesh::FEMContext::elem_reinit(), libMesh::MeshBase::get_info(), if(), libMesh::Threads::num_pthreads(), libMesh::Threads::parallel_for(), libMesh::Threads::parallel_reduce(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.SS "const unsigned int libMesh::n_vars = system\&.n_vars()"

.PP
Definition at line 219 of file exact_error_estimator\&.C\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::WrappedFunction< Output >::component(), libMesh::DofMap::dof_indices(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ErrorEstimator::estimate_errors(), libMesh::DofMap::old_dof_indices(), libMesh::WrappedFunction< Output >::operator()(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MEDITIO::write_ascii(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::GmshIO::write_post(), and libMesh::GnuPlotIO::write_solution()\&.
.SS "std::terminate_handler libMesh::old_terminate_handler"

.PP
Definition at line 263 of file libmesh\&.C\&.
.PP
Referenced by libmesh_terminate_handler()\&.
.SS "\fBOStreamProxy\fP libMesh::out"

.PP
Definition at line 222 of file libmesh_common\&.h\&.
.PP
Referenced by __libmesh_petsc_diff_solver_monitor(), __libmesh_petsc_diff_solver_residual(), __libmesh_petsc_snes_monitor(), libMesh::DenseMatrix< T >::_lu_back_substitute_lapack(), libMesh::DenseMatrix< T >::_lu_decompose(), libMesh::DenseMatrix< T >::_lu_decompose_lapack(), libMesh::DenseMatrix< T >::_matvec_blas(), libMesh::DenseMatrix< T >::_multiply_blas(), libMesh::DenseMatrix< T >::_svd_helper(), libMesh::PetscVector< T >::add_vector_conjugate_transpose(), libMesh::FEMSystem::assembly(), libMesh::AbaqusIO::assign_boundary_node_ids(), libMesh::AbaqusIO::assign_sideset_ids(), libMesh::System::attach_assemble_function(), libMesh::System::attach_assemble_object(), libMesh::System::attach_constraint_function(), libMesh::System::attach_constraint_object(), libMesh::System::attach_init_function(), libMesh::System::attach_init_object(), libMesh::System::attach_QOI_derivative(), libMesh::System::attach_QOI_derivative_object(), libMesh::System::attach_QOI_function(), libMesh::System::attach_QOI_object(), libMesh::ElementTypes::basic_name(), libMesh::Parallel::Sort< KeyType, IdxType >::bin(), libMesh::QBase::build(), libMesh::FEAbstract::build(), libMesh::FEGenericBase< T >::build(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::BoundaryInfo::build_side_list_from_node_list(), libMesh::DofMap::build_sparsity(), libMesh::MeshTools::Generation::build_sphere(), libMesh::ExodusII_IO_Helper::check_existing_vars(), libMesh::PerfLog::clear(), libMesh::MeshRefinement::coarsen_elements(), libMesh::EquationSystems::compare(), libMesh::System::compare(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ContinuationSystem::continuation_solve(), libMesh::UNVIO::count_elements(), libMesh::UNVIO::count_nodes(), libMesh::ExodusII_IO_Helper::create(), libMesh::Nemesis_IO_Helper::create(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofObject::debug_buffer(), libMesh::EnsightIO::elem_type_to_string(), libMesh::UNVIO::element_in(), libMesh::UNVIO::element_out(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::PetscMatrix< T >::get_diagonal(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::Utility::get_timestamp(), libMesh::StatisticsVector< T >::histogram(), if(), libMesh::XdrMGF::init(), libMesh::ContinuationSystem::initialize_tangent(), libMesh::NewtonSolver::line_search(), libMesh::Parallel::Communicator::maxloc(), libMesh::MeshInput< MT >::MeshInput(), libMesh::MeshOutput< MT >::MeshOutput(), libMesh::ExodusII_IO_Helper::message(), libMesh::Parallel::Communicator::minloc(), libMesh::SerialMesh::node(), libMesh::UNVIO::node_in(), libMesh::UNVIO::node_out(), libMesh::Xdr::open(), libMesh::ExodusII_IO_Helper::open(), libMesh::PetscVector< T >::pointwise_mult(), libMesh::DofMap::prepare_send_list(), libMesh::PetscNonlinearSolver< T >::print_converged_reason(), libMesh::EigenSparseLinearSolver< T >::print_converged_reason(), libMesh::LaspackLinearSolver< T >::print_converged_reason(), libMesh::LinearSolver< T >::print_converged_reason(), libMesh::NewtonSolver::print_convergence(), libMesh::ExodusII_IO_Helper::print_header(), libMesh::PerfLog::print_log(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Tet::qual_bounds(), libMesh::Hex::qual_bounds(), libMesh::Tri::qual_bounds(), libMesh::Quad::qual_bounds(), libMesh::InfQuad::qual_bounds(), libMesh::AbaqusIO::read(), libMesh::TetGenIO::read(), libMesh::PltLoader::read(), libMesh::Nemesis_IO::read(), libMesh::EquationSystems::read(), libMesh::PltLoader::read_data(), libMesh::ExodusII_IO_Helper::read_elem_in_block(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::PltLoader::read_header(), libMesh::System::read_header(), libMesh::UNVIO::read_implementation(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::ExodusII_IO_Helper::read_var_names_impl(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::TetGenWrapper::set_switches(), libMesh::ContinuationSystem::set_Theta(), libMesh::ContinuationSystem::set_Theta_LOCA(), libMesh::TwostepTimeSolver::solve(), libMesh::EigenSparseLinearSolver< T >::solve(), libMesh::NewtonSolver::solve(), libMesh::UnsteadySolver::solve(), libMesh::EigenTimeSolver::solve(), libMesh::PetscLinearSolver< T >::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::SerialMesh::stitching_helper(), libMesh::MacroFunctions::stop(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::ContinuationSystem::update_solution(), libMesh::Quality::valid(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::XdrIO::write(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::MeshOutput< MT >::write_equation_systems(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::GmshIO::write_post(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO_Helper::write_var_names_impl(), and libMesh::VariationalMeshSmoother::writegr()\&.
.SS "\fBPetscMatrix\fP< \fBNumber\fP > \fBPC\fP * libMesh::pc"

.PP
Definition at line 143 of file petsc_diff_solver\&.C\&.
.PP
Referenced by libMesh::PetscLinearSolver< T >::init_names(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::TrilinosPreconditioner< T >::set_preconditioner_type(), and libMesh::NoxNonlinearSolver< T >::solve()\&.
.SS "\fBPerfLog\fP libMesh::perflog"
A \fC\fBPerfLog\fP\fP object to log performance\&. If the library is configured with \fC--enable-perflog\fP then it will log key functions\&. 
.PP
Definition at line 39 of file libmesh_logging\&.h\&.
.PP
Referenced by libMesh::Threads::parallel_for(), and libMesh::Threads::parallel_reduce()\&.
.SS "\fBPetscBool\fP libMesh::PetscDMRegistered = PETSC_FALSE"

.PP
Definition at line 50 of file petsc_dm_nonlinear_solver\&.C\&.
.PP
Referenced by PetscDMRegister()\&.
.SS "const \fBReal\fP libMesh::pi"
\fBInitial value:\fP
.PP
.nf
=
  static_cast<Real>(3\&.1415926535897932384626433832795029L)
.fi
$ \pi=3.14159... $\&. 
.PP
Definition at line 153 of file libmesh\&.h\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::FESubdivision::loop_subdivision_mask(), libMesh::Tri3::min_and_max_angle(), libMesh::TriangleInterface::PolygonHole::point(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshTools::Modification::rotate(), and libMesh::Sphere::surface_coords()\&.
.SS "DIE \fBA\fP HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE libMesh::Real"

.PP
Definition at line 119 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DenseMatrix< T >::_lu_decompose(), libMesh::FEMContext::_update_time_from_system(), libMesh::Plane::above_surface(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::ImplicitSystem::adjoint_qoi_parameter_sensitivity(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ContinuationSystem::apply_predictor(), libMesh::ImplicitSystem::assemble_residual_derivatives(), libMesh::DiscontinuityMeasure::boundary_side_integration(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::MeshTools::bounding_sphere(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::SystemNorm::calculate_norm(), libMesh::System::calculate_norm(), libMesh::VTKIO::cells_to_vtk(), libMesh::Tet::choose_diagonal(), libMesh::NewmarkSystem::clear(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::FEMap::compute_edge_map(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEAbstract::compute_node_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::FEMap::compute_single_point_map(), libMesh::QConical::conical_product_pyramid(), libMesh::MeshTools::BoundingBox::contains_point(), libMesh::InfQuad4::contains_point(), libMesh::InfPrism6::contains_point(), libMesh::InfHex8::contains_point(), libMesh::ContinuationSystem::continuation_solve(), libMesh::ExodusII_IO_Helper::create(), libMesh::Nemesis_IO_Helper::create(), libMesh::TreeNode< N >::create_bounding_box(), libMesh::XdrMGF::dataBlk(), libMesh::DenseMatrix< T >::det(), libMesh::Sphere::distance(), libMesh::EquationSystems::EquationSystems(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::ImplicitSystem::forward_qoi_parameter_sensitivity(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::PerfLog::get_perf_info(), libMesh::NumericVector< T >::global_relative_compare(), libMesh::QGrundmann_Moller::gm_rule(), libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::FEHermite< Dim >::hermite_raw_shape_second_deriv(), libMesh::StatisticsVector< T >::histogram(), libMesh::Elem::hmax(), libMesh::Elem::hmin(), libMesh::PointLocatorTree::init(), libMesh::FEComputeData::init(), libMesh::QGrid::init_1D(), libMesh::QGauss::init_2D(), libMesh::QGrid::init_2D(), libMesh::QMonomial::init_2D(), libMesh::QGauss::init_3D(), libMesh::QGrid::init_3D(), libMesh::QMonomial::init_3D(), libMesh::FESubdivision::init_shape_functions(), libMesh::ContinuationSystem::initialize_tangent(), libMesh::LaplacianErrorEstimator::internal_side_integration(), libMesh::DiscontinuityMeasure::internal_side_integration(), libMesh::KellyErrorEstimator::internal_side_integration(), libMesh::MeshTools::BoundingBox::intersect(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::Tet::is_child_on_side_helper(), libMesh::QGauss::keast_rule(), libMesh::LocationMap< T >::key(), libMesh::QMonomial::kim_rule(), libMesh::DenseVector< T >::l1_norm(), libMesh::LaspackVector< T >::l1_norm(), libMesh::EpetraVector< T >::l1_norm(), libMesh::PetscVector< T >::l1_norm(), libMesh::EpetraMatrix< T >::l1_norm(), libMesh::DenseMatrix< T >::l1_norm(), libMesh::PetscMatrix< T >::l1_norm(), libMesh::StatisticsVector< T >::l2_norm(), libMesh::DenseVector< T >::l2_norm(), libMesh::LaspackVector< T >::l2_norm(), libMesh::EpetraVector< T >::l2_norm(), libMesh::PetscVector< T >::l2_norm(), libMesh::NewtonSolver::line_search(), libMesh::DenseVector< T >::linfty_norm(), libMesh::DistributedVector< T >::linfty_norm(), libMesh::LaspackVector< T >::linfty_norm(), libMesh::EpetraVector< T >::linfty_norm(), libMesh::PetscVector< T >::linfty_norm(), libMesh::EpetraMatrix< T >::linfty_norm(), libMesh::DenseMatrix< T >::linfty_norm(), libMesh::PetscMatrix< T >::linfty_norm(), libMesh::FESubdivision::loop_subdivision_mask(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map(), libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), libMesh::DenseVector< T >::max(), libMesh::DistributedVector< T >::max(), libMesh::LaspackVector< T >::max(), libMesh::EigenSparseVector< T >::max(), libMesh::PetscVector< T >::max(), libMesh::DenseMatrix< T >::max(), libMesh::DofMap::max_constraint_error(), libMesh::ErrorVector::mean(), libMesh::StatisticsVector< T >::mean(), libMesh::StatisticsVector< T >::median(), libMesh::DenseVector< T >::min(), libMesh::DistributedVector< T >::min(), libMesh::LaspackVector< T >::min(), libMesh::EigenSparseVector< T >::min(), libMesh::PetscVector< T >::min(), libMesh::DenseMatrix< T >::min(), libMesh::Tri3::min_and_max_angle(), libMesh::Tet4::min_and_max_angle(), libMesh::NewmarkSystem::NewmarkSystem(), libMesh::TetGenIO::node_in(), libMesh::NonlinearImplicitSystem::NonlinearImplicitSystem(), libMesh::StatisticsVector< T >::normalize(), libMesh::FEMSystem::numerical_jacobian(), libMesh::FEAbstract::on_reference_element(), libMesh::Plane::on_surface(), libMesh::ExodusII_IO_Helper::open(), LIBMESH_DEFINE_HASH_POINTERS::FuzzyPointCompare::operator()(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PointLocatorList::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Node::packed_size(), libMesh::ParsedFunction< Output >::ParsedFunction(), libMesh::TriangleInterface::PolygonHole::point(), libMesh::Elem::point_test(), libMesh::DofMap::process_constraints(), libMesh::MeshTools::processor_bounding_sphere(), libMesh::ImplicitSystem::qoi_parameter_hessian(), libMesh::ImplicitSystem::qoi_parameter_hessian_vector_product(), libMesh::Hex::quality(), libMesh::Tri::quality(), libMesh::InfHex::quality(), libMesh::Quad::quality(), libMesh::GmshIO::read_mesh(), libMesh::AbaqusIO::read_nodes(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::MeshData::read_tetgen(), libMesh::MeshData::read_unv_implementation(), libMesh::VariationalMeshSmoother::readgr(), libMesh::Elem::refine(), libMesh::FESubdivision::regular_shape(), libMesh::FESubdivision::regular_shape_deriv(), libMesh::FESubdivision::regular_shape_second_deriv(), libMesh::MemorySolutionHistory::retrieve(), libMesh::MeshTools::Modification::rotate(), libMesh::MeshTools::Modification::scale(), libMesh::QBase::scale(), libMesh::HPCoarsenTest::select_refinement(), libMesh::FrequencySystem::set_current_frequency(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), libMesh::FrequencySystem::set_frequencies_by_steps(), libMesh::NewmarkSystem::set_newmark_parameters(), libMesh::NonlinearImplicitSystem::set_solver_parameters(), libMesh::FE< Dim, T >::shape(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::TypeTensor< T >::size_sq(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::TwostepTimeSolver::solve(), libMesh::NewtonSolver::solve(), libMesh::NoxNonlinearSolver< T >::solve(), libMesh::CondensedEigenSystem::solve(), libMesh::EigenSystem::solve(), libMesh::PetscNonlinearSolver< T >::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::PatchRecoveryErrorEstimator::specpoly(), libMesh::Sphere::Sphere(), libMesh::SerialMesh::stitching_helper(), libMesh::QMonomial::stroud_rule(), libMesh::MeshTools::subdomain_bounding_sphere(), libMesh::NumericVector< T >::subset_l1_norm(), libMesh::NumericVector< T >::subset_l2_norm(), libMesh::NumericVector< T >::subset_linfty_norm(), libMesh::Sphere::surface_coords(), libMesh::TypeVector< T >::unit(), libMesh::Parallel::unpack(), libMesh::Node::PackedNode::unpack(), libMesh::ContinuationSystem::update_solution(), libMesh::ErrorVector::variance(), libMesh::StatisticsVector< T >::variance(), libMesh::Quad4::volume(), libMesh::Edge3::volume(), libMesh::Prism6::volume(), libMesh::Hex8::volume(), libMesh::Elem::volume(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::ImplicitSystem::weighted_sensitivity_solve(), libMesh::Sphere::world_coords(), libMesh::PostscriptIO::write(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::GmshIO::write_mesh(), and libMesh::GnuPlotIO::write_solution()\&.
.SS "const \fBRemoteElem\fP * libMesh::remote_elem"

.PP
Definition at line 57 of file remote_elem\&.C\&.
.PP
Referenced by libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::add_child(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::Elem::coarsen(), libMesh::FEAbstract::compute_node_constraints(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::RemoteElem::create(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::find_edge_neighbors(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Elem::find_point_neighbors(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshTools::Modification::flatten(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::nullify_neighbors(), libMesh::MeshRefinement::test_level_one(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::RemoteElem::~RemoteElem()\&.
.SS "\fBLibMeshInit::LibMeshInit\fP (int argc, const char* const* argv) \fBLibMeshInit\fP command_lin libMesh::reset)(new GetPot(argc, argv))"

.PP
Definition at line 325 of file libmesh\&.C\&.
.SS "\fBPetscNonlinearSolver\fP< \fBNumber\fP > * libMesh::solver"
\fBInitial value:\fP
.PP
.nf
=
      *(static_cast<PetscDiffSolver*> (ctx))
.fi
.PP
Definition at line 152 of file petsc_diff_solver\&.C\&.
.PP
Referenced by __libmesh_petsc_diff_solver_monitor(), __libmesh_petsc_diff_solver_residual(), __libmesh_petsc_snes_residual(), libMesh::EigenSparseLinearSolver< T >::solve(), and libMesh::NoxNonlinearSolver< T >::solve()\&.
.SS "const unsigned char libMesh::square_number_column"
\fBInitial value:\fP
.PP
.nf
= {
  0,
  0, 1, 1,
  0, 1, 2, 2, 2,
  0, 1, 2, 3, 3, 3, 3,
  0, 1, 2, 3, 4, 4, 4, 4, 4,
  0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5,
  0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 6, 6,
  0, 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9
}
.fi
.PP
Definition at line 57 of file number_lookups\&.C\&.
.PP
Referenced by libMesh::FE< Dim, T >::shape(), and libMesh::FE< Dim, T >::shape_deriv()\&.
.SS "const unsigned char libMesh::square_number_row"
\fBInitial value:\fP
.PP
.nf
= {
  0,
  1, 1, 0,
  2, 2, 2, 1, 0,
  3, 3, 3, 3, 2, 1, 0,
  4, 4, 4, 4, 4, 3, 2, 1, 0,
  5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0,
  6, 6, 6, 6, 6, 6, 6, 5, 4, 3, 2, 1, 0,
  7, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
}
.fi
.PP
Definition at line 70 of file number_lookups\&.C\&.
.PP
Referenced by libMesh::FE< Dim, T >::shape(), and libMesh::FE< Dim, T >::shape_deriv()\&.
.SS "KSP* libMesh::subksps"

.PP
Definition at line 272 of file petsc_preconditioner\&.C\&.
.SS "\fBNonlinearImplicitSystem\fP & libMesh::sys = solver\&.system()"

.PP
Definition at line 154 of file petsc_diff_solver\&.C\&.
.PP
Referenced by __libmesh_petsc_diff_solver_residual(), __libmesh_petsc_snes_residual(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::EquationSystems::_read_impl(), libMesh::EquationSystems::allgather(), libMesh::ExactSolution::attach_exact_deriv(), libMesh::ExactSolution::attach_exact_hessian(), libMesh::EquationSystems::clear(), libMesh::ExactSolution::compute_error(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::GMVIO::copy_nodal_solution(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), DMlibMeshFunction(), DMLibMeshSetSystem(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::ErrorEstimator::estimate_errors(), libMesh::ExactSolution::ExactSolution(), if(), libMesh::System::read_legacy_data(), libMesh::EquationSystems::reinit(), libMesh::DifferentiablePhysics::set_mesh_system(), libMesh::FEMContext::set_mesh_system(), libMesh::NoxNonlinearSolver< T >::solve(), libMesh::VTKIO::system_vectors_to_vtk(), libMesh::EnsightIO::write_case(), and libMesh::EnsightIO::write_solution_ascii()\&.
.SS "static const \fBReal\fP libMesh::TOLERANCE = 1\&.e-8\fC [static]\fP"

.PP
Definition at line 127 of file libmesh_common\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_qoi_parameter_sensitivity(), libMesh::ImplicitSystem::assemble_residual_derivatives(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::Elem::contains_point(), libMesh::EquationSystems::EquationSystems(), libMesh::MemorySolutionHistory::find_stored_entry(), libMesh::ImplicitSystem::forward_qoi_parameter_sensitivity(), libMesh::LocationMap< T >::key(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::TypeTensor< T >::operator==(), libMesh::ImplicitSystem::qoi_parameter_hessian(), libMesh::ImplicitSystem::qoi_parameter_hessian_vector_product(), libMesh::Elem::refine(), libMesh::MemorySolutionHistory::retrieve(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::NewtonSolver::solve(), libMesh::SerialMesh::stitching_helper(), libMesh::MemorySolutionHistory::store(), libMesh::TriangleInterface::triangulate(), libMesh::Edge3::volume(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.SS "const unsigned char libMesh::triangular_number_column"
\fBInitial value:\fP
.PP
.nf
= {
  0,
  0, 1,
  0, 1, 2,
  0, 1, 2, 3,
  0, 1, 2, 3, 4,
  0, 1, 2, 3, 4, 5,
  0, 1, 2, 3, 4, 5, 6,
  0, 1, 2, 3, 4, 5, 6, 7,
  0, 1, 2, 3, 4, 5, 6, 7, 8,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9
}
.fi
.PP
Definition at line 42 of file number_lookups\&.C\&.
.PP
Referenced by libMesh::FE< Dim, T >::shape()\&.
.SS "const unsigned char libMesh::triangular_number_row"
\fBInitial value:\fP
.PP
.nf
= {
  0,
  1, 1,
  2, 2, 2,
  3, 3, 3, 3,
  4, 4, 4, 4, 4,
  5, 5, 5, 5, 5, 5,
  6, 6, 6, 6, 6, 6, 6,
  7, 7, 7, 7, 7, 7, 7, 7,
  8, 8, 8, 8, 8, 8, 8, 8, 8,
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9
}
.fi
.PP
Definition at line 29 of file number_lookups\&.C\&.
.PP
Referenced by libMesh::FE< Dim, T >::shape()\&.
.SS "libMesh::TRILINOS_SOLVERS"

.PP
Definition at line 235 of file libmesh\&.C\&.
.PP
Referenced by libMesh::LinearSolver< T >::build(), libMesh::NonlinearSolver< T >::build(), libMesh::Preconditioner< T >::build(), libMesh::SparseMatrix< T >::build(), libMesh::NumericVector< T >::build(), and default_solver_package()\&.
.SS "\fBPetscErrorCode\fP Vec libMesh::x"

.PP
Definition at line 143 of file petsc_diff_solver\&.C\&.
.PP
Referenced by libMesh::DenseMatrix< T >::_cholesky_back_substitute(), libMesh::SFCPartitioner::_do_partition(), libMesh::DenseMatrix< T >::_lu_back_substitute(), libMesh::DenseMatrix< T >::_matvec_blas(), libMesh::VariationalMeshSmoother::adp_renew(), libMesh::PetscPreconditioner< T >::apply(), libMesh::Utility::do_pow< 6, T >::apply(), libMesh::Utility::do_pow< 1, T >::apply(), libMesh::MeshTools::Generation::build_cube(), libMesh::VariationalMeshSmoother::gener(), libMesh::QMonomial::kim_rule(), libMesh::NewtonSolver::line_search(), libMesh::GmshIO::read_mesh(), libMesh::AbaqusIO::read_nodes(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshTools::Modification::rotate(), libMesh::TetGenWrapper::set_hole(), libMesh::TetGenWrapper::set_node(), libMesh::TetGenWrapper::set_region(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::NoxNonlinearSolver< T >::solve(), libMesh::PetscDMNonlinearSolver< T >::solve(), libMesh::PatchRecoveryErrorEstimator::specpoly(), libMesh::QMonomial::stroud_rule(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), and libMesh::TypeVector< T >::TypeVector()\&.
.SS "\fBPetscVector\fP<\fBNumber\fP>& libMesh::X_sys = *\fBlibmesh_cast_ptr\fP<\fBPetscVector\fP<\fBNumber\fP>*>(sys\&.solution\&.get())"

.PP
Definition at line 191 of file petsc_nonlinear_solver\&.C\&.
.PP
Referenced by __libmesh_petsc_snes_residual(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), and DMlibMeshFunction()\&.
.SS "\fBif\fP (solver\&.verbose) libMesh \fBPetscVector\fP<\fBNumber\fP>& libMesh::X_system"
\fBInitial value:\fP
.PP
.nf
=
      *libmesh_cast_ptr<PetscVector<Number>*>(sys\&.solution\&.get())
.fi
.PP
Definition at line 159 of file petsc_diff_solver\&.C\&.
.PP
Referenced by __libmesh_petsc_diff_solver_residual()\&.
.SS "const \fBNumber\fP libMesh::zero = 0\&."
$ zero=0. $\&. 
.PP
Definition at line 159 of file libmesh\&.h\&.
.PP
Referenced by libMesh::DenseMatrix< T >::_lu_decompose(), libMesh::HPCoarsenTest::add_projection(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::PetscMatrix< T >::init(), libMesh::DistributedVector< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::init(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshData::operator()(), libMesh::System::read_legacy_data(), libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::HPCoarsenTest::select_refinement(), and libMesh::FE< Dim, T >::side_map()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
