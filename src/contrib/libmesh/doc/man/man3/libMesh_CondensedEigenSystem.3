.TH "libMesh::CondensedEigenSystem" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::CondensedEigenSystem \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <condensed_eigen_system\&.h>\fP
.PP
Inherits \fBlibMesh::EigenSystem\fP\&.
.PP
Inherited by \fBlibMesh::RBConstructionBase< CondensedEigenSystem >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBCondensedEigenSystem\fP \fBsys_type\fP"
.br
.ti -1c
.RI "typedef \fBEigenSystem\fP \fBParent\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBNumericVector\fP< \fBNumber\fP >
.br
 * >::iterator \fBvectors_iterator\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBNumericVector\fP< \fBNumber\fP >
.br
 * >::const_iterator \fBconst_vectors_iterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCondensedEigenSystem\fP (\fBEquationSystems\fP &es, const std::string &\fBname\fP, const unsigned int \fBnumber\fP)"
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "void \fBinitialize_condensed_dofs\fP (std::set< unsigned int > &global_dirichlet_dofs_set)"
.br
.ti -1c
.RI "unsigned int \fBn_global_non_condensed_dofs\fP () const "
.br
.ti -1c
.RI "virtual void \fBsolve\fP ()"
.br
.ti -1c
.RI "virtual std::pair< \fBReal\fP, \fBReal\fP > \fBget_eigenpair\fP (unsigned int i)"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble\fP ()"
.br
.ti -1c
.RI "virtual std::string \fBsystem_type\fP () const "
.br
.ti -1c
.RI "virtual unsigned int \fBn_matrices\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_n_converged\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_n_iterations\fP () const "
.br
.ti -1c
.RI "void \fBset_eigenproblem_type\fP (\fBEigenProblemType\fP ept)"
.br
.ti -1c
.RI "\fBEigenProblemType\fP \fBget_eigenproblem_type\fP () const "
.br
.ti -1c
.RI "bool \fBgeneralized\fP () const "
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble_qoi\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual void \fBassemble_qoi_derivative\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual void \fBassemble_residual_derivatives\fP (const \fBParameterVector\fP &parameters)"
.br
.ti -1c
.RI "virtual void \fBrestrict_solve_to\fP (const \fBSystemSubset\fP *subset, const \fBSubsetSolveMode\fP subset_solve_mode=\fBSUBSET_ZERO\fP)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBsensitivity_solve\fP (const \fBParameterVector\fP &parameters)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBweighted_sensitivity_solve\fP (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBadjoint_solve\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBweighted_sensitivity_adjoint_solve\fP (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights, const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "bool \fBis_adjoint_already_solved\fP () const "
.br
.ti -1c
.RI "void \fBset_adjoint_already_solved\fP (bool setting)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual void \fBadjoint_qoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual void \fBforward_qoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_hessian\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &hessian)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_hessian_vector_product\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &vector, \fBSensitivityData\fP &product)"
.br
.ti -1c
.RI "virtual bool \fBcompare\fP (const \fBSystem\fP &other_system, const \fBReal\fP threshold, const bool verbose) const "
.br
.ti -1c
.RI "const std::string & \fBname\fP () const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &parameters) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const "
.br
.ti -1c
.RI "void \fBboundary_project_solution\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL)"
.br
.ti -1c
.RI "void \fBboundary_project_solution\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &parameters)"
.br
.ti -1c
.RI "void \fBboundary_project_vector\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBboundary_project_vector\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &parameters, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const "
.br
.ti -1c
.RI "unsigned int \fBnumber\fP () const "
.br
.ti -1c
.RI "void \fBupdate_global_solution\fP (std::vector< \fBNumber\fP > &global_soln) const "
.br
.ti -1c
.RI "void \fBupdate_global_solution\fP (std::vector< \fBNumber\fP > &global_soln, const unsigned int dest_proc) const "
.br
.ti -1c
.RI "const \fBMeshBase\fP & \fBget_mesh\fP () const "
.br
.ti -1c
.RI "\fBMeshBase\fP & \fBget_mesh\fP ()"
.br
.ti -1c
.RI "const \fBDofMap\fP & \fBget_dof_map\fP () const "
.br
.ti -1c
.RI "\fBDofMap\fP & \fBget_dof_map\fP ()"
.br
.ti -1c
.RI "const \fBEquationSystems\fP & \fBget_equation_systems\fP () const "
.br
.ti -1c
.RI "\fBEquationSystems\fP & \fBget_equation_systems\fP ()"
.br
.ti -1c
.RI "bool \fBactive\fP () const "
.br
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.ti -1c
.RI "void \fBset_basic_system_only\fP ()"
.br
.ti -1c
.RI "\fBvectors_iterator\fP \fBvectors_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_vectors_iterator\fP \fBvectors_begin\fP () const "
.br
.ti -1c
.RI "\fBvectors_iterator\fP \fBvectors_end\fP ()"
.br
.ti -1c
.RI "\fBconst_vectors_iterator\fP \fBvectors_end\fP () const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_vector\fP (const std::string &vec_name, const bool projections=true, const \fBParallelType\fP type=\fBPARALLEL\fP)"
.br
.ti -1c
.RI "void \fBremove_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "bool & \fBproject_solution_on_reinit\fP (void)"
.br
.ti -1c
.RI "bool \fBhave_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const unsigned int vec_num)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const unsigned int vec_num)"
.br
.ti -1c
.RI "const std::string & \fBvector_name\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "const std::string & \fBvector_name\fP (const \fBNumericVector\fP< \fBNumber\fP > &vec_reference) const "
.br
.ti -1c
.RI "void \fBset_vector_preservation\fP (const std::string &vec_name, bool preserve)"
.br
.ti -1c
.RI "bool \fBvector_preservation\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_sensitivity_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_weighted_sensitivity_solution\fP ()"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_solution\fP ()"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_solution\fP () const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_adjoint_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_rhs\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_sensitivity_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_rhs\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "unsigned int \fBn_vectors\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_variable_groups\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_components\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_dofs\fP () const "
.br
.ti -1c
.RI "unsigned int \fBadd_variable\fP (const std::string &var, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variable\fP (const std::string &var, const \fBOrder\fP order=\fBFIRST\fP, const \fBFEFamily\fP=\fBLAGRANGE\fP, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variables\fP (const std::vector< std::string > &vars, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variables\fP (const std::vector< std::string > &vars, const \fBOrder\fP order=\fBFIRST\fP, const \fBFEFamily\fP=\fBLAGRANGE\fP, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "const \fBVariable\fP & \fBvariable\fP (unsigned int var) const "
.br
.ti -1c
.RI "const \fBVariableGroup\fP & \fBvariable_group\fP (unsigned int vg) const "
.br
.ti -1c
.RI "bool \fBhas_variable\fP (const std::string &var) const "
.br
.ti -1c
.RI "const std::string & \fBvariable_name\fP (const unsigned int i) const "
.br
.ti -1c
.RI "unsigned short int \fBvariable_number\fP (const std::string &var) const "
.br
.ti -1c
.RI "void \fBget_all_variable_numbers\fP (std::vector< unsigned int > &all_variable_numbers) const "
.br
.ti -1c
.RI "unsigned int \fBvariable_scalar_number\fP (const std::string &var, unsigned int component) const "
.br
.ti -1c
.RI "unsigned int \fBvariable_scalar_number\fP (unsigned int var_num, unsigned int component) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_type\fP (const unsigned int i) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_type\fP (const std::string &var) const "
.br
.ti -1c
.RI "bool \fBidentify_variable_groups\fP () const "
.br
.ti -1c
.RI "void \fBidentify_variable_groups\fP (const bool)"
.br
.ti -1c
.RI "\fBReal\fP \fBcalculate_norm\fP (const \fBNumericVector\fP< \fBNumber\fP > &v, unsigned int var, \fBFEMNormType\fP norm_type) const "
.br
.ti -1c
.RI "\fBReal\fP \fBcalculate_norm\fP (const \fBNumericVector\fP< \fBNumber\fP > &v, const \fBSystemNorm\fP &norm) const "
.br
.ti -1c
.RI "void \fBread_header\fP (\fBXdr\fP &io, const std::string &version, const bool read_header=true, const bool read_additional_data=true, const bool read_legacy_format=false)"
.br
.ti -1c
.RI "void \fBread_legacy_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "template<typename ValType > void \fBread_serialized_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "void \fBread_serialized_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "template<typename InValType > std::size_t \fBread_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "std::size_t \fBread_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "template<typename InValType > void \fBread_parallel_data\fP (\fBXdr\fP &io, const bool read_additional_data)"
.br
.ti -1c
.RI "void \fBread_parallel_data\fP (\fBXdr\fP &io, const bool read_additional_data)"
.br
.ti -1c
.RI "void \fBwrite_header\fP (\fBXdr\fP &io, const std::string &version, const bool write_additional_data) const "
.br
.ti -1c
.RI "void \fBwrite_serialized_data\fP (\fBXdr\fP &io, const bool write_additional_data=true) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBwrite_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< const \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "void \fBwrite_parallel_data\fP (\fBXdr\fP &io, const bool write_additional_data) const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "void \fBattach_init_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_init_object\fP (\fBInitialization\fP &\fBinit\fP)"
.br
.ti -1c
.RI "void \fBattach_assemble_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_assemble_object\fP (\fBAssembly\fP &\fBassemble\fP)"
.br
.ti -1c
.RI "void \fBattach_constraint_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_constraint_object\fP (\fBConstraint\fP &constrain)"
.br
.ti -1c
.RI "void \fBattach_QOI_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP, const \fBQoISet\fP &qoi_indices))"
.br
.ti -1c
.RI "void \fBattach_QOI_object\fP (\fBQOI\fP &\fBqoi\fP)"
.br
.ti -1c
.RI "void \fBattach_QOI_derivative\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP, const \fBQoISet\fP &qoi_indices))"
.br
.ti -1c
.RI "void \fBattach_QOI_derivative_object\fP (\fBQOIDerivative\fP &qoi_derivative)"
.br
.ti -1c
.RI "virtual void \fBuser_initialization\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_assembly\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_constrain\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_QOI\fP (const \fBQoISet\fP &qoi_indices)"
.br
.ti -1c
.RI "virtual void \fBuser_QOI_derivative\fP (const \fBQoISet\fP &qoi_indices)"
.br
.ti -1c
.RI "virtual void \fBre_update\fP ()"
.br
.ti -1c
.RI "virtual void \fBrestrict_vectors\fP ()"
.br
.ti -1c
.RI "virtual void \fBprolong_vectors\fP ()"
.br
.ti -1c
.RI "virtual void \fBdisable_cache\fP ()"
.br
.ti -1c
.RI "\fBNumber\fP \fBcurrent_solution\fP (const \fBdof_id_type\fP global_dof_number) const "
.br
.ti -1c
.RI "\fBNumber\fP \fBpoint_value\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBNumber\fP \fBpoint_value\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "\fBGradient\fP \fBpoint_gradient\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBGradient\fP \fBpoint_gradient\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "\fBTensor\fP \fBpoint_hessian\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBTensor\fP \fBpoint_hessian\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "void \fBlocal_dof_indices\fP (const unsigned int var, std::set< \fBdof_id_type\fP > &var_indices) const "
.br
.ti -1c
.RI "void \fBzero_variable\fP (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned int var_num) const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBcondensed_matrix_A\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBcondensed_matrix_B\fP"
.br
.ti -1c
.RI "std::vector< \fBdof_id_type\fP > \fBlocal_non_condensed_dofs_vector\fP"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBmatrix_A\fP"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBmatrix_B\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBEigenSolver\fP< \fBNumber\fP > > \fBeigen_solver\fP"
.br
.ti -1c
.RI "bool \fBassemble_before_solve\fP"
.br
.ti -1c
.RI "bool \fBuse_fixed_solution\fP"
.br
.ti -1c
.RI "int \fBextra_quadrature_order\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBsolution\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBcurrent_local_solution\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBtime\fP"
.br
.ti -1c
.RI "std::vector< \fBNumber\fP > \fBqoi\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBinit_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit_matrices\fP ()"
.br
.ti -1c
.RI "void \fBset_n_converged\fP (unsigned int nconv)"
.br
.ti -1c
.RI "void \fBset_n_iterations\fP (unsigned int its)"
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (const \fBNumericVector\fP< \fBNumber\fP > &, \fBNumericVector\fP< \fBNumber\fP > &) const "
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &\fBname\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBcondensed_dofs_initialized\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class extends \fBEigenSystem\fP to allow a simple way of solving (standard or generalized) eigenvalue problems in the case where we want to remove certain degrees of freedom from the system\&. This is useful, for example, in the case that one wants to solve eigenvalue problems with Dirichlet boundary conditions\&. 
.PP
Definition at line 48 of file condensed_eigen_system\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, \fBNumericVector\fP<\fBNumber\fP>* >::const_iterator \fBlibMesh::System::const_vectors_iterator\fP\fC [inherited]\fP"

.PP
Definition at line 718 of file system\&.h\&.
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBEigenSystem\fP \fBlibMesh::CondensedEigenSystem::Parent\fP"
The type of the parent 
.PP
Definition at line 68 of file condensed_eigen_system\&.h\&.
.SS "typedef \fBCondensedEigenSystem\fP \fBlibMesh::CondensedEigenSystem::sys_type\fP"
The type of system\&. 
.PP
Definition at line 63 of file condensed_eigen_system\&.h\&.
.SS "typedef std::map<std::string, \fBNumericVector\fP<\fBNumber\fP>* >::iterator \fBlibMesh::System::vectors_iterator\fP\fC [inherited]\fP"
Vector iterator typedefs\&. 
.PP
Definition at line 717 of file system\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::CondensedEigenSystem::CondensedEigenSystem (\fBEquationSystems\fP &es, const std::string &name, const unsigned intnumber)"
Constructor\&. Optionally initializes required data structures\&. 
.PP
Definition at line 34 of file condensed_eigen_system\&.C\&.
.PP
.nf
37   : Parent(es, name, number),
38     condensed_matrix_A(SparseMatrix<Number>::build(es\&.comm())),
39     condensed_matrix_B(SparseMatrix<Number>::build(es\&.comm())),
40     condensed_dofs_initialized(false)
41 {
42 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::System::activate ()\fC [inline]\fP, \fC [inherited]\fP"
Activates the system\&. Only active systems are solved\&. 
.PP
Definition at line 1927 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1928 {
1929   _active = true;
1930 }
.fi
.SS "bool libMesh::System::active () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the system is active, \fCfalse\fP otherwise\&. An active system will be solved\&. 
.RE
.PP

.PP
Definition at line 1919 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1920 {
1921   return _active;
1922 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_adjoint_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 1017 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ExplicitSystem::assemble_qoi_derivative(), and libMesh::FEMSystem::assemble_qoi_derivative()\&.
.PP
.nf
1018 {
1019   std::ostringstream adjoint_rhs_name;
1020   adjoint_rhs_name << "adjoint_rhs" << i;
1021 
1022   return this->add_vector(adjoint_rhs_name\&.str(), false);
1023 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 957 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve()\&.
.PP
.nf
958 {
959   std::ostringstream adjoint_name;
960   adjoint_name << "adjoint_solution" << i;
961 
962   return this->add_vector(adjoint_name\&.str());
963 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_sensitivity_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 1047 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::assemble_residual_derivatives()\&.
.PP
.nf
1048 {
1049   std::ostringstream sensitivity_rhs_name;
1050   sensitivity_rhs_name << "sensitivity_rhs" << i;
1051 
1052   return this->add_vector(sensitivity_rhs_name\&.str(), false);
1053 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_sensitivity_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 906 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
907 {
908   std::ostringstream sensitivity_name;
909   sensitivity_name << "sensitivity_solution" << i;
910 
911   return this->add_vector(sensitivity_name\&.str());
912 }
.fi
.SS "unsigned int libMesh::System::add_variable (const std::string &var, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Returns the index number for the new variable\&. 
.PP
Definition at line 1077 of file system\&.C\&.
.PP
References libMesh::System::_variable_groups, libMesh::System::_variable_numbers, libMesh::System::_variables, libMesh::System::add_variables(), libMesh::err, libMesh::System::identify_variable_groups(), libMesh::System::n_variable_groups(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::System::variable_name(), and libMesh::System::variable_type()\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::ErrorVector::plot_error(), and libMesh::System::read_header()\&.
.PP
.nf
1080 {
1081   // Make sure the variable isn't there already
1082   // or if it is, that it's the type we want
1083   for (unsigned int v=0; v<this->n_vars(); v++)
1084     if (this->variable_name(v) == var)
1085       {
1086         if (this->variable_type(v) == type)
1087           return _variables[v]\&.number();
1088 
1089         libMesh::err << "ERROR: incompatible variable "
1090                      << var
1091                      << " has already been added for this system!"
1092                      << std::endl;
1093         libmesh_error();
1094       }
1095 
1096   // Optimize for VariableGroups here - if the user is adding multiple
1097   // variables of the same FEType and subdomain restriction, catch
1098   // that here and add them as members of the same VariableGroup\&.
1099   //
1100   // start by setting this flag to whatever the user has requested
1101   // and then consider the conditions which should negate it\&.
1102   bool should_be_in_vg = this->identify_variable_groups();
1103 
1104   // No variable groups, nothing to add to
1105   if (!this->n_variable_groups())
1106     should_be_in_vg = false;
1107 
1108   else
1109     {
1110       VariableGroup &vg(_variable_groups\&.back());
1111 
1112       // get a pointer to their subdomain restriction, if any\&.
1113       const std::set<subdomain_id_type> * const
1114         their_active_subdomains (vg\&.implicitly_active() ?
1115                                  NULL : &vg\&.active_subdomains());
1116 
1117       // Different types?
1118       if (vg\&.type() != type)
1119         should_be_in_vg = false;
1120 
1121       // they are restricted, we aren't?
1122       if (their_active_subdomains && !active_subdomains)
1123         should_be_in_vg = false;
1124 
1125       // they aren't restriced, we are?
1126       if (!their_active_subdomains && active_subdomains)
1127         should_be_in_vg = false;
1128 
1129       if (their_active_subdomains && active_subdomains)
1130         // restricted to different sets?
1131         if (*their_active_subdomains != *active_subdomains)
1132           should_be_in_vg = false;
1133 
1134       // OK, after all that, append the variable to the vg if none of the conditions
1135       // were violated
1136       if (should_be_in_vg)
1137         {
1138           const unsigned int curr_n_vars = this->n_vars();
1139 
1140           vg\&.append (var);
1141 
1142           _variables\&.push_back(vg(vg\&.n_variables()-1));
1143           _variable_numbers[var] = curr_n_vars;
1144           return curr_n_vars;
1145         }
1146     }
1147 
1148   // otherwise, fall back to adding a single variable group
1149   return this->add_variables (std::vector<std::string>(1, var),
1150                               type,
1151                               active_subdomains);
1152 }
.fi
.SS "unsigned int libMesh::System::add_variable (const std::string &var, const \fBOrder\fPorder = \fC\fBFIRST\fP\fP, const \fBFEFamily\fPfamily = \fC\fBLAGRANGE\fP\fP, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Same as before, but assumes \fCLAGRANGE\fP as default value for \fC\fBFEType\&.family\fP\fP\&. 
.PP
Definition at line 1156 of file system\&.C\&.
.PP
References libMesh::System::add_variable()\&.
.PP
.nf
1160 {
1161   return this->add_variable(var,
1162                             FEType(order, family),
1163                             active_subdomains);
1164 }
.fi
.SS "unsigned int libMesh::System::add_variables (const std::vector< std::string > &vars, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Returns the index number for the new variable\&. 
.PP
Definition at line 1168 of file system\&.C\&.
.PP
References libMesh::System::_variable_groups, libMesh::System::_variable_numbers, libMesh::System::_variables, libMesh::err, libMesh::System::n_components(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::System::variable_name(), and libMesh::System::variable_type()\&.
.PP
Referenced by libMesh::System::add_variable(), and libMesh::System::add_variables()\&.
.PP
.nf
1171 {
1172   // Make sure the variable isn't there already
1173   // or if it is, that it's the type we want
1174   for (unsigned int ov=0; ov<vars\&.size(); ov++)
1175     for (unsigned int v=0; v<this->n_vars(); v++)
1176       if (this->variable_name(v) == vars[ov])
1177         {
1178           if (this->variable_type(v) == type)
1179             return _variables[v]\&.number();
1180 
1181           libMesh::err << "ERROR: incompatible variable "
1182                        << vars[ov]
1183                        << " has already been added for this system!"
1184                        << std::endl;
1185           libmesh_error();
1186         }
1187 
1188   const unsigned int curr_n_vars = this->n_vars();
1189 
1190   const unsigned int next_first_component = this->n_components();
1191 
1192   // Add the variable group to the list
1193   _variable_groups\&.push_back((active_subdomains == NULL) ?
1194                              VariableGroup(this, vars, curr_n_vars,
1195                                            next_first_component, type) :
1196                              VariableGroup(this, vars, curr_n_vars,
1197                                            next_first_component, type, *active_subdomains));
1198 
1199   const VariableGroup &vg (_variable_groups\&.back());
1200 
1201   // Add each component of the group individually
1202   for (unsigned int v=0; v<vars\&.size(); v++)
1203     {
1204       _variables\&.push_back (vg(v));
1205       _variable_numbers[vars[v]] = curr_n_vars+v;
1206     }
1207 
1208   libmesh_assert_equal_to ((curr_n_vars+vars\&.size()), this->n_vars());
1209 
1210   // BSK - Defer this now to System::init_data() so we can detect
1211   // VariableGroups 12/28/2012
1212   // // Add the variable group to the _dof_map
1213   // _dof_map->add_variable_group (vg);
1214 
1215   // Return the number of the new variable
1216   return curr_n_vars+vars\&.size()-1;
1217 }
.fi
.SS "unsigned int libMesh::System::add_variables (const std::vector< std::string > &vars, const \fBOrder\fPorder = \fC\fBFIRST\fP\fP, const \fBFEFamily\fPfamily = \fC\fBLAGRANGE\fP\fP, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Same as before, but assumes \fCLAGRANGE\fP as default value for \fC\fBFEType\&.family\fP\fP\&. 
.PP
Definition at line 1221 of file system\&.C\&.
.PP
References libMesh::System::add_variables()\&.
.PP
.nf
1225 {
1226   return this->add_variables(vars,
1227                              FEType(order, family),
1228                              active_subdomains);
1229 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_vector (const std::string &vec_name, const boolprojections = \fCtrue\fP, const \fBParallelType\fPtype = \fC\fBPARALLEL\fP\fP)\fC [inherited]\fP"
Adds the additional vector \fCvec_name\fP to this system\&. All the additional vectors are similarly distributed, like the \fCsolution\fP, and inititialized to zero\&.
.PP
By default vectors added by add_vector are projected to changed grids by \fBreinit()\fP\&. To zero them instead (more efficient), pass 'false' as the second argument 
.PP
Definition at line 676 of file system\&.C\&.
.PP
References libMesh::System::_can_add_vectors, libMesh::System::_dof_map, libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, libMesh::NumericVector< T >::build(), libMesh::ParallelObject::comm(), libMesh::err, libMesh::GHOSTED, libMesh::System::have_vector(), libMesh::NumericVector< T >::init(), libMesh::System::n_dofs(), and libMesh::System::n_local_dofs()\&.
.PP
Referenced by libMesh::System::add_adjoint_rhs(), libMesh::System::add_adjoint_solution(), libMesh::System::add_sensitivity_rhs(), libMesh::System::add_sensitivity_solution(), libMesh::ExplicitSystem::add_system_rhs(), libMesh::System::add_weighted_sensitivity_adjoint_solution(), libMesh::System::add_weighted_sensitivity_solution(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnsteadySolver::init(), libMesh::ContinuationSystem::init_data(), libMesh::NewmarkSystem::NewmarkSystem(), libMesh::System::read_header(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), and libMesh::FrequencySystem::set_frequencies_by_steps()\&.
.PP
.nf
679 {
680   // Return the vector if it is already there\&.
681   if (this->have_vector(vec_name))
682     return *(_vectors[vec_name]);
683 
684   // Otherwise build the vector
685   NumericVector<Number>* buf = NumericVector<Number>::build(this->comm())\&.release();
686   _vectors\&.insert (std::make_pair (vec_name, buf));
687   _vector_projections\&.insert (std::make_pair (vec_name, projections));
688 
689   _vector_types\&.insert (std::make_pair (vec_name, type));
690 
691   // Initialize it if necessary
692   if (!_can_add_vectors)
693     {
694       if(type == GHOSTED)
695         {
696 #ifdef LIBMESH_ENABLE_GHOSTED
697           buf->init (this->n_dofs(), this->n_local_dofs(),
698                      _dof_map->get_send_list(), false,
699                      GHOSTED);
700 #else
701           libMesh::err << "Cannot initialize ghosted vectors when they are not enabled\&." << std::endl;
702           libmesh_error();
703 #endif
704         }
705       else
706         buf->init (this->n_dofs(), this->n_local_dofs(), false, type);
707     }
708 
709   return *buf;
710 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 987 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
988 {
989   std::ostringstream adjoint_name;
990   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
991 
992   return this->add_vector(adjoint_name\&.str());
993 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_weighted_sensitivity_solution ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 936 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
937 {
938   return this->add_vector("weighted_sensitivity_solution");
939 }
.fi
.SS "void libMesh::System::adjoint_qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Solves for parameter sensitivities using the adjoint method\&.
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2156 of file system\&.h\&.
.PP
.nf
2159 {
2160   libmesh_not_implemented();
2161 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::System::adjoint_solve (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Solves the adjoint system, for the specified qoi indices, or for every qoi if \fCqoi_indices\fP is NULL\&. Must be overloaded in derived systems\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP, and \fBlibMesh::DifferentiableSystem\fP\&.
.PP
Definition at line 2140 of file system\&.h\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::AdjointResidualErrorEstimator::estimate_error()\&.
.PP
.nf
2141 {
2142   libmesh_not_implemented();
2143 }
.fi
.SS "void libMesh::EigenSystem::assemble ()\fC [virtual]\fP, \fC [inherited]\fP"
Assembles the system matrix\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 251 of file eigen_system\&.C\&.
.PP
References libMesh::System::assemble()\&.
.PP
Referenced by solve(), and libMesh::EigenSystem::solve()\&.
.PP
.nf
252 {
253 
254   // Assemble the linear system
255   Parent::assemble ();
256 
257 }
.fi
.SS "void libMesh::System::assemble_qoi (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user qoi function\&. \fICan\fP be overloaded in derived classes\&. 
.PP
Reimplemented in \fBlibMesh::FEMSystem\fP, and \fBlibMesh::ExplicitSystem\fP\&.
.PP
Definition at line 481 of file system\&.C\&.
.PP
References libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::System::user_QOI()\&.
.PP
Referenced by libMesh::ExplicitSystem::assemble_qoi()\&.
.PP
.nf
482 {
483   // Log how long the user's assembly code takes
484   START_LOG("assemble_qoi()", "System");
485 
486   // Call the user-specified quantity of interest function
487   this->user_QOI(qoi_indices);
488 
489   // Stop logging the user code
490   STOP_LOG("assemble_qoi()", "System");
491 }
.fi
.SS "void libMesh::System::assemble_qoi_derivative (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user qoi derivative function\&. \fICan\fP be overloaded in derived classes\&. 
.PP
Reimplemented in \fBlibMesh::FEMSystem\fP, and \fBlibMesh::ExplicitSystem\fP\&.
.PP
Definition at line 495 of file system\&.C\&.
.PP
References libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::System::user_QOI_derivative()\&.
.PP
Referenced by libMesh::ExplicitSystem::assemble_qoi_derivative()\&.
.PP
.nf
496 {
497   // Log how long the user's assembly code takes
498   START_LOG("assemble_qoi_derivative()", "System");
499 
500   // Call the user-specified quantity of interest function
501   this->user_QOI_derivative(qoi_indices);
502 
503   // Stop logging the user code
504   STOP_LOG("assemble_qoi_derivative()", "System");
505 }
.fi
.SS "void libMesh::System::assemble_residual_derivatives (const \fBParameterVector\fP &parameters)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Calls residual parameter derivative function\&.
.PP
Library subclasses use finite differences by default\&.
.PP
This should assemble the sensitivity rhs vectors to hold -(partial R / partial p_i), making them ready to solve the forward sensitivity equation\&.
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2115 of file system\&.h\&.
.PP
.nf
2116 {
2117   libmesh_not_implemented();
2118 }
.fi
.SS "void libMesh::System::attach_assemble_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function to use in assembling the system matrix and RHS\&. 
.PP
Definition at line 1754 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1756 {
1757   libmesh_assert(fptr);
1758 
1759   if (_assemble_system_object != NULL)
1760     {
1761       libmesh_here();
1762       libMesh::out << "WARNING:  Cannot specify both assembly function and object!"
1763                    << std::endl;
1764 
1765       _assemble_system_object = NULL;
1766     }
1767 
1768   _assemble_system_function = fptr;
1769 }
.fi
.SS "void libMesh::System::attach_assemble_object (\fBSystem::Assembly\fP &assemble_in)\fC [inherited]\fP"
Register a user object to use in assembling the system matrix and RHS\&. 
.PP
Definition at line 1773 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, and libMesh::out\&.
.PP
.nf
1774 {
1775   if (_assemble_system_function != NULL)
1776     {
1777       libmesh_here();
1778       libMesh::out << "WARNING:  Cannot specify both assembly object and function!"
1779                    << std::endl;
1780 
1781       _assemble_system_function = NULL;
1782     }
1783 
1784   _assemble_system_object = &assemble_in;
1785 }
.fi
.SS "void libMesh::System::attach_constraint_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function for imposing constraints\&. 
.PP
Definition at line 1789 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1791 {
1792   libmesh_assert(fptr);
1793 
1794   if (_constrain_system_object != NULL)
1795     {
1796       libmesh_here();
1797       libMesh::out << "WARNING:  Cannot specify both constraint function and object!"
1798                    << std::endl;
1799 
1800       _constrain_system_object = NULL;
1801     }
1802 
1803   _constrain_system_function = fptr;
1804 }
.fi
.SS "void libMesh::System::attach_constraint_object (\fBSystem::Constraint\fP &constrain)\fC [inherited]\fP"
Register a user object for imposing constraints\&. 
.PP
Definition at line 1808 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, and libMesh::out\&.
.PP
.nf
1809 {
1810   if (_constrain_system_function != NULL)
1811     {
1812       libmesh_here();
1813       libMesh::out << "WARNING:  Cannot specify both constraint object and function!"
1814                    << std::endl;
1815 
1816       _constrain_system_function = NULL;
1817     }
1818 
1819   _constrain_system_object = &constrain;
1820 }
.fi
.SS "void libMesh::System::attach_init_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function to use in initializing the system\&. 
.PP
Definition at line 1719 of file system\&.C\&.
.PP
References libMesh::System::_init_system_function, libMesh::System::_init_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1721 {
1722   libmesh_assert(fptr);
1723 
1724   if (_init_system_object != NULL)
1725     {
1726       libmesh_here();
1727       libMesh::out << "WARNING:  Cannot specify both initialization function and object!"
1728                    << std::endl;
1729 
1730       _init_system_object = NULL;
1731     }
1732 
1733   _init_system_function = fptr;
1734 }
.fi
.SS "void libMesh::System::attach_init_object (\fBSystem::Initialization\fP &init_in)\fC [inherited]\fP"
Register a user class to use to initialize the system\&. Note this is exclusive with the \fCattach_init_function\fP\&. 
.PP
Definition at line 1738 of file system\&.C\&.
.PP
References libMesh::System::_init_system_function, libMesh::System::_init_system_object, and libMesh::out\&.
.PP
.nf
1739 {
1740   if (_init_system_function != NULL)
1741     {
1742       libmesh_here();
1743       libMesh::out << "WARNING:  Cannot specify both initialization object and function!"
1744                    << std::endl;
1745 
1746       _init_system_function = NULL;
1747     }
1748 
1749   _init_system_object = &init_in;
1750 }
.fi
.SS "void libMesh::System::attach_QOI_derivative (void fptrEquationSystems &es,const std::string &name,const QoISet &qoi_indices)\fC [inherited]\fP"
Register a user function for evaluating derivatives of a quantity of interest with respect to test functions, whose values should be placed in \fCSystem::rhs\fP 
.PP
Definition at line 1860 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1863 {
1864   libmesh_assert(fptr);
1865 
1866   if (_qoi_evaluate_derivative_object != NULL)
1867     {
1868       libmesh_here();
1869       libMesh::out << "WARNING:  Cannot specify both QOI derivative function and object!"
1870                    << std::endl;
1871 
1872       _qoi_evaluate_derivative_object = NULL;
1873     }
1874 
1875   _qoi_evaluate_derivative_function = fptr;
1876 }
.fi
.SS "void libMesh::System::attach_QOI_derivative_object (\fBQOIDerivative\fP &qoi_derivative)\fC [inherited]\fP"
Register a user object for evaluating derivatives of a quantity of interest with respect to test functions, whose values should be placed in \fCSystem::rhs\fP 
.PP
Definition at line 1880 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, and libMesh::out\&.
.PP
.nf
1881 {
1882   if (_qoi_evaluate_derivative_function != NULL)
1883     {
1884       libmesh_here();
1885       libMesh::out << "WARNING:  Cannot specify both QOI derivative object and function!"
1886                    << std::endl;
1887 
1888       _qoi_evaluate_derivative_function = NULL;
1889     }
1890 
1891   _qoi_evaluate_derivative_object = &qoi_derivative;
1892 }
.fi
.SS "void libMesh::System::attach_QOI_function (void fptrEquationSystems &es,const std::string &name,const QoISet &qoi_indices)\fC [inherited]\fP"
Register a user function for evaluating the quantities of interest, whose values should be placed in \fC\fBSystem::qoi\fP\fP 
.PP
Definition at line 1824 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1827 {
1828   libmesh_assert(fptr);
1829 
1830   if (_qoi_evaluate_object != NULL)
1831     {
1832       libmesh_here();
1833       libMesh::out << "WARNING:  Cannot specify both QOI function and object!"
1834                    << std::endl;
1835 
1836       _qoi_evaluate_object = NULL;
1837     }
1838 
1839   _qoi_evaluate_function = fptr;
1840 }
.fi
.SS "void libMesh::System::attach_QOI_object (\fBQOI\fP &qoi)\fC [inherited]\fP"
Register a user object for evaluating the quantities of interest, whose values should be placed in \fC\fBSystem::qoi\fP\fP 
.PP
Definition at line 1844 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, and libMesh::out\&.
.PP
.nf
1845 {
1846   if (_qoi_evaluate_function != NULL)
1847     {
1848       libmesh_here();
1849       libMesh::out << "WARNING:  Cannot specify both QOI object and function!"
1850                    << std::endl;
1851 
1852       _qoi_evaluate_function = NULL;
1853     }
1854 
1855   _qoi_evaluate_object = &qoi_in;
1856 }
.fi
.SS "void libMesh::System::boundary_project_solution (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP)\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitary boundary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 665 of file system_projection\&.C\&.
.PP
.nf
669 {
670   this->boundary_project_vector(b, variables, *solution, f, g);
671 
672   solution->localize(*current_local_solution);
673 }
.fi
.SS "void libMesh::System::boundary_project_solution (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters)\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects components of an arbitrary boundary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 641 of file system_projection\&.C\&.
.PP
.nf
652 {
653   WrappedFunction<Number> f(*this, fptr, &parameters);
654   WrappedFunction<Gradient> g(*this, gptr, &parameters);
655   this->boundary_project_solution(b, variables, &f, &g);
656 }
.fi
.SS "void libMesh::System::boundary_project_vector (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 707 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::get_dof_map(), libMesh::Threads::parallel_for(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
712 {
713   START_LOG ("boundary_project_vector()", "System");
714 
715   Threads::parallel_for
716     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
717                      this->get_mesh()\&.active_local_elements_end() ),
718      BoundaryProjectSolution(b, variables, *this, f, g,
719                              this->get_equation_systems()\&.parameters,
720                              new_vector)
721      );
722 
723   // We don't do SCALAR dofs when just projecting the boundary, so
724   // we're done here\&.
725 
726   new_vector\&.close();
727 
728 #ifdef LIBMESH_ENABLE_CONSTRAINTS
729   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
730 #endif
731 
732   STOP_LOG("boundary_project_vector()", "System");
733 }
.fi
.SS "void libMesh::System::boundary_project_vector (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary boundary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 684 of file system_projection\&.C\&.
.PP
.nf
696 {
697   WrappedFunction<Number> f(*this, fptr, &parameters);
698   WrappedFunction<Gradient> g(*this, gptr, &parameters);
699   this->boundary_project_vector(b, variables, new_vector, &f, &g);
700 }
.fi
.SS "\fBReal\fP libMesh::System::calculate_norm (const \fBNumericVector\fP< \fBNumber\fP > &v, unsigned intvar, \fBFEMNormType\fPnorm_type) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a norm of variable \fCvar\fP in the vector \fCv\fP, in the specified norm (e\&.g\&. L2, L_INF, H1) 
.RE
.PP

.PP
Definition at line 1380 of file system\&.C\&.
.PP
References libMesh::DISCRETE_L1, libMesh::DISCRETE_L2, libMesh::DISCRETE_L_INF, libMesh::System::discrete_var_norm(), libMesh::L2, libMesh::System::n_vars(), and libMesh::Real\&.
.PP
Referenced by libMesh::AdaptiveTimeSolver::calculate_norm(), and libMesh::UnsteadySolver::du()\&.
.PP
.nf
1383 {
1384   //short circuit to save time
1385   if(norm_type == DISCRETE_L1 ||
1386      norm_type == DISCRETE_L2 ||
1387      norm_type == DISCRETE_L_INF)
1388     return discrete_var_norm(v,var,norm_type);
1389 
1390   // Not a discrete norm
1391   std::vector<FEMNormType> norms(this->n_vars(), L2);
1392   std::vector<Real> weights(this->n_vars(), 0\&.0);
1393   norms[var] = norm_type;
1394   weights[var] = 1\&.0;
1395   Real val = this->calculate_norm(v, SystemNorm(norms, weights));
1396   return val;
1397 }
.fi
.SS "\fBReal\fP libMesh::System::calculate_norm (const \fBNumericVector\fP< \fBNumber\fP > &v, const \fBSystemNorm\fP &norm) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a norm of the vector \fCv\fP, using \fCcomponent_norm\fP and \fCcomponent_scale\fP to choose and weight the norms of each variable\&. 
.RE
.PP

.PP
Definition at line 1401 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, std::abs(), libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::TypeVector< T >::add_scaled(), libMesh::TypeTensor< T >::add_scaled(), libMesh::NumericVector< T >::build(), libMesh::FEGenericBase< T >::build(), libMesh::ParallelObject::comm(), libMesh::FEType::default_quadrature_rule(), libMesh::dim, libMesh::DISCRETE_L1, libMesh::DISCRETE_L2, libMesh::DISCRETE_L_INF, libMesh::System::discrete_var_norm(), libMesh::DofMap::dof_indices(), libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::H1, libMesh::H1_SEMINORM, libMesh::H2, libMesh::H2_SEMINORM, libMesh::SystemNorm::is_discrete(), libMesh::L1, libMesh::NumericVector< T >::l1_norm(), libMesh::L2, libMesh::NumericVector< T >::l2_norm(), libMesh::L_INF, libMesh::NumericVector< T >::linfty_norm(), libMesh::NumericVector< T >::localize(), std::max(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::System::n_vars(), libMesh::TensorTools::norm_sq(), libMesh::Real, libMesh::SERIAL, libMesh::TypeVector< T >::size(), libMesh::TypeTensor< T >::size(), libMesh::NumericVector< T >::size(), libMesh::TypeVector< T >::size_sq(), libMesh::TypeTensor< T >::size_sq(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Parallel::Communicator::sum(), libMesh::SystemNorm::type(), libMesh::DofMap::variable_type(), libMesh::W1_INF_SEMINORM, libMesh::W2_INF_SEMINORM, libMesh::SystemNorm::weight(), and libMesh::SystemNorm::weight_sq()\&.
.PP
.nf
1403 {
1404   // This function must be run on all processors at once
1405   parallel_object_only();
1406 
1407   START_LOG ("calculate_norm()", "System");
1408 
1409   // Zero the norm before summation
1410   Real v_norm = 0\&.;
1411 
1412   if (norm\&.is_discrete())
1413     {
1414       STOP_LOG ("calculate_norm()", "System");
1415       //Check to see if all weights are 1\&.0 and all types are equal
1416       FEMNormType norm_type0 = norm\&.type(0);
1417       unsigned int check_var = 0;
1418       for (; check_var != this->n_vars(); ++check_var)
1419         if((norm\&.weight(check_var) != 1\&.0) || (norm\&.type(check_var) != norm_type0))
1420           break;
1421 
1422       //All weights were 1\&.0 so just do the full vector discrete norm
1423       if(check_var == this->n_vars())
1424         {
1425           if(norm_type0 == DISCRETE_L1)
1426             return v\&.l1_norm();
1427           if(norm_type0 == DISCRETE_L2)
1428             return v\&.l2_norm();
1429           if(norm_type0 == DISCRETE_L_INF)
1430             return v\&.linfty_norm();
1431           else
1432             libmesh_error();
1433         }
1434 
1435       for (unsigned int var=0; var != this->n_vars(); ++var)
1436         {
1437           // Skip any variables we don't need to integrate
1438           if (norm\&.weight(var) == 0\&.0)
1439             continue;
1440 
1441           v_norm += norm\&.weight(var) * discrete_var_norm(v, var, norm\&.type(var));
1442         }
1443 
1444       return v_norm;
1445     }
1446 
1447   // Localize the potentially parallel vector
1448   AutoPtr<NumericVector<Number> > local_v = NumericVector<Number>::build(this->comm());
1449   local_v->init(v\&.size(), true, SERIAL);
1450   v\&.localize (*local_v, _dof_map->get_send_list());
1451 
1452   unsigned int dim = this->get_mesh()\&.mesh_dimension();
1453 
1454   // I'm not sure how best to mix Hilbert norms on some variables (for
1455   // which we'll want to square then sum then square root) with norms
1456   // like L_inf (for which we'll just want to take an absolute value
1457   // and then sum)\&.
1458   bool using_hilbert_norm = true,
1459     using_nonhilbert_norm = true;
1460 
1461   // Loop over all variables
1462   for (unsigned int var=0; var != this->n_vars(); ++var)
1463     {
1464       // Skip any variables we don't need to integrate
1465       Real norm_weight_sq = norm\&.weight_sq(var);
1466       if (norm_weight_sq == 0\&.0)
1467         continue;
1468       Real norm_weight = norm\&.weight(var);
1469 
1470       // Check for unimplemented norms (rather than just returning 0)\&.
1471       FEMNormType norm_type = norm\&.type(var);
1472       if((norm_type==H1) ||
1473          (norm_type==H2) ||
1474          (norm_type==L2) ||
1475          (norm_type==H1_SEMINORM) ||
1476          (norm_type==H2_SEMINORM))
1477         {
1478           if (!using_hilbert_norm)
1479             libmesh_not_implemented();
1480           using_nonhilbert_norm = false;
1481         }
1482       else if ((norm_type==L1) ||
1483                (norm_type==L_INF) ||
1484                (norm_type==W1_INF_SEMINORM) ||
1485                (norm_type==W2_INF_SEMINORM))
1486         {
1487           if (!using_nonhilbert_norm)
1488             libmesh_not_implemented();
1489           using_hilbert_norm = false;
1490         }
1491       else
1492         libmesh_not_implemented();
1493 
1494       const FEType& fe_type = this->get_dof_map()\&.variable_type(var);
1495       AutoPtr<QBase> qrule =
1496         fe_type\&.default_quadrature_rule (dim);
1497       AutoPtr<FEBase> fe
1498         (FEBase::build(dim, fe_type));
1499       fe->attach_quadrature_rule (qrule\&.get());
1500 
1501       const std::vector<Real>&               JxW = fe->get_JxW();
1502       const std::vector<std::vector<Real> >* phi = NULL;
1503       if (norm_type == H1 ||
1504           norm_type == H2 ||
1505           norm_type == L2 ||
1506           norm_type == L1 ||
1507           norm_type == L_INF)
1508         phi = &(fe->get_phi());
1509 
1510       const std::vector<std::vector<RealGradient> >* dphi = NULL;
1511       if (norm_type == H1 ||
1512           norm_type == H2 ||
1513           norm_type == H1_SEMINORM ||
1514           norm_type == W1_INF_SEMINORM)
1515         dphi = &(fe->get_dphi());
1516 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
1517       const std::vector<std::vector<RealTensor> >*   d2phi = NULL;
1518       if (norm_type == H2 ||
1519           norm_type == H2_SEMINORM ||
1520           norm_type == W2_INF_SEMINORM)
1521         d2phi = &(fe->get_d2phi());
1522 #endif
1523 
1524       std::vector<dof_id_type> dof_indices;
1525 
1526       // Begin the loop over the elements
1527       MeshBase::const_element_iterator       el     =
1528         this->get_mesh()\&.active_local_elements_begin();
1529       const MeshBase::const_element_iterator end_el =
1530         this->get_mesh()\&.active_local_elements_end();
1531 
1532       for ( ; el != end_el; ++el)
1533         {
1534           const Elem* elem = *el;
1535 
1536           fe->reinit (elem);
1537 
1538           this->get_dof_map()\&.dof_indices (elem, dof_indices, var);
1539 
1540           const unsigned int n_qp = qrule->n_points();
1541 
1542           const unsigned int n_sf = libmesh_cast_int<unsigned int>
1543             (dof_indices\&.size());
1544 
1545           // Begin the loop over the Quadrature points\&.
1546           for (unsigned int qp=0; qp<n_qp; qp++)
1547             {
1548               if (norm_type == L1)
1549                 {
1550                   Number u_h = 0\&.;
1551                   for (unsigned int i=0; i != n_sf; ++i)
1552                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1553                   v_norm += norm_weight *
1554                     JxW[qp] * std::abs(u_h);
1555                 }
1556 
1557               if (norm_type == L_INF)
1558                 {
1559                   Number u_h = 0\&.;
1560                   for (unsigned int i=0; i != n_sf; ++i)
1561                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1562                   v_norm = std::max(v_norm, norm_weight * std::abs(u_h));
1563                 }
1564 
1565               if (norm_type == H1 ||
1566                   norm_type == H2 ||
1567                   norm_type == L2)
1568                 {
1569                   Number u_h = 0\&.;
1570                   for (unsigned int i=0; i != n_sf; ++i)
1571                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1572                   v_norm += norm_weight_sq *
1573                     JxW[qp] * TensorTools::norm_sq(u_h);
1574                 }
1575 
1576               if (norm_type == H1 ||
1577                   norm_type == H2 ||
1578                   norm_type == H1_SEMINORM)
1579                 {
1580                   Gradient grad_u_h;
1581                   for (unsigned int i=0; i != n_sf; ++i)
1582                     grad_u_h\&.add_scaled((*dphi)[i][qp], (*local_v)(dof_indices[i]));
1583                   v_norm += norm_weight_sq *
1584                     JxW[qp] * grad_u_h\&.size_sq();
1585                 }
1586 
1587               if (norm_type == W1_INF_SEMINORM)
1588                 {
1589                   Gradient grad_u_h;
1590                   for (unsigned int i=0; i != n_sf; ++i)
1591                     grad_u_h\&.add_scaled((*dphi)[i][qp], (*local_v)(dof_indices[i]));
1592                   v_norm = std::max(v_norm, norm_weight * grad_u_h\&.size());
1593                 }
1594 
1595 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
1596               if (norm_type == H2 ||
1597                   norm_type == H2_SEMINORM)
1598                 {
1599                   Tensor hess_u_h;
1600                   for (unsigned int i=0; i != n_sf; ++i)
1601                     hess_u_h\&.add_scaled((*d2phi)[i][qp], (*local_v)(dof_indices[i]));
1602                   v_norm += norm_weight_sq *
1603                     JxW[qp] * hess_u_h\&.size_sq();
1604                 }
1605 
1606               if (norm_type == W2_INF_SEMINORM)
1607                 {
1608                   Tensor hess_u_h;
1609                   for (unsigned int i=0; i != n_sf; ++i)
1610                     hess_u_h\&.add_scaled((*d2phi)[i][qp], (*local_v)(dof_indices[i]));
1611                   v_norm = std::max(v_norm, norm_weight * hess_u_h\&.size());
1612                 }
1613 #endif
1614             }
1615         }
1616     }
1617 
1618   if (using_hilbert_norm)
1619     {
1620       this->comm()\&.sum(v_norm);
1621       v_norm = std::sqrt(v_norm);
1622     }
1623   else
1624     {
1625       this->comm()\&.max(v_norm);
1626     }
1627 
1628   STOP_LOG ("calculate_norm()", "System");
1629 
1630   return v_norm;
1631 }
.fi
.SS "void libMesh::EigenSystem::clear ()\fC [virtual]\fP, \fC [inherited]\fP"
Clear all the data structures associated with the system\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Reimplemented in \fBlibMesh::RBConstructionBase< CondensedEigenSystem >\fP, and \fBlibMesh::RBSCMConstruction\fP\&.
.PP
Definition at line 66 of file eigen_system\&.C\&.
.PP
References libMesh::System::clear(), libMesh::EigenSystem::eigen_solver, libMesh::EigenSystem::matrix_A, and libMesh::EigenSystem::matrix_B\&.
.PP
Referenced by libMesh::EigenSystem::~EigenSystem()\&.
.PP
.nf
67 {
68   // Clear the parent data
69   Parent::clear();
70 
71   // delete the matricies
72   delete matrix_A;
73   delete matrix_B;
74 
75   // NULL-out the matricies\&.
76   matrix_A = NULL;
77   matrix_B = NULL;
78 
79   // clear the solver
80   eigen_solver->clear();
81 
82 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "bool libMesh::System::compare (const \fBSystem\fP &other_system, const \fBReal\fPthreshold, const boolverbose) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the other system contains identical data, up to the given threshold\&. Outputs some diagnostic info when \fCverbose\fP is set\&. 
.RE
.PP

.PP
Definition at line 526 of file system\&.C\&.
.PP
References libMesh::System::_can_add_vectors, libMesh::System::_sys_name, libMesh::System::_vectors, libMesh::System::get_vector(), libMesh::libmesh_assert(), libMesh::System::n_vectors(), libMesh::System::name(), libMesh::out, and libMesh::System::solution\&.
.PP
Referenced by libMesh::EquationSystems::compare()\&.
.PP
.nf
529 {
530   // we do not care for matrices, but for vectors
531   libmesh_assert (!_can_add_vectors);
532   libmesh_assert (!other_system\&._can_add_vectors);
533 
534   if (verbose)
535     {
536       libMesh::out << "  Systems \"" << _sys_name << "\"" << std::endl;
537       libMesh::out << "   comparing matrices not supported\&." << std::endl;
538       libMesh::out << "   comparing names\&.\&.\&.";
539     }
540 
541   // compare the name: 0 means identical
542   const int name_result = _sys_name\&.compare(other_system\&.name());
543   if (verbose)
544     {
545       if (name_result == 0)
546         libMesh::out << " identical\&." << std::endl;
547       else
548         libMesh::out << "  names not identical\&." << std::endl;
549       libMesh::out << "   comparing solution vector\&.\&.\&.";
550     }
551 
552 
553   // compare the solution: -1 means identical
554   const int solu_result = solution->compare (*other_system\&.solution\&.get(),
555                                              threshold);
556 
557   if (verbose)
558     {
559       if (solu_result == -1)
560         libMesh::out << " identical up to threshold\&." << std::endl;
561       else
562         libMesh::out << "  first difference occured at index = "
563                      << solu_result << "\&." << std::endl;
564     }
565 
566 
567   // safety check, whether we handle at least the same number
568   // of vectors
569   std::vector<int> ov_result;
570 
571   if (this->n_vectors() != other_system\&.n_vectors())
572     {
573       if (verbose)
574         {
575           libMesh::out << "   Fatal difference\&. This system handles "
576                        << this->n_vectors() << " add'l vectors," << std::endl
577                        << "   while the other system handles "
578                        << other_system\&.n_vectors()
579                        << " add'l vectors\&." << std::endl
580                        << "   Aborting comparison\&." << std::endl;
581         }
582       return false;
583     }
584   else if (this->n_vectors() == 0)
585     {
586       // there are no additional vectors\&.\&.\&.
587       ov_result\&.clear ();
588     }
589   else
590     {
591       // compare other vectors
592       for (const_vectors_iterator pos = _vectors\&.begin();
593            pos != _vectors\&.end(); ++pos)
594         {
595           if (verbose)
596             libMesh::out << "   comparing vector \""
597                          << pos->first << "\" \&.\&.\&.";
598 
599           // assume they have the same name
600           const NumericVector<Number>& other_system_vector =
601             other_system\&.get_vector(pos->first);
602 
603           ov_result\&.push_back(pos->second->compare (other_system_vector,
604                                                     threshold));
605 
606           if (verbose)
607             {
608               if (ov_result[ov_result\&.size()-1] == -1)
609                 libMesh::out << " identical up to threshold\&." << std::endl;
610               else
611                 libMesh::out << " first difference occured at" << std::endl
612                              << "   index = " << ov_result[ov_result\&.size()-1] << "\&." << std::endl;
613             }
614 
615         }
616 
617     } // finished comparing additional vectors
618 
619 
620   bool overall_result;
621 
622   // sum up the results
623   if ((name_result==0) && (solu_result==-1))
624     {
625       if (ov_result\&.size()==0)
626         overall_result = true;
627       else
628         {
629           bool ov_identical;
630           unsigned int n    = 0;
631           do
632             {
633               ov_identical = (ov_result[n]==-1);
634               n++;
635             }
636           while (ov_identical && n<ov_result\&.size());
637           overall_result = ov_identical;
638         }
639     }
640   else
641     overall_result = false;
642 
643   if (verbose)
644     {
645       libMesh::out << "   finished comparisons, ";
646       if (overall_result)
647         libMesh::out << "found no differences\&." << std::endl << std::endl;
648       else
649         libMesh::out << "found differences\&." << std::endl << std::endl;
650     }
651 
652   return overall_result;
653 }
.fi
.SS "\fBNumber\fP libMesh::System::current_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the current solution for the specified global DOF\&. 
.RE
.PP

.PP
Definition at line 184 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, and libMesh::System::current_local_solution\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::for(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::HPCoarsenTest::select_refinement(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
185 {
186   // Check the sizes
187   libmesh_assert_less (global_dof_number, _dof_map->n_dofs());
188   libmesh_assert_less (global_dof_number, current_local_solution->size());
189 
190   return (*current_local_solution)(global_dof_number);
191 }
.fi
.SS "void libMesh::System::deactivate ()\fC [inline]\fP, \fC [inherited]\fP"
Deactivates the system\&. Only active systems are solved\&. 
.PP
Definition at line 1935 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1936 {
1937   _active = false;
1938 }
.fi
.SS "void libMesh::System::disable_cache ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Avoids use of any cached data that might affect any solve result\&. Should be overloaded in derived systems\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2121 of file system\&.h\&.
.PP
References libMesh::System::assemble_before_solve\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error()\&.
.PP
.nf
2121 { assemble_before_solve = true; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "void libMesh::System::forward_qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Solves for parameter sensitivities using the forward method\&.
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2165 of file system\&.h\&.
.PP
.nf
2168 {
2169   libmesh_not_implemented();
2170 }
.fi
.SS "bool libMesh::EigenSystem::generalized () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the underlying problem is generalized , false otherwise\&. 
.RE
.PP

.PP
Definition at line 148 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_is_generalized_eigenproblem\&.
.PP
Referenced by solve()\&.
.PP
.nf
148 { return _is_generalized_eigenproblem; }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. This what the user's QoI derivative code should assemble when setting up an adjoint problem 
.RE
.PP

.PP
Definition at line 1027 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
1028 {
1029   std::ostringstream adjoint_rhs_name;
1030   adjoint_rhs_name << "adjoint_rhs" << i;
1031 
1032   return this->get_vector(adjoint_rhs_name\&.str());
1033 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_rhs (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 1037 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1038 {
1039   std::ostringstream adjoint_rhs_name;
1040   adjoint_rhs_name << "adjoint_rhs" << i;
1041 
1042   return this->get_vector(adjoint_rhs_name\&.str());
1043 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 967 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
968 {
969   std::ostringstream adjoint_name;
970   adjoint_name << "adjoint_solution" << i;
971 
972   return this->get_vector(adjoint_name\&.str());
973 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 977 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
978 {
979   std::ostringstream adjoint_name;
980   adjoint_name << "adjoint_solution" << i;
981 
982   return this->get_vector(adjoint_name\&.str());
983 }
.fi
.SS "void libMesh::System::get_all_variable_numbers (std::vector< unsigned int > &all_variable_numbers) const\fC [inherited]\fP"
Fills \fCall_variable_numbers\fP with all the variable numbers for the variables that have been added to this system\&. 
.PP
Definition at line 1260 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers, and libMesh::System::n_vars()\&.
.PP
.nf
1261 {
1262   all_variable_numbers\&.resize(n_vars());
1263 
1264   // Make sure the variable exists
1265   std::map<std::string, unsigned short int>::const_iterator
1266     it = _variable_numbers\&.begin();
1267   std::map<std::string, unsigned short int>::const_iterator
1268     it_end = _variable_numbers\&.end();
1269 
1270   unsigned int count = 0;
1271   for( ; it != it_end; ++it)
1272     {
1273       all_variable_numbers[count] = it->second;
1274       count++;
1275     }
1276 }
.fi
.SS "const \fBDofMap\fP & libMesh::System::get_dof_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this system's \fC_dof_map\fP\&. 
.RE
.PP

.PP
Definition at line 1903 of file system\&.h\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::UnsteadySolver::advance_timestep(), libMesh::EquationSystems::allgather(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), DMlibMeshFunction(), DMLibMeshSetSystem(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::System::get_info(), libMesh::EquationSystems::get_solution(), libMesh::SystemSubsetBySubdomain::init(), libMesh::UnsteadySolver::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), initialize_condensed_dofs(), libMesh::System::local_dof_indices(), libMesh::DofMap::max_constraint_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::ErrorVector::plot_error(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_vector(), libMesh::System::re_update(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::UnsteadySolver::reinit(), libMesh::ImplicitSystem::reinit(), libMesh::EigenSystem::reinit(), libMesh::EquationSystems::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::HPCoarsenTest::select_refinement(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::NewtonSolver::solve(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::ImplicitSystem::weighted_sensitivity_solve(), libMesh::System::write_parallel_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::System::write_SCALAR_dofs(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1904 {
1905   return *_dof_map;
1906 }
.fi
.SS "\fBDofMap\fP & libMesh::System::get_dof_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fC_dof_map\fP\&. 
.RE
.PP

.PP
Definition at line 1911 of file system\&.h\&.
.PP
References libMesh::System::_dof_map\&.
.PP
.nf
1912 {
1913   return *_dof_map;
1914 }
.fi
.SS "std::pair< \fBReal\fP, \fBReal\fP > libMesh::CondensedEigenSystem::get_eigenpair (unsigned inti)\fC [virtual]\fP"
Overload get_eigenpair to retrieve the eigenpair for the condensed eigensolve\&. We only set the non-condensed entries of the solution vector (the condensed entries are set to zero by default)\&. 
.PP
Reimplemented from \fBlibMesh::EigenSystem\fP\&.
.PP
Definition at line 178 of file condensed_eigen_system\&.C\&.
.PP
References libMesh::NumericVector< T >::build(), libMesh::ParallelObject::comm(), condensed_dofs_initialized, libMesh::EigenSystem::eigen_solver, libMesh::EigenSystem::get_eigenpair(), libMesh::libmesh_assert(), local_non_condensed_dofs_vector, libMesh::n_local, libMesh::PARALLEL, libMesh::System::solution, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Parallel::Communicator::sum(), and libMesh::System::update()\&.
.PP
.nf
179 {
180   START_LOG("get_eigenpair()", "CondensedEigenSystem");
181 
182   // If we haven't initialized any condensed dofs,
183   // just use the default eigen_system
184   if(!condensed_dofs_initialized)
185     {
186       STOP_LOG("get_eigenpair()", "CondensedEigenSystem");
187       return Parent::get_eigenpair(i);
188     }
189 
190   // If we reach here, then there should be some non-condensed dofs
191   libmesh_assert(!local_non_condensed_dofs_vector\&.empty());
192 
193   // This function assumes that condensed_solve has just been called\&.
194   // If this is not the case, then we will trip an asset in get_eigenpair
195   AutoPtr< NumericVector<Number> > temp = NumericVector<Number>::build(this->comm());
196   unsigned int n_local = local_non_condensed_dofs_vector\&.size();
197   unsigned int n       = n_local;
198   this->comm()\&.sum(n);
199 
200   temp->init (n, n_local, false, PARALLEL);
201 
202   std::pair<Real, Real> eval = eigen_solver->get_eigenpair (i, *temp);
203 
204   // Now map temp to solution\&. Loop over local entries of local_non_condensed_dofs_vector
205   this->solution->zero();
206   for (unsigned int j=0; j<local_non_condensed_dofs_vector\&.size(); j++)
207     {
208       unsigned int index = local_non_condensed_dofs_vector[j];
209       solution->set(index,(*temp)(temp->first_local_index()+j));
210     }
211 
212   solution->close();
213   this->update();
214 
215   STOP_LOG("get_eigenpair()", "CondensedEigenSystem");
216 
217   return eval;
218 }
.fi
.SS "\fBEigenProblemType\fP libMesh::EigenSystem::get_eigenproblem_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the eigen problem type\&. 
.RE
.PP

.PP
Definition at line 142 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_eigen_problem_type\&.
.PP
.nf
142 {return _eigen_problem_type;}
.fi
.SS "const \fBEquationSystems\fP& libMesh::System::get_equation_systems () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this system's parent \fBEquationSystems\fP object\&. 
.RE
.PP

.PP
Definition at line 681 of file system\&.h\&.
.PP
References libMesh::System::_equation_systems\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::NewmarkSystem::clear(), libMesh::FrequencySystem::clear_all(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::FrequencySystem::init_data(), libMesh::FrequencySystem::n_frequencies(), libMesh::System::project_vector(), libMesh::FrequencySystem::set_current_frequency(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), libMesh::FrequencySystem::set_frequencies_by_steps(), libMesh::NewmarkSystem::set_newmark_parameters(), libMesh::NonlinearImplicitSystem::set_solver_parameters(), solve(), libMesh::EigenSystem::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), and libMesh::WrappedFunction< Output >::WrappedFunction()\&.
.PP
.nf
681 { return _equation_systems; }
.fi
.SS "\fBEquationSystems\fP& libMesh::System::get_equation_systems ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to this system's parent \fBEquationSystems\fP object\&. 
.RE
.PP

.PP
Definition at line 686 of file system\&.h\&.
.PP
References libMesh::System::_equation_systems\&.
.PP
.nf
686 { return _equation_systems; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::System::get_info () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a string containing information about the system\&. 
.RE
.PP

.PP
Definition at line 1635 of file system\&.C\&.
.PP
References libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::DofMap::get_info(), libMesh::FEType::inf_map, libMesh::System::n_constrained_dofs(), libMesh::System::n_dofs(), libMesh::System::n_local_constrained_dofs(), libMesh::System::n_local_dofs(), libMesh::System::n_matrices(), libMesh::System::n_variable_groups(), libMesh::VariableGroup::n_variables(), libMesh::System::n_vectors(), libMesh::VariableGroup::name(), libMesh::System::name(), libMesh::System::number(), libMesh::FEType::order, libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::System::system_type(), libMesh::Variable::type(), libMesh::DofMap::variable_group(), and libMesh::System::variable_group()\&.
.PP
.nf
1636 {
1637   std::ostringstream oss;
1638 
1639 
1640   const std::string& sys_name = this->name();
1641 
1642   oss << "   System #"  << this->number() << ", \"" << sys_name << "\"\n"
1643       << "    Type \""  << this->system_type() << "\"\n"
1644       << "    Variables=";
1645 
1646   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1647     {
1648       const VariableGroup &vg_description (this->variable_group(vg));
1649 
1650       if (vg_description\&.n_variables() > 1) oss << "{ ";
1651       for (unsigned int vn=0; vn<vg_description\&.n_variables(); vn++)
1652         oss << "\"" << vg_description\&.name(vn) << "\" ";
1653       if (vg_description\&.n_variables() > 1) oss << "} ";
1654     }
1655 
1656   oss << '\n';
1657 
1658   oss << "    Finite Element Types=";
1659 #ifndef LIBMESH_ENABLE_INFINITE_ELEMENTS
1660   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1661     oss << "\""
1662         << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.family)
1663         << "\" ";
1664 #else
1665   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1666     {
1667       oss << "\""
1668           << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.family)
1669           << "\", \""
1670           << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.radial_family)
1671           << "\" ";
1672     }
1673 
1674   oss << '\n' << "    Infinite Element Mapping=";
1675   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1676     oss << "\""
1677         << Utility::enum_to_string<InfMapType>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.inf_map)
1678         << "\" ";
1679 #endif
1680 
1681   oss << '\n';
1682 
1683   oss << "    Approximation Orders=";
1684   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1685     {
1686 #ifndef LIBMESH_ENABLE_INFINITE_ELEMENTS
1687       oss << "\""
1688           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.order)
1689           << "\" ";
1690 #else
1691       oss << "\""
1692           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.order)
1693           << "\", \""
1694           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.radial_order)
1695           << "\" ";
1696 #endif
1697     }
1698 
1699   oss << '\n';
1700 
1701   oss << "    n_dofs()="             << this->n_dofs()             << '\n';
1702   oss << "    n_local_dofs()="       << this->n_local_dofs()       << '\n';
1703 #ifdef LIBMESH_ENABLE_CONSTRAINTS
1704   oss << "    n_constrained_dofs()=" << this->n_constrained_dofs() << '\n';
1705   oss << "    n_local_constrained_dofs()=" << this->n_local_constrained_dofs() << '\n';
1706 #endif
1707 
1708   oss << "    " << "n_vectors()="  << this->n_vectors()  << '\n';
1709   oss << "    " << "n_matrices()="  << this->n_matrices()  << '\n';
1710   //   oss << "    " << "n_additional_matrices()=" << this->n_additional_matrices() << '\n';
1711 
1712   oss << this->get_dof_map()\&.get_info();
1713 
1714   return oss\&.str();
1715 }
.fi
.SS "const \fBMeshBase\fP & libMesh::System::get_mesh () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this systems's \fC_mesh\fP\&. 
.RE
.PP

.PP
Definition at line 1887 of file system\&.h\&.
.PP
References libMesh::System::_mesh\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::System::calculate_norm(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), DMLibMeshSetSystem(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::SystemSubsetBySubdomain::init(), libMesh::System::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), libMesh::System::local_dof_indices(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::mesh_position_set(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::FEMSystem::postprocess(), libMesh::System::project_vector(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::ImplicitSystem::reinit(), libMesh::EigenSystem::reinit(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), and libMesh::System::zero_variable()\&.
.PP
.nf
1888 {
1889   return _mesh;
1890 }
.fi
.SS "\fBMeshBase\fP & libMesh::System::get_mesh ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to this systems's \fC_mesh\fP\&. 
.RE
.PP

.PP
Definition at line 1895 of file system\&.h\&.
.PP
References libMesh::System::_mesh\&.
.PP
.nf
1896 {
1897   return _mesh;
1898 }
.fi
.SS "unsigned int libMesh::EigenSystem::get_n_converged () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of converged eigenpairs\&. 
.RE
.PP

.PP
Definition at line 127 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_n_converged_eigenpairs\&.
.PP
.nf
127 {return _n_converged_eigenpairs;}
.fi
.SS "unsigned int libMesh::EigenSystem::get_n_iterations () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of eigen solver iterations\&. 
.RE
.PP

.PP
Definition at line 132 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_n_iterations\&.
.PP
.nf
132 {return _n_iterations;}
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. By default these vectors are built by the library, using finite differences, when \fC\fBassemble_residual_derivatives()\fP\fP is called\&.
.RE
.PP
When assembled, this vector should hold -(partial R / partial p_i) 
.PP
Definition at line 1057 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
1058 {
1059   std::ostringstream sensitivity_rhs_name;
1060   sensitivity_rhs_name << "sensitivity_rhs" << i;
1061 
1062   return this->get_vector(sensitivity_rhs_name\&.str());
1063 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_rhs (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 1067 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1068 {
1069   std::ostringstream sensitivity_rhs_name;
1070   sensitivity_rhs_name << "sensitivity_rhs" << i;
1071 
1072   return this->get_vector(sensitivity_rhs_name\&.str());
1073 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 916 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
917 {
918   std::ostringstream sensitivity_name;
919   sensitivity_name << "sensitivity_solution" << i;
920 
921   return this->get_vector(sensitivity_name\&.str());
922 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 926 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
927 {
928   std::ostringstream sensitivity_name;
929   sensitivity_name << "sensitivity_solution" << i;
930 
931   return this->get_vector(sensitivity_name\&.str());
932 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const reference to this system's \fIadditional\fP vector named \fCvec_name\fP\&. Access is only granted when the vector is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 785 of file system\&.C\&.
.PP
References libMesh::System::_vectors, and libMesh::err\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::System::compare(), libMesh::UnsteadySolver::du(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_adjoint_rhs(), libMesh::System::get_adjoint_solution(), libMesh::System::get_sensitivity_rhs(), libMesh::System::get_sensitivity_solution(), libMesh::System::get_weighted_sensitivity_adjoint_solution(), libMesh::System::get_weighted_sensitivity_solution(), libMesh::NewmarkSystem::initial_conditions(), libMesh::UnsteadySolver::reinit(), libMesh::MemorySolutionHistory::retrieve(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::TwostepTimeSolver::solve(), libMesh::FrequencySystem::solve(), libMesh::NewmarkSystem::update_rhs(), and libMesh::NewmarkSystem::update_u_v_a()\&.
.PP
.nf
786 {
787   // Make sure the vector exists
788   const_vectors_iterator pos = _vectors\&.find(vec_name);
789 
790   if (pos == _vectors\&.end())
791     {
792       libMesh::err << "ERROR: vector "
793                    << vec_name
794                    << " does not exist in this system!"
795                    << std::endl;
796       libmesh_error();
797     }
798 
799   return *(pos->second);
800 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const std::string &vec_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fIadditional\fP vector named \fCvec_name\fP\&. Access is only granted when the vector is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 804 of file system\&.C\&.
.PP
References libMesh::System::_vectors, and libMesh::err\&.
.PP
.nf
805 {
806   // Make sure the vector exists
807   vectors_iterator pos = _vectors\&.find(vec_name);
808 
809   if (pos == _vectors\&.end())
810     {
811       libMesh::err << "ERROR: vector "
812                    << vec_name
813                    << " does not exist in this system!"
814                    << std::endl;
815       libmesh_error();
816     }
817 
818   return *(pos->second);
819 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const reference to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 823 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
824 {
825   const_vectors_iterator v = vectors_begin();
826   const_vectors_iterator v_end = vectors_end();
827   unsigned int num = 0;
828   while((num<vec_num) && (v!=v_end))
829     {
830       num++;
831       ++v;
832     }
833   libmesh_assert (v != v_end);
834   return *(v->second);
835 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const unsigned intvec_num)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 839 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
840 {
841   vectors_iterator v = vectors_begin();
842   vectors_iterator v_end = vectors_end();
843   unsigned int num = 0;
844   while((num<vec_num) && (v!=v_end))
845     {
846       num++;
847       ++v;
848     }
849   libmesh_assert (v != v_end);
850   return *(v->second);
851 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 997 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
998 {
999   std::ostringstream adjoint_name;
1000   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
1001 
1002   return this->get_vector(adjoint_name\&.str());
1003 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 1007 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1008 {
1009   std::ostringstream adjoint_name;
1010   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
1011 
1012   return this->get_vector(adjoint_name\&.str());
1013 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_solution ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve 
.RE
.PP

.PP
Definition at line 943 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
944 {
945   return this->get_vector("weighted_sensitivity_solution");
946 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_solution () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve 
.RE
.PP

.PP
Definition at line 950 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
951 {
952   return this->get_vector("weighted_sensitivity_solution");
953 }
.fi
.SS "bool libMesh::System::has_variable (const std::string &var) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if a variable named \fCvar\fP exists in this \fBSystem\fP 
.RE
.PP

.PP
Definition at line 1233 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers\&.
.PP
Referenced by libMesh::GMVIO::copy_nodal_solution()\&.
.PP
.nf
1234 {
1235   return _variable_numbers\&.count(var);
1236 }
.fi
.SS "bool libMesh::System::have_vector (const std::string &vec_name) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 2071 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::System::add_vector(), and libMesh::System::remove_vector()\&.
.PP
.nf
2072 {
2073   return (_vectors\&.count(vec_name));
2074 }
.fi
.SS "bool libMesh::System::identify_variable_groups () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when \fC\fBVariableGroup\fP\fP structures should be automatically identified, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 2047 of file system\&.h\&.
.PP
References libMesh::System::_identify_variable_groups\&.
.PP
Referenced by libMesh::System::add_variable()\&.
.PP
.nf
2048 {
2049   return _identify_variable_groups;
2050 }
.fi
.SS "void libMesh::System::identify_variable_groups (const boolivg)\fC [inline]\fP, \fC [inherited]\fP"
Toggle automatic \fC\fBVariableGroup\fP\fP identification\&. 
.PP
Definition at line 2055 of file system\&.h\&.
.PP
References libMesh::System::_identify_variable_groups\&.
.PP
.nf
2056 {
2057   _identify_variable_groups = ivg;
2058 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::System::init ()\fC [inherited]\fP"
Initializes degrees of freedom on the current mesh\&. Sets the 
.PP
Definition at line 226 of file system\&.C\&.
.PP
References libMesh::System::_basic_system_only, libMesh::System::init_data(), libMesh::System::n_vars(), and libMesh::System::user_initialization()\&.
.PP
.nf
227 {
228   // First initialize any required data:
229   // either only the basic System data
230   if (_basic_system_only)
231     System::init_data();
232   // or all the derived class' data too
233   else
234     this->init_data();
235 
236   // If no variables have been added to this system
237   // don't do anything
238   if(!this->n_vars())
239     return;
240 
241   // Then call the user-provided intialization function
242   this->user_initialization();
243 }
.fi
.SS "void libMesh::EigenSystem::init_data ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initializes the member data fields associated with the system, so that, e\&.g\&., \fC\fBassemble()\fP\fP may be used\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Reimplemented in \fBlibMesh::RBConstructionBase< CondensedEigenSystem >\fP\&.
.PP
Definition at line 117 of file eigen_system\&.C\&.
.PP
References libMesh::EigenSystem::_eigen_problem_type, libMesh::EigenSystem::_is_generalized_eigenproblem, libMesh::SparseMatrix< T >::build(), libMesh::ParallelObject::comm(), libMesh::GHEP, libMesh::GNHEP, libMesh::System::init_data(), libMesh::EigenSystem::init_matrices(), and libMesh::EigenSystem::matrix_A\&.
.PP
.nf
118 {
119   // initialize parent data
120   Parent::init_data();
121 
122   // define the type of eigenproblem
123   if (_eigen_problem_type == GNHEP || _eigen_problem_type == GHEP)
124     _is_generalized_eigenproblem = true;
125 
126   // build the system matrix
127   matrix_A = SparseMatrix<Number>::build(this->comm())\&.release();
128 
129   this->init_matrices();
130 }
.fi
.SS "void libMesh::EigenSystem::init_matrices ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initializes the matrices associated with the system 
.PP
Definition at line 134 of file eigen_system\&.C\&.
.PP
References libMesh::EigenSystem::_is_generalized_eigenproblem, libMesh::DofMap::attach_matrix(), libMesh::SparseMatrix< T >::build(), libMesh::ParallelObject::comm(), libMesh::DofMap::compute_sparsity(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::SparseMatrix< T >::init(), libMesh::EigenSystem::matrix_A, libMesh::EigenSystem::matrix_B, and libMesh::SparseMatrix< T >::zero()\&.
.PP
Referenced by libMesh::EigenSystem::init_data()\&.
.PP
.nf
135 {
136   DofMap& dof_map = this->get_dof_map();
137 
138   dof_map\&.attach_matrix(*matrix_A);
139 
140   // build matrix_B only in case of a
141   // generalized problem
142   if (_is_generalized_eigenproblem)
143     {
144       matrix_B = SparseMatrix<Number>::build(this->comm())\&.release();
145       dof_map\&.attach_matrix(*matrix_B);
146     }
147 
148   dof_map\&.compute_sparsity(this->get_mesh());
149 
150   // initialize and zero system matrix
151   matrix_A->init();
152   matrix_A->zero();
153 
154   // eventually initialize and zero system matrix_B
155   if (_is_generalized_eigenproblem)
156     {
157       matrix_B->init();
158       matrix_B->zero();
159     }
160 }
.fi
.SS "void libMesh::CondensedEigenSystem::initialize_condensed_dofs (std::set< unsigned int > &global_dirichlet_dofs_set)"
Loop over the dofs on each processor to initialize the list of non-condensed dofs\&. These are the dofs in the system that are not contained in \fCglobal_dirichlet_dofs_set\fP\&. 
.PP
Definition at line 44 of file condensed_eigen_system\&.C\&.
.PP
References condensed_dofs_initialized, libMesh::DofMap::end_dof(), libMesh::System::get_dof_map(), and local_non_condensed_dofs_vector\&.
.PP
.nf
45 {
46   // First, put all local dofs into non_dirichlet_dofs_set and
47   std::set<unsigned int> local_non_condensed_dofs_set;
48   for(unsigned int i=this->get_dof_map()\&.first_dof(); i<this->get_dof_map()\&.end_dof(); i++)
49     local_non_condensed_dofs_set\&.insert(i);
50 
51   // Now erase the condensed dofs
52   std::set<unsigned int>::iterator iter     = global_dirichlet_dofs_set\&.begin();
53   std::set<unsigned int>::iterator iter_end = global_dirichlet_dofs_set\&.end();
54 
55   for ( ; iter != iter_end ; ++iter)
56     {
57       unsigned int condensed_dof_index = *iter;
58       if ( (this->get_dof_map()\&.first_dof() <= condensed_dof_index) &&
59            (condensed_dof_index < this->get_dof_map()\&.end_dof()) )
60         {
61           local_non_condensed_dofs_set\&.erase(condensed_dof_index);
62         }
63     }
64 
65   // Finally, move local_non_condensed_dofs_set over to a vector for convenience in solve()
66   iter     = local_non_condensed_dofs_set\&.begin();
67   iter_end = local_non_condensed_dofs_set\&.end();
68 
69   this->local_non_condensed_dofs_vector\&.clear();
70 
71   for ( ; iter != iter_end; ++iter)
72     {
73       unsigned int non_condensed_dof_index = *iter;
74 
75       this->local_non_condensed_dofs_vector\&.push_back(non_condensed_dof_index);
76     }
77 
78   condensed_dofs_initialized = true;
79 }
.fi
.SS "bool libMesh::System::is_adjoint_already_solved () const\fC [inline]\fP, \fC [inherited]\fP"
Accessor for the adjoint_already_solved boolean 
.PP
Definition at line 361 of file system\&.h\&.
.PP
References libMesh::System::adjoint_already_solved\&.
.PP
Referenced by libMesh::AdjointResidualErrorEstimator::estimate_error()\&.
.PP
.nf
362   { return adjoint_already_solved;}
.fi
.SS "void libMesh::System::local_dof_indices (const unsigned intvar, std::set< \fBdof_id_type\fP > &var_indices) const\fC [inherited]\fP"
Fills the std::set with the degrees of freedom on the local processor corresponding the the variable number passed in\&. 
.PP
Definition at line 1279 of file system\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::DofMap::dof_indices(), libMesh::DofMap::end_dof(), libMesh::DofMap::first_dof(), libMesh::System::get_dof_map(), and libMesh::System::get_mesh()\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
1281 {
1282   // Make sure the set is clear
1283   var_indices\&.clear();
1284 
1285   std::vector<dof_id_type> dof_indices;
1286 
1287   // Begin the loop over the elements
1288   MeshBase::const_element_iterator       el     =
1289     this->get_mesh()\&.active_local_elements_begin();
1290   const MeshBase::const_element_iterator end_el =
1291     this->get_mesh()\&.active_local_elements_end();
1292 
1293   const dof_id_type
1294     first_local = this->get_dof_map()\&.first_dof(),
1295     end_local   = this->get_dof_map()\&.end_dof();
1296 
1297   for ( ; el != end_el; ++el)
1298     {
1299       const Elem* elem = *el;
1300       this->get_dof_map()\&.dof_indices (elem, dof_indices, var);
1301 
1302       for(unsigned int i=0; i<dof_indices\&.size(); i++)
1303         {
1304           dof_id_type dof = dof_indices[i];
1305 
1306           //If the dof is owned by the local processor
1307           if(first_local <= dof && dof < end_local)
1308             var_indices\&.insert(dof_indices[i]);
1309         }
1310     }
1311 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_active_dofs () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of active degrees of freedom for this \fBSystem\fP\&. 
.PP
Definition at line 2063 of file system\&.h\&.
.PP
References libMesh::System::n_constrained_dofs(), and libMesh::System::n_dofs()\&.
.PP
.nf
2064 {
2065   return this->n_dofs() - this->n_constrained_dofs();
2066 }
.fi
.SS "unsigned int libMesh::System::n_components () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of scalar components in the system's variables\&. This will equal \fC\fBn_vars()\fP\fP in the case of all scalar-valued variables\&. 
.RE
.PP

.PP
Definition at line 1967 of file system\&.h\&.
.PP
References libMesh::System::_variables, libMesh::Variable::first_scalar_number(), and libMesh::Variable::n_components()\&.
.PP
Referenced by libMesh::System::add_variables(), libMesh::WrappedFunction< Output >::operator()(), and libMesh::System::project_vector()\&.
.PP
.nf
1968 {
1969   if (_variables\&.empty())
1970     return 0;
1971 
1972   const Variable& last = _variables\&.back();
1973   return last\&.first_scalar_number() + last\&.n_components();
1974 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_constrained_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of constrained degrees of freedom in the system\&. 
.RE
.PP

.PP
Definition at line 147 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::get_info(), and libMesh::System::n_active_dofs()\&.
.PP
.nf
148 {
149 #ifdef LIBMESH_ENABLE_CONSTRAINTS
150 
151   return _dof_map->n_constrained_dofs();
152 
153 #else
154 
155   return 0;
156 
157 #endif
158 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom in the system 
.RE
.PP

.PP
Definition at line 140 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::add_vector(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_info(), libMesh::UnsteadySolver::init_data(), libMesh::System::init_data(), libMesh::System::n_active_dofs(), n_global_non_condensed_dofs(), libMesh::System::project_vector(), libMesh::System::read_legacy_data(), libMesh::UnsteadySolver::reinit(), libMesh::System::reinit(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
141 {
142   return _dof_map->n_dofs();
143 }
.fi
.SS "unsigned int libMesh::CondensedEigenSystem::n_global_non_condensed_dofs () const"

.PP
\fBReturns:\fP
.RS 4
the global number of non-condensed dofs in the system\&. 
.RE
.PP

.PP
Definition at line 81 of file condensed_eigen_system\&.C\&.
.PP
References libMesh::ParallelObject::comm(), condensed_dofs_initialized, local_non_condensed_dofs_vector, libMesh::System::n_dofs(), and libMesh::Parallel::Communicator::sum()\&.
.PP
.nf
82 {
83   if(!condensed_dofs_initialized)
84     {
85       return this->n_dofs();
86     }
87   else
88     {
89       unsigned int n_global_non_condensed_dofs = local_non_condensed_dofs_vector\&.size();
90       this->comm()\&.sum(n_global_non_condensed_dofs);
91 
92       return n_global_non_condensed_dofs;
93     }
94 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_local_constrained_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of constrained degrees of freedom on this processor\&. 
.RE
.PP

.PP
Definition at line 162 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::get_info()\&.
.PP
.nf
163 {
164 #ifdef LIBMESH_ENABLE_CONSTRAINTS
165 
166   return _dof_map->n_local_constrained_dofs();
167 
168 #else
169 
170   return 0;
171 
172 #endif
173 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_local_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom local to this processor 
.RE
.PP

.PP
Definition at line 177 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::System::add_vector(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_info(), libMesh::UnsteadySolver::init_data(), libMesh::System::init_data(), libMesh::System::project_vector(), libMesh::UnsteadySolver::reinit(), libMesh::System::reinit(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
178 {
179   return _dof_map->n_dofs_on_processor (this->processor_id());
180 }
.fi
.SS "unsigned int libMesh::EigenSystem::n_matrices () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of matrices handled by this system 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 227 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_is_generalized_eigenproblem\&.
.PP
.nf
228 {
229   if(_is_generalized_eigenproblem)
230     return 2;
231 
232   return 1;
233 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "unsigned int libMesh::System::n_variable_groups () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariableGroup\fP\fP variable groups in the system 
.RE
.PP

.PP
Definition at line 1959 of file system\&.h\&.
.PP
References libMesh::System::_variable_groups\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::get_info(), and libMesh::System::init_data()\&.
.PP
.nf
1960 {
1961   return libmesh_cast_int<unsigned int>(_variable_groups\&.size());
1962 }
.fi
.SS "unsigned int libMesh::System::n_vars () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of variables in the system 
.RE
.PP

.PP
Definition at line 1951 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DiffContext::add_localized_vector(), libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::WrappedFunction< Output >::component(), libMesh::DGFEMContext::DGFEMContext(), libMesh::DiffContext::DiffContext(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ErrorEstimator::estimate_errors(), libMesh::ExactSolution::ExactSolution(), libMesh::FEMContext::FEMContext(), libMesh::System::get_all_variable_numbers(), libMesh::EquationSystems::get_solution(), libMesh::System::init(), libMesh::FEMSystem::init_context(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), libMesh::WrappedFunction< Output >::operator()(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_vector(), libMesh::System::re_update(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::EquationSystems::reinit(), libMesh::System::reinit(), libMesh::HPCoarsenTest::select_refinement(), libMesh::SystemSubsetBySubdomain::set_var_nums(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), and libMesh::System::zero_variable()\&.
.PP
.nf
1952 {
1953   return libmesh_cast_int<unsigned int>(_variables\&.size());
1954 }
.fi
.SS "unsigned int libMesh::System::n_vectors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of vectors (in addition to the solution) handled by this system This is the size of the \fC_vectors\fP map 
.RE
.PP

.PP
Definition at line 2079 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::ExplicitSystem::add_system_rhs(), libMesh::System::compare(), libMesh::System::get_info(), and libMesh::System::write_header()\&.
.PP
.nf
2080 {
2081   return libmesh_cast_int<unsigned int>(_vectors\&.size());
2082 }
.fi
.SS "const std::string & libMesh::System::name () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the system name\&. 
.RE
.PP

.PP
Definition at line 1871 of file system\&.h\&.
.PP
References libMesh::System::_sys_name\&.
.PP
Referenced by libMesh::System::compare(), libMesh::WrappedFunction< Output >::component(), libMesh::ContinuationSystem::ContinuationSystem(), DMLibMeshSetUpName_Private(), libMesh::ExactSolution::ExactSolution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::for(), libMesh::System::get_info(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::NewtonSolver::init(), libMesh::TimeSolver::init_data(), libMesh::WrappedFunction< Output >::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::TimeSolver::reinit(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::System::user_assembly(), libMesh::System::user_constrain(), libMesh::System::user_initialization(), libMesh::System::user_QOI(), libMesh::System::user_QOI_derivative(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), and libMesh::System::write_serialized_data()\&.
.PP
.nf
1872 {
1873   return _sys_name;
1874 }
.fi
.SS "unsigned int libMesh::System::number () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the system number\&. 
.RE
.PP

.PP
Definition at line 1879 of file system\&.h\&.
.PP
References libMesh::System::_sys_number\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_solution_vector(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::System::get_info(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::HPCoarsenTest::select_refinement(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_blocked_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
1880 {
1881   return _sys_number;
1882 }
.fi
.SS "\fBGradient\fP libMesh::System::point_gradient (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the gradient of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2063 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
2064 {
2065   // This function must be called on every processor; there's no
2066   // telling where in the partition p falls\&.
2067   parallel_object_only();
2068 
2069   // And every processor had better agree about which point we're
2070   // looking for
2071 #ifndef NDEBUG
2072   this->comm()\&.verify(p);
2073 #endif // NDEBUG
2074 
2075   // Get a reference to the mesh object associated with the system object that calls this function
2076   const MeshBase &mesh = this->get_mesh();
2077 
2078   // Use an existing PointLocator or create a new one
2079   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
2080   PointLocatorBase& locator = *locator_ptr;
2081 
2082   if (!insist_on_success)
2083     locator\&.enable_out_of_mesh_mode();
2084 
2085   // Get a pointer to the element that contains P
2086   const Elem *e = locator(p);
2087 
2088   Gradient grad_u;
2089 
2090   if (e && e->processor_id() == this->processor_id())
2091     grad_u = point_gradient(var, p, *e);
2092 
2093   // If I have an element containing p, then let's let everyone know
2094   processor_id_type lowest_owner =
2095     (e && (e->processor_id() == this->processor_id())) ?
2096     this->processor_id() : this->n_processors();
2097   this->comm()\&.min(lowest_owner);
2098 
2099   // Everybody should get their value from a processor that was able
2100   // to compute it\&.
2101   // If nobody admits owning the point, we may have a problem\&.
2102   if (lowest_owner != this->n_processors())
2103     this->comm()\&.broadcast(grad_u, lowest_owner);
2104   else
2105     libmesh_assert(!insist_on_success);
2106 
2107   return grad_u;
2108 }
.fi
.SS "\fBGradient\fP libMesh::System::point_gradient (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the gradient of the solution variable \fCvar\fP at the physical point \fCp\fP in local \fBElem\fP \fCe\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2111 of file system\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2112 {
2113   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2114 
2115   // Ensuring that the given point is really in the element is an
2116   // expensive assert, but as long as debugging is turned on we might
2117   // as well try to catch a particularly nasty potential error
2118   libmesh_assert (e\&.contains_point(p));
2119 
2120   // Get the dof map to get the proper indices for our computation
2121   const DofMap& dof_map = this->get_dof_map();
2122 
2123   // Need dof_indices for phi[i][j]
2124   std::vector<dof_id_type> dof_indices;
2125 
2126   // Fill in the dof_indices for our element
2127   dof_map\&.dof_indices (&e, dof_indices, var);
2128 
2129   // Get the no of dofs assciated with this point
2130   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2131     (dof_indices\&.size());
2132 
2133   FEType fe_type = dof_map\&.variable_type(var);
2134 
2135   // Build a FE again so we can calculate u(p)
2136   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2137 
2138   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2139   // Build a vector of point co-ordinates to send to reinit
2140   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2141 
2142   // Get the values of the shape function derivatives
2143   const std::vector<std::vector<RealGradient> >&  dphi = fe->get_dphi();
2144 
2145   // Reinitialize the element and compute the shape function values at coor
2146   fe->reinit (&e, &coor);
2147 
2148   // Get ready to accumulate a gradient
2149   Gradient grad_u;
2150 
2151   for (unsigned int l=0; l<num_dofs; l++)
2152     {
2153       grad_u\&.add_scaled (dphi[l][0], this->current_solution (dof_indices[l]));
2154     }
2155 
2156   return grad_u;
2157 }
.fi
.SS "\fBTensor\fP libMesh::System::point_hessian (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the second derivative tensor of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2162 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
2163 {
2164   // This function must be called on every processor; there's no
2165   // telling where in the partition p falls\&.
2166   parallel_object_only();
2167 
2168   // And every processor had better agree about which point we're
2169   // looking for
2170 #ifndef NDEBUG
2171   this->comm()\&.verify(p);
2172 #endif // NDEBUG
2173 
2174   // Get a reference to the mesh object associated with the system object that calls this function
2175   const MeshBase &mesh = this->get_mesh();
2176 
2177   // Use an existing PointLocator or create a new one
2178   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
2179   PointLocatorBase& locator = *locator_ptr;
2180 
2181   if (!insist_on_success)
2182     locator\&.enable_out_of_mesh_mode();
2183 
2184   // Get a pointer to the element that contains P
2185   const Elem *e = locator(p);
2186 
2187   Tensor hess_u;
2188 
2189   if (e && e->processor_id() == this->processor_id())
2190     hess_u = point_hessian(var, p, *e);
2191 
2192   // If I have an element containing p, then let's let everyone know
2193   processor_id_type lowest_owner =
2194     (e && (e->processor_id() == this->processor_id())) ?
2195     this->processor_id() : this->n_processors();
2196   this->comm()\&.min(lowest_owner);
2197 
2198   // Everybody should get their value from a processor that was able
2199   // to compute it\&.
2200   // If nobody admits owning the point, we may have a problem\&.
2201   if (lowest_owner != this->n_processors())
2202     this->comm()\&.broadcast(hess_u, lowest_owner);
2203   else
2204     libmesh_assert(!insist_on_success);
2205 
2206   return hess_u;
2207 }
.fi
.SS "\fBTensor\fP libMesh::System::point_hessian (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the second derivative tensor of the solution variable \fCvar\fP at the physical point \fCp\fP in local \fBElem\fP \fCe\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2209 of file system\&.C\&.
.PP
References libMesh::TypeTensor< T >::add_scaled(), libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2210 {
2211   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2212 
2213   // Ensuring that the given point is really in the element is an
2214   // expensive assert, but as long as debugging is turned on we might
2215   // as well try to catch a particularly nasty potential error
2216   libmesh_assert (e\&.contains_point(p));
2217 
2218   // Get the dof map to get the proper indices for our computation
2219   const DofMap& dof_map = this->get_dof_map();
2220 
2221   // Need dof_indices for phi[i][j]
2222   std::vector<dof_id_type> dof_indices;
2223 
2224   // Fill in the dof_indices for our element
2225   dof_map\&.dof_indices (&e, dof_indices, var);
2226 
2227   // Get the no of dofs assciated with this point
2228   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2229     (dof_indices\&.size());
2230 
2231   FEType fe_type = dof_map\&.variable_type(var);
2232 
2233   // Build a FE again so we can calculate u(p)
2234   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2235 
2236   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2237   // Build a vector of point co-ordinates to send to reinit
2238   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2239 
2240   // Get the values of the shape function derivatives
2241   const std::vector<std::vector<RealTensor> >&  d2phi = fe->get_d2phi();
2242 
2243   // Reinitialize the element and compute the shape function values at coor
2244   fe->reinit (&e, &coor);
2245 
2246   // Get ready to accumulate a hessian
2247   Tensor hess_u;
2248 
2249   for (unsigned int l=0; l<num_dofs; l++)
2250     {
2251       hess_u\&.add_scaled (d2phi[l][0], this->current_solution (dof_indices[l]));
2252     }
2253 
2254   return hess_u;
2255 }
.fi
.SS "\fBNumber\fP libMesh::System::point_value (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the value of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, without knowing a priori which element contains \fCp\fP\&.
.PP
Note that this function uses \fC\fBMeshBase::sub_point_locator()\fP\fP; users may or may not want to call \fC\fBMeshBase::clear_point_locator()\fP\fP afterward\&. Also, point_locator() is expensive (N log N for initial construction, log N for evaluations)\&. Avoid using this function in any context where you are already looping over elements\&.
.PP
Because the element containing \fCp\fP may lie on any processor, this function is parallel-only\&.
.PP
By default this method expects the point to reside inside the domain and will abort if no element can be found which contains \fC\fP\&. The optional parameter \fCinsist_on_success\fP can be set to false to allow the method to return 0 when the point is not located\&. 
.PP
Definition at line 1966 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
1967 {
1968   // This function must be called on every processor; there's no
1969   // telling where in the partition p falls\&.
1970   parallel_object_only();
1971 
1972   // And every processor had better agree about which point we're
1973   // looking for
1974 #ifndef NDEBUG
1975   this->comm()\&.verify(p);
1976 #endif // NDEBUG
1977 
1978   // Get a reference to the mesh object associated with the system object that calls this function
1979   const MeshBase &mesh = this->get_mesh();
1980 
1981   // Use an existing PointLocator or create a new one
1982   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
1983   PointLocatorBase& locator = *locator_ptr;
1984 
1985   if (!insist_on_success)
1986     locator\&.enable_out_of_mesh_mode();
1987 
1988   // Get a pointer to the element that contains P
1989   const Elem *e = locator(p);
1990 
1991   Number u = 0;
1992 
1993   if (e && e->processor_id() == this->processor_id())
1994     u = point_value(var, p, *e);
1995 
1996   // If I have an element containing p, then let's let everyone know
1997   processor_id_type lowest_owner =
1998     (e && (e->processor_id() == this->processor_id())) ?
1999     this->processor_id() : this->n_processors();
2000   this->comm()\&.min(lowest_owner);
2001 
2002   // Everybody should get their value from a processor that was able
2003   // to compute it\&.
2004   // If nobody admits owning the point, we have a problem\&.
2005   if (lowest_owner != this->n_processors())
2006     this->comm()\&.broadcast(u, lowest_owner);
2007   else
2008     libmesh_assert(!insist_on_success);
2009 
2010   return u;
2011 }
.fi
.SS "\fBNumber\fP libMesh::System::point_value (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the value of the solution variable \fCvar\fP at the physical point \fCp\fP contained in local \fBElem\fP \fCe\fP 
.PP
This version of point_value can be run in serial, but assumes \fCe\fP is in the local mesh partition\&. 
.PP
Definition at line 2013 of file system\&.C\&.
.PP
References libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2014 {
2015   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2016 
2017   // Ensuring that the given point is really in the element is an
2018   // expensive assert, but as long as debugging is turned on we might
2019   // as well try to catch a particularly nasty potential error
2020   libmesh_assert (e\&.contains_point(p));
2021 
2022   // Get the dof map to get the proper indices for our computation
2023   const DofMap& dof_map = this->get_dof_map();
2024 
2025   // Need dof_indices for phi[i][j]
2026   std::vector<dof_id_type> dof_indices;
2027 
2028   // Fill in the dof_indices for our element
2029   dof_map\&.dof_indices (&e, dof_indices, var);
2030 
2031   // Get the no of dofs assciated with this point
2032   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2033     (dof_indices\&.size());
2034 
2035   FEType fe_type = dof_map\&.variable_type(var);
2036 
2037   // Build a FE so we can calculate u(p)
2038   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2039 
2040   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2041   // Build a vector of point co-ordinates to send to reinit
2042   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2043 
2044   // Get the shape function values
2045   const std::vector<std::vector<Real> >& phi = fe->get_phi();
2046 
2047   // Reinitialize the element and compute the shape function values at coor
2048   fe->reinit (&e, &coor);
2049 
2050   // Get ready to accumulate a value
2051   Number u = 0;
2052 
2053   for (unsigned int l=0; l<num_dofs; l++)
2054     {
2055       u += phi[l][0]*this->current_solution (dof_indices[l]);
2056     }
2057 
2058   return u;
2059 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "void libMesh::System::project_solution (\fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 470 of file system_projection\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::System::project_solution()\&.
.PP
.nf
472 {
473   this->project_vector(*solution, f, g);
474 
475   solution->localize(*current_local_solution, _dof_map->get_send_list());
476 }
.fi
.SS "void libMesh::System::project_solution (\fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 483 of file system_projection\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
.nf
485 {
486   this->project_vector(*solution, f, g);
487 
488   solution->localize(*current_local_solution, _dof_map->get_send_list());
489 }
.fi
.SS "void libMesh::System::project_solution (\fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 450 of file system_projection\&.C\&.
.PP
References libMesh::System::project_solution()\&.
.PP
.nf
459 {
460   WrappedFunction<Number> f(*this, fptr, &parameters);
461   WrappedFunction<Gradient> g(*this, gptr, &parameters);
462   this->project_solution(&f, &g);
463 }
.fi
.SS "bool& libMesh::System::project_solution_on_reinit (void)\fC [inline]\fP, \fC [inherited]\fP"
Tells the \fBSystem\fP whether or not to project the solution vector onto new grids when the system is reinitialized\&. The solution will be projected unless \fBproject_solution_on_reinit()\fP = false is called\&. 
.PP
Definition at line 763 of file system\&.h\&.
.PP
References libMesh::System::_solution_projection\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::MemorySolutionHistory::store()\&.
.PP
.nf
764   { return _solution_projection; }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 516 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_equation_systems(), libMesh::System::get_mesh(), libMesh::System::n_components(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::Threads::parallel_for(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::NumericVector< T >::set(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::System::time, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::System::variable_scalar_number()\&.
.PP
Referenced by libMesh::System::project_solution(), libMesh::System::project_vector(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
519 {
520   START_LOG ("project_vector()", "System");
521 
522   Threads::parallel_for
523     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
524                      this->get_mesh()\&.active_local_elements_end() ),
525      ProjectSolution(*this, f, g,
526                      this->get_equation_systems()\&.parameters,
527                      new_vector)
528      );
529 
530   // Also, load values into the SCALAR dofs
531   // Note: We assume that all SCALAR dofs are on the
532   // processor with highest ID
533   if(this->processor_id() == (this->n_processors()-1))
534     {
535       // We get different scalars as different
536       // components from a new-style f functor\&.
537       DenseVector<Number> fout(this->n_components());
538       bool filled_fout = false;
539 
540       const DofMap& dof_map = this->get_dof_map();
541       for (unsigned int var=0; var<this->n_vars(); var++)
542         if(this->variable(var)\&.type()\&.family == SCALAR)
543           {
544             if (!filled_fout)
545               {
546                 (*f) (Point(), this->time, fout);
547                 filled_fout = true;
548               }
549 
550             std::vector<dof_id_type> SCALAR_indices;
551             dof_map\&.SCALAR_dof_indices (SCALAR_indices, var);
552             const unsigned int n_SCALAR_dofs =
553               libmesh_cast_int<unsigned int>(SCALAR_indices\&.size());
554 
555             for (unsigned int i=0; i<n_SCALAR_dofs; i++)
556               {
557                 const dof_id_type global_index = SCALAR_indices[i];
558                 const unsigned int component_index =
559                   this->variable_scalar_number(var,i);
560                 new_vector\&.set(global_index, fout(component_index));
561               }
562           }
563     }
564 
565   new_vector\&.close();
566 
567 #ifdef LIBMESH_ENABLE_CONSTRAINTS
568   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
569 #endif
570 
571   STOP_LOG("project_vector()", "System");
572 }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 579 of file system_projection\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::NumericVector< T >::close(), libMesh::FEMFunctionBase< Output >::component(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::Threads::parallel_for(), libMesh::FEMContext::pre_fe_reinit(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::NumericVector< T >::set(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::System::time, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::System::variable_scalar_number()\&.
.PP
.nf
582 {
583   START_LOG ("project_fem_vector()", "System");
584 
585   Threads::parallel_for
586     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
587                      this->get_mesh()\&.active_local_elements_end() ),
588      ProjectFEMSolution(*this, f, g, new_vector)
589      );
590 
591   // Also, load values into the SCALAR dofs
592   // Note: We assume that all SCALAR dofs are on the
593   // processor with highest ID
594   if(this->processor_id() == (this->n_processors()-1))
595     {
596       // FIXME: Do we want to first check for SCALAR vars before building this? [PB]
597       FEMContext context( *this );
598 
599       const DofMap& dof_map = this->get_dof_map();
600       for (unsigned int var=0; var<this->n_vars(); var++)
601         if(this->variable(var)\&.type()\&.family == SCALAR)
602           {
603             // FIXME: We reinit with an arbitrary element in case the user
604             //        doesn't override FEMFunctionBase::component\&. Is there
605             //        any use case we're missing? [PB]
606             Elem *el = const_cast<Elem *>(*(this->get_mesh()\&.active_local_elements_begin()));
607             context\&.pre_fe_reinit( *this, el );
608 
609             std::vector<dof_id_type> SCALAR_indices;
610             dof_map\&.SCALAR_dof_indices (SCALAR_indices, var);
611             const unsigned int n_SCALAR_dofs =
612               libmesh_cast_int<unsigned int>(SCALAR_indices\&.size());
613 
614             for (unsigned int i=0; i<n_SCALAR_dofs; i++)
615               {
616                 const dof_id_type global_index = SCALAR_indices[i];
617                 const unsigned int component_index =
618                   this->variable_scalar_number(var,i);
619 
620                 new_vector\&.set(global_index, f->component(context, component_index, Point(), this->time));
621               }
622           }
623     }
624 
625   new_vector\&.close();
626 
627 #ifdef LIBMESH_ENABLE_CONSTRAINTS
628   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
629 #endif
630 
631   STOP_LOG("project_fem_vector()", "System");
632 }
.fi
.SS "void libMesh::System::project_vector (\fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 496 of file system_projection\&.C\&.
.PP
References libMesh::System::project_vector()\&.
.PP
.nf
506 {
507   WrappedFunction<Number> f(*this, fptr, &parameters);
508   WrappedFunction<Gradient> g(*this, gptr, &parameters);
509   this->project_vector(new_vector, &f, &g);
510 }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &vector) const\fC [protected]\fP, \fC [inherited]\fP"
Projects the vector defined on the old mesh onto the new mesh\&. 
.PP
Definition at line 255 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::clone(), and libMesh::System::project_vector()\&.
.PP
.nf
256 {
257   // Create a copy of the vector, which currently
258   // contains the old data\&.
259   AutoPtr<NumericVector<Number> >
260     old_vector (vector\&.clone());
261 
262   // Project the old vector to the new vector
263   this->project_vector (*old_vector, vector);
264 }
.fi
.SS "void libMesh::System::project_vector (const \fBNumericVector\fP< \fBNumber\fP > &old_v, \fBNumericVector\fP< \fBNumber\fP > &new_v) const\fC [protected]\fP, \fC [inherited]\fP"
Projects the vector defined on the old mesh onto the new mesh\&. The original vector is unchanged and the new vector is passed through the second argument\&.
.PP
This method projects the vector via L2 projections or nodal interpolations on each element\&. This method projects a solution from an old mesh to a current, refined mesh\&. The input vector \fCold_v\fP gives the solution on the old mesh, while the \fCnew_v\fP gives the solution (to be computed) on the new mesh\&.
.PP
Definition at line 272 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::build(), libMesh::NumericVector< T >::clear(), libMesh::NumericVector< T >::close(), libMesh::ParallelObject::comm(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::err, libMesh::FEType::family, libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::GHOSTED, libMesh::NumericVector< T >::init(), libMesh::libmesh_assert(), libMesh::NumericVector< T >::local_size(), libMesh::NumericVector< T >::localize(), libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::PARALLEL, libMesh::Threads::parallel_for(), libMesh::Threads::parallel_reduce(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::BuildProjectionList::send_list, libMesh::SERIAL, libMesh::NumericVector< T >::set(), libMesh::NumericVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Variable::type(), libMesh::NumericVector< T >::type(), libMesh::BuildProjectionList::unique(), and libMesh::System::variable()\&.
.PP
.nf
274 {
275   START_LOG ("project_vector()", "System");
276 
283   new_v\&.clear();
284 
285 #ifdef LIBMESH_ENABLE_AMR
286 
287   // Resize the new vector and get a serial version\&.
288   NumericVector<Number> *new_vector_ptr = NULL;
289   AutoPtr<NumericVector<Number> > new_vector_built;
290   NumericVector<Number> *local_old_vector;
291   AutoPtr<NumericVector<Number> > local_old_vector_built;
292   const NumericVector<Number> *old_vector_ptr = NULL;
293 
294   ConstElemRange active_local_elem_range
295     (this->get_mesh()\&.active_local_elements_begin(),
296      this->get_mesh()\&.active_local_elements_end());
297 
298   // If the old vector was uniprocessor, make the new
299   // vector uniprocessor
300   if (old_v\&.type() == SERIAL)
301     {
302       new_v\&.init (this->n_dofs(), false, SERIAL);
303       new_vector_ptr = &new_v;
304       old_vector_ptr = &old_v;
305     }
306 
307   // Otherwise it is a parallel, distributed vector, which
308   // we need to localize\&.
309   else if (old_v\&.type() == PARALLEL)
310     {
311       // Build a send list for efficient localization
312       BuildProjectionList projection_list(*this);
313       Threads::parallel_reduce (active_local_elem_range,
314                                 projection_list);
315 
316       // Create a sorted, unique send_list
317       projection_list\&.unique();
318 
319       new_v\&.init (this->n_dofs(), this->n_local_dofs(), false, PARALLEL);
320       new_vector_built = NumericVector<Number>::build(this->comm());
321       local_old_vector_built = NumericVector<Number>::build(this->comm());
322       new_vector_ptr = new_vector_built\&.get();
323       local_old_vector = local_old_vector_built\&.get();
324       new_vector_ptr->init(this->n_dofs(), false, SERIAL);
325       local_old_vector->init(old_v\&.size(), false, SERIAL);
326       old_v\&.localize(*local_old_vector, projection_list\&.send_list);
327       local_old_vector->close();
328       old_vector_ptr = local_old_vector;
329     }
330   else if (old_v\&.type() == GHOSTED)
331     {
332       // Build a send list for efficient localization
333       BuildProjectionList projection_list(*this);
334       Threads::parallel_reduce (active_local_elem_range,
335                                 projection_list);
336 
337       // Create a sorted, unique send_list
338       projection_list\&.unique();
339 
340       new_v\&.init (this->n_dofs(), this->n_local_dofs(),
341                   this->get_dof_map()\&.get_send_list(), false, GHOSTED);
342 
343       local_old_vector_built = NumericVector<Number>::build(this->comm());
344       new_vector_ptr = &new_v;
345       local_old_vector = local_old_vector_built\&.get();
346       local_old_vector->init(old_v\&.size(), old_v\&.local_size(),
347                              projection_list\&.send_list, false, GHOSTED);
348       old_v\&.localize(*local_old_vector, projection_list\&.send_list);
349       local_old_vector->close();
350       old_vector_ptr = local_old_vector;
351     }
352   else // unknown old_v\&.type()
353     {
354       libMesh::err << "ERROR: Unknown old_v\&.type() == " << old_v\&.type()
355                    << std::endl;
356       libmesh_error();
357     }
358 
359   // Note that the above will have zeroed the new_vector\&.
360   // Just to be sure, assert that new_vector_ptr and old_vector_ptr
361   // were successfully set before trying to deref them\&.
362   libmesh_assert(new_vector_ptr);
363   libmesh_assert(old_vector_ptr);
364 
365   NumericVector<Number> &new_vector = *new_vector_ptr;
366   const NumericVector<Number> &old_vector = *old_vector_ptr;
367 
368   Threads::parallel_for (active_local_elem_range,
369                          ProjectVector(*this,
370                                        old_vector,
371                                        new_vector)
372                          );
373 
374   // Copy the SCALAR dofs from old_vector to new_vector
375   // Note: We assume that all SCALAR dofs are on the
376   // processor with highest ID
377   if(this->processor_id() == (this->n_processors()-1))
378     {
379       const DofMap& dof_map = this->get_dof_map();
380       for (unsigned int var=0; var<this->n_vars(); var++)
381         if(this->variable(var)\&.type()\&.family == SCALAR)
382           {
383             // We can just map SCALAR dofs directly across
384             std::vector<dof_id_type> new_SCALAR_indices, old_SCALAR_indices;
385             dof_map\&.SCALAR_dof_indices (new_SCALAR_indices, var, false);
386             dof_map\&.SCALAR_dof_indices (old_SCALAR_indices, var, true);
387             const unsigned int new_n_dofs =
388               libmesh_cast_int<unsigned int>(new_SCALAR_indices\&.size());
389 
390             for (unsigned int i=0; i<new_n_dofs; i++)
391               {
392                 new_vector\&.set( new_SCALAR_indices[i], old_vector(old_SCALAR_indices[i]) );
393               }
394           }
395     }
396 
397   new_vector\&.close();
398 
399   // If the old vector was serial, we probably need to send our values
400   // to other processors
401   //
402   // FIXME: I'm not sure how to make a NumericVector do that without
403   // creating a temporary parallel vector to use localize! - RHS
404   if (old_v\&.type() == SERIAL)
405     {
406       AutoPtr<NumericVector<Number> > dist_v = NumericVector<Number>::build(this->comm());
407       dist_v->init(this->n_dofs(), this->n_local_dofs(), false, PARALLEL);
408       dist_v->close();
409 
410       for (dof_id_type i=0; i!=dist_v->size(); i++)
411         if (new_vector(i) != 0\&.0)
412           dist_v->set(i, new_vector(i));
413 
414       dist_v->close();
415 
416       dist_v->localize (new_v, this->get_dof_map()\&.get_send_list());
417       new_v\&.close();
418     }
419   // If the old vector was parallel, we need to update it
420   // and free the localized copies
421   else if (old_v\&.type() == PARALLEL)
422     {
423       // We may have to set dof values that this processor doesn't
424       // own in certain special cases, like LAGRANGE FIRST or
425       // HERMITE THIRD elements on second-order meshes
426       for (dof_id_type i=0; i!=new_v\&.size(); i++)
427         if (new_vector(i) != 0\&.0)
428           new_v\&.set(i, new_vector(i));
429       new_v\&.close();
430     }
431 
432   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_v);
433 
434 #else
435 
436   // AMR is disabled: simply copy the vector
437   new_v = old_v;
438 
439 #endif // #ifdef LIBMESH_ENABLE_AMR
440 
441   STOP_LOG("project_vector()", "System");
442 }
.fi
.SS "void libMesh::System::prolong_vectors ()\fC [virtual]\fP, \fC [inherited]\fP"
Prolong vectors after the mesh has refined 
.PP
Definition at line 371 of file system\&.C\&.
.PP
References libMesh::System::restrict_vectors()\&.
.PP
Referenced by libMesh::EquationSystems::reinit()\&.
.PP
.nf
372 {
373 #ifdef LIBMESH_ENABLE_AMR
374   // Currently project_vector handles both restriction and prolongation
375   this->restrict_vectors();
376 #endif
377 }
.fi
.SS "void libMesh::System::qoi_parameter_hessian (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &hessian)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
For each of the system's quantities of interest q in \fCqoi\fP[qoi_indices], and for a vector of parameters p, the parameter sensitivity Hessian H_ij is defined as H_ij = (d^2 q)/(d p_i d p_j) This Hessian is the output of this method, where for each q_i, H_jk is stored in \fChessian\&.second_derivative(i,j,k)\fP\&.
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2174 of file system\&.h\&.
.PP
.nf
2177 {
2178   libmesh_not_implemented();
2179 }
.fi
.SS "void libMesh::System::qoi_parameter_hessian_vector_product (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &vector, \fBSensitivityData\fP &product)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
For each of the system's quantities of interest q in \fCqoi\fP[qoi_indices], and for a vector of parameters p, the parameter sensitivity Hessian H_ij is defined as H_ij = (d^2 q)/(d p_i d p_j) The Hessian-vector product, for a vector v_k in parameter space, is S_j = H_jk v_k This product is the output of this method, where for each q_i, S_j is stored in \fCsensitivities\fP[i][j]\&.
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2183 of file system\&.h\&.
.PP
.nf
2187 {
2188   libmesh_not_implemented();
2189 }
.fi
.SS "void libMesh::System::qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [virtual]\fP, \fC [inherited]\fP"
Solves for the derivative of each of the system's quantities of interest q in \fCqoi\fP[qoi_indices] with respect to each parameter in \fCparameters\fP, placing the result for qoi \fCi\fP and parameter \fCj\fP into \fCsensitivities\fP[i][j]\&.
.PP
Note that parameters is a const vector, not a vector-of-const; parameter values in this vector need to be mutable for finite differencing to work\&.
.PP
Automatically chooses the forward method for problems with more quantities of interest than parameters, or the adjoint method otherwise\&.
.PP
This method is only usable in derived classes which overload an implementation\&. 
.PP
Definition at line 510 of file system\&.C\&.
.PP
References libMesh::ParameterVector::size(), and libMesh::QoISet::size()\&.
.PP
.nf
513 {
514   // Forward sensitivities are more efficient for Nq > Np
515   if (qoi_indices\&.size(*this) > parameters\&.size())
516     forward_qoi_parameter_sensitivity(qoi_indices, parameters, sensitivities);
517   // Adjoint sensitivities are more efficient for Np > Nq,
518   // and an adjoint may be more reusable than a forward
519   // solution sensitivity in the Np == Nq case\&.
520   else
521     adjoint_qoi_parameter_sensitivity(qoi_indices, parameters, sensitivities);
522 }
.fi
.SS "void libMesh::System::re_update ()\fC [virtual]\fP, \fC [inherited]\fP"
Re-update the local values when the mesh has changed\&. This method takes the data updated by \fC\fBupdate()\fP\fP and makes it up-to-date on the current mesh\&. 
.PP
Reimplemented in \fBlibMesh::TransientSystem< RBConstruction >\fP\&.
.PP
Definition at line 432 of file system\&.C\&.
.PP
References libMesh::System::current_local_solution, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::n_vars(), and libMesh::System::solution\&.
.PP
.nf
433 {
434   parallel_object_only();
435 
436   // If this system is empty\&.\&.\&. don't do anything!
437   if(!this->n_vars())
438     return;
439 
440   const std::vector<dof_id_type>& send_list = this->get_dof_map()\&.get_send_list ();
441 
442   // Check sizes
443   libmesh_assert_equal_to (current_local_solution->size(), solution->size());
444   // Not true with ghosted vectors
445   // libmesh_assert_equal_to (current_local_solution->local_size(), solution->size());
446   // libmesh_assert (!send_list\&.empty());
447   libmesh_assert_less_equal (send_list\&.size(), solution->size());
448 
449   // Create current_local_solution from solution\&.  This will
450   // put a local copy of solution into current_local_solution\&.
451   solution->localize (*current_local_solution, send_list);
452 }
.fi
.SS "void libMesh::System::read_header (\fBXdr\fP &io, const std::string &version, const boolread_header = \fCtrue\fP, const boolread_additional_data = \fCtrue\fP, const boolread_legacy_format = \fCfalse\fP)\fC [inherited]\fP"
Reads the basic data header for this \fBSystem\fP\&. 
.PP
Definition at line 114 of file system_io\&.C\&.
.PP
References libMesh::System::_additional_data_written, libMesh::System::_written_var_indices, libMesh::System::add_variable(), libMesh::System::add_vector(), libMesh::Parallel::Communicator::broadcast(), libMesh::System::clear(), libMesh::ParallelObject::comm(), libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::FEType::inf_map, libMesh::libmesh_assert(), libMesh::MeshBase::mesh_dimension(), libMesh::MONOMIAL, libMesh::on_command_line(), libMesh::FEType::order, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::Xdr::reading(), libMesh::System::variable_number(), libMesh::Xdr::version(), and libMesh::XYZ\&.
.PP
Referenced by libMesh::EquationSystems::_read_impl()\&.
.PP
.nf
119 {
120   // This method implements the input of a
121   // System object, embedded in the output of
122   // an EquationSystems<T_sys>\&.  This warrants some
123   // documentation\&.  The output file essentially
124   // consists of 5 sections:
125   //
126   // for this system
127   //
128   //   5\&.) The number of variables in the system (unsigned int)
129   //
130   //   for each variable in the system
131   //
132   //     6\&.) The name of the variable (string)
133   //
134   //     6\&.1\&.) Variable subdmains
135   //
136   //     7\&.) Combined in an FEType:
137   //         - The approximation order(s) of the variable
138   //           (Order Enum, cast to int/s)
139   //         - The finite element family/ies of the variable
140   //           (FEFamily Enum, cast to int/s)
141   //
142   //   end variable loop
143   //
144   //   8\&.) The number of additional vectors (unsigned int),
145   //
146   //     for each additional vector in the system object
147   //
148   //     9\&.) the name of the additional vector  (string)
149   //
150   // end system
151   libmesh_assert (io\&.reading());
152 
153   // Possibly clear data structures and start from scratch\&.
154   if (read_header_in)
155     this->clear ();
156 
157   // Figure out if we need to read infinite element information\&.
158   // This will be true if the version string contains " with infinite elements"
159   const bool read_ifem_info =
160     (version\&.rfind(" with infinite elements") < version\&.size()) ||
161     libMesh::on_command_line ("--read_ifem_systems");
162 
163 
164   {
165     // 5\&.)
166     // Read the number of variables in the system
167     unsigned int nv=0;
168     if (this->processor_id() == 0)
169       io\&.data (nv);
170     this->comm()\&.broadcast(nv);
171 
172     _written_var_indices\&.clear();
173     _written_var_indices\&.resize(nv, 0);
174 
175     for (unsigned int var=0; var<nv; var++)
176       {
177         // 6\&.)
178         // Read the name of the var-th variable
179         std::string var_name;
180         if (this->processor_id() == 0)
181           io\&.data (var_name);
182         this->comm()\&.broadcast(var_name);
183 
184         // 6\&.1\&.)
185         std::set<subdomain_id_type> domains;
186         if (io\&.version() >= LIBMESH_VERSION_ID(0,7,2))
187           {
188             std::vector<subdomain_id_type> domain_array;
189             if (this->processor_id() == 0)
190               io\&.data (domain_array);
191             for (std::vector<subdomain_id_type>::iterator it = domain_array\&.begin(); it != domain_array\&.end(); ++it)
192               domains\&.insert(*it);
193           }
194         this->comm()\&.broadcast(domains);
195 
196         // 7\&.)
197         // Read the approximation order(s) of the var-th variable
198         int order=0;
199         if (this->processor_id() == 0)
200           io\&.data (order);
201         this->comm()\&.broadcast(order);
202 
203 
204         // do the same for infinite element radial_order
205         int rad_order=0;
206         if (read_ifem_info)
207           {
208             if (this->processor_id() == 0)
209               io\&.data(rad_order);
210             this->comm()\&.broadcast(rad_order);
211           }
212 
213         // Read the finite element type of the var-th variable
214         int fam=0;
215         if (this->processor_id() == 0)
216           io\&.data (fam);
217         this->comm()\&.broadcast(fam);
218         FEType type;
219         type\&.order  = static_cast<Order>(order);
220         type\&.family = static_cast<FEFamily>(fam);
221 
222         // Check for incompatibilities\&.  The shape function indexing was
223         // changed for the monomial and xyz finite element families to
224         // simplify extension to arbitrary p\&.  The consequence is that
225         // old restart files will not be read correctly\&.  This is expected
226         // to be an unlikely occurance, but catch it anyway\&.
227         if (read_legacy_format)
228           if ((type\&.family == MONOMIAL || type\&.family == XYZ) &&
229               ((type\&.order > 2 && this->get_mesh()\&.mesh_dimension() == 2) ||
230                (type\&.order > 1 && this->get_mesh()\&.mesh_dimension() == 3)))
231             {
232               libmesh_here();
233               libMesh::out << "*****************************************************************\n"
234                            << "* WARNING: reading a potentially incompatible restart file!!!   *\n"
235                            << "*  contact libmesh-users@lists\&.sourceforge\&.net for more details *\n"
236                            << "*****************************************************************"
237                            << std::endl;
238             }
239 
240         // Read additional information for infinite elements
241         int radial_fam=0;
242         int i_map=0;
243         if (read_ifem_info)
244           {
245             if (this->processor_id() == 0)
246               io\&.data (radial_fam);
247             this->comm()\&.broadcast(radial_fam);
248             if (this->processor_id() == 0)
249               io\&.data (i_map);
250             this->comm()\&.broadcast(i_map);
251           }
252 
253 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
254 
255         type\&.radial_order  = static_cast<Order>(rad_order);
256         type\&.radial_family = static_cast<FEFamily>(radial_fam);
257         type\&.inf_map       = static_cast<InfMapType>(i_map);
258 
259 #endif
260 
261         if (read_header_in)
262           {
263             if (domains\&.empty())
264               _written_var_indices[var] = this->add_variable (var_name, type);
265             else
266               _written_var_indices[var] = this->add_variable (var_name, type, &domains);
267           }
268         else
269           _written_var_indices[var] = this->variable_number(var_name);
270       }
271   }
272 
273   // 8\&.)
274   // Read the number of additional vectors\&.
275   unsigned int nvecs=0;
276   if (this->processor_id() == 0)
277     io\&.data (nvecs);
278   this->comm()\&.broadcast(nvecs);
279 
280   // If nvecs > 0, this means that write_additional_data
281   // was true when this file was written\&.  We will need to
282   // make use of this fact later\&.
283   if (nvecs > 0)
284     this->_additional_data_written = true;
285 
286   for (unsigned int vec=0; vec<nvecs; vec++)
287     {
288       // 9\&.)
289       // Read the name of the vec-th additional vector
290       std::string vec_name;
291       if (this->processor_id() == 0)
292         io\&.data (vec_name);
293       this->comm()\&.broadcast(vec_name);
294 
295       if (read_additional_data)
296         {
297           // Systems now can handle adding post-initialization vectors
298           //  libmesh_assert(this->_can_add_vectors);
299           // Some systems may have added their own vectors already
300           //  libmesh_assert_equal_to (this->_vectors\&.count(vec_name), 0);
301 
302           this->add_vector(vec_name);
303         }
304     }
305 }
.fi
.SS "void libMesh::System::read_legacy_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. 
.PP
Definition at line 309 of file system_io\&.C\&.
.PP
References libMesh::System::_additional_data_written, libMesh::System::_vectors, libMesh::System::_written_var_indices, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::Xdr::data(), end, libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::System::n_dofs(), libMesh::System::n_vars(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::Xdr::reading(), libMesh::System::solution, libMesh::sys, and libMesh::zero\&.
.PP
.nf
311 {
312   libmesh_deprecated();
313 
314   // This method implements the output of the vectors
315   // contained in this System object, embedded in the
316   // output of an EquationSystems<T_sys>\&.
317   //
318   //   10\&.) The global solution vector, re-ordered to be node-major
319   //       (More on this later\&.)
320   //
321   //      for each additional vector in the object
322   //
323   //      11\&.) The global additional vector, re-ordered to be
324   //           node-major (More on this later\&.)
325   libmesh_assert (io\&.reading());
326 
327   // read and reordering buffers
328   std::vector<Number> global_vector;
329   std::vector<Number> reordered_vector;
330 
331   // 10\&.)
332   // Read and set the solution vector
333   {
334     if (this->processor_id() == 0)
335       io\&.data (global_vector);
336     this->comm()\&.broadcast(global_vector);
337 
338     // Remember that the stored vector is node-major\&.
339     // We need to put it into whatever application-specific
340     // ordering we may have using the dof_map\&.
341     reordered_vector\&.resize(global_vector\&.size());
342 
343     //libMesh::out << "global_vector\&.size()=" << global_vector\&.size() << std::endl;
344     //libMesh::out << "this->n_dofs()=" << this->n_dofs() << std::endl;
345 
346     libmesh_assert_equal_to (global_vector\&.size(), this->n_dofs());
347 
348     dof_id_type cnt=0;
349 
350     const unsigned int sys = this->number();
351     const unsigned int nv  = this->_written_var_indices\&.size();
352     libmesh_assert_less_equal (nv, this->n_vars());
353 
354     for (unsigned int data_var=0; data_var<nv; data_var++)
355       {
356         const unsigned int var = _written_var_indices[data_var];
357 
358         // First reorder the nodal DOF values
359         {
360           MeshBase::node_iterator
361             it  = this->get_mesh()\&.nodes_begin(),
362             end = this->get_mesh()\&.nodes_end();
363 
364           for (; it != end; ++it)
365             for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
366               {
367                 libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
368                                              DofObject::invalid_id);
369 
370                 libmesh_assert_less (cnt, global_vector\&.size());
371 
372                 reordered_vector[(*it)->dof_number(sys, var, index)] =
373                   global_vector[cnt++];
374               }
375         }
376 
377         // Then reorder the element DOF values
378         {
379           MeshBase::element_iterator
380             it  = this->get_mesh()\&.active_elements_begin(),
381             end = this->get_mesh()\&.active_elements_end();
382 
383           for (; it != end; ++it)
384             for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
385               {
386                 libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
387                                              DofObject::invalid_id);
388 
389                 libmesh_assert_less (cnt, global_vector\&.size());
390 
391                 reordered_vector[(*it)->dof_number(sys, var, index)] =
392                   global_vector[cnt++];
393               }
394         }
395       }
396 
397     *(this->solution) = reordered_vector;
398   }
399 
400   // For each additional vector, simply go through the list\&.
401   // ONLY attempt to do this IF additional data was actually
402   // written to the file for this system (controlled by the
403   // _additional_data_written flag)\&.
404   if (this->_additional_data_written)
405     {
406       std::map<std::string, NumericVector<Number>* >::iterator
407         pos = this->_vectors\&.begin();
408 
409       for (; pos != this->_vectors\&.end(); ++pos)
410         {
411           // 11\&.)
412           // Read the values of the vec-th additional vector\&.
413           // Prior do _not_ clear, but fill with zero, since the
414           // additional vectors _have_ to have the same size
415           // as the solution vector
416           std::fill (global_vector\&.begin(), global_vector\&.end(), libMesh::zero);
417 
418           if (this->processor_id() == 0)
419             io\&.data (global_vector);
420           this->comm()\&.broadcast(global_vector);
421 
422           // If read_additional_data==true, then we will keep this vector, otherwise
423           // we are going to throw it away\&.
424           if (read_additional_data)
425             {
426               // Remember that the stored vector is node-major\&.
427               // We need to put it into whatever application-specific
428               // ordering we may have using the dof_map\&.
429               std::fill (reordered_vector\&.begin(),
430                          reordered_vector\&.end(),
431                          libMesh::zero);
432 
433               reordered_vector\&.resize(global_vector\&.size());
434 
435               libmesh_assert_equal_to (global_vector\&.size(), this->n_dofs());
436 
437               dof_id_type cnt=0;
438 
439               const unsigned int sys = this->number();
440               const unsigned int nv  = this->_written_var_indices\&.size();
441               libmesh_assert_less_equal (nv, this->n_vars());
442 
443               for (unsigned int data_var=0; data_var<nv; data_var++)
444                 {
445                   const unsigned int var = _written_var_indices[data_var];
446                   // First reorder the nodal DOF values
447                   {
448                     MeshBase::node_iterator
449                       it  = this->get_mesh()\&.nodes_begin(),
450                       end = this->get_mesh()\&.nodes_end();
451 
452                     for (; it!=end; ++it)
453                       for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
454                         {
455                           libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
456                                                        DofObject::invalid_id);
457 
458                           libmesh_assert_less (cnt, global_vector\&.size());
459 
460                           reordered_vector[(*it)->dof_number(sys, var, index)] =
461                             global_vector[cnt++];
462                         }
463                   }
464 
465                   // Then reorder the element DOF values
466                   {
467                     MeshBase::element_iterator
468                       it  = this->get_mesh()\&.active_elements_begin(),
469                       end = this->get_mesh()\&.active_elements_end();
470 
471                     for (; it!=end; ++it)
472                       for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
473                         {
474                           libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
475                                                        DofObject::invalid_id);
476 
477                           libmesh_assert_less (cnt, global_vector\&.size());
478 
479                           reordered_vector[(*it)->dof_number(sys, var, index)] =
480                             global_vector[cnt++];
481                         }
482                   }
483                 }
484 
485               // use the overloaded operator=(std::vector) to assign the values
486               *(pos->second) = reordered_vector;
487             }
488         }
489     } // end if (_additional_data_written)
490 }
.fi
.SS "template<typename InValType > void libMesh::System::read_parallel_data (\fBXdr\fP &io, const boolread_additional_data)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will read an individual file for each processor in the simulation where the local solution components for that processor are stored\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Note that the actual IO is handled through the \fBXdr\fP class (to be renamed later?) which provides a uniform interface to both the XDR (eXternal Data Representation) interface and standard ASCII output\&. Thus this one section of code will read XDR or ASCII files with no changes\&.
.PP
Definition at line 495 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::System::_written_var_indices, libMesh::Xdr::data(), libMesh::dof_map, libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::Xdr::is_open(), libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::Xdr::reading(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::System::solution, libMesh::Variable::type(), and libMesh::System::variable()\&.
.PP
.nf
497 {
517   // PerfLog pl("IO Performance",false);
518   // pl\&.push("read_parallel_data");
519   dof_id_type total_read_size = 0;
520 
521   libmesh_assert (io\&.reading());
522   libmesh_assert (io\&.is_open());
523 
524   // build the ordered nodes and element maps\&.
525   // when writing/reading parallel files we need to iterate
526   // over our nodes/elements in order of increasing global id()\&.
527   // however, this is not guaranteed to be ordering we obtain
528   // by using the node_iterators/element_iterators directly\&.
529   // so build a set, sorted by id(), that provides the ordering\&.
530   // further, for memory economy build the set but then transfer
531   // its contents to vectors, which will be sorted\&.
532   std::vector<const DofObject*> ordered_nodes, ordered_elements;
533   {
534     std::set<const DofObject*, CompareDofObjectsByID>
535       ordered_nodes_set (this->get_mesh()\&.local_nodes_begin(),
536                          this->get_mesh()\&.local_nodes_end());
537 
538     ordered_nodes\&.insert(ordered_nodes\&.end(),
539                          ordered_nodes_set\&.begin(),
540                          ordered_nodes_set\&.end());
541   }
542   {
543     std::set<const DofObject*, CompareDofObjectsByID>
544       ordered_elements_set (this->get_mesh()\&.local_elements_begin(),
545                             this->get_mesh()\&.local_elements_end());
546 
547     ordered_elements\&.insert(ordered_elements\&.end(),
548                             ordered_elements_set\&.begin(),
549                             ordered_elements_set\&.end());
550   }
551 
552   //  std::vector<Number> io_buffer;
553   std::vector<InValType> io_buffer;
554 
555   // 9\&.)
556   //
557   // Actually read the solution components
558   // for the ith system to disk
559   io\&.data(io_buffer);
560 
561   total_read_size += io_buffer\&.size();
562 
563   const unsigned int sys_num = this->number();
564   const unsigned int nv      = this->_written_var_indices\&.size();
565   libmesh_assert_less_equal (nv, this->n_vars());
566 
567   dof_id_type cnt=0;
568 
569   // Loop over each non-SCALAR variable and each node, and read out the value\&.
570   for (unsigned int data_var=0; data_var<nv; data_var++)
571     {
572       const unsigned int var = _written_var_indices[data_var];
573       if(this->variable(var)\&.type()\&.family != SCALAR)
574         {
575           // First read the node DOF values
576           for (std::vector<const DofObject*>::const_iterator
577                  it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
578             for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
579               {
580                 libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
581                                              DofObject::invalid_id);
582                 libmesh_assert_less (cnt, io_buffer\&.size());
583                 this->solution->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
584               }
585 
586           // Then read the element DOF values
587           for (std::vector<const DofObject*>::const_iterator
588                  it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
589             for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
590               {
591                 libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
592                                              DofObject::invalid_id);
593                 libmesh_assert_less (cnt, io_buffer\&.size());
594                 this->solution->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
595               }
596         }
597     }
598 
599   // Finally, read the SCALAR variables on the last processor
600   for (unsigned int data_var=0; data_var<nv; data_var++)
601     {
602       const unsigned int var = _written_var_indices[data_var];
603       if(this->variable(var)\&.type()\&.family == SCALAR)
604         {
605           if (this->processor_id() == (this->n_processors()-1))
606             {
607               const DofMap& dof_map = this->get_dof_map();
608               std::vector<dof_id_type> SCALAR_dofs;
609               dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
610 
611               for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
612                 {
613                   this->solution->set( SCALAR_dofs[i], io_buffer[cnt++] );
614                 }
615             }
616         }
617     }
618 
619   // And we're done setting solution entries
620   this->solution->close();
621 
622   // Only read additional vectors if wanted
623   if (read_additional_data)
624     {
625       std::map<std::string, NumericVector<Number>* >::const_iterator
626         pos = _vectors\&.begin();
627 
628       for(; pos != this->_vectors\&.end(); ++pos)
629         {
630           cnt=0;
631           io_buffer\&.clear();
632 
633           // 10\&.)
634           //
635           // Actually read the additional vector components
636           // for the ith system to disk
637           io\&.data(io_buffer);
638 
639           total_read_size += io_buffer\&.size();
640 
641           // Loop over each non-SCALAR variable and each node, and read out the value\&.
642           for (unsigned int data_var=0; data_var<nv; data_var++)
643             {
644               const unsigned int var = _written_var_indices[data_var];
645               if(this->variable(var)\&.type()\&.family != SCALAR)
646                 {
647                   // First read the node DOF values
648                   for (std::vector<const DofObject*>::const_iterator
649                          it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
650                     for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
651                       {
652                         libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
653                                                      DofObject::invalid_id);
654                         libmesh_assert_less (cnt, io_buffer\&.size());
655                         pos->second->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
656                       }
657 
658                   // Then read the element DOF values
659                   for (std::vector<const DofObject*>::const_iterator
660                          it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
661                     for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
662                       {
663                         libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
664                                                      DofObject::invalid_id);
665                         libmesh_assert_less (cnt, io_buffer\&.size());
666                         pos->second->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
667                       }
668                 }
669             }
670 
671           // Finally, read the SCALAR variables on the last processor
672           for (unsigned int data_var=0; data_var<nv; data_var++)
673             {
674               const unsigned int var = _written_var_indices[data_var];
675               if(this->variable(var)\&.type()\&.family == SCALAR)
676                 {
677                   if (this->processor_id() == (this->n_processors()-1))
678                     {
679                       const DofMap& dof_map = this->get_dof_map();
680                       std::vector<dof_id_type> SCALAR_dofs;
681                       dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
682 
683                       for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
684                         {
685                           pos->second->set( SCALAR_dofs[i], io_buffer[cnt++] );
686                         }
687                     }
688                 }
689             }
690 
691           // And we're done setting entries for this variable
692           pos->second->close();
693         }
694     }
695 
696   // const Real
697   //   dt   = pl\&.get_elapsed_time(),
698   //   rate = total_read_size*sizeof(Number)/dt;
699 
700   // libMesh::err << "Read " << total_read_size << " \"Number\" values\n"
701   //     << " Elapsed time = " << dt << '\n'
702   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
703 
704   // pl\&.pop("read_parallel_data");
705 }
.fi
.SS "template void System::read_parallel_data< \fBReal\fP > (\fBXdr\fP &io, const boolread_additional_data)\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will read an individual file for each processor in the simulation where the local solution components for that processor are stored\&. 
.PP
Definition at line 1237 of file system\&.h\&.
.PP
.nf
1239   { read_parallel_data<Number>(io, read_additional_data); }
.fi
.SS "template<typename InValType > void libMesh::System::read_serialized_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. 
.PP
Definition at line 709 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::ParallelObject::processor_id(), and libMesh::System::solution\&.
.PP
.nf
711 {
712   // This method implements the input of the vectors
713   // contained in this System object, embedded in the
714   // output of an EquationSystems<T_sys>\&.
715   //
716   //   10\&.) The global solution vector, re-ordered to be node-major
717   //       (More on this later\&.)
718   //
719   //      for each additional vector in the object
720   //
721   //      11\&.) The global additional vector, re-ordered to be
722   //          node-major (More on this later\&.)
723   parallel_object_only();
724   std::string comment;
725 
726   // PerfLog pl("IO Performance",false);
727   // pl\&.push("read_serialized_data");
728   // std::size_t total_read_size = 0;
729 
730   // 10\&.)
731   // Read the global solution vector
732   {
733     // total_read_size +=
734     this->read_serialized_vector<InValType>(io, *this->solution);
735 
736     // get the comment
737     if (this->processor_id() == 0)
738       io\&.comment (comment);
739   }
740 
741   // 11\&.)
742   // Only read additional vectors if wanted
743   if (read_additional_data)
744     {
745       std::map<std::string, NumericVector<Number>* >::const_iterator
746         pos = _vectors\&.begin();
747 
748       for(; pos != this->_vectors\&.end(); ++pos)
749         {
750           // total_read_size +=
751           this->read_serialized_vector<InValType>(io, *pos->second);
752 
753           // get the comment
754           if (this->processor_id() == 0)
755             io\&.comment (comment);
756 
757         }
758     }
759 
760   // const Real
761   //   dt   = pl\&.get_elapsed_time(),
762   //   rate = total_read_size*sizeof(Number)/dt;
763 
764   // libMesh::out << "Read " << total_read_size << " \"Number\" values\n"
765   //     << " Elapsed time = " << dt << '\n'
766   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
767 
768   // pl\&.pop("read_serialized_data");
769 }
.fi
.SS "void libMesh::System::read_serialized_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. 
.PP
Definition at line 1195 of file system\&.h\&.
.PP
.nf
1197   { read_serialized_data<Number>(io, read_additional_data); }
.fi
.SS "template<typename InValType > std::size_t libMesh::System::read_serialized_vectors (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inherited]\fP"
Read a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 2193 of file system_io\&.C\&.
.PP
References libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshTools::n_elem(), n_nodes, libMesh::MeshBase::n_nodes(), libMesh::System::n_vars(), libMesh::ParallelObject::processor_id(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::Xdr::reading(), libMesh::SCALAR, libMesh::Variable::type(), and libMesh::System::variable()\&.
.PP
.nf
2195 {
2196   parallel_object_only();
2197 
2198   // Error checking
2199   // #ifndef NDEBUG
2200   //   // In parallel we better be reading a parallel vector -- if not
2201   //   // we will not set all of its components below!!
2202   //   if (this->n_processors() > 1)
2203   //     {
2204   //       libmesh_assert (vec\&.type() == PARALLEL ||
2205   //       vec\&.type() == GHOSTED);
2206   //     }
2207   // #endif
2208 
2209   libmesh_assert (io\&.reading());
2210 
2211   if (this->processor_id() == 0)
2212     {
2213       // sizes
2214       unsigned int num_vecs=0;
2215       dof_id_type vector_length=0;
2216 
2217       // Get the number of vectors
2218       io\&.data(num_vecs);
2219       // Get the buffer size
2220       io\&.data(vector_length);
2221 
2222       libmesh_assert_equal_to (num_vecs, vectors\&.size());
2223 
2224       if (num_vecs != 0)
2225         {
2226           libmesh_assert_not_equal_to (vectors[0], 0);
2227           libmesh_assert_equal_to     (vectors[0]->size(), vector_length);
2228         }
2229     }
2230 
2231   // no need to actually communicate these\&.
2232   // this->comm()\&.broadcast(num_vecs);
2233   // this->comm()\&.broadcast(vector_length);
2234 
2235   // Cache these - they are not free!
2236   const dof_id_type
2237     n_nodes = this->get_mesh()\&.n_nodes(),
2238     n_elem  = this->get_mesh()\&.n_elem();
2239 
2240   std::size_t read_length = 0\&.;
2241 
2242   //---------------------------------
2243   // Collect the values for all nodes
2244   read_length +=
2245     this->read_serialized_blocked_dof_objects (n_nodes,
2246                                                this->get_mesh()\&.local_nodes_begin(),
2247                                                this->get_mesh()\&.local_nodes_end(),
2248                                                InValType(),
2249                                                io,
2250                                                vectors);
2251 
2252   //------------------------------------
2253   // Collect the values for all elements
2254   read_length +=
2255     this->read_serialized_blocked_dof_objects (n_elem,
2256                                                this->get_mesh()\&.local_elements_begin(),
2257                                                this->get_mesh()\&.local_elements_end(),
2258                                                InValType(),
2259                                                io,
2260                                                vectors);
2261 
2262   //-------------------------------------------
2263   // Finally loop over all the SCALAR variables
2264   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2265     for (unsigned int var=0; var<this->n_vars(); var++)
2266       if(this->variable(var)\&.type()\&.family == SCALAR)
2267         {
2268           libmesh_assert_not_equal_to (vectors[vec], 0);
2269 
2270           read_length +=
2271             this->read_SCALAR_dofs (var, io, *vectors[vec]);
2272         }
2273 
2274   //---------------------------------------
2275   // last step - must close all the vectors
2276   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2277     {
2278       libmesh_assert_not_equal_to (vectors[vec], 0);
2279       vectors[vec]->close();
2280     }
2281 
2282   return read_length;
2283 }
.fi
.SS "std::size_t libMesh::System::read_serialized_vectors (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Read a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 1215 of file system\&.h\&.
.PP
.nf
1217   { return read_serialized_vectors<Number>(io, vectors); }
.fi
.SS "void libMesh::EigenSystem::reinit ()\fC [virtual]\fP, \fC [inherited]\fP"
Reinitializes the member data fields associated with the system, so that, e\&.g\&., \fC\fBassemble()\fP\fP may be used\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 164 of file eigen_system\&.C\&.
.PP
References libMesh::EigenSystem::_is_generalized_eigenproblem, libMesh::SparseMatrix< T >::clear(), libMesh::DofMap::clear_sparsity(), libMesh::DofMap::compute_sparsity(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::SparseMatrix< T >::init(), libMesh::EigenSystem::matrix_A, libMesh::EigenSystem::matrix_B, libMesh::System::reinit(), and libMesh::SparseMatrix< T >::zero()\&.
.PP
.nf
165 {
166   // initialize parent data
167   Parent::reinit();
168 
169   // Clear the matrices
170   matrix_A->clear();
171 
172   if (_is_generalized_eigenproblem)
173     matrix_B->clear();
174 
175   DofMap& dof_map = this->get_dof_map();
176 
177   // Clear the sparsity pattern
178   dof_map\&.clear_sparsity();
179 
180   // Compute the sparsity pattern for the current
181   // mesh and DOF distribution\&.  This also updates
182   // both matrices, \p DofMap now knows them
183   dof_map\&.compute_sparsity(this->get_mesh());
184 
185   matrix_A->init();
186   matrix_A->zero();
187 
188   if (_is_generalized_eigenproblem)
189     {
190       matrix_B->init();
191       matrix_B->zero();
192     }
193 }
.fi
.SS "void libMesh::System::remove_vector (const std::string &vec_name)\fC [inherited]\fP"
Removes the additional vector \fCvec_name\fP from this system 
.PP
Definition at line 712 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, and libMesh::System::have_vector()\&.
.PP
Referenced by libMesh::AdjointRefinementEstimator::estimate_error()\&.
.PP
.nf
713 {
714   //Return if the vector does not exist
715   if ( !(this->have_vector(vec_name)) )
716     return;
717 
718   _vectors[vec_name]->clear();
719   delete _vectors[vec_name];
720   _vectors[vec_name] = NULL;
721 
722   _vectors\&.erase(vec_name);
723   _vector_projections\&.erase(vec_name);
724   _vector_types\&.erase(vec_name);
725 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to the vector if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCNULL\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 727 of file system\&.C\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error()\&.
.PP
.nf
728 {
729   const_vectors_iterator pos = _vectors\&.find(vec_name);
730 
731   if (pos == _vectors\&.end())
732     return NULL;
733 
734   return pos->second;
735 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const std::string &vec_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the vector if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCNULL\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 739 of file system\&.C\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
740 {
741   vectors_iterator pos = _vectors\&.find(vec_name);
742 
743   if (pos == _vectors\&.end())
744     return NULL;
745 
746   return pos->second;
747 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0), or returns \fCNULL\fP if the system has no such vector\&. 
.RE
.PP

.PP
Definition at line 751 of file system\&.C\&.
.PP
References libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
752 {
753   const_vectors_iterator v = vectors_begin();
754   const_vectors_iterator v_end = vectors_end();
755   unsigned int num = 0;
756   while((num<vec_num) && (v!=v_end))
757     {
758       num++;
759       ++v;
760     }
761   if (v==v_end)
762     return NULL;
763   return v->second;
764 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const unsigned intvec_num)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable pointer to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0), or returns \fCNULL\fP if the system has no such vector\&. 
.RE
.PP

.PP
Definition at line 768 of file system\&.C\&.
.PP
References libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
769 {
770   vectors_iterator v = vectors_begin();
771   vectors_iterator v_end = vectors_end();
772   unsigned int num = 0;
773   while((num<vec_num) && (v!=v_end))
774     {
775       num++;
776       ++v;
777     }
778   if (v==v_end)
779     return NULL;
780   return v->second;
781 }
.fi
.SS "void libMesh::System::restrict_solve_to (const \fBSystemSubset\fP *subset, const \fBSubsetSolveMode\fPsubset_solve_mode = \fC\fBSUBSET_ZERO\fP\fP)\fC [virtual]\fP, \fC [inherited]\fP"
After calling this method, any solve will be restricted to the given subdomain\&. To disable this mode, call this method with \fCsubset\fP being a \fCNULL\fP pointer\&. 
.PP
Reimplemented in \fBlibMesh::LinearImplicitSystem\fP\&.
.PP
Definition at line 456 of file system\&.C\&.
.PP
.nf
458 {
459   if(subset!=NULL)
460     {
461       libmesh_not_implemented();
462     }
463 }
.fi
.SS "void libMesh::System::restrict_vectors ()\fC [virtual]\fP, \fC [inherited]\fP"
Restrict vectors after the mesh has coarsened 
.PP
Definition at line 319 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::_solution_projection, libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, libMesh::System::current_local_solution, libMesh::err, libMesh::GHOSTED, libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::System::prolong_vectors(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
320 {
321 #ifdef LIBMESH_ENABLE_AMR
322   // Restrict the _vectors on the coarsened cells
323   for (vectors_iterator pos = _vectors\&.begin(); pos != _vectors\&.end(); ++pos)
324     {
325       NumericVector<Number>* v = pos->second;
326 
327       if (_vector_projections[pos->first])
328         this->project_vector (*v);
329       else
330         {
331           ParallelType type = _vector_types[pos->first];
332 
333           if(type == GHOSTED)
334             {
335 #ifdef LIBMESH_ENABLE_GHOSTED
336               pos->second->init (this->n_dofs(), this->n_local_dofs(),
337                                  _dof_map->get_send_list(), false,
338                                  GHOSTED);
339 #else
340               libMesh::err << "Cannot initialize ghosted vectors when they are not enabled\&." << std::endl;
341               libmesh_error();
342 #endif
343             }
344           else
345             pos->second->init (this->n_dofs(), this->n_local_dofs(), false, type);
346         }
347     }
348 
349   const std::vector<dof_id_type>& send_list = _dof_map->get_send_list ();
350 
351   // Restrict the solution on the coarsened cells
352   if (_solution_projection)
353     this->project_vector (*solution);
354 
355 #ifdef LIBMESH_ENABLE_GHOSTED
356   current_local_solution->init(this->n_dofs(),
357                                this->n_local_dofs(), send_list,
358                                false, GHOSTED);
359 #else
360   current_local_solution->init(this->n_dofs());
361 #endif
362 
363   if (_solution_projection)
364     solution->localize (*current_local_solution, send_list);
365 
366 #endif // LIBMESH_ENABLE_AMR
367 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::System::sensitivity_solve (const \fBParameterVector\fP &parameters)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Solves the sensitivity system, for the provided parameters\&. Must be overloaded in derived systems\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2125 of file system\&.h\&.
.PP
.nf
2126 {
2127   libmesh_not_implemented();
2128 }
.fi
.SS "void libMesh::System::set_adjoint_already_solved (boolsetting)\fC [inline]\fP, \fC [inherited]\fP"
Setter for the adjoint_already_solved boolean 
.PP
Definition at line 367 of file system\&.h\&.
.PP
References libMesh::System::adjoint_already_solved\&.
.PP
.nf
368   { adjoint_already_solved = setting;}
.fi
.SS "void libMesh::System::set_basic_system_only ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the system to be 'basic only': i\&.e\&. advanced system components such as \fBImplicitSystem\fP matrices may not be initialized\&. This is useful for efficiency in certain utility programs that never use \fBSystem::solve()\fP\&. This method must be called after the \fBSystem\fP or derived class is created but before it is initialized; e\&.g\&. from within \fBEquationSystems::read()\fP 
.PP
Definition at line 1943 of file system\&.h\&.
.PP
References libMesh::System::_basic_system_only\&.
.PP
Referenced by libMesh::EquationSystems::_read_impl()\&.
.PP
.nf
1944 {
1945   _basic_system_only = true;
1946 }
.fi
.SS "void libMesh::EigenSystem::set_eigenproblem_type (\fBEigenProblemType\fPept)\fC [inherited]\fP"
Sets the type of the current eigen problem\&. 
.PP
Definition at line 85 of file eigen_system\&.C\&.
.PP
References libMesh::EigenSystem::_eigen_problem_type, libMesh::EigenSystem::eigen_solver, libMesh::GHEP, libMesh::GNHEP, libMesh::HEP, and libMesh::NHEP\&.
.PP
.nf
86 {
87   _eigen_problem_type = ept;
88 
89   eigen_solver->set_eigenproblem_type(ept);
90 
91   // libMesh::out<< "The Problem type is set to be: "<<std::endl;
92 
93   switch (_eigen_problem_type)
94     {
95     case HEP: // libMesh::out<<"Hermitian"<<std::endl;
96       break;
97 
98     case NHEP: // libMesh::out<<"Non-Hermitian"<<std::endl;
99       break;
100 
101     case GHEP: // libMesh::out<<"Gerneralized Hermitian"<<std::endl;
102       break;
103 
104     case GNHEP: // libMesh::out<<"Generalized Non-Hermitian"<<std::endl;
105       break;
106 
107     default: // libMesh::out<<"not properly specified"<<std::endl;
108       libmesh_error();
109       break;
110 
111     }
112 }
.fi
.SS "void libMesh::EigenSystem::set_n_converged (unsigned intnconv)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Set the _n_converged_eigenpairs member, useful for subclasses of \fBEigenSystem\fP\&. 
.PP
Definition at line 185 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_n_converged_eigenpairs\&.
.PP
Referenced by solve()\&.
.PP
.nf
186   { _n_converged_eigenpairs = nconv; }
.fi
.SS "void libMesh::EigenSystem::set_n_iterations (unsigned intits)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Set the _n_iterations member, useful for subclasses of \fBEigenSystem\fP\&. 
.PP
Definition at line 192 of file eigen_system\&.h\&.
.PP
References libMesh::EigenSystem::_n_iterations\&.
.PP
Referenced by solve()\&.
.PP
.nf
193   { _n_iterations = its;}
.fi
.SS "void libMesh::System::set_vector_preservation (const std::string &vec_name, boolpreserve)\fC [inherited]\fP"
Allows one to set the boolean controlling whether the vector identified by vec_name should be 'preserved': projected to new meshes, saved, etc\&. 
.PP
Definition at line 888 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections\&.
.PP
.nf
890 {
891   _vector_projections[vec_name] = preserve;
892 }
.fi
.SS "void libMesh::CondensedEigenSystem::solve ()\fC [virtual]\fP"
Override to solve the condensed eigenproblem with the dofs in local_non_condensed_dofs_vector stripped out of the system matrices on each processor\&. 
.PP
Reimplemented from \fBlibMesh::EigenSystem\fP\&.
.PP
Definition at line 97 of file condensed_eigen_system\&.C\&.
.PP
References libMesh::EigenSystem::assemble(), libMesh::System::assemble_before_solve, condensed_dofs_initialized, condensed_matrix_A, condensed_matrix_B, libMesh::SparseMatrix< T >::create_submatrix(), libMesh::EigenSystem::eigen_solver, libMesh::EigenSystem::generalized(), libMesh::Parameters::get(), libMesh::System::get_equation_systems(), libMesh::Parameters::have_parameter(), libMesh::libmesh_assert(), local_non_condensed_dofs_vector, libMesh::EigenSystem::matrix_A, libMesh::EigenSystem::matrix_B, libMesh::EquationSystems::parameters, libMesh::Real, libMesh::EigenSystem::set_n_converged(), libMesh::EigenSystem::set_n_iterations(), libMesh::EigenSystem::solve(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
98 {
99   START_LOG("solve()", "CondensedEigenSystem");
100 
101   // If we haven't initialized any condensed dofs,
102   // just use the default eigen_system
103   if(!condensed_dofs_initialized)
104     {
105       STOP_LOG("solve()", "CondensedEigenSystem");
106       Parent::solve();
107       return;
108     }
109 
110   // A reference to the EquationSystems
111   EquationSystems& es = this->get_equation_systems();
112 
113   // check that necessary parameters have been set
114   libmesh_assert (es\&.parameters\&.have_parameter<unsigned int>("eigenpairs"));
115   libmesh_assert (es\&.parameters\&.have_parameter<unsigned int>("basis vectors"));
116 
117   if (this->assemble_before_solve)
118     // Assemble the linear system
119     this->assemble ();
120 
121   // If we reach here, then there should be some non-condensed dofs
122   libmesh_assert(!local_non_condensed_dofs_vector\&.empty());
123 
124   // Now condense the matrices
125   matrix_A->create_submatrix(*condensed_matrix_A,
126                              local_non_condensed_dofs_vector,
127                              local_non_condensed_dofs_vector);
128 
129   if(generalized())
130     {
131       matrix_B->create_submatrix(*condensed_matrix_B,
132                                  local_non_condensed_dofs_vector,
133                                  local_non_condensed_dofs_vector);
134     }
135 
136 
137   // Get the tolerance for the solver and the maximum
138   // number of iterations\&. Here, we simply adopt the linear solver
139   // specific parameters\&.
140   const Real tol            =
141     es\&.parameters\&.get<Real>("linear solver tolerance");
142 
143   const unsigned int maxits =
144     es\&.parameters\&.get<unsigned int>("linear solver maximum iterations");
145 
146   const unsigned int nev    =
147     es\&.parameters\&.get<unsigned int>("eigenpairs");
148 
149   const unsigned int ncv    =
150     es\&.parameters\&.get<unsigned int>("basis vectors");
151 
152   std::pair<unsigned int, unsigned int> solve_data;
153 
154   // call the solver depending on the type of eigenproblem
155   if ( generalized() )
156     {
157       //in case of a generalized eigenproblem
158       solve_data = eigen_solver->solve_generalized
159         (*condensed_matrix_A,*condensed_matrix_B, nev, ncv, tol, maxits);
160     }
161 
162   else
163     {
164       libmesh_assert (!matrix_B);
165 
166       //in case of a standard eigenproblem
167       solve_data = eigen_solver->solve_standard (*condensed_matrix_A, nev, ncv, tol, maxits);
168     }
169 
170   set_n_converged(solve_data\&.first);
171   set_n_iterations(solve_data\&.second);
172 
173   STOP_LOG("solve()", "CondensedEigenSystem");
174 }
.fi
.SS "\fBsys_type\fP& libMesh::CondensedEigenSystem::system ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
a clever pointer to the system\&. 
.RE
.PP

.PP
Definition at line 73 of file condensed_eigen_system\&.h\&.
.PP
.nf
73 { return *this; }
.fi
.SS "virtual std::string libMesh::EigenSystem::system_type () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC'Eigen'\fP\&. Helps in identifying the system type in an equation system file\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 117 of file eigen_system\&.h\&.
.PP
.nf
117 { return "Eigen"; }
.fi
.SS "void libMesh::System::update ()\fC [virtual]\fP, \fC [inherited]\fP"
Update the local values to reflect the solution on neighboring processors\&. 
.PP
Definition at line 411 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::libmesh_assert(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), DMlibMeshFunction(), libMesh::AdjointRefinementEstimator::estimate_error(), get_eigenpair(), libMesh::EquationSystems::get_solution(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::postprocess(), libMesh::NewtonSolver::solve(), libMesh::ExplicitSystem::solve(), libMesh::LinearImplicitSystem::solve(), and libMesh::NonlinearImplicitSystem::solve()\&.
.PP
.nf
412 {
413   libmesh_assert(solution->closed());
414 
415   const std::vector<dof_id_type>& send_list = _dof_map->get_send_list ();
416 
417   // Check sizes
418   libmesh_assert_equal_to (current_local_solution->size(), solution->size());
419   // More processors than elements => empty send_list
420   //  libmesh_assert (!send_list\&.empty());
421   libmesh_assert_less_equal (send_list\&.size(), solution->size());
422 
423   // Create current_local_solution from solution\&.  This will
424   // put a local copy of solution into current_local_solution\&.
425   // Only the necessary values (specified by the send_list)
426   // are copied to minimize communication
427   solution->localize (*current_local_solution, send_list);
428 }
.fi
.SS "void libMesh::System::update_global_solution (std::vector< \fBNumber\fP > &global_soln) const\fC [inherited]\fP"
Fill the input vector \fCglobal_soln\fP so that it contains the global solution on all processors\&. Requires communication with all other processors\&. 
.PP
Definition at line 657 of file system\&.C\&.
.PP
References libMesh::System::solution\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::EquationSystems::build_discontinuous_solution_vector(), and libMesh::for()\&.
.PP
.nf
658 {
659   global_soln\&.resize (solution->size());
660 
661   solution->localize (global_soln);
662 }
.fi
.SS "void libMesh::System::update_global_solution (std::vector< \fBNumber\fP > &global_soln, const unsigned intdest_proc) const\fC [inherited]\fP"
Fill the input vector \fCglobal_soln\fP so that it contains the global solution on processor \fCdest_proc\fP\&. Requires communication with all other processors\&. 
.PP
Definition at line 666 of file system\&.C\&.
.PP
References libMesh::System::solution\&.
.PP
.nf
668 {
669   global_soln\&.resize        (solution->size());
670 
671   solution->localize_to_one (global_soln, dest_proc);
672 }
.fi
.SS "void libMesh::System::user_assembly ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached assembly function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1910 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, libMesh::System::_equation_systems, libMesh::System::Assembly::assemble(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::System::assemble()\&.
.PP
.nf
1911 {
1912   // Call the user-provided assembly function,
1913   // if it was provided
1914   if (_assemble_system_function != NULL)
1915     this->_assemble_system_function (_equation_systems, this->name());
1916 
1917   // \&.\&.\&.or the user-provided assembly object\&.
1918   else if (_assemble_system_object != NULL)
1919     this->_assemble_system_object->assemble();
1920 }
.fi
.SS "void libMesh::System::user_constrain ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached constraint function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1924 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, libMesh::System::_equation_systems, libMesh::System::Constraint::constrain(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), libMesh::System::init_data(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
1925 {
1926   // Call the user-provided constraint function,
1927   // if it was provided
1928   if (_constrain_system_function!= NULL)
1929     this->_constrain_system_function(_equation_systems, this->name());
1930 
1931   // \&.\&.\&.or the user-provided constraint object\&.
1932   else if (_constrain_system_object != NULL)
1933     this->_constrain_system_object->constrain();
1934 }
.fi
.SS "void libMesh::System::user_initialization ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached initialization function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1896 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_init_system_function, libMesh::System::_init_system_object, libMesh::System::Initialization::initialize(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::System::init(), and libMesh::NewmarkSystem::initial_conditions()\&.
.PP
.nf
1897 {
1898   // Call the user-provided intialization function,
1899   // if it was provided
1900   if (_init_system_function != NULL)
1901     this->_init_system_function (_equation_systems, this->name());
1902 
1903   // \&.\&.\&.or the user-provided initialization object\&.
1904   else if (_init_system_object != NULL)
1905     this->_init_system_object->initialize();
1906 }
.fi
.SS "void libMesh::System::user_QOI (const \fBQoISet\fP &qoi_indices)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached quantity of interest function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1938 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, libMesh::System::name(), and libMesh::System::QOI::qoi()\&.
.PP
Referenced by libMesh::System::assemble_qoi()\&.
.PP
.nf
1939 {
1940   // Call the user-provided quantity of interest function,
1941   // if it was provided
1942   if (_qoi_evaluate_function != NULL)
1943     this->_qoi_evaluate_function(_equation_systems, this->name(), qoi_indices);
1944 
1945   // \&.\&.\&.or the user-provided QOI function object\&.
1946   else if (_qoi_evaluate_object != NULL)
1947     this->_qoi_evaluate_object->qoi(qoi_indices);
1948 }
.fi
.SS "void libMesh::System::user_QOI_derivative (const \fBQoISet\fP &qoi_indices)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached quantity of interest derivative function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1952 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, libMesh::System::name(), and libMesh::System::QOIDerivative::qoi_derivative()\&.
.PP
Referenced by libMesh::System::assemble_qoi_derivative()\&.
.PP
.nf
1953 {
1954   // Call the user-provided quantity of interest derivative,
1955   // if it was provided
1956   if (_qoi_evaluate_derivative_function != NULL)
1957     this->_qoi_evaluate_derivative_function(_equation_systems, this->name(), qoi_indices);
1958 
1959   // \&.\&.\&.or the user-provided QOI derivative function object\&.
1960   else if (_qoi_evaluate_derivative_object != NULL)
1961     this->_qoi_evaluate_derivative_object->qoi_derivative(qoi_indices);
1962 }
.fi
.SS "const \fBVariable\fP & libMesh::System::variable (unsigned intvar) const\fC [inline]\fP, \fC [inherited]\fP"
Return a constant reference to \fC\fBVariable\fP\fP \fCvar\fP\&. 
.PP
Definition at line 1979 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::WrappedFunction< Output >::component(), libMesh::EquationSystems::get_solution(), libMesh::WrappedFunction< Output >::operator()(), libMesh::System::project_vector(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_vector(), and libMesh::System::write_serialized_vectors()\&.
.PP
.nf
1980 {
1981   libmesh_assert_less (i, _variables\&.size());
1982 
1983   return _variables[i];
1984 }
.fi
.SS "const \fBVariableGroup\fP & libMesh::System::variable_group (unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"
Return a constant reference to \fC\fBVariableGroup\fP\fP \fCvg\fP\&. 
.PP
Definition at line 1989 of file system\&.h\&.
.PP
References libMesh::System::_variable_groups\&.
.PP
Referenced by libMesh::System::get_info()\&.
.PP
.nf
1990 {
1991   libmesh_assert_less (vg, _variable_groups\&.size());
1992 
1993   return _variable_groups[vg];
1994 }
.fi
.SS "const std::string & libMesh::System::variable_name (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of variable \fCi\fP\&. 
.RE
.PP

.PP
Definition at line 1999 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::DiscontinuityMeasure::boundary_side_integration(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::WrappedFunction< Output >::component(), libMesh::ExactSolution::ExactSolution(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::WrappedFunction< Output >::operator()(), libMesh::petsc_auto_fieldsplit(), and libMesh::System::write_header()\&.
.PP
.nf
2000 {
2001   libmesh_assert_less (i, _variables\&.size());
2002 
2003   return _variables[i]\&.name();
2004 }
.fi
.SS "unsigned short int libMesh::System::variable_number (const std::string &var) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the variable number assoicated with the user-specified variable named \fCvar\fP\&. 
.RE
.PP

.PP
Definition at line 1240 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers, libMesh::System::_variables, and libMesh::err\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::for(), libMesh::System::read_header(), libMesh::System::variable_scalar_number(), libMesh::System::variable_type(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1241 {
1242   // Make sure the variable exists
1243   std::map<std::string, unsigned short int>::const_iterator
1244     pos = _variable_numbers\&.find(var);
1245 
1246   if (pos == _variable_numbers\&.end())
1247     {
1248       libMesh::err << "ERROR: variable "
1249                    << var
1250                    << " does not exist in this system!"
1251                    << std::endl;
1252       libmesh_error();
1253     }
1254   libmesh_assert_equal_to (_variables[pos->second]\&.name(), var);
1255 
1256   return pos->second;
1257 }
.fi
.SS "unsigned int libMesh::System::variable_scalar_number (const std::string &var, unsigned intcomponent) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
an index, starting from 0 for the first component of the first variable, and incrementing for each component of each (potentially vector-valued) variable in the system in order\&. For systems with only scalar-valued variables, this will be the same as \fCvariable_number(var)\fP 
.RE
.PP
Irony: currently our only non-scalar-valued variable type is SCALAR\&. 
.PP
Definition at line 2010 of file system\&.h\&.
.PP
References libMesh::System::variable_number()\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::WrappedFunction< Output >::component(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::WrappedFunction< Output >::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), and libMesh::System::project_vector()\&.
.PP
.nf
2012 {
2013   return variable_scalar_number(this->variable_number(var), component);
2014 }
.fi
.SS "unsigned int libMesh::System::variable_scalar_number (unsigned intvar_num, unsigned intcomponent) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
an index, starting from 0 for the first component of the first variable, and incrementing for each component of each (potentially vector-valued) variable in the system in order\&. For systems with only scalar-valued variables, this will be the same as \fCvar_num\fP 
.RE
.PP
Irony: currently our only non-scalar-valued variable type is SCALAR\&. 
.PP
Definition at line 2020 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
.nf
2022 {
2023   return _variables[var_num]\&.first_scalar_number() + component;
2024 }
.fi
.SS "const \fBFEType\fP & libMesh::System::variable_type (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type variable number \fCi\fP\&. 
.RE
.PP

.PP
Definition at line 2029 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::GMVIO::copy_nodal_solution(), libMesh::DGFEMContext::DGFEMContext(), libMesh::FEMContext::FEMContext(), libMesh::EquationSystems::get_solution(), libMesh::FEMSystem::init_context(), libMesh::System::write_header(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
2030 {
2031   libmesh_assert_less (i, _variables\&.size());
2032 
2033   return _variables[i]\&.type();
2034 }
.fi
.SS "const \fBFEType\fP & libMesh::System::variable_type (const std::string &var) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type for variable \fCvar\fP\&. 
.RE
.PP

.PP
Definition at line 2039 of file system\&.h\&.
.PP
References libMesh::System::_variables, and libMesh::System::variable_number()\&.
.PP
.nf
2040 {
2041   return _variables[this->variable_number(var)]\&.type();
2042 }
.fi
.SS "const std::string & libMesh::System::vector_name (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 855 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
856 {
857   const_vectors_iterator v = vectors_begin();
858   const_vectors_iterator v_end = vectors_end();
859   unsigned int num = 0;
860   while((num<vec_num) && (v!=v_end))
861     {
862       num++;
863       ++v;
864     }
865   libmesh_assert (v != v_end);
866   return v->first;
867 }
.fi
.SS "const std::string & libMesh::System::vector_name (const \fBNumericVector\fP< \fBNumber\fP > &vec_reference) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of a system vector, given a reference to that vector 
.RE
.PP

.PP
Definition at line 869 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
870 {
871   const_vectors_iterator v = vectors_begin();
872   const_vectors_iterator v_end = vectors_end();
873 
874   for(; v != v_end; ++v)
875     {
876       // Check if the current vector is the one whose name we want
877       if(&vec_reference == v->second)
878         break; // exit loop if it is
879     }
880 
881   // Before returning, make sure we didnt loop till the end and not find any match
882   libmesh_assert (v != v_end);
883 
884   // Return the string associated with the current vector
885   return v->first;
886 }
.fi
.SS "bool libMesh::System::vector_preservation (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the boolean describing whether the vector identified by vec_name should be 'preserved': projected to new meshes, saved, etc\&. 
.RE
.PP

.PP
Definition at line 896 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections\&.
.PP
Referenced by libMesh::MemorySolutionHistory::store()\&.
.PP
.nf
897 {
898   if (_vector_projections\&.find(vec_name) == _vector_projections\&.end())
899     return false;
900 
901   return _vector_projections\&.find(vec_name)->second;
902 }
.fi
.SS "\fBSystem::vectors_iterator\fP libMesh::System::vectors_begin ()\fC [inline]\fP, \fC [inherited]\fP"
Beginning of vectors container 
.PP
Definition at line 2091 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_vector(), libMesh::System::request_vector(), libMesh::MemorySolutionHistory::store(), libMesh::VTKIO::system_vectors_to_vtk(), and libMesh::System::vector_name()\&.
.PP
.nf
2092 {
2093   return _vectors\&.begin();
2094 }
.fi
.SS "\fBSystem::const_vectors_iterator\fP libMesh::System::vectors_begin () const\fC [inline]\fP, \fC [inherited]\fP"
Beginning of vectors container 
.PP
Definition at line 2097 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
2098 {
2099   return _vectors\&.begin();
2100 }
.fi
.SS "\fBSystem::vectors_iterator\fP libMesh::System::vectors_end ()\fC [inline]\fP, \fC [inherited]\fP"
End of vectors container 
.PP
Definition at line 2103 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_vector(), libMesh::System::request_vector(), libMesh::MemorySolutionHistory::store(), libMesh::VTKIO::system_vectors_to_vtk(), and libMesh::System::vector_name()\&.
.PP
.nf
2104 {
2105   return _vectors\&.end();
2106 }
.fi
.SS "\fBSystem::const_vectors_iterator\fP libMesh::System::vectors_end () const\fC [inline]\fP, \fC [inherited]\fP"
End of vectors container 
.PP
Definition at line 2109 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
2110 {
2111   return _vectors\&.end();
2112 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::System::weighted_sensitivity_adjoint_solve (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights, const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system(s) (dR/du)^T*z_w = sum(w_p*(d^2q/dudp - d^2R/dudp*z)), for those parameters p contained within \fCparameters\fP, weighted by the values w_p found within \fCweights\fP\&.
.PP
Assumes that adjoint_solve has already calculated z for each qoi in \fCqoi_indices\fP\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2147 of file system\&.h\&.
.PP
.nf
2150 {
2151   libmesh_not_implemented();
2152 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::System::weighted_sensitivity_solve (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system(s) (dR/du)*u_w = sum(w_p*-dR/dp), for those parameters p contained within \fCparameters\fP weighted by the values w_p found within \fCweights\fP\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms
.PP
This method is only implemented in some derived classes\&. 
.PP
Reimplemented in \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 2132 of file system\&.h\&.
.PP
.nf
2134 {
2135   libmesh_not_implemented();
2136 }
.fi
.SS "void libMesh::System::write_header (\fBXdr\fP &io, const std::string &version, const boolwrite_additional_data) const\fC [inherited]\fP"
Writes the basic data header for this \fBSystem\fP\&. This method implements the output of a \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&. This warrants some documentation\&. The output of this part consists of 5 sections:
.PP
for this system
.PP
5\&.) The number of variables in the system (unsigned int)
.PP
for each variable in the system
.PP
6\&.) The name of the variable (string)
.PP
6\&.1\&.) subdomain where the variable lives
.PP
7\&.) Combined in an \fBFEType\fP:
.IP "\(bu" 2
The approximation order(s) of the variable (Order Enum, cast to int/s)
.IP "\(bu" 2
The finite element family/ies of the variable (FEFamily Enum, cast to int/s)
.PP
.PP
end variable loop
.PP
8\&.) The number of additional vectors (unsigned int),
.PP
for each additional vector in the system object
.PP
9\&.) the name of the additional vector (string)
.PP
end system
.PP
Definition at line 1268 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Variable::active_subdomains(), libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::FEType::inf_map, libMesh::libmesh_assert(), libMesh::System::n_vars(), libMesh::System::n_vectors(), libMesh::System::name(), libMesh::FEType::order, libMesh::ParallelObject::processor_id(), libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::System::variable(), libMesh::System::variable_name(), libMesh::System::variable_type(), and libMesh::Xdr::writing()\&.
.PP
.nf
1271 {
1305   libmesh_assert (io\&.writing());
1306 
1307 
1308   // Only write the header information
1309   // if we are processor 0\&.
1310   if (this->get_mesh()\&.processor_id() != 0)
1311     return;
1312 
1313   std::string comment;
1314   char buf[80];
1315 
1316   // 5\&.)
1317   // Write the number of variables in the system
1318 
1319   {
1320     // set up the comment
1321     comment = "# No\&. of Variables in System \"";
1322     comment += this->name();
1323     comment += "\"";
1324 
1325     unsigned int nv = this->n_vars();
1326     io\&.data (nv, comment\&.c_str());
1327   }
1328 
1329 
1330   for (unsigned int var=0; var<this->n_vars(); var++)
1331     {
1332       // 6\&.)
1333       // Write the name of the var-th variable
1334       {
1335         // set up the comment
1336         comment  = "#   Name, Variable No\&. ";
1337         std::sprintf(buf, "%u", var);
1338         comment += buf;
1339         comment += ", System \"";
1340         comment += this->name();
1341         comment += "\"";
1342 
1343         std::string var_name = this->variable_name(var);
1344         io\&.data (var_name, comment\&.c_str());
1345       }
1346 
1347       // 6\&.1\&.) Variable subdomains
1348       {
1349         // set up the comment
1350         comment  = "#     Subdomains, Variable \"";
1351         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1352         comment += buf;
1353         comment += "\", System \"";
1354         comment += this->name();
1355         comment += "\"";
1356 
1357         const std::set<subdomain_id_type> & domains = this->variable(var)\&.active_subdomains();
1358         std::vector<subdomain_id_type> domain_array;
1359         domain_array\&.assign(domains\&.begin(), domains\&.end());
1360         io\&.data (domain_array, comment\&.c_str());
1361       }
1362 
1363       // 7\&.)
1364       // Write the approximation order of the var-th variable
1365       // in this system
1366       {
1367         // set up the comment
1368         comment = "#     Approximation Order, Variable \"";
1369         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1370         comment += buf;
1371         comment += "\", System \"";
1372         comment += this->name();
1373         comment += "\"";
1374 
1375         int order = static_cast<int>(this->variable_type(var)\&.order);
1376         io\&.data (order, comment\&.c_str());
1377       }
1378 
1379 
1380 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
1381 
1382       // do the same for radial_order
1383       {
1384         comment = "#     Radial Approximation Order, Variable \"";
1385         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1386         comment += buf;
1387         comment += "\", System \"";
1388         comment += this->name();
1389         comment += "\"";
1390 
1391         int rad_order = static_cast<int>(this->variable_type(var)\&.radial_order);
1392         io\&.data (rad_order, comment\&.c_str());
1393       }
1394 
1395 #endif
1396 
1397       // Write the Finite Element type of the var-th variable
1398       // in this System
1399       {
1400         // set up the comment
1401         comment = "#     FE Family, Variable \"";
1402         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1403         comment += buf;
1404         comment += "\", System \"";
1405         comment += this->name();
1406         comment += "\"";
1407 
1408         const FEType& type = this->variable_type(var);
1409         int fam = static_cast<int>(type\&.family);
1410         io\&.data (fam, comment\&.c_str());
1411 
1412 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
1413 
1414         comment = "#     Radial FE Family, Variable \"";
1415         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1416         comment += buf;
1417         comment += "\", System \"";
1418         comment += this->name();
1419         comment += "\"";
1420 
1421         int radial_fam = static_cast<int>(type\&.radial_family);
1422         io\&.data (radial_fam, comment\&.c_str());
1423 
1424         comment = "#     Infinite Mapping Type, Variable \"";
1425         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1426         comment += buf;
1427         comment += "\", System \"";
1428         comment += this->name();
1429         comment += "\"";
1430 
1431         int i_map = static_cast<int>(type\&.inf_map);
1432         io\&.data (i_map, comment\&.c_str());
1433 #endif
1434       }
1435     } // end of the variable loop
1436 
1437   // 8\&.)
1438   // Write the number of additional vectors in the System\&.
1439   // If write_additional_data==false, then write zero for
1440   // the number of additional vectors\&.
1441   {
1442     {
1443       // set up the comment
1444       comment = "# No\&. of Additional Vectors, System \"";
1445       comment += this->name();
1446       comment += "\"";
1447 
1448       unsigned int nvecs = write_additional_data ? this->n_vectors () : 0;
1449       io\&.data (nvecs, comment\&.c_str());
1450     }
1451 
1452     if (write_additional_data)
1453       {
1454         std::map<std::string, NumericVector<Number>* >::const_iterator
1455           vec_pos = this->_vectors\&.begin();
1456         unsigned int cnt=0;
1457 
1458         for (; vec_pos != this->_vectors\&.end(); ++vec_pos)
1459           {
1460             // 9\&.)
1461             // write the name of the cnt-th additional vector
1462             comment =  "# Name of ";
1463             std::sprintf(buf, "%d", cnt++);
1464             comment += buf;
1465             comment += "th vector";
1466             std::string vec_name = vec_pos->first;
1467 
1468             io\&.data (vec_name, comment\&.c_str());
1469           }
1470       }
1471   }
1472 }
.fi
.SS "void libMesh::System::write_parallel_data (\fBXdr\fP &io, const boolwrite_additional_data) const\fC [inherited]\fP"
Writes additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will create an individual file for each processor in the simulation where the local solution components for that processor will be stored\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Note that the actual IO is handled through the \fBXdr\fP class (to be renamed later?) which provides a uniform interface to both the XDR (eXternal Data Representation) interface and standard ASCII output\&. Thus this one section of code will read XDR or ASCII files with no changes\&.
.PP
Definition at line 1476 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Xdr::data(), libMesh::dof_map, libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::System::name(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::System::solution, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::Xdr::writing()\&.
.PP
.nf
1478 {
1498   // PerfLog pl("IO Performance",false);
1499   // pl\&.push("write_parallel_data");
1500   // std::size_t total_written_size = 0;
1501 
1502   std::string comment;
1503 
1504   libmesh_assert (io\&.writing());
1505 
1506   std::vector<Number> io_buffer; io_buffer\&.reserve(this->solution->local_size());
1507 
1508   // build the ordered nodes and element maps\&.
1509   // when writing/reading parallel files we need to iterate
1510   // over our nodes/elements in order of increasing global id()\&.
1511   // however, this is not guaranteed to be ordering we obtain
1512   // by using the node_iterators/element_iterators directly\&.
1513   // so build a set, sorted by id(), that provides the ordering\&.
1514   // further, for memory economy build the set but then transfer
1515   // its contents to vectors, which will be sorted\&.
1516   std::vector<const DofObject*> ordered_nodes, ordered_elements;
1517   {
1518     std::set<const DofObject*, CompareDofObjectsByID>
1519       ordered_nodes_set (this->get_mesh()\&.local_nodes_begin(),
1520                          this->get_mesh()\&.local_nodes_end());
1521 
1522     ordered_nodes\&.insert(ordered_nodes\&.end(),
1523                          ordered_nodes_set\&.begin(),
1524                          ordered_nodes_set\&.end());
1525   }
1526   {
1527     std::set<const DofObject*, CompareDofObjectsByID>
1528       ordered_elements_set (this->get_mesh()\&.local_elements_begin(),
1529                             this->get_mesh()\&.local_elements_end());
1530 
1531     ordered_elements\&.insert(ordered_elements\&.end(),
1532                             ordered_elements_set\&.begin(),
1533                             ordered_elements_set\&.end());
1534   }
1535 
1536   const unsigned int sys_num = this->number();
1537   const unsigned int nv      = this->n_vars();
1538 
1539   // Loop over each non-SCALAR variable and each node, and write out the value\&.
1540   for (unsigned int var=0; var<nv; var++)
1541     if (this->variable(var)\&.type()\&.family != SCALAR)
1542       {
1543         // First write the node DOF values
1544         for (std::vector<const DofObject*>::const_iterator
1545                it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
1546           for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1547             {
1548               //libMesh::out << "(*it)->id()=" << (*it)->id() << std::endl;
1549               libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1550                                            DofObject::invalid_id);
1551 
1552               io_buffer\&.push_back((*this->solution)((*it)->dof_number(sys_num, var, comp)));
1553             }
1554 
1555         // Then write the element DOF values
1556         for (std::vector<const DofObject*>::const_iterator
1557                it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
1558           for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1559             {
1560               libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1561                                            DofObject::invalid_id);
1562 
1563               io_buffer\&.push_back((*this->solution)((*it)->dof_number(sys_num, var, comp)));
1564             }
1565       }
1566 
1567   // Finally, write the SCALAR data on the last processor
1568   for (unsigned int var=0; var<this->n_vars(); var++)
1569     if(this->variable(var)\&.type()\&.family == SCALAR)
1570       {
1571         if (this->processor_id() == (this->n_processors()-1))
1572           {
1573             const DofMap& dof_map = this->get_dof_map();
1574             std::vector<dof_id_type> SCALAR_dofs;
1575             dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
1576 
1577             for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
1578               {
1579                 io_buffer\&.push_back( (*this->solution)(SCALAR_dofs[i]) );
1580               }
1581           }
1582       }
1583 
1584   // 9\&.)
1585   //
1586   // Actually write the reordered solution vector
1587   // for the ith system to disk
1588 
1589   // set up the comment
1590   {
1591     comment = "# System \"";
1592     comment += this->name();
1593     comment += "\" Solution Vector";
1594   }
1595 
1596   io\&.data (io_buffer, comment\&.c_str());
1597 
1598   // total_written_size += io_buffer\&.size();
1599 
1600   // Only write additional vectors if wanted
1601   if (write_additional_data)
1602     {
1603       std::map<std::string, NumericVector<Number>* >::const_iterator
1604         pos = _vectors\&.begin();
1605 
1606       for(; pos != this->_vectors\&.end(); ++pos)
1607         {
1608           io_buffer\&.clear(); io_buffer\&.reserve( pos->second->local_size());
1609 
1610           // Loop over each non-SCALAR variable and each node, and write out the value\&.
1611           for (unsigned int var=0; var<nv; var++)
1612             if(this->variable(var)\&.type()\&.family != SCALAR)
1613               {
1614                 // First write the node DOF values
1615                 for (std::vector<const DofObject*>::const_iterator
1616                        it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
1617                   for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1618                     {
1619                       libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1620                                                    DofObject::invalid_id);
1621 
1622                       io_buffer\&.push_back((*pos->second)((*it)->dof_number(sys_num, var, comp)));
1623                     }
1624 
1625                 // Then write the element DOF values
1626                 for (std::vector<const DofObject*>::const_iterator
1627                        it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
1628                   for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1629                     {
1630                       libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1631                                                    DofObject::invalid_id);
1632 
1633                       io_buffer\&.push_back((*pos->second)((*it)->dof_number(sys_num, var, comp)));
1634                     }
1635               }
1636 
1637           // Finally, write the SCALAR data on the last processor
1638           for (unsigned int var=0; var<this->n_vars(); var++)
1639             if(this->variable(var)\&.type()\&.family == SCALAR)
1640               {
1641                 if (this->processor_id() == (this->n_processors()-1))
1642                   {
1643                     const DofMap& dof_map = this->get_dof_map();
1644                     std::vector<dof_id_type> SCALAR_dofs;
1645                     dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
1646 
1647                     for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
1648                       {
1649                         io_buffer\&.push_back( (*pos->second)(SCALAR_dofs[i]) );
1650                       }
1651                   }
1652               }
1653 
1654           // 10\&.)
1655           //
1656           // Actually write the reordered additional vector
1657           // for this system to disk
1658 
1659           // set up the comment
1660           {
1661             comment = "# System \"";
1662             comment += this->name();
1663             comment += "\" Additional Vector \"";
1664             comment += pos->first;
1665             comment += "\"";
1666           }
1667 
1668           io\&.data (io_buffer, comment\&.c_str());
1669 
1670           // total_written_size += io_buffer\&.size();
1671         }
1672     }
1673 
1674   // const Real
1675   //   dt   = pl\&.get_elapsed_time(),
1676   //   rate = total_written_size*sizeof(Number)/dt;
1677 
1678   // libMesh::err << "Write " << total_written_size << " \"Number\" values\n"
1679   //     << " Elapsed time = " << dt << '\n'
1680   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
1681 
1682   // pl\&.pop("write_parallel_data");
1683 }
.fi
.SS "void libMesh::System::write_serialized_data (\fBXdr\fP &io, const boolwrite_additional_data = \fCtrue\fP) const\fC [inherited]\fP"
Writes additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Definition at line 1687 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Xdr::comment(), libMesh::System::name(), libMesh::ParallelObject::processor_id(), libMesh::System::solution, and libMesh::System::write_serialized_vector()\&.
.PP
.nf
1689 {
1703   parallel_object_only();
1704   std::string comment;
1705 
1706   // PerfLog pl("IO Performance",false);
1707   // pl\&.push("write_serialized_data");
1708   // std::size_t total_written_size = 0;
1709 
1710   // total_written_size +=
1711   this->write_serialized_vector(io, *this->solution);
1712 
1713   // set up the comment
1714   if (this->processor_id() == 0)
1715     {
1716       comment = "# System \"";
1717       comment += this->name();
1718       comment += "\" Solution Vector";
1719 
1720       io\&.comment (comment);
1721     }
1722 
1723   // Only write additional vectors if wanted
1724   if (write_additional_data)
1725     {
1726       std::map<std::string, NumericVector<Number>* >::const_iterator
1727         pos = _vectors\&.begin();
1728 
1729       for(; pos != this->_vectors\&.end(); ++pos)
1730         {
1731           // total_written_size +=
1732           this->write_serialized_vector(io, *pos->second);
1733 
1734           // set up the comment
1735           if (this->processor_id() == 0)
1736             {
1737               comment = "# System \"";
1738               comment += this->name();
1739               comment += "\" Additional Vector \"";
1740               comment += pos->first;
1741               comment += "\"";
1742               io\&.comment (comment);
1743             }
1744         }
1745     }
1746 
1747   // const Real
1748   //   dt   = pl\&.get_elapsed_time(),
1749   //   rate = total_written_size*sizeof(Number)/dt;
1750 
1751   // libMesh::out << "Write " << total_written_size << " \"Number\" values\n"
1752   //     << " Elapsed time = " << dt << '\n'
1753   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
1754 
1755   // pl\&.pop("write_serialized_data");
1756 
1757 
1758 
1759 
1760   // // test the new method
1761   // {
1762   //   std::vector<std::string> names;
1763   //   std::vector<NumericVector<Number>*> vectors_to_write;
1764 
1765   //   names\&.push_back("Solution Vector");
1766   //   vectors_to_write\&.push_back(this->solution\&.get());
1767 
1768   //   // Only write additional vectors if wanted
1769   //   if (write_additional_data)
1770   //     {
1771   // std::map<std::string, NumericVector<Number>* >::const_iterator
1772   //   pos = _vectors\&.begin();
1773 
1774   // for(; pos != this->_vectors\&.end(); ++pos)
1775   //   {
1776   //     names\&.push_back("Additional Vector " + pos->first);
1777   //     vectors_to_write\&.push_back(pos->second);
1778   //   }
1779   //     }
1780 
1781   //   total_written_size =
1782   //     this->write_serialized_vectors (io, names, vectors_to_write);
1783 
1784   //   const Real
1785   //     dt2   = pl\&.get_elapsed_time(),
1786   //     rate2 = total_written_size*sizeof(Number)/(dt2-dt);
1787 
1788   //   libMesh::out << "Write (new) " << total_written_size << " \"Number\" values\n"
1789   //       << " Elapsed time = " << (dt2-dt) << '\n'
1790   //       << " Rate = " << rate2/1\&.e6 << "(MB/sec)\n\n";
1791 
1792   // }
1793 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::write_serialized_vectors (\fBXdr\fP &io, const std::vector< const \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inherited]\fP"
Serialize & write a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 2287 of file system_io\&.C\&.
.PP
References libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshTools::n_elem(), n_nodes, libMesh::MeshBase::n_nodes(), libMesh::System::n_vars(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::Variable::type(), libMesh::System::variable(), libMesh::System::write_SCALAR_dofs(), libMesh::System::write_serialized_blocked_dof_objects(), and libMesh::Xdr::writing()\&.
.PP
.nf
2289 {
2290   parallel_object_only();
2291 
2292   libmesh_assert (io\&.writing());
2293 
2294   // Cache these - they are not free!
2295   const dof_id_type
2296     n_nodes       = this->get_mesh()\&.n_nodes(),
2297     n_elem        = this->get_mesh()\&.n_elem();
2298 
2299   dof_id_type written_length = 0\&.;
2300 
2301   if (this->processor_id() == 0)
2302     {
2303       unsigned int
2304         n_vec    = libmesh_cast_int<unsigned int>(vectors\&.size());
2305       dof_id_type
2306         vec_size = vectors\&.empty() ? 0 : vectors[0]->size();
2307       // Set the number of vectors
2308       io\&.data(n_vec, "# number of vectors");
2309       // Set the buffer size
2310       io\&.data(vec_size, "# vector length");
2311     }
2312 
2313   //---------------------------------
2314   // Collect the values for all nodes
2315   written_length +=
2316     this->write_serialized_blocked_dof_objects (vectors,
2317                                                 n_nodes,
2318                                                 this->get_mesh()\&.local_nodes_begin(),
2319                                                 this->get_mesh()\&.local_nodes_end(),
2320                                                 io);
2321 
2322   //------------------------------------
2323   // Collect the values for all elements
2324   written_length +=
2325     this->write_serialized_blocked_dof_objects (vectors,
2326                                                 n_elem,
2327                                                 this->get_mesh()\&.local_elements_begin(),
2328                                                 this->get_mesh()\&.local_elements_end(),
2329                                                 io);
2330 
2331   //-------------------------------------------
2332   // Finally loop over all the SCALAR variables
2333   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2334     for (unsigned int var=0; var<this->n_vars(); var++)
2335       if(this->variable(var)\&.type()\&.family == SCALAR)
2336         {
2337           libmesh_assert_not_equal_to (vectors[vec], 0);
2338 
2339           written_length +=
2340             this->write_SCALAR_dofs (*vectors[vec], var, io);
2341         }
2342 
2343   return written_length;
2344 }
.fi
.SS "void libMesh::System::zero_variable (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned intvar_num) const\fC [inherited]\fP"
Zeroes all dofs in \fCv\fP that correspond to variable number \fCvar_num\fP\&. 
.PP
Definition at line 1315 of file system\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::DofObject::dof_number(), libMesh::System::get_mesh(), libMesh::MeshBase::local_nodes_begin(), libMesh::MeshBase::local_nodes_end(), mesh, libMesh::DofObject::n_comp(), libMesh::System::n_vars(), libMesh::System::number(), and libMesh::NumericVector< T >::set()\&.
.PP
.nf
1316 {
1317   /* Make sure the call makes sense\&.  */
1318   libmesh_assert_less (var_num, this->n_vars());
1319 
1320   /* Get a reference to the mesh\&.  */
1321   const MeshBase& mesh = this->get_mesh();
1322 
1323   /* Check which system we are\&.  */
1324   const unsigned int sys_num = this->number();
1325 
1326   /* Loop over nodes\&.  */
1327   {
1328     MeshBase::const_node_iterator it = mesh\&.local_nodes_begin();
1329     const MeshBase::const_node_iterator end_it = mesh\&.local_nodes_end();
1330     for ( ; it != end_it; ++it)
1331       {
1332         const Node* node = *it;
1333         unsigned int n_comp = node->n_comp(sys_num,var_num);
1334         for(unsigned int i=0; i<n_comp; i++)
1335           {
1336             const dof_id_type index = node->dof_number(sys_num,var_num,i);
1337             v\&.set(index,0\&.0);
1338           }
1339       }
1340   }
1341 
1342   /* Loop over elements\&.  */
1343   {
1344     MeshBase::const_element_iterator it = mesh\&.active_local_elements_begin();
1345     const MeshBase::const_element_iterator end_it = mesh\&.active_local_elements_end();
1346     for ( ; it != end_it; ++it)
1347       {
1348         const Elem* elem = *it;
1349         unsigned int n_comp = elem->n_comp(sys_num,var_num);
1350         for(unsigned int i=0; i<n_comp; i++)
1351           {
1352             const dof_id_type index = elem->dof_number(sys_num,var_num,i);
1353             v\&.set(index,0\&.0);
1354           }
1355       }
1356   }
1357 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "bool libMesh::System::assemble_before_solve\fC [inherited]\fP"
Flag which tells the system to whether or not to call the user assembly function during each call to \fBsolve()\fP\&. By default, every call to \fBsolve()\fP begins with a call to the user assemble, so this flag is true\&. (For explicit systems, 'solving' the system occurs during the assembly step, so this flag is always true for explicit systems\&.)
.PP
You will only want to set this to false if you need direct control over when the system is assembled, and are willing to track the state of its assembly yourself\&. An example of such a case is an implicit system with multiple right hand sides\&. In this instance, a single assembly would likely be followed with multiple calls to solve\&.
.PP
The frequency system and Newmark system have their own versions of this flag, called _finished_assemble, which might be able to be replaced with this more general concept\&. 
.PP
Definition at line 1410 of file system\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), libMesh::ImplicitSystem::disable_cache(), libMesh::System::disable_cache(), libMesh::ImplicitSystem::sensitivity_solve(), solve(), libMesh::EigenSystem::solve(), and libMesh::LinearImplicitSystem::solve()\&.
.SS "bool libMesh::CondensedEigenSystem::condensed_dofs_initialized\fC [private]\fP"
A private flag to indicate whether the condensed dofs have been initialized\&. 
.PP
Definition at line 125 of file condensed_eigen_system\&.h\&.
.PP
Referenced by get_eigenpair(), initialize_condensed_dofs(), n_global_non_condensed_dofs(), and solve()\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::CondensedEigenSystem::condensed_matrix_A"
The (condensed) system matrix for standard eigenvalue problems\&. 
.PP
Definition at line 105 of file condensed_eigen_system\&.h\&.
.PP
Referenced by solve()\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::CondensedEigenSystem::condensed_matrix_B"
A second (condensed) system matrix for generalized eigenvalue problems\&. 
.PP
Definition at line 110 of file condensed_eigen_system\&.h\&.
.PP
Referenced by solve()\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::System::current_local_solution\fC [inherited]\fP"
All the values I need to compute my contribution to the simulation at hand\&. Think of this as the current solution with any ghost values needed from other processors\&. This vector is necessarily larger than the \fCsolution\fP vector in the case of a parallel simulation\&. The \fC\fBupdate()\fP\fP member is used to synchronize the contents of the \fCsolution\fP and \fCcurrent_local_solution\fP vectors\&. 
.PP
Definition at line 1469 of file system\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::clear(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::System::current_solution(), DMlibMeshFunction(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::System::init_data(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_solution(), libMesh::System::re_update(), libMesh::System::reinit(), libMesh::System::restrict_vectors(), and libMesh::System::update()\&.
.SS "\fBAutoPtr\fP<\fBEigenSolver\fP<\fBNumber\fP> > libMesh::EigenSystem::eigen_solver\fC [inherited]\fP"
The \fBEigenSolver\fP, definig which interface, i\&.e solver package to use\&. 
.PP
Definition at line 164 of file eigen_system\&.h\&.
.PP
Referenced by libMesh::EigenSystem::clear(), get_eigenpair(), libMesh::EigenSystem::get_eigenpair(), libMesh::EigenSystem::set_eigenproblem_type(), solve(), and libMesh::EigenSystem::solve()\&.
.SS "int libMesh::System::extra_quadrature_order\fC [inherited]\fP"
A member int that can be employed to indicate increased or reduced quadrature order\&.
.PP
Note for \fBFEMSystem\fP users: By default, when calling the user-defined residual functions, the \fBFEMSystem\fP will first set up an appropriate \fBFEType::default_quadrature_rule()\fP object for performing the integration\&. This rule will integrate elements of order up to 2*p+1 exactly (where p is the sum of the base \fBFEType\fP and local p refinement levels), but if additional (or reduced) quadrature accuracy is desired then this extra_quadrature_order (default 0) will be added\&. 
.PP
Definition at line 1442 of file system\&.h\&.
.PP
Referenced by libMesh::FEMContext::FEMContext()\&.
.SS "std::vector<\fBdof_id_type\fP> libMesh::CondensedEigenSystem::local_non_condensed_dofs_vector"
Vector storing the local dof indices that will not be condensed\&. All dofs that are not in this vector will be eliminated from the system when we perform a solve\&. 
.PP
Definition at line 117 of file condensed_eigen_system\&.h\&.
.PP
Referenced by get_eigenpair(), initialize_condensed_dofs(), n_global_non_condensed_dofs(), and solve()\&.
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::EigenSystem::matrix_A\fC [inherited]\fP"
The system matrix for standard eigenvalue problems\&. 
.PP
Definition at line 153 of file eigen_system\&.h\&.
.PP
Referenced by libMesh::EigenSystem::clear(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::EigenSystem::reinit(), solve(), and libMesh::EigenSystem::solve()\&.
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::EigenSystem::matrix_B\fC [inherited]\fP"
A second system matrix for generalized eigenvalue problems\&. 
.PP
Definition at line 158 of file eigen_system\&.h\&.
.PP
Referenced by libMesh::EigenSystem::clear(), libMesh::EigenSystem::init_matrices(), libMesh::EigenSystem::reinit(), solve(), and libMesh::EigenSystem::solve()\&.
.SS "std::vector<\fBNumber\fP> libMesh::System::qoi\fC [inherited]\fP"
Values of the quantities of interest\&. This vector needs to be both resized and filled by the user before any quantity of interest assembly is done and before any sensitivities are calculated\&. 
.PP
Definition at line 1488 of file system\&.h\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::SensitivityData::allocate_data(), libMesh::SensitivityData::allocate_hessian_data(), libMesh::ExplicitSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi(), libMesh::ExplicitSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::DifferentiableSystem::attach_qoi(), libMesh::DiffContext::DiffContext(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::FEMContext::pre_fe_reinit(), libMesh::QoISet::size(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::System::solution\fC [inherited]\fP"
Data structure to hold solution values\&. 
.PP
Definition at line 1457 of file system\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::ContinuationSystem::apply_predictor(), libMesh::FEMSystem::assembly(), libMesh::LinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::clear(), libMesh::System::compare(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::ContinuationSystem::continuation_solve(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), DMCreateGlobalVector_libMesh(), DMlibMeshFunction(), libMesh::UnsteadySolver::du(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), get_eigenpair(), libMesh::EigenSystem::get_eigenpair(), libMesh::EquationSystems::get_solution(), libMesh::System::init_data(), libMesh::ContinuationSystem::initialize_tangent(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::ErrorVector::plot_error(), libMesh::System::project_solution(), libMesh::System::re_update(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_data(), libMesh::System::reinit(), libMesh::System::restrict_vectors(), libMesh::MemorySolutionHistory::retrieve(), libMesh::ContinuationSystem::save_current_solution(), libMesh::TwostepTimeSolver::solve(), libMesh::NewtonSolver::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::MemorySolutionHistory::store(), libMesh::System::update(), libMesh::System::update_global_solution(), libMesh::ContinuationSystem::update_solution(), libMesh::NewmarkSystem::update_u_v_a(), libMesh::System::write_parallel_data(), and libMesh::System::write_serialized_data()\&.
.SS "\fBReal\fP libMesh::System::time\fC [inherited]\fP"
For time-dependent problems, this is the time t at the beginning of the current timestep\&.
.PP
Note for \fBDifferentiableSystem\fP users: do \fInot\fP access this time during an assembly! Use the \fBDiffContext::time\fP value instead to get correct results\&. 
.PP
Definition at line 1480 of file system\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::EquationSystems::allgather(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::MemorySolutionHistory::find_stored_entry(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::System::project_vector(), libMesh::EquationSystems::reinit(), libMesh::MemorySolutionHistory::retrieve(), libMesh::TwostepTimeSolver::solve(), and libMesh::MemorySolutionHistory::store()\&.
.SS "bool libMesh::System::use_fixed_solution\fC [inherited]\fP"
A boolean to be set to true by systems using elem_fixed_solution, for optional use by e\&.g\&. stabilized methods\&. False by default\&.
.PP
Note for \fBFEMSystem\fP users: Warning: if this variable is set to true, it must be before \fBinit_data()\fP is called\&. 
.PP
Definition at line 1427 of file system\&.h\&.
.PP
Referenced by libMesh::DifferentiableSystem::clear(), libMesh::DiffContext::DiffContext(), libMesh::EulerSolver::element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::SteadySolver::element_residual(), libMesh::FEMContext::pre_fe_reinit(), libMesh::EulerSolver::side_residual(), libMesh::Euler2Solver::side_residual(), and libMesh::SteadySolver::side_residual()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
