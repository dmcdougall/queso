.TH "libMesh::UnstructuredMesh" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::UnstructuredMesh \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <unstructured_mesh\&.h>\fP
.PP
Inherits \fBlibMesh::MeshBase\fP\&.
.PP
Inherited by \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBPredicates::multi_predicate\fP \fBPredicate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBUnstructuredMesh\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "\fBUnstructuredMesh\fP (unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "virtual \fB~UnstructuredMesh\fP ()"
.br
.ti -1c
.RI "void \fBread\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL, bool skip_renumber_nodes_and_elements=false)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)"
.br
.ti -1c
.RI "virtual void \fBall_first_order\fP ()"
.br
.ti -1c
.RI "virtual void \fBall_second_order\fP (const bool full_ordered=true)"
.br
.ti -1c
.RI "void \fBcreate_pid_mesh\fP (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fP pid) const "
.br
.ti -1c
.RI "void \fBcreate_submesh\fP (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const "
.br
.ti -1c
.RI "virtual void \fBcopy_nodes_and_elements\fP (const \fBUnstructuredMesh\fP &other_mesh, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBfind_neighbors\fP (const bool reset_remote_elements=false, const bool reset_current_list=true)"
.br
.ti -1c
.RI "virtual bool \fBcontract\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBMeshBase\fP > \fBclone\fP () const =0"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBPartitioner\fP > & \fBpartitioner\fP ()"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "bool \fBis_prepared\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_serial\fP () const "
.br
.ti -1c
.RI "virtual void \fBallgather\fP ()"
.br
.ti -1c
.RI "virtual void \fBdelete_remote_elements\fP ()"
.br
.ti -1c
.RI "unsigned int \fBmesh_dimension\fP () const "
.br
.ti -1c
.RI "void \fBset_mesh_dimension\fP (unsigned int d)"
.br
.ti -1c
.RI "unsigned int \fBspatial_dimension\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_nodes\fP () const =0"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBparallel_n_nodes\fP () const =0"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_nodes_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_nodes\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_nodes\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_node_id\fP () const =0"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBnext_unique_id\fP ()"
.br
.ti -1c
.RI "void \fBset_next_unique_id\fP (\fBunique_id_type\fP id)"
.br
.ti -1c
.RI "virtual void \fBreserve_nodes\fP (const \fBdof_id_type\fP nn)=0"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_elem\fP () const =0"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBparallel_n_elem\fP () const =0"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_elem_id\fP () const =0"
.br
.ti -1c
.RI "virtual void \fBreserve_elem\fP (const \fBdof_id_type\fP ne)=0"
.br
.ti -1c
.RI "virtual void \fBupdate_parallel_id_counts\fP ()=0"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_active_elem\fP () const =0"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_sub_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_sub_elem\fP () const "
.br
.ti -1c
.RI "virtual const \fBPoint\fP & \fBpoint\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual const \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i)=0"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i)=0"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i)=0"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i)=0"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i) const =0"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i)=0"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_point\fP (const \fBPoint\fP &p, const \fBdof_id_type\fP id=\fBDofObject::invalid_id\fP, const \fBprocessor_id_type\fP proc_id=\fBDofObject::invalid_processor_id\fP)=0"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_node\fP (\fBNode\fP *n)=0"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBinsert_node\fP (\fBNode\fP *n)=0"
.br
.ti -1c
.RI "virtual void \fBdelete_node\fP (\fBNode\fP *n)=0"
.br
.ti -1c
.RI "virtual void \fBrenumber_node\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)=0"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBadd_elem\fP (\fBElem\fP *e)=0"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBinsert_elem\fP (\fBElem\fP *e)=0"
.br
.ti -1c
.RI "virtual void \fBdelete_elem\fP (\fBElem\fP *e)=0"
.br
.ti -1c
.RI "virtual void \fBrenumber_elem\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)=0"
.br
.ti -1c
.RI "virtual void \fBrenumber_nodes_and_elements\fP ()=0"
.br
.ti -1c
.RI "virtual void \fBfix_broken_node_and_element_numbering\fP ()=0"
.br
.ti -1c
.RI "void \fBprepare_for_use\fP (const bool skip_renumber_nodes_and_elements=false, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBpartition\fP (const unsigned int n_parts)"
.br
.ti -1c
.RI "void \fBpartition\fP ()"
.br
.ti -1c
.RI "virtual void \fBredistribute\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_post_partitioning\fP ()"
.br
.ti -1c
.RI "void \fBallow_renumbering\fP (bool allow)"
.br
.ti -1c
.RI "bool \fBallow_renumbering\fP () const "
.br
.ti -1c
.RI "void \fBskip_partitioning\fP (bool skip)"
.br
.ti -1c
.RI "bool \fBskip_partitioning\fP () const "
.br
.ti -1c
.RI "void \fBsubdomain_ids\fP (std::set< \fBsubdomain_id_type\fP > &ids) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBn_subdomains\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_partitions\fP () const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "unsigned int \fBrecalculate_n_partitions\fP ()"
.br
.ti -1c
.RI "const \fBPointLocatorBase\fP & \fBpoint_locator\fP () const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fBsub_point_locator\fP () const "
.br
.ti -1c
.RI "void \fBclear_point_locator\fP ()"
.br
.ti -1c
.RI "virtual void \fBlibmesh_assert_valid_parallel_ids\fP () const "
.br
.ti -1c
.RI "std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id)"
.br
.ti -1c
.RI "const std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBget_id_by_name\fP (const std::string &name) const "
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBelements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBelements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBelements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBelements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBancestor_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBancestor_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBancestor_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBancestor_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBsubactive_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBsubactive_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBsubactive_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBsubactive_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_active_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_active_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_active_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_active_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_ancestor_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_ancestor_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_ancestor_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_ancestor_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_subactive_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_subactive_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_subactive_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_subactive_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_local_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_local_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_local_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_local_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_local_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_local_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_local_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_local_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_not_local_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_not_local_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_not_local_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_not_local_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlevel_elements_end\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlevel_elements_end\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBunpartitioned_elements_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBunpartitioned_elements_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBunpartitioned_elements_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBunpartitioned_elements_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const =0"
.br
.ti -1c
.RI "virtual \fBelement_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_element_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBnodes_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBnodes_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBnodes_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBnodes_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBactive_nodes_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBactive_nodes_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBactive_nodes_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBactive_nodes_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBlocal_nodes_begin\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBlocal_nodes_begin\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBlocal_nodes_end\fP ()=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBlocal_nodes_end\fP () const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "virtual \fBnode_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id)=0"
.br
.ti -1c
.RI "virtual \fBconst_node_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id) const =0"
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBset_subdomain_name_map\fP ()"
.br
.ti -1c
.RI "const std::map
.br
< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBget_subdomain_name_map\fP () const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBBoundaryInfo\fP > \fBboundary_info\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBassign_unique_ids\fP ()=0"
.br
.ti -1c
.RI "unsigned int & \fBset_n_partitions\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "unsigned int \fB_n_parts\fP"
.br
.ti -1c
.RI "unsigned int \fB_dim\fP"
.br
.ti -1c
.RI "bool \fB_is_prepared\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fB_point_locator\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPartitioner\fP > \fB_partitioner\fP"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fB_next_unique_id\fP"
.br
.ti -1c
.RI "bool \fB_skip_partitioning\fP"
.br
.ti -1c
.RI "bool \fB_skip_renumber_nodes_and_elements\fP"
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > \fB_block_id_to_name\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBUnstructuredMesh\fP\fP class is derived from the \fC\fBMeshBase\fP\fP class\&. The user will typically want to instantiate and use the \fBMesh\fP class in her applications, which is currently a simple derived class of \fBUnstructuredMesh\fP\&. In order to use the adaptive mesh refinment capabilities of the library, first instantiate a \fBMeshRefinement\fP object with a reference to this class\&. Then call the appropriate refinement functions from that object\&. To interact with the boundary, instantiate a \fBBoundaryMesh\fP with a reference to this class, and then use that object's functionality\&. 
.PP
Definition at line 51 of file unstructured_mesh\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBPredicates::multi_predicate\fP \fBlibMesh::MeshBase::Predicate\fP\fC [inherited]\fP"
We need an empty, generic class to act as a predicate for this and derived mesh classes\&. 
.PP
Definition at line 632 of file mesh_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::UnstructuredMesh::UnstructuredMesh (const \fBParallel::Communicator\fP &comm, unsigned intdim = \fC1\fP)\fC [explicit]\fP"
Constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 84 of file unstructured_mesh\&.C\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
85                                                     :
86   MeshBase (comm,d)
87 {
88   libmesh_assert (libMesh::initialized());
89 }
.fi
.SS "libMesh::UnstructuredMesh::UnstructuredMesh (unsigned intdim = \fC1\fP)"
Deprecated constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 94 of file unstructured_mesh\&.C\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
94                                                   :
95   MeshBase (d)
96 {
97   libmesh_assert (libMesh::initialized());
98 }
.fi
.SS "libMesh::UnstructuredMesh::~UnstructuredMesh ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 240 of file unstructured_mesh\&.C\&.
.PP
References libMesh::closed()\&.
.PP
.nf
241 {
242   //  this->clear ();  // Nothing to clear at this level
243 
244   libmesh_exceptionless_assert (!libMesh::closed());
245 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::BoundaryInfo::build_side_list_from_node_list(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshTools::Modification::distort(), DMLibMeshSetSystem(), libMesh::TecplotIO::elem_dimension(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::LocationMap< T >::fill(), libMesh::MeshTools::find_boundary_nodes(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshTools::Modification::flatten(), libMesh::PointLocatorList::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::DofMap::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::CheckpointIO::n_active_levels_on_processor(), libMesh::MeshBase::n_active_sub_elem(), libMesh::System::read_legacy_data(), libMesh::GmshIO::read_mesh(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::DofMap::reinit(), libMesh::Partitioner::set_node_processor_ids(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::Tree< N >::Tree(), libMesh::MeshRefinement::uniformly_coarsen(), libMesh::MeshRefinement::uniformly_p_coarsen(), libMesh::MeshRefinement::uniformly_p_refine(), libMesh::MeshRefinement::uniformly_refine(), libMesh::FroIO::write(), libMesh::PostscriptIO::write(), libMesh::TetGenIO::write(), libMesh::MEDITIO::write_ascii(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::GmshIO::write_post(), and libMesh::GnuPlotIO::write_solution()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::BoundaryInfo::build_side_list_from_node_list(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshTools::Modification::distort(), DMLibMeshSetSystem(), libMesh::TecplotIO::elem_dimension(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::LocationMap< T >::fill(), libMesh::MeshTools::find_boundary_nodes(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshTools::Modification::flatten(), libMesh::PointLocatorList::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::DofMap::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::CheckpointIO::n_active_levels_on_processor(), libMesh::MeshBase::n_active_sub_elem(), libMesh::System::read_legacy_data(), libMesh::GmshIO::read_mesh(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::DofMap::reinit(), libMesh::Partitioner::set_node_processor_ids(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::Tree< N >::Tree(), libMesh::MeshRefinement::uniformly_coarsen(), libMesh::MeshRefinement::uniformly_p_coarsen(), libMesh::MeshRefinement::uniformly_p_refine(), libMesh::MeshRefinement::uniformly_refine(), libMesh::FroIO::write(), libMesh::PostscriptIO::write(), libMesh::TetGenIO::write(), libMesh::MEDITIO::write_ascii(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::GmshIO::write_post(), and libMesh::GnuPlotIO::write_solution()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_local_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::build_sparsity(), libMesh::System::calculate_norm(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::LaplaceMeshSmoother::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::System::local_dof_indices(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshTools::n_active_local_levels(), libMesh::ErrorVector::plot_error(), libMesh::FEMSystem::postprocess(), libMesh::System::project_vector(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::Nemesis_IO_Helper::write_exodus_initialization_info(), libMesh::EnsightIO::write_geometry_ascii(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::EnsightIO::write_vector_ascii(), and libMesh::System::zero_variable()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_local_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_local_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::build_sparsity(), libMesh::System::calculate_norm(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::LaplaceMeshSmoother::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::System::local_dof_indices(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshTools::n_active_local_levels(), libMesh::ErrorVector::plot_error(), libMesh::FEMSystem::postprocess(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::Nemesis_IO_Helper::write_exodus_initialization_info(), libMesh::EnsightIO::write_geometry_ascii(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::EnsightIO::write_vector_ascii(), and libMesh::System::zero_variable()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_local_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by DMCreateDomainDecomposition_libMesh(), and DMCreateFieldDecomposition_libMesh()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by DMCreateDomainDecomposition_libMesh(), and DMCreateFieldDecomposition_libMesh()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::active_nodes_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::active_nodes_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::active_nodes_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::active_nodes_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_not_local_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::DofMap::allgather_recursive_constraints(), and libMesh::DofMap::scatter_constraints()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_not_local_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_not_local_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::DofMap::allgather_recursive_constraints(), and libMesh::DofMap::scatter_constraints()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_not_local_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by create_pid_mesh(), libMesh::ParmetisPartitioner::initialize(), and libMesh::MeshBase::n_active_elem_on_proc()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by create_pid_mesh(), libMesh::ParmetisPartitioner::initialize(), and libMesh::MeshBase::n_active_elem_on_proc()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::TecplotIO::write_binary()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::TecplotIO::write_binary()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_type_elements_begin (const \fBElemType\fPtype)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_active_elem_of_type()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_type_elements_begin (const \fBElemType\fPtype) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::active_type_elements_end (const \fBElemType\fPtype)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_active_elem_of_type()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::active_type_elements_end (const \fBElemType\fPtype) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBElem\fP* libMesh::MeshBase::add_elem (\fBElem\fP *e)\fC [pure virtual]\fP, \fC [inherited]\fP"
Add elem \fCe\fP to the end of the element array\&. To add an element locally, set e->\fBprocessor_id()\fP before adding it\&. To ensure a specific element id, call e->set_id() before adding it; only do this in parallel if you are manually keeping ids consistent\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::MeshRefinement::add_elem(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::TriangleWrapper::copy_tri_to_mesh(), create_submesh(), libMesh::UNVIO::element_in(), libMesh::MeshTools::Modification::flatten(), libMesh::mesh_inserter_iterator< T >::operator=(), libMesh::TetGenMeshInterface::pointset_convexhull(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), and libMesh::TetGenMeshInterface::triangulate_pointset()\&.
.SS "virtual \fBNode\fP* libMesh::MeshBase::add_node (\fBNode\fP *n)\fC [pure virtual]\fP, \fC [inherited]\fP"
Add \fC\fBNode\fP\fP \fCn\fP to the end of the vertex array\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBNode\fP* libMesh::MeshBase::add_point (const \fBPoint\fP &p, const \fBdof_id_type\fPid = \fC\fBDofObject::invalid_id\fP\fP, const \fBprocessor_id_type\fPproc_id = \fC\fBDofObject::invalid_processor_id\fP\fP)\fC [pure virtual]\fP, \fC [inherited]\fP"
Add a new \fC\fBNode\fP\fP at \fC\fBPoint\fP\fP \fCp\fP to the end of the vertex array, with processor_id \fCprocid\fP\&. Use \fBDofObject::invalid_processor_id\fP (default) to add a node to all processors, or this->\fBprocessor_id()\fP to add a node to the local processor only\&. If adding a node locally, passing an \fCid\fP other than \fBDofObject::invalid_id\fP will set that specific node id\&. Only do this in parallel if you are manually keeping ids consistent\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::MeshRefinement::add_point(), all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::TriangleWrapper::copy_tri_to_mesh(), create_submesh(), libMesh::UNVIO::node_in(), libMesh::mesh_inserter_iterator< T >::operator=(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::AbaqusIO::read_nodes(), libMesh::CheckpointIO::read_nodes(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), libMesh::TriangleInterface::triangulate(), and libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole()\&.
.SS "void libMesh::UnstructuredMesh::all_first_order ()\fC [virtual]\fP"
Converts a mesh with higher-order elements into a mesh with linear elements\&. For example, a mesh consisting of \fC\fBTet10\fP\fP will be converted to a mesh with \fC\fBTet4\fP\fP etc\&. Prepare to identify (and then delete) a bunch of no-longer-used nodes\&.
.PP
Loop over the high-ordered elements\&. First make sure they \fIare\fP indeed high-order, and then replace them with an equivalent first-order element\&.
.PP
If the second order element had any boundary conditions they should be transfered to the first-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 292 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::Elem::add_child(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::delete_node(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::Elem::first_order_equivalent_type(), libMesh::Elem::get_node(), libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::libmesh_assert(), libMesh::MeshBase::max_node_id(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::Elem::replace_child(), libMesh::DofObject::set_id(), libMesh::Elem::set_neighbor(), libMesh::Elem::set_node(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Elem::set_p_level(), libMesh::Elem::set_p_refinement_flag(), libMesh::Elem::set_parent(), libMesh::Elem::set_refinement_flag(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
293 {
294   /*
295    * when the mesh is not prepared,
296    * at least renumber the nodes and
297    * elements, so that the node ids
298    * are correct
299    */
300   if (!this->_is_prepared)
301     this->renumber_nodes_and_elements ();
302 
303   START_LOG("all_first_order()", "Mesh");
304 
308   std::vector<bool> node_touched_by_me(this->max_node_id(), false);
309 
315   element_iterator endit = elements_end();
316   for (element_iterator it = elements_begin();
317        it != endit; ++it)
318     {
319       Elem* so_elem = *it;
320 
321       libmesh_assert(so_elem);
322 
323       /*
324        * build the first-order equivalent, add to
325        * the new_elements list\&.
326        */
327       Elem* lo_elem = Elem::build
328         (Elem::first_order_equivalent_type
329          (so_elem->type()), so_elem->parent())\&.release();
330 
331       for (unsigned int s=0; s != so_elem->n_sides(); ++s)
332         if (so_elem->neighbor(s) == remote_elem)
333           lo_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
334 
335 #ifdef LIBMESH_ENABLE_AMR
336       /*
337        * Reset the parent links of any child elements
338        */
339       if (so_elem->has_children())
340         for (unsigned int c=0; c != so_elem->n_children(); ++c)
341           {
342             so_elem->child(c)->set_parent(lo_elem);
343             lo_elem->add_child(so_elem->child(c), c);
344           }
345 
346       /*
347        * Reset the child link of any parent element
348        */
349       if (so_elem->parent())
350         {
351           unsigned int c =
352             so_elem->parent()->which_child_am_i(so_elem);
353           lo_elem->parent()->replace_child(lo_elem, c);
354         }
355 
356       /*
357        * Copy as much data to the new element as makes sense
358        */
359       lo_elem->set_p_level(so_elem->p_level());
360       lo_elem->set_refinement_flag(so_elem->refinement_flag());
361       lo_elem->set_p_refinement_flag(so_elem->p_refinement_flag());
362 #endif
363 
364       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
365 
366       /*
367        * By definition the vertices of the linear and
368        * second order element are identically numbered\&.
369        * transfer these\&.
370        */
371       for (unsigned int v=0; v < so_elem->n_vertices(); v++)
372         {
373           lo_elem->set_node(v) = so_elem->get_node(v);
374           node_touched_by_me[lo_elem->node(v)] = true;
375         }
376 
383       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
384 
385       for (unsigned int s=0; s<so_elem->n_sides(); s++)
386         {
387           const std::vector<boundary_id_type> boundary_ids =
388             this->boundary_info->raw_boundary_ids (so_elem, s);
389 
390           this->boundary_info->add_side (lo_elem, s, boundary_ids);
391         }
392 
393       /*
394        * The new first-order element is ready\&.
395        * Inserting it into the mesh will replace and delete
396        * the second-order element\&.
397        */
398       lo_elem->set_id(so_elem->id());
399       lo_elem->processor_id() = so_elem->processor_id();
400       lo_elem->subdomain_id() = so_elem->subdomain_id();
401       this->insert_elem(lo_elem);
402     }
403 
404   const MeshBase::node_iterator nd_end = this->nodes_end();
405   MeshBase::node_iterator nd = this->nodes_begin();
406   while (nd != nd_end)
407     {
408       Node *the_node = *nd;
409       ++nd;
410       if (!node_touched_by_me[the_node->id()])
411         this->delete_node(the_node);
412     }
413 
414   STOP_LOG("all_first_order()", "Mesh");
415 
416   // On hanging nodes that used to also be second order nodes, we
417   // might now have an invalid nodal processor_id()
418   Partitioner::set_node_processor_ids(*this);
419 
420   // delete or renumber nodes, etc
421   this->prepare_for_use(/*skip_renumber =*/ false);
422 }
.fi
.SS "void libMesh::UnstructuredMesh::all_second_order (const boolfull_ordered = \fCtrue\fP)\fC [virtual]\fP"
Converts a (conforming, non-refined) mesh with linear elements into a mesh with second-order elements\&. For example, a mesh consisting of \fC\fBTet4\fP\fP will be converted to a mesh with \fC\fBTet10\fP\fP etc\&. Note that for some elements like \fC\fBHex8\fP\fP there exist \fItwo\fP higher order equivalents, \fC\fBHex20\fP\fP and \fC\fBHex27\fP\fP\&. When \fCfull_ordered\fP is \fCtrue\fP (default), then \fC\fBHex27\fP\fP is built\&. Otherwise, \fC\fBHex20\fP\fP is built\&. The same holds obviously for \fC\fBQuad4\fP\fP, \fC\fBPrism6\fP\fP \&.\&.\&. Loop over the low-ordered elements in the \fIelements vector\&. First make sure they _are\fP indeed low-order, and then replace them with an equivalent second-order element\&. Don't forget to delete the low-order element, or else it will leak!
.PP
If the linear element had any boundary conditions they should be transfered to the second-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Also, \fBprepare_for_use()\fP will reconstruct most of our neighbor links, but if we have any remote_elem links in a distributed mesh, they need to be preserved\&. We do that in the same loop here\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 426 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::add_point(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::ParallelObject::comm(), libMesh::Elem::default_order(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::err, libMesh::FIRST, libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::DofObject::invalid_id, libMesh::MeshBase::is_serial(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::MeshBase::node(), libMesh::MeshBase::point(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Real, libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::reserve_nodes(), libMesh::Elem::second_order_equivalent_type(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube()\&.
.PP
.nf
427 {
428   // This function must be run on all processors at once
429   parallel_object_only();
430 
431   /*
432    * when the mesh is not prepared,
433    * at least renumber the nodes and
434    * elements, so that the node ids
435    * are correct
436    */
437   if (!this->_is_prepared)
438     this->renumber_nodes_and_elements ();
439 
440   /*
441    * If the mesh is empty
442    * then we have nothing to do
443    */
444   if (!this->n_elem())
445     return;
446 
447   /*
448    * If the mesh is already second order
449    * then we have nothing to do\&.
450    * We have to test for this in a round-about way to avoid
451    * a bug on distributed parallel meshes with more processors
452    * than elements\&.
453    */
454   bool already_second_order = false;
455   if (this->elements_begin() != this->elements_end() &&
456       (*(this->elements_begin()))->default_order() != FIRST)
457     already_second_order = true;
458   this->comm()\&.max(already_second_order);
459   if (already_second_order)
460     return;
461 
462   START_LOG("all_second_order()", "Mesh");
463 
464   /*
465    * this map helps in identifying second order
466    * nodes\&.  Namely, a second-order node:
467    * - edge node
468    * - face node
469    * - bubble node
470    * is uniquely defined through a set of adjacent
471    * vertices\&.  This set of adjacent vertices is
472    * used to identify already added higher-order
473    * nodes\&.  We are safe to use node id's since we
474    * make sure that these are correctly numbered\&.
475    */
476   std::map<std::vector<dof_id_type>, Node*> adj_vertices_to_so_nodes;
477 
478   /*
479    * for speed-up of the \p add_point() method, we
480    * can reserve memory\&.  Guess the number of additional
481    * nodes for different dimensions
482    */
483   switch (this->mesh_dimension())
484     {
485     case 1:
486       /*
487        * in 1D, there can only be order-increase from Edge2
488        * to Edge3\&.  Something like 1/2 of n_nodes() have
489        * to be added
490        */
491       this->reserve_nodes(static_cast<unsigned int>
492                           (1\&.5*static_cast<double>(this->n_nodes())));
493       break;
494 
495     case 2:
496       /*
497        * in 2D, either refine from Tri3 to Tri6 (double the nodes)
498        * or from Quad4 to Quad8 (again, double) or Quad9 (2\&.25 that much)
499        */
500       this->reserve_nodes(static_cast<unsigned int>
501                           (2*static_cast<double>(this->n_nodes())));
502       break;
503 
504 
505     case 3:
506       /*
507        * in 3D, either refine from Tet4 to Tet10 (factor = 2\&.5) up to
508        * Hex8 to Hex27 (something  > 3)\&.  Since in 3D there _are_ already
509        * quite some nodes, and since we do not want to overburden the memory by
510        * a too conservative guess, use the lower bound
511        */
512       this->reserve_nodes(static_cast<unsigned int>
513                           (2\&.5*static_cast<double>(this->n_nodes())));
514       break;
515 
516     default:
517       // Hm?
518       libmesh_error();
519     }
520 
521 
522 
523   /*
524    * form a vector that will hold the node id's of
525    * the vertices that are adjacent to the son-th
526    * second-order node\&.  Pull this outside of the
527    * loop so that silly compilers don't repeatedly
528    * create and destroy the vector\&.
529    */
530   std::vector<dof_id_type> adjacent_vertices_ids;
531 
538   const_element_iterator endit = elements_end();
539   for (const_element_iterator it = elements_begin();
540        it != endit; ++it)
541     {
542       // the linear-order element
543       const Elem* lo_elem = *it;
544 
545       libmesh_assert(lo_elem);
546 
547       // make sure it is linear order
548       if (lo_elem->default_order() != FIRST)
549         {
550           libMesh::err << "ERROR: This is not a linear element: type="
551                        << lo_elem->type() << std::endl;
552           libmesh_error();
553         }
554 
555       // this does _not_ work for refined elements
556       libmesh_assert_equal_to (lo_elem->level (), 0);
557 
558       /*
559        * build the second-order equivalent, add to
560        * the new_elements list\&.  Note that this here
561        * is the only point where \p full_ordered
562        * is necessary\&.  The remaining code works well
563        * for either type of seconrd-order equivalent, e\&.g\&.
564        * Hex20 or Hex27, as equivalents for Hex8
565        */
566       Elem* so_elem =
567         Elem::build (Elem::second_order_equivalent_type(lo_elem->type(),
568                                                         full_ordered) )\&.release();
569 
570       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
571 
572 
573       /*
574        * By definition the vertices of the linear and
575        * second order element are identically numbered\&.
576        * transfer these\&.
577        */
578       for (unsigned int v=0; v < lo_elem->n_vertices(); v++)
579         so_elem->set_node(v) = lo_elem->get_node(v);
580 
581       /*
582        * Now handle the additional mid-side nodes\&.  This
583        * is simply handled through a map that remembers
584        * the already-added nodes\&.  This map maps the global
585        * ids of the vertices (that uniquely define this
586        * higher-order node) to the new node\&.
587        * Notation: son = second-order node
588        */
589       const unsigned int son_begin = so_elem->n_vertices();
590       const unsigned int son_end   = so_elem->n_nodes();
591 
592 
593       for (unsigned int son=son_begin; son<son_end; son++)
594         {
595           const unsigned int n_adjacent_vertices =
596             so_elem->n_second_order_adjacent_vertices(son);
597 
598           adjacent_vertices_ids\&.resize(n_adjacent_vertices);
599 
600           for (unsigned int v=0; v<n_adjacent_vertices; v++)
601             adjacent_vertices_ids[v] =
602               so_elem->node( so_elem->second_order_adjacent_vertex(son,v) );
603 
604           /*
605            * \p adjacent_vertices_ids is now in order of the current
606            * side\&.  sort it, so that comparisons  with the
607            * \p adjacent_vertices_ids created through other elements'
608            * sides can match
609            */
610           std::sort(adjacent_vertices_ids\&.begin(),
611                     adjacent_vertices_ids\&.end());
612 
613 
614           // does this set of vertices already has a mid-node added?
615           std::pair<std::map<std::vector<dof_id_type>, Node*>::iterator,
616             std::map<std::vector<dof_id_type>, Node*>::iterator>
617             pos = adj_vertices_to_so_nodes\&.equal_range (adjacent_vertices_ids);
618 
619           // no, not added yet
620           if (pos\&.first == pos\&.second)
621             {
622               /*
623                * for this set of vertices, there is no
624                * second_order node yet\&.  Add it\&.
625                *
626                * compute the location of the new node as
627                * the average over the adjacent vertices\&.
628                */
629               Point new_location = this->point(adjacent_vertices_ids[0]);
630               for (unsigned int v=1; v<n_adjacent_vertices; v++)
631                 new_location += this->point(adjacent_vertices_ids[v]);
632 
633               new_location /= static_cast<Real>(n_adjacent_vertices);
634 
635               /* Add the new point to the mesh, giving it a globally
636                * well-defined processor id\&.
637                */
638               Node* so_node = this->add_point
639                 (new_location, DofObject::invalid_id,
640                  this->node(adjacent_vertices_ids[0])\&.processor_id());
641 
642               /*
643                * insert the new node with its defining vertex
644                * set into the map, and relocate pos to this
645                * new entry, so that the so_elem can use
646                * \p pos for inserting the node
647                */
648               adj_vertices_to_so_nodes\&.insert(pos\&.first,
649                                               std::make_pair(adjacent_vertices_ids,
650                                                              so_node));
651 
652               so_elem->set_node(son) = so_node;
653             }
654           // yes, already added\&.
655           else
656             {
657               libmesh_assert(pos\&.first->second);
658 
659               so_elem->set_node(son) = pos\&.first->second;
660             }
661         }
662 
663 
675       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
676 
677       for (unsigned int s=0; s<lo_elem->n_sides(); s++)
678         {
679           const std::vector<boundary_id_type> boundary_ids =
680             this->boundary_info->raw_boundary_ids (lo_elem, s);
681 
682           this->boundary_info->add_side (so_elem, s, boundary_ids);
683 
684           if (lo_elem->neighbor(s) == remote_elem)
685             so_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
686         }
687 
688       /*
689        * The new second-order element is ready\&.
690        * Inserting it into the mesh will replace and delete
691        * the first-order element\&.
692        */
693       so_elem->set_id(lo_elem->id());
694       so_elem->processor_id() = lo_elem->processor_id();
695       so_elem->subdomain_id() = lo_elem->subdomain_id();
696       this->insert_elem(so_elem);
697     }
698 
699   // we can clear the map
700   adj_vertices_to_so_nodes\&.clear();
701 
702 
703   STOP_LOG("all_second_order()", "Mesh");
704 
705   // In a ParallelMesh our ghost node processor ids may be bad and
706   // the ids of nodes touching remote elements may be inconsistent\&.
707   // Fix them\&.
708   if (!this->is_serial())
709     {
710       LocationMap<Node> loc_map;
711       MeshCommunication()\&.make_nodes_parallel_consistent
712         (*this, loc_map);
713     }
714 
715   // renumber nodes, elements etc
716   this->prepare_for_use(/*skip_renumber =*/ false);
717 }
.fi
.SS "virtual void libMesh::MeshBase::allgather ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Gathers all elements and nodes of the mesh onto every processor 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 140 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::MeshSerializer::MeshSerializer()\&.
.PP
.nf
140 {}
.fi
.SS "void libMesh::MeshBase::allow_renumbering (boolallow)\fC [inline]\fP, \fC [inherited]\fP"
If false is passed in then this mesh will no longer be renumbered when being prepared for use\&. This may slightly adversely affect performance during subsequent element access, particulary when using a distributed mesh\&. 
.PP
Definition at line 536 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by copy_nodes_and_elements(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::ErrorVector::plot_error()\&.
.PP
.nf
536 { _skip_renumber_nodes_and_elements = !allow; }
.fi
.SS "bool libMesh::MeshBase::allow_renumbering () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 537 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use(), and read()\&.
.PP
.nf
537 { return !_skip_renumber_nodes_and_elements; }
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::ancestor_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::ancestor_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::ancestor_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::ancestor_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual void libMesh::MeshBase::assign_unique_ids ()\fC [protected]\fP, \fC [pure virtual]\fP, \fC [inherited]\fP"
Assign globally unique IDs to all DOF objects (Elements and Nodes) if the library has been configured with unique_id support\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use()\&.
.SS "void libMesh::MeshBase::clear ()\fC [virtual]\fP, \fC [inherited]\fP"
Deletes all the data that are currently stored\&. 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Definition at line 190 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_n_parts, libMesh::MeshBase::boundary_info, and libMesh::MeshBase::clear_point_locator()\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::SerialMesh::clear(), libMesh::ParallelMesh::clear(), libMesh::TriangleWrapper::copy_tri_to_mesh(), create_submesh(), libMesh::AbaqusIO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::LegacyXdrIO::read_ascii(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), libMesh::TriangleInterface::triangulate(), and libMesh::MeshBase::~MeshBase()\&.
.PP
.nf
191 {
192   // Reset the number of partitions
193   _n_parts = 1;
194 
195   // Reset the _is_prepared flag
196   _is_prepared = false;
197 
198   // Clear boundary information
199   this->boundary_info->clear();
200 
201   // Clear our point locator\&.
202   this->clear_point_locator();
203 }
.fi
.SS "void libMesh::MeshBase::clear_point_locator ()\fC [inherited]\fP"
Releases the current \fCPointLocator\fP object\&. 
.PP
Definition at line 415 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator\&.
.PP
Referenced by libMesh::MeshBase::clear(), contract(), and libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
416 {
417   _point_locator\&.reset(NULL);
418 }
.fi
.SS "virtual \fBAutoPtr\fP<\fBMeshBase\fP> libMesh::MeshBase::clone () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Virtual 'copy constructor' 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::ErrorVector::plot_error()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "bool libMesh::UnstructuredMesh::contract ()\fC [virtual]\fP"
Delete subactive (i\&.e\&. children of coarsened) elements\&. This removes all elements descended from currently active elements in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1131 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::MeshBase::clear_point_locator(), libMesh::Elem::contract(), libMesh::MeshBase::delete_elem(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::libmesh_assert(), libMesh::Elem::parent(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::subactive()\&.
.PP
.nf
1132 {
1133   START_LOG ("contract()", "Mesh");
1134 
1135   // Flag indicating if this call actually changes the mesh
1136   bool mesh_changed = false;
1137 
1138   element_iterator in        = elements_begin();
1139   const element_iterator end = elements_end();
1140 
1141 #ifdef DEBUG
1142   for ( ; in != end; ++in)
1143     if (*in != NULL)
1144       {
1145         Elem* el = *in;
1146         libmesh_assert(el->active() || el->subactive() || el->ancestor());
1147       }
1148   in = elements_begin();
1149 #endif
1150 
1151   // Loop over the elements\&.
1152   for ( ; in != end; ++in)
1153     if (*in != NULL)
1154       {
1155         Elem* el = *in;
1156 
1157         // Delete all the subactive ones
1158         if (el->subactive())
1159           {
1160             // No level-0 element should be subactive\&.
1161             // Note that we CAN'T test elem->level(), as that
1162             // touches elem->parent()->dim(), and elem->parent()
1163             // might have already been deleted!
1164             libmesh_assert(el->parent());
1165 
1166             // Delete the element
1167             // This just sets a pointer to NULL, and doesn't
1168             // invalidate any iterators
1169             this->delete_elem(el);
1170 
1171             // the mesh has certainly changed
1172             mesh_changed = true;
1173           }
1174         else
1175           {
1176             // Compress all the active ones
1177             if (el->active())
1178               el->contract();
1179             else
1180               libmesh_assert (el->ancestor());
1181           }
1182       }
1183 
1184   // Strip any newly-created NULL voids out of the element array
1185   this->renumber_nodes_and_elements();
1186 
1187   // FIXME: Need to understand why deleting subactive children
1188   // invalidates the point locator\&.  For now we will clear it explicitly
1189   this->clear_point_locator();
1190 
1191   STOP_LOG ("contract()", "Mesh");
1192 
1193   return mesh_changed;
1194 }
.fi
.SS "void libMesh::UnstructuredMesh::copy_nodes_and_elements (const \fBUnstructuredMesh\fP &other_mesh, const boolskip_find_neighbors = \fCfalse\fP)\fC [virtual]\fP"
Deep copy of another unstructured mesh class (used by subclass copy constructors) 
.PP
Definition at line 104 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_n_parts, libMesh::Elem::add_child(), libMesh::MeshBase::allow_renumbering(), libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::Elem::n_children(), libMesh::MeshBase::n_elem(), libMesh::Elem::n_neighbors(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::MeshBase::skip_partitioning(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
Referenced by libMesh::ParallelMesh::ParallelMesh(), libMesh::SerialMesh::SerialMesh(), and libMesh::SerialMesh::stitching_helper()\&.
.PP
.nf
105 {
106   // We're assuming our subclass data needs no copy
107   libmesh_assert_equal_to (_n_parts, other_mesh\&._n_parts);
108   libmesh_assert_equal_to (_dim, other_mesh\&._dim);
109   libmesh_assert_equal_to (_is_prepared, other_mesh\&._is_prepared);
110 
111   // We're assuming the other mesh has proper element number ordering,
112   // so that we add parents before their children\&.
113 #ifdef DEBUG
114   MeshTools::libmesh_assert_valid_amr_elem_ids(other_mesh);
115 #endif
116 
117   //Copy in Nodes
118   {
119     //Preallocate Memory if necessary
120     this->reserve_nodes(other_mesh\&.n_nodes());
121 
122     const_node_iterator it = other_mesh\&.nodes_begin();
123     const_node_iterator end = other_mesh\&.nodes_end();
124 
125     for (; it != end; ++it)
126       {
127         const Node *oldn = *it;
128 
129         // Add new nodes in old node Point locations
130         /*Node *newn =*/ this->add_point(*oldn, oldn->id(), oldn->processor_id());
131 
132         // And start them off in the same subdomain
133         //        newn->processor_id() = oldn->processor_id();
134       }
135   }
136 
137   //Copy in Elements
138   {
139     //Preallocate Memory if necessary
140     this->reserve_elem(other_mesh\&.n_elem());
141 
142     // Declare a map linking old and new elements, needed to copy the neighbor lists
143     std::map<const Elem*, Elem*> old_elems_to_new_elems;
144 
145     // Loop over the elements
146     MeshBase::const_element_iterator it = other_mesh\&.elements_begin();
147     const MeshBase::const_element_iterator end = other_mesh\&.elements_end();
148 
149     // FIXME: Where do we set element IDs??
150     for (; it != end; ++it)
151       {
152         //Look at the old element
153         const Elem *old = *it;
154         //Build a new element
155         Elem *newparent = old->parent() ?
156           this->elem(old->parent()->id()) : NULL;
157         AutoPtr<Elem> ap = Elem::build(old->type(), newparent);
158         Elem * el = ap\&.release();
159 
160         el->subdomain_id() = old->subdomain_id();
161 
162         for (unsigned int s=0; s != old->n_sides(); ++s)
163           if (old->neighbor(s) == remote_elem)
164             el->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
165 
166 #ifdef LIBMESH_ENABLE_AMR
167         if (old->has_children())
168           for (unsigned int c=0; c != old->n_children(); ++c)
169             if (old->child(c) == remote_elem)
170               el->add_child(const_cast<RemoteElem*>(remote_elem), c);
171 
172         //Create the parent's child pointers if necessary
173         if (newparent)
174           {
175             unsigned int oldc = old->parent()->which_child_am_i(old);
176             newparent->add_child(el, oldc);
177           }
178 
179         // Copy the refinement flags
180         el->set_refinement_flag(old->refinement_flag());
181         el->set_p_refinement_flag(old->p_refinement_flag());
182 #endif // #ifdef LIBMESH_ENABLE_AMR
183 
184         //Assign all the nodes
185         for(unsigned int i=0;i<el->n_nodes();i++)
186           el->set_node(i) = &this->node(old->node(i));
187 
188         // And start it off in the same subdomain
189         el->processor_id() = old->processor_id();
190 
191         // Give it the same id
192         el->set_id(old->id());
193 
194         //Hold onto it
195         if(!skip_find_neighbors)
196           {
197             this->add_elem(el);
198           }
199         else
200           {
201             Elem* new_el = this->add_elem(el);
202             old_elems_to_new_elems[old] = new_el;
203           }
204 
205         // Add the link between the original element and this copy to the map
206         if(skip_find_neighbors)
207           old_elems_to_new_elems[old] = el;
208       }
209 
210     // Loop (again) over the elements to fill in the neighbors
211     if(skip_find_neighbors)
212       {
213         it = other_mesh\&.elements_begin();
214         for (; it != end; ++it)
215           {
216             Elem* old_elem = *it;
217             Elem* new_elem = old_elems_to_new_elems[old_elem];
218             for (unsigned int s=0; s != old_elem->n_neighbors(); ++s)
219               {
220                 const Elem* old_neighbor = old_elem->neighbor(s);
221                 Elem* new_neighbor = old_elems_to_new_elems[old_neighbor];
222                 new_elem->set_neighbor(s, new_neighbor);
223               }
224           }
225       }
226   }
227 
228   //Finally prepare the new Mesh for use\&.  Keep the same numbering and
229   //partitioning but also the same renumbering and partitioning
230   //policies as our source mesh\&.
231   this->allow_renumbering(false);
232   this->skip_partitioning(true);
233   this->prepare_for_use(false, skip_find_neighbors);
234   this->allow_renumbering(other_mesh\&.allow_renumbering());
235   this->skip_partitioning(other_mesh\&.skip_partitioning());
236 }
.fi
.SS "void libMesh::UnstructuredMesh::create_pid_mesh (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fPpid) const"
Generates a new mesh containing all the elements which are assigned to processor \fCpid\fP\&. This mesh is written to the pid_mesh reference which you must create and pass to the function\&. 
.PP
Definition at line 997 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), create_submesh(), libMesh::ParallelObject::n_processors(), and libMesh::out\&.
.PP
.nf
999 {
1000 
1001   // Issue a warning if the number the number of processors
1002   // currently available is less that that requested for
1003   // partitioning\&.  This is not necessarily an error since
1004   // you may run on one processor and still partition the
1005   // mesh into several partitions\&.
1006 #ifdef DEBUG
1007   if (this->n_processors() < pid)
1008     {
1009       libMesh::out << "WARNING:  You are creating a "
1010                    << "mesh for a processor id (="
1011                    << pid
1012                    << ") greater than "
1013                    << "the number of processors available for "
1014                    << "the calculation\&. (="
1015                    << this->n_processors()
1016                    << ")\&."
1017                    << std::endl;
1018     }
1019 #endif
1020 
1021   // Create iterators to loop over the list of elements
1022   //   const_active_pid_elem_iterator       it(this->elements_begin(),   pid);
1023   //   const const_active_pid_elem_iterator it_end(this->elements_end(), pid);
1024 
1025   const_element_iterator       it     = this->active_pid_elements_begin(pid);
1026   const const_element_iterator it_end = this->active_pid_elements_end(pid);
1027 
1028   this->create_submesh (pid_mesh, it, it_end);
1029 }
.fi
.SS "void libMesh::UnstructuredMesh::create_submesh (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const"
Constructs a mesh called 'new_mesh' from the current mesh by iterating over the elements between it and it_end and adding them to the new mesh\&. 
.PP
Definition at line 1037 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::add_elem(), libMesh::MeshBase::add_point(), bc_id, libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::MeshBase::clear(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::node(), libMesh::MeshBase::node_ptr(), libMesh::Elem::point(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::set_node(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by create_pid_mesh()\&.
.PP
.nf
1040 {
1041   // Just in case the subdomain_mesh already has some information
1042   // in it, get rid of it\&.
1043   new_mesh\&.clear();
1044 
1045   // Fail if (*this == new_mesh), we cannot create a submesh inside ourself!
1046   // This may happen if the user accidently passes the original mesh into
1047   // this function!  We will check this by making sure we did not just
1048   // clear ourself\&.
1049   libmesh_assert_not_equal_to (this->n_nodes(), 0);
1050   libmesh_assert_not_equal_to (this->n_elem(), 0);
1051 
1052   // How the nodes on this mesh will be renumbered to nodes
1053   // on the new_mesh\&.
1054   std::vector<dof_id_type> new_node_numbers (this->n_nodes());
1055 
1056   std::fill (new_node_numbers\&.begin(),
1057              new_node_numbers\&.end(),
1058              DofObject::invalid_id);
1059 
1060 
1061 
1062   // the number of nodes on the new mesh, will be incremented
1063   dof_id_type n_new_nodes = 0;
1064   dof_id_type n_new_elem  = 0;
1065 
1066   for (; it != it_end; ++it)
1067     {
1068       // increment the new element counter
1069       n_new_elem++;
1070 
1071       const Elem* old_elem = *it;
1072 
1073       // Add an equivalent element type to the new_mesh
1074       Elem* new_elem =
1075         new_mesh\&.add_elem (Elem::build(old_elem->type())\&.release());
1076 
1077       libmesh_assert(new_elem);
1078 
1079       // Loop over the nodes on this element\&.
1080       for (unsigned int n=0; n<old_elem->n_nodes(); n++)
1081         {
1082           libmesh_assert_less (old_elem->node(n), new_node_numbers\&.size());
1083 
1084           if (new_node_numbers[old_elem->node(n)] == DofObject::invalid_id)
1085             {
1086               new_node_numbers[old_elem->node(n)] = n_new_nodes;
1087 
1088               // Add this node to the new mesh
1089               new_mesh\&.add_point (old_elem->point(n));
1090 
1091               // Increment the new node counter
1092               n_new_nodes++;
1093             }
1094 
1095           // Define this element's connectivity on the new mesh
1096           libmesh_assert_less (new_node_numbers[old_elem->node(n)], new_mesh\&.n_nodes());
1097 
1098           new_elem->set_node(n) = new_mesh\&.node_ptr (new_node_numbers[old_elem->node(n)]);
1099         }
1100 
1101       // Copy ids for this element
1102       new_elem->subdomain_id() = old_elem->subdomain_id();
1103       new_elem->processor_id() = old_elem->processor_id();
1104 
1105       // Maybe add boundary conditions for this element
1106       for (unsigned int s=0; s<old_elem->n_sides(); s++)
1107         // We're supporting boundary ids on internal sides now
1108         //if (old_elem->neighbor(s) == NULL)
1109         {
1110           const std::vector<boundary_id_type>& bc_ids = this->boundary_info->boundary_ids(old_elem, s);
1111           for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1112             {
1113               const boundary_id_type bc_id = *id_it;
1114               if (bc_id != this->boundary_info->invalid_id)
1115                 new_mesh\&.boundary_info->add_side (new_elem,
1116                                                   s,
1117                                                   bc_id);
1118             }
1119         }
1120     } // end loop over elements
1121 
1122 
1123   // Prepare the new_mesh for use
1124   new_mesh\&.prepare_for_use(/*skip_renumber =*/false);
1125 
1126 }
.fi
.SS "virtual void libMesh::MeshBase::delete_elem (\fBElem\fP *e)\fC [pure virtual]\fP, \fC [inherited]\fP"
Removes element \fCe\fP from the mesh\&. Note that calling this method may produce isolated nodes, i\&.e\&. nodes not connected to any element\&. This method must be implemented in derived classes in such a way that it does not invalidate element iterators\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), contract(), libMesh::TetGenMeshInterface::delete_2D_hull_elements(), libMesh::MeshTools::Modification::flatten(), libMesh::TetGenMeshInterface::pointset_convexhull(), and libMesh::GmshIO::read_mesh()\&.
.SS "virtual void libMesh::MeshBase::delete_node (\fBNode\fP *n)\fC [pure virtual]\fP, \fC [inherited]\fP"
Removes the \fBNode\fP n from the mesh\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_first_order()\&.
.SS "virtual void libMesh::MeshBase::delete_remote_elements ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
When supported, deletes all nonlocal elements of the mesh except for 'ghosts' which touch a local element, and deletes all nodes which are not part of a local or ghost element 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 147 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_extrusion(), libMesh::EquationSystems::init(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::BoundaryInfo::sync(), and libMesh::MeshSerializer::~MeshSerializer()\&.
.PP
.nf
147 {}
.fi
.SS "virtual const \fBElem\fP* libMesh::MeshBase::elem (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::BoundaryInfo::add_edge(), libMesh::BoundaryInfo::add_side(), libMesh::AbaqusIO::assign_sideset_ids(), libMesh::AbaqusIO::assign_subdomain_ids(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::DofMap::elem_ptr(), libMesh::MeshData::foreign_id_to_elem(), libMesh::ErrorVector::is_active_elem(), libMesh::BoundaryInfo::operator=(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::FroIO::write(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::Nemesis_IO_Helper::write_elements(), libMesh::LegacyXdrIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), and libMesh::DivaIO::write_stream()\&.
.SS "virtual \fBElem\fP* libMesh::MeshBase::elem (const \fBdof_id_type\fPi)\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"
\fBElem\fP iterator accessor functions\&. These must be defined in Concrete base classes\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::EquationSystems::_add_system_to_nodes_and_elems(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::MeshRefinement::add_p_to_h_refinement(), libMesh::VariationalMeshSmoother::adjust_adapt_data(), all_first_order(), all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::EquationSystems::allgather(), libMesh::MeshData::assign(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::build_nodes_to_elem_map(), libMesh::MeshTools::Modification::change_subdomain_id(), libMesh::TetGenMeshInterface::check_hull_integrity(), libMesh::MeshRefinement::clean_refinement_flags(), libMesh::MeshRefinement::coarsen_elements(), libMesh::CentroidPartitioner::compute_centroids(), contract(), copy_nodes_and_elements(), libMesh::DofMap::create_dof_constraints(), libMesh::TetGenMeshInterface::delete_2D_hull_elements(), libMesh::DofMap::distribute_dofs(), libMesh::MeshTools::elem_types(), libMesh::UNVIO::element_out(), find_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshTools::get_not_subactive_node_ids(), libMesh::EquationSystems::init(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshBase::n_sub_elem(), libMesh::TetGenMeshInterface::pointset_convexhull(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::EquationSystems::reinit(), libMesh::DofMap::reinit(), libMesh::Partitioner::single_partition(), libMesh::MeshRefinement::switch_h_to_p_refinement(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::Subdivision::tag_boundary_ghosts(), libMesh::MeshTools::total_weight(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::UCDIO::write_interior_elems(), and libMesh::LegacyXdrIO::write_mesh()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"
const \fBElem\fP iterator accessor functions\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::EquationSystems::_add_system_to_nodes_and_elems(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::MeshRefinement::add_p_to_h_refinement(), libMesh::VariationalMeshSmoother::adjust_adapt_data(), all_first_order(), all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::EquationSystems::allgather(), libMesh::MeshData::assign(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::build_nodes_to_elem_map(), libMesh::MeshTools::Modification::change_subdomain_id(), libMesh::TetGenMeshInterface::check_hull_integrity(), libMesh::MeshRefinement::clean_refinement_flags(), libMesh::MeshRefinement::coarsen_elements(), libMesh::CentroidPartitioner::compute_centroids(), contract(), copy_nodes_and_elements(), libMesh::DofMap::create_dof_constraints(), libMesh::TetGenMeshInterface::delete_2D_hull_elements(), libMesh::DofMap::distribute_dofs(), libMesh::MeshTools::elem_types(), libMesh::UNVIO::element_out(), find_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshTools::get_not_subactive_node_ids(), libMesh::EquationSystems::init(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshBase::n_sub_elem(), libMesh::TetGenMeshInterface::pointset_convexhull(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::EquationSystems::reinit(), libMesh::DofMap::reinit(), libMesh::Partitioner::single_partition(), libMesh::MeshRefinement::switch_h_to_p_refinement(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::Subdivision::tag_boundary_ghosts(), libMesh::MeshTools::total_weight(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::UCDIO::write_interior_elems(), and libMesh::LegacyXdrIO::write_mesh()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "void libMesh::UnstructuredMesh::find_neighbors (const boolreset_remote_elements = \fCfalse\fP, const boolreset_current_list = \fCtrue\fP)\fC [virtual]\fP"
Other functions from \fBMeshBase\fP requiring re-definition\&. Here we look at all of the child elements which don't already have valid neighbors\&.
.PP
If a child element has a NULL neighbor it is either because it is on the boundary or because its neighbor is at a different level\&. In the latter case we must get the neighbor from the parent\&.
.PP
If a child element has a remote_elem neighbor on a boundary it shares with its parent, that info may have become out-dated through coarsening of the neighbor's parent\&. In this case, if the parent's neighbor is active then the child should share it\&.
.PP
Furthermore, that neighbor better be active, otherwise we missed a child somewhere\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 251 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::Elem::centroid(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::err, libMesh::Elem::has_children(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::Elem::is_child_on_side(), libMesh::Elem::key(), libMesh::Elem::level(), libMesh::MeshBase::level_elements_begin(), libMesh::MeshBase::level_elements_end(), libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::Elem::n_children(), libMesh::MeshTools::n_levels(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::Elem::side(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subactive(), libMesh::Elem::which_child_am_i(), and libMesh::GMVIO::write()\&.
.PP
Referenced by libMesh::TriangleWrapper::copy_tri_to_mesh()\&.
.PP
.nf
253 {
254   // We might actually want to run this on an empty mesh
255   // (e\&.g\&. the boundary mesh for a nonexistant bcid!)
256   // libmesh_assert_not_equal_to (this->n_nodes(), 0);
257   // libmesh_assert_not_equal_to (this->n_elem(), 0);
258 
259   // This function must be run on all processors at once
260   parallel_object_only();
261 
262   START_LOG("find_neighbors()", "Mesh");
263 
264   const element_iterator el_end = this->elements_end();
265 
266   //TODO:[BSK] This should be removed later?!
267   if (reset_current_list)
268     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
269       {
270         Elem* e = *el;
271         for (unsigned int s=0; s<e->n_neighbors(); s++)
272           if (e->neighbor(s) != remote_elem ||
273               reset_remote_elements)
274             e->set_neighbor(s,NULL);
275       }
276 
277   // Find neighboring elements by first finding elements
278   // with identical side keys and then check to see if they
279   // are neighbors
280   {
281     // data structures -- Use the hash_multimap if available
282     typedef unsigned int                    key_type;
283     typedef std::pair<Elem*, unsigned char> val_type;
284     typedef std::pair<key_type, val_type>   key_val_pair;
285 
286     typedef LIBMESH_BEST_UNORDERED_MULTIMAP<key_type, val_type> map_type;
287 
288     // A map from side keys to corresponding elements & side numbers
289     map_type side_to_elem_map;
290 
291 
292 
293     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
294       {
295         Elem* element = *el;
296 
297         for (unsigned int ms=0; ms<element->n_neighbors(); ms++)
298           {
299           next_side:
300             // If we haven't yet found a neighbor on this side, try\&.
301             // Even if we think our neighbor is remote, that
302             // information may be out of date\&.
303             if (element->neighbor(ms) == NULL ||
304                 element->neighbor(ms) == remote_elem)
305               {
306                 // Get the key for the side of this element
307                 const unsigned int key = element->key(ms);
308 
309                 // Look for elements that have an identical side key
310                 std::pair <map_type::iterator, map_type::iterator>
311                   bounds = side_to_elem_map\&.equal_range(key);
312 
313                 // May be multiple keys, check all the possible
314                 // elements which _might_ be neighbors\&.
315                 if (bounds\&.first != bounds\&.second)
316                   {
317                     // Get the side for this element
318                     const AutoPtr<Elem> my_side(element->side(ms));
319 
320                     // Look at all the entries with an equivalent key
321                     while (bounds\&.first != bounds\&.second)
322                       {
323                         // Get the potential element
324                         Elem* neighbor = bounds\&.first->second\&.first;
325 
326                         // Get the side for the neighboring element
327                         const unsigned int ns = bounds\&.first->second\&.second;
328                         const AutoPtr<Elem> their_side(neighbor->side(ns));
329                         //libmesh_assert(my_side\&.get());
330                         //libmesh_assert(their_side\&.get());
331 
332                         // If found a match with my side
333                         //
334                         // We need special tests here for 1D:
335                         // since parents and children have an equal
336                         // side (i\&.e\&. a node), we need to check
337                         // ns != ms, and we also check level() to
338                         // avoid setting our neighbor pointer to
339                         // any of our neighbor's descendants
340                         if( (*my_side == *their_side) &&
341                             (element->level() == neighbor->level()) &&
342                             ((_dim != 1) || (ns != ms)) )
343                           {
344                             // So share a side\&.  Is this a mixed pair
345                             // of subactive and active/ancestor
346                             // elements?
347                             // If not, then we're neighbors\&.
348                             // If so, then the subactive's neighbor is
349 
350                             if (element->subactive() ==
351                                 neighbor->subactive())
352                               {
353                                 // an element is only subactive if it has
354                                 // been coarsened but not deleted
355                                 element->set_neighbor (ms,neighbor);
356                                 neighbor->set_neighbor(ns,element);
357                               }
358                             else if (element->subactive())
359                               {
360                                 element->set_neighbor(ms,neighbor);
361                               }
362                             else if (neighbor->subactive())
363                               {
364                                 neighbor->set_neighbor(ns,element);
365                               }
366                             side_to_elem_map\&.erase (bounds\&.first);
367 
368                             // get out of this nested crap
369                             goto next_side;
370                           }
371 
372                         ++bounds\&.first;
373                       }
374                   }
375 
376                 // didn't find a match\&.\&.\&.
377                 // Build the map entry for this element
378                 key_val_pair kvp;
379 
380                 kvp\&.first         = key;
381                 kvp\&.second\&.first  = element;
382                 kvp\&.second\&.second = ms;
383 
384                 // use the lower bound as a hint for
385                 // where to put it\&.
386 #if defined(LIBMESH_HAVE_UNORDERED_MAP) || defined(LIBMESH_HAVE_TR1_UNORDERED_MAP) || defined(LIBMESH_HAVE_HASH_MAP) || defined(LIBMESH_HAVE_EXT_HASH_MAP)
387                 side_to_elem_map\&.insert (kvp);
388 #else
389                 side_to_elem_map\&.insert (bounds\&.first,kvp);
390 #endif
391               }
392           }
393       }
394   }
395 
396 #ifdef LIBMESH_ENABLE_AMR
397 
418   const unsigned int n_levels = MeshTools::n_levels(*this);
419   for (unsigned int level = 1; level < n_levels; ++level)
420     {
421       element_iterator end = this->level_elements_end(level);
422       for (element_iterator el = this->level_elements_begin(level);
423            el != end; ++el)
424         {
425           Elem* current_elem = *el;
426           libmesh_assert(current_elem);
427           Elem* parent = current_elem->parent();
428           libmesh_assert(parent);
429           const unsigned int my_child_num = parent->which_child_am_i(current_elem);
430 
431           for (unsigned int s=0; s < current_elem->n_neighbors(); s++)
432             {
433               if (current_elem->neighbor(s) == NULL ||
434                   (current_elem->neighbor(s) == remote_elem &&
435                    parent->is_child_on_side(my_child_num, s)))
436                 {
437                   Elem *neigh = parent->neighbor(s);
438 
439                   // If neigh was refined and had non-subactive children
440                   // made remote earlier, then a non-subactive elem should
441                   // actually have one of those remote children as a
442                   // neighbor
443                   if (neigh && (neigh->ancestor()) && (!current_elem->subactive()))
444                     {
445 #ifdef DEBUG
446                       // Let's make sure that "had children made remote"
447                       // situation is actually the case
448                       libmesh_assert(neigh->has_children());
449                       bool neigh_has_remote_children = false;
450                       for (unsigned int c = 0; c != neigh->n_children(); ++c)
451                         {
452                           if (neigh->child(c) == remote_elem)
453                             neigh_has_remote_children = true;
454                         }
455                       libmesh_assert(neigh_has_remote_children);
456 
457                       // And let's double-check that we don't have
458                       // a remote_elem neighboring a local element
459                       libmesh_assert_not_equal_to (current_elem->processor_id(),
460                                                    this->processor_id());
461 #endif // DEBUG
462                       neigh = const_cast<RemoteElem*>(remote_elem);
463                     }
464 
465                   current_elem->set_neighbor(s, neigh);
466 #ifdef DEBUG
467                   if (neigh != NULL && neigh != remote_elem)
468                     // We ignore subactive elements here because
469                     // we don't care about neighbors of subactive element\&.
470                     if ((!neigh->active()) && (!current_elem->subactive()))
471                       {
472                         libMesh::err << "On processor " << this->processor_id()
473                                      << std::endl;
474                         libMesh::err << "Bad element ID = " << current_elem->id()
475                                      << ", Side " << s << ", Bad neighbor ID = " << neigh->id() << std::endl;
476                         libMesh::err << "Bad element proc_ID = " << current_elem->processor_id()
477                                      << ", Bad neighbor proc_ID = " << neigh->processor_id() << std::endl;
478                         libMesh::err << "Bad element size = " << current_elem->hmin()
479                                      << ", Bad neighbor size = " << neigh->hmin() << std::endl;
480                         libMesh::err << "Bad element center = " << current_elem->centroid()
481                                      << ", Bad neighbor center = " << neigh->centroid() << std::endl;
482                         libMesh::err << "ERROR: "
483                                      << (current_elem->active()?"Active":"Ancestor")
484                                      << " Element at level "
485                                      << current_elem->level() << std::endl;
486                         libMesh::err << "with "
487                                      << (parent->active()?"active":
488                                          (parent->subactive()?"subactive":"ancestor"))
489                                      << " parent share "
490                                      << (neigh->subactive()?"subactive":"ancestor")
491                                      << " neighbor at level " << neigh->level()
492                                      << std::endl;
493                         GMVIO(*this)\&.write ("bad_mesh\&.gmv");
494                         libmesh_error();
495                       }
496 #endif // DEBUG
497                 }
498             }
499         }
500     }
501 
502 #endif // AMR
503 
504 
505 #ifdef DEBUG
506   MeshTools::libmesh_assert_valid_neighbors(*this);
507 #endif
508 
509   STOP_LOG("find_neighbors()", "Mesh");
510 }
.fi
.SS "virtual void libMesh::MeshBase::fix_broken_node_and_element_numbering ()\fC [pure virtual]\fP, \fC [inherited]\fP"
There is no reason for a user to ever call this function\&.
.PP
This function restores a previously broken element/node numbering such that \fCmesh\&.node(n)->id()\fP == n\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::EquationSystems::_read_impl()\&.
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::get_id_by_name (const std::string &name) const\fC [inherited]\fP"
Returns a the id of the requested block by name\&. Throws an error if a block by name is not found 
.PP
Definition at line 442 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name, and libMesh::err\&.
.PP
.nf
443 {
444   // This function is searching the *values* of the map (linear search)
445   // We might want to make this more efficient\&.\&.\&.
446   std::map<subdomain_id_type, std::string>::const_iterator
447     iter = _block_id_to_name\&.begin(),
448     end_iter = _block_id_to_name\&.end();
449 
450   for ( ; iter != end_iter; ++iter)
451     {
452       if (iter->second == name)
453         return iter->first;
454     }
455 
456   libMesh::err << "Block '" << name << "' does not exist in mesh" << std::endl;
457   libmesh_error();
458 }
.fi
.SS "std::string libMesh::MeshBase::get_info () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a string containing relevant information about the mesh\&. 
.RE
.PP

.PP
Definition at line 306 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_active_elem(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::MeshBase::n_nodes(), libMesh::MeshBase::n_partitions(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::n_subdomains(), libMesh::n_threads, libMesh::ParallelObject::processor_id(), and libMesh::MeshBase::spatial_dimension()\&.
.PP
Referenced by libMesh::MeshBase::print_info()\&.
.PP
.nf
307 {
308   std::ostringstream oss;
309 
310   oss << " Mesh Information:"                                  << '\n'
311       << "  mesh_dimension()="    << this->mesh_dimension()    << '\n'
312       << "  spatial_dimension()=" << this->spatial_dimension() << '\n'
313       << "  n_nodes()="           << this->n_nodes()           << '\n'
314       << "    n_local_nodes()="   << this->n_local_nodes()     << '\n'
315       << "  n_elem()="            << this->n_elem()            << '\n'
316       << "    n_local_elem()="    << this->n_local_elem()      << '\n'
317 #ifdef LIBMESH_ENABLE_AMR
318       << "    n_active_elem()="   << this->n_active_elem()     << '\n'
319 #endif
320       << "  n_subdomains()="      << static_cast<std::size_t>(this->n_subdomains()) << '\n'
321       << "  n_partitions()="      << static_cast<std::size_t>(this->n_partitions()) << '\n'
322       << "  n_processors()="      << static_cast<std::size_t>(this->n_processors()) << '\n'
323       << "  n_threads()="         << static_cast<std::size_t>(libMesh::n_threads()) << '\n'
324       << "  processor_id()="      << static_cast<std::size_t>(this->processor_id()) << '\n';
325 
326   return oss\&.str();
327 }
.fi
.SS "const std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::get_subdomain_name_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 843 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::write_serialized_subdomain_names(), and libMesh::CheckpointIO::write_subdomain_names()\&.
.PP
.nf
844   { return _block_id_to_name; }
.fi
.SS "virtual \fBElem\fP* libMesh::MeshBase::insert_elem (\fBElem\fP *e)\fC [pure virtual]\fP, \fC [inherited]\fP"
Insert elem \fCe\fP to the element array, preserving its id and replacing/deleting any existing element with the same id\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_first_order(), all_second_order(), and libMesh::MeshTools::Subdivision::all_subdivision()\&.
.SS "virtual \fBNode\fP* libMesh::MeshBase::insert_node (\fBNode\fP *n)\fC [pure virtual]\fP, \fC [inherited]\fP"
Insert \fC\fBNode\fP\fP \fCn\fP into the \fBMesh\fP at a location consistent with n->id(), allocating extra storage if necessary\&. Will error rather than overwriting an existing \fBNode\fP\&. Primarily intended for use with the \fBmesh_inserter_iterator\fP, only use if you know what you are doing\&.\&.\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::mesh_inserter_iterator< T >::operator=()\&.
.SS "bool libMesh::MeshBase::is_prepared () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the mesh has been prepared via a call to \fCprepare_for_use\fP, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 126 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_is_prepared\&.
.PP
Referenced by libMesh::DofMap::build_sparsity(), libMesh::DofMap::create_dof_constraints(), libMesh::DofMap::distribute_dofs(), and libMesh::DofMap::reinit()\&.
.PP
.nf
127   { return _is_prepared; }
.fi
.SS "virtual bool libMesh::MeshBase::is_serial () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if all elements and nodes of the mesh exist on the current processor, \fCfalse\fP otherwise 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 133 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MetisPartitioner::_do_partition(), libMesh::MeshRefinement::_refine_elements(), all_second_order(), libMesh::EquationSystems::allgather(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshRefinement::coarsen_elements(), libMesh::DofMap::create_dof_constraints(), libMesh::LocationMap< T >::init(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshSerializer::MeshSerializer(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshBase::partition(), libMesh::MeshBase::prepare_for_use(), libMesh::DofMap::process_constraints(), libMesh::Nemesis_IO::read(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::EquationSystems::write(), libMesh::LegacyXdrIO::write_mesh(), and libMesh::XdrIO::write_parallel()\&.
.PP
.nf
134   { return true; }
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::level_elements_begin (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Modification::change_boundary_id(), find_neighbors(), libMesh::MeshRefinement::make_coarsening_compatible(), and libMesh::MeshTools::Modification::smooth()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::level_elements_begin (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::level_elements_end (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Modification::change_boundary_id(), find_neighbors(), libMesh::MeshRefinement::make_coarsening_compatible(), and libMesh::MeshTools::Modification::smooth()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::level_elements_end (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual void libMesh::MeshBase::libmesh_assert_valid_parallel_ids () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Verify id and processor_id consistency of our elements and nodes containers\&. Calls \fBlibmesh_assert()\fP on each possible failure\&. Currently only implemented on \fBParallelMesh\fP; a serial data structure is much harder to get out of sync\&. 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 692 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_refine_elements(), libMesh::InfElemBuilder::build_inf_elem(), and libMesh::MeshRefinement::refine_and_coarsen_elements()\&.
.PP
.nf
692 {}
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::assign_global_indices(), libMesh::DofMap::create_dof_constraints(), libMesh::EquationSystems::get_solution(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshTools::n_local_levels(), and libMesh::MeshTools::n_p_levels()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::assign_global_indices(), libMesh::DofMap::create_dof_constraints(), libMesh::EquationSystems::get_solution(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshTools::n_local_levels(), libMesh::MeshTools::n_p_levels(), and libMesh::XdrIO::write_serialized_connectivity()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_level_elements_begin (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::XdrIO::write_serialized_connectivity()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_level_elements_begin (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_level_elements_end (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::XdrIO::write_serialized_connectivity()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_level_elements_end (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::local_nodes_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::bounding_box(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::VTKIO::nodes_to_vtk(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::System::zero_variable()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::local_nodes_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::local_nodes_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::bounding_box(), libMesh::EquationSystems::build_solution_vector(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::VTKIO::nodes_to_vtk(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::System::zero_variable()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::local_nodes_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_not_level_elements_begin (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_not_level_elements_begin (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::local_not_level_elements_end (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::local_not_level_elements_end (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::max_elem_id () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns a number greater than or equal to the maximum element id in the mesh\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::EquationSystems::get_solution(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), and libMesh::ErrorVector::plot_error()\&.
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::max_node_id () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns a number greater than or equal to the maximum node id in the mesh\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::DofMap::add_neighbors_to_send_list(), all_first_order(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::EquationSystems::build_solution_vector(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::ErrorVector::plot_error(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.SS "unsigned int libMesh::MeshBase::mesh_dimension () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the logical dimension of the mesh; i\&.e\&. the manifold dimension of the elements in the mesh\&. If we ever support multi-dimensional meshes (e\&.g\&. hexes and quads in the same mesh) then this will return the largest such dimension\&. 
.RE
.PP

.PP
Definition at line 155 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), all_second_order(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::EquationSystems::build_variable_names(), libMesh::System::calculate_norm(), libMesh::DofMap::create_dof_constraints(), libMesh::MeshTools::Modification::distort(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshBase::get_info(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::LaplaceMeshSmoother::init(), libMesh::PointLocatorTree::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::FEInterface::n_vec_dim(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::MeshFunction::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::System::read_header(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshTools::Modification::rotate(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshTools::Modification::smooth(), libMesh::BoundaryInfo::sync(), libMesh::DofMap::use_coupled_neighbor_dofs(), libMesh::PostscriptIO::write(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::UCDIO::write_nodal_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
156   { return static_cast<unsigned int>(_dim); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::n_active_elem () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns the number of active elements in the mesh\&. Implemented in terms of active_element_iterators\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshBase::get_info(), libMesh::PointLocatorList::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::Partitioner::partition(), libMesh::Partitioner::repartition(), libMesh::VariationalMeshSmoother::smooth(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), and libMesh::GnuPlotIO::write_solution()\&.
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of active elements on processor \fCproc\fP\&. 
.PP
Definition at line 267 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), and libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::n_active_local_elem()\&.
.PP
.nf
268 {
269   libmesh_assert_less (proc_id, this->n_processors());
270   return static_cast<dof_id_type>(std::distance (this->active_pid_elements_begin(proc_id),
271                                                  this->active_pid_elements_end  (proc_id)));
272 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of active elements on the local processor\&. 
.PP
Definition at line 300 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_active_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParmetisPartitioner::build_graph(), libMesh::VTKIO::cells_to_vtk(), and libMesh::ParmetisPartitioner::initialize()\&.
.PP
.nf
301   { return this->n_active_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_sub_elem () const\fC [inherited]\fP"
Same, but only counts active elements\&. 
.PP
Definition at line 291 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), and end\&.
.PP
Referenced by libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_old_impl(), and libMesh::TecplotIO::write_binary()\&.
.PP
.nf
292 {
293   dof_id_type ne=0;
294 
295   const_element_iterator       el  = this->active_elements_begin();
296   const const_element_iterator end = this->active_elements_end();
297 
298   for (; el!=end; ++el)
299     ne += (*el)->n_sub_elem();
300 
301   return ne;
302 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::n_elem () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns the number of elements in the mesh\&. The standard \fBn_elem()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::SFCPartitioner::_do_partition(), libMesh::CentroidPartitioner::_do_partition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshTools::build_nodes_to_elem_map(), libMesh::TetGenMeshInterface::check_hull_integrity(), libMesh::CentroidPartitioner::compute_centroids(), copy_nodes_and_elements(), create_submesh(), libMesh::MeshTools::Modification::distort(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::get_solution(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ErrorVector::plot_error(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshTools::Modification::redistribute(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::FroIO::write(), libMesh::TetGenIO::write(), libMesh::XdrIO::write(), libMesh::UNVIO::write_implementation(), libMesh::LegacyXdrIO::write_mesh(), libMesh::UCDIO::write_nodal_data(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_vectors(), and libMesh::DivaIO::write_stream()\&.
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of elements on processor \fCproc\fP\&. 
.PP
Definition at line 254 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_elements_begin(), and libMesh::MeshBase::pid_elements_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_elem(), and libMesh::MeshBase::n_unpartitioned_elem()\&.
.PP
.nf
255 {
256   // We're either counting a processor's elements or unpartitioned
257   // elements
258   libmesh_assert (proc_id < this->n_processors() ||
259                   proc_id == DofObject::invalid_processor_id);
260 
261   return static_cast<dof_id_type>(std::distance (this->pid_elements_begin(proc_id),
262                                                  this->pid_elements_end  (proc_id)));
263 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements on the local processor\&. 
.PP
Definition at line 283 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), and libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
284   { return this->n_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes on the local processor\&. 
.PP
Definition at line 197 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_nodes_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::VTKIO::nodes_to_vtk(), and libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
198   { return this->n_nodes_on_proc (this->processor_id()); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::n_nodes () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The standard \fBn_nodes()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::build_nodes_to_elem_map(), libMesh::EquationSystems::build_solution_vector(), copy_nodes_and_elements(), create_submesh(), libMesh::MeshTools::Modification::distort(), libMesh::TetGenMeshInterface::fill_pointlist(), libMesh::MeshTools::find_boundary_nodes(), libMesh::MeshBase::get_info(), libMesh::LaplaceMeshSmoother::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::TreeNode< N >::insert(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::ErrorVector::plot_error(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshTools::Modification::redistribute(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::VariationalMeshSmoother::smooth(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::VTKIO::system_vectors_to_vtk(), libMesh::TreeNode< N >::transform_nodes_to_elements(), libMesh::MeshData::translate(), libMesh::TriangleInterface::triangulate(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::FroIO::write(), libMesh::TetGenIO::write(), libMesh::XdrIO::write(), libMesh::MEDITIO::write_ascii(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::UCDIO::write_header(), libMesh::UNVIO::write_implementation(), libMesh::GmshIO::write_mesh(), libMesh::VTKIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::GmshIO::write_post(), libMesh::XdrIO::write_serialized_nodes(), libMesh::System::write_serialized_vectors(), libMesh::UCDIO::write_soln(), libMesh::LegacyXdrIO::write_soln(), libMesh::DivaIO::write_stream(), and libMesh::VariationalMeshSmoother::writegr()\&.
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_nodes_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of nodes on processor \fCproc\fP\&. 
.PP
Definition at line 241 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_nodes_begin(), and libMesh::MeshBase::pid_nodes_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_nodes(), and libMesh::MeshBase::n_unpartitioned_nodes()\&.
.PP
.nf
242 {
243   // We're either counting a processor's nodes or unpartitioned
244   // nodes
245   libmesh_assert (proc_id < this->n_processors() ||
246                   proc_id == DofObject::invalid_processor_id);
247 
248   return static_cast<dof_id_type>(std::distance (this->pid_nodes_begin(proc_id),
249                                                  this->pid_nodes_end  (proc_id)));
250 }
.fi
.SS "unsigned int libMesh::MeshBase::n_partitions () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of partitions which have been defined via a call to either mesh\&.partition() or by building a \fBPartitioner\fP object and calling partition\&. Note that the partitioner objects are responsible for setting this value\&. 
.PP
Definition at line 578 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::Partitioner::set_node_processor_ids(), libMesh::BoundaryInfo::sync(), write(), libMesh::GMVIO::write_ascii_new_impl(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.PP
.nf
579   { return _n_parts; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_sub_elem () const\fC [inherited]\fP"
This function returns the number of elements that will be written out in the Tecplot format\&. For example, a 9-noded quadrilateral will be broken into 4 linear sub-elements for plotting purposes\&. Thus, for a mesh of 2 \fCQUAD9\fP elements \fCn_tecplot_elem()\fP will return 8\&. Implemented in terms of element_iterators\&. 
.PP
Definition at line 276 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), and end\&.
.PP
.nf
277 {
278   dof_id_type ne=0;
279 
280   const_element_iterator       el  = this->elements_begin();
281   const const_element_iterator end = this->elements_end();
282 
283   for (; el!=end; ++el)
284     ne += (*el)->n_sub_elem();
285 
286   return ne;
287 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::n_subdomains () const\fC [inherited]\fP"
Returns the number of subdomains in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 226 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::subdomain_ids()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::XdrIO::write(), and write()\&.
.PP
.nf
227 {
228   // This requires an inspection on every processor
229   parallel_object_only();
230 
231   std::set<subdomain_id_type> ids;
232 
233   this->subdomain_ids (ids);
234 
235   return ids\&.size();
236 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements owned by no processor\&. 
.PP
Definition at line 289 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_elem_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
290   { return this->n_elem_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes owned by no processor\&. 
.PP
Definition at line 203 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_nodes_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
204   { return this->n_nodes_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBunique_id_type\fP libMesh::MeshBase::next_unique_id ()\fC [inline]\fP, \fC [inherited]\fP"
Returns the next unique id to be used\&. 
.PP
Definition at line 216 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
216 { return _next_unique_id; }
.fi
.SS "virtual const \fBNode\fP& libMesh::MeshBase::node (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::GmshIO::write_mesh(), and libMesh::LegacyXdrIO::write_mesh()\&.
.SS "virtual \fBNode\fP& libMesh::MeshBase::node (const \fBdof_id_type\fPi)\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a reference to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual const \fBNode\fP* libMesh::MeshBase::node_ptr (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::SyncNodalPositions::act_on_data(), libMesh::BoundaryInfo::add_node(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::AbaqusIO::assign_boundary_node_ids(), libMesh::TetGenMeshInterface::assign_nodes_to_elem(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::TriangleWrapper::copy_tri_to_mesh(), create_submesh(), libMesh::MeshTools::Modification::distort(), libMesh::UNVIO::element_in(), libMesh::MeshData::foreign_id_to_node(), libMesh::SyncNodalPositions::gather_data(), libMesh::DofMap::node_ptr(), libMesh::BoundaryInfo::operator=(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::DofMap::scatter_constraints(), libMesh::Partitioner::set_node_processor_ids(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::Nemesis_IO_Helper::write_nodal_coordinates()\&.
.SS "virtual \fBNode\fP* libMesh::MeshBase::node_ptr (const \fBdof_id_type\fPi)\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::nodes_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"
non-const \fBNode\fP iterator accessor functions\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::EquationSystems::_add_system_to_nodes_and_elems(), all_first_order(), libMesh::EquationSystems::allgather(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_extrusion(), copy_nodes_and_elements(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::DofMap::distribute_dofs(), libMesh::LocationMap< T >::fill(), libMesh::TetGenMeshInterface::fill_pointlist(), libMesh::LocationMap< T >::init(), libMesh::EquationSystems::init(), libMesh::DofMap::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::FEMSystem::mesh_position_set(), libMesh::UNVIO::node_out(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::System::read_legacy_data(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshTools::Modification::redistribute(), libMesh::EquationSystems::reinit(), libMesh::DofMap::reinit(), libMesh::MeshTools::Modification::rotate(), libMesh::MeshTools::Modification::scale(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Partitioner::single_partition(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::Modification::translate(), libMesh::MeshData::translate(), libMesh::Tree< N >::Tree(), libMesh::TriangleInterface::triangulate(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodes(), libMesh::CheckpointIO::write_nodes(), and libMesh::VariationalMeshSmoother::writegr()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::nodes_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"
const \fBNode\fP iterator accessor functions\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::nodes_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::EquationSystems::_add_system_to_nodes_and_elems(), all_first_order(), libMesh::EquationSystems::allgather(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_extrusion(), copy_nodes_and_elements(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::DofMap::distribute_dofs(), libMesh::LocationMap< T >::fill(), libMesh::TetGenMeshInterface::fill_pointlist(), libMesh::LocationMap< T >::init(), libMesh::EquationSystems::init(), libMesh::DofMap::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::FEMSystem::mesh_position_set(), libMesh::UNVIO::node_out(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::System::read_legacy_data(), libMesh::VariationalMeshSmoother::readgr(), libMesh::MeshTools::Modification::redistribute(), libMesh::EquationSystems::reinit(), libMesh::DofMap::reinit(), libMesh::MeshTools::Modification::rotate(), libMesh::MeshTools::Modification::scale(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Partitioner::single_partition(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::Modification::translate(), libMesh::MeshData::translate(), libMesh::Tree< N >::Tree(), libMesh::TriangleInterface::triangulate(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodes(), libMesh::CheckpointIO::write_nodes(), and libMesh::VariationalMeshSmoother::writegr()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::nodes_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_active_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_active_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_active_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_active_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_ancestor_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_ancestor_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_ancestor_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_ancestor_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_level_elements_begin (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_level_elements_begin (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_level_elements_end (const unsigned intlevel)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_level_elements_end (const unsigned intlevel) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_local_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_local_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_local_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_local_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_subactive_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_subactive_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::not_subactive_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::not_subactive_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::parallel_n_elem () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns the number of elements in the mesh\&. The \fBparallel_n_elem()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "virtual \fBdof_id_type\fP libMesh::MeshBase::parallel_n_nodes () const\fC [pure virtual]\fP, \fC [inherited]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The \fBparallel_n_nodes()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Nemesis_IO_Helper::initialize(), and libMesh::Nemesis_IO::read()\&.
.SS "void libMesh::MeshBase::partition (const unsigned intn_parts)\fC [virtual]\fP, \fC [inherited]\fP"
Call the default partitioner (currently \fCmetis_partition()\fP)\&. 
.PP
Definition at line 344 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::is_serial(), libMesh::MeshBase::partitioner(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshBase::skip_partitioning(), and libMesh::MeshBase::update_post_partitioning()\&.
.PP
.nf
345 {
346   // NULL partitioner means don't partition
347   // Non-serial meshes aren't ready for partitioning yet\&.
348   if(!skip_partitioning() &&
349      partitioner()\&.get() &&
350      this->is_serial())
351     {
352       partitioner()->partition (*this, n_parts);
353     }
354   else
355     {
356       // Make sure locally cached partition count
357       this->recalculate_n_partitions();
358 
359       // Make sure any other locally cached data is correct
360       this->update_post_partitioning();
361     }
362 }
.fi
.SS "void libMesh::MeshBase::partition ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 514 of file mesh_base\&.h\&.
.PP
References libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
515   { this->partition(this->n_processors()); }
.fi
.SS "virtual \fBAutoPtr\fP<\fBPartitioner\fP>& libMesh::MeshBase::partitioner ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP 
.PP
Definition at line 115 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_partitioner\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshBase::partition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
115 { return _partitioner; }
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshTools::processor_bounding_box(), libMesh::BoundaryInfo::sync(), and libMesh::MeshTools::weight()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshTools::processor_bounding_box(), libMesh::BoundaryInfo::sync(), and libMesh::MeshTools::weight()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::bounding_box(), and libMesh::MeshBase::n_nodes_on_proc()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBnode_iterator\fP libMesh::MeshBase::pid_nodes_end (const \fBprocessor_id_type\fPproc_id)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::bounding_box(), and libMesh::MeshBase::n_nodes_on_proc()\&.
.SS "virtual \fBconst_node_iterator\fP libMesh::MeshBase::pid_nodes_end (const \fBprocessor_id_type\fPproc_id) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual const \fBPoint\fP& libMesh::MeshBase::point (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ point, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_second_order(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::FroIO::write(), libMesh::TetGenIO::write(), libMesh::MEDITIO::write_ascii(), libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GnuPlotIO::write_solution(), and libMesh::DivaIO::write_stream()\&.
.SS "const \fBPointLocatorBase\fP & libMesh::MeshBase::point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should never be used in threaded or non-parallel_only code, and so is deprecated\&. 
.PP
Definition at line 384 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
.nf
385 {
386   libmesh_deprecated();
387 
388   if (_point_locator\&.get() == NULL)
389     {
390       // PointLocator construction may not be safe within threads
391       libmesh_assert(!Threads::in_threads);
392 
393       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
394     }
395 
396   return *_point_locator;
397 }
.fi
.SS "void libMesh::MeshBase::prepare_for_use (const boolskip_renumber_nodes_and_elements = \fCfalse\fP, const boolskip_find_neighbors = \fCfalse\fP)\fC [inherited]\fP"
Prepare a newly created (or read) mesh for use\&. This involves 3 steps: 1\&.) call \fC\fBfind_neighbors()\fP\fP 2\&.) call \fC\fBpartition()\fP\fP 3\&.) call \fC\fBrenumber_nodes_and_elements()\fP\fP 
.PP
The argument to skip renumbering is now deprecated - to prevent a mesh from being renumbered, set allow_renumbering(false)\&. 
.PP
Definition at line 120 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_skip_renumber_nodes_and_elements, libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::assign_unique_ids(), libMesh::MeshBase::clear_point_locator(), libMesh::ParallelObject::comm(), libMesh::MeshBase::delete_remote_elements(), libMesh::dim, libMesh::MeshBase::find_neighbors(), libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::partition(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::set_mesh_dimension(), libMesh::MeshBase::update_parallel_id_counts(), and libMesh::Parallel::verify()\&.
.PP
Referenced by all_first_order(), all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshRefinement::coarsen_elements(), create_submesh(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::GMVIO::read(), read(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::MeshRefinement::uniformly_coarsen(), and libMesh::MeshRefinement::uniformly_refine()\&.
.PP
.nf
121 {
122   parallel_object_only();
123 
124   // A distributed mesh may have processors with no elements (or
125   // processors with no elements of higher dimension, if we ever
126   // support mixed-dimension meshes), but we want consistent
127   // mesh_dimension anyways\&.
128   libmesh_assert(this->comm()\&.verify(this->is_serial()));
129 
130   if (!this->is_serial())
131     {
132       unsigned int dim = this->mesh_dimension();
133       this->comm()\&.max(dim);
134       this->set_mesh_dimension(dim);
135     }
136 
137   // Renumber the nodes and elements so that they in contiguous
138   // blocks\&.  By default, _skip_renumber_nodes_and_elements is false\&.
139   //
140   // We may currently change that by passing
141   // skip_renumber_nodes_and_elements==true to this function, but we
142   // should use the allow_renumbering() accessor instead\&.
143   //
144   // Instances where you if prepare_for_use() should not renumber the nodes
145   // and elements include reading in e\&.g\&. an xda/r or gmv file\&. In
146   // this case, the ordering of the nodes may depend on an accompanying
147   // solution, and the node ordering cannot be changed\&.
148 
149   if (skip_renumber_nodes_and_elements)
150     {
151       libmesh_deprecated();
152       this->allow_renumbering(false);
153     }
154 
155   // Mesh modification operations might not leave us with consistent
156   // id counts, but our partitioner might need that consistency\&.
157   if(!_skip_renumber_nodes_and_elements)
158     this->renumber_nodes_and_elements();
159   else
160     this->update_parallel_id_counts();
161 
162   // Let all the elements find their neighbors
163   if(!skip_find_neighbors)
164     this->find_neighbors();
165 
166   // Partition the mesh\&.
167   this->partition();
168 
169   // If we're using ParallelMesh, we'll want it parallelized\&.
170   this->delete_remote_elements();
171 
172 #ifdef LIBMESH_ENABLE_UNIQUE_ID
173   // Assign DOF object unique ids
174   this->assign_unique_ids();
175 #endif
176 
177   if(!_skip_renumber_nodes_and_elements)
178     this->renumber_nodes_and_elements();
179 
180   // Reset our PointLocator\&.  This needs to happen any time the elements
181   // in the underlying elements in the mesh have changed, so we do it here\&.
182   this->clear_point_locator();
183 
184   // The mesh is now prepared for use\&.
185   _is_prepared = true;
186 }
.fi
.SS "void libMesh::MeshBase::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Prints relevant information about the mesh\&. 
.PP
Definition at line 330 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::get_info()\&.
.PP
Referenced by libMesh::InfElemBuilder::build_inf_elem(), and libMesh::operator<<()\&.
.PP
.nf
331 {
332   os << this->get_info()
333      << std::endl;
334 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "virtual const \fBElem\fP* libMesh::MeshBase::query_elem (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.SS "virtual \fBElem\fP* libMesh::MeshBase::query_elem (const \fBdof_id_type\fPi)\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual const \fBNode\fP* libMesh::MeshBase::query_node_ptr (const \fBdof_id_type\fPi) const\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), and libMesh::Parallel::unpack()\&.
.SS "virtual \fBNode\fP* libMesh::MeshBase::query_node_ptr (const \fBdof_id_type\fPi)\fC [pure virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "void libMesh::UnstructuredMesh::read (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP, boolskip_renumber_nodes_and_elements = \fCfalse\fP)\fC [virtual]\fP"
Reads the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. This is now the only way to read a mesh\&. The \fC\fBUnstructuredMesh\fP\fP then initializes its data structures and is ready for use\&.
.PP
In order to read the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you will use with this mesh, since these read methods expect it\&.
.PP
The skip_renumber_nodes_and_elements argument is now deprecated - to disallow renumbering, set \fCMeshBase::allow_renumbering(false)\fP 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 514 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::allow_renumbering(), libMesh::XdrIO::binary(), libMesh::MeshCommunication::broadcast(), libMesh::err, libMesh::XdrIO::legacy(), libMesh::ParallelObject::n_processors(), libMesh::Quality::name(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::AbaqusIO::read(), libMesh::OFFIO::read(), libMesh::UCDIO::read(), libMesh::TetGenIO::read(), libMesh::UNVIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GmshIO::read(), libMesh::GMVIO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::VTKIO::read(), libMesh::MatlabIO::read(), libMesh::LegacyXdrIO::read_mgf(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
517 {
518   // See if the file exists\&.  Perform this check on all processors
519   // so that the code is terminated properly in the case that the
520   // file does not exist\&.
521 
522   // For Nemesis files, the name we try to read will have suffixes
523   // identifying processor rank
524   if (name\&.rfind("\&.nem") + 4 == name\&.size() ||
525       name\&.rfind("\&.n") + 2 == name\&.size())
526     {
527       std::ostringstream full_name;
528 
529       // Find the length of a string which represents the highest processor ID
530       full_name << (this->n_processors());
531       unsigned field_width = full_name\&.str()\&.size();
532 
533       // reset the string stream
534       full_name\&.str("");
535 
536       // And build up the full filename
537       full_name << name
538                 << '\&.' << this->n_processors()
539                 << '\&.' << std::setfill('0') << std::setw(field_width) << this->processor_id();
540 
541       std::ifstream in (full_name\&.str()\&.c_str());
542 
543       if (!in\&.good())
544         {
545           libMesh::err << "ERROR: cannot locate specified file:\n\t"
546                        << full_name\&.str()
547                        << std::endl;
548           libmesh_error();
549         }
550     }
551   else if(name\&.rfind("\&.cp")) {} // Do error checking in the reader
552   else
553     {
554       std::ifstream in (name\&.c_str());
555 
556       if (!in\&.good())
557         {
558           libMesh::err << "ERROR: cannot locate specified file:\n\t"
559                        << name
560                        << std::endl;
561           libmesh_error();
562         }
563     }
564 
565   // Set the skip_renumber_nodes_and_elements flag on all processors\&.
566   // This ensures that renumber_nodes_and_elements is *not* called
567   // during prepare_for_use() for certain types of mesh files\&.
568   // This is required in cases where there is an associated solution
569   // file which expects a certain ordering of the nodes\&.
570   if(name\&.rfind("\&.gmv")+4==name\&.size())
571     {
572       skip_renumber_nodes_and_elements =  true;
573     }
574 
575   // Look for parallel formats first
576   if (is_parallel_file_format(name))
577     {
578       // no need to handle bz2 files here -- the Xdr class does that\&.
579       if ((name\&.rfind("\&.xda") < name\&.size()) ||
580           (name\&.rfind("\&.xdr") < name\&.size()))
581         {
582           XdrIO xdr_io(*this);
583 
584           // \&.xda* ==> bzip2/gzip/ASCII flavors
585           if (name\&.rfind("\&.xda") < name\&.size())
586             {
587               xdr_io\&.binary() = false;
588               xdr_io\&.read (name);
589             }
590           else // \&.xdr* ==> true binary XDR file
591             {
592               xdr_io\&.binary() = true;
593               xdr_io\&.read (name);
594             }
595 
596           // The xdr_io object gets constructed with legacy() == false\&.
597           // if legacy() == true then it means that a legacy file was detected and
598           // thus processor 0 performed the read\&. We therefore need to broadcast the
599           // mesh\&.  Further, for this flavor of mesh solution data ordering is tied
600           // to the node ordering, so we better not reorder the nodes!
601           if (xdr_io\&.legacy())
602             {
603               this->allow_renumbering(false);
604               MeshCommunication()\&.broadcast(*this);
605             }
606 
607           // libHilbert-enabled libMesh builds should construct files
608           // with a canonical node ordering, which libHilbert-enabled
609           // builds will be able to read in again regardless of any
610           // renumbering\&.  So in that case we're free to renumber\&.
611           // However, if either the writer or the reader of this file
612           // don't have libHilbert, then we'll have to skip
613           // renumbering because we need the numbering to remain
614           // consistent with any solution file we read in next\&.
615 #ifdef LIBMESH_HAVE_LIBHILBERT
616           // if (!xdr_io\&.libhilbert_ordering())
617           //   skip_renumber_nodes_and_elements = true;
618 #else
619           this->allow_renumbering(false);
620 #endif
621         }
622       else if (name\&.rfind("\&.nem") < name\&.size() ||
623                name\&.rfind("\&.n")   < name\&.size())
624         Nemesis_IO(*this)\&.read (name);
625       else if (name\&.rfind("\&.cp") < name\&.size())
626         {
627           if(name\&.rfind("\&.cpa") < name\&.size())
628             CheckpointIO(*this, false)\&.read(name);
629           else
630             CheckpointIO(*this, true)\&.read(name);
631         }
632     }
633 
634   // Serial mesh formats
635   else
636     {
637       START_LOG("read()", "Mesh");
638 
639       // Read the file based on extension\&.  Only processor 0
640       // needs to read the mesh\&.  It will then broadcast it and
641       // the other processors will pick it up
642       if (this->processor_id() == 0)
643         {
644           std::ostringstream pid_suffix;
645           pid_suffix << '_' << getpid();
646           // Nasty hack for reading/writing zipped files
647           std::string new_name = name;
648           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
649             {
650 #ifdef LIBMESH_HAVE_BZIP
651               new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
652               new_name += pid_suffix\&.str();
653               std::string system_string = "bunzip2 -f -k -c ";
654               system_string += name + " > " + new_name;
655               START_LOG("system(bunzip2)", "Mesh");
656               if (std::system(system_string\&.c_str()))
657                 libmesh_file_error(system_string);
658               STOP_LOG("system(bunzip2)", "Mesh");
659 #else
660               libMesh::err << "ERROR: need bzip2/bunzip2 to open \&.bz2 file "
661                            << name << std::endl;
662               libmesh_error();
663 #endif
664             }
665           else if (name\&.size() - name\&.rfind("\&.xz") == 3)
666             {
667 #ifdef LIBMESH_HAVE_XZ
668               new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
669               new_name += pid_suffix\&.str();
670               std::string system_string = "xz -f -d -k -c ";
671               system_string += name + " > " + new_name;
672               START_LOG("system(xz -d)", "XdrIO");
673               if (std::system(system_string\&.c_str()))
674                 libmesh_file_error(system_string);
675               STOP_LOG("system(xz -d)", "XdrIO");
676 #else
677               libMesh::err << "ERROR: need xz to open \&.xz file "
678                            << name << std::endl;
679               libmesh_error();
680 #endif
681             }
682 
683           if (new_name\&.rfind("\&.mat") < new_name\&.size())
684             MatlabIO(*this)\&.read(new_name);
685 
686           else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
687             UCDIO(*this)\&.read (new_name);
688 
689           else if ((new_name\&.rfind("\&.off")  < new_name\&.size()) ||
690                    (new_name\&.rfind("\&.ogl")  < new_name\&.size()) ||
691                    (new_name\&.rfind("\&.oogl") < new_name\&.size()))
692             OFFIO(*this)\&.read (new_name);
693 
694           else if (new_name\&.rfind("\&.mgf") < new_name\&.size())
695             LegacyXdrIO(*this,true)\&.read_mgf (new_name);
696 
697           else if (new_name\&.rfind("\&.unv") < new_name\&.size())
698             {
699               if (mesh_data == NULL)
700                 {
701                   libMesh::err << "Error! You must pass a "
702                                << "valid MeshData pointer to "
703                                << "read UNV files!" << std::endl;
704                   libmesh_error();
705                 }
706               UNVIO(*this, *mesh_data)\&.read (new_name);
707             }
708 
709           else if ((new_name\&.rfind("\&.node")  < new_name\&.size()) ||
710                    (new_name\&.rfind("\&.ele")   < new_name\&.size()))
711             TetGenIO(*this,mesh_data)\&.read (new_name);
712 
713           else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
714                    new_name\&.rfind("\&.e") < new_name\&.size())
715             ExodusII_IO(*this)\&.read (new_name);
716 
717           else if (new_name\&.rfind("\&.msh") < new_name\&.size())
718             GmshIO(*this)\&.read (new_name);
719 
720           else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
721             GMVIO(*this)\&.read (new_name);
722 
723           else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
724             VTKIO(*this)\&.read(new_name);
725 
726           else if (new_name\&.rfind("\&.inp") < new_name\&.size())
727             AbaqusIO(*this)\&.read(new_name);
728 
729           else
730             {
731               libMesh::err << " ERROR: Unrecognized file extension: " << name
732                            << "\n   I understand the following:\n\n"
733                            << "     *\&.e    -- Sandia's ExodusII format\n"
734                            << "     *\&.exd  -- Sandia's ExodusII format\n"
735                            << "     *\&.gmv  -- LANL's General Mesh Viewer format\n"
736                            << "     *\&.mat  -- Matlab triangular ASCII file\n"
737                            << "     *\&.n    -- Sandia's Nemesis format\n"
738                            << "     *\&.nem  -- Sandia's Nemesis format\n"
739                            << "     *\&.off  -- OOGL OFF surface format\n"
740                            << "     *\&.ucd  -- AVS's ASCII UCD format\n"
741                            << "     *\&.unv  -- I-deas Universal format\n"
742                            << "     *\&.vtu  -- Paraview VTK format\n"
743                            << "     *\&.inp  -- Abaqus \&.inp format\n"
744                            << "     *\&.xda  -- libMesh ASCII format\n"
745                            << "     *\&.xdr  -- libMesh binary format\n"
746                            << "     *\&.gz   -- any above format gzipped\n"
747                            << "     *\&.bz2  -- any above format bzip2'ed\n"
748                            << "     *\&.xz   -- any above format xzipped\n"
749                            << "     *\&.cpa  -- libMesh Checkpoint ASCII format\n"
750                            << "     *\&.cpr  -- libMesh Checkpoint binary format\n"
751 
752                            << std::endl;
753               libmesh_error();
754             }
755 
756           // If we temporarily decompressed a file, remove the
757           // uncompressed version
758           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
759             std::remove(new_name\&.c_str());
760           if (name\&.size() - name\&.rfind("\&.xz") == 3)
761             std::remove(new_name\&.c_str());
762         }
763 
764 
765       STOP_LOG("read()", "Mesh");
766 
767       // Send the mesh & bcs (which are now only on processor 0) to the other
768       // processors
769       MeshCommunication()\&.broadcast (*this);
770     }
771 
772   if (skip_renumber_nodes_and_elements)
773     {
774       // Use MeshBase::allow_renumbering() yourself instead\&.
775       libmesh_deprecated();
776       this->allow_renumbering(false);
777     }
778 
779   // Done reading the mesh\&.  Now prepare it for use\&.
780   this->prepare_for_use();
781 }
.fi
.SS "unsigned int libMesh::MeshBase::recalculate_n_partitions ()\fC [inherited]\fP"
In a few (very rare) cases, the user may have manually tagged the elements with specific processor IDs by hand, without using a partitioner\&. In this case, the \fBMesh\fP will not know that the total number of partitions, _n_parts, has changed, unless you call this function\&. This is an O(N active elements) calculation\&. The return value is the number of partitions, and _n_parts is also set by this function\&. 
.PP
Definition at line 364 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_n_parts, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, std::max(), and libMesh::Parallel::Communicator::max()\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
365 {
366   const_element_iterator       el  = this->active_elements_begin();
367   const const_element_iterator end = this->active_elements_end();
368 
369   unsigned int max_proc_id=0;
370 
371   for (; el!=end; ++el)
372     max_proc_id = std::max(max_proc_id, static_cast<unsigned int>((*el)->processor_id()));
373 
374   // The number of partitions is one more than the max processor ID\&.
375   _n_parts = max_proc_id+1;
376 
377   this->comm()\&.max(_n_parts);
378 
379   return _n_parts;
380 }
.fi
.SS "virtual void libMesh::MeshBase::redistribute ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Redistribute elements between processors\&. This gets called automatically by the \fBPartitioner\fP, and is a no-op in the case of a \fBSerialMesh\fP or serialized \fBParallelMesh\fP 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 522 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::Partitioner::partition()\&.
.PP
.nf
522 {}
.fi
.SS "virtual void libMesh::MeshBase::renumber_elem (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [pure virtual]\fP, \fC [inherited]\fP"
Changes the id of element \fCold_id\fP, both by changing elem(old_id)->id() and by moving elem(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::make_elems_parallel_consistent()\&.
.SS "virtual void libMesh::MeshBase::renumber_node (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [pure virtual]\fP, \fC [inherited]\fP"
Changes the id of node \fCold_id\fP, both by changing node(old_id)->id() and by moving node(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshCommunication::make_node_ids_parallel_consistent()\&.
.SS "virtual void libMesh::MeshBase::renumber_nodes_and_elements ()\fC [pure virtual]\fP, \fC [inherited]\fP"
After partitoning a mesh it is useful to renumber the nodes and elements so that they lie in contiguous blocks on the processors\&. This method does just that\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_first_order(), all_second_order(), contract(), libMesh::ErrorVector::plot_error(), and libMesh::MeshBase::prepare_for_use()\&.
.SS "virtual void libMesh::MeshBase::reserve_elem (const \fBdof_id_type\fPne)\fC [pure virtual]\fP, \fC [inherited]\fP"
Reserves space for a known number of elements\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of elements you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ExodusII_IO::read(), libMesh::XdrIO::read(), libMesh::GmshIO::read_mesh(), and libMesh::LegacyXdrIO::read_mesh()\&.
.SS "virtual void libMesh::MeshBase::reserve_nodes (const \fBdof_id_type\fPnn)\fC [pure virtual]\fP, \fC [inherited]\fP"
Reserves space for a known number of nodes\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of nodes you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by all_second_order(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ExodusII_IO::read(), libMesh::XdrIO::read(), libMesh::GmshIO::read_mesh(), and libMesh::LegacyXdrIO::read_mesh()\&.
.SS "void libMesh::MeshBase::set_mesh_dimension (unsigned intd)\fC [inline]\fP, \fC [inherited]\fP"
Resets the logical dimension of the mesh\&. 
.PP
Definition at line 161 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::TriangleWrapper::copy_tri_to_mesh(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), and libMesh::TriangleInterface::triangulate()\&.
.PP
.nf
162   { _dim = d; }
.fi
.SS "unsigned int& libMesh::MeshBase::set_n_partitions ()\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Returns a writeable reference to the number of partitions\&. 
.PP
Definition at line 859 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::Partitioner::partition(), libMesh::Partitioner::repartition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
860   { return _n_parts; }
.fi
.SS "void libMesh::MeshBase::set_next_unique_id (\fBunique_id_type\fPid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the next unique id to be used\&. 
.PP
Definition at line 221 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
221 { _next_unique_id = id; }
.fi
.SS "std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::set_subdomain_name_map ()\fC [inline]\fP, \fC [inherited]\fP"
Return a writeable reference to the whole subdomain name map 
.PP
Definition at line 841 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::read_serialized_subdomain_names(), and libMesh::CheckpointIO::read_subdomain_names()\&.
.PP
.nf
842   { return _block_id_to_name; }
.fi
.SS "void libMesh::MeshBase::skip_partitioning (boolskip)\fC [inline]\fP, \fC [inherited]\fP"
If true is passed in then this mesh will no longer be (re)partitioned\&. It would probably be a bad idea to call this on a Serial \fBMesh\fP \fIbefore\fP the first partitioning has happened\&.\&.\&. because no elements would get assigned to your processor pool\&.
.PP
Note that turning on \fBskip_partitioning()\fP can have adverse effects on your performance when using AMR\&.\&.\&. ie you could get large load imbalances\&.
.PP
However you might still want to use this if the communication and computation of the rebalance and repartition is too high for your application\&. 
.PP
Definition at line 551 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by copy_nodes_and_elements()\&.
.PP
.nf
551 { _skip_partitioning = skip; }
.fi
.SS "bool libMesh::MeshBase::skip_partitioning () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 552 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
552 { return _skip_partitioning; }
.fi
.SS "unsigned int libMesh::MeshBase::spatial_dimension () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the spatial dimension of the mesh\&. Note that this is defined at compile time in the header \fC\fBlibmesh_common\&.h\fP\fP\&. 
.PP
Definition at line 168 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::MeshBase::get_info(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::UNVIO::node_out(), libMesh::MeshTools::Modification::scale(), libMesh::MeshTools::subdomain_bounding_box(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.PP
.nf
169   { return static_cast<unsigned int>(LIBMESH_DIM); }
.fi
.SS "\fBAutoPtr\fP< \fBPointLocatorBase\fP > libMesh::MeshBase::sub_point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a subordinate \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should not be used in threaded or non-parallel_only code unless the master has already been constructed\&. 
.PP
Definition at line 400 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
Referenced by libMesh::DofMap::create_dof_constraints(), libMesh::MeshFunction::init(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), and libMesh::MeshRefinement::test_level_one()\&.
.PP
.nf
401 {
402   if (_point_locator\&.get() == NULL)
403     {
404       // PointLocator construction may not be safe within threads
405       libmesh_assert(!Threads::in_threads);
406 
407       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
408     }
409 
410   return PointLocatorBase::build(TREE, *this, _point_locator\&.get());
411 }
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::subactive_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::subactive_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::subactive_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::subactive_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "void libMesh::MeshBase::subdomain_ids (std::set< \fBsubdomain_id_type\fP > &ids) const\fC [inherited]\fP"
Constructs a list of all subdomain identifiers in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 207 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, and libMesh::Parallel::Communicator::set_union()\&.
.PP
Referenced by libMesh::MeshBase::n_subdomains(), and libMesh::TecplotIO::TecplotIO()\&.
.PP
.nf
208 {
209   // This requires an inspection on every processor
210   parallel_object_only();
211 
212   ids\&.clear();
213 
214   const_element_iterator       el  = this->active_elements_begin();
215   const const_element_iterator end = this->active_elements_end();
216 
217   for (; el!=end; ++el)
218     ids\&.insert((*el)->subdomain_id());
219 
220   // Some subdomains may only live on other processors
221   this->comm()\&.set_union(ids);
222 }
.fi
.SS "std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid)\fC [inherited]\fP"
Returns a writable reference for getting/setting an optional name for a subdomain\&. 
.PP
Definition at line 422 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by DMLibMeshSetSystem(), libMesh::ExodusII_IO::read(), libMesh::TecplotIO::write_binary(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.PP
.nf
423 {
424   return _block_id_to_name[id];
425 }
.fi
.SS "const std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid) const\fC [inherited]\fP"

.PP
Definition at line 427 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
.nf
428 {
429   // An empty string to return when no matching subdomain name is found
430   static const std::string empty;
431 
432   std::map<subdomain_id_type, std::string>::const_iterator iter = _block_id_to_name\&.find(id);
433   if (iter == _block_id_to_name\&.end())
434     return empty;
435   else
436     return iter->second;
437 }
.fi
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::type_elements_begin (const \fBElemType\fPtype)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_elem_of_type(), and libMesh::MeshTools::n_non_subactive_elem_of_type_at_level()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::type_elements_begin (const \fBElemType\fPtype) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::type_elements_end (const \fBElemType\fPtype)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_elem_of_type(), and libMesh::MeshTools::n_non_subactive_elem_of_type_at_level()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::type_elements_end (const \fBElemType\fPtype) const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::unpartitioned_elements_begin ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_active_levels(), libMesh::MeshTools::n_levels(), libMesh::MeshTools::n_p_levels(), libMesh::Partitioner::partition_unpartitioned_elements(), and libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::unpartitioned_elements_begin () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual \fBelement_iterator\fP libMesh::MeshBase::unpartitioned_elements_end ()\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshTools::n_active_levels(), libMesh::MeshTools::n_levels(), libMesh::MeshTools::n_p_levels(), libMesh::Partitioner::partition_unpartitioned_elements(), and libMesh::Partitioner::set_node_processor_ids()\&.
.SS "virtual \fBconst_element_iterator\fP libMesh::MeshBase::unpartitioned_elements_end () const\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.SS "virtual void libMesh::MeshBase::update_parallel_id_counts ()\fC [pure virtual]\fP, \fC [inherited]\fP"
Updates parallel caches so that methods like \fBn_elem()\fP accurately reflect changes on other processors 
.PP
Implemented in \fBlibMesh::ParallelMesh\fP, and \fBlibMesh::SerialMesh\fP\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), and libMesh::MeshBase::prepare_for_use()\&.
.SS "virtual void libMesh::MeshBase::update_post_partitioning ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Recalculate any cached data after elements and nodes have been repartitioned\&. 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 528 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), and libMesh::Nemesis_IO::read()\&.
.PP
.nf
528 {}
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP)\fC [virtual]\fP"
Write the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&.
.PP
In order to write the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you have been using with this mesh, since these write methods expect it\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 785 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Parallel::Communicator::barrier(), libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::err, libMesh::MeshBase::n_partitions(), libMesh::Quality::name(), libMesh::GMVIO::partitioning(), libMesh::ParallelObject::processor_id(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::FroIO::write(), libMesh::DivaIO::write(), libMesh::TecplotIO::write(), libMesh::MEDITIO::write(), libMesh::GMVIO::write(), libMesh::UCDIO::write(), libMesh::TetGenIO::write(), libMesh::UNVIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::GmshIO::write(), libMesh::XdrIO::write(), libMesh::VTKIO::write(), and libMesh::LegacyXdrIO::write_mgf()\&.
.PP
.nf
787 {
788   // parallel formats are special -- they may choose to write
789   // separate files, let's not try to handle the zipping here\&.
790   if (is_parallel_file_format(name))
791     {
792       // no need to handle bz2 files here -- the Xdr class does that\&.
793       if (name\&.rfind("\&.xda") < name\&.size())
794         XdrIO(*this)\&.write(name);
795 
796       else if (name\&.rfind("\&.xdr") < name\&.size())
797         XdrIO(*this,true)\&.write(name);
798 
799       else if (name\&.rfind("\&.nem") < name\&.size() ||
800                name\&.rfind("\&.n")   < name\&.size())
801         Nemesis_IO(*this)\&.write(name);
802     }
803 
804   // serial file formats
805   else
806     {
807       START_LOG("write()", "Mesh");
808 
809       // Nasty hack for reading/writing zipped files
810       std::string new_name = name;
811       processor_id_type pid_0 = 0;
812       if (this->processor_id() == 0)
813         pid_0 = getpid();
814       this->comm()\&.broadcast(pid_0);
815       std::ostringstream pid_suffix;
816       pid_suffix << '_' << pid_0;
817 
818       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
819         {
820           new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
821           new_name += pid_suffix\&.str();
822         }
823       else if (name\&.size() - name\&.rfind("\&.xz") == 3)
824         {
825           new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
826           new_name += pid_suffix\&.str();
827         }
828 
829       // New scope so that io will close before we try to zip the file
830       {
831         // Write the file based on extension
832         if (new_name\&.rfind("\&.dat") < new_name\&.size())
833           TecplotIO(*this)\&.write (new_name);
834 
835         else if (new_name\&.rfind("\&.plt") < new_name\&.size())
836           TecplotIO(*this,true)\&.write (new_name);
837 
838         else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
839           UCDIO (*this)\&.write (new_name);
840 
841         else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
842           if (this->n_partitions() > 1)
843             GMVIO(*this)\&.write (new_name);
844           else
845             {
846               GMVIO io(*this);
847               io\&.partitioning() = false;
848               io\&.write (new_name);
849             }
850 
851         else if (new_name\&.rfind("\&.ugrid") < new_name\&.size())
852           DivaIO(*this)\&.write(new_name);
853         else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
854                  new_name\&.rfind("\&.e") < new_name\&.size())
855           ExodusII_IO(*this)\&.write(new_name);
856         else if (new_name\&.rfind("\&.mgf")  < new_name\&.size())
857           LegacyXdrIO(*this,true)\&.write_mgf(new_name);
858 
859         else if (new_name\&.rfind("\&.unv") < new_name\&.size())
860           {
861             if (mesh_data == NULL)
862               {
863                 libMesh::err << "Error! You must pass a "
864                              << "valid MeshData pointer to "
865                              << "write UNV files!" << std::endl;
866                 libmesh_error();
867               }
868             UNVIO(*this, *mesh_data)\&.write (new_name);
869           }
870 
871         else if (new_name\&.rfind("\&.mesh") < new_name\&.size())
872           MEDITIO(*this)\&.write (new_name);
873 
874         else if (new_name\&.rfind("\&.poly") < new_name\&.size())
875           TetGenIO(*this)\&.write (new_name);
876 
877         else if (new_name\&.rfind("\&.msh") < new_name\&.size())
878           GmshIO(*this)\&.write (new_name);
879 
880         else if (new_name\&.rfind("\&.fro") < new_name\&.size())
881           FroIO(*this)\&.write (new_name);
882 
883         else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
884           VTKIO(*this)\&.write (new_name);
885 
886         else
887           {
888             libMesh::err
889               << " ERROR: Unrecognized file extension: " << name
890               << "\n   I understand the following:\n\n"
891               << "     *\&.dat   -- Tecplot ASCII file\n"
892               << "     *\&.e     -- Sandia's ExodusII format\n"
893               << "     *\&.exd   -- Sandia's ExodusII format\n"
894               << "     *\&.fro   -- ACDL's surface triangulation file\n"
895               << "     *\&.gmv   -- LANL's GMV (General Mesh Viewer) format\n"
896               << "     *\&.mesh  -- MEdit mesh format\n"
897               << "     *\&.mgf   -- MGF binary mesh format\n"
898               << "     *\&.msh   -- GMSH ASCII file\n"
899               << "     *\&.n     -- Sandia's Nemesis format\n"
900               << "     *\&.nem   -- Sandia's Nemesis format\n"
901               << "     *\&.plt   -- Tecplot binary file\n"
902               << "     *\&.poly  -- TetGen ASCII file\n"
903               << "     *\&.ucd   -- AVS's ASCII UCD format\n"
904               << "     *\&.ugrid -- Kelly's DIVA ASCII format\n"
905               << "     *\&.unv   -- I-deas Universal format\n"
906               << "     *\&.vtu   -- VTK (paraview-readable) format\n"
907               << "     *\&.xda   -- libMesh ASCII format\n"
908               << "     *\&.xdr   -- libMesh binary format,\n"
909               << std::endl
910               << "\n Exiting without writing output\n";
911           }
912       }
913 
914       // Nasty hack for reading/writing zipped files
915       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
916         {
917           START_LOG("system(bzip2)", "Mesh");
918           if (this->processor_id() == 0)
919             {
920               std::string system_string = "bzip2 -f -c ";
921               system_string += new_name + " > " + name;
922               if (std::system(system_string\&.c_str()))
923                 libmesh_file_error(system_string);
924               std::remove(new_name\&.c_str());
925             }
926           this->comm()\&.barrier();
927           STOP_LOG("system(bzip2)", "Mesh");
928         }
929       if (name\&.size() - name\&.rfind("\&.xz") == 3)
930         {
931           START_LOG("system(xz)", "Mesh");
932           if (this->processor_id() == 0)
933             {
934               std::string system_string = "xz -f -c ";
935               system_string += new_name + " > " + name;
936               if (std::system(system_string\&.c_str()))
937                 libmesh_file_error(system_string);
938               std::remove(new_name\&.c_str());
939             }
940           this->comm()\&.barrier();
941           STOP_LOG("system(xz)", "Mesh");
942         }
943 
944       STOP_LOG("write()", "Mesh");
945     }
946 }
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)"
Write to the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. Also writes data\&. 
.PP
Definition at line 950 of file unstructured_mesh\&.C\&.
.PP
References libMesh::err, libMesh::MeshBase::n_subdomains(), libMesh::GMVIO::partitioning(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TecplotIO::write_nodal_data(), libMesh::VTKIO::write_nodal_data(), and libMesh::GMVIO::write_nodal_data()\&.
.PP
.nf
953 {
954   START_LOG("write()", "Mesh");
955 
956   // Write the file based on extension
957   if (name\&.rfind("\&.dat") < name\&.size())
958     TecplotIO(*this)\&.write_nodal_data (name, v, vn);
959 
960   else if (name\&.rfind("\&.plt") < name\&.size())
961     TecplotIO(*this,true)\&.write_nodal_data (name, v, vn);
962 
963   else if (name\&.rfind("\&.gmv") < name\&.size())
964     {
965       if (n_subdomains() > 1)
966         GMVIO(*this)\&.write_nodal_data (name, v, vn);
967       else
968         {
969           GMVIO io(*this);
970           io\&.partitioning() = false;
971           io\&.write_nodal_data (name, v, vn);
972         }
973     }
974   else if (name\&.rfind("\&.pvtu") < name\&.size())
975     {
976       VTKIO(*this)\&.write_nodal_data (name, v, vn);
977     }
978   else
979     {
980       libMesh::err
981         << " ERROR: Unrecognized file extension: " << name
982         << "\n   I understand the following:\n\n"
983         << "     *\&.dat  -- Tecplot ASCII file\n"
984         << "     *\&.gmv  -- LANL's GMV (General Mesh Viewer) format\n"
985         << "     *\&.plt  -- Tecplot binary file\n"
986         << "     *\&.pvtu -- Paraview VTK file\n"
987         << "\n Exiting without writing output\n";
988     }
989 
990   STOP_LOG("write()", "Mesh");
991 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::map<\fBsubdomain_id_type\fP, std::string> libMesh::MeshBase::_block_id_to_name\fC [protected]\fP, \fC [inherited]\fP"
This structure maintains the mapping of named blocks for file formats that support named blocks\&. Currently this is only implemented for ExodusII 
.PP
Definition at line 924 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::get_id_by_name(), libMesh::MeshBase::get_subdomain_name_map(), libMesh::MeshBase::set_subdomain_name_map(), and libMesh::MeshBase::subdomain_name()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "unsigned int libMesh::MeshBase::_dim\fC [protected]\fP, \fC [inherited]\fP"
The logical dimension of the mesh\&. 
.PP
Definition at line 876 of file mesh_base\&.h\&.
.PP
Referenced by copy_nodes_and_elements(), find_neighbors(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::MeshBase(), and libMesh::MeshBase::set_mesh_dimension()\&.
.SS "bool libMesh::MeshBase::_is_prepared\fC [protected]\fP, \fC [inherited]\fP"
Flag indicating if the mesh has been prepared for use\&. 
.PP
Definition at line 881 of file mesh_base\&.h\&.
.PP
Referenced by all_first_order(), all_second_order(), libMesh::MeshBase::clear(), copy_nodes_and_elements(), libMesh::MeshBase::is_prepared(), and libMesh::MeshBase::prepare_for_use()\&.
.SS "unsigned int libMesh::MeshBase::_n_parts\fC [protected]\fP, \fC [inherited]\fP"
The number of partitions the mesh has\&. This is set by the partitioners, and may not be changed directly by the user\&. \fBNOTE\fP The number of partitions \fIneed not\fP equal this->\fBn_processors()\fP, consider for example the case where you simply want to partition a mesh on one processor and view the result in GMV\&. 
.PP
Definition at line 871 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear(), copy_nodes_and_elements(), libMesh::MeshBase::n_partitions(), libMesh::MeshBase::recalculate_n_partitions(), and libMesh::MeshBase::set_n_partitions()\&.
.SS "\fBunique_id_type\fP libMesh::MeshBase::_next_unique_id\fC [protected]\fP, \fC [inherited]\fP"
The next available unique id for assigning ids to DOF objects 
.PP
Definition at line 904 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::SerialMesh::assign_unique_ids(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::MeshBase::next_unique_id(), libMesh::ParallelMesh::ParallelMesh(), libMesh::SerialMesh::SerialMesh(), and libMesh::MeshBase::set_next_unique_id()\&.
.SS "\fBAutoPtr\fP<\fBPartitioner\fP> libMesh::MeshBase::_partitioner\fC [protected]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP\&.
.PP
This will be built in the constructor of each derived class, but can be replaced by the user through the \fBpartitioner()\fP accessor\&. 
.PP
Definition at line 898 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::MeshBase(), libMesh::ParallelMesh::ParallelMesh(), libMesh::MeshBase::partitioner(), and libMesh::SerialMesh::SerialMesh()\&.
.SS "\fBAutoPtr\fP<\fBPointLocatorBase\fP> libMesh::MeshBase::_point_locator\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
A \fCPointLocator\fP class for this mesh\&. This will not actually be built unless needed\&. Further, since we want our \fC\fBpoint_locator()\fP\fP method to be \fCconst\fP (yet do the dynamic allocating) this needs to be mutable\&. Since the \fBPointLocatorBase::build()\fP member is used, and it operates on a constant reference to the mesh, this is OK\&. 
.PP
Definition at line 890 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear_point_locator(), libMesh::MeshBase::point_locator(), and libMesh::MeshBase::sub_point_locator()\&.
.SS "bool libMesh::MeshBase::_skip_partitioning\fC [protected]\fP, \fC [inherited]\fP"
If this is true then no partitioning should be done\&. 
.PP
Definition at line 910 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::skip_partitioning()\&.
.SS "bool libMesh::MeshBase::_skip_renumber_nodes_and_elements\fC [protected]\fP, \fC [inherited]\fP"
If this is true then renumbering will be kept to a miniumum\&.
.PP
This is set when \fBprepare_for_use()\fP is called\&. 
.PP
Definition at line 917 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::prepare_for_use(), libMesh::SerialMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.SS "\fBAutoPtr\fP<\fBBoundaryInfo\fP> libMesh::MeshBase::boundary_info\fC [inherited]\fP"
This class holds the boundary information\&. It can store nodes, edges, and faces with a corresponding id that facilitates setting boundary conditions\&. 
.PP
Definition at line 110 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), all_first_order(), all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::AbaqusIO::assign_boundary_node_ids(), libMesh::AbaqusIO::assign_sideset_ids(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::Modification::change_boundary_id(), libMesh::MeshBase::clear(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), create_submesh(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshTools::Modification::flatten(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::BoundaryProjectSolution::operator()(), libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), libMesh::ParallelMesh::ParallelMesh(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_bcs(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::CheckpointIO::read_nodesets(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::SerialMesh::SerialMesh(), libMesh::SerialMesh::stitching_helper(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::FroIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::XdrIO::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::LegacyXdrIO::write_soln(), and libMesh::DivaIO::write_stream()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
