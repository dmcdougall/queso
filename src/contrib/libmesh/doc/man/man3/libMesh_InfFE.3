.TH "libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe\&.h>\fP
.PP
Inherits \fBlibMesh::FEGenericBase< T >\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBBase\fP"
.br
.ti -1c
.RI "class \fBRadial\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef OutputType \fBOutputShape\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputGradient\fP >::type \fBOutputTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputDivergence\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::MakeNumber\fP
.br
< \fBOutputShape\fP >::type \fBOutputNumber\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumberGradient\fP >::type \fBOutputNumberTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberDivergence\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInfFE\fP (const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "\fB~InfFE\fP ()"
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const "
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const unsigned int \fBside\fP, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *, const \fBElem\fP *, const unsigned int, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &)"
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const "
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const "
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP
.br
< \fBRealGradient\fP > > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP
.br
< \fBRealGradient\fP > > \fBbuild_InfFE\fP (const unsigned int, const \fBFEType\fP &)"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputGradient\fP > > & \fBget_dphi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_curl_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputDivergence\fP > > & \fBget_div_phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidx\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidy\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidxi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphideta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputTensor\fP > > & \fBget_d2phi\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidx2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdy\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidy2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidydz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidz2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phideta2\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector
.br
< \fBOutputGradient\fP > & \fBget_dphase\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_Sobolev_weight\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_Sobolev_dweight\fP () const "
.br
.ti -1c
.RI "void \fBprint_phi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_dphi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_d2phi\fP (std::ostream &os) const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBReal\fP \fBshape\fP (const \fBFEType\fP &fet, const \fBElemType\fP t, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBReal\fP \fBshape\fP (const \fBFEType\fP &fet, const \fBElem\fP *elem, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static void \fBcompute_data\fP (const \fBFEType\fP &fe_t, const \fBElem\fP *inf_elem, \fBFEComputeData\fP &\fBdata\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_shape_functions\fP (const \fBFEType\fP &fet, const \fBElemType\fP t)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs\fP (const \fBFEType\fP &fet, const \fBElemType\fP inf_elem_type)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_at_node\fP (const \fBFEType\fP &fet, const \fBElemType\fP inf_elem_type, const unsigned int n)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_per_elem\fP (const \fBFEType\fP &fet, const \fBElemType\fP inf_elem_type)"
.br
.ti -1c
.RI "static void \fBnodal_soln\fP (const \fBFEType\fP &fet, const \fBElem\fP *elem, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBinverse_map\fP (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true, const bool interpolated=true)"
.br
.ti -1c
.RI "static void \fBinverse_map\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static void \fBcompute_proj_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcoarsened_dof_values\fP (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &\fBdof_map\fP, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned int var, const bool use_old_dof_indices=false)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdate_base_elem\fP (const \fBElem\fP *inf_elem)"
.br
.ti -1c
.RI "virtual void \fBinit_base_shape_functions\fP (const std::vector< \fBPoint\fP > &, const \fBElem\fP *)"
.br
.ti -1c
.RI "void \fBinit_radial_shape_functions\fP (const \fBElem\fP *inf_elem)"
.br
.ti -1c
.RI "void \fBinit_shape_functions\fP (const \fBElem\fP *inf_elem)"
.br
.ti -1c
.RI "void \fBinit_face_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *\fBside\fP)"
.br
.ti -1c
.RI "void \fBcombine_base_radial\fP (const \fBElem\fP *inf_elem)"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *, const std::vector< \fBPoint\fP > &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP o, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP, unsigned i)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBReal\fP \fBeval\fP (\fBReal\fP v, \fBOrder\fP o_radial, unsigned int i)"
.br
.ti -1c
.RI "static \fBReal\fP \fBeval_deriv\fP (\fBReal\fP v, \fBOrder\fP o_radial, unsigned int i)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap\fP (const \fBElem\fP *inf_elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static void \fBcompute_node_indices\fP (const \fBElemType\fP inf_elem_type, const unsigned int outer_node_index, unsigned int &base_node, unsigned int &radial_node)"
.br
.ti -1c
.RI "static void \fBcompute_node_indices_fast\fP (const \fBElemType\fP inf_elem_type, const unsigned int outer_node_index, unsigned int &base_node, unsigned int &radial_node)"
.br
.ti -1c
.RI "static void \fBcompute_shape_indices\fP (const \fBFEType\fP &fet, const \fBElemType\fP inf_elem_type, const unsigned int i, unsigned int &base_shape, unsigned int &radial_shape)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdist\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdweightdv\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBsom\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdsomdv\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBmode\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdmodedv\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBradial_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdradialdv_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdphasedxi\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdphasedeta\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdphasedzeta\fP"
.br
.ti -1c
.RI "std::vector< unsigned int > \fB_radial_node_index\fP"
.br
.ti -1c
.RI "std::vector< unsigned int > \fB_base_node_index\fP"
.br
.ti -1c
.RI "std::vector< unsigned int > \fB_radial_shape_index\fP"
.br
.ti -1c
.RI "std::vector< unsigned int > \fB_base_shape_index\fP"
.br
.ti -1c
.RI "unsigned int \fB_n_total_approx_sf\fP"
.br
.ti -1c
.RI "unsigned int \fB_n_total_qp\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fB_total_qrule_weights\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBbase_qrule\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBradial_qrule\fP"
.br
.ti -1c
.RI "\fBElem\fP * \fBbase_elem\fP"
.br
.ti -1c
.RI "\fBFEBase\fP * \fBbase_fe\fP"
.br
.ti -1c
.RI "\fBFEType\fP \fBcurrent_fe_type\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFETransformationBase\fP
.br
< OutputType > > \fB_fe_trans\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputGradient\fP > > \fBdphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBcurl_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputDivergence\fP > > \fBdiv_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidxi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidx\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputTensor\fP > > \fBd2phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxi2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phideta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidetadzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidzeta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidx2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidy2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidydz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidz2\fP"
.br
.ti -1c
.RI "std::vector< \fBOutputGradient\fP > \fBdphase\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdweight\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBweight\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const "
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBElemType\fP \fB_compute_node_indices_fast_current_elem_type\fP = \fBINVALID_ELEM\fP"
.br
.ti -1c
.RI "static bool \fB_warned_for_nodal_soln\fP = false"
.br
.ti -1c
.RI "static bool \fB_warned_for_shape\fP = false"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> class \fBInfFE\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map>class libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >"
A specific instatiation of the \fCFEBase\fP class\&. This class is templated, and specific template instantiations will result in different Infinite Element families, similar to the \fC\fBFE\fP\fP class\&. \fC\fBInfFE\fP\fP builds a \fC\fBFE\fP<Dim-1\fP,T_base>, and most of the requests related to the base are handed over to this object\&. All methods related to the radial part are collected in the nested class \fC\fBRadial\fP\fP\&. Similarly, most of the static methods concerning base approximation are contained in \fC\fBBase\fP\fP\&.
.PP
Having different shape approximation families in radial direction introduces the requirement for an additional \fCOrder\fP in this class\&. Therefore, the \fC\fBFEType\fP\fP internals change when infinite elements are enabled\&. When the specific infinite element type is not known at compile time, use the \fC\fBFEBase::build()\fP\fP member to create abstract (but still optimized) infinite elements at run time\&.
.PP
The \fInode\fP numbering scheme is the one from the current infinite element\&. Each node in the base holds exactly the same number of dofs as an adjacent conventional \fC\fBFE\fP\fP would contain\&. The nodes further out hold the additional dof necessary for radial approximation\&. The order of the outer nodes' components is such that the radial shapes have highest priority, followed by the base shapes\&.
.PP
\fBAuthor:\fP
.RS 4
Daniel Dreyer 
.RE
.PP
\fBDate:\fP
.RS 4
2003 
.RE
.PP

.PP
Definition at line 40 of file fe\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::DecrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 138 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputGradient\fP\fC [inherited]\fP"

.PP
Definition at line 136 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::MakeNumber\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumber\fP\fC [inherited]\fP"

.PP
Definition at line 139 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::DecrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 142 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberGradient\fP\fC [inherited]\fP"

.PP
Definition at line 140 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumberGradient\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputNumberTensor\fP\fC [inherited]\fP"

.PP
Definition at line 141 of file fe_base\&.h\&.
.SS "template<typename T> typedef OutputType \fBlibMesh::FEGenericBase\fP< T >::\fBOutputShape\fP\fC [inherited]\fP"
Convenient typedefs for gradients of output, hessians of output, and potentially-complex-valued versions of same\&. 
.PP
Definition at line 135 of file fe_base\&.h\&.
.SS "template<typename T> typedef \fBTensorTools::IncrementRank\fP<\fBOutputGradient\fP>::type \fBlibMesh::FEGenericBase\fP< T >::\fBOutputTensor\fP\fC [inherited]\fP"

.PP
Definition at line 137 of file fe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::\fBInfFE\fP (const \fBFEType\fP &fet)\fC [explicit]\fP"
Constructor\&. Initializes some data structures\&. Builds a \fC\fBFE\fP<Dim-1\fP,T_base> object to handle approximation in the base, so that there is no need to template \fCInfFE<Dim,T_radial,T_map>\fP also with respect to the base approximation \fCT_base\fP\&.
.PP
The same remarks concerning compile-time optimization for \fC\fBFE\fP\fP also hold for \fC\fBInfFE\fP\fP\&. Use the \fC\fBFEBase::build_InfFE(const unsigned int, const FEType&)\fP\fP method to build specific instantiations of \fC\fBInfFE\fP\fP at run time\&. 
.PP
Definition at line 40 of file inf_fe\&.C\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::base_fe, libMesh::FEGenericBase< T >::build(), libMesh::FEAbstract::fe_type, libMesh::FEType::inf_map, libMesh::FEType::radial_family, and libMesh::AutoPtr< Tp >::release()\&.
.PP
.nf
40                                                    :
41   FEBase       (Dim, fet),
42 
43   _n_total_approx_sf (0),
44   _n_total_qp        (0),
45 
46   base_qrule   (NULL),
47   radial_qrule (NULL),
48   base_elem    (NULL),
49   base_fe      (NULL),
50 
51   // initialize the current_fe_type to all the same
52   // values as \p fet (since the FE families and coordinate
53   // map type should @e not change), but use an invalid order
54   // for the radial part (since this is the only order
55   // that may change!)\&.
56   // the data structures like \p phi etc are not initialized
57   // through the constructor, but throught reinit()
58   current_fe_type ( FEType(fet\&.order,
59                            fet\&.family,
60                            INVALID_ORDER,
61                            fet\&.radial_family,
62                            fet\&.inf_map) )
63 
64 {
65   // Sanity checks
66   libmesh_assert_equal_to (T_radial, fe_type\&.radial_family);
67   libmesh_assert_equal_to (T_map, fe_type\&.inf_map);
68 
69   // build the base_fe object, handle the AutoPtr
70   if (Dim != 1)
71     {
72       AutoPtr<FEBase> ap_fb(FEBase::build(Dim-1, fet));
73       base_fe = ap_fb\&.release();
74     }
75 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::~\fBInfFE\fP ()"
Desctructor\&. Clean up\&. 
.PP
Definition at line 82 of file inf_fe\&.C\&.
.PP
.nf
83 {
84   // delete pointers, if necessary
85   delete base_qrule;
86   base_qrule = NULL;
87 
88   delete radial_qrule;
89   radial_qrule = NULL;
90 
91   delete base_elem;
92   base_elem = NULL;
93 
94   delete base_fe;
95   base_fe = NULL;
96 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::attach_quadrature_rule (\fBQBase\fP *q)\fC [virtual]\fP"
The use of quadrature rules with the \fC\fBInfFE\fP\fP class is somewhat different from the approach of the \fC\fBFE\fP\fP class\&. While the \fC\fBFE\fP\fP class requires an appropriately initialized quadrature rule object, and simply uses it, the \fC\fBInfFE\fP\fP class requires only the quadrature rule object of the current \fC\fBFE\fP\fP class\&. From this \fCQBase*\fP, it determines the necessary data, and \fIbuilds\fP two appropriate quadrature classes, one for radial, and another for base integration, using the convenient \fC\fBQBase::build()\fP\fP method\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 103 of file inf_fe\&.C\&.
.PP
References libMesh::QBase::build(), libMesh::QBase::get_dim(), libMesh::QBase::get_order(), libMesh::libmesh_assert(), libMesh::AutoPtr< Tp >::release(), and libMesh::QBase::type()\&.
.PP
.nf
104 {
105   libmesh_assert(q);
106   libmesh_assert(base_fe);
107 
108   const Order base_int_order   = q->get_order();
109   const Order radial_int_order = static_cast<Order>(2 * (static_cast<unsigned int>(fe_type\&.radial_order) + 1) +2);
110   const unsigned int qrule_dim = q->get_dim();
111 
112   if (Dim != 1)
113     {
114       // build a Dim-1 quadrature rule of the type that we received
115       AutoPtr<QBase> apq( QBase::build(q->type(), qrule_dim-1, base_int_order) );
116       base_qrule = apq\&.release();
117       base_fe->attach_quadrature_rule(base_qrule);
118     }
119 
120   // in radial direction, always use Gauss quadrature
121   radial_qrule = new QGauss(1, radial_int_order);
122 
123   // currently not used\&. But maybe helpful to store the QBase*
124   // with which we initialized our own quadrature rules
125   qrule = q;
126 }
.fi
.SS "template<typename T> static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< T >::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputType of this class is not compatible with the output required for the requested \fCtype\fP 
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::calculate_norm(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::for(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_face_shape_functions(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::HPCoarsenTest::select_refinement(), and libMesh::Elem::volume()\&.
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBlibMesh::FEGenericBase\fP< \fBReal\fP >::build (const unsigned intdim, const \fBFEType\fP &fet)\fC [inherited]\fP"

.PP
Definition at line 184 of file fe_base\&.C\&.
.PP
References libMesh::BERNSTEIN, libMesh::CLOUGH, libMesh::FEType::family, libMesh::HERMITE, libMesh::HIERARCHIC, libMesh::L2_HIERARCHIC, libMesh::L2_LAGRANGE, libMesh::LAGRANGE, libMesh::MONOMIAL, libMesh::out, libMesh::SCALAR, libMesh::SUBDIVISION, libMesh::SZABAB, and libMesh::XYZ\&.
.PP
.nf
186 {
187   // The stupid AutoPtr<FEBase> ap(); return ap;
188   // construct is required to satisfy IBM's xlC
189 
190   switch (dim)
191     {
192       // 0D
193     case 0:
194       {
195         switch (fet\&.family)
196           {
197           case CLOUGH:
198             {
199               AutoPtr<FEBase> ap(new FE<0,CLOUGH>(fet));
200               return ap;
201             }
202 
203           case HERMITE:
204             {
205               AutoPtr<FEBase> ap(new FE<0,HERMITE>(fet));
206               return ap;
207             }
208 
209           case LAGRANGE:
210             {
211               AutoPtr<FEBase> ap(new FE<0,LAGRANGE>(fet));
212               return ap;
213             }
214 
215           case L2_LAGRANGE:
216             {
217               AutoPtr<FEBase> ap(new FE<0,L2_LAGRANGE>(fet));
218               return ap;
219             }
220 
221           case HIERARCHIC:
222             {
223               AutoPtr<FEBase> ap(new FE<0,HIERARCHIC>(fet));
224               return ap;
225             }
226 
227           case L2_HIERARCHIC:
228             {
229               AutoPtr<FEBase> ap(new FE<0,L2_HIERARCHIC>(fet));
230               return ap;
231             }
232 
233           case MONOMIAL:
234             {
235               AutoPtr<FEBase> ap(new FE<0,MONOMIAL>(fet));
236               return ap;
237             }
238 
239 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
240           case SZABAB:
241             {
242               AutoPtr<FEBase> ap(new FE<0,SZABAB>(fet));
243               return ap;
244             }
245 
246           case BERNSTEIN:
247             {
248               AutoPtr<FEBase> ap(new FE<0,BERNSTEIN>(fet));
249               return ap;
250             }
251 #endif
252 
253           case XYZ:
254             {
255               AutoPtr<FEBase> ap(new FEXYZ<0>(fet));
256               return ap;
257             }
258 
259           case SCALAR:
260             {
261               AutoPtr<FEBase> ap(new FEScalar<0>(fet));
262               return ap;
263             }
264 
265           default:
266             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
267             libmesh_error();
268           }
269       }
270       // 1D
271     case 1:
272       {
273         switch (fet\&.family)
274           {
275           case CLOUGH:
276             {
277               AutoPtr<FEBase> ap(new FE<1,CLOUGH>(fet));
278               return ap;
279             }
280 
281           case HERMITE:
282             {
283               AutoPtr<FEBase> ap(new FE<1,HERMITE>(fet));
284               return ap;
285             }
286 
287           case LAGRANGE:
288             {
289               AutoPtr<FEBase> ap(new FE<1,LAGRANGE>(fet));
290               return ap;
291             }
292 
293           case L2_LAGRANGE:
294             {
295               AutoPtr<FEBase> ap(new FE<1,L2_LAGRANGE>(fet));
296               return ap;
297             }
298 
299           case HIERARCHIC:
300             {
301               AutoPtr<FEBase> ap(new FE<1,HIERARCHIC>(fet));
302               return ap;
303             }
304 
305           case L2_HIERARCHIC:
306             {
307               AutoPtr<FEBase> ap(new FE<1,L2_HIERARCHIC>(fet));
308               return ap;
309             }
310 
311           case MONOMIAL:
312             {
313               AutoPtr<FEBase> ap(new FE<1,MONOMIAL>(fet));
314               return ap;
315             }
316 
317 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
318           case SZABAB:
319             {
320               AutoPtr<FEBase> ap(new FE<1,SZABAB>(fet));
321               return ap;
322             }
323 
324           case BERNSTEIN:
325             {
326               AutoPtr<FEBase> ap(new FE<1,BERNSTEIN>(fet));
327               return ap;
328             }
329 #endif
330 
331           case XYZ:
332             {
333               AutoPtr<FEBase> ap(new FEXYZ<1>(fet));
334               return ap;
335             }
336 
337           case SCALAR:
338             {
339               AutoPtr<FEBase> ap(new FEScalar<1>(fet));
340               return ap;
341             }
342 
343           default:
344             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
345             libmesh_error();
346           }
347       }
348 
349 
350       // 2D
351     case 2:
352       {
353         switch (fet\&.family)
354           {
355           case CLOUGH:
356             {
357               AutoPtr<FEBase> ap(new FE<2,CLOUGH>(fet));
358               return ap;
359             }
360 
361           case HERMITE:
362             {
363               AutoPtr<FEBase> ap(new FE<2,HERMITE>(fet));
364               return ap;
365             }
366 
367           case LAGRANGE:
368             {
369               AutoPtr<FEBase> ap(new FE<2,LAGRANGE>(fet));
370               return ap;
371             }
372 
373           case L2_LAGRANGE:
374             {
375               AutoPtr<FEBase> ap(new FE<2,L2_LAGRANGE>(fet));
376               return ap;
377             }
378 
379           case HIERARCHIC:
380             {
381               AutoPtr<FEBase> ap(new FE<2,HIERARCHIC>(fet));
382               return ap;
383             }
384 
385           case L2_HIERARCHIC:
386             {
387               AutoPtr<FEBase> ap(new FE<2,L2_HIERARCHIC>(fet));
388               return ap;
389             }
390 
391           case MONOMIAL:
392             {
393               AutoPtr<FEBase> ap(new FE<2,MONOMIAL>(fet));
394               return ap;
395             }
396 
397 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
398           case SZABAB:
399             {
400               AutoPtr<FEBase> ap(new FE<2,SZABAB>(fet));
401               return ap;
402             }
403 
404           case BERNSTEIN:
405             {
406               AutoPtr<FEBase> ap(new FE<2,BERNSTEIN>(fet));
407               return ap;
408             }
409 #endif
410 
411           case XYZ:
412             {
413               AutoPtr<FEBase> ap(new FEXYZ<2>(fet));
414               return ap;
415             }
416 
417           case SCALAR:
418             {
419               AutoPtr<FEBase> ap(new FEScalar<2>(fet));
420               return ap;
421             }
422 
423           case SUBDIVISION:
424             {
425               AutoPtr<FEBase> ap(new FESubdivision(fet));
426               return ap;
427             }
428 
429           default:
430             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
431             libmesh_error();
432           }
433       }
434 
435 
436       // 3D
437     case 3:
438       {
439         switch (fet\&.family)
440           {
441           case CLOUGH:
442             {
443               libMesh::out << "ERROR: Clough-Tocher elements currently only support 1D and 2D"
444                            << std::endl;
445               libmesh_error();
446             }
447 
448           case HERMITE:
449             {
450               AutoPtr<FEBase> ap(new FE<3,HERMITE>(fet));
451               return ap;
452             }
453 
454           case LAGRANGE:
455             {
456               AutoPtr<FEBase> ap(new FE<3,LAGRANGE>(fet));
457               return ap;
458             }
459 
460           case L2_LAGRANGE:
461             {
462               AutoPtr<FEBase> ap(new FE<3,L2_LAGRANGE>(fet));
463               return ap;
464             }
465 
466           case HIERARCHIC:
467             {
468               AutoPtr<FEBase> ap(new FE<3,HIERARCHIC>(fet));
469               return ap;
470             }
471 
472           case L2_HIERARCHIC:
473             {
474               AutoPtr<FEBase> ap(new FE<3,L2_HIERARCHIC>(fet));
475               return ap;
476             }
477 
478           case MONOMIAL:
479             {
480               AutoPtr<FEBase> ap(new FE<3,MONOMIAL>(fet));
481               return ap;
482             }
483 
484 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
485           case SZABAB:
486             {
487               AutoPtr<FEBase> ap(new FE<3,SZABAB>(fet));
488               return ap;
489             }
490 
491           case BERNSTEIN:
492             {
493               AutoPtr<FEBase> ap(new FE<3,BERNSTEIN>(fet));
494               return ap;
495             }
496 #endif
497 
498           case XYZ:
499             {
500               AutoPtr<FEBase> ap(new FEXYZ<3>(fet));
501               return ap;
502             }
503 
504           case SCALAR:
505             {
506               AutoPtr<FEBase> ap(new FEScalar<3>(fet));
507               return ap;
508             }
509 
510           default:
511             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
512             libmesh_error();
513           }
514       }
515 
516     default:
517       libmesh_error();
518     }
519 
520   libmesh_error();
521   AutoPtr<FEBase> ap(NULL);
522   return ap;
523 }
.fi
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBRealGradient\fP > > \fBlibMesh::FEGenericBase\fP< \fBRealGradient\fP >::build (const unsigned intdim, const \fBFEType\fP &fet)\fC [inherited]\fP"

.PP
Definition at line 529 of file fe_base\&.C\&.
.PP
References libMesh::FEType::family, libMesh::LAGRANGE_VEC, libMesh::NEDELEC_ONE, and libMesh::out\&.
.PP
.nf
531 {
532   // The stupid AutoPtr<FEBase> ap(); return ap;
533   // construct is required to satisfy IBM's xlC
534 
535   switch (dim)
536     {
537       // 0D
538     case 0:
539       {
540         switch (fet\&.family)
541           {
542           case LAGRANGE_VEC:
543             {
544               AutoPtr<FEVectorBase> ap( new FELagrangeVec<0>(fet) );
545               return ap;
546             }
547           default:
548             {
549               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
550               libmesh_error();
551             }
552           }
553       }
554     case 1:
555       {
556         switch (fet\&.family)
557           {
558           case LAGRANGE_VEC:
559             {
560               AutoPtr<FEVectorBase> ap( new FELagrangeVec<1>(fet) );
561               return ap;
562             }
563           default:
564             {
565               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
566               libmesh_error();
567             }
568           }
569       }
570     case 2:
571       {
572         switch (fet\&.family)
573           {
574           case LAGRANGE_VEC:
575             {
576               AutoPtr<FEVectorBase> ap( new FELagrangeVec<2>(fet) );
577               return ap;
578             }
579           case NEDELEC_ONE:
580             {
581               AutoPtr<FEVectorBase> ap( new FENedelecOne<2>(fet) );
582               return ap;
583             }
584           default:
585             {
586               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
587               libmesh_error();
588             }
589           }
590       }
591     case 3:
592       {
593         switch (fet\&.family)
594           {
595           case LAGRANGE_VEC:
596             {
597               AutoPtr<FEVectorBase> ap( new FELagrangeVec<3>(fet) );
598               return ap;
599             }
600           case NEDELEC_ONE:
601             {
602               AutoPtr<FEVectorBase> ap( new FENedelecOne<3>(fet) );
603               return ap;
604             }
605           default:
606             {
607               libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
608               libmesh_error();
609             }
610           }
611       }
612 
613     default:
614       libmesh_error();
615 
616     } // switch(dim)
617 
618   libmesh_error();
619   AutoPtr<FEVectorBase> ap(NULL);
620   return ap;
621 }
.fi
.SS "template<typename T> static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< T >::build_InfFE (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific infinite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputShape of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBReal\fP > > \fBlibMesh::FEGenericBase\fP< \fBReal\fP >::build_InfFE (const unsigned intdim, const \fBFEType\fP &fet)\fC [inherited]\fP"

.PP
Definition at line 634 of file fe_base\&.C\&.
.PP
References libMesh::CARTESIAN, libMesh::err, libMesh::FEType::inf_map, libMesh::INFINITE_MAP, libMesh::JACOBI_20_00, libMesh::JACOBI_30_00, libMesh::LAGRANGE, libMesh::LEGENDRE, and libMesh::FEType::radial_family\&.
.PP
.nf
636 {
637   // The stupid AutoPtr<FEBase> ap(); return ap;
638   // construct is required to satisfy IBM's xlC
639 
640   switch (dim)
641     {
642 
643       // 1D
644     case 1:
645       {
646         switch (fet\&.radial_family)
647           {
648           case INFINITE_MAP:
649             {
650               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
651                            << " with FEFamily = " << fet\&.radial_family << std::endl;
652               libmesh_error();
653             }
654 
655           case JACOBI_20_00:
656             {
657               switch (fet\&.inf_map)
658                 {
659                 case CARTESIAN:
660                   {
661                     AutoPtr<FEBase> ap(new InfFE<1,JACOBI_20_00,CARTESIAN>(fet));
662                     return ap;
663                   }
664                 default:
665                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
666                                << " with InfMapType = " << fet\&.inf_map << std::endl;
667                   libmesh_error();
668                 }
669             }
670 
671           case JACOBI_30_00:
672             {
673               switch (fet\&.inf_map)
674                 {
675                 case CARTESIAN:
676                   {
677                     AutoPtr<FEBase> ap(new InfFE<1,JACOBI_30_00,CARTESIAN>(fet));
678                     return ap;
679                   }
680                 default:
681                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
682                                << " with InfMapType = " << fet\&.inf_map << std::endl;
683                   libmesh_error();
684                 }
685             }
686 
687           case LEGENDRE:
688             {
689               switch (fet\&.inf_map)
690                 {
691                 case CARTESIAN:
692                   {
693                     AutoPtr<FEBase> ap(new InfFE<1,LEGENDRE,CARTESIAN>(fet));
694                     return ap;
695                   }
696                 default:
697                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
698                                << " with InfMapType = " << fet\&.inf_map << std::endl;
699                   libmesh_error();
700                 }
701             }
702 
703           case LAGRANGE:
704             {
705               switch (fet\&.inf_map)
706                 {
707                 case CARTESIAN:
708                   {
709                     AutoPtr<FEBase> ap(new InfFE<1,LAGRANGE,CARTESIAN>(fet));
710                     return ap;
711                   }
712                 default:
713                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
714                                << " with InfMapType = " << fet\&.inf_map << std::endl;
715                   libmesh_error();
716                 }
717             }
718 
719 
720 
721           default:
722             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
723             libmesh_error();
724           }
725 
726       }
727 
728 
729 
730 
731       // 2D
732     case 2:
733       {
734         switch (fet\&.radial_family)
735           {
736           case INFINITE_MAP:
737             {
738               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
739                            << " with FEFamily = " << fet\&.radial_family << std::endl;
740               libmesh_error();
741             }
742 
743           case JACOBI_20_00:
744             {
745               switch (fet\&.inf_map)
746                 {
747                 case CARTESIAN:
748                   {
749                     AutoPtr<FEBase> ap(new InfFE<2,JACOBI_20_00,CARTESIAN>(fet));
750                     return ap;
751                   }
752                 default:
753                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
754                                << " with InfMapType = " << fet\&.inf_map << std::endl;
755                   libmesh_error();
756                 }
757             }
758 
759           case JACOBI_30_00:
760             {
761               switch (fet\&.inf_map)
762                 {
763                 case CARTESIAN:
764                   {
765                     AutoPtr<FEBase> ap(new InfFE<2,JACOBI_30_00,CARTESIAN>(fet));
766                     return ap;
767                   }
768                 default:
769                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
770                                << " with InfMapType = " << fet\&.inf_map << std::endl;
771                   libmesh_error();
772                 }
773             }
774 
775           case LEGENDRE:
776             {
777               switch (fet\&.inf_map)
778                 {
779                 case CARTESIAN:
780                   {
781                     AutoPtr<FEBase> ap(new InfFE<2,LEGENDRE,CARTESIAN>(fet));
782                     return ap;
783                   }
784                 default:
785                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
786                                << " with InfMapType = " << fet\&.inf_map << std::endl;
787                   libmesh_error();
788                 }
789             }
790 
791           case LAGRANGE:
792             {
793               switch (fet\&.inf_map)
794                 {
795                 case CARTESIAN:
796                   {
797                     AutoPtr<FEBase> ap(new InfFE<2,LAGRANGE,CARTESIAN>(fet));
798                     return ap;
799                   }
800                 default:
801                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
802                                << " with InfMapType = " << fet\&.inf_map << std::endl;
803                   libmesh_error();
804                 }
805             }
806 
807 
808 
809           default:
810             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
811             libmesh_error();
812           }
813 
814       }
815 
816 
817 
818 
819       // 3D
820     case 3:
821       {
822         switch (fet\&.radial_family)
823           {
824           case INFINITE_MAP:
825             {
826               libMesh::err << "ERROR: Don't build an infinite element " << std::endl
827                            << " with FEFamily = " << fet\&.radial_family << std::endl;
828               libmesh_error();
829             }
830 
831           case JACOBI_20_00:
832             {
833               switch (fet\&.inf_map)
834                 {
835                 case CARTESIAN:
836                   {
837                     AutoPtr<FEBase> ap(new InfFE<3,JACOBI_20_00,CARTESIAN>(fet));
838                     return ap;
839                   }
840                 default:
841                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
842                                << " with InfMapType = " << fet\&.inf_map << std::endl;
843                   libmesh_error();
844                 }
845             }
846 
847           case JACOBI_30_00:
848             {
849               switch (fet\&.inf_map)
850                 {
851                 case CARTESIAN:
852                   {
853                     AutoPtr<FEBase> ap(new InfFE<3,JACOBI_30_00,CARTESIAN>(fet));
854                     return ap;
855                   }
856                 default:
857                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
858                                << " with InfMapType = " << fet\&.inf_map << std::endl;
859                   libmesh_error();
860                 }
861             }
862 
863           case LEGENDRE:
864             {
865               switch (fet\&.inf_map)
866                 {
867                 case CARTESIAN:
868                   {
869                     AutoPtr<FEBase> ap(new InfFE<3,LEGENDRE,CARTESIAN>(fet));
870                     return ap;
871                   }
872                 default:
873                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
874                                << " with InfMapType = " << fet\&.inf_map << std::endl;
875                   libmesh_error();
876                 }
877             }
878 
879           case LAGRANGE:
880             {
881               switch (fet\&.inf_map)
882                 {
883                 case CARTESIAN:
884                   {
885                     AutoPtr<FEBase> ap(new InfFE<3,LAGRANGE,CARTESIAN>(fet));
886                     return ap;
887                   }
888                 default:
889                   libMesh::err << "ERROR: Don't build an infinite element " << std::endl
890                                << " with InfMapType = " << fet\&.inf_map << std::endl;
891                   libmesh_error();
892                 }
893             }
894 
895 
896 
897           default:
898             libMesh::err << "ERROR: Bad FEType\&.radial_family= " << fet\&.radial_family << std::endl;
899             libmesh_error();
900           }
901       }
902 
903     default:
904       libmesh_error();
905     }
906 
907   libmesh_error();
908   AutoPtr<FEBase> ap(NULL);
909   return ap;
910 }
.fi
.SS "template<> \fBAutoPtr\fP< \fBFEGenericBase\fP< \fBRealGradient\fP > > \fBlibMesh::FEGenericBase\fP< \fBRealGradient\fP >::build_InfFE (const unsigned int, const \fBFEType\fP &)\fC [inherited]\fP"

.PP
Definition at line 916 of file fe_base\&.C\&.
.PP
.nf
918 {
919   // No vector types defined\&.\&.\&. YET\&.
920   libmesh_error();
921   AutoPtr<FEVectorBase> ap(NULL);
922   return ap;
923 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::coarsened_dof_values (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &dof_map, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned intvar, const booluse_old_dof_indices = \fCfalse\fP)\fC [static]\fP, \fC [inherited]\fP"
Creates a local projection on \fCcoarse_elem\fP, based on the DoF values in \fCglobal_vector\fP for it's children\&. 
.PP
Definition at line 1036 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::C_ONE, libMesh::Elem::child(), libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::FEType::default_quadrature_rule(), libMesh::dim, libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::FEInterface::dofs_on_edge(), libMesh::FEInterface::dofs_on_side(), libMesh::TensorTools::inner_product(), libMesh::FEInterface::inverse_map(), libMesh::Elem::is_child_on_edge(), libMesh::Elem::is_child_on_side(), libMesh::Elem::is_vertex(), libMesh::libmesh_assert(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::n_children(), libMesh::FEInterface::n_dofs(), libMesh::FEInterface::n_dofs_at_node(), libMesh::Elem::n_edges(), n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::DofMap::old_dof_indices(), libMesh::FEType::order, libMesh::Elem::p_level(), libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::TOLERANCE, libMesh::Elem::type(), libMesh::DofMap::variable_type(), libMesh::DenseMatrix< T >::zero(), libMesh::DenseVector< T >::zero(), and libMesh::zero\&.
.PP
Referenced by libMesh::JumpErrorEstimator::estimate_error(), and libMesh::for()\&.
.PP
.nf
1042 {
1043   // Side/edge local DOF indices
1044   std::vector<unsigned int> new_side_dofs, old_side_dofs;
1045 
1046   // FIXME: what about 2D shells in 3D space?
1047   unsigned int dim = elem->dim();
1048 
1049   // We use local FE objects for now
1050   // FIXME: we should use more, external objects instead for efficiency
1051   const FEType& base_fe_type = dof_map\&.variable_type(var);
1052   AutoPtr<FEGenericBase<OutputShape> > fe
1053     (FEGenericBase<OutputShape>::build(dim, base_fe_type));
1054   AutoPtr<FEGenericBase<OutputShape> > fe_coarse
1055     (FEGenericBase<OutputShape>::build(dim, base_fe_type));
1056 
1057   AutoPtr<QBase> qrule     (base_fe_type\&.default_quadrature_rule(dim));
1058   AutoPtr<QBase> qedgerule (base_fe_type\&.default_quadrature_rule(1));
1059   AutoPtr<QBase> qsiderule (base_fe_type\&.default_quadrature_rule(dim-1));
1060   std::vector<Point> coarse_qpoints;
1061 
1062   // The values of the shape functions at the quadrature
1063   // points
1064   const std::vector<std::vector<OutputShape> >& phi_values =
1065     fe->get_phi();
1066   const std::vector<std::vector<OutputShape> >& phi_coarse =
1067     fe_coarse->get_phi();
1068 
1069   // The gradients of the shape functions at the quadrature
1070   // points on the child element\&.
1071   const std::vector<std::vector<OutputGradient> > *dphi_values =
1072     NULL;
1073   const std::vector<std::vector<OutputGradient> > *dphi_coarse =
1074     NULL;
1075 
1076   const FEContinuity cont = fe->get_continuity();
1077 
1078   if (cont == C_ONE)
1079     {
1080       const std::vector<std::vector<OutputGradient> >&
1081         ref_dphi_values = fe->get_dphi();
1082       dphi_values = &ref_dphi_values;
1083       const std::vector<std::vector<OutputGradient> >&
1084         ref_dphi_coarse = fe_coarse->get_dphi();
1085       dphi_coarse = &ref_dphi_coarse;
1086     }
1087 
1088   // The Jacobian * quadrature weight at the quadrature points
1089   const std::vector<Real>& JxW =
1090     fe->get_JxW();
1091 
1092   // The XYZ locations of the quadrature points on the
1093   // child element
1094   const std::vector<Point>& xyz_values =
1095     fe->get_xyz();
1096 
1097 
1098 
1099   FEType fe_type = base_fe_type, temp_fe_type;
1100   const ElemType elem_type = elem->type();
1101   fe_type\&.order = static_cast<Order>(fe_type\&.order +
1102                                      elem->max_descendant_p_level());
1103 
1104   // Number of nodes on parent element
1105   const unsigned int n_nodes = elem->n_nodes();
1106 
1107   // Number of dofs on parent element
1108   const unsigned int new_n_dofs =
1109     FEInterface::n_dofs(dim, fe_type, elem_type);
1110 
1111   // Fixed vs\&. free DoFs on edge/face projections
1112   std::vector<char> dof_is_fixed(new_n_dofs, false); // bools
1113   std::vector<int> free_dof(new_n_dofs, 0);
1114 
1115   DenseMatrix<Real> Ke;
1116   DenseVector<Number> Fe;
1117   Ue\&.resize(new_n_dofs); Ue\&.zero();
1118 
1119 
1120   // When coarsening, in general, we need a series of
1121   // projections to ensure a unique and continuous
1122   // solution\&.  We start by interpolating nodes, then
1123   // hold those fixed and project edges, then
1124   // hold those fixed and project faces, then
1125   // hold those fixed and project interiors
1126 
1127   // Copy node values first
1128   {
1129     std::vector<dof_id_type> node_dof_indices;
1130     if (use_old_dof_indices)
1131       dof_map\&.old_dof_indices (elem, node_dof_indices, var);
1132     else
1133       dof_map\&.dof_indices (elem, node_dof_indices, var);
1134 
1135     unsigned int current_dof = 0;
1136     for (unsigned int n=0; n!= n_nodes; ++n)
1137       {
1138         // FIXME: this should go through the DofMap,
1139         // not duplicate dof_indices code badly!
1140         const unsigned int my_nc =
1141           FEInterface::n_dofs_at_node (dim, fe_type,
1142                                        elem_type, n);
1143         if (!elem->is_vertex(n))
1144           {
1145             current_dof += my_nc;
1146             continue;
1147           }
1148 
1149         temp_fe_type = base_fe_type;
1150         // We're assuming here that child n shares vertex n,
1151         // which is wrong on non-simplices right now
1152         // \&.\&.\&. but this code isn't necessary except on elements
1153         // where p refinement creates more vertex dofs; we have
1154         // no such elements yet\&.
1155         /*
1156           if (elem->child(n)->p_level() < elem->p_level())
1157           {
1158           temp_fe_type\&.order =
1159           static_cast<Order>(temp_fe_type\&.order +
1160           elem->child(n)->p_level());
1161           }
1162         */
1163         const unsigned int nc =
1164           FEInterface::n_dofs_at_node (dim, temp_fe_type,
1165                                        elem_type, n);
1166         for (unsigned int i=0; i!= nc; ++i)
1167           {
1168             Ue(current_dof) =
1169               old_vector(node_dof_indices[current_dof]);
1170             dof_is_fixed[current_dof] = true;
1171             current_dof++;
1172           }
1173       }
1174   }
1175 
1176   // In 3D, project any edge values next
1177   if (dim > 2 && cont != DISCONTINUOUS)
1178     for (unsigned int e=0; e != elem->n_edges(); ++e)
1179       {
1180         FEInterface::dofs_on_edge(elem, dim, fe_type,
1181                                   e, new_side_dofs);
1182 
1183         // Some edge dofs are on nodes and already
1184         // fixed, others are free to calculate
1185         unsigned int free_dofs = 0;
1186         for (unsigned int i=0; i !=
1187                new_side_dofs\&.size(); ++i)
1188           if (!dof_is_fixed[new_side_dofs[i]])
1189             free_dof[free_dofs++] = i;
1190         Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1191         Fe\&.resize (free_dofs); Fe\&.zero();
1192         // The new edge coefficients
1193         DenseVector<Number> Uedge(free_dofs);
1194 
1195         // Add projection terms from each child sharing
1196         // this edge
1197         for (unsigned int c=0; c != elem->n_children();
1198              ++c)
1199           {
1200             if (!elem->is_child_on_edge(c,e))
1201               continue;
1202             Elem *child = elem->child(c);
1203 
1204             std::vector<dof_id_type> child_dof_indices;
1205             if (use_old_dof_indices)
1206               dof_map\&.old_dof_indices (child,
1207                                        child_dof_indices, var);
1208             else
1209               dof_map\&.dof_indices (child,
1210                                    child_dof_indices, var);
1211             const unsigned int child_n_dofs =
1212               libmesh_cast_int<unsigned int>
1213               (child_dof_indices\&.size());
1214 
1215             temp_fe_type = base_fe_type;
1216             temp_fe_type\&.order =
1217               static_cast<Order>(temp_fe_type\&.order +
1218                                  child->p_level());
1219 
1220             FEInterface::dofs_on_edge(child, dim,
1221                                       temp_fe_type, e, old_side_dofs);
1222 
1223             // Initialize both child and parent FE data
1224             // on the child's edge
1225             fe->attach_quadrature_rule (qedgerule\&.get());
1226             fe->edge_reinit (child, e);
1227             const unsigned int n_qp = qedgerule->n_points();
1228 
1229             FEInterface::inverse_map (dim, fe_type, elem,
1230                                       xyz_values, coarse_qpoints);
1231 
1232             fe_coarse->reinit(elem, &coarse_qpoints);
1233 
1234             // Loop over the quadrature points
1235             for (unsigned int qp=0; qp<n_qp; qp++)
1236               {
1237                 // solution value at the quadrature point
1238                 OutputNumber fineval = libMesh::zero;
1239                 // solution grad at the quadrature point
1240                 OutputNumberGradient finegrad;
1241 
1242                 // Sum the solution values * the DOF
1243                 // values at the quadrature point to
1244                 // get the solution value and gradient\&.
1245                 for (unsigned int i=0; i<child_n_dofs;
1246                      i++)
1247                   {
1248                     fineval +=
1249                       (old_vector(child_dof_indices[i])*
1250                        phi_values[i][qp]);
1251                     if (cont == C_ONE)
1252                       finegrad += (*dphi_values)[i][qp] *
1253                         old_vector(child_dof_indices[i]);
1254                   }
1255 
1256                 // Form edge projection matrix
1257                 for (unsigned int sidei=0, freei=0;
1258                      sidei != new_side_dofs\&.size();
1259                      ++sidei)
1260                   {
1261                     unsigned int i = new_side_dofs[sidei];
1262                     // fixed DoFs aren't test functions
1263                     if (dof_is_fixed[i])
1264                       continue;
1265                     for (unsigned int sidej=0, freej=0;
1266                          sidej != new_side_dofs\&.size();
1267                          ++sidej)
1268                       {
1269                         unsigned int j =
1270                           new_side_dofs[sidej];
1271                         if (dof_is_fixed[j])
1272                           Fe(freei) -=
1273                             TensorTools::inner_product(phi_coarse[i][qp],
1274                                                        phi_coarse[j][qp]) *
1275                             JxW[qp] * Ue(j);
1276                         else
1277                           Ke(freei,freej) +=
1278                             TensorTools::inner_product(phi_coarse[i][qp],
1279                                                        phi_coarse[j][qp]) *
1280                             JxW[qp];
1281                         if (cont == C_ONE)
1282                           {
1283                             if (dof_is_fixed[j])
1284                               Fe(freei) -=
1285                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1286                                                            (*dphi_coarse)[j][qp]) *
1287                                 JxW[qp] * Ue(j);
1288                             else
1289                               Ke(freei,freej) +=
1290                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1291                                                            (*dphi_coarse)[j][qp]) *
1292                                 JxW[qp];
1293                           }
1294                         if (!dof_is_fixed[j])
1295                           freej++;
1296                       }
1297                     Fe(freei) += TensorTools::inner_product(phi_coarse[i][qp],
1298                                                             fineval) * JxW[qp];
1299                     if (cont == C_ONE)
1300                       Fe(freei) +=
1301                         TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1302                     freei++;
1303                   }
1304               }
1305           }
1306         Ke\&.cholesky_solve(Fe, Uedge);
1307 
1308         // Transfer new edge solutions to element
1309         for (unsigned int i=0; i != free_dofs; ++i)
1310           {
1311             Number &ui = Ue(new_side_dofs[free_dof[i]]);
1312             libmesh_assert(std::abs(ui) < TOLERANCE ||
1313                            std::abs(ui - Uedge(i)) < TOLERANCE);
1314             ui = Uedge(i);
1315             dof_is_fixed[new_side_dofs[free_dof[i]]] =
1316               true;
1317           }
1318       }
1319 
1320   // Project any side values (edges in 2D, faces in 3D)
1321   if (dim > 1 && cont != DISCONTINUOUS)
1322     for (unsigned int s=0; s != elem->n_sides(); ++s)
1323       {
1324         FEInterface::dofs_on_side(elem, dim, fe_type,
1325                                   s, new_side_dofs);
1326 
1327         // Some side dofs are on nodes/edges and already
1328         // fixed, others are free to calculate
1329         unsigned int free_dofs = 0;
1330         for (unsigned int i=0; i !=
1331                new_side_dofs\&.size(); ++i)
1332           if (!dof_is_fixed[new_side_dofs[i]])
1333             free_dof[free_dofs++] = i;
1334         Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1335         Fe\&.resize (free_dofs); Fe\&.zero();
1336         // The new side coefficients
1337         DenseVector<Number> Uside(free_dofs);
1338 
1339         // Add projection terms from each child sharing
1340         // this side
1341         for (unsigned int c=0; c != elem->n_children();
1342              ++c)
1343           {
1344             if (!elem->is_child_on_side(c,s))
1345               continue;
1346             Elem *child = elem->child(c);
1347 
1348             std::vector<dof_id_type> child_dof_indices;
1349             if (use_old_dof_indices)
1350               dof_map\&.old_dof_indices (child,
1351                                        child_dof_indices, var);
1352             else
1353               dof_map\&.dof_indices (child,
1354                                    child_dof_indices, var);
1355             const unsigned int child_n_dofs =
1356               libmesh_cast_int<unsigned int>
1357               (child_dof_indices\&.size());
1358 
1359             temp_fe_type = base_fe_type;
1360             temp_fe_type\&.order =
1361               static_cast<Order>(temp_fe_type\&.order +
1362                                  child->p_level());
1363 
1364             FEInterface::dofs_on_side(child, dim,
1365                                       temp_fe_type, s, old_side_dofs);
1366 
1367             // Initialize both child and parent FE data
1368             // on the child's side
1369             fe->attach_quadrature_rule (qsiderule\&.get());
1370             fe->reinit (child, s);
1371             const unsigned int n_qp = qsiderule->n_points();
1372 
1373             FEInterface::inverse_map (dim, fe_type, elem,
1374                                       xyz_values, coarse_qpoints);
1375 
1376             fe_coarse->reinit(elem, &coarse_qpoints);
1377 
1378             // Loop over the quadrature points
1379             for (unsigned int qp=0; qp<n_qp; qp++)
1380               {
1381                 // solution value at the quadrature point
1382                 OutputNumber fineval = libMesh::zero;
1383                 // solution grad at the quadrature point
1384                 OutputNumberGradient finegrad;
1385 
1386                 // Sum the solution values * the DOF
1387                 // values at the quadrature point to
1388                 // get the solution value and gradient\&.
1389                 for (unsigned int i=0; i<child_n_dofs;
1390                      i++)
1391                   {
1392                     fineval +=
1393                       old_vector(child_dof_indices[i]) *
1394                       phi_values[i][qp];
1395                     if (cont == C_ONE)
1396                       finegrad += (*dphi_values)[i][qp] *
1397                         old_vector(child_dof_indices[i]);
1398                   }
1399 
1400                 // Form side projection matrix
1401                 for (unsigned int sidei=0, freei=0;
1402                      sidei != new_side_dofs\&.size();
1403                      ++sidei)
1404                   {
1405                     unsigned int i = new_side_dofs[sidei];
1406                     // fixed DoFs aren't test functions
1407                     if (dof_is_fixed[i])
1408                       continue;
1409                     for (unsigned int sidej=0, freej=0;
1410                          sidej != new_side_dofs\&.size();
1411                          ++sidej)
1412                       {
1413                         unsigned int j =
1414                           new_side_dofs[sidej];
1415                         if (dof_is_fixed[j])
1416                           Fe(freei) -=
1417                             TensorTools::inner_product(phi_coarse[i][qp],
1418                                                        phi_coarse[j][qp]) *
1419                             JxW[qp] * Ue(j);
1420                         else
1421                           Ke(freei,freej) +=
1422                             TensorTools::inner_product(phi_coarse[i][qp],
1423                                                        phi_coarse[j][qp]) *
1424                             JxW[qp];
1425                         if (cont == C_ONE)
1426                           {
1427                             if (dof_is_fixed[j])
1428                               Fe(freei) -=
1429                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1430                                                            (*dphi_coarse)[j][qp]) *
1431                                 JxW[qp] * Ue(j);
1432                             else
1433                               Ke(freei,freej) +=
1434                                 TensorTools::inner_product((*dphi_coarse)[i][qp],
1435                                                            (*dphi_coarse)[j][qp]) *
1436                                 JxW[qp];
1437                           }
1438                         if (!dof_is_fixed[j])
1439                           freej++;
1440                       }
1441                     Fe(freei) += TensorTools::inner_product(fineval, phi_coarse[i][qp]) * JxW[qp];
1442                     if (cont == C_ONE)
1443                       Fe(freei) +=
1444                         TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1445                     freei++;
1446                   }
1447               }
1448           }
1449         Ke\&.cholesky_solve(Fe, Uside);
1450 
1451         // Transfer new side solutions to element
1452         for (unsigned int i=0; i != free_dofs; ++i)
1453           {
1454             Number &ui = Ue(new_side_dofs[free_dof[i]]);
1455             libmesh_assert(std::abs(ui) < TOLERANCE ||
1456                            std::abs(ui - Uside(i)) < TOLERANCE);
1457             ui = Uside(i);
1458             dof_is_fixed[new_side_dofs[free_dof[i]]] =
1459               true;
1460           }
1461       }
1462 
1463   // Project the interior values, finally
1464 
1465   // Some interior dofs are on nodes/edges/sides and
1466   // already fixed, others are free to calculate
1467   unsigned int free_dofs = 0;
1468   for (unsigned int i=0; i != new_n_dofs; ++i)
1469     if (!dof_is_fixed[i])
1470       free_dof[free_dofs++] = i;
1471   Ke\&.resize (free_dofs, free_dofs); Ke\&.zero();
1472   Fe\&.resize (free_dofs); Fe\&.zero();
1473   // The new interior coefficients
1474   DenseVector<Number> Uint(free_dofs);
1475 
1476   // Add projection terms from each child
1477   for (unsigned int c=0; c != elem->n_children(); ++c)
1478     {
1479       Elem *child = elem->child(c);
1480 
1481       std::vector<dof_id_type> child_dof_indices;
1482       if (use_old_dof_indices)
1483         dof_map\&.old_dof_indices (child,
1484                                  child_dof_indices, var);
1485       else
1486         dof_map\&.dof_indices (child,
1487                              child_dof_indices, var);
1488       const unsigned int child_n_dofs =
1489         libmesh_cast_int<unsigned int>
1490         (child_dof_indices\&.size());
1491 
1492       // Initialize both child and parent FE data
1493       // on the child's quadrature points
1494       fe->attach_quadrature_rule (qrule\&.get());
1495       fe->reinit (child);
1496       const unsigned int n_qp = qrule->n_points();
1497 
1498       FEInterface::inverse_map (dim, fe_type, elem,
1499                                 xyz_values, coarse_qpoints);
1500 
1501       fe_coarse->reinit(elem, &coarse_qpoints);
1502 
1503       // Loop over the quadrature points
1504       for (unsigned int qp=0; qp<n_qp; qp++)
1505         {
1506           // solution value at the quadrature point
1507           OutputNumber fineval = libMesh::zero;
1508           // solution grad at the quadrature point
1509           OutputNumberGradient finegrad;
1510 
1511           // Sum the solution values * the DOF
1512           // values at the quadrature point to
1513           // get the solution value and gradient\&.
1514           for (unsigned int i=0; i<child_n_dofs; i++)
1515             {
1516               fineval +=
1517                 (old_vector(child_dof_indices[i]) *
1518                  phi_values[i][qp]);
1519               if (cont == C_ONE)
1520                 finegrad += (*dphi_values)[i][qp] *
1521                   old_vector(child_dof_indices[i]);
1522             }
1523 
1524           // Form interior projection matrix
1525           for (unsigned int i=0, freei=0;
1526                i != new_n_dofs; ++i)
1527             {
1528               // fixed DoFs aren't test functions
1529               if (dof_is_fixed[i])
1530                 continue;
1531               for (unsigned int j=0, freej=0; j !=
1532                      new_n_dofs; ++j)
1533                 {
1534                   if (dof_is_fixed[j])
1535                     Fe(freei) -=
1536                       TensorTools::inner_product(phi_coarse[i][qp],
1537                                                  phi_coarse[j][qp]) *
1538                       JxW[qp] * Ue(j);
1539                   else
1540                     Ke(freei,freej) +=
1541                       TensorTools::inner_product(phi_coarse[i][qp],
1542                                                  phi_coarse[j][qp]) *
1543                       JxW[qp];
1544                   if (cont == C_ONE)
1545                     {
1546                       if (dof_is_fixed[j])
1547                         Fe(freei) -=
1548                           TensorTools::inner_product((*dphi_coarse)[i][qp],
1549                                                      (*dphi_coarse)[j][qp]) *
1550                           JxW[qp] * Ue(j);
1551                       else
1552                         Ke(freei,freej) +=
1553                           TensorTools::inner_product((*dphi_coarse)[i][qp],
1554                                                      (*dphi_coarse)[j][qp]) *
1555                           JxW[qp];
1556                     }
1557                   if (!dof_is_fixed[j])
1558                     freej++;
1559                 }
1560               Fe(freei) += TensorTools::inner_product(phi_coarse[i][qp], fineval) *
1561                 JxW[qp];
1562               if (cont == C_ONE)
1563                 Fe(freei) += TensorTools::inner_product(finegrad, (*dphi_coarse)[i][qp]) * JxW[qp];
1564               freei++;
1565             }
1566         }
1567     }
1568   Ke\&.cholesky_solve(Fe, Uint);
1569 
1570   // Transfer new interior solutions to element
1571   for (unsigned int i=0; i != free_dofs; ++i)
1572     {
1573       Number &ui = Ue(free_dof[i]);
1574       libmesh_assert(std::abs(ui) < TOLERANCE ||
1575                      std::abs(ui - Uint(i)) < TOLERANCE);
1576       ui = Uint(i);
1577       // We should be fixing all dofs by now; no need to keep track of
1578       // that unless we're debugging
1579 #ifndef NDEBUG
1580       dof_is_fixed[free_dof[i]] = true;
1581 #endif
1582     }
1583 
1584 #ifndef NDEBUG
1585   // Make sure every DoF got reached!
1586   for (unsigned int i=0; i != new_n_dofs; ++i)
1587     libmesh_assert(dof_is_fixed[i]);
1588 #endif
1589 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::combine_base_radial (const \fBElem\fP *inf_elem)\fC [protected]\fP"
Combines the shape functions, which were formed in \fCinit_shape_functions(Elem*)\fP, with geometric data\&. Has to be called every time the geometric configuration changes\&. Afterwards, the fields are ready to be used to compute global derivatives, the jacobian etc, see \fCFEAbstract::compute_map()\fP\&. Start logging the combination of radial and base parts
.PP
Start logging the combination of radial and base parts
.PP
Definition at line 728 of file inf_fe\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::origin(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
.nf
729 {
730   libmesh_assert(inf_elem);
731   // at least check whether the base element type is correct\&.
732   // otherwise this version of computing dist would give problems
733   libmesh_assert_equal_to (base_elem->type(), Base::get_elem_type(inf_elem->type()));
734 
735 
739   START_LOG("combine_base_radial()", "InfFE");
740 
741 
742   // zero  the phase, since it is to be summed up
743   std::fill (dphasedxi\&.begin(),   dphasedxi\&.end(),   0\&.);
744   std::fill (dphasedeta\&.begin(),  dphasedeta\&.end(),  0\&.);
745   std::fill (dphasedzeta\&.begin(), dphasedzeta\&.end(), 0\&.);
746 
747 
748   const unsigned int n_base_mapping_sf =
749     libmesh_cast_int<unsigned int>(dist\&.size());
750   const Point origin = inf_elem->origin();
751 
752   // for each new infinite element, compute the radial distances
753   for (unsigned int n=0; n<n_base_mapping_sf; n++)
754     dist[n] =  Point(base_elem->point(n) - origin)\&.size();
755 
756 
757   switch (Dim)
758     {
759 
760       //------------------------------------------------------------
761       // 1D
762     case 1:
763       {
764         libmesh_not_implemented();
765         break;
766       }
767 
768 
769 
770       //------------------------------------------------------------
771       // 2D
772     case 2:
773       {
774         libmesh_not_implemented();
775         break;
776       }
777 
778 
779 
780       //------------------------------------------------------------
781       // 3D
782     case 3:
783       {
784         // fast access to the approximation and mapping shapes of base_fe
785         const std::vector<std::vector<Real> >& S  = base_fe->phi;
786         const std::vector<std::vector<Real> >& Ss = base_fe->dphidxi;
787         const std::vector<std::vector<Real> >& St = base_fe->dphideta;
788         const std::vector<std::vector<Real> >& S_map  = (base_fe->get_fe_map())\&.get_phi_map();
789         const std::vector<std::vector<Real> >& Ss_map = (base_fe->get_fe_map())\&.get_dphidxi_map();
790         const std::vector<std::vector<Real> >& St_map = (base_fe->get_fe_map())\&.get_dphideta_map();
791 
792         const unsigned int n_radial_qp         = radial_qrule->n_points();
793         const unsigned int n_base_qp           = base_qrule->  n_points();
794 
795         const unsigned int n_total_mapping_sf  =
796           libmesh_cast_int<unsigned int>(radial_map\&.size()) * n_base_mapping_sf;
797 
798         const unsigned int n_total_approx_sf   = Radial::n_dofs(fe_type\&.radial_order) *  base_fe->n_shape_functions();
799 
800 
801         // compute the phase term derivatives
802         {
803           unsigned int tp=0;
804           for (unsigned int rp=0; rp<n_radial_qp; rp++)  // over radial qp's
805             for (unsigned int bp=0; bp<n_base_qp; bp++)  // over base qp's
806               {
807                 // sum over all base shapes, to get the average distance
808                 for (unsigned int i=0; i<n_base_mapping_sf; i++)
809                   {
810                     dphasedxi[tp]   += Ss_map[i][bp] * dist[i] * radial_map   [1][rp];
811                     dphasedeta[tp]  += St_map[i][bp] * dist[i] * radial_map   [1][rp];
812                     dphasedzeta[tp] += S_map [i][bp] * dist[i] * dradialdv_map[1][rp];
813                   }
814 
815                 tp++;
816 
817               } // loop radial and base qp's
818 
819         }
820 
821         libmesh_assert_equal_to (phi\&.size(), n_total_approx_sf);
822         libmesh_assert_equal_to (dphidxi\&.size(), n_total_approx_sf);
823         libmesh_assert_equal_to (dphideta\&.size(), n_total_approx_sf);
824         libmesh_assert_equal_to (dphidzeta\&.size(), n_total_approx_sf);
825 
826         // compute the overall approximation shape functions,
827         // pick the appropriate radial and base shapes through using
828         // _base_shape_index and _radial_shape_index
829         for (unsigned int rp=0; rp<n_radial_qp; rp++)  // over radial qp's
830           for (unsigned int bp=0; bp<n_base_qp; bp++)  // over base qp's
831             for (unsigned int ti=0; ti<n_total_approx_sf; ti++)  // over _all_ approx_sf
832               {
833                 // let the index vectors take care of selecting the appropriate base/radial shape
834                 const unsigned int bi = _base_shape_index  [ti];
835                 const unsigned int ri = _radial_shape_index[ti];
836                 phi      [ti][bp+rp*n_base_qp] = S [bi][bp] * mode[ri][rp] * som[rp];
837                 dphidxi  [ti][bp+rp*n_base_qp] = Ss[bi][bp] * mode[ri][rp] * som[rp];
838                 dphideta [ti][bp+rp*n_base_qp] = St[bi][bp] * mode[ri][rp] * som[rp];
839                 dphidzeta[ti][bp+rp*n_base_qp] = S [bi][bp]
840                   * (dmodedv[ri][rp] * som[rp] + mode[ri][rp] * dsomdv[rp]);
841               }
842 
843         std::vector<std::vector<Real> >& phi_map = this->_fe_map->get_phi_map();
844         std::vector<std::vector<Real> >& dphidxi_map = this->_fe_map->get_dphidxi_map();
845         std::vector<std::vector<Real> >& dphideta_map = this->_fe_map->get_dphideta_map();
846         std::vector<std::vector<Real> >& dphidzeta_map = this->_fe_map->get_dphidzeta_map();
847 
848         libmesh_assert_equal_to (phi_map\&.size(), n_total_mapping_sf);
849         libmesh_assert_equal_to (dphidxi_map\&.size(), n_total_mapping_sf);
850         libmesh_assert_equal_to (dphideta_map\&.size(), n_total_mapping_sf);
851         libmesh_assert_equal_to (dphidzeta_map\&.size(), n_total_mapping_sf);
852 
853         // compute the overall mapping functions,
854         // pick the appropriate radial and base entries through using
855         // _base_node_index and _radial_node_index
856         for (unsigned int rp=0; rp<n_radial_qp; rp++)  // over radial qp's
857           for (unsigned int bp=0; bp<n_base_qp; bp++)  // over base qp's
858             for (unsigned int ti=0; ti<n_total_mapping_sf; ti++)  // over all mapping shapes
859               {
860                 // let the index vectors take care of selecting the appropriate base/radial mapping shape
861                 const unsigned int bi = _base_node_index  [ti];
862                 const unsigned int ri = _radial_node_index[ti];
863                 phi_map      [ti][bp+rp*n_base_qp] = S_map [bi][bp] * radial_map   [ri][rp];
864                 dphidxi_map  [ti][bp+rp*n_base_qp] = Ss_map[bi][bp] * radial_map   [ri][rp];
865                 dphideta_map [ti][bp+rp*n_base_qp] = St_map[bi][bp] * radial_map   [ri][rp];
866                 dphidzeta_map[ti][bp+rp*n_base_qp] = S_map [bi][bp] * dradialdv_map[ri][rp];
867               }
868 
869 
870         break;
871       }
872 
873 
874     default:
875       libmesh_error();
876     }
877 
878 
882   STOP_LOG("combine_base_radial()", "InfFE");
883 
884 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::compute_data (const \fBFEType\fP &fe_t, const \fBElem\fP *inf_elem, \fBFEComputeData\fP &data)\fC [static]\fP"
Generalized version of \fC\fBshape()\fP\fP, takes an \fCElem*\fP\&. The \fCdata\fP contains both input and output parameters\&. For frequency domain simulations, the complex-valued shape is returned\&. In time domain both the computed shape, \fIand\fP the phase is returned\&. Note that the phase (proportional to the distance of the \fC\fBPoint\fP\fP \fCdata\&.p\fP from the envelope) is actually a measure how \fIfar\fP into the \fIfuture\fP the results are\&. Pretty weird, hm!? 
.PP
Definition at line 239 of file inf_fe_static\&.C\&.
.PP
References libMesh::Elem::build_side(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::Radial::decay(), libMesh::err, libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval(), libMesh::FEComputeData::frequency, libMesh::INFEDGE2, libMesh::libmesh_assert(), libMesh::Elem::origin(), libMesh::FEComputeData::p, libMesh::FEComputeData::phase, libMesh::pi, libMesh::Elem::point(), libMesh::FEType::radial_order, libMesh::Real, libMesh::FEComputeData::shape, libMesh::FE< Dim, T >::shape(), libMesh::FEInterface::shape(), libMesh::FEComputeData::speed, and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEInterface::ifem_compute_data()\&.
.PP
.nf
242 {
243   libmesh_assert(inf_elem);
244   libmesh_assert_not_equal_to (Dim, 0);
245 
246   const Order        o_radial             (fet\&.radial_order);
247   const Order        radial_mapping_order (Radial::mapping_order());
248   const Point&       p                    (data\&.p);
249   const Real         v                    (p(Dim-1));
250   AutoPtr<Elem>      base_el              (inf_elem->build_side(0));
251 
252   /*
253    * compute \p interpolated_dist containing the mapping-interpolated
254    * distance of the base point to the origin\&.  This is the same
255    * for all shape functions\&.  Set \p interpolated_dist to 0, it
256    * is added to\&.
257    */
258   Real interpolated_dist = 0\&.;
259   switch (Dim)
260     {
261     case 1:
262       {
263         libmesh_assert_equal_to (inf_elem->type(), INFEDGE2);
264         interpolated_dist =  Point(inf_elem->point(0) - inf_elem->point(1))\&.size();
265         break;
266       }
267 
268     case 2:
269       {
270         const unsigned int n_base_nodes = base_el->n_nodes();
271 
272         const Point    origin                 = inf_elem->origin();
273         const Order    base_mapping_order     (base_el->default_order());
274         const ElemType base_mapping_elem_type (base_el->type());
275 
276         // interpolate the base nodes' distances
277         for (unsigned int n=0; n<n_base_nodes; n++)
278           interpolated_dist += Point(base_el->point(n) - origin)\&.size()
279             * FE<1,LAGRANGE>::shape (base_mapping_elem_type, base_mapping_order, n, p);
280         break;
281       }
282 
283     case 3:
284       {
285         const unsigned int n_base_nodes = base_el->n_nodes();
286 
287         const Point    origin                 = inf_elem->origin();
288         const Order    base_mapping_order     (base_el->default_order());
289         const ElemType base_mapping_elem_type (base_el->type());
290 
291         // interpolate the base nodes' distances
292         for (unsigned int n=0; n<n_base_nodes; n++)
293           interpolated_dist += Point(base_el->point(n) - origin)\&.size()
294             * FE<2,LAGRANGE>::shape (base_mapping_elem_type, base_mapping_order, n, p);
295         break;
296       }
297 #ifdef DEBUG
298     default:
299       libmesh_error();
300 #endif
301     }
302 
303 
304 
305 #ifdef LIBMESH_USE_COMPLEX_NUMBERS
306 
307   // assumption on time-harmonic behavior
308   const short int sign (-1);
309 
310   // the wave number
311   const Real wavenumber = 2\&. * libMesh::pi * data\&.frequency / data\&.speed;
312 
313   // the exponent for time-harmonic behavior
314   const Real exponent = sign                                                            /* +1\&. or -1\&.                */
315     * wavenumber                                                                      /* k                         */
316     * interpolated_dist                                                               /* together with next line:  */
317     * InfFE<Dim,INFINITE_MAP,T_map>::eval(v, radial_mapping_order, 1);                /* phase(s,t,v)              */
318 
319   const Number time_harmonic = Number(cos(exponent), sin(exponent));                    /* e^(sign*i*k*phase(s,t,v)) */
320 
321   /*
322    * compute \p shape for all dof in the element
323    */
324   if (Dim > 1)
325     {
326       const unsigned int n_dof = n_dofs (fet, inf_elem->type());
327       data\&.shape\&.resize(n_dof);
328 
329       for (unsigned int i=0; i<n_dof; i++)
330         {
331           // compute base and radial shape indices
332           unsigned int i_base, i_radial;
333           compute_shape_indices(fet, inf_elem->type(), i, i_base, i_radial);
334 
335           data\&.shape[i] = (InfFE<Dim,T_radial,T_map>::Radial::decay(v)                  /* (1\&.-v)/2\&. in 3D          */
336                            *  FEInterface::shape(Dim-1, fet, base_el\&.get(), i_base, p)  /* S_n(s,t)                 */
337                            * InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial))    /* L_n(v)                   */
338             * time_harmonic;                                                          /* e^(sign*i*k*phase(s,t,v) */
339         }
340     }
341   else
342     {
343       libMesh::err << "compute_data() for 1-dimensional InfFE not implemented\&." << std::endl;
344       libmesh_error();
345     }
346 
347 #else
348 
349   const Real speed = data\&.speed;
350 
351   /*
352    * This is quite weird: the phase is actually
353    * a measure how @e advanced the pressure is that
354    * we compute\&.  In other words: the further away
355    * the node \p data\&.p is, the further we look into
356    * the future\&.\&.\&.
357    */
358   data\&.phase = interpolated_dist                                                       /* phase(s,t,v)/c  */
359     * InfFE<Dim,INFINITE_MAP,T_map>::eval(v, radial_mapping_order, 1) / speed;
360 
361   if (Dim > 1)
362     {
363       const unsigned int n_dof = n_dofs (fet, inf_elem->type());
364       data\&.shape\&.resize(n_dof);
365 
366       for (unsigned int i=0; i<n_dof; i++)
367         {
368           // compute base and radial shape indices
369           unsigned int i_base, i_radial;
370           compute_shape_indices(fet, inf_elem->type(), i, i_base, i_radial);
371 
372           data\&.shape[i] = InfFE<Dim,T_radial,T_map>::Radial::decay(v)                  /* (1\&.-v)/2\&. in 3D */
373             *  FEInterface::shape(Dim-1, fet, base_el\&.get(), i_base, p)  /* S_n(s,t)        */
374             * InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial);    /* L_n(v)          */
375         }
376     }
377   else
378     {
379       libMesh::err << "compute_data() for 1-dimensional InfFE not implemented\&." << std::endl;
380       libmesh_error();
381     }
382 
383 #endif
384 }
.fi
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::compute_node_indices (const \fBElemType\fPinf_elem_type, const unsigned intouter_node_index, unsigned int &base_node, unsigned int &radial_node)\fC [static]\fP, \fC [protected]\fP"
Computes the indices in the base \fCbase_node\fP and in radial direction \fCradial_node\fP (either 0 or 1) associated to the node \fCouter_node_index\fP of an infinite element of type \fCinf_elem_type\fP\&. 
.PP
Definition at line 392 of file inf_fe_static\&.C\&.
.PP
References libMesh::err, libMesh::INFEDGE2, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, and libMesh::INFQUAD6\&.
.PP
.nf
396 {
397   switch (inf_elem_type)
398     {
399     case INFEDGE2:
400       {
401         libmesh_assert_less (outer_node_index, 2);
402         base_node   = 0;
403         radial_node = outer_node_index;
404         return;
405       }
406 
407 
408       // linear base approximation, easy to determine
409     case INFQUAD4:
410       {
411         libmesh_assert_less (outer_node_index, 4);
412         base_node   = outer_node_index % 2;
413         radial_node = outer_node_index / 2;
414         return;
415       }
416 
417     case INFPRISM6:
418       {
419         libmesh_assert_less (outer_node_index, 6);
420         base_node   = outer_node_index % 3;
421         radial_node = outer_node_index / 3;
422         return;
423       }
424 
425     case INFHEX8:
426       {
427         libmesh_assert_less (outer_node_index, 8);
428         base_node   = outer_node_index % 4;
429         radial_node = outer_node_index / 4;
430         return;
431       }
432 
433 
434       // higher order base approximation, more work necessary
435     case INFQUAD6:
436       {
437         switch (outer_node_index)
438           {
439           case 0:
440           case 1:
441             {
442               radial_node = 0;
443               base_node   = outer_node_index;
444               return;
445             }
446 
447           case 2:
448           case 3:
449             {
450               radial_node = 1;
451               base_node   = outer_node_index-2;
452               return;
453             }
454 
455           case 4:
456             {
457               radial_node = 0;
458               base_node   = 2;
459               return;
460             }
461 
462           case 5:
463             {
464               radial_node = 1;
465               base_node   = 2;
466               return;
467             }
468 
469           default:
470             {
471               libmesh_error();
472               return;
473             }
474           }
475       }
476 
477 
478     case INFHEX16:
479     case INFHEX18:
480       {
481         switch (outer_node_index)
482           {
483           case 0:
484           case 1:
485           case 2:
486           case 3:
487             {
488               radial_node = 0;
489               base_node   = outer_node_index;
490               return;
491             }
492 
493           case 4:
494           case 5:
495           case 6:
496           case 7:
497             {
498               radial_node = 1;
499               base_node   = outer_node_index-4;
500               return;
501             }
502 
503           case 8:
504           case 9:
505           case 10:
506           case 11:
507             {
508               radial_node = 0;
509               base_node   = outer_node_index-4;
510               return;
511             }
512 
513           case 12:
514           case 13:
515           case 14:
516           case 15:
517             {
518               radial_node = 1;
519               base_node   = outer_node_index-8;
520               return;
521             }
522 
523           case 16:
524             {
525               libmesh_assert_equal_to (inf_elem_type, INFHEX18);
526               radial_node = 0;
527               base_node   = 8;
528               return;
529             }
530 
531           case 17:
532             {
533               libmesh_assert_equal_to (inf_elem_type, INFHEX18);
534               radial_node = 1;
535               base_node   = 8;
536               return;
537             }
538 
539           default:
540             {
541               libmesh_error();
542               return;
543             }
544           }
545       }
546 
547 
548     case INFPRISM12:
549       {
550         switch (outer_node_index)
551           {
552           case 0:
553           case 1:
554           case 2:
555             {
556               radial_node = 0;
557               base_node   = outer_node_index;
558               return;
559             }
560 
561           case 3:
562           case 4:
563           case 5:
564             {
565               radial_node = 1;
566               base_node   = outer_node_index-3;
567               return;
568             }
569 
570           case 6:
571           case 7:
572           case 8:
573             {
574               radial_node = 0;
575               base_node   = outer_node_index-3;
576               return;
577             }
578 
579           case 9:
580           case 10:
581           case 11:
582             {
583               radial_node = 1;
584               base_node   = outer_node_index-6;
585               return;
586             }
587 
588           default:
589             {
590               libmesh_error();
591               return;
592             }
593           }
594       }
595 
596 
597     default:
598       {
599         libMesh::err << "ERROR: Bad infinite element type=" << inf_elem_type
600                      << ", node=" << outer_node_index << std::endl;
601         libmesh_error();
602         return;
603       }
604     }
605 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::compute_node_indices_fast (const \fBElemType\fPinf_elem_type, const unsigned intouter_node_index, unsigned int &base_node, unsigned int &radial_node)\fC [static]\fP, \fC [protected]\fP"
Does the same as \fC\fBcompute_node_indices()\fP\fP, but stores the maps for the current element type\&. Provided the infinite element type changes seldom, this is probably faster than using \fCcompute_node_indices\fP () alone\&. This is possible since the number of \fInodes\fP is not likely to change\&. 
.PP
Definition at line 613 of file inf_fe_static\&.C\&.
.PP
References libMesh::err, libMesh::INFEDGE2, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, libMesh::INFQUAD6, libMesh::INVALID_ELEM, libMesh::invalid_uint, and n_nodes\&.
.PP
.nf
617 {
618   libmesh_assert_not_equal_to (inf_elem_type, INVALID_ELEM);
619 
620   static std::vector<unsigned int> _static_base_node_index;
621   static std::vector<unsigned int> _static_radial_node_index;
622 
623   /*
624    * fast counterpart to compute_node_indices(), uses local static buffers
625    * to store the index maps\&.  The class member
626    * \p _compute_node_indices_fast_current_elem_type remembers
627    * the current element type\&.
628    *
629    * Note that there exist non-static members storing the
630    * same data\&.  However, you never know what element type
631    * is currently used by the \p InfFE object, and what
632    * request is currently directed to the static \p InfFE
633    * members (which use \p compute_node_indices_fast())\&.
634    * So separate these\&.
635    *
636    * check whether the work for this elemtype has already
637    * been done\&.  If so, use this index\&.  Otherwise, refresh
638    * the buffer to this element type\&.
639    */
640   if (inf_elem_type==_compute_node_indices_fast_current_elem_type)
641     {
642       base_node   = _static_base_node_index  [outer_node_index];
643       radial_node = _static_radial_node_index[outer_node_index];
644       return;
645     }
646   else
647     {
648       // store the map for _all_ nodes for this element type
649       _compute_node_indices_fast_current_elem_type = inf_elem_type;
650 
651       unsigned int n_nodes = libMesh::invalid_uint;
652 
653       switch (inf_elem_type)
654         {
655         case INFEDGE2:
656           {
657             n_nodes = 2;
658             break;
659           }
660         case INFQUAD4:
661           {
662             n_nodes = 4;
663             break;
664           }
665         case INFQUAD6:
666           {
667             n_nodes = 6;
668             break;
669           }
670         case INFHEX8:
671           {
672             n_nodes = 8;
673             break;
674           }
675         case INFHEX16:
676           {
677             n_nodes = 16;
678             break;
679           }
680         case INFHEX18:
681           {
682             n_nodes = 18;
683             break;
684           }
685         case INFPRISM6:
686           {
687             n_nodes = 6;
688             break;
689           }
690         case INFPRISM12:
691           {
692             n_nodes = 12;
693             break;
694           }
695         default:
696           {
697             libMesh::err << "ERROR: Bad infinite element type=" << inf_elem_type
698                          << ", node=" << outer_node_index << std::endl;
699             libmesh_error();
700             break;
701           }
702         }
703 
704 
705       _static_base_node_index\&.resize  (n_nodes);
706       _static_radial_node_index\&.resize(n_nodes);
707 
708       for (unsigned int n=0; n<n_nodes; n++)
709         compute_node_indices (inf_elem_type,
710                               n,
711                               _static_base_node_index  [outer_node_index],
712                               _static_radial_node_index[outer_node_index]);
713 
714       // and return for the specified node
715       base_node   = _static_base_node_index  [outer_node_index];
716       radial_node = _static_radial_node_index[outer_node_index];
717       return;
718     }
719 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::compute_periodic_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for meshes with periodic boundary conditions) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.PP
Definition at line 1877 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::TypeVector< T >::absolute_fuzzy_equals(), libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::C_ONE, libMesh::C_ZERO, libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::DofMap::constrain_p_dofs(), libMesh::FEType::default_quadrature_order(), libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::DofObject::dof_number(), libMesh::FEInterface::dofs_on_side(), libMesh::err, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::Elem::get_node(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::TensorTools::inner_product(), libMesh::DofObject::invalid_id, libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::DofMap::is_constrained_dof(), libMesh::Elem::is_edge(), libMesh::Elem::is_face(), libMesh::PeriodicBoundaryBase::is_my_variable(), libMesh::Elem::is_node_on_edge(), libMesh::Elem::is_node_on_side(), libMesh::Elem::is_vertex(), libMesh::Elem::level(), libMesh::libmesh_assert(), std::min(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::DofObject::n_comp(), libMesh::Elem::n_edges(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::Elem::p_level(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::Threads::spin_mtx, libMesh::swap(), libMesh::DofMap::sys_number(), libMesh::TOLERANCE, and libMesh::DofMap::variable_type()\&.
.PP
Referenced by libMesh::FEInterface::compute_periodic_constraints()\&.
.PP
.nf
1884 {
1885   // Only bother if we truly have periodic boundaries
1886   if (boundaries\&.empty())
1887     return;
1888 
1889   libmesh_assert(elem);
1890 
1891   // Only constrain active elements with this method
1892   if (!elem->active())
1893     return;
1894 
1895   const unsigned int Dim = elem->dim();
1896 
1897   // We need sys_number and variable_number for DofObject methods
1898   // later
1899   const unsigned int sys_number = dof_map\&.sys_number();
1900 
1901   const FEType& base_fe_type = dof_map\&.variable_type(variable_number);
1902 
1903   // Construct FE objects for this element and its pseudo-neighbors\&.
1904   AutoPtr<FEGenericBase<OutputShape> > my_fe
1905     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1906   const FEContinuity cont = my_fe->get_continuity();
1907 
1908   // We don't need to constrain discontinuous elements
1909   if (cont == DISCONTINUOUS)
1910     return;
1911   libmesh_assert (cont == C_ZERO || cont == C_ONE);
1912 
1913   // We'll use element size to generate relative tolerances later
1914   const Real primary_hmin = elem->hmin();
1915 
1916   AutoPtr<FEGenericBase<OutputShape> > neigh_fe
1917     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1918 
1919   QGauss my_qface(Dim-1, base_fe_type\&.default_quadrature_order());
1920   my_fe->attach_quadrature_rule (&my_qface);
1921   std::vector<Point> neigh_qface;
1922 
1923   const std::vector<Real>& JxW = my_fe->get_JxW();
1924   const std::vector<Point>& q_point = my_fe->get_xyz();
1925   const std::vector<std::vector<OutputShape> >& phi = my_fe->get_phi();
1926   const std::vector<std::vector<OutputShape> >& neigh_phi =
1927     neigh_fe->get_phi();
1928   const std::vector<Point> *face_normals = NULL;
1929   const std::vector<std::vector<OutputGradient> > *dphi = NULL;
1930   const std::vector<std::vector<OutputGradient> > *neigh_dphi = NULL;
1931   std::vector<dof_id_type> my_dof_indices, neigh_dof_indices;
1932   std::vector<unsigned int> my_side_dofs, neigh_side_dofs;
1933 
1934   if (cont != C_ZERO)
1935     {
1936       const std::vector<Point>& ref_face_normals =
1937         my_fe->get_normals();
1938       face_normals = &ref_face_normals;
1939       const std::vector<std::vector<OutputGradient> >& ref_dphi =
1940         my_fe->get_dphi();
1941       dphi = &ref_dphi;
1942       const std::vector<std::vector<OutputGradient> >& ref_neigh_dphi =
1943         neigh_fe->get_dphi();
1944       neigh_dphi = &ref_neigh_dphi;
1945     }
1946 
1947   DenseMatrix<Real> Ke;
1948   DenseVector<Real> Fe;
1949   std::vector<DenseVector<Real> > Ue;
1950 
1951   // Look at the element faces\&.  Check to see if we need to
1952   // build constraints\&.
1953   for (unsigned int s=0; s<elem->n_sides(); s++)
1954     {
1955       if (elem->neighbor(s))
1956         continue;
1957 
1958       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1959       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1960         {
1961           const boundary_id_type boundary_id = *id_it;
1962           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1963           if (periodic && periodic->is_my_variable(variable_number))
1964             {
1965               libmesh_assert(point_locator);
1966 
1967               // Get pointers to the element's neighbor\&.
1968               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1969 
1970               if (neigh == NULL)
1971                 {
1972                   libMesh::err << "PeriodicBoundaries point locator object returned NULL!" << std::endl;
1973                   libmesh_error();
1974                 }
1975 
1976               // periodic (and possibly h refinement) constraints:
1977               // constrain dofs shared between
1978               // this element and ones as coarse
1979               // as or coarser than this element\&.
1980               if (neigh->level() <= elem->level())
1981                 {
1982                   unsigned int s_neigh =
1983                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1984                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1985 
1986 #ifdef LIBMESH_ENABLE_AMR
1987                   // Find the minimum p level; we build the h constraint
1988                   // matrix with this and then constrain away all higher p
1989                   // DoFs\&.
1990                   libmesh_assert(neigh->active());
1991                   const unsigned int min_p_level =
1992                     std::min(elem->p_level(), neigh->p_level());
1993 
1994                   // we may need to make the FE objects reinit with the
1995                   // minimum shared p_level
1996                   // FIXME - I hate using const_cast<> and avoiding
1997                   // accessor functions; there's got to be a
1998                   // better way to do this!
1999                   const unsigned int old_elem_level = elem->p_level();
2000                   if (old_elem_level != min_p_level)
2001                     (const_cast<Elem *>(elem))->hack_p_level(min_p_level);
2002                   const unsigned int old_neigh_level = neigh->p_level();
2003                   if (old_neigh_level != min_p_level)
2004                     (const_cast<Elem *>(neigh))->hack_p_level(min_p_level);
2005 #endif // #ifdef LIBMESH_ENABLE_AMR
2006 
2007                   // We can do a projection with a single integration,
2008                   // due to the assumption of nested finite element
2009                   // subspaces\&.
2010                   // FIXME: it might be more efficient to do nodes,
2011                   // then edges, then side, to reduce the size of the
2012                   // Cholesky factorization(s)
2013                   my_fe->reinit(elem, s);
2014 
2015                   dof_map\&.dof_indices (elem, my_dof_indices,
2016                                        variable_number);
2017                   dof_map\&.dof_indices (neigh, neigh_dof_indices,
2018                                        variable_number);
2019 
2020                   const unsigned int n_qp = my_qface\&.n_points();
2021 
2022                   // Translate the quadrature points over to the
2023                   // neighbor's boundary
2024                   std::vector<Point> neigh_point(q_point\&.size());
2025                   for (unsigned int i=0; i != neigh_point\&.size(); ++i)
2026                     neigh_point[i] = periodic->get_corresponding_pos(q_point[i]);
2027 
2028                   FEInterface::inverse_map (Dim, base_fe_type, neigh,
2029                                             neigh_point, neigh_qface);
2030 
2031                   neigh_fe->reinit(neigh, &neigh_qface);
2032 
2033                   // We're only concerned with DOFs whose values (and/or first
2034                   // derivatives for C1 elements) are supported on side nodes
2035                   FEInterface::dofs_on_side(elem, Dim, base_fe_type, s, my_side_dofs);
2036                   FEInterface::dofs_on_side(neigh, Dim, base_fe_type, s_neigh, neigh_side_dofs);
2037 
2038                   // We're done with functions that examine Elem::p_level(),
2039                   // so let's unhack those levels
2040 #ifdef LIBMESH_ENABLE_AMR
2041                   if (elem->p_level() != old_elem_level)
2042                     (const_cast<Elem *>(elem))->hack_p_level(old_elem_level);
2043                   if (neigh->p_level() != old_neigh_level)
2044                     (const_cast<Elem *>(neigh))->hack_p_level(old_neigh_level);
2045 #endif // #ifdef LIBMESH_ENABLE_AMR
2046 
2047                   const unsigned int n_side_dofs =
2048                     libmesh_cast_int<unsigned int>
2049                     (my_side_dofs\&.size());
2050                   libmesh_assert_equal_to (n_side_dofs, neigh_side_dofs\&.size());
2051 
2052                   Ke\&.resize (n_side_dofs, n_side_dofs);
2053                   Ue\&.resize(n_side_dofs);
2054 
2055                   // Form the projection matrix, (inner product of fine basis
2056                   // functions against fine test functions)
2057                   for (unsigned int is = 0; is != n_side_dofs; ++is)
2058                     {
2059                       const unsigned int i = my_side_dofs[is];
2060                       for (unsigned int js = 0; js != n_side_dofs; ++js)
2061                         {
2062                           const unsigned int j = my_side_dofs[js];
2063                           for (unsigned int qp = 0; qp != n_qp; ++qp)
2064                             {
2065                               Ke(is,js) += JxW[qp] *
2066                                 TensorTools::inner_product(phi[i][qp],
2067                                                            phi[j][qp]);
2068                               if (cont != C_ZERO)
2069                                 Ke(is,js) += JxW[qp] *
2070                                   TensorTools::inner_product((*dphi)[i][qp] *
2071                                                              (*face_normals)[qp],
2072                                                              (*dphi)[j][qp] *
2073                                                              (*face_normals)[qp]);
2074                             }
2075                         }
2076                     }
2077 
2078                   // Form the right hand sides, (inner product of coarse basis
2079                   // functions against fine test functions)
2080                   for (unsigned int is = 0; is != n_side_dofs; ++is)
2081                     {
2082                       const unsigned int i = neigh_side_dofs[is];
2083                       Fe\&.resize (n_side_dofs);
2084                       for (unsigned int js = 0; js != n_side_dofs; ++js)
2085                         {
2086                           const unsigned int j = my_side_dofs[js];
2087                           for (unsigned int qp = 0; qp != n_qp; ++qp)
2088                             {
2089                               Fe(js) += JxW[qp] *
2090                                 TensorTools::inner_product(neigh_phi[i][qp],
2091                                                            phi[j][qp]);
2092                               if (cont != C_ZERO)
2093                                 Fe(js) += JxW[qp] *
2094                                   TensorTools::inner_product((*neigh_dphi)[i][qp] *
2095                                                              (*face_normals)[qp],
2096                                                              (*dphi)[j][qp] *
2097                                                              (*face_normals)[qp]);
2098                             }
2099                         }
2100                       Ke\&.cholesky_solve(Fe, Ue[is]);
2101                     }
2102 
2103                   // Make sure we're not adding recursive constraints
2104                   // due to the redundancy in the way we add periodic
2105                   // boundary constraints
2106                   //
2107                   // In order for this to work while threaded or on
2108                   // distributed meshes, we need a rigorous way to
2109                   // avoid recursive constraints\&.  Here it is:
2110                   //
2111                   // For vertex DoFs, if there is a "prior" element
2112                   // (i\&.e\&. a coarser element or an equally refined
2113                   // element with a lower id) on this boundary which
2114                   // contains the vertex point, then we will avoid
2115                   // generating constraints; the prior element (or
2116                   // something prior to it) may do so\&.  If we are the
2117                   // most prior (or "primary") element on this
2118                   // boundary sharing this point, then we look at the
2119                   // boundary periodic to us, we find the primary
2120                   // element there, and if that primary is coarser or
2121                   // equal-but-lower-id, then our vertex dofs are
2122                   // constrained in terms of that element\&.
2123                   //
2124                   // For edge DoFs, if there is a coarser element
2125                   // on this boundary sharing this edge, then we will
2126                   // avoid generating constraints (we will be
2127                   // constrained indirectly via AMR constraints
2128                   // connecting us to the coarser element's DoFs)\&.  If
2129                   // we are the coarsest element sharing this edge,
2130                   // then we generate constraints if and only if we
2131                   // are finer than the coarsest element on the
2132                   // boundary periodic to us sharing the corresponding
2133                   // periodic edge, or if we are at equal level but
2134                   // our edge nodes have higher ids than the periodic
2135                   // edge nodes (sorted from highest to lowest, then
2136                   // compared lexicographically)
2137                   //
2138                   // For face DoFs, we generate constraints if we are
2139                   // finer than our periodic neighbor, or if we are at
2140                   // equal level but our element id is higher than its
2141                   // element id\&.
2142                   //
2143                   // If the primary neighbor is also the current elem
2144                   // (a 1-element-thick mesh) then we choose which
2145                   // vertex dofs to constrain via lexicographic
2146                   // ordering on point locations
2147 
2148                   // FIXME: This code doesn't yet properly handle
2149                   // cases where multiple different periodic BCs
2150                   // intersect\&.
2151                   std::set<dof_id_type> my_constrained_dofs;
2152 
2153                   for (unsigned int n = 0; n != elem->n_nodes(); ++n)
2154                     {
2155                       if (!elem->is_node_on_side(n,s))
2156                         continue;
2157 
2158                       const Node* my_node = elem->get_node(n);
2159 
2160                       if (elem->is_vertex(n))
2161                         {
2162                           // Find all boundary ids that include this
2163                           // point and have periodic boundary
2164                           // conditions for this variable
2165                           std::set<boundary_id_type> point_bcids;
2166 
2167                           for (unsigned int new_s = 0; new_s !=
2168                                  elem->n_sides(); ++new_s)
2169                             {
2170                               if (!elem->is_node_on_side(n,new_s))
2171                                 continue;
2172 
2173                               const std::vector<boundary_id_type>
2174                                 new_bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
2175                               for (std::vector<boundary_id_type>::const_iterator
2176                                      new_id_it=new_bc_ids\&.begin(); new_id_it!=new_bc_ids\&.end(); ++new_id_it)
2177                                 {
2178                                   const boundary_id_type new_boundary_id = *new_id_it;
2179                                   const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2180                                   if (new_periodic && new_periodic->is_my_variable(variable_number))
2181                                     {
2182                                       point_bcids\&.insert(new_boundary_id);
2183                                     }
2184                                 }
2185                             }
2186 
2187                           // See if this vertex has point neighbors to
2188                           // defer to
2189                           if (primary_boundary_point_neighbor
2190                               (elem, *my_node, *mesh\&.boundary_info, point_bcids) != elem)
2191                             continue;
2192 
2193                           // Find the complementary boundary id set
2194                           std::set<boundary_id_type> point_pairedids;
2195                           for (std::set<boundary_id_type>::const_iterator i =
2196                                  point_bcids\&.begin(); i != point_bcids\&.end(); ++i)
2197                             {
2198                               const boundary_id_type new_boundary_id = *i;
2199                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2200                               point_pairedids\&.insert(new_periodic->pairedboundary);
2201                             }
2202 
2203                           // What do we want to constrain against?
2204                           const Elem* primary_elem = NULL;
2205                           const Elem* main_neigh = NULL;
2206                           Point main_pt = *my_node,
2207                             primary_pt = *my_node;
2208 
2209                           for (std::set<boundary_id_type>::const_iterator i =
2210                                  point_bcids\&.begin(); i != point_bcids\&.end(); ++i)
2211                             {
2212                               // Find the corresponding periodic point and
2213                               // its primary neighbor
2214                               const boundary_id_type new_boundary_id = *i;
2215                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2216 
2217                               const Point neigh_pt =
2218                                 new_periodic->get_corresponding_pos(*my_node);
2219 
2220                               // If the point is getting constrained
2221                               // to itself by this PBC then we don't
2222                               // generate any constraints
2223                               if (neigh_pt\&.absolute_fuzzy_equals
2224                                   (*my_node, primary_hmin*TOLERANCE))
2225                                 continue;
2226 
2227                               // Otherwise we'll have a constraint in
2228                               // one direction or another
2229                               if (!primary_elem)
2230                                 primary_elem = elem;
2231 
2232                               const Elem *primary_neigh = primary_boundary_point_neighbor
2233                                 (neigh, neigh_pt, *mesh\&.boundary_info,
2234                                  point_pairedids);
2235 
2236                               libmesh_assert(primary_neigh);
2237 
2238                               if (new_boundary_id == boundary_id)
2239                                 {
2240                                   main_neigh = primary_neigh;
2241                                   main_pt = neigh_pt;
2242                                 }
2243 
2244                               // Finer elements will get constrained in
2245                               // terms of coarser neighbors, not the
2246                               // other way around
2247                               if ((primary_neigh->level() > primary_elem->level()) ||
2248 
2249                                   // For equal-level elements, the one with
2250                                   // higher id gets constrained in terms of
2251                                   // the one with lower id
2252                                   (primary_neigh->level() == primary_elem->level() &&
2253                                    primary_neigh->id() > primary_elem->id()) ||
2254 
2255                                   // On a one-element-thick mesh, we compare
2256                                   // points to see what side gets constrained
2257                                   (primary_neigh == primary_elem &&
2258                                    (neigh_pt > primary_pt)))
2259                                 continue;
2260 
2261                               primary_elem = primary_neigh;
2262                               primary_pt = neigh_pt;
2263                             }
2264 
2265                           if (!primary_elem ||
2266                               primary_elem != main_neigh ||
2267                               primary_pt != main_pt)
2268                             continue;
2269                         }
2270                       else if (elem->is_edge(n))
2271                         {
2272                           // Find which edge we're on
2273                           unsigned int e=0;
2274                           for (; e != elem->n_edges(); ++e)
2275                             {
2276                               if (elem->is_node_on_edge(n,e))
2277                                 break;
2278                             }
2279                           libmesh_assert_less (e, elem->n_edges());
2280 
2281                           // Find the edge end nodes
2282                           Node *e1 = NULL,
2283                             *e2 = NULL;
2284                           for (unsigned int nn = 0; nn != elem->n_nodes(); ++nn)
2285                             {
2286                               if (nn == n)
2287                                 continue;
2288 
2289                               if (elem->is_node_on_edge(nn, e))
2290                                 {
2291                                   if (e1 == NULL)
2292                                     {
2293                                       e1 = elem->get_node(nn);
2294                                     }
2295                                   else
2296                                     {
2297                                       e2 = elem->get_node(nn);
2298                                       break;
2299                                     }
2300                                 }
2301                             }
2302                           libmesh_assert (e1 && e2);
2303 
2304                           // Find all boundary ids that include this
2305                           // edge and have periodic boundary
2306                           // conditions for this variable
2307                           std::set<boundary_id_type> edge_bcids;
2308 
2309                           for (unsigned int new_s = 0; new_s !=
2310                                  elem->n_sides(); ++new_s)
2311                             {
2312                               if (!elem->is_node_on_side(n,new_s))
2313                                 continue;
2314 
2315                               const std::vector<boundary_id_type>&
2316                                 new_bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
2317                               for (std::vector<boundary_id_type>::const_iterator
2318                                      new_id_it=new_bc_ids\&.begin(); new_id_it!=new_bc_ids\&.end(); ++new_id_it)
2319                                 {
2320                                   const boundary_id_type new_boundary_id = *new_id_it;
2321                                   const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2322                                   if (new_periodic && new_periodic->is_my_variable(variable_number))
2323                                     {
2324                                       edge_bcids\&.insert(new_boundary_id);
2325                                     }
2326                                 }
2327                             }
2328 
2329 
2330                           // See if this edge has neighbors to defer to
2331                           if (primary_boundary_edge_neighbor
2332                               (elem, *e1, *e2, *mesh\&.boundary_info, edge_bcids) != elem)
2333                             continue;
2334 
2335                           // Find the complementary boundary id set
2336                           std::set<boundary_id_type> edge_pairedids;
2337                           for (std::set<boundary_id_type>::const_iterator i =
2338                                  edge_bcids\&.begin(); i != edge_bcids\&.end(); ++i)
2339                             {
2340                               const boundary_id_type new_boundary_id = *i;
2341                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2342                               edge_pairedids\&.insert(new_periodic->pairedboundary);
2343                             }
2344 
2345                           // What do we want to constrain against?
2346                           const Elem* primary_elem = NULL;
2347                           const Elem* main_neigh = NULL;
2348                           Point main_pt1 = *e1,
2349                             main_pt2 = *e2,
2350                             primary_pt1 = *e1,
2351                             primary_pt2 = *e2;
2352 
2353                           for (std::set<boundary_id_type>::const_iterator i =
2354                                  edge_bcids\&.begin(); i != edge_bcids\&.end(); ++i)
2355                             {
2356                               // Find the corresponding periodic edge and
2357                               // its primary neighbor
2358                               const boundary_id_type new_boundary_id = *i;
2359                               const PeriodicBoundaryBase *new_periodic = boundaries\&.boundary(new_boundary_id);
2360 
2361                               Point neigh_pt1 = new_periodic->get_corresponding_pos(*e1),
2362                                 neigh_pt2 = new_periodic->get_corresponding_pos(*e2);
2363 
2364                               // If the edge is getting constrained
2365                               // to itself by this PBC then we don't
2366                               // generate any constraints
2367                               if (neigh_pt1\&.absolute_fuzzy_equals
2368                                   (*e1, primary_hmin*TOLERANCE) &&
2369                                   neigh_pt2\&.absolute_fuzzy_equals
2370                                   (*e2, primary_hmin*TOLERANCE))
2371                                 continue;
2372 
2373                               // Otherwise we'll have a constraint in
2374                               // one direction or another
2375                               if (!primary_elem)
2376                                 primary_elem = elem;
2377 
2378                               const Elem *primary_neigh = primary_boundary_edge_neighbor
2379                                 (neigh, neigh_pt1, neigh_pt2, *mesh\&.boundary_info,
2380                                  edge_pairedids);
2381 
2382                               libmesh_assert(primary_neigh);
2383 
2384                               if (new_boundary_id == boundary_id)
2385                                 {
2386                                   main_neigh = primary_neigh;
2387                                   main_pt1 = neigh_pt1;
2388                                   main_pt2 = neigh_pt2;
2389                                 }
2390 
2391                               // If we have a one-element thick mesh,
2392                               // we'll need to sort our points to get a
2393                               // consistent ordering rule
2394                               //
2395                               // Use >= in this test to make sure that,
2396                               // for angular constraints, no node gets
2397                               // constrained to itself\&.
2398                               if (primary_neigh == primary_elem)
2399                                 {
2400                                   if (primary_pt1 > primary_pt2)
2401                                     std::swap(primary_pt1, primary_pt2);
2402                                   if (neigh_pt1 > neigh_pt2)
2403                                     std::swap(neigh_pt1, neigh_pt2);
2404 
2405                                   if (neigh_pt2 >= primary_pt2)
2406                                     continue;
2407                                 }
2408 
2409                               // Otherwise:
2410                               // Finer elements will get constrained in
2411                               // terms of coarser ones, not the other way
2412                               // around
2413                               if ((primary_neigh->level() > primary_elem->level()) ||
2414 
2415                                   // For equal-level elements, the one with
2416                                   // higher id gets constrained in terms of
2417                                   // the one with lower id
2418                                   (primary_neigh->level() == primary_elem->level() &&
2419                                    primary_neigh->id() > primary_elem->id()))
2420                                 continue;
2421 
2422                               primary_elem = primary_neigh;
2423                               primary_pt1 = neigh_pt1;
2424                               primary_pt2 = neigh_pt2;
2425                             }
2426 
2427                           if (!primary_elem ||
2428                               primary_elem != main_neigh ||
2429                               primary_pt1 != main_pt1 ||
2430                               primary_pt2 != main_pt2)
2431                             continue;
2432                         }
2433                       else if (elem->is_face(n))
2434                         {
2435                           // If we have a one-element thick mesh,
2436                           // use the ordering of the face node and its
2437                           // periodic counterpart to determine what
2438                           // gets constrained
2439                           if (neigh == elem)
2440                             {
2441                               const Point neigh_pt =
2442                                 periodic->get_corresponding_pos(*my_node);
2443                               if (neigh_pt > *my_node)
2444                                 continue;
2445                             }
2446 
2447                           // Otherwise:
2448                           // Finer elements will get constrained in
2449                           // terms of coarser ones, not the other way
2450                           // around
2451                           if ((neigh->level() > elem->level()) ||
2452 
2453                               // For equal-level elements, the one with
2454                               // higher id gets constrained in terms of
2455                               // the one with lower id
2456                               (neigh->level() == elem->level() &&
2457                                neigh->id() > elem->id()))
2458                             continue;
2459                         }
2460 
2461                       // If we made it here without hitting a continue
2462                       // statement, then we're at a node whose dofs
2463                       // should be constrained by this element's
2464                       // calculations\&.
2465                       const unsigned int n_comp =
2466                         my_node->n_comp(sys_number, variable_number);
2467 
2468                       for (unsigned int i=0; i != n_comp; ++i)
2469                         my_constrained_dofs\&.insert
2470                           (my_node->dof_number
2471                            (sys_number, variable_number, i));
2472                     }
2473 
2474                   // FIXME: old code for disambiguating periodic BCs:
2475                   // this is not threadsafe nor safe to run on a
2476                   // non-serialized mesh\&.
2477                   /*
2478                     std::vector<bool> recursive_constraint(n_side_dofs, false);
2479 
2480                     for (unsigned int is = 0; is != n_side_dofs; ++is)
2481                     {
2482                     const unsigned int i = neigh_side_dofs[is];
2483                     const dof_id_type their_dof_g = neigh_dof_indices[i];
2484                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
2485 
2486                     {
2487                     Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
2488 
2489                     if (!dof_map\&.is_constrained_dof(their_dof_g))
2490                     continue;
2491                     }
2492 
2493                     DofConstraintRow& their_constraint_row =
2494                     constraints[their_dof_g]\&.first;
2495 
2496                     for (unsigned int js = 0; js != n_side_dofs; ++js)
2497                     {
2498                     const unsigned int j = my_side_dofs[js];
2499                     const dof_id_type my_dof_g = my_dof_indices[j];
2500                     libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
2501 
2502                     if (their_constraint_row\&.count(my_dof_g))
2503                     recursive_constraint[js] = true;
2504                     }
2505                     }
2506                   */
2507 
2508                   for (unsigned int js = 0; js != n_side_dofs; ++js)
2509                     {
2510                       // FIXME: old code path
2511                       // if (recursive_constraint[js])
2512                       //  continue;
2513 
2514                       const unsigned int j = my_side_dofs[js];
2515                       const dof_id_type my_dof_g = my_dof_indices[j];
2516                       libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
2517 
2518                       // FIXME: new code path
2519                       if (!my_constrained_dofs\&.count(my_dof_g))
2520                         continue;
2521 
2522                       DofConstraintRow* constraint_row;
2523 
2524                       // we may be running constraint methods concurretly
2525                       // on multiple threads, so we need a lock to
2526                       // ensure that this constraint is "ours"
2527                       {
2528                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
2529 
2530                         if (dof_map\&.is_constrained_dof(my_dof_g))
2531                           continue;
2532 
2533                         constraint_row = &(constraints[my_dof_g]);
2534                         libmesh_assert(constraint_row->empty());
2535                       }
2536 
2537                       for (unsigned int is = 0; is != n_side_dofs; ++is)
2538                         {
2539                           const unsigned int i = neigh_side_dofs[is];
2540                           const dof_id_type their_dof_g = neigh_dof_indices[i];
2541                           libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
2542 
2543                           // Periodic constraints should never be
2544                           // self-constraints
2545                           // libmesh_assert_not_equal_to (their_dof_g, my_dof_g);
2546 
2547                           const Real their_dof_value = Ue[is](js);
2548 
2549                           if (their_dof_g == my_dof_g)
2550                             {
2551                               libmesh_assert_less (std::abs(their_dof_value-1\&.), 1\&.e-5);
2552                               for (unsigned int k = 0; k != n_side_dofs; ++k)
2553                                 libmesh_assert(k == is || std::abs(Ue[k](js)) < 1\&.e-5);
2554                               continue;
2555                             }
2556 
2557                           if (std::abs(their_dof_value) < 10*TOLERANCE)
2558                             continue;
2559 
2560                           constraint_row->insert(std::make_pair(their_dof_g,
2561                                                                 their_dof_value));
2562                         }
2563                     }
2564                 }
2565               // p refinement constraints:
2566               // constrain dofs shared between
2567               // active elements and neighbors with
2568               // lower polynomial degrees
2569 #ifdef LIBMESH_ENABLE_AMR
2570               const unsigned int min_p_level =
2571                 neigh->min_p_level_by_neighbor(elem, elem->p_level());
2572               if (min_p_level < elem->p_level())
2573                 {
2574                   // Adaptive p refinement of non-hierarchic bases will
2575                   // require more coding
2576                   libmesh_assert(my_fe->is_hierarchic());
2577                   dof_map\&.constrain_p_dofs(variable_number, elem,
2578                                            s, min_p_level);
2579                 }
2580 #endif // #ifdef LIBMESH_ENABLE_AMR
2581             }
2582         }
2583     }
2584 }
.fi
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::compute_proj_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.PP
Definition at line 1595 of file fe_base\&.C\&.
.PP
References std::abs(), libMesh::Elem::active(), libMesh::C_ONE, libMesh::C_ZERO, libMesh::DenseMatrix< T >::cholesky_solve(), libMesh::DofMap::constrain_p_dofs(), libMesh::FEType::default_quadrature_order(), libMesh::Elem::dim(), libMesh::DISCONTINUOUS, libMesh::DofMap::dof_indices(), libMesh::FEInterface::dofs_on_side(), libMesh::TensorTools::inner_product(), libMesh::DofObject::invalid_id, libMesh::FEInterface::inverse_map(), libMesh::DofMap::is_constrained_dof(), libMesh::Elem::level(), libMesh::libmesh_assert(), std::min(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::n_neighbors(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::p_level(), libMesh::Real, libMesh::DenseVector< T >::resize(), libMesh::DenseMatrix< T >::resize(), libMesh::Threads::spin_mtx, libMesh::TOLERANCE, libMesh::DofMap::variable_type(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
Referenced by libMesh::FE< Dim, T >::compute_constraints()\&.
.PP
.nf
1599 {
1600   libmesh_assert(elem);
1601 
1602   const unsigned int Dim = elem->dim();
1603 
1604   // Only constrain elements in 2,3D\&.
1605   if (Dim == 1)
1606     return;
1607 
1608   // Only constrain active elements with this method
1609   if (!elem->active())
1610     return;
1611 
1612   const FEType& base_fe_type = dof_map\&.variable_type(variable_number);
1613 
1614   // Construct FE objects for this element and its neighbors\&.
1615   AutoPtr<FEGenericBase<OutputShape> > my_fe
1616     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1617   const FEContinuity cont = my_fe->get_continuity();
1618 
1619   // We don't need to constrain discontinuous elements
1620   if (cont == DISCONTINUOUS)
1621     return;
1622   libmesh_assert (cont == C_ZERO || cont == C_ONE);
1623 
1624   AutoPtr<FEGenericBase<OutputShape> > neigh_fe
1625     (FEGenericBase<OutputShape>::build(Dim, base_fe_type));
1626 
1627   QGauss my_qface(Dim-1, base_fe_type\&.default_quadrature_order());
1628   my_fe->attach_quadrature_rule (&my_qface);
1629   std::vector<Point> neigh_qface;
1630 
1631   const std::vector<Real>& JxW = my_fe->get_JxW();
1632   const std::vector<Point>& q_point = my_fe->get_xyz();
1633   const std::vector<std::vector<OutputShape> >& phi = my_fe->get_phi();
1634   const std::vector<std::vector<OutputShape> >& neigh_phi =
1635     neigh_fe->get_phi();
1636   const std::vector<Point> *face_normals = NULL;
1637   const std::vector<std::vector<OutputGradient> > *dphi = NULL;
1638   const std::vector<std::vector<OutputGradient> > *neigh_dphi = NULL;
1639 
1640   std::vector<dof_id_type> my_dof_indices, neigh_dof_indices;
1641   std::vector<unsigned int> my_side_dofs, neigh_side_dofs;
1642 
1643   if (cont != C_ZERO)
1644     {
1645       const std::vector<Point>& ref_face_normals =
1646         my_fe->get_normals();
1647       face_normals = &ref_face_normals;
1648       const std::vector<std::vector<OutputGradient> >& ref_dphi =
1649         my_fe->get_dphi();
1650       dphi = &ref_dphi;
1651       const std::vector<std::vector<OutputGradient> >& ref_neigh_dphi =
1652         neigh_fe->get_dphi();
1653       neigh_dphi = &ref_neigh_dphi;
1654     }
1655 
1656   DenseMatrix<Real> Ke;
1657   DenseVector<Real> Fe;
1658   std::vector<DenseVector<Real> > Ue;
1659 
1660   // Look at the element faces\&.  Check to see if we need to
1661   // build constraints\&.
1662   for (unsigned int s=0; s<elem->n_sides(); s++)
1663     if (elem->neighbor(s) != NULL)
1664       {
1665         // Get pointers to the element's neighbor\&.
1666         const Elem* neigh = elem->neighbor(s);
1667 
1668         // h refinement constraints:
1669         // constrain dofs shared between
1670         // this element and ones coarser
1671         // than this element\&.
1672         if (neigh->level() < elem->level())
1673           {
1674             unsigned int s_neigh = neigh->which_neighbor_am_i(elem);
1675             libmesh_assert_less (s_neigh, neigh->n_neighbors());
1676 
1677             // Find the minimum p level; we build the h constraint
1678             // matrix with this and then constrain away all higher p
1679             // DoFs\&.
1680             libmesh_assert(neigh->active());
1681             const unsigned int min_p_level =
1682               std::min(elem->p_level(), neigh->p_level());
1683 
1684             // we may need to make the FE objects reinit with the
1685             // minimum shared p_level
1686             // FIXME - I hate using const_cast<> and avoiding
1687             // accessor functions; there's got to be a
1688             // better way to do this!
1689             const unsigned int old_elem_level = elem->p_level();
1690             if (old_elem_level != min_p_level)
1691               (const_cast<Elem *>(elem))->hack_p_level(min_p_level);
1692             const unsigned int old_neigh_level = neigh->p_level();
1693             if (old_neigh_level != min_p_level)
1694               (const_cast<Elem *>(neigh))->hack_p_level(min_p_level);
1695 
1696             my_fe->reinit(elem, s);
1697 
1698             // This function gets called element-by-element, so there
1699             // will be a lot of memory allocation going on\&.  We can
1700             // at least minimize this for the case of the dof indices
1701             // by efficiently preallocating the requisite storage\&.
1702             // n_nodes is not necessarily n_dofs, but it is better
1703             // than nothing!
1704             my_dof_indices\&.reserve    (elem->n_nodes());
1705             neigh_dof_indices\&.reserve (neigh->n_nodes());
1706 
1707             dof_map\&.dof_indices (elem, my_dof_indices,
1708                                  variable_number);
1709             dof_map\&.dof_indices (neigh, neigh_dof_indices,
1710                                  variable_number);
1711 
1712             const unsigned int n_qp = my_qface\&.n_points();
1713 
1714             FEInterface::inverse_map (Dim, base_fe_type, neigh,
1715                                       q_point, neigh_qface);
1716 
1717             neigh_fe->reinit(neigh, &neigh_qface);
1718 
1719             // We're only concerned with DOFs whose values (and/or first
1720             // derivatives for C1 elements) are supported on side nodes
1721             FEInterface::dofs_on_side(elem,  Dim, base_fe_type, s,       my_side_dofs);
1722             FEInterface::dofs_on_side(neigh, Dim, base_fe_type, s_neigh, neigh_side_dofs);
1723 
1724             // We're done with functions that examine Elem::p_level(),
1725             // so let's unhack those levels
1726             if (elem->p_level() != old_elem_level)
1727               (const_cast<Elem *>(elem))->hack_p_level(old_elem_level);
1728             if (neigh->p_level() != old_neigh_level)
1729               (const_cast<Elem *>(neigh))->hack_p_level(old_neigh_level);
1730 
1731             const unsigned int n_side_dofs =
1732               libmesh_cast_int<unsigned int>(my_side_dofs\&.size());
1733             libmesh_assert_equal_to (n_side_dofs, neigh_side_dofs\&.size());
1734 
1735             Ke\&.resize (n_side_dofs, n_side_dofs);
1736             Ue\&.resize(n_side_dofs);
1737 
1738             // Form the projection matrix, (inner product of fine basis
1739             // functions against fine test functions)
1740             for (unsigned int is = 0; is != n_side_dofs; ++is)
1741               {
1742                 const unsigned int i = my_side_dofs[is];
1743                 for (unsigned int js = 0; js != n_side_dofs; ++js)
1744                   {
1745                     const unsigned int j = my_side_dofs[js];
1746                     for (unsigned int qp = 0; qp != n_qp; ++qp)
1747                       {
1748                         Ke(is,js) += JxW[qp] * TensorTools::inner_product(phi[i][qp], phi[j][qp]);
1749                         if (cont != C_ZERO)
1750                           Ke(is,js) += JxW[qp] *
1751                             TensorTools::inner_product((*dphi)[i][qp] *
1752                                                        (*face_normals)[qp],
1753                                                        (*dphi)[j][qp] *
1754                                                        (*face_normals)[qp]);
1755                       }
1756                   }
1757               }
1758 
1759             // Form the right hand sides, (inner product of coarse basis
1760             // functions against fine test functions)
1761             for (unsigned int is = 0; is != n_side_dofs; ++is)
1762               {
1763                 const unsigned int i = neigh_side_dofs[is];
1764                 Fe\&.resize (n_side_dofs);
1765                 for (unsigned int js = 0; js != n_side_dofs; ++js)
1766                   {
1767                     const unsigned int j = my_side_dofs[js];
1768                     for (unsigned int qp = 0; qp != n_qp; ++qp)
1769                       {
1770                         Fe(js) += JxW[qp] *
1771                           TensorTools::inner_product(neigh_phi[i][qp],
1772                                                      phi[j][qp]);
1773                         if (cont != C_ZERO)
1774                           Fe(js) += JxW[qp] *
1775                             TensorTools::inner_product((*neigh_dphi)[i][qp] *
1776                                                        (*face_normals)[qp],
1777                                                        (*dphi)[j][qp] *
1778                                                        (*face_normals)[qp]);
1779                       }
1780                   }
1781                 Ke\&.cholesky_solve(Fe, Ue[is]);
1782               }
1783 
1784             for (unsigned int js = 0; js != n_side_dofs; ++js)
1785               {
1786                 const unsigned int j = my_side_dofs[js];
1787                 const dof_id_type my_dof_g = my_dof_indices[j];
1788                 libmesh_assert_not_equal_to (my_dof_g, DofObject::invalid_id);
1789 
1790                 // Hunt for "constraining against myself" cases before
1791                 // we bother creating a constraint row
1792                 bool self_constraint = false;
1793                 for (unsigned int is = 0; is != n_side_dofs; ++is)
1794                   {
1795                     const unsigned int i = neigh_side_dofs[is];
1796                     const dof_id_type their_dof_g = neigh_dof_indices[i];
1797                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
1798 
1799                     if (their_dof_g == my_dof_g)
1800                       {
1801 #ifndef NDEBUG
1802                         const Real their_dof_value = Ue[is](js);
1803                         libmesh_assert_less (std::abs(their_dof_value-1\&.),
1804                                              10*TOLERANCE);
1805 
1806                         for (unsigned int k = 0; k != n_side_dofs; ++k)
1807                           libmesh_assert(k == is ||
1808                                          std::abs(Ue[k](js)) <
1809                                          10*TOLERANCE);
1810 #endif
1811 
1812                         self_constraint = true;
1813                         break;
1814                       }
1815                   }
1816 
1817                 if (self_constraint)
1818                   continue;
1819 
1820                 DofConstraintRow* constraint_row;
1821 
1822                 // we may be running constraint methods concurrently
1823                 // on multiple threads, so we need a lock to
1824                 // ensure that this constraint is "ours"
1825                 {
1826                   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1827 
1828                   if (dof_map\&.is_constrained_dof(my_dof_g))
1829                     continue;
1830 
1831                   constraint_row = &(constraints[my_dof_g]);
1832                   libmesh_assert(constraint_row->empty());
1833                 }
1834 
1835                 for (unsigned int is = 0; is != n_side_dofs; ++is)
1836                   {
1837                     const unsigned int i = neigh_side_dofs[is];
1838                     const dof_id_type their_dof_g = neigh_dof_indices[i];
1839                     libmesh_assert_not_equal_to (their_dof_g, DofObject::invalid_id);
1840                     libmesh_assert_not_equal_to (their_dof_g, my_dof_g);
1841 
1842                     const Real their_dof_value = Ue[is](js);
1843 
1844                     if (std::abs(their_dof_value) < 10*TOLERANCE)
1845                       continue;
1846 
1847                     constraint_row->insert(std::make_pair(their_dof_g,
1848                                                           their_dof_value));
1849                   }
1850               }
1851           }
1852         // p refinement constraints:
1853         // constrain dofs shared between
1854         // active elements and neighbors with
1855         // lower polynomial degrees
1856         const unsigned int min_p_level =
1857           neigh->min_p_level_by_neighbor(elem, elem->p_level());
1858         if (min_p_level < elem->p_level())
1859           {
1860             // Adaptive p refinement of non-hierarchic bases will
1861             // require more coding
1862             libmesh_assert(my_fe->is_hierarchic());
1863             dof_map\&.constrain_p_dofs(variable_number, elem,
1864                                      s, min_p_level);
1865           }
1866       }
1867 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::compute_shape_functions (const \fBElem\fP *, const std::vector< \fBPoint\fP > &)\fC [protected]\fP, \fC [virtual]\fP"
After having updated the jacobian and the transformation from local to global coordinates in FEAbstract::compute_map(), the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx/y/z\fP, \fCdphasedx/y/z\fP, \fCdweight\fP\&. This method should barely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. Overloaded method from the \fCFEBase\fP version\&. 
.PP
Reimplemented from \fBlibMesh::FEGenericBase< T >\fP\&.
.PP
Definition at line 892 of file inf_fe\&.C\&.
.PP
References libMesh::dim, libMesh::libmesh_assert(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
893 {
894   libmesh_assert(radial_qrule);
895 
896 
897 
898   // Start logging the overall computation of shape functions
899   START_LOG("compute_shape_functions()", "InfFE");
900 
901 
902   const unsigned int n_total_qp  = _n_total_qp;
903 
904 
905   //-------------------------------------------------------------------------
906   // Compute the shape function values (and derivatives)
907   // at the Quadrature points\&.  Note that the actual values
908   // have already been computed via init_shape_functions
909 
910   // Compute the value of the derivative shape function i at quadrature point p
911   switch (dim)
912     {
913 
914     case 1:
915       {
916         libmesh_not_implemented();
917         break;
918       }
919 
920     case 2:
921       {
922         libmesh_not_implemented();
923         break;
924       }
925 
926     case 3:
927       {
928         const std::vector<Real>& dxidx_map = this->_fe_map->get_dxidx();
929         const std::vector<Real>& dxidy_map = this->_fe_map->get_dxidy();
930         const std::vector<Real>& dxidz_map = this->_fe_map->get_dxidz();
931 
932         const std::vector<Real>& detadx_map = this->_fe_map->get_detadx();
933         const std::vector<Real>& detady_map = this->_fe_map->get_detady();
934         const std::vector<Real>& detadz_map = this->_fe_map->get_detadz();
935 
936         const std::vector<Real>& dzetadx_map = this->_fe_map->get_dzetadx();
937         const std::vector<Real>& dzetady_map = this->_fe_map->get_dzetady();
938         const std::vector<Real>& dzetadz_map = this->_fe_map->get_dzetadz();
939 
940         // These are _all_ shape functions of this infinite element
941         for (unsigned int i=0; i<phi\&.size(); i++)
942           for (unsigned int p=0; p<n_total_qp; p++)
943             {
944               // dphi/dx    = (dphi/dxi)*(dxi/dx) + (dphi/deta)*(deta/dx) + (dphi/dzeta)*(dzeta/dx);
945               dphi[i][p](0) =
946                 dphidx[i][p] = (dphidxi[i][p]*dxidx_map[p] +
947                                 dphideta[i][p]*detadx_map[p] +
948                                 dphidzeta[i][p]*dzetadx_map[p]);
949 
950               // dphi/dy    = (dphi/dxi)*(dxi/dy) + (dphi/deta)*(deta/dy) + (dphi/dzeta)*(dzeta/dy);
951               dphi[i][p](1) =
952                 dphidy[i][p] = (dphidxi[i][p]*dxidy_map[p] +
953                                 dphideta[i][p]*detady_map[p] +
954                                 dphidzeta[i][p]*dzetady_map[p]);
955 
956               // dphi/dz    = (dphi/dxi)*(dxi/dz) + (dphi/deta)*(deta/dz) + (dphi/dzeta)*(dzeta/dz);
957               dphi[i][p](2) =
958                 dphidz[i][p] = (dphidxi[i][p]*dxidz_map[p] +
959                                 dphideta[i][p]*detadz_map[p] +
960                                 dphidzeta[i][p]*dzetadz_map[p]);
961             }
962 
963 
964         // This is the derivative of the phase term of this infinite element
965         for (unsigned int p=0; p<n_total_qp; p++)
966           {
967             // the derivative of the phase term
968             dphase[p](0) = (dphasedxi[p]   * dxidx_map[p] +
969                             dphasedeta[p]  * detadx_map[p] +
970                             dphasedzeta[p] * dzetadx_map[p]);
971 
972             dphase[p](1) = (dphasedxi[p]   * dxidy_map[p] +
973                             dphasedeta[p]  * detady_map[p] +
974                             dphasedzeta[p] * dzetady_map[p]);
975 
976             dphase[p](2) = (dphasedxi[p]   * dxidz_map[p] +
977                             dphasedeta[p]  * detadz_map[p] +
978                             dphasedzeta[p] * dzetadz_map[p]);
979 
980             // the derivative of the radial weight - varies only in radial direction,
981             // therefore dweightdxi = dweightdeta = 0\&.
982             dweight[p](0) = dweightdv[p] * dzetadx_map[p];
983 
984             dweight[p](1) = dweightdv[p] * dzetady_map[p];
985 
986             dweight[p](2) = dweightdv[p] * dzetadz_map[p];
987 
988           }
989 
990         break;
991       }
992 
993 
994 
995     default:
996       {
997         libmesh_error();
998       }
999     }
1000 
1001 
1002 
1003   // Stop logging the overall computation of shape functions
1004   STOP_LOG("compute_shape_functions()", "InfFE");
1005 
1006 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::compute_shape_indices (const \fBFEType\fP &fet, const \fBElemType\fPinf_elem_type, const unsigned inti, unsigned int &base_shape, unsigned int &radial_shape)\fC [static]\fP, \fC [protected]\fP"
Computes the indices of shape functions in the base \fCbase_shape\fP and in radial direction \fCradial_shape\fP (0 in the base, $ \ge 1 $ further out) associated to the shape with global index \fCi\fP of an infinite element of type \fCinf_elem_type\fP\&. 
.PP
Definition at line 727 of file inf_fe_static\&.C\&.
.PP
References libMesh::INFEDGE2, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, libMesh::INFQUAD6, libMesh::invalid_uint, libMesh::FEInterface::n_dofs_at_node(), libMesh::FEInterface::n_dofs_per_elem(), and libMesh::FEType::radial_order\&.
.PP
.nf
732 {
733 
734   /*
735    * An example is provided:  the numbers in comments refer to
736    * a fictitious InfHex18\&.  The numbers are chosen as exemplary
737    * values\&.  There is currently no base approximation that
738    * requires this many dof's at nodes, sides, faces and in the element\&.
739    *
740    * the order of the shape functions is heavily related with the
741    * order the dofs are assigned in \p DofMap::distributed_dofs()\&.
742    * Due to the infinite elements with higher-order base approximation,
743    * some more effort is necessary\&.
744    *
745    * numbering scheme:
746    * 1\&. all vertices in the base, assign node->n_comp() dofs to each vertex
747    * 2\&. all vertices further out: innermost loop: radial shapes,
748    *    then the base approximation shapes
749    * 3\&. all side nodes in the base, assign node->n_comp() dofs to each side node
750    * 4\&. all side nodes further out: innermost loop: radial shapes,
751    *    then the base approximation shapes
752    * 5\&. (all) face nodes in the base, assign node->n_comp() dofs to each face node
753    * 6\&. (all) face nodes further out: innermost loop: radial shapes,
754    *    then the base approximation shapes
755    * 7\&. element-associated dof in the base
756    * 8\&. element-associated dof further out
757    */
758 
759   const unsigned int radial_order       = static_cast<unsigned int>(fet\&.radial_order);             // 4
760   const unsigned int radial_order_p_one = radial_order+1;                                          // 5
761 
762   const ElemType base_elem_type           (Base::get_elem_type(inf_elem_type));                    // QUAD9
763 
764   // assume that the number of dof is the same for all vertices
765   unsigned int n_base_vertices         = libMesh::invalid_uint;                                    // 4
766   const unsigned int n_base_vertex_dof = FEInterface::n_dofs_at_node  (Dim-1, fet, base_elem_type, 0);// 2
767 
768   unsigned int n_base_side_nodes       = libMesh::invalid_uint;                                    // 4
769   unsigned int n_base_side_dof         = libMesh::invalid_uint;                                    // 3
770 
771   unsigned int n_base_face_nodes       = libMesh::invalid_uint;                                    // 1
772   unsigned int n_base_face_dof         = libMesh::invalid_uint;                                    // 5
773 
774   const unsigned int n_base_elem_dof   = FEInterface::n_dofs_per_elem (Dim-1, fet, base_elem_type);// 9
775 
776 
777   switch (inf_elem_type)
778     {
779     case INFEDGE2:
780       {
781         n_base_vertices   = 1;
782         n_base_side_nodes = 0;
783         n_base_face_nodes = 0;
784         n_base_side_dof   = 0;
785         n_base_face_dof   = 0;
786         break;
787       }
788 
789     case INFQUAD4:
790       {
791         n_base_vertices   = 2;
792         n_base_side_nodes = 0;
793         n_base_face_nodes = 0;
794         n_base_side_dof   = 0;
795         n_base_face_dof   = 0;
796         break;
797       }
798 
799     case INFQUAD6:
800       {
801         n_base_vertices   = 2;
802         n_base_side_nodes = 1;
803         n_base_face_nodes = 0;
804         n_base_side_dof   = FEInterface::n_dofs_at_node (Dim-1, fet,base_elem_type, n_base_vertices);
805         n_base_face_dof   = 0;
806         break;
807       }
808 
809     case INFHEX8:
810       {
811         n_base_vertices   = 4;
812         n_base_side_nodes = 0;
813         n_base_face_nodes = 0;
814         n_base_side_dof   = 0;
815         n_base_face_dof   = 0;
816         break;
817       }
818 
819     case INFHEX16:
820       {
821         n_base_vertices   = 4;
822         n_base_side_nodes = 4;
823         n_base_face_nodes = 0;
824         n_base_side_dof   = FEInterface::n_dofs_at_node (Dim-1, fet,base_elem_type, n_base_vertices);
825         n_base_face_dof   = 0;
826         break;
827       }
828 
829     case INFHEX18:
830       {
831         n_base_vertices   = 4;
832         n_base_side_nodes = 4;
833         n_base_face_nodes = 1;
834         n_base_side_dof   = FEInterface::n_dofs_at_node (Dim-1, fet,base_elem_type, n_base_vertices);
835         n_base_face_dof   = FEInterface::n_dofs_at_node (Dim-1, fet,base_elem_type, 8);
836         break;
837       }
838 
839 
840     case INFPRISM6:
841       {
842         n_base_vertices   = 3;
843         n_base_side_nodes = 0;
844         n_base_face_nodes = 0;
845         n_base_side_dof   = 0;
846         n_base_face_dof   = 0;
847         break;
848       }
849 
850     case INFPRISM12:
851       {
852         n_base_vertices   = 3;
853         n_base_side_nodes = 3;
854         n_base_face_nodes = 0;
855         n_base_side_dof   = FEInterface::n_dofs_at_node (Dim-1, fet,base_elem_type, n_base_vertices);
856         n_base_face_dof   = 0;
857         break;
858       }
859 
860     default:
861       libmesh_error();
862     }
863 
864 
865   {
866     // these are the limits describing the intervals where the shape function lies
867     const unsigned int n_dof_at_base_vertices = n_base_vertices*n_base_vertex_dof;                 // 8
868     const unsigned int n_dof_at_all_vertices  = n_dof_at_base_vertices*radial_order_p_one;         // 40
869 
870     const unsigned int n_dof_at_base_sides    = n_base_side_nodes*n_base_side_dof;                 // 12
871     const unsigned int n_dof_at_all_sides     = n_dof_at_base_sides*radial_order_p_one;            // 60
872 
873     const unsigned int n_dof_at_base_face     = n_base_face_nodes*n_base_face_dof;                 // 5
874     const unsigned int n_dof_at_all_faces     = n_dof_at_base_face*radial_order_p_one;             // 25
875 
876 
877     // start locating the shape function
878     if (i < n_dof_at_base_vertices)                                              // range of i: 0\&.\&.7
879       {
880         // belongs to vertex in the base
881         radial_shape = 0;
882         base_shape   = i;
883       }
884 
885     else if (i < n_dof_at_all_vertices)                                          // range of i: 8\&.\&.39
886       {
887         /* belongs to vertex in the outer shell
888          *
889          * subtract the number of dof already counted,
890          * so that i_offset contains only the offset for the base
891          */
892         const unsigned int i_offset = i - n_dof_at_base_vertices;                // 0\&.\&.31
893 
894         // first the radial dof are counted, then the base dof
895         radial_shape = (i_offset % radial_order) + 1;
896         base_shape   = i_offset / radial_order;
897       }
898 
899     else if (i < n_dof_at_all_vertices+n_dof_at_base_sides)                      // range of i: 40\&.\&.51
900       {
901         // belongs to base, is a side node
902         radial_shape = 0;
903         base_shape = i - radial_order * n_dof_at_base_vertices;                  //  8\&.\&.19
904       }
905 
906     else if (i < n_dof_at_all_vertices+n_dof_at_all_sides)                       // range of i: 52\&.\&.99
907       {
908         // belongs to side node in the outer shell
909         const unsigned int i_offset = i - (n_dof_at_all_vertices
910                                            + n_dof_at_base_sides);               // 0\&.\&.47
911         radial_shape = (i_offset % radial_order) + 1;
912         base_shape   = (i_offset / radial_order) + n_dof_at_base_vertices;
913       }
914 
915     else if (i < n_dof_at_all_vertices+n_dof_at_all_sides+n_dof_at_base_face)    // range of i: 100\&.\&.104
916       {
917         // belongs to the node in the base face
918         radial_shape = 0;
919         base_shape = i - radial_order*(n_dof_at_base_vertices
920                                        + n_dof_at_base_sides);                   //  20\&.\&.24
921       }
922 
923     else if (i < n_dof_at_all_vertices+n_dof_at_all_sides+n_dof_at_all_faces)    // range of i: 105\&.\&.124
924       {
925         // belongs to the node in the outer face
926         const unsigned int i_offset = i - (n_dof_at_all_vertices
927                                            + n_dof_at_all_sides
928                                            + n_dof_at_base_face);                // 0\&.\&.19
929         radial_shape = (i_offset % radial_order) + 1;
930         base_shape   = (i_offset / radial_order) + n_dof_at_base_vertices + n_dof_at_base_sides;
931       }
932 
933     else if (i < n_dof_at_all_vertices+n_dof_at_all_sides+n_dof_at_all_faces+n_base_elem_dof)      // range of i: 125\&.\&.133
934       {
935         // belongs to the base and is an element associated shape
936         radial_shape = 0;
937         base_shape = i - (n_dof_at_all_vertices
938                           + n_dof_at_all_sides
939                           + n_dof_at_all_faces);                                 // 0\&.\&.8
940       }
941 
942     else                                                                         // range of i: 134\&.\&.169
943       {
944         libmesh_assert_less (i, n_dofs(fet, inf_elem_type));
945         // belongs to the outer shell and is an element associated shape
946         const unsigned int i_offset = i - (n_dof_at_all_vertices
947                                            + n_dof_at_all_sides
948                                            + n_dof_at_all_faces
949                                            + n_base_elem_dof);                   // 0\&.\&.19
950         radial_shape = (i_offset % radial_order) + 1;
951         base_shape   = (i_offset / radial_order) + n_dof_at_base_vertices + n_dof_at_base_sides + n_dof_at_base_face;
952       }
953   }
954 
955   return;
956 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_base> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_base >::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
Not implemented yet\&. Reinitializes all the physical element-dependent data based on the \fCedge\fP of an infinite element\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 117 of file inf_fe_boundary\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
122 {
123   // We don't do this for 1D elements!
124   //libmesh_assert_not_equal_to (Dim, 1);
125 
126   libMesh::err << "ERROR: Edge conditions for infinite elements "
127                << "not implemented!" << std::endl;
128   libmesh_error();
129 
130   if (pts != NULL)
131     {
132       libMesh::err << "ERROR: User-specified points for infinite elements "
133                    << "not implemented!" << std::endl;
134       libmesh_error();
135     }
136 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 81 of file inf_fe_map_eval\&.C\&.
.PP
.nf
81 { return infinite_map_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 82 of file inf_fe_map_eval\&.C\&.
.PP
.nf
82 { return infinite_map_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 83 of file inf_fe_map_eval\&.C\&.
.PP
.nf
83 { return infinite_map_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 322 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
322 { return legendre_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 323 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
323 { return legendre_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 324 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
324 { return legendre_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 467 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
467 { return jacobi_30_00_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 468 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
468 { return jacobi_30_00_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 469 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
469 { return jacobi_30_00_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 473 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
473 { return jacobi_20_00_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 474 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
474 { return jacobi_20_00_eval(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 475 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
475 { return jacobi_20_00_eval(v, i); }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> static \fBReal\fP \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::eval (\fBReal\fPv, \fBOrder\fPo_radial, unsigned inti)\fC [static]\fP, \fC [protected]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ polynomial evaluated at \fCv\fP\&. This method provides the approximation in radial direction for the overall shape functions, which is defined in \fC\fBInfFE::shape()\fP\fP\&. This method is allowed to be static, since it is independent of dimension and base_family\&. It is templated, though, w\&.r\&.t\&. to radial \fCFEFamily\fP\&.
.RE
.PP
Specialized for \fCT_radial=INFINITE_MAP\fP, this function returns the value of the $ i^{th} $ \fImapping\fP shape function in radial direction evaluated at \fCv\fP\&. Currently, only one specific mapping shape is used\&. Namely the one by Marques JMMC, Owen DRJ: Infinite elements in quasi-static materially nonlinear problems, \fIComputers\fP \fIand\fP \fIStructures\fP, 1984\&. 
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_radial_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::shape()\&.
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2649 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2649 { return lagrange_eval(v, o, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2650 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2650 { return lagrange_eval(v, o, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2651 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2651 { return lagrange_eval(v, o, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 87 of file inf_fe_map_eval\&.C\&.
.PP
.nf
87 { return infinite_map_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 88 of file inf_fe_map_eval\&.C\&.
.PP
.nf
88 { return infinite_map_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBINFINITE_MAP\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 89 of file inf_fe_map_eval\&.C\&.
.PP
.nf
89 { return infinite_map_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 328 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
328 { return legendre_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 329 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
329 { return legendre_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBLEGENDRE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 330 of file inf_fe_legendre_eval\&.C\&.
.PP
.nf
330 { return legendre_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 473 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
473 { return jacobi_30_00_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 474 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
474 { return jacobi_30_00_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBJACOBI_30_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 475 of file inf_fe_jacobi_30_00_eval\&.C\&.
.PP
.nf
475 { return jacobi_30_00_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 479 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
479 { return jacobi_20_00_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 480 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
480 { return jacobi_20_00_eval_deriv(v, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBJACOBI_20_00\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fP, unsignedi)\fC [protected]\fP"

.PP
Definition at line 481 of file inf_fe_jacobi_20_00_eval\&.C\&.
.PP
.nf
481 { return jacobi_20_00_eval_deriv(v, i); }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> static \fBReal\fP \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::eval_deriv (\fBReal\fPv, \fBOrder\fPo_radial, unsigned inti)\fC [static]\fP, \fC [protected]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the first derivative of the $ i^{th} $ polynomial at coordinate \fCv\fP\&. See \fCeval\fP for details\&. 
.RE
.PP

.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_radial_shape_functions(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map()\&.
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 1, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2655 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2655 { return lagrange_eval_deriv(v, o, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 2, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2656 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2656 { return lagrange_eval_deriv(v, o, i); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::InfFE\fP< 3, \fBLAGRANGE\fP, \fBCARTESIAN\fP >::eval_deriv (\fBReal\fPv, \fBOrder\fPo, unsignedi)\fC [protected]\fP"

.PP
Definition at line 2657 of file inf_fe_lagrange_eval\&.C\&.
.PP
.nf
2657 { return lagrange_eval_deriv(v, o, i); }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual \fBFEContinuity\fP \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::get_continuity () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity of the element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 340 of file inf_fe\&.h\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
341   { return C_ZERO; }  // FIXME - is this true??
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_curl_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curl of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 225 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEMContext::interior_curl()\&.
.PP
.nf
226   { libmesh_assert(!calculations_started || calculate_curl_phi);
227     calculate_curl_phi = calculate_dphiref = true; return curl_phi; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputTensor\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_interior_hessian(), libMesh::FEMContext::fixed_side_hessian(), libMesh::FEMContext::interior_hessian(), libMesh::FEMContext::interior_hessians(), libMesh::FEMContext::side_hessian(), and libMesh::FEMContext::side_hessians()\&.
.PP
.nf
292   { libmesh_assert(!calculations_started || calculate_d2phi);
293     calculate_d2phi = calculate_dphiref = true; return d2phi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phideta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 371 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
372   { libmesh_assert(!calculations_started || calculate_d2phi);
373     calculate_d2phi = calculate_dphiref = true; return d2phideta2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 379 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
380   { libmesh_assert(!calculations_started || calculate_d2phi);
381     calculate_d2phi = calculate_dphiref = true; return d2phidetadzeta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidx2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_base\&.h\&.
.PP
.nf
300   { libmesh_assert(!calculations_started || calculate_d2phi);
301     calculate_d2phi = calculate_dphiref = true; return d2phidx2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxdy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 307 of file fe_base\&.h\&.
.PP
.nf
308   { libmesh_assert(!calculations_started || calculate_d2phi);
309     calculate_d2phi = calculate_dphiref = true; return d2phidxdy; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxdz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 315 of file fe_base\&.h\&.
.PP
.nf
316   { libmesh_assert(!calculations_started || calculate_d2phi);
317     calculate_d2phi = calculate_dphiref = true; return d2phidxdz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 347 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
348   { libmesh_assert(!calculations_started || calculate_d2phi);
349     calculate_d2phi = calculate_dphiref = true; return d2phidxi2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 355 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
356   { libmesh_assert(!calculations_started || calculate_d2phi);
357     calculate_d2phi = calculate_dphiref = true; return d2phidxideta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 363 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
364   { libmesh_assert(!calculations_started || calculate_d2phi);
365     calculate_d2phi = calculate_dphiref = true; return d2phidxidzeta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidy2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 323 of file fe_base\&.h\&.
.PP
.nf
324   { libmesh_assert(!calculations_started || calculate_d2phi);
325     calculate_d2phi =  calculate_dphiref = true; return d2phidy2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidydz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 331 of file fe_base\&.h\&.
.PP
.nf
332   { libmesh_assert(!calculations_started || calculate_d2phi);
333     calculate_d2phi = calculate_dphiref = true; return d2phidydz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidz2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 339 of file fe_base\&.h\&.
.PP
.nf
340   { libmesh_assert(!calculations_started || calculate_d2phi);
341     calculate_d2phi = calculate_dphiref = true; return d2phidz2; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_d2phidzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 387 of file fe_base\&.h\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_d2phi()\&.
.PP
.nf
388   { libmesh_assert(!calculations_started || calculate_d2phi);
389     calculate_d2phi = calculate_dphiref = true; return d2phidzeta2; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputDivergence\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_div_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the divergence of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 233 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEMContext::interior_div()\&.
.PP
.nf
234   { libmesh_assert(!calculations_started || calculate_div_phi);
235     calculate_div_phi = calculate_dphiref = true; return div_phi; }
.fi
.SS "template<typename T> const std::vector<\fBOutputGradient\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_dphase () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global first derivative of the phase term which is used in infinite elements, evaluated at the quadrature points\&.
.RE
.PP
In case of the general finite element class \fC\fBFE\fP\fP this field is initialized to all zero, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 405 of file fe_base\&.h\&.
.PP
.nf
406   { return dphase; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputGradient\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 217 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_side_gradient(), libMesh::FEMContext::interior_gradient(), libMesh::FEMContext::interior_gradients(), libMesh::ProjectFEMSolution::operator()(), libMesh::FEMContext::side_gradient(), and libMesh::FEMContext::side_gradients()\&.
.PP
.nf
218   { libmesh_assert(!calculations_started || calculate_dphi);
219     calculate_dphi = calculate_dphiref = true; return dphi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function eta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 273 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
274   { libmesh_assert(!calculations_started || calculate_dphiref);
275     calculate_dphiref = true; return dphideta; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function x-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_base\&.h\&.
.PP
.nf
242   { libmesh_assert(!calculations_started || calculate_dphi);
243     calculate_dphi = calculate_dphiref = true; return dphidx; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function xi-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 265 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
266   { libmesh_assert(!calculations_started || calculate_dphiref);
267     calculate_dphiref = true; return dphidxi; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function y-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 249 of file fe_base\&.h\&.
.PP
.nf
250   { libmesh_assert(!calculations_started || calculate_dphi);
251     calculate_dphi = calculate_dphiref = true; return dphidy; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function z-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_base\&.h\&.
.PP
.nf
258   { libmesh_assert(!calculations_started || calculate_dphi);
259     calculate_dphi = calculate_dphiref = true; return dphidz; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_dphidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function zeta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 281 of file fe_base\&.h\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_div(), and libMesh::H1FETransformation< T >::map_dphi()\&.
.PP
.nf
282   { libmesh_assert(!calculations_started || calculate_dphiref);
283     calculate_dphiref = true; return dphidzeta; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level, libMesh::FEAbstract::fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "template<typename T> const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< T >::get_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function values at the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 209 of file fe_base\&.h\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMContext::fixed_interior_value(), libMesh::FEMContext::fixed_side_value(), libMesh::FEMSystem::init_context(), libMesh::FEMContext::interior_value(), libMesh::FEMContext::interior_values(), libMesh::ProjectFEMSolution::operator()(), libMesh::FEMContext::side_value(), and libMesh::FEMContext::side_values()\&.
.PP
.nf
210   { libmesh_assert(!calculations_started || calculate_phi);
211     calculate_phi = true; return phi; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP, \fC [inherited]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "template<typename T> const std::vector<\fBRealGradient\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_Sobolev_dweight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the first global derivative of the multiplicative weight at each quadrature point\&. See \fC\fBget_Sobolev_weight()\fP\fP for details\&. In case of \fC\fBFE\fP\fP initialized to all zero\&. 
.RE
.PP

.PP
Definition at line 429 of file fe_base\&.h\&.
.PP
.nf
430   { return dweight; }
.fi
.SS "template<typename T> const std::vector<\fBReal\fP>& \fBlibMesh::FEGenericBase\fP< T >::get_Sobolev_weight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the multiplicative weight at each quadrature point\&. This weight is used for certain infinite element weak formulations, so that \fIweighted\fP Sobolev spaces are used for the trial function space\&. This renders the variational form easily computable\&.
.RE
.PP
In case of the general finite element class \fC\fBFE\fP\fP this field is initialized to all ones, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 421 of file fe_base\&.h\&.
.PP
.nf
422   { return weight; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual void \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::init_base_shape_functions (const std::vector< \fBPoint\fP > &, const \fBElem\fP *)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"
Do not use this derived member in \fCInfFE<Dim,T_radial,T_map>\fP\&. 
.PP
Implements \fBlibMesh::FEGenericBase< T >\fP\&.
.PP
Definition at line 520 of file inf_fe\&.h\&.
.PP
.nf
522   { libmesh_error(); }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_base> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_base >::init_face_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *side)\fC [protected]\fP"
Not implemented yet\&. Initialize all the data fields like \fCweight\fP, \fCphi\fP, etc for the side \fCs\fP\&. 
.PP
Definition at line 142 of file inf_fe_boundary\&.C\&.
.PP
References libMesh::FEGenericBase< T >::build(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::AutoPtr< Tp >::release(), and libMesh::Elem::type()\&.
.PP
.nf
144 {
145   libmesh_assert(inf_side);
146 
147   // Currently, this makes only sense in 3-D!
148   libmesh_assert_equal_to (Dim, 3);
149 
150   // Initialiize the radial shape functions
151   this->init_radial_shape_functions(inf_side);
152 
153   // Initialize the base shape functions
154   this->update_base_elem(inf_side);
155 
156   // Initialize the base quadratur rule
157   base_qrule->init(base_elem->type(), inf_side->p_level());
158 
159   // base_fe still corresponds to the (dim-1)-dimensional base of the InfFE object,
160   // so update the fe_base\&.
161   {
162     libmesh_assert_equal_to (Dim, 3);
163 
164     AutoPtr<FEBase> ap_fb(FEBase::build(Dim-2, this->fe_type));
165 
166     delete base_fe;
167     base_fe = ap_fb\&.release();
168     base_fe->attach_quadrature_rule(base_qrule);
169   }
170 
171   // initialize the shape functions on the base
172   base_fe->init_base_shape_functions(base_fe->qrule->get_points(),
173                                      base_elem);
174 
175   // the number of quadrature points
176   const unsigned int n_radial_qp =
177     libmesh_cast_int<unsigned int>(som\&.size());
178   const unsigned int n_base_qp   = base_qrule->n_points();
179   const unsigned int n_total_qp  = n_radial_qp * n_base_qp;
180 
181   // the quadratur weigths
182   _total_qrule_weights\&.resize(n_total_qp);
183 
184   // now inite the shapes for boundary work
185   {
186 
187     // The element type and order to use in the base map
188     const Order    base_mapping_order     ( base_elem->default_order() );
189     const ElemType base_mapping_elem_type ( base_elem->type()          );
190 
191     // the number of mapping shape functions
192     // (Lagrange shape functions are used for mapping in the base)
193     const unsigned int n_radial_mapping_sf =
194       libmesh_cast_int<unsigned int>(radial_map\&.size());
195     const unsigned int n_base_mapping_shape_functions = Base::n_base_mapping_sf(base_mapping_elem_type,
196                                                                                 base_mapping_order);
197 
198     const unsigned int n_total_mapping_shape_functions =
199       n_radial_mapping_sf * n_base_mapping_shape_functions;
200 
201 
202     // initialize the node and shape numbering maps
203     {
204       _radial_node_index\&.resize    (n_total_mapping_shape_functions);
205       _base_node_index\&.resize      (n_total_mapping_shape_functions);
206 
207       const ElemType inf_face_elem_type (inf_side->type());
208 
209       // fill the node index map
210       for (unsigned int n=0; n<n_total_mapping_shape_functions; n++)
211         {
212           compute_node_indices (inf_face_elem_type,
213                                 n,
214                                 _base_node_index[n],
215                                 _radial_node_index[n]);
216 
217           libmesh_assert_less (_base_node_index[n], n_base_mapping_shape_functions);
218           libmesh_assert_less (_radial_node_index[n], n_radial_mapping_sf);
219         }
220 
221     }
222 
223     // rezise map data fields
224     {
225       std::vector<std::vector<Real> >& psi_map = this->_fe_map->get_psi();
226       std::vector<std::vector<Real> >& dpsidxi_map = this->_fe_map->get_dpsidxi();
227       std::vector<std::vector<Real> >& d2psidxi2_map = this->_fe_map->get_d2psidxi2();
228       psi_map\&.resize          (n_total_mapping_shape_functions);
229       dpsidxi_map\&.resize      (n_total_mapping_shape_functions);
230       d2psidxi2_map\&.resize    (n_total_mapping_shape_functions);
231 
232       //  if (Dim == 3)
233       {
234         std::vector<std::vector<Real> >& dpsideta_map = this->_fe_map->get_dpsideta();
235         std::vector<std::vector<Real> >& d2psidxideta_map = this->_fe_map->get_d2psidxideta();
236         std::vector<std::vector<Real> >& d2psideta2_map = this->_fe_map->get_d2psideta2();
237         dpsideta_map\&.resize     (n_total_mapping_shape_functions);
238         d2psidxideta_map\&.resize (n_total_mapping_shape_functions);
239         d2psideta2_map\&.resize   (n_total_mapping_shape_functions);
240       }
241 
242       for (unsigned int i=0; i<n_total_mapping_shape_functions; i++)
243         {
244           psi_map[i]\&.resize         (n_total_qp);
245           dpsidxi_map[i]\&.resize     (n_total_qp);
246           d2psidxi2_map[i]\&.resize   (n_total_qp);
247 
248           // if (Dim == 3)
249           {
250             std::vector<std::vector<Real> >& dpsideta_map = this->_fe_map->get_dpsideta();
251             std::vector<std::vector<Real> >& d2psidxideta_map = this->_fe_map->get_d2psidxideta();
252             std::vector<std::vector<Real> >& d2psideta2_map = this->_fe_map->get_d2psideta2();
253             dpsideta_map[i]\&.resize     (n_total_qp);
254             d2psidxideta_map[i]\&.resize (n_total_qp);
255             d2psideta2_map[i]\&.resize   (n_total_qp);
256           }
257         }
258     }
259 
260 
261     // compute shape maps
262     {
263       const std::vector<std::vector<Real> >& S_map  = (base_fe->get_fe_map())\&.get_phi_map();
264       const std::vector<std::vector<Real> >& Ss_map = (base_fe->get_fe_map())\&.get_dphidxi_map();
265 
266       std::vector<std::vector<Real> >& psi_map = this->_fe_map->get_psi();
267       std::vector<std::vector<Real> >& dpsidxi_map = this->_fe_map->get_dpsidxi();
268       std::vector<std::vector<Real> >& dpsideta_map = this->_fe_map->get_dpsideta();
269 
270       for (unsigned int rp=0; rp<n_radial_qp; rp++)  // over radial qp's
271         for (unsigned int bp=0; bp<n_base_qp; bp++)  // over base qp's
272           for (unsigned int ti=0; ti<n_total_mapping_shape_functions; ti++)  // over all mapping shapes
273             {
274               // let the index vectors take care of selecting the appropriate base/radial mapping shape
275               const unsigned int bi = _base_node_index  [ti];
276               const unsigned int ri = _radial_node_index[ti];
277               psi_map          [ti][bp+rp*n_base_qp] = S_map [bi][bp] * radial_map   [ri][rp];
278               dpsidxi_map      [ti][bp+rp*n_base_qp] = Ss_map[bi][bp] * radial_map   [ri][rp];
279               dpsideta_map     [ti][bp+rp*n_base_qp] = S_map [bi][bp] * dradialdv_map[ri][rp];
280 
281               // second derivatives are not implemented for infinite elements
282               // d2psidxi2_map    [ti][bp+rp*n_base_qp] = 0\&.;
283               // d2psidxideta_map [ti][bp+rp*n_base_qp] = 0\&.;
284               // d2psideta2_map   [ti][bp+rp*n_base_qp] = 0\&.;
285             }
286 
287     }
288 
289   }
290 
291   // quadrature rule weights
292   {
293     const std::vector<Real>&   radial_qw = radial_qrule->get_weights();
294     const std::vector<Real>&   base_qw   = base_qrule->get_weights();
295 
296     libmesh_assert_equal_to (radial_qw\&.size(), n_radial_qp);
297     libmesh_assert_equal_to (base_qw\&.size(), n_base_qp);
298 
299     for (unsigned int rp=0; rp<n_radial_qp; rp++)
300       for (unsigned int bp=0; bp<n_base_qp; bp++)
301         {
302           _total_qrule_weights[  bp+rp*n_base_qp ] = radial_qw[rp] * base_qw[bp];
303         }
304   }
305 
306 }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::init_radial_shape_functions (const \fBElem\fP *inf_elem)\fC [protected]\fP"
Some of the member data only depend on the radial part of the infinite element\&. The parts that only change when the radial order changes, are initialized here\&. Start logging the radial shape function initialization
.PP
Stop logging the radial shape function initialization
.PP
Definition at line 280 of file inf_fe\&.C\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval_deriv(), libMesh::libmesh_assert(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
281 {
282   libmesh_assert(radial_qrule);
283   libmesh_assert(inf_elem);
284 
285 
289   START_LOG("init_radial_shape_functions()", "InfFE");
290 
291 
292   // -----------------------------------------------------------------
293   // initialize most of the things related to mapping
294 
295   // The order to use in the radial map (currently independent of the element type)
296   const Order        radial_mapping_order             (Radial::mapping_order());
297   const unsigned int n_radial_mapping_shape_functions (Radial::n_dofs(radial_mapping_order));
298 
299 
300 
301   // -----------------------------------------------------------------
302   // initialize most of the things related to physical approximation
303 
304   const Order        radial_approx_order             (fe_type\&.radial_order);
305   const unsigned int n_radial_approx_shape_functions (Radial::n_dofs(radial_approx_order));
306 
307   const unsigned int        n_radial_qp = radial_qrule->n_points();
308   const std::vector<Point>&   radial_qp = radial_qrule->get_points();
309 
310 
311 
312   // -----------------------------------------------------------------
313   // resize the radial data fields
314 
315   mode\&.resize      (n_radial_approx_shape_functions);       // the radial polynomials (eval)
316   dmodedv\&.resize   (n_radial_approx_shape_functions);
317 
318   som\&.resize       (n_radial_qp);                           // the (1-v)/2 weight
319   dsomdv\&.resize    (n_radial_qp);
320 
321   radial_map\&.resize    (n_radial_mapping_shape_functions);  // the radial map
322   dradialdv_map\&.resize (n_radial_mapping_shape_functions);
323 
324 
325   for (unsigned int i=0; i<n_radial_mapping_shape_functions; i++)
326     {
327       radial_map[i]\&.resize    (n_radial_qp);
328       dradialdv_map[i]\&.resize (n_radial_qp);
329     }
330 
331 
332   for (unsigned int i=0; i<n_radial_approx_shape_functions; i++)
333     {
334       mode[i]\&.resize    (n_radial_qp);
335       dmodedv[i]\&.resize (n_radial_qp);
336     }
337 
338 
339   // compute scalar values at radial quadrature points
340   for (unsigned int p=0; p<n_radial_qp; p++)
341     {
342       som[p]       = Radial::decay       (radial_qp[p](0));
343       dsomdv[p]    = Radial::decay_deriv (radial_qp[p](0));
344     }
345 
346 
347   // evaluate the mode shapes in radial direction at radial quadrature points
348   for (unsigned int i=0; i<n_radial_approx_shape_functions; i++)
349     for (unsigned int p=0; p<n_radial_qp; p++)
350       {
351         mode[i][p]    = InfFE<Dim,T_radial,T_map>::eval       (radial_qp[p](0), radial_approx_order, i);
352         dmodedv[i][p] = InfFE<Dim,T_radial,T_map>::eval_deriv (radial_qp[p](0), radial_approx_order, i);
353       }
354 
355 
356   // evaluate the mapping functions in radial direction at radial quadrature points
357   for (unsigned int i=0; i<n_radial_mapping_shape_functions; i++)
358     for (unsigned int p=0; p<n_radial_qp; p++)
359       {
360         radial_map[i][p]    = InfFE<Dim,INFINITE_MAP,T_map>::eval       (radial_qp[p](0), radial_mapping_order, i);
361         dradialdv_map[i][p] = InfFE<Dim,INFINITE_MAP,T_map>::eval_deriv (radial_qp[p](0), radial_mapping_order, i);
362       }
363 
367   STOP_LOG("init_radial_shape_functions()", "InfFE");
368 
369 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::init_shape_functions (const \fBElem\fP *inf_elem)\fC [protected]\fP"
Initialize all the data fields like \fCweight\fP, \fCmode\fP, \fCphi\fP, \fCdphidxi\fP, \fCdphideta\fP, \fCdphidzeta\fP, etc\&. for the current element\&. This method prepares the data related to the base part, and some of the combined fields\&. Stop logging the radial shape function initialization
.PP
Definition at line 376 of file inf_fe\&.C\&.
.PP
References libMesh::err, libMesh::libmesh_assert(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::type(), and libMesh::MeshTools::weight()\&.
.PP
.nf
377 {
378   libmesh_assert(inf_elem);
379 
380 
381   // Start logging the radial shape function initialization
382   START_LOG("init_shape_functions()", "InfFE");
383 
384 
385   // -----------------------------------------------------------------
386   // fast access to some const int's for the radial data
387   const unsigned int n_radial_mapping_sf =
388     libmesh_cast_int<unsigned int>(radial_map\&.size());
389   const unsigned int n_radial_approx_sf  =
390     libmesh_cast_int<unsigned int>(mode\&.size());
391   const unsigned int n_radial_qp         =
392     libmesh_cast_int<unsigned int>(som\&.size());
393 
394 
395   // -----------------------------------------------------------------
396   // initialize most of the things related to mapping
397 
398   // The element type and order to use in the base map
399   const Order    base_mapping_order     ( base_elem->default_order() );
400   const ElemType base_mapping_elem_type ( base_elem->type()          );
401 
402   // the number of base shape functions used to construct the map
403   // (Lagrange shape functions are used for mapping in the base)
404   unsigned int n_base_mapping_shape_functions = Base::n_base_mapping_sf(base_mapping_elem_type,
405                                                                         base_mapping_order);
406 
407   const unsigned int n_total_mapping_shape_functions =
408     n_radial_mapping_sf * n_base_mapping_shape_functions;
409 
410 
411 
412   // -----------------------------------------------------------------
413   // initialize most of the things related to physical approximation
414 
415   unsigned int n_base_approx_shape_functions;
416   if (Dim > 1)
417     n_base_approx_shape_functions = base_fe->n_shape_functions();
418   else
419     n_base_approx_shape_functions = 1;
420 
421 
422   const unsigned int n_total_approx_shape_functions =
423     n_radial_approx_sf * n_base_approx_shape_functions;
424 
425   // update class member field
426   _n_total_approx_sf = n_total_approx_shape_functions;
427 
428 
429   // The number of the base quadrature points\&.
430   const unsigned int        n_base_qp =  base_qrule->n_points();
431 
432   // The total number of quadrature points\&.
433   const unsigned int        n_total_qp =  n_radial_qp * n_base_qp;
434 
435 
436   // update class member field
437   _n_total_qp = n_total_qp;
438 
439 
440 
441   // -----------------------------------------------------------------
442   // initialize the node and shape numbering maps
443   {
444     // these vectors work as follows: the i-th entry stores
445     // the associated base/radial node number
446     _radial_node_index\&.resize    (n_total_mapping_shape_functions);
447     _base_node_index\&.resize      (n_total_mapping_shape_functions);
448 
449     // similar for the shapes: the i-th entry stores
450     // the associated base/radial shape number
451     _radial_shape_index\&.resize   (n_total_approx_shape_functions);
452     _base_shape_index\&.resize     (n_total_approx_shape_functions);
453 
454     const ElemType inf_elem_type (inf_elem->type());
455 
456     // fill the node index map
457     for (unsigned int n=0; n<n_total_mapping_shape_functions; n++)
458       {
459         compute_node_indices (inf_elem_type,
460                               n,
461                               _base_node_index[n],
462                               _radial_node_index[n]);
463         libmesh_assert_less (_base_node_index[n], n_base_mapping_shape_functions);
464         libmesh_assert_less (_radial_node_index[n], n_radial_mapping_sf);
465       }
466 
467     // fill the shape index map
468     for (unsigned int n=0; n<n_total_approx_shape_functions; n++)
469       {
470         compute_shape_indices (this->fe_type,
471                                inf_elem_type,
472                                n,
473                                _base_shape_index[n],
474                                _radial_shape_index[n]);
475         libmesh_assert_less (_base_shape_index[n], n_base_approx_shape_functions);
476         libmesh_assert_less (_radial_shape_index[n], n_radial_approx_sf);
477       }
478   }
479 
480 
481 
482 
483 
484   // -----------------------------------------------------------------
485   // resize the base data fields
486   dist\&.resize(n_base_mapping_shape_functions);
487 
488 
489 
490   // -----------------------------------------------------------------
491   // resize the total data fields
492 
493   // the phase term varies with xi, eta and zeta(v): store it for _all_ qp
494   //
495   // when computing the phase, we need the base approximations
496   // therefore, initialize the phase here, but evaluate it
497   // in combine_base_radial()\&.
498   //
499   // the weight, though, is only needed at the radial quadrature points, n_radial_qp\&.
500   // but for a uniform interface to the protected data fields
501   // the weight data field (which are accessible from the outside) are expanded to n_total_qp\&.
502   weight\&.resize      (n_total_qp);
503   dweightdv\&.resize   (n_total_qp);
504   dweight\&.resize     (n_total_qp);
505 
506   dphase\&.resize      (n_total_qp);
507   dphasedxi\&.resize   (n_total_qp);
508   dphasedeta\&.resize  (n_total_qp);
509   dphasedzeta\&.resize (n_total_qp);
510 
511   // this vector contains the integration weights for the combined quadrature rule
512   _total_qrule_weights\&.resize(n_total_qp);
513 
514 
515   // -----------------------------------------------------------------
516   // InfFE's data fields phi, dphi, dphidx, phi_map etc hold the _total_
517   // shape and mapping functions, respectively
518   {
519     phi\&.resize     (n_total_approx_shape_functions);
520     dphi\&.resize    (n_total_approx_shape_functions);
521     dphidx\&.resize  (n_total_approx_shape_functions);
522     dphidy\&.resize  (n_total_approx_shape_functions);
523     dphidz\&.resize  (n_total_approx_shape_functions);
524     dphidxi\&.resize (n_total_approx_shape_functions);
525 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
526     libmesh_do_once(libMesh::err << "Second derivatives for Infinite elements"
527                     << " are not yet implemented!"
528                     << std::endl);
529 
530     d2phi\&.resize     (n_total_approx_shape_functions);
531     d2phidx2\&.resize  (n_total_approx_shape_functions);
532     d2phidxdy\&.resize (n_total_approx_shape_functions);
533     d2phidxdz\&.resize (n_total_approx_shape_functions);
534     d2phidy2\&.resize  (n_total_approx_shape_functions);
535     d2phidydz\&.resize (n_total_approx_shape_functions);
536     d2phidz2\&.resize  (n_total_approx_shape_functions);
537     d2phidxi2\&.resize (n_total_approx_shape_functions);
538 
539     if (Dim > 1)
540       {
541         d2phidxideta\&.resize   (n_total_approx_shape_functions);
542         d2phideta2\&.resize     (n_total_approx_shape_functions);
543       }
544 
545     if (Dim > 2)
546       {
547         d2phidetadzeta\&.resize (n_total_approx_shape_functions);
548         d2phidxidzeta\&.resize  (n_total_approx_shape_functions);
549         d2phidzeta2\&.resize    (n_total_approx_shape_functions);
550       }
551 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
552 
553     if (Dim > 1)
554       dphideta\&.resize      (n_total_approx_shape_functions);
555 
556     if (Dim == 3)
557       dphidzeta\&.resize     (n_total_approx_shape_functions);
558 
559 
560 
561     std::vector<std::vector<Real> >& phi_map = this->_fe_map->get_phi_map();
562     std::vector<std::vector<Real> >& dphidxi_map = this->_fe_map->get_dphidxi_map();
563 
564     phi_map\&.resize         (n_total_mapping_shape_functions);
565     dphidxi_map\&.resize     (n_total_mapping_shape_functions);
566 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
567     std::vector<std::vector<Real> >& d2phidxi2_map = this->_fe_map->get_d2phidxi2_map();
568     d2phidxi2_map\&.resize   (n_total_mapping_shape_functions);
569 
570     if (Dim > 1)
571       {
572         std::vector<std::vector<Real> >& d2phidxideta_map = this->_fe_map->get_d2phidxideta_map();
573         std::vector<std::vector<Real> >& d2phideta2_map = this->_fe_map->get_d2phideta2_map();
574         d2phidxideta_map\&.resize   (n_total_mapping_shape_functions);
575         d2phideta2_map\&.resize     (n_total_mapping_shape_functions);
576       }
577 
578     if (Dim == 3)
579       {
580         std::vector<std::vector<Real> >& d2phidxidzeta_map = this->_fe_map->get_d2phidxidzeta_map();
581         std::vector<std::vector<Real> >& d2phidetadzeta_map = this->_fe_map->get_d2phidetadzeta_map();
582         std::vector<std::vector<Real> >& d2phidzeta2_map = this->_fe_map->get_d2phidzeta2_map();
583         d2phidxidzeta_map\&.resize  (n_total_mapping_shape_functions);
584         d2phidetadzeta_map\&.resize (n_total_mapping_shape_functions);
585         d2phidzeta2_map\&.resize    (n_total_mapping_shape_functions);
586       }
587 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
588 
589     if (Dim > 1)
590       {
591         std::vector<std::vector<Real> >& dphideta_map = this->_fe_map->get_dphideta_map();
592         dphideta_map\&.resize  (n_total_mapping_shape_functions);
593       }
594 
595     if (Dim == 3)
596       {
597         std::vector<std::vector<Real> >& dphidzeta_map = this->_fe_map->get_dphidzeta_map();
598         dphidzeta_map\&.resize (n_total_mapping_shape_functions);
599       }
600   }
601 
602 
603 
604   // -----------------------------------------------------------------
605   // collect all the for loops, where inner vectors are
606   // resized to the appropriate number of quadrature points
607   {
608     for (unsigned int i=0; i<n_total_approx_shape_functions; i++)
609       {
610         phi[i]\&.resize         (n_total_qp);
611         dphi[i]\&.resize        (n_total_qp);
612         dphidx[i]\&.resize      (n_total_qp);
613         dphidy[i]\&.resize      (n_total_qp);
614         dphidz[i]\&.resize      (n_total_qp);
615         dphidxi[i]\&.resize     (n_total_qp);
616 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
617         d2phi[i]\&.resize       (n_total_qp);
618         d2phidx2[i]\&.resize    (n_total_qp);
619         d2phidxdy[i]\&.resize   (n_total_qp);
620         d2phidxdz[i]\&.resize   (n_total_qp);
621         d2phidy2[i]\&.resize    (n_total_qp);
622         d2phidydz[i]\&.resize   (n_total_qp);
623         d2phidy2[i]\&.resize    (n_total_qp);
624         d2phidxi2[i]\&.resize   (n_total_qp);
625 
626         if (Dim > 1)
627           {
628             d2phidxideta[i]\&.resize   (n_total_qp);
629             d2phideta2[i]\&.resize     (n_total_qp);
630           }
631         if (Dim > 2)
632           {
633             d2phidxidzeta[i]\&.resize  (n_total_qp);
634             d2phidetadzeta[i]\&.resize (n_total_qp);
635             d2phidzeta2[i]\&.resize    (n_total_qp);
636           }
637 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
638 
639         if (Dim > 1)
640           dphideta[i]\&.resize  (n_total_qp);
641 
642         if (Dim == 3)
643           dphidzeta[i]\&.resize (n_total_qp);
644 
645       }
646 
647     for (unsigned int i=0; i<n_total_mapping_shape_functions; i++)
648       {
649         std::vector<std::vector<Real> >& phi_map = this->_fe_map->get_phi_map();
650         std::vector<std::vector<Real> >& dphidxi_map = this->_fe_map->get_dphidxi_map();
651         phi_map[i]\&.resize         (n_total_qp);
652         dphidxi_map[i]\&.resize     (n_total_qp);
653 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
654         std::vector<std::vector<Real> >& d2phidxi2_map = this->_fe_map->get_d2phidxi2_map();
655         d2phidxi2_map[i]\&.resize   (n_total_qp);
656         if (Dim > 1)
657           {
658             std::vector<std::vector<Real> >& d2phidxideta_map = this->_fe_map->get_d2phidxideta_map();
659             std::vector<std::vector<Real> >& d2phideta2_map = this->_fe_map->get_d2phideta2_map();
660             d2phidxideta_map[i]\&.resize   (n_total_qp);
661             d2phideta2_map[i]\&.resize     (n_total_qp);
662           }
663 
664         if (Dim > 2)
665           {
666             std::vector<std::vector<Real> >& d2phidxidzeta_map = this->_fe_map->get_d2phidxidzeta_map();
667             std::vector<std::vector<Real> >& d2phidetadzeta_map = this->_fe_map->get_d2phidetadzeta_map();
668             std::vector<std::vector<Real> >& d2phidzeta2_map = this->_fe_map->get_d2phidzeta2_map();
669             d2phidxidzeta_map[i]\&.resize  (n_total_qp);
670             d2phidetadzeta_map[i]\&.resize (n_total_qp);
671             d2phidzeta2_map[i]\&.resize    (n_total_qp);
672           }
673 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
674 
675         if (Dim > 1)
676           {
677             std::vector<std::vector<Real> >& dphideta_map = this->_fe_map->get_dphideta_map();
678             dphideta_map[i]\&.resize  (n_total_qp);
679           }
680 
681         if (Dim == 3)
682           {
683             std::vector<std::vector<Real> >& dphidzeta_map = this->_fe_map->get_dphidzeta_map();
684             dphidzeta_map[i]\&.resize (n_total_qp);
685           }
686       }
687   }
688 
689 
690 
691   {
692     // -----------------------------------------------------------------
693     // (a) compute scalar values at _all_ quadrature points  -- for uniform
694     //     access from the outside to these fields
695     // (b) form a std::vector<Real> which contains the appropriate weights
696     //     of the combined quadrature rule!
697     const std::vector<Point>&  radial_qp = radial_qrule->get_points();
698     libmesh_assert_equal_to (radial_qp\&.size(), n_radial_qp);
699 
700     const std::vector<Real>&   radial_qw = radial_qrule->get_weights();
701     const std::vector<Real>&   base_qw   = base_qrule->get_weights();
702     libmesh_assert_equal_to (radial_qw\&.size(), n_radial_qp);
703     libmesh_assert_equal_to (base_qw\&.size(), n_base_qp);
704 
705     for (unsigned int rp=0; rp<n_radial_qp; rp++)
706       for (unsigned int bp=0; bp<n_base_qp; bp++)
707         {
708           weight   [ bp+rp*n_base_qp ] = Radial::D       (radial_qp[rp](0));
709           dweightdv[ bp+rp*n_base_qp ] = Radial::D_deriv (radial_qp[rp](0));
710 
711           _total_qrule_weights[  bp+rp*n_base_qp ] = radial_qw[rp] * base_qw[bp];
712         }
713   }
714 
715 
719   STOP_LOG("init_shape_functions()", "InfFE");
720 
721 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBPoint\fP \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::inverse_map (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const boolsecure = \fCtrue\fP, const boolinterpolated = \fCtrue\fP)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (on the reference element) of the point \fCp\fP located in physical space\&. First, the location in the base face is computed\&. This requires inverting the (possibly nonlinear) transformation map in the base, so it is not trivial\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $\&. Once the base face point is determined, the radial local coordinate is directly evaluated\&. If \fCinterpolated\fP is true, the interpolated distance from the base element to the infinite element origin is used for the map in radial direction\&. 
.RE
.PP
The number of iterations in the map inversion process\&.
.PP
Newton iteration loop\&.
.PP
Definition at line 89 of file inf_fe_map\&.C\&.
.PP
References std::abs(), libMesh::TypeVector< T >::add(), libMesh::TypeVector< T >::add_scaled(), libMesh::err, libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval_deriv(), libMesh::AutoPtr< Tp >::get(), libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::FE< Dim, T >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::Elem::origin(), libMesh::Elem::point(), libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::TypeVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEInterface::ifem_inverse_map()\&.
.PP
.nf
94 {
95   libmesh_assert(inf_elem);
96   libmesh_assert_greater_equal (tolerance, 0\&.);
97 
98 
99   // Start logging the map inversion\&.
100   START_LOG("inverse_map()", "InfFE");
101 
102 
103   // 1\&.)
104   // build a base element to do the map inversion in the base face
105   AutoPtr<Elem> base_elem (Base::build_elem (inf_elem));
106 
107   const Order    base_mapping_order     (base_elem->default_order());
108   const ElemType base_mapping_elem_type (base_elem->type());
109   const unsigned int n_base_mapping_sf = Base::n_base_mapping_sf (base_mapping_elem_type,
110                                                                   base_mapping_order);
111 
112   const ElemType inf_elem_type = inf_elem->type();
113   if (inf_elem_type != INFHEX8 &&
114       inf_elem_type != INFPRISM6)
115     {
116       libMesh::err << "ERROR: InfFE::inverse_map is currently implemented only for\n"
117                    << " infinite elments of type InfHex8 and InfPrism6\&." << std::endl;
118       libmesh_error();
119     }
120 
121 
122   // 2\&.)
123   // just like in FE<Dim-1,LAGRANGE>::inverse_map(): compute
124   // the local coordinates, but only in the base element\&.
125   // The radial part can then be computed directly later on\&.
126 
127 
128   // How much did the point on the reference
129   // element change by in this Newton step?
130   Real inverse_map_error = 0\&.;
131 
132 
133   // The point on the reference element\&.  This is
134   // the "initial guess" for Newton's method\&.  The
135   // centroid seems like a good idea, but computing
136   // it is a little more intensive than, say taking
137   // the zero point\&.
138   //
139   // Convergence should be insensitive of this choice
140   // for "good" elements\&.
141   Point p; // the zero point\&.  No computation required
142 
143 
144 
145   // Now find the intersection of a plane represented by the base
146   // element nodes and the line given by the origin of the infinite
147   // element and the physical point\&.
148   Point intersection;
149 
150   // the origin of the infinite lement
151   const Point o = inf_elem->origin();
152 
153   switch (Dim)
154     {
155 
156       // unnecessary for 1D
157     case 1:
158       {
159         break;
160       }
161 
162     case 2:
163       {
164         libMesh::err << "ERROR: InfFE::inverse_map is not yet implemented"
165                      << " in 2d" << std::endl;
166         libmesh_error();
167         break;
168       }
169 
170 
171     case 3:
172       {
173         // references to the nodal points of the base element
174         const Point& p0 = base_elem->point(0);
175         const Point& p1 = base_elem->point(1);
176         const Point& p2 = base_elem->point(2);
177 
178         // a reference to the physical point
179         const Point& fp = physical_point;
180 
181         // The intersection of the plane and the line is given by
182         // can be computed solving a linear 3x3 system
183         // a*({p1}-{p0})+b*({p2}-{p0})-c*({fp}-{o})={fp}-{p0}\&.
184         const Real c_factor = -(p1(0)*fp(1)*p0(2)-p1(0)*fp(2)*p0(1)
185                                 +fp(0)*p1(2)*p0(1)-p0(0)*fp(1)*p1(2)
186                                 +p0(0)*fp(2)*p1(1)+p2(0)*fp(2)*p0(1)
187                                 -p2(0)*fp(1)*p0(2)-fp(0)*p2(2)*p0(1)
188                                 +fp(0)*p0(2)*p2(1)+p0(0)*fp(1)*p2(2)
189                                 -p0(0)*fp(2)*p2(1)-fp(0)*p0(2)*p1(1)
190                                 +p0(2)*p2(0)*p1(1)-p0(1)*p2(0)*p1(2)
191                                 -fp(0)*p1(2)*p2(1)+p2(1)*p0(0)*p1(2)
192                                 -p2(0)*fp(2)*p1(1)-p1(0)*fp(1)*p2(2)
193                                 +p2(2)*p1(0)*p0(1)+p1(0)*fp(2)*p2(1)
194                                 -p0(2)*p1(0)*p2(1)-p2(2)*p0(0)*p1(1)
195                                 +fp(0)*p2(2)*p1(1)+p2(0)*fp(1)*p1(2))/
196           (fp(0)*p1(2)*p0(1)-p1(0)*fp(2)*p0(1)
197            +p1(0)*fp(1)*p0(2)-p1(0)*o(1)*p0(2)
198            +o(0)*p2(2)*p0(1)-p0(0)*fp(2)*p2(1)
199            +p1(0)*o(1)*p2(2)+fp(0)*p0(2)*p2(1)
200            -fp(0)*p1(2)*p2(1)-p0(0)*o(1)*p2(2)
201            +p0(0)*fp(1)*p2(2)-o(0)*p0(2)*p2(1)
202            +o(0)*p1(2)*p2(1)-p2(0)*fp(2)*p1(1)
203            +fp(0)*p2(2)*p1(1)-p2(0)*fp(1)*p0(2)
204            -o(2)*p0(0)*p1(1)-fp(0)*p0(2)*p1(1)
205            +p0(0)*o(1)*p1(2)+p0(0)*fp(2)*p1(1)
206            -p0(0)*fp(1)*p1(2)-o(0)*p1(2)*p0(1)
207            -p2(0)*o(1)*p1(2)-o(2)*p2(0)*p0(1)
208            -o(2)*p1(0)*p2(1)+o(2)*p0(0)*p2(1)
209            -fp(0)*p2(2)*p0(1)+o(2)*p2(0)*p1(1)
210            +p2(0)*o(1)*p0(2)+p2(0)*fp(1)*p1(2)
211            +p2(0)*fp(2)*p0(1)-p1(0)*fp(1)*p2(2)
212            +p1(0)*fp(2)*p2(1)-o(0)*p2(2)*p1(1)
213            +o(2)*p1(0)*p0(1)+o(0)*p0(2)*p1(1));
214 
215 
216         // Compute the intersection with
217         // {intersection} = {fp} + c*({fp}-{o})\&.
218         intersection\&.add_scaled(fp,1\&.+c_factor);
219         intersection\&.add_scaled(o,-c_factor);
220 
221         break;
222       }
223     }
224 
228   unsigned int cnt = 0;
229 
230 
234   do
235     {
236 
237       // Increment in current iterate \p p, will be computed\&.
238       // Automatically initialized to all zero\&.  Note that
239       // in 3D, actually only the first two entries are
240       // filled by the inverse map, and in 2D only the first\&.
241       Point dp;
242 
243       // The form of the map and how we invert it depends
244       // on the dimension that we are in\&.
245       switch (Dim)
246         {
247 
248           //------------------------------------------------------------------
249           // 1D infinite element - no map inversion necessary
250         case 1:
251           {
252             break;
253           }
254 
255 
256           //------------------------------------------------------------------
257           // 2D infinite element - 1D map inversion
258           //
259           // In this iteration scheme only search for the local coordinate
260           // in xi direction\&.  Once xi is determined, the radial coordinate eta is
261           // uniquely determined, and there is no need to iterate in that direction\&.
262         case 2:
263           {
264 
265             // Where our current iterate \p p maps to\&.
266             const Point physical_guess = FE<1,LAGRANGE>::map (base_elem\&.get(), p);
267 
268 
269             // How far our current iterate is from the actual point\&.
270             const Point delta = physical_point - physical_guess;
271 
272 
273             const Point dxi = FE<1,LAGRANGE>::map_xi (base_elem\&.get(), p);
274 
275 
276             // For details on Newton's method see fe_map\&.C
277             const Real G = dxi*dxi;
278 
279             if (secure)
280               libmesh_assert_greater (G, 0\&.);
281 
282             const Real Ginv = 1\&./G;
283 
284             const Real  dxidelta = dxi*delta;
285 
286             // compute only the first coordinate
287             dp(0) = Ginv*dxidelta;
288 
289             break;
290           }
291 
292 
293 
294           //------------------------------------------------------------------
295           // 3D infinite element - 2D map inversion
296           //
297           // In this iteration scheme only search for the local coordinates
298           // in xi and eta direction\&.  Once xi, eta are determined, the radial
299           // coordinate zeta may directly computed\&.
300         case 3:
301           {
302 
303 
304             // Where our current iterate \p p maps to\&.
305             const Point physical_guess = FE<2,LAGRANGE>::map (base_elem\&.get(), p);
306 
307             // How far our current iterate is from the actual point\&.
308             // const Point delta = physical_point - physical_guess;
309             const Point delta = intersection - physical_guess;
310 
311             const Point dxi  = FE<2,LAGRANGE>::map_xi  (base_elem\&.get(), p);
312             const Point deta = FE<2,LAGRANGE>::map_eta (base_elem\&.get(), p);
313 
314 
315             // For details on Newton's method see fe_map\&.C
316             const Real
317               G11 = dxi*dxi,  G12 = dxi*deta,
318               G21 = dxi*deta, G22 = deta*deta;
319 
320 
321             const Real det = (G11*G22 - G12*G21);
322 
323             if (secure)
324               {
325                 libmesh_assert_greater (det, 0\&.);
326                 libmesh_assert_greater (std::abs(det), 1\&.e-10);
327               }
328 
329             const Real inv_det = 1\&./det;
330 
331             const Real
332               Ginv11 =  G22*inv_det,
333               Ginv12 = -G12*inv_det,
334 
335               Ginv21 = -G21*inv_det,
336               Ginv22 =  G11*inv_det;
337 
338 
339             const Real  dxidelta  = dxi*delta;
340             const Real  detadelta = deta*delta;
341 
342             // compute only the first two coordinates\&.
343             dp(0) = (Ginv11*dxidelta + Ginv12*detadelta);
344             dp(1) = (Ginv21*dxidelta + Ginv22*detadelta);
345 
346             break;
347           }
348 
349 
350 
351           // Some other dimension?
352         default:
353           libmesh_error();
354         } // end switch(Dim), dp now computed
355 
356 
357 
358       // determine the error in computing the local coordinates
359       // in the base: ||P_n+1 - P_n||
360       inverse_map_error = dp\&.size();
361 
362 
363       // P_n+1 = P_n + dp
364       p\&.add (dp);
365 
366 
367       // Increment the iteration count\&.
368       cnt++;
369 
370 
371       // Watch for divergence of Newton's
372       // method\&.
373       if (cnt > 10)
374         {
375           if (secure || !secure)
376             {
377               libmesh_here();
378               {
379                 libMesh::err << "WARNING: Newton scheme has not converged in "
380                              << cnt << " iterations:\n"
381                              << "   physical_point="
382                              << physical_point
383                              << "   dp="
384                              << dp
385                              << "   p="
386                              << p
387                              << "   error=" << inverse_map_error
388                              << std::endl;
389               }
390             }
391 
392           if (cnt > 20)
393             {
394               libMesh::err << "ERROR: Newton scheme FAILED to converge in "
395                            << cnt << " iterations!" << std::endl;
396               libmesh_error();
397             }
398 
399           // else
400           //  {
401           //    break;
402           //  }
403         }
404     }
405   while (inverse_map_error > tolerance);
406 
407 
408 
409   // 4\&.
410   //
411   // Now that we have the local coordinates in the base,
412   // compute the interpolated radial distance a(s,t) \p a_interpolated
413   if (interpolated)
414     switch (Dim)
415       {
416       case 1:
417         {
418           Real a_interpolated = Point( inf_elem->point(0)
419                                        - inf_elem->point(n_base_mapping_sf) )\&.size();
420 
421           p(0) = 1\&. - 2*a_interpolated/physical_point(0);
422 
423 #ifdef DEBUG
424           // the radial distance should always be >= -1\&.
425 
426           if (p(0)+1 < tolerance)
427             {
428               libmesh_here();
429               libMesh::err << "WARNING: radial distance p(0) is "
430                            << p(0)
431                            << std::endl;
432             }
433 #endif
434 
435           break;
436         }
437 
438 
439       case 2:
440         {
441           Real a_interpolated = 0\&.;
442 
443           // the distance between the origin and the physical point
444           const Real fp_o_dist = Point(o-physical_point)\&.size();
445 
446           for (unsigned int i=0; i<n_base_mapping_sf; i++)
447             {
448               // the radial distance of the i-th base mapping point
449               const Real dist_i = Point( inf_elem->point(i)
450                                          - inf_elem->point(i+n_base_mapping_sf) )\&.size();
451               // weight with the corresponding shape function
452               a_interpolated += dist_i * FE<1,LAGRANGE>::shape(base_mapping_elem_type,
453                                                                base_mapping_order,
454                                                                i,
455                                                                p);
456             }
457 
458           p(1) = 1\&. - 2*a_interpolated/fp_o_dist;
459 
460 #ifdef DEBUG
461           // the radial distance should always be >= -1\&.
462 
463           // if (p(1)+1 < tolerance)
464           //  {
465           //    libmesh_here();
466           //    libMesh::err << "WARNING: radial distance p(1) is "
467           //      << p(1)
468           //      << std::endl;
469           //  }
470 #endif
471 
472           break;
473         }
474 
475 
476       case 3:
477         {
478           Real a_interpolated = 0\&.;
479 
480 
481           // the distance between the origin and the physical point
482           const Real fp_o_dist = Point(o-physical_point)\&.size();
483 
484           for (unsigned int i=0; i<n_base_mapping_sf; i++)
485             {
486               // the radial distance of the i-th base mapping point
487               const Real dist_i = Point( inf_elem->point(i)
488                                          - inf_elem->point(i+n_base_mapping_sf) )\&.size();
489 
490               // weight with the corresponding shape function
491               a_interpolated += dist_i * FE<2,LAGRANGE>::shape(base_mapping_elem_type,
492                                                                base_mapping_order,
493                                                                i,
494                                                                p);
495 
496             }
497 
498           p(2) = 1\&. - 2*a_interpolated/fp_o_dist;
499 
500 #ifdef DEBUG
501 
502 
503           // the radial distance should always be >= -1\&.
504 
505           // if (p(2)+1 < tolerance)
506           //  {
507           // libmesh_here();
508           // libMesh::err << "WARNING: radial distance p(2) is "
509           //      << p(2)
510           //      << std::endl;
511           //  }
512 #endif
513 
514           break;
515         }
516 
517       default:
518         libmesh_error();
519       } // end switch(Dim), p fully computed, including radial part
520 
521   // if we do not want the interpolated distance, then
522   // use newton iteration to get the actual distance
523   else
524     {
525       // distance from the physical point to the ifem origin
526       const Real fp_o_dist = Point(o-physical_point)\&.size();
527 
528       // the distance from the intersection on the
529       // base to the origin
530       const Real a_dist = intersection\&.size();
531 
532       // element coordinate in radial direction
533       // here our first guess is 0\&.
534       Real v = 0\&.;
535 
536       // the order of the radial mapping
537       const Order radial_mapping_order (Radial::mapping_order());
538 
539       unsigned int cnt2 = 0;
540       inverse_map_error = 0\&.;
541 
542       // Newton iteration in 1-D
543       do
544         {
545           // the mapping in radial direction
546           // note that we only have two mapping functions in
547           // radial direction
548           const Real r = a_dist * InfFE<Dim,INFINITE_MAP,T_map>::eval (v, radial_mapping_order, 0)
549             + 2\&. * a_dist * InfFE<Dim,INFINITE_MAP,T_map>::eval (v, radial_mapping_order, 1);
550 
551           const Real dr = a_dist * InfFE<Dim,INFINITE_MAP,T_map>::eval_deriv (v, radial_mapping_order, 0)
552             + 2\&. * a_dist * InfFE<Dim,INFINITE_MAP,T_map>::eval_deriv (v, radial_mapping_order, 1);
553 
554           const Real G = dr*dr;
555           const Real Ginv = 1\&./G;
556 
557           const Real delta = fp_o_dist - r;
558           const Real drdelta = dr*delta;
559 
560           Real dp = Ginv*drdelta;
561 
562           // update the radial coordinate
563           v += dp;
564 
565           // note that v should be smaller than 1,
566           // since radial mapping function tends to infinity
567           if (v >= 1\&.)
568             v = \&.9999;
569 
570           inverse_map_error = std::fabs(dp);
571 
572           // increment iteration count
573           cnt2 ++;
574           if (cnt2 > 20)
575             {
576 
577               libMesh::err << "ERROR: 1D Newton scheme FAILED to converge"
578                            << std::endl;
579 
580               libmesh_error();
581             }
582 
583 
584         }
585       while (inverse_map_error > tolerance);
586 
587       switch (Dim)
588         {
589         case 1:
590           {
591             p(0) = v;
592             break;
593           }
594         case 2:
595           {
596             p(1) = v;
597             break;
598           }
599         case 3:
600           {
601             p(2) = v;
602             break;
603           }
604         default:
605           libmesh_error();
606         }
607     }
608 
609   // If we are in debug mode do a sanity check\&.  Make sure
610   // the point \p p on the reference element actually does
611   // map to the point \p physical_point within a tolerance\&.
612 #ifdef DEBUG
613   /*
614     const Point check = InfFE<Dim,T_radial,T_map>::map (inf_elem, p);
615     const Point diff  = physical_point - check;
616 
617     if (diff\&.size() > tolerance)
618     {
619     libmesh_here();
620     libMesh::err << "WARNING:  diff is "
621     << diff\&.size()
622     << std::endl;
623     }
624   */
625 #endif
626 
627 
628 
629 
630   // Stop logging the map inversion\&.
631   STOP_LOG("inverse_map()", "InfFE");
632 
633   return p;
634 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::inverse_map (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP"
Takes a number points in physical space (in the \fCphysical_points\fP vector) and finds their location on the reference element for the input element \fCelem\fP\&. The values on the reference element are returned in the vector \fCreference_points\fP 
.PP
Definition at line 637 of file inf_fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::size()\&.
.PP
.nf
642 {
643   // The number of points to find the
644   // inverse map of
645   const std::size_t n_points = physical_points\&.size();
646 
647   // Resize the vector to hold the points
648   // on the reference element
649   reference_points\&.resize(n_points);
650 
651   // Find the coordinates on the reference
652   // element of each point in physical space
653   for (unsigned int p=0; p<n_points; p++)
654     reference_points[p] =
655       InfFE<Dim,T_radial,T_map>::inverse_map (elem, physical_points[p], tolerance, secure, false);
656 }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual bool \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::is_hierarchic () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 347 of file inf_fe\&.h\&.
.PP
.nf
348   { return false; }  // FIXME - Inf FEs don't handle p elevation yet
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBPoint\fP \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::map (const \fBElem\fP *inf_elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [protected]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.PP
Definition at line 40 of file inf_fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::AutoPtr< Tp >::get(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::map(), libMesh::Elem::origin(), libMesh::Elem::point(), and libMesh::Real\&.
.PP
.nf
42 {
43   libmesh_assert(inf_elem);
44   libmesh_assert_not_equal_to (Dim, 0);
45 
46   AutoPtr<Elem>      base_elem (Base::build_elem (inf_elem));
47 
48   const Order        radial_mapping_order (Radial::mapping_order());
49   const Real         v                    (reference_point(Dim-1));
50 
51   // map in the base face
52   Point base_point;
53   switch (Dim)
54     {
55     case 1:
56       base_point = inf_elem->point(0);
57       break;
58     case 2:
59       base_point = FE<1,LAGRANGE>::map (base_elem\&.get(), reference_point);
60       break;
61     case 3:
62       base_point = FE<2,LAGRANGE>::map (base_elem\&.get(), reference_point);
63       break;
64 #ifdef DEBUG
65     default:
66       libmesh_error();
67 #endif
68     }
69 
70 
71   // map in the outer node face not necessary\&. Simply
72   // compute the outer_point = base_point + (base_point-origin)
73   const Point outer_point (base_point * 2\&. - inf_elem->origin());
74 
75   Point p;
76 
77   // there are only two mapping shapes in radial direction
78   p\&.add_scaled (base_point,  InfFE<Dim,INFINITE_MAP,T_map>::eval (v, radial_mapping_order, 0));
79   p\&.add_scaled (outer_point, InfFE<Dim,INFINITE_MAP,T_map>::eval (v, radial_mapping_order, 1));
80 
81   return p;
82 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> unsigned int \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::n_dofs (const \fBFEType\fP &fet, const \fBElemType\fPinf_elem_type)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this infinite element\&. Currently, we have \fCo_radial+1\fP modes in radial direction, and \fC\fBFE\fP<Dim-1\fP,T>::n_dofs(\&.\&.\&.) in the base\&. 
.RE
.PP

.PP
Definition at line 55 of file inf_fe_static\&.C\&.
.PP
References libMesh::FEInterface::n_dofs(), and libMesh::FEType::radial_order\&.
.PP
Referenced by libMesh::FEInterface::ifem_n_dofs(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_shape_functions()\&.
.PP
.nf
57 {
58   const ElemType base_et (Base::get_elem_type(inf_elem_type));
59 
60   if (Dim > 1)
61     return FEInterface::n_dofs(Dim-1, fet, base_et) * Radial::n_dofs(fet\&.radial_order);
62   else
63     return Radial::n_dofs(fet\&.radial_order);
64 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> unsigned int \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::n_dofs_at_node (const \fBFEType\fP &fet, const \fBElemType\fPinf_elem_type, const unsigned intn)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs at infinite element \fInode\fP \fCn\fP (not dof!) for an element of type \fCt\fP and order \fCo\fP\&. 
.RE
.PP

.PP
Definition at line 72 of file inf_fe_static\&.C\&.
.PP
References libMesh::FEInterface::n_dofs_at_node(), and libMesh::FEType::radial_order\&.
.PP
Referenced by libMesh::FEInterface::ifem_n_dofs_at_node()\&.
.PP
.nf
75 {
76   const ElemType base_et (Base::get_elem_type(inf_elem_type));
77 
78   unsigned int n_base, n_radial;
79   compute_node_indices(inf_elem_type, n, n_base, n_radial);
80 
81   //   libMesh::out << "elem_type=" << inf_elem_type
82   //     << ",  fet\&.radial_order=" << fet\&.radial_order
83   //     << ",  n=" << n
84   //     << ",  n_radial=" << n_radial
85   //     << ",  n_base=" << n_base
86   //     << std::endl;
87 
88   if (Dim > 1)
89     return FEInterface::n_dofs_at_node(Dim-1, fet, base_et, n_base)
90       * Radial::n_dofs_at_node(fet\&.radial_order, n_radial);
91   else
92     return Radial::n_dofs_at_node(fet\&.radial_order, n_radial);
93 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> unsigned int \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::n_dofs_per_elem (const \fBFEType\fP &fet, const \fBElemType\fPinf_elem_type)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs interior to the element, not associated with any interior nodes\&. 
.RE
.PP

.PP
Definition at line 101 of file inf_fe_static\&.C\&.
.PP
References libMesh::FEInterface::n_dofs_per_elem(), and libMesh::FEType::radial_order\&.
.PP
Referenced by libMesh::FEInterface::ifem_n_dofs_per_elem()\&.
.PP
.nf
103 {
104   const ElemType base_et (Base::get_elem_type(inf_elem_type));
105 
106   if (Dim > 1)
107     return FEInterface::n_dofs_per_elem(Dim-1, fet, base_et)
108       * Radial::n_dofs_per_elem(fet\&.radial_order);
109   else
110     return Radial::n_dofs_per_elem(fet\&.radial_order);
111 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual unsigned int \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::n_quadrature_points () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Call this to get an upper bound for the \fCfor\fP loop in your simulation for matrix assembly of the current element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 469 of file inf_fe\&.h\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::_n_total_qp, libMesh::libmesh_assert(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::radial_qrule\&.
.PP
.nf
470   { libmesh_assert(radial_qrule); return _n_total_qp; }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> static unsigned int \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::n_shape_functions (const \fBFEType\fP &fet, const \fBElemType\fPt)\fC [inline]\fP, \fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with a finite element of type \fCt\fP and approximation order \fCo\fP\&. 
.RE
.PP

.PP
Definition at line 310 of file inf_fe\&.h\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_dofs()\&.
.PP
.nf
312   { return n_dofs(fet, t); }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual unsigned int \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::n_shape_functions () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this infinite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 461 of file inf_fe\&.h\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::_n_total_approx_sf\&.
.PP
Referenced by libMesh::FEInterface::ifem_n_shape_functions()\&.
.PP
.nf
462   { return _n_total_approx_sf; }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::nodal_soln (const \fBFEType\fP &fet, const \fBElem\fP *elem, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)\fC [static]\fP"
Usually, this method would build the nodal soln from the element soln\&. But infinite elements require additional simulation-specific data to compute physically correct results\&. Use \fC\fBcompute_data()\fP\fP to compute results\&. For compatibility an empty vector is returned\&. 
.PP
Definition at line 119 of file inf_fe_static\&.C\&.
.PP
References libMesh::err, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::FEInterface::ifem_nodal_soln()\&.
.PP
.nf
123 {
124 #ifdef DEBUG
125   if (!_warned_for_nodal_soln)
126     {
127       libMesh::err << "WARNING: nodal_soln(\&.\&.\&.) does _not_ work for infinite elements\&." << std::endl
128                    << " Will return an empty nodal solution\&.  Use " << std::endl
129                    << " InfFE<Dim,T_radial,T_map>::compute_data(\&.\&.) instead!" << std::endl;
130       _warned_for_nodal_soln = true;
131     }
132 #endif
133 
134   /*
135    * In the base the infinite element couples to
136    * conventional finite elements\&.  To not destroy
137    * the values there, clear \p nodal_soln\&.  This
138    * indicates to the user of \p nodal_soln to
139    * not use this result\&.
140    */
141   nodal_soln\&.clear();
142   libmesh_assert (nodal_soln\&.empty());
143   return;
144 }
.fi
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_d2phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1021 of file fe_base\&.C\&.
.PP
.nf
1022 {
1023   for (unsigned int i=0; i<dphi\&.size(); ++i)
1024     for (unsigned int j=0; j<dphi[i]\&.size(); ++j)
1025       os << " d2phi[" << i << "][" << j << "]=" << d2phi[i][j];
1026 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_dphi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1008 of file fe_base\&.C\&.
.PP
.nf
1009 {
1010   for (unsigned int i=0; i<dphi\&.size(); ++i)
1011     for (unsigned int j=0; j<dphi[i]\&.size(); ++j)
1012       os << " dphi[" << i << "][" << j << "]=" << dphi[i][j];
1013 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const\fC [inherited]\fP"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_dphi(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_phi(), and libMesh::FEAbstract::print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "template<typename OutputType > void \fBlibMesh::FEGenericBase\fP< OutputType >::print_phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 997 of file fe_base\&.C\&.
.PP
.nf
998 {
999   for (unsigned int i=0; i<phi\&.size(); ++i)
1000     for (unsigned int j=0; j<phi[i]\&.size(); ++j)
1001       os << " phi[" << i << "][" << j << "]=" << phi[i][j] << std::endl;
1002 }
.fi
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
This is at the core of this class\&. Use this for each new element in the mesh\&. Reinitializes all the physical element-dependent data based on the current element \fCelem\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 146 of file inf_fe\&.C\&.
.PP
References libMesh::FEGenericBase< T >::build(), libMesh::dim, libMesh::EDGE2, libMesh::libmesh_assert(), libMesh::AutoPtr< Tp >::release(), and libMesh::Elem::type()\&.
.PP
.nf
149 {
150   libmesh_assert(base_fe);
151   libmesh_assert(base_fe->qrule);
152   libmesh_assert_equal_to (base_fe->qrule, base_qrule);
153   libmesh_assert(radial_qrule);
154   libmesh_assert(inf_elem);
155 
156   if (pts == NULL)
157     {
158       bool init_shape_functions_required = false;
159 
160       // -----------------------------------------------------------------
161       // init the radial data fields only when the radial order changes
162       if (current_fe_type\&.radial_order != fe_type\&.radial_order)
163         {
164           current_fe_type\&.radial_order = fe_type\&.radial_order;
165 
166           // Watch out: this call to QBase->init() only works for
167           // current_fe_type = const!   To allow variable Order,
168           // the init() of QBase has to be modified\&.\&.\&.
169           radial_qrule->init(EDGE2);
170 
171           // initialize the radial shape functions
172           this->init_radial_shape_functions(inf_elem);
173 
174           init_shape_functions_required=true;
175         }
176 
177 
178       bool update_base_elem_required=true;
179 
180       // -----------------------------------------------------------------
181       // update the type in accordance to the current cell
182       // and reinit if the cell type has changed or (as in
183       // the case of the hierarchics) the shape functions
184       // depend on the particular element and need a reinit
185       if (  ( Dim != 1) &&
186             (  (this->get_type() != inf_elem->type())  ||
187                (base_fe->shapes_need_reinit())  )  )
188         {
189           // store the new element type, update base_elem
190           // here\&.  Through \p update_base_elem_required,
191           // remember whether it has to be updated (see below)\&.
192           elem_type = inf_elem->type();
193           this->update_base_elem(inf_elem);
194           update_base_elem_required=false;
195 
196           // initialize the base quadrature rule for the new element
197           base_qrule->init(base_elem->type());
198 
199           // initialize the shape functions in the base
200           base_fe->init_base_shape_functions(base_fe->qrule->get_points(),
201                                              base_elem);
202 
203           init_shape_functions_required=true;
204         }
205 
206 
207       // when either the radial or base part change,
208       // we have to init the whole fields
209       if (init_shape_functions_required)
210         this->init_shape_functions (inf_elem);
211 
212       // computing the distance only works when we have the current
213       // base_elem stored\&.  This happens when fe_type is const,
214       // the inf_elem->type remains the same\&.  Then we have to
215       // update the base elem _here_\&.
216       if (update_base_elem_required)
217         this->update_base_elem(inf_elem);
218 
219       // compute dist (depends on geometry, therefore has to be updated for
220       // each and every new element), throw radial and base part together
221       this->combine_base_radial (inf_elem);
222 
223       this->_fe_map->compute_map (this->dim,_total_qrule_weights, inf_elem);
224 
225       // Compute the shape functions and the derivatives
226       // at all quadrature points\&.
227       this->compute_shape_functions (inf_elem,base_fe->qrule->get_points());
228     }
229 
230   else // if pts != NULL
231     {
232       // update the elem_type
233       elem_type = inf_elem->type();
234 
235       // init radial shapes
236       this->init_radial_shape_functions(inf_elem);
237 
238       // update the base
239       this->update_base_elem(inf_elem);
240 
241       // the finite element on the ifem base
242       {
243         AutoPtr<FEBase> ap_fb(FEBase::build(Dim-1, this->fe_type));
244         if (base_fe != NULL)
245           delete base_fe;
246         base_fe = ap_fb\&.release();
247       }
248 
249       // inite base shapes
250       base_fe->init_base_shape_functions(*pts,
251                                          base_elem);
252 
253       this->init_shape_functions (inf_elem);
254 
255       // combine the base and radial shapes
256       this->combine_base_radial (inf_elem);
257 
258       // weights
259       if (weights != NULL)
260         {
261           this->_fe_map->compute_map (this->dim, *weights, inf_elem);
262         }
263       else
264         {
265           std::vector<Real> dummy_weights (pts->size(), 1\&.);
266           this->_fe_map->compute_map (this->dim, dummy_weights, inf_elem);
267         }
268 
269       // finally compute the ifem shapes
270       this->compute_shape_functions (inf_elem,*pts);
271     }
272 
273 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_base> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_base >::reinit (const \fBElem\fP *elem, const unsigned intside, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
Not implemented yet\&. Reinitializes all the physical element-dependent data based on the \fCside\fP of an infinite element\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 40 of file inf_fe_boundary\&.C\&.
.PP
References libMesh::Elem::build_side(), libMesh::dim, libMesh::EDGE2, libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), side, and libMesh::Elem::type()\&.
.PP
.nf
45 {
46   if (weights != NULL)
47     {
48       libMesh::err << "ERROR: User-specified weights for infinite elements "
49                    << "are not implemented!" << std::endl;
50       libmesh_not_implemented();
51     }
52 
53   if (pts != NULL)
54     {
55       libMesh::err << "ERROR: User-specified points for infinite elements "
56                    << "are not implemented!" << std::endl;
57       libmesh_not_implemented();
58     }
59 
60   // We don't do this for 1D elements!
61   libmesh_assert_not_equal_to (Dim, 1);
62 
63   libmesh_assert(inf_elem);
64   libmesh_assert(qrule);
65 
66   // Don't do this for the base
67   libmesh_assert_not_equal_to (s, 0);
68 
69   // Build the side of interest
70   const AutoPtr<Elem> side(inf_elem->build_side(s));
71 
72   // set the element type
73   elem_type = inf_elem->type();
74 
75   // eventually initialize radial quadrature rule
76   bool radial_qrule_initialized = false;
77 
78   if (current_fe_type\&.radial_order != fe_type\&.radial_order)
79     {
80       current_fe_type\&.radial_order = fe_type\&.radial_order;
81       radial_qrule->init(EDGE2, inf_elem->p_level());
82       radial_qrule_initialized = true;
83     }
84 
85   // Initialize the face shape functions
86   if (this->get_type() != inf_elem->type() ||
87       base_fe->shapes_need_reinit()        ||
88       radial_qrule_initialized)
89     this->init_face_shape_functions (qrule->get_points(), side\&.get());
90 
91 
92   // compute the face map
93   this->_fe_map->compute_face_map(this->dim, _total_qrule_weights, side\&.get());
94 
95   // make a copy of the Jacobian for integration
96   const std::vector<Real> JxW_int(this->_fe_map->get_JxW());
97 
98   // Find where the integration points are located on the
99   // full element\&.
100   std::vector<Point> qp; this->inverse_map (inf_elem, this->_fe_map->get_xyz(),
101                                             qp, tolerance);
102 
103   // compute the shape function and derivative values
104   // at the points qp
105   this->reinit  (inf_elem, &qp);
106 
107   // copy back old data
108   this->_fe_map->get_JxW() = JxW_int;
109 
110 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBReal\fP \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::shape (const \fBFEType\fP &fet, const \fBElemType\fPt, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method lets you specify the relevant data directly, and is therefore allowed to be static\&. Note that this class member is by far not as efficient as its counterpart in \fCFE<Dim,T>\fP, and is \fInot\fP employed in the \fC\fBreinit()\fP\fP cycle\&. Also note that this method does \fInot\fP return physically correct shapes, instead use \fC\fBcompute_data()\fP\fP\&. The \fC\fBshape()\fP\fP methods should only be used for mapping\&. 
.RE
.PP

.PP
Definition at line 154 of file inf_fe_static\&.C\&.
.PP
References libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::Radial::decay(), libMesh::err, libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval(), libMesh::INFINITE_MAP, libMesh::FEType::radial_order, libMesh::Real, and libMesh::FEInterface::shape()\&.
.PP
Referenced by libMesh::FEInterface::ifem_shape()\&.
.PP
.nf
158 {
159   libmesh_assert_not_equal_to (Dim, 0);
160 
161 #ifdef DEBUG
162   // this makes only sense when used for mapping
163   if ((T_radial != INFINITE_MAP) && !_warned_for_shape)
164     {
165       libMesh::err << "WARNING: InfFE<Dim,T_radial,T_map>::shape(\&.\&.\&.) does _not_" << std::endl
166                    << " return the correct trial function!  Use " << std::endl
167                    << " InfFE<Dim,T_radial,T_map>::compute_data(\&.\&.) instead!"
168                    << std::endl;
169       _warned_for_shape = true;
170     }
171 #endif
172 
173   const ElemType     base_et  (Base::get_elem_type(inf_elem_type));
174   const Order        o_radial (fet\&.radial_order);
175   const Real         v        (p(Dim-1));
176 
177   unsigned int i_base, i_radial;
178   compute_shape_indices(fet, inf_elem_type, i, i_base, i_radial);
179 
180   //TODO:[SP/DD]  exp(ikr) is still missing here!
181   if (Dim > 1)
182     return FEInterface::shape(Dim-1, fet, base_et, i_base, p)
183       * InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial)
184       * InfFE<Dim,T_radial,T_map>::Radial::decay(v);
185   else
186     return InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial)
187       * InfFE<Dim,T_radial,T_map>::Radial::decay(v);
188 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> \fBReal\fP \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::shape (const \fBFEType\fP &fet, const \fBElem\fP *elem, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method lets you specify the relevant data directly, and is therefore allowed to be static\&. Note that this class member is not as efficient as its counterpart in \fCFE<Dim,T>\fP, and is \fInot\fP employed in the \fC\fBreinit()\fP\fP cycle\&. Also note that this method does \fInot\fP return physically correct shapes, instead use \fC\fBcompute_data()\fP\fP\&. The \fC\fBshape()\fP\fP methods should only be used for mapping\&. 
.RE
.PP

.PP
Definition at line 196 of file inf_fe_static\&.C\&.
.PP
References libMesh::Elem::build_side(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::Radial::decay(), libMesh::err, libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::eval(), libMesh::INFINITE_MAP, libMesh::libmesh_assert(), libMesh::FEType::radial_order, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Elem::type()\&.
.PP
.nf
200 {
201   libmesh_assert(inf_elem);
202   libmesh_assert_not_equal_to (Dim, 0);
203 
204 #ifdef DEBUG
205   // this makes only sense when used for mapping
206   if ((T_radial != INFINITE_MAP) && !_warned_for_shape)
207     {
208       libMesh::err << "WARNING: InfFE<Dim,T_radial,T_map>::shape(\&.\&.\&.) does _not_" << std::endl
209                    << " return the correct trial function!  Use " << std::endl
210                    << " InfFE<Dim,T_radial,T_map>::compute_data(\&.\&.) instead!"
211                    << std::endl;
212       _warned_for_shape = true;
213     }
214 #endif
215 
216   const Order        o_radial (fet\&.radial_order);
217   const Real         v        (p(Dim-1));
218   AutoPtr<Elem>      base_el  (inf_elem->build_side(0));
219 
220   unsigned int i_base, i_radial;
221   compute_shape_indices(fet, inf_elem->type(), i, i_base, i_radial);
222 
223   if (Dim > 1)
224     return FEInterface::shape(Dim-1, fet, base_el\&.get(), i_base, p)
225       * InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial)
226       * InfFE<Dim,T_radial,T_map>::Radial::decay(v);
227   else
228     return InfFE<Dim,T_radial,T_map>::eval(v, o_radial, i_radial)
229       * InfFE<Dim,T_radial,T_map>::Radial::decay(v);
230 }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_map> bool \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::shapes_need_reinit () const\fC [private]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP, currently not required\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1011 of file inf_fe\&.C\&.
.PP
.nf
1012 {
1013   return false;
1014 }
.fi
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> virtual void \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::side_map (const \fBElem\fP *, const \fBElem\fP *, const unsigned int, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &)\fC [inline]\fP, \fC [virtual]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 435 of file inf_fe\&.h\&.
.PP
.nf
440   {
441     libmesh_not_implemented();
442   }
.fi
.SS "template<unsigned int Dim, FEFamily T_radial, InfMapType T_base> void \fBlibMesh::InfFE\fP< Dim, T_radial, T_base >::update_base_elem (const \fBElem\fP *inf_elem)\fC [protected]\fP"
Updates the protected member \fCbase_elem\fP to the appropriate base element for the given \fCinf_elem\fP\&. 
.PP
Definition at line 133 of file inf_fe\&.C\&.
.PP
.nf
134 {
135   if (base_elem != NULL)
136     delete base_elem;
137   base_elem = Base::build_elem(inf_elem);
138 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> friend class \fBInfFE\fP\fC [friend]\fP"
Make all \fCInfFE<Dim,T_radial,T_map>\fP classes friends of each other, so that the protected \fC\fBeval()\fP\fP may be accessed\&. 
.PP
Definition at line 828 of file inf_fe\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<unsigned int> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_base_node_index\fC [protected]\fP"
The internal structure of the \fC\fBInfFE\fP\fP -- tensor product of base element times radial nodes -- has to be determined from the node numbering of the current element\&. This vector maps the \fIinfinte\fP \fC\fBElem\fP\fP node number to the associated node in the \fIbase\fP element\&. 
.PP
Definition at line 713 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<unsigned int> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_base_shape_index\fC [protected]\fP"
The internal structure of the \fC\fBInfFE\fP\fP -- tensor product of base element shapes times radial shapes -- has to be determined from the dof numbering scheme of the current infinite element\&. This vector maps the infinite \fC\fBElem\fP\fP dof index to the associated dof in the \fIbase\fP \fC\fBFE\fP\fP\&. 
.PP
Definition at line 733 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBElemType\fP \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::_compute_node_indices_fast_current_elem_type = \fBINVALID_ELEM\fP\fC [static]\fP, \fC [private]\fP"
When \fC\fBcompute_node_indices_fast()\fP\fP is used, this static variable remembers the element type for which the static variables in \fC\fBcompute_node_indices_fast()\fP\fP are currently set\&. Using a class member for the element type helps initializing it to a default value\&. 
.PP
Definition at line 809 of file inf_fe\&.h\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_curvatures(), libMesh::FEAbstract::get_d2xyzdeta2(), libMesh::FEAbstract::get_d2xyzdetadzeta(), libMesh::FEAbstract::get_d2xyzdxi2(), libMesh::FEAbstract::get_d2xyzdxideta(), libMesh::FEAbstract::get_d2xyzdxidzeta(), libMesh::FEAbstract::get_d2xyzdzeta2(), libMesh::FEAbstract::get_detadx(), libMesh::FEAbstract::get_detady(), libMesh::FEAbstract::get_detadz(), libMesh::FEAbstract::get_dxidx(), libMesh::FEAbstract::get_dxidy(), libMesh::FEAbstract::get_dxidz(), libMesh::FEAbstract::get_dxyzdeta(), libMesh::FEAbstract::get_dxyzdxi(), libMesh::FEAbstract::get_dxyzdzeta(), libMesh::FEAbstract::get_dzetadx(), libMesh::FEAbstract::get_dzetady(), libMesh::FEAbstract::get_dzetadz(), libMesh::FEAbstract::get_fe_map(), libMesh::FEAbstract::get_JxW(), libMesh::FEAbstract::get_normals(), libMesh::FEAbstract::get_tangents(), libMesh::FEAbstract::get_xyz(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_xyz(), and libMesh::FESubdivision::reinit()\&.
.SS "template<typename T> \fBAutoPtr\fP<\fBFETransformationBase\fP<OutputType> > \fBlibMesh::FEGenericBase\fP< T >::_fe_trans\fC [protected]\fP, \fC [inherited]\fP"
Object that handles computing shape function values, gradients, etc in the physical domain\&. 
.PP
Definition at line 489 of file fe_base\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> unsigned int \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_n_total_approx_sf\fC [protected]\fP"
The number of total approximation shape functions for the current configuration 
.PP
Definition at line 745 of file inf_fe\&.h\&.
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_shape_functions()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> unsigned int \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_n_total_qp\fC [protected]\fP"
The total number of quadrature points for the current configuration 
.PP
Definition at line 751 of file inf_fe\&.h\&.
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_quadrature_points()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP, \fC [inherited]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_order(), and libMesh::FEAbstract::get_p_level()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<unsigned int> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_radial_node_index\fC [protected]\fP"
The internal structure of the \fC\fBInfFE\fP\fP -- tensor product of base element times radial nodes -- has to be determined from the node numbering of the current infinite element\&. This vector maps the \fIinfinte\fP \fC\fBElem\fP\fP node number to the \fIradial\fP node (either 0 or 1)\&. 
.PP
Definition at line 703 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<unsigned int> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_radial_shape_index\fC [protected]\fP"
The internal structure of the \fC\fBInfFE\fP\fP -- tensor product of base element shapes times radial shapes -- has to be determined from the dof numbering scheme of the current infinite element\&. This vector maps the infinite \fC\fBElem\fP\fP dof index to the \fIradial\fP \fC\fBInfFE\fP\fP shape index (\fC0\fP\&.\&.radial_order+1 )\&. 
.PP
Definition at line 723 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::_total_qrule_weights\fC [protected]\fP"
this vector contains the combined integration weights, so that \fCFEAbstract::compute_map()\fP can still be used 
.PP
Definition at line 757 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> bool \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::_warned_for_nodal_soln = false\fC [static]\fP, \fC [private]\fP"
static members that are used to issue warning messages only once\&. 
.PP
Definition at line 817 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> bool \fBlibMesh::InfFE\fP< Dim, T_radial, T_map >::_warned_for_shape = false\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 818 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBElem\fP* \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::base_elem\fC [protected]\fP"
The base element associated with the current infinite element 
.PP
Definition at line 775 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBFEBase\fP* \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::base_fe\fC [protected]\fP"
Have a \fC\fBFE\fP<Dim-1\fP,T_base> handy for base approximation\&. Since this one is created using the \fC\fBFEBase::build()\fP\fP method, the \fC\fBInfFE\fP\fP class is not required to be templated w\&.r\&.t\&. to the base approximation shape\&. 
.PP
Definition at line 783 of file inf_fe\&.h\&.
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBQBase\fP* \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::base_qrule\fC [protected]\fP"
The quadrature rule for the base element associated with the current infinite element 
.PP
Definition at line 763 of file inf_fe\&.h\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::curl_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function curl values\&. Only defined for vector types\&. 
.PP
Definition at line 504 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBFEType\fP \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::current_fe_type\fC [protected]\fP"
This \fC\fBFEType\fP\fP stores the characteristics for which the data structures \fCphi\fP, \fCphi_map\fP etc are currently initialized\&. This avoids re-initializing the radial part\&. But note that currently \fIonly\fP \fCorder\fP may change, neither the \fBFE\fP families nor \fCbase_order!\fP 
.PP
Definition at line 792 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputTensor\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivative values\&. 
.PP
Definition at line 547 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phideta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta direction\&. 
.PP
Definition at line 567 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidetadzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta-zeta direction\&. 
.PP
Definition at line 572 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidx2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x direction\&. 
.PP
Definition at line 582 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxdy\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-y direction\&. 
.PP
Definition at line 587 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxdz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-z direction\&. 
.PP
Definition at line 592 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxi2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi direction\&. 
.PP
Definition at line 552 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-eta direction\&. 
.PP
Definition at line 557 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidxidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-zeta direction\&. 
.PP
Definition at line 562 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidy2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y direction\&. 
.PP
Definition at line 597 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidydz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y-z direction\&. 
.PP
Definition at line 602 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidz2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the z direction\&. 
.PP
Definition at line 607 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::d2phidzeta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the zeta direction\&. 
.PP
Definition at line 577 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2()\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP, \fC [inherited]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dist\fC [protected]\fP"
the radial distance of the base nodes from the origin 
.PP
Definition at line 622 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputDivergence\fP> > \fBlibMesh::FEGenericBase\fP< T >::div_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function divergence values\&. Only defined for vector types\&. 
.PP
Definition at line 509 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<std::vector<\fBReal\fP> > \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dmodedv\fC [protected]\fP"
the first local derivative of the radial approximation shapes\&. Needed when setting up the overall shape functions\&. 
.PP
Definition at line 655 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<\fBOutputGradient\fP> \fBlibMesh::FEGenericBase\fP< T >::dphase\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the first derivatives of the phase term in global coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 625 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphase()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dphasedeta\fC [protected]\fP"
the second local derivative (for 3D, the second in the base) of the phase term in local coordinates\&. Needed in the overall weak form of infinite element formulations\&. 
.PP
Definition at line 680 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dphasedxi\fC [protected]\fP"
the first local derivative (for 3D, the first in the base) of the phase term in local coordinates\&. Needed in the overall weak form of infinite element formulations\&. 
.PP
Definition at line 673 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dphasedzeta\fC [protected]\fP"
the third local derivative (for 3D, the derivative in radial direction) of the phase term in local coordinates\&. Needed in the overall weak form of infinite element formulations\&. 
.PP
Definition at line 687 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputGradient\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivative values\&. 
.PP
Definition at line 499 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the eta direction\&. 
.PP
Definition at line 519 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidx\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the x direction\&. 
.PP
Definition at line 529 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidxi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the xi direction\&. 
.PP
Definition at line 514 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidy\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the y direction\&. 
.PP
Definition at line 534 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidz\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the z direction\&. 
.PP
Definition at line 539 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz()\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::dphidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the zeta direction\&. 
.PP
Definition at line 524 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<std::vector<\fBReal\fP> > \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dradialdv_map\fC [protected]\fP"
the first local derivative of the radial mapping shapes 
.PP
Definition at line 666 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dsomdv\fC [protected]\fP"
the first local derivative of the radial decay $ 1/r $ in local coordinates\&. Needed when setting up the overall shape functions\&. 
.PP
Definition at line 643 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<\fBRealGradient\fP> \fBlibMesh::FEGenericBase\fP< T >::dweight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the global derivative of the additional radial weight $ 1/{r^2} $, over \fIall\fP quadrature points\&. 
.PP
Definition at line 632 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_Sobolev_dweight()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::dweightdv\fC [protected]\fP"
the additional radial weight $ 1/{r^2} $ in local coordinates, over all quadrature points\&. The weight does not vary in base direction\&. However, for uniform access to the data fields from the outside, this data field is expanded to \fIall\fP quadrature points\&. 
.PP
Definition at line 630 of file inf_fe\&.h\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP, \fC [inherited]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FEAbstract::get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP, \fC [inherited]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::compute_node_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEAbstract::get_family(), libMesh::FEAbstract::get_fe_type(), libMesh::FEAbstract::get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<std::vector<\fBReal\fP> > \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::mode\fC [protected]\fP"
the radial approximation shapes in local coordinates Needed when setting up the overall shape functions\&. 
.PP
Definition at line 649 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< T >::phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function values\&. 
.PP
Definition at line 494 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP, \fC [inherited]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FESubdivision::reinit()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<std::vector<\fBReal\fP> > \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::radial_map\fC [protected]\fP"
the radial mapping shapes in local coordinates 
.PP
Definition at line 660 of file inf_fe\&.h\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> \fBQBase\fP* \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::radial_qrule\fC [protected]\fP"
The quadrature rule for the base element associated with the current infinite element 
.PP
Definition at line 769 of file inf_fe\&.h\&.
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::n_quadrature_points()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP, \fC [inherited]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> std::vector<\fBReal\fP> \fBlibMesh::InfFE\fP< friend_Dim, friend_T_radial, friend_T_map >::som\fC [protected]\fP"
the radial decay $ 1/r $ in local coordinates\&. Needed when setting up the overall shape functions\&. Note that it is this decay which assures to satisfy the Sommerfeld radiation condition in advance\&. 
.PP
Definition at line 638 of file inf_fe\&.h\&.
.SS "template<typename T> std::vector<\fBReal\fP> \fBlibMesh::FEGenericBase\fP< T >::weight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the additional radial weight $ 1/{r^2} $ in local coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 639 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_Sobolev_weight()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
