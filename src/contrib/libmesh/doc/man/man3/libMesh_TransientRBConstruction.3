.TH "libMesh::TransientRBConstruction" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::TransientRBConstruction \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <transient_rb_construction\&.h>\fP
.PP
Inherits \fBlibMesh::TransientSystem< RBConstruction >\fP, and \fBlibMesh::RBTemporalDiscretization\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBTransientRBConstruction\fP \fBsys_type\fP"
.br
.ti -1c
.RI "typedef \fBTransientSystem\fP
.br
< \fBRBConstruction\fP > \fBParent\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBSparseMatrix\fP< \fBNumber\fP >
.br
 * >::iterator \fBmatrices_iterator\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBSparseMatrix\fP< \fBNumber\fP >
.br
 * >::const_iterator \fBconst_matrices_iterator\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBNumericVector\fP< \fBNumber\fP >
.br
 * >::iterator \fBvectors_iterator\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBNumericVector\fP< \fBNumber\fP >
.br
 * >::const_iterator \fBconst_vectors_iterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTransientRBConstruction\fP (\fBEquationSystems\fP &es, const std::string &\fBname\fP, const unsigned int \fBnumber\fP)"
.br
.ti -1c
.RI "virtual \fB~TransientRBConstruction\fP ()"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBinitialize_rb_construction\fP (bool skip_matrix_assembly=false, bool skip_vector_assembly=false)"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBtruth_solve\fP (int write_interval)"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBtrain_reduced_basis\fP (const std::string &directory_name='offline_data', const bool resize_rb_eval_data=true)"
.br
.ti -1c
.RI "virtual void \fBprocess_parameters_file\fP (const std::string &parameters_filename)"
.br
.ti -1c
.RI "virtual void \fBprint_info\fP ()"
.br
.ti -1c
.RI "virtual bool \fBgreedy_termination_test\fP (\fBReal\fP training_greedy_error, int count)"
.br
.ti -1c
.RI "virtual void \fBassemble_all_affine_operators\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble_misc_matrices\fP ()"
.br
.ti -1c
.RI "void \fBassemble_L2_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, bool apply_dirichlet_bc=true)"
.br
.ti -1c
.RI "void \fBassemble_mass_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
.br
.ti -1c
.RI "void \fBadd_scaled_mass_matrix\fP (\fBNumber\fP scalar, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
.br
.ti -1c
.RI "void \fBmass_matrix_scaled_matvec\fP (\fBNumber\fP scalar, \fBNumericVector\fP< \fBNumber\fP > &dest, \fBNumericVector\fP< \fBNumber\fP > &arg)"
.br
.ti -1c
.RI "void \fBset_L2_assembly\fP (\fBElemAssembly\fP &L2_assembly_in)"
.br
.ti -1c
.RI "\fBElemAssembly\fP & \fBget_L2_assembly\fP ()"
.br
.ti -1c
.RI "void \fBassemble_Mq_matrix\fP (unsigned int q, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, bool apply_dirichlet_bc=true)"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_M_q\fP (unsigned int q)"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_non_dirichlet_M_q\fP (unsigned int q)"
.br
.ti -1c
.RI "virtual void \fBget_all_matrices\fP (std::map< std::string, \fBSparseMatrix\fP< \fBNumber\fP > * > &all_matrices)"
.br
.ti -1c
.RI "virtual void \fBtruth_assembly\fP ()"
.br
.ti -1c
.RI "int \fBget_max_truth_solves\fP () const "
.br
.ti -1c
.RI "void \fBset_max_truth_solves\fP (int max_truth_solves_in)"
.br
.ti -1c
.RI "\fBReal\fP \fBget_POD_tol\fP () const "
.br
.ti -1c
.RI "void \fBset_POD_tol\fP (const \fBReal\fP POD_tol_in)"
.br
.ti -1c
.RI "void \fBset_delta_N\fP (const unsigned int new_delta_N)"
.br
.ti -1c
.RI "virtual void \fBload_rb_solution\fP ()"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_error_temporal_data\fP ()"
.br
.ti -1c
.RI "void \fBupdate_RB_initial_condition_all_N\fP ()"
.br
.ti -1c
.RI "virtual void \fBwrite_riesz_representors_to_files\fP (const std::string &riesz_representors_dir, const bool write_binary_residual_representors)"
.br
.ti -1c
.RI "virtual void \fBread_riesz_representors_from_files\fP (const std::string &riesz_representors_dir, const bool write_binary_residual_representors)"
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP ()"
.br
.ti -1c
.RI "virtual std::string \fBsystem_type\fP () const"
.br
.ti -1c
.RI "\fBNumber\fP \fBold_solution\fP (const \fBdof_id_type\fP global_dof_number) const"
.br
.ti -1c
.RI "\fBNumber\fP \fBolder_solution\fP (const \fBdof_id_type\fP global_dof_number) const"
.br
.ti -1c
.RI "void \fBset_rb_evaluation\fP (\fBRBEvaluation\fP &rb_eval_in)"
.br
.ti -1c
.RI "\fBRBEvaluation\fP & \fBget_rb_evaluation\fP ()"
.br
.ti -1c
.RI "bool \fBis_rb_eval_initialized\fP () const "
.br
.ti -1c
.RI "\fBRBThetaExpansion\fP & \fBget_rb_theta_expansion\fP ()"
.br
.ti -1c
.RI "void \fBset_rb_assembly_expansion\fP (\fBRBAssemblyExpansion\fP &rb_assembly_expansion_in)"
.br
.ti -1c
.RI "\fBRBAssemblyExpansion\fP & \fBget_rb_assembly_expansion\fP ()"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBcompute_max_error_bound\fP ()"
.br
.ti -1c
.RI "const \fBRBParameters\fP & \fBget_greedy_parameter\fP (unsigned int i)"
.br
.ti -1c
.RI "void \fBset_training_tolerance\fP (\fBReal\fP new_training_tolerance)"
.br
.ti -1c
.RI "\fBReal\fP \fBget_training_tolerance\fP ()"
.br
.ti -1c
.RI "unsigned int \fBget_Nmax\fP () const "
.br
.ti -1c
.RI "virtual void \fBset_Nmax\fP (unsigned int \fBNmax\fP)"
.br
.ti -1c
.RI "void \fBset_quiet_mode\fP (bool quiet_mode_in)"
.br
.ti -1c
.RI "bool \fBis_quiet\fP () const "
.br
.ti -1c
.RI "virtual void \fBload_basis_function\fP (unsigned int i)"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_inner_product_matrix\fP ()"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_non_dirichlet_inner_product_matrix\fP ()"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_Aq\fP (unsigned int q)"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBget_non_dirichlet_Aq\fP (unsigned int q)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBget_Fq\fP (unsigned int q)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBget_non_dirichlet_Fq\fP (unsigned int q)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBget_output_vector\fP (unsigned int n, unsigned int q_l)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBget_non_dirichlet_output_vector\fP (unsigned int n, unsigned int q_l)"
.br
.ti -1c
.RI "virtual void \fBget_all_vectors\fP (std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &all_vectors)"
.br
.ti -1c
.RI "virtual void \fBget_output_vectors\fP (std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &all_vectors)"
.br
.ti -1c
.RI "void \fBassemble_inner_product_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, bool apply_dof_constraints=true)"
.br
.ti -1c
.RI "void \fBassemble_constraint_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
.br
.ti -1c
.RI "void \fBassemble_and_add_constraint_matrix\fP (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
.br
.ti -1c
.RI "void \fBassemble_Aq_matrix\fP (unsigned int q, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, bool apply_dof_constraints=true)"
.br
.ti -1c
.RI "void \fBassemble_Fq_vector\fP (unsigned int q, \fBNumericVector\fP< \fBNumber\fP > *input_vector, bool apply_dof_constraints=true)"
.br
.ti -1c
.RI "void \fBadd_scaled_Aq\fP (\fBNumber\fP scalar, unsigned int q_a, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, bool symmetrize)"
.br
.ti -1c
.RI "virtual void \fBrecompute_all_residual_terms\fP (const bool compute_inner_products=true)"
.br
.ti -1c
.RI "void \fBset_rb_construction_parameters\fP (unsigned int n_training_samples_in, bool deterministic_training_in, std::string alternative_solver_in, bool reuse_preconditioner_in, bool use_relative_bound_in_greedy_in, bool write_data_during_training_in, unsigned int training_parameters_random_seed_in, bool quiet_mode_in, unsigned int Nmax_in, \fBReal\fP training_tolerance_in, \fBRBParameters\fP mu_min_in, \fBRBParameters\fP mu_max_in, std::map< std::string, std::vector< \fBReal\fP > > discrete_parameter_values_in, std::map< std::string, bool > log_scaling)"
.br
.ti -1c
.RI "void \fBprint_basis_function_orthogonality\fP ()"
.br
.ti -1c
.RI "unsigned int \fBget_delta_N\fP () const "
.br
.ti -1c
.RI "void \fBset_inner_product_assembly\fP (\fBElemAssembly\fP &inner_product_assembly_in)"
.br
.ti -1c
.RI "\fBElemAssembly\fP & \fBget_inner_product_assembly\fP ()"
.br
.ti -1c
.RI "void \fBset_constraint_assembly\fP (\fBElemAssembly\fP &constraint_assembly_in)"
.br
.ti -1c
.RI "\fBElemAssembly\fP & \fBget_constraint_assembly\fP ()"
.br
.ti -1c
.RI "void \fBzero_constrained_dofs_on_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &vector)"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBget_n_training_samples\fP () const"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBget_local_n_training_samples\fP () const"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBget_first_local_training_index\fP () const"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBget_last_local_training_index\fP () const"
.br
.ti -1c
.RI "virtual void \fBinitialize_training_parameters\fP (const \fBRBParameters\fP &mu_min, const \fBRBParameters\fP &mu_max, unsigned int n_training_parameters, std::map< std::string, bool > log_param_scale, bool deterministic=true)"
.br
.ti -1c
.RI "virtual void \fBload_training_set\fP (std::map< std::string, std::vector< \fBNumber\fP > > &new_training_set)"
.br
.ti -1c
.RI "std::pair< std::string, 
.br
std::string > \fBset_alternative_solver\fP (\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > &ls)"
.br
.ti -1c
.RI "void \fBreset_alternative_solver\fP (\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > &ls, const std::pair< std::string, std::string > &orig)"
.br
.ti -1c
.RI "void \fBbroadcast_parameters\fP (unsigned int proc_id)"
.br
.ti -1c
.RI "void \fBset_training_random_seed\fP (unsigned int seed)"
.br
.ti -1c
.RI "void \fBset_deterministic_training_parameter_name\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "const std::string & \fBget_deterministic_training_parameter_name\fP () const"
.br
.ti -1c
.RI "void \fBset_deterministic_training_parameter_repeats\fP (unsigned int repeats)"
.br
.ti -1c
.RI "unsigned int \fBget_deterministic_training_parameter_repeats\fP () const"
.br
.ti -1c
.RI "virtual void \fBassemble\fP ()"
.br
.ti -1c
.RI "virtual void \fBrestrict_solve_to\fP (const \fBSystemSubset\fP *subset, const \fBSubsetSolveMode\fP subset_solve_mode=\fBSUBSET_ZERO\fP)"
.br
.ti -1c
.RI "virtual void \fBsolve\fP ()"
.br
.ti -1c
.RI "virtual \fBLinearSolver\fP< \fBNumber\fP > * \fBget_linear_solver\fP () const "
.br
.ti -1c
.RI "virtual void \fBrelease_linear_solver\fP (\fBLinearSolver\fP< \fBNumber\fP > *) const "
.br
.ti -1c
.RI "virtual void \fBassembly\fP (bool get_residual, bool get_jacobian)"
.br
.ti -1c
.RI "unsigned int \fBn_linear_iterations\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBfinal_linear_residual\fP () const "
.br
.ti -1c
.RI "void \fBattach_shell_matrix\fP (\fBShellMatrix\fP< \fBNumber\fP > *shell_matrix)"
.br
.ti -1c
.RI "void \fBdetach_shell_matrix\fP (void)"
.br
.ti -1c
.RI "\fBShellMatrix\fP< \fBNumber\fP > * \fBget_shell_matrix\fP (void)"
.br
.ti -1c
.RI "virtual void \fBdisable_cache\fP ()"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBget_linear_solve_parameters\fP () const "
.br
.ti -1c
.RI "virtual void \fBassemble_residual_derivatives\fP (const \fBParameterVector\fP &\fBparameters\fP)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBsensitivity_solve\fP (const \fBParameterVector\fP &\fBparameters\fP)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBweighted_sensitivity_solve\fP (const \fBParameterVector\fP &\fBparameters\fP, const \fBParameterVector\fP &weights)"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBadjoint_solve\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
int, \fBReal\fP > \fBweighted_sensitivity_adjoint_solve\fP (const \fBParameterVector\fP &\fBparameters\fP, const \fBParameterVector\fP &weights, const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual void \fBadjoint_qoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &\fBparameters\fP, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual void \fBforward_qoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &\fBparameters\fP, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_hessian\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &\fBparameters\fP, \fBSensitivityData\fP &hessian)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_hessian_vector_product\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &\fBparameters\fP, const \fBParameterVector\fP &vector, \fBSensitivityData\fP &product)"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > & \fBadd_matrix\fP (const std::string &mat_name)"
.br
.ti -1c
.RI "bool \fBhave_matrix\fP (const std::string &mat_name) const "
.br
.ti -1c
.RI "const \fBSparseMatrix\fP< \fBNumber\fP > * \fBrequest_matrix\fP (const std::string &mat_name) const "
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBrequest_matrix\fP (const std::string &mat_name)"
.br
.ti -1c
.RI "const \fBSparseMatrix\fP< \fBNumber\fP > & \fBget_matrix\fP (const std::string &mat_name) const "
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > & \fBget_matrix\fP (const std::string &mat_name)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_matrices\fP () const "
.br
.ti -1c
.RI "virtual void \fBassemble_qoi\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "virtual void \fBassemble_qoi_derivative\fP (const \fBQoISet\fP &qoi_indices=\fBQoISet\fP())"
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate\fP ()"
.br
.ti -1c
.RI "bool \fBis_adjoint_already_solved\fP () const "
.br
.ti -1c
.RI "void \fBset_adjoint_already_solved\fP (bool setting)"
.br
.ti -1c
.RI "virtual void \fBqoi_parameter_sensitivity\fP (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &\fBparameters\fP, \fBSensitivityData\fP &sensitivities)"
.br
.ti -1c
.RI "virtual bool \fBcompare\fP (const \fBSystem\fP &other_system, const \fBReal\fP threshold, const bool verbose) const "
.br
.ti -1c
.RI "const std::string & \fBname\fP () const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_solution\fP (\fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &\fBparameters\fP) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &\fBparameters\fP, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const "
.br
.ti -1c
.RI "void \fBboundary_project_solution\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL)"
.br
.ti -1c
.RI "void \fBboundary_project_solution\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &\fBparameters\fP)"
.br
.ti -1c
.RI "void \fBboundary_project_vector\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g=NULL) const "
.br
.ti -1c
.RI "void \fBboundary_project_vector\fP (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), \fBGradient\fP gptr(const \fBPoint\fP &p, const \fBParameters\fP &\fBparameters\fP, const std::string &sys_name, const std::string &unknown_name), const \fBParameters\fP &\fBparameters\fP, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const "
.br
.ti -1c
.RI "unsigned int \fBnumber\fP () const "
.br
.ti -1c
.RI "void \fBupdate_global_solution\fP (std::vector< \fBNumber\fP > &global_soln) const "
.br
.ti -1c
.RI "void \fBupdate_global_solution\fP (std::vector< \fBNumber\fP > &global_soln, const unsigned int dest_proc) const "
.br
.ti -1c
.RI "const \fBMeshBase\fP & \fBget_mesh\fP () const "
.br
.ti -1c
.RI "\fBMeshBase\fP & \fBget_mesh\fP ()"
.br
.ti -1c
.RI "const \fBDofMap\fP & \fBget_dof_map\fP () const "
.br
.ti -1c
.RI "\fBDofMap\fP & \fBget_dof_map\fP ()"
.br
.ti -1c
.RI "const \fBEquationSystems\fP & \fBget_equation_systems\fP () const "
.br
.ti -1c
.RI "\fBEquationSystems\fP & \fBget_equation_systems\fP ()"
.br
.ti -1c
.RI "bool \fBactive\fP () const "
.br
.ti -1c
.RI "void \fBactivate\fP ()"
.br
.ti -1c
.RI "void \fBdeactivate\fP ()"
.br
.ti -1c
.RI "void \fBset_basic_system_only\fP ()"
.br
.ti -1c
.RI "\fBvectors_iterator\fP \fBvectors_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_vectors_iterator\fP \fBvectors_begin\fP () const "
.br
.ti -1c
.RI "\fBvectors_iterator\fP \fBvectors_end\fP ()"
.br
.ti -1c
.RI "\fBconst_vectors_iterator\fP \fBvectors_end\fP () const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_vector\fP (const std::string &vec_name, const bool projections=true, const \fBParallelType\fP type=\fBPARALLEL\fP)"
.br
.ti -1c
.RI "void \fBremove_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "bool & \fBproject_solution_on_reinit\fP (void)"
.br
.ti -1c
.RI "bool \fBhave_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBrequest_vector\fP (const unsigned int vec_num)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const std::string &vec_name)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_vector\fP (const unsigned int vec_num)"
.br
.ti -1c
.RI "const std::string & \fBvector_name\fP (const unsigned int vec_num) const "
.br
.ti -1c
.RI "const std::string & \fBvector_name\fP (const \fBNumericVector\fP< \fBNumber\fP > &vec_reference) const "
.br
.ti -1c
.RI "void \fBset_vector_preservation\fP (const std::string &vec_name, bool preserve)"
.br
.ti -1c
.RI "bool \fBvector_preservation\fP (const std::string &vec_name) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_sensitivity_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_adjoint_solution\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_weighted_sensitivity_solution\fP ()"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_solution\fP ()"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_weighted_sensitivity_solution\fP () const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_adjoint_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_adjoint_rhs\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBadd_sensitivity_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_rhs\fP (unsigned int i=0)"
.br
.ti -1c
.RI "const \fBNumericVector\fP< \fBNumber\fP > & \fBget_sensitivity_rhs\fP (unsigned int i=0) const "
.br
.ti -1c
.RI "unsigned int \fBn_vectors\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_variable_groups\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_components\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_constrained_dofs\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_dofs\fP () const "
.br
.ti -1c
.RI "unsigned int \fBadd_variable\fP (const std::string &var, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variable\fP (const std::string &var, const \fBOrder\fP order=\fBFIRST\fP, const \fBFEFamily\fP=\fBLAGRANGE\fP, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variables\fP (const std::vector< std::string > &vars, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "unsigned int \fBadd_variables\fP (const std::vector< std::string > &vars, const \fBOrder\fP order=\fBFIRST\fP, const \fBFEFamily\fP=\fBLAGRANGE\fP, const std::set< \fBsubdomain_id_type\fP > *const active_subdomains=NULL)"
.br
.ti -1c
.RI "const \fBVariable\fP & \fBvariable\fP (unsigned int var) const "
.br
.ti -1c
.RI "const \fBVariableGroup\fP & \fBvariable_group\fP (unsigned int vg) const "
.br
.ti -1c
.RI "bool \fBhas_variable\fP (const std::string &var) const "
.br
.ti -1c
.RI "const std::string & \fBvariable_name\fP (const unsigned int i) const "
.br
.ti -1c
.RI "unsigned short int \fBvariable_number\fP (const std::string &var) const "
.br
.ti -1c
.RI "void \fBget_all_variable_numbers\fP (std::vector< unsigned int > &all_variable_numbers) const "
.br
.ti -1c
.RI "unsigned int \fBvariable_scalar_number\fP (const std::string &var, unsigned int component) const "
.br
.ti -1c
.RI "unsigned int \fBvariable_scalar_number\fP (unsigned int var_num, unsigned int component) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_type\fP (const unsigned int i) const "
.br
.ti -1c
.RI "const \fBFEType\fP & \fBvariable_type\fP (const std::string &var) const "
.br
.ti -1c
.RI "bool \fBidentify_variable_groups\fP () const "
.br
.ti -1c
.RI "void \fBidentify_variable_groups\fP (const bool)"
.br
.ti -1c
.RI "\fBReal\fP \fBcalculate_norm\fP (const \fBNumericVector\fP< \fBNumber\fP > &v, unsigned int var, \fBFEMNormType\fP norm_type) const "
.br
.ti -1c
.RI "\fBReal\fP \fBcalculate_norm\fP (const \fBNumericVector\fP< \fBNumber\fP > &v, const \fBSystemNorm\fP &norm) const "
.br
.ti -1c
.RI "void \fBread_header\fP (\fBXdr\fP &io, const std::string &version, const bool read_header=true, const bool read_additional_data=true, const bool read_legacy_format=false)"
.br
.ti -1c
.RI "void \fBread_legacy_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "template<typename ValType > void \fBread_serialized_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "void \fBread_serialized_data\fP (\fBXdr\fP &io, const bool read_additional_data=true)"
.br
.ti -1c
.RI "template<typename InValType > std::size_t \fBread_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "std::size_t \fBread_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "template<typename InValType > void \fBread_parallel_data\fP (\fBXdr\fP &io, const bool read_additional_data)"
.br
.ti -1c
.RI "void \fBread_parallel_data\fP (\fBXdr\fP &io, const bool read_additional_data)"
.br
.ti -1c
.RI "void \fBwrite_header\fP (\fBXdr\fP &io, const std::string &version, const bool write_additional_data) const "
.br
.ti -1c
.RI "void \fBwrite_serialized_data\fP (\fBXdr\fP &io, const bool write_additional_data=true) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBwrite_serialized_vectors\fP (\fBXdr\fP &io, const std::vector< const \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const "
.br
.ti -1c
.RI "void \fBwrite_parallel_data\fP (\fBXdr\fP &io, const bool write_additional_data) const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "void \fBattach_init_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_init_object\fP (\fBInitialization\fP &\fBinit\fP)"
.br
.ti -1c
.RI "void \fBattach_assemble_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_assemble_object\fP (\fBAssembly\fP &\fBassemble\fP)"
.br
.ti -1c
.RI "void \fBattach_constraint_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP))"
.br
.ti -1c
.RI "void \fBattach_constraint_object\fP (\fBConstraint\fP &constrain)"
.br
.ti -1c
.RI "void \fBattach_QOI_function\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP, const \fBQoISet\fP &qoi_indices))"
.br
.ti -1c
.RI "void \fBattach_QOI_object\fP (\fBQOI\fP &\fBqoi\fP)"
.br
.ti -1c
.RI "void \fBattach_QOI_derivative\fP (void fptr(\fBEquationSystems\fP &es, const std::string &\fBname\fP, const \fBQoISet\fP &qoi_indices))"
.br
.ti -1c
.RI "void \fBattach_QOI_derivative_object\fP (\fBQOIDerivative\fP &qoi_derivative)"
.br
.ti -1c
.RI "virtual void \fBuser_initialization\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_assembly\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_constrain\fP ()"
.br
.ti -1c
.RI "virtual void \fBuser_QOI\fP (const \fBQoISet\fP &qoi_indices)"
.br
.ti -1c
.RI "virtual void \fBuser_QOI_derivative\fP (const \fBQoISet\fP &qoi_indices)"
.br
.ti -1c
.RI "virtual void \fBrestrict_vectors\fP ()"
.br
.ti -1c
.RI "virtual void \fBprolong_vectors\fP ()"
.br
.ti -1c
.RI "\fBNumber\fP \fBcurrent_solution\fP (const \fBdof_id_type\fP global_dof_number) const "
.br
.ti -1c
.RI "\fBNumber\fP \fBpoint_value\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBNumber\fP \fBpoint_value\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "\fBGradient\fP \fBpoint_gradient\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBGradient\fP \fBpoint_gradient\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "\fBTensor\fP \fBpoint_hessian\fP (unsigned int var, const \fBPoint\fP &p, const bool insist_on_success=true) const "
.br
.ti -1c
.RI "\fBTensor\fP \fBpoint_hessian\fP (unsigned int var, const \fBPoint\fP &p, const \fBElem\fP &e) const "
.br
.ti -1c
.RI "void \fBlocal_dof_indices\fP (const unsigned int var, std::set< \fBdof_id_type\fP > &var_indices) const "
.br
.ti -1c
.RI "void \fBzero_variable\fP (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned int var_num) const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.ti -1c
.RI "void \fBinitialize_parameters\fP (const \fBRBParameters\fP &mu_min_in, const \fBRBParameters\fP &mu_max_in, const std::map< std::string, std::vector< \fBReal\fP > > &discrete_parameter_values)"
.br
.ti -1c
.RI "void \fBinitialize_parameters\fP (const \fBRBParametrized\fP &rb_parametrized)"
.br
.ti -1c
.RI "unsigned int \fBget_n_params\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_n_continuous_params\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_n_discrete_params\fP () const "
.br
.ti -1c
.RI "std::set< std::string > \fBget_parameter_names\fP () const "
.br
.ti -1c
.RI "const \fBRBParameters\fP & \fBget_parameters\fP () const "
.br
.ti -1c
.RI "void \fBset_parameters\fP (const \fBRBParameters\fP &params)"
.br
.ti -1c
.RI "const \fBRBParameters\fP & \fBget_parameters_min\fP () const "
.br
.ti -1c
.RI "const \fBRBParameters\fP & \fBget_parameters_max\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBget_parameter_min\fP (const std::string &param_name) const "
.br
.ti -1c
.RI "\fBReal\fP \fBget_parameter_max\fP (const std::string &param_name) const "
.br
.ti -1c
.RI "void \fBprint_parameters\fP () const "
.br
.ti -1c
.RI "void \fBwrite_parameter_data_to_files\fP (const std::string &continuous_param_file_name, const std::string &discrete_param_file_name, const bool write_binary_data)"
.br
.ti -1c
.RI "void \fBread_parameter_data_from_files\fP (const std::string &continuous_param_file_name, const std::string &discrete_param_file_name, const bool read_binary_data)"
.br
.ti -1c
.RI "bool \fBis_discrete_parameter\fP (const std::string &mu_name) const "
.br
.ti -1c
.RI "const std::map< std::string, 
.br
std::vector< \fBReal\fP > > & \fBget_discrete_parameter_values\fP () const "
.br
.ti -1c
.RI "void \fBprint_discrete_parameter_values\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBget_delta_t\fP () const "
.br
.ti -1c
.RI "void \fBset_delta_t\fP (const \fBReal\fP delta_t_in)"
.br
.ti -1c
.RI "\fBReal\fP \fBget_euler_theta\fP () const "
.br
.ti -1c
.RI "void \fBset_euler_theta\fP (const \fBReal\fP euler_theta_in)"
.br
.ti -1c
.RI "unsigned int \fBget_time_step\fP () const "
.br
.ti -1c
.RI "void \fBset_time_step\fP (const unsigned int k)"
.br
.ti -1c
.RI "unsigned int \fBget_n_time_steps\fP () const "
.br
.ti -1c
.RI "void \fBset_n_time_steps\fP (const unsigned int K)"
.br
.ti -1c
.RI "void \fBprocess_temporal_parameters_file\fP (const std::string &parameters_filename)"
.br
.ti -1c
.RI "void \fBpull_temporal_discretization_data\fP (\fBRBTemporalDiscretization\fP &other)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBDirichletBoundary\fP > \fBbuild_zero_dirichlet_boundary_object\fP ()"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static \fBReal\fP \fBget_closest_value\fP (\fBReal\fP value, const std::vector< \fBReal\fP > &list_of_values)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBL2_matrix\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBnon_dirichlet_L2_matrix\fP"
.br
.ti -1c
.RI "std::vector< \fBSparseMatrix\fP
.br
< \fBNumber\fP > * > \fBM_q_vector\fP"
.br
.ti -1c
.RI "std::vector< \fBSparseMatrix\fP
.br
< \fBNumber\fP > * > \fBnon_dirichlet_M_q_vector\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBNumber\fP > > \fBtruth_outputs_all_k\fP"
.br
.ti -1c
.RI "bool \fBnonzero_initialization\fP"
.br
.ti -1c
.RI "bool \fBcompute_truth_projection_error\fP"
.br
.ti -1c
.RI "std::string \fBinit_filename\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBold_local_solution\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBolder_local_solution\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBtraining_error_bounds\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBinner_product_matrix\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBnon_dirichlet_inner_product_matrix\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSparseMatrix\fP< \fBNumber\fP > > \fBconstraint_matrix\fP"
.br
.ti -1c
.RI "std::vector< \fBNumber\fP > \fBtruth_outputs\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBNumber\fP > > \fBoutput_dual_innerprods\fP"
.br
.ti -1c
.RI "std::vector< \fBNumericVector\fP
.br
< \fBNumber\fP > * > \fBFq_representor\fP"
.br
.ti -1c
.RI "std::vector< \fBNumber\fP > \fBFq_representor_innerprods\fP"
.br
.ti -1c
.RI "bool \fBconstrained_problem\fP"
.br
.ti -1c
.RI "bool \fBreuse_preconditioner\fP"
.br
.ti -1c
.RI "bool \fBuse_relative_bound_in_greedy\fP"
.br
.ti -1c
.RI "bool \fBexit_on_repeated_greedy_parameters\fP"
.br
.ti -1c
.RI "bool \fBwrite_data_during_training\fP"
.br
.ti -1c
.RI "bool \fBimpose_internal_dirichlet_BCs\fP"
.br
.ti -1c
.RI "bool \fBimpose_internal_fluxes\fP"
.br
.ti -1c
.RI "bool \fBcompute_RB_inner_product\fP"
.br
.ti -1c
.RI "bool \fBstore_non_dirichlet_operators\fP"
.br
.ti -1c
.RI "bool \fBenforce_constraints_exactly\fP"
.br
.ti -1c
.RI "bool \fBuse_empty_rb_solve_in_greedy\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > \fBlinear_solver\fP"
.br
.ti -1c
.RI "\fBSparseMatrix\fP< \fBNumber\fP > * \fBmatrix\fP"
.br
.ti -1c
.RI "\fBNumericVector\fP< \fBNumber\fP > * \fBrhs\fP"
.br
.ti -1c
.RI "bool \fBassemble_before_solve\fP"
.br
.ti -1c
.RI "bool \fBuse_fixed_solution\fP"
.br
.ti -1c
.RI "int \fBextra_quadrature_order\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBsolution\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBcurrent_local_solution\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBtime\fP"
.br
.ti -1c
.RI "std::vector< \fBNumber\fP > \fBqoi\fP"
.br
.ti -1c
.RI "bool \fBverbose_mode\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBallocate_data_structures\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble_affine_expansion\fP (bool skip_matrix_assembly, bool skip_vector_assembly)"
.br
.ti -1c
.RI "virtual void \fBinitialize_truth\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble_matrix_for_output_dual_solves\fP ()"
.br
.ti -1c
.RI "void \fBadd_IC_to_RB_space\fP ()"
.br
.ti -1c
.RI "virtual void \fBenrich_RB_space\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_system\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_RB_system_matrices\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_residual_terms\fP (bool compute_inner_products)"
.br
.ti -1c
.RI "\fBNumber\fP \fBset_error_temporal_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBre_update\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBDGFEMContext\fP > \fBbuild_context\fP ()"
.br
.ti -1c
.RI "void \fBupdate_greedy_param_list\fP ()"
.br
.ti -1c
.RI "void \fBadd_scaled_matrix_and_vector\fP (\fBNumber\fP scalar, \fBElemAssembly\fP *elem_assembly, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, \fBNumericVector\fP< \fBNumber\fP > *input_vector, bool symmetrize=false, bool apply_dof_constraints=true)"
.br
.ti -1c
.RI "virtual void \fBset_context_solution_vec\fP (\fBNumericVector\fP< \fBNumber\fP > &vec)"
.br
.ti -1c
.RI "virtual void \fBassemble_all_affine_vectors\fP ()"
.br
.ti -1c
.RI "virtual void \fBassemble_all_output_vectors\fP ()"
.br
.ti -1c
.RI "virtual void \fBcompute_output_dual_innerprods\fP ()"
.br
.ti -1c
.RI "virtual void \fBcompute_Fq_representor_innerprods\fP (bool compute_inner_products=true)"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBget_RB_error_bound\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit_context\fP (\fBFEMContext\fP &)"
.br
.ti -1c
.RI "bool \fBget_convergence_assertion_flag\fP () const "
.br
.ti -1c
.RI "void \fBset_convergence_assertion_flag\fP (bool flag)"
.br
.ti -1c
.RI "void \fBcheck_convergence\fP ()"
.br
.ti -1c
.RI "\fBRBParameters\fP \fBget_params_from_training_set\fP (unsigned int index)"
.br
.ti -1c
.RI "void \fBset_params_from_training_set\fP (unsigned int index)"
.br
.ti -1c
.RI "virtual void \fBset_params_from_training_set_and_broadcast\fP (unsigned int index)"
.br
.ti -1c
.RI "virtual void \fBinit_matrices\fP ()"
.br
.ti -1c
.RI "void \fBproject_vector\fP (\fBNumericVector\fP< \fBNumber\fP > &) const "
.br
.ti -1c
.RI "void \fBproject_vector\fP (const \fBNumericVector\fP< \fBNumber\fP > &, \fBNumericVector\fP< \fBNumber\fP > &) const "
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &\fBname\fP)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBget_global_max_error_pair\fP (const \fBParallel::Communicator\fP &\fBcommunicator\fP, std::pair< unsigned int, \fBReal\fP > &error_pair)"
.br
.ti -1c
.RI "static void \fBgenerate_training_parameters_random\fP (const \fBParallel::Communicator\fP &\fBcommunicator\fP, std::map< std::string, bool > log_param_scale, std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &training_parameters_in, unsigned int n_training_samples_in, const \fBRBParameters\fP &min_parameters, const \fBRBParameters\fP &max_parameters, int \fBtraining_parameters_random_seed\fP=-1, bool \fBserial_training_set\fP=false)"
.br
.ti -1c
.RI "static void \fBgenerate_training_parameters_deterministic\fP (const \fBParallel::Communicator\fP &\fBcommunicator\fP, std::map< std::string, bool > log_param_scale, std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &training_parameters_in, unsigned int n_training_samples_in, const \fBRBParameters\fP &min_parameters, const \fBRBParameters\fP &max_parameters, bool \fBserial_training_set\fP=false)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBReal\fP \fBPOD_tol\fP"
.br
.ti -1c
.RI "int \fBmax_truth_solves\fP"
.br
.ti -1c
.RI "\fBElemAssembly\fP * \fBL2_assembly\fP"
.br
.ti -1c
.RI "\fBDenseVector\fP< \fBNumber\fP > \fBRB_ic_proj_rhs_all_N\fP"
.br
.ti -1c
.RI "unsigned int \fBNmax\fP"
.br
.ti -1c
.RI "unsigned int \fBdelta_N\fP"
.br
.ti -1c
.RI "bool \fBquiet_mode\fP"
.br
.ti -1c
.RI "bool \fBoutput_dual_innerprods_computed\fP"
.br
.ti -1c
.RI "bool \fBFq_representor_innerprods_computed\fP"
.br
.ti -1c
.RI "bool \fBassert_convergence\fP"
.br
.ti -1c
.RI "bool \fBserial_training_set\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBinner_product_storage_vector\fP"
.br
.ti -1c
.RI "std::string \fBalternative_solver\fP"
.br
.ti -1c
.RI "unsigned int \fB_n_linear_iterations\fP"
.br
.ti -1c
.RI "\fBReal\fP \fB_final_linear_residual\fP"
.br
.ti -1c
.RI "\fBShellMatrix\fP< \fBNumber\fP > * \fB_shell_matrix\fP"
.br
.ti -1c
.RI "const \fBSystemSubset\fP * \fB_subset\fP"
.br
.ti -1c
.RI "\fBSubsetSolveMode\fP \fB_subset_solve_mode\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBNumericVector\fP
.br
< \fBNumber\fP > * > \fBtemporal_data\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class is part of the rbOOmit framework\&.
.PP
\fBTransientRBConstruction\fP extends \fBRBConstruction\fP to add functionality relevant in the time-dependent case\&.
.PP
\fBAuthor:\fP
.RS 4
David J\&. Knezevic 2009 
.RE
.PP

.PP
Definition at line 48 of file transient_rb_construction\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, \fBSparseMatrix\fP<\fBNumber\fP>* >::const_iterator \fBlibMesh::ImplicitSystem::const_matrices_iterator\fP\fC [inherited]\fP"

.PP
Definition at line 277 of file implicit_system\&.h\&.
.SS "typedef std::map<std::string, \fBNumericVector\fP<\fBNumber\fP>* >::const_iterator \fBlibMesh::System::const_vectors_iterator\fP\fC [inherited]\fP"

.PP
Definition at line 718 of file system\&.h\&.
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef std::map<std::string, \fBSparseMatrix\fP<\fBNumber\fP>* >::iterator \fBlibMesh::ImplicitSystem::matrices_iterator\fP\fC [inherited]\fP"
Matrix iterator typedefs\&. 
.PP
Definition at line 276 of file implicit_system\&.h\&.
.SS "typedef \fBTransientSystem\fP<\fBRBConstruction\fP> \fBlibMesh::TransientRBConstruction::Parent\fP"
The type of the parent\&. 
.PP
Definition at line 73 of file transient_rb_construction\&.h\&.
.SS "typedef \fBTransientRBConstruction\fP \fBlibMesh::TransientRBConstruction::sys_type\fP"
The type of system\&. 
.PP
Definition at line 68 of file transient_rb_construction\&.h\&.
.SS "typedef std::map<std::string, \fBNumericVector\fP<\fBNumber\fP>* >::iterator \fBlibMesh::System::vectors_iterator\fP\fC [inherited]\fP"
Vector iterator typedefs\&. 
.PP
Definition at line 717 of file system\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::TransientRBConstruction::TransientRBConstruction (\fBEquationSystems\fP &es, const std::string &name, const unsigned intnumber)"
Constructor\&. Optionally initializes required data structures\&. 
.SS "virtual libMesh::TransientRBConstruction::~TransientRBConstruction ()\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::System::activate ()\fC [inline]\fP, \fC [inherited]\fP"
Activates the system\&. Only active systems are solved\&. 
.PP
Definition at line 1927 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1928 {
1929   _active = true;
1930 }
.fi
.SS "bool libMesh::System::active () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the system is active, \fCfalse\fP otherwise\&. An active system will be solved\&. 
.RE
.PP

.PP
Definition at line 1919 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1920 {
1921   return _active;
1922 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_adjoint_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 1017 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ExplicitSystem::assemble_qoi_derivative(), and libMesh::FEMSystem::assemble_qoi_derivative()\&.
.PP
.nf
1018 {
1019   std::ostringstream adjoint_rhs_name;
1020   adjoint_rhs_name << "adjoint_rhs" << i;
1021 
1022   return this->add_vector(adjoint_rhs_name\&.str(), false);
1023 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 957 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve()\&.
.PP
.nf
958 {
959   std::ostringstream adjoint_name;
960   adjoint_name << "adjoint_solution" << i;
961 
962   return this->add_vector(adjoint_name\&.str());
963 }
.fi
.SS "void libMesh::TransientRBConstruction::add_IC_to_RB_space ()\fC [protected]\fP"
Initialize RB space by adding the truth initial condition as the first RB basis function\&. 
.SS "\fBSparseMatrix\fP< \fBNumber\fP > & libMesh::ImplicitSystem::add_matrix (const std::string &mat_name)\fC [inherited]\fP"
Adds the additional matrix \fCmat_name\fP to this system\&. Only allowed \fIprior\fP to \fC\fBassemble()\fP\fP\&. All additional matrices have the same sparsity pattern as the matrix used during solution\&. When not \fC\fBSystem\fP\fP but the \fIuser\fP wants to initialize the mayor matrix, then all the additional matrices, if existent, have to be initialized by the user, too\&. 
.PP
Definition at line 207 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_can_add_matrices, libMesh::ImplicitSystem::_matrices, libMesh::SparseMatrix< T >::build(), libMesh::ParallelObject::comm(), libMesh::err, and libMesh::ImplicitSystem::have_matrix()\&.
.PP
Referenced by libMesh::ImplicitSystem::add_system_matrix(), libMesh::EigenTimeSolver::init(), and libMesh::NewmarkSystem::NewmarkSystem()\&.
.PP
.nf
208 {
209   // only add matrices before initializing\&.\&.\&.
210   if (!_can_add_matrices)
211     {
212       libMesh::err << "ERROR: Too late\&.  Cannot add matrices to the system after initialization"
213                    << std::endl
214                    << " any more\&.  You should have done this earlier\&."
215                    << std::endl;
216       libmesh_error();
217     }
218 
219   // Return the matrix if it is already there\&.
220   if (this->have_matrix(mat_name))
221     return *(_matrices[mat_name]);
222 
223   // Otherwise build the matrix and return it\&.
224   SparseMatrix<Number>* buf = SparseMatrix<Number>::build(this->comm())\&.release();
225   _matrices\&.insert (std::make_pair (mat_name, buf));
226 
227   return *buf;
228 }
.fi
.SS "void libMesh::RBConstruction::add_scaled_Aq (\fBNumber\fPscalar, unsigned intq_a, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, boolsymmetrize)\fC [inherited]\fP"
Add the scaled q^th affine matrix to input_matrix\&. If symmetrize==true, then we symmetrize Aq before adding it\&. 
.SS "void libMesh::TransientRBConstruction::add_scaled_mass_matrix (\fBNumber\fPscalar, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
Add the scaled mass matrix (assembled for the current parameter) to input_matrix\&. 
.SS "void libMesh::RBConstruction::add_scaled_matrix_and_vector (\fBNumber\fPscalar, \fBElemAssembly\fP *elem_assembly, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, \fBNumericVector\fP< \fBNumber\fP > *input_vector, boolsymmetrize = \fCfalse\fP, boolapply_dof_constraints = \fCtrue\fP)\fC [protected]\fP, \fC [inherited]\fP"
This function loops over the mesh and applies the specified interior and/or boundary assembly routines, then adds the scaled result to input_matrix and/or input_vector\&. If symmetrize==true then we assemble the symmetric part of the matrix, 0\&.5*(A + A^T) 
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_sensitivity_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 1047 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::assemble_residual_derivatives()\&.
.PP
.nf
1048 {
1049   std::ostringstream sensitivity_rhs_name;
1050   sensitivity_rhs_name << "sensitivity_rhs" << i;
1051 
1052   return this->add_vector(sensitivity_rhs_name\&.str(), false);
1053 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_sensitivity_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 906 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
907 {
908   std::ostringstream sensitivity_name;
909   sensitivity_name << "sensitivity_solution" << i;
910 
911   return this->add_vector(sensitivity_name\&.str());
912 }
.fi
.SS "unsigned int libMesh::System::add_variable (const std::string &var, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Returns the index number for the new variable\&. 
.PP
Definition at line 1077 of file system\&.C\&.
.PP
References libMesh::System::_variable_groups, libMesh::System::_variable_numbers, libMesh::System::_variables, libMesh::System::add_variables(), libMesh::err, libMesh::System::identify_variable_groups(), libMesh::System::n_variable_groups(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::System::variable_name(), and libMesh::System::variable_type()\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::ErrorVector::plot_error(), and libMesh::System::read_header()\&.
.PP
.nf
1080 {
1081   // Make sure the variable isn't there already
1082   // or if it is, that it's the type we want
1083   for (unsigned int v=0; v<this->n_vars(); v++)
1084     if (this->variable_name(v) == var)
1085       {
1086         if (this->variable_type(v) == type)
1087           return _variables[v]\&.number();
1088 
1089         libMesh::err << "ERROR: incompatible variable "
1090                      << var
1091                      << " has already been added for this system!"
1092                      << std::endl;
1093         libmesh_error();
1094       }
1095 
1096   // Optimize for VariableGroups here - if the user is adding multiple
1097   // variables of the same FEType and subdomain restriction, catch
1098   // that here and add them as members of the same VariableGroup\&.
1099   //
1100   // start by setting this flag to whatever the user has requested
1101   // and then consider the conditions which should negate it\&.
1102   bool should_be_in_vg = this->identify_variable_groups();
1103 
1104   // No variable groups, nothing to add to
1105   if (!this->n_variable_groups())
1106     should_be_in_vg = false;
1107 
1108   else
1109     {
1110       VariableGroup &vg(_variable_groups\&.back());
1111 
1112       // get a pointer to their subdomain restriction, if any\&.
1113       const std::set<subdomain_id_type> * const
1114         their_active_subdomains (vg\&.implicitly_active() ?
1115                                  NULL : &vg\&.active_subdomains());
1116 
1117       // Different types?
1118       if (vg\&.type() != type)
1119         should_be_in_vg = false;
1120 
1121       // they are restricted, we aren't?
1122       if (their_active_subdomains && !active_subdomains)
1123         should_be_in_vg = false;
1124 
1125       // they aren't restriced, we are?
1126       if (!their_active_subdomains && active_subdomains)
1127         should_be_in_vg = false;
1128 
1129       if (their_active_subdomains && active_subdomains)
1130         // restricted to different sets?
1131         if (*their_active_subdomains != *active_subdomains)
1132           should_be_in_vg = false;
1133 
1134       // OK, after all that, append the variable to the vg if none of the conditions
1135       // were violated
1136       if (should_be_in_vg)
1137         {
1138           const unsigned int curr_n_vars = this->n_vars();
1139 
1140           vg\&.append (var);
1141 
1142           _variables\&.push_back(vg(vg\&.n_variables()-1));
1143           _variable_numbers[var] = curr_n_vars;
1144           return curr_n_vars;
1145         }
1146     }
1147 
1148   // otherwise, fall back to adding a single variable group
1149   return this->add_variables (std::vector<std::string>(1, var),
1150                               type,
1151                               active_subdomains);
1152 }
.fi
.SS "unsigned int libMesh::System::add_variable (const std::string &var, const \fBOrder\fPorder = \fC\fBFIRST\fP\fP, const \fBFEFamily\fPfamily = \fC\fBLAGRANGE\fP\fP, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Same as before, but assumes \fCLAGRANGE\fP as default value for \fC\fBFEType\&.family\fP\fP\&. 
.PP
Definition at line 1156 of file system\&.C\&.
.PP
References libMesh::System::add_variable()\&.
.PP
.nf
1160 {
1161   return this->add_variable(var,
1162                             FEType(order, family),
1163                             active_subdomains);
1164 }
.fi
.SS "unsigned int libMesh::System::add_variables (const std::vector< std::string > &vars, const \fBFEType\fP &type, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Returns the index number for the new variable\&. 
.PP
Definition at line 1168 of file system\&.C\&.
.PP
References libMesh::System::_variable_groups, libMesh::System::_variable_numbers, libMesh::System::_variables, libMesh::err, libMesh::System::n_components(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::System::variable_name(), and libMesh::System::variable_type()\&.
.PP
Referenced by libMesh::System::add_variable(), and libMesh::System::add_variables()\&.
.PP
.nf
1171 {
1172   // Make sure the variable isn't there already
1173   // or if it is, that it's the type we want
1174   for (unsigned int ov=0; ov<vars\&.size(); ov++)
1175     for (unsigned int v=0; v<this->n_vars(); v++)
1176       if (this->variable_name(v) == vars[ov])
1177         {
1178           if (this->variable_type(v) == type)
1179             return _variables[v]\&.number();
1180 
1181           libMesh::err << "ERROR: incompatible variable "
1182                        << vars[ov]
1183                        << " has already been added for this system!"
1184                        << std::endl;
1185           libmesh_error();
1186         }
1187 
1188   const unsigned int curr_n_vars = this->n_vars();
1189 
1190   const unsigned int next_first_component = this->n_components();
1191 
1192   // Add the variable group to the list
1193   _variable_groups\&.push_back((active_subdomains == NULL) ?
1194                              VariableGroup(this, vars, curr_n_vars,
1195                                            next_first_component, type) :
1196                              VariableGroup(this, vars, curr_n_vars,
1197                                            next_first_component, type, *active_subdomains));
1198 
1199   const VariableGroup &vg (_variable_groups\&.back());
1200 
1201   // Add each component of the group individually
1202   for (unsigned int v=0; v<vars\&.size(); v++)
1203     {
1204       _variables\&.push_back (vg(v));
1205       _variable_numbers[vars[v]] = curr_n_vars+v;
1206     }
1207 
1208   libmesh_assert_equal_to ((curr_n_vars+vars\&.size()), this->n_vars());
1209 
1210   // BSK - Defer this now to System::init_data() so we can detect
1211   // VariableGroups 12/28/2012
1212   // // Add the variable group to the _dof_map
1213   // _dof_map->add_variable_group (vg);
1214 
1215   // Return the number of the new variable
1216   return curr_n_vars+vars\&.size()-1;
1217 }
.fi
.SS "unsigned int libMesh::System::add_variables (const std::vector< std::string > &vars, const \fBOrder\fPorder = \fC\fBFIRST\fP\fP, const \fBFEFamily\fPfamily = \fC\fBLAGRANGE\fP\fP, const std::set< \fBsubdomain_id_type\fP > *constactive_subdomains = \fCNULL\fP)\fC [inherited]\fP"
Adds the variable \fCvar\fP to the list of variables for this system\&. Same as before, but assumes \fCLAGRANGE\fP as default value for \fC\fBFEType\&.family\fP\fP\&. 
.PP
Definition at line 1221 of file system\&.C\&.
.PP
References libMesh::System::add_variables()\&.
.PP
.nf
1225 {
1226   return this->add_variables(vars,
1227                              FEType(order, family),
1228                              active_subdomains);
1229 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_vector (const std::string &vec_name, const boolprojections = \fCtrue\fP, const \fBParallelType\fPtype = \fC\fBPARALLEL\fP\fP)\fC [inherited]\fP"
Adds the additional vector \fCvec_name\fP to this system\&. All the additional vectors are similarly distributed, like the \fCsolution\fP, and inititialized to zero\&.
.PP
By default vectors added by add_vector are projected to changed grids by \fBreinit()\fP\&. To zero them instead (more efficient), pass 'false' as the second argument 
.PP
Definition at line 676 of file system\&.C\&.
.PP
References libMesh::System::_can_add_vectors, libMesh::System::_dof_map, libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, libMesh::NumericVector< T >::build(), libMesh::ParallelObject::comm(), libMesh::err, libMesh::GHOSTED, libMesh::System::have_vector(), libMesh::NumericVector< T >::init(), libMesh::System::n_dofs(), and libMesh::System::n_local_dofs()\&.
.PP
Referenced by libMesh::System::add_adjoint_rhs(), libMesh::System::add_adjoint_solution(), libMesh::System::add_sensitivity_rhs(), libMesh::System::add_sensitivity_solution(), libMesh::ExplicitSystem::add_system_rhs(), libMesh::System::add_weighted_sensitivity_adjoint_solution(), libMesh::System::add_weighted_sensitivity_solution(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnsteadySolver::init(), libMesh::ContinuationSystem::init_data(), libMesh::NewmarkSystem::NewmarkSystem(), libMesh::System::read_header(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), and libMesh::FrequencySystem::set_frequencies_by_steps()\&.
.PP
.nf
679 {
680   // Return the vector if it is already there\&.
681   if (this->have_vector(vec_name))
682     return *(_vectors[vec_name]);
683 
684   // Otherwise build the vector
685   NumericVector<Number>* buf = NumericVector<Number>::build(this->comm())\&.release();
686   _vectors\&.insert (std::make_pair (vec_name, buf));
687   _vector_projections\&.insert (std::make_pair (vec_name, projections));
688 
689   _vector_types\&.insert (std::make_pair (vec_name, type));
690 
691   // Initialize it if necessary
692   if (!_can_add_vectors)
693     {
694       if(type == GHOSTED)
695         {
696 #ifdef LIBMESH_ENABLE_GHOSTED
697           buf->init (this->n_dofs(), this->n_local_dofs(),
698                      _dof_map->get_send_list(), false,
699                      GHOSTED);
700 #else
701           libMesh::err << "Cannot initialize ghosted vectors when they are not enabled\&." << std::endl;
702           libmesh_error();
703 #endif
704         }
705       else
706         buf->init (this->n_dofs(), this->n_local_dofs(), false, type);
707     }
708 
709   return *buf;
710 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 987 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
988 {
989   std::ostringstream adjoint_name;
990   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
991 
992   return this->add_vector(adjoint_name\&.str());
993 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::add_weighted_sensitivity_solution ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve Creates the vector if it doesn't already exist\&. 
.RE
.PP

.PP
Definition at line 936 of file system\&.C\&.
.PP
References libMesh::System::add_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
937 {
938   return this->add_vector("weighted_sensitivity_solution");
939 }
.fi
.SS "void libMesh::ImplicitSystem::adjoint_qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [virtual]\fP, \fC [inherited]\fP"
Solves for the derivative of each of the system's quantities of interest q in \fCqoi\fP[qoi_indices] with respect to each parameter in \fCparameters\fP, placing the result for qoi \fCi\fP and parameter \fCj\fP into \fCsensitivities\fP[i][j]\&.
.PP
Uses \fBadjoint_solve()\fP and the adjoint sensitivity method\&.
.PP
Currently uses finite differenced derivatives (partial q / partial p) and (partial R / partial p)\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 701 of file implicit_system\&.C\&.
.PP
References libMesh::SensitivityData::allocate_data(), libMesh::AutoPtr< Tp >::get(), libMesh::get_dof_map(), libMesh::QoISet::has_index(), libMesh::Real, libMesh::ParameterVector::size(), and libMesh::TOLERANCE\&.
.PP
.nf
704 {
705   const unsigned int Np = libmesh_cast_int<unsigned int>
706     (parameters\&.size());
707   const unsigned int Nq = libmesh_cast_int<unsigned int>
708     (qoi\&.size());
709 
710   // We currently get partial derivatives via central differencing
711   const Real delta_p = TOLERANCE;
712 
713   // An introduction to the problem:
714   //
715   // Residual R(u(p),p) = 0
716   // partial R / partial u = J = system matrix
717   //
718   // This implies that:
719   // d/dp(R) = 0
720   // (partial R / partial p) +
721   // (partial R / partial u) * (partial u / partial p) = 0
722 
723   // We first do an adjoint solve:
724   // J^T * z = (partial q / partial u)
725   // if we havent already or dont have an initial condition for the adjoint
726   if (!this->is_adjoint_already_solved())
727     {
728       this->adjoint_solve(qoi_indices);
729     }
730 
731   // Get ready to fill in senstivities:
732   sensitivities\&.allocate_data(qoi_indices, *this, parameters);
733 
734   // We use the identities:
735   // dq/dp = (partial q / partial p) + (partial q / partial u) *
736   //         (partial u / partial p)
737   // dq/dp = (partial q / partial p) + (J^T * z) *
738   //         (partial u / partial p)
739   // dq/dp = (partial q / partial p) + z * J *
740   //         (partial u / partial p)
741 
742   // Leading to our final formula:
743   // dq/dp = (partial q / partial p) - z * (partial R / partial p)
744 
745   // In the case of adjoints with heterogenous Dirichlet boundary
746   // function phi, where
747   // q := R(u,phi) + S(u)
748   // the final formula works out to:
749   // dq/dp = (partial S / partial p) - z * (partial R / partial p)
750   // Because we currently have no direct access to
751   // (partial S / partial p), we use the identity
752   // (partial S / partial p) = (partial q / partial p) -
753   //                           phi * (partial R / partial p)
754   // to derive an equivalent equation:
755   // dq/dp = (partial q / partial p) - (z+phi) * (partial R / partial p)
756 
757   for (unsigned int j=0; j != Np; ++j)
758     {
759       // (partial q / partial p) ~= (q(p+dp)-q(p-dp))/(2*dp)
760       // (partial R / partial p) ~= (rhs(p+dp) - rhs(p-dp))/(2*dp)
761 
762       Number old_parameter = *parameters[j];
763       // Number old_qoi = this->qoi;
764 
765       *parameters[j] = old_parameter - delta_p;
766       this->assemble_qoi(qoi_indices);
767       std::vector<Number> qoi_minus = this->qoi;
768 
769       this->assembly(true, false);
770       this->rhs->close();
771 
772       // FIXME - this can and should be optimized to avoid the clone()
773       AutoPtr<NumericVector<Number> > partialR_partialp = this->rhs->clone();
774       *partialR_partialp *= -1;
775 
776       *parameters[j] = old_parameter + delta_p;
777       this->assemble_qoi(qoi_indices);
778       std::vector<Number>& qoi_plus = this->qoi;
779 
780       std::vector<Number> partialq_partialp(Nq, 0);
781       for (unsigned int i=0; i != Nq; ++i)
782         if (qoi_indices\&.has_index(i))
783           partialq_partialp[i] = (qoi_plus[i] - qoi_minus[i]) / (2\&.*delta_p);
784 
785       this->assembly(true, false);
786       this->rhs->close();
787       *partialR_partialp += *this->rhs;
788       *partialR_partialp /= (2\&.*delta_p);
789 
790       // Don't leave the parameter changed
791       *parameters[j] = old_parameter;
792 
793       for (unsigned int i=0; i != Nq; ++i)
794         if (qoi_indices\&.has_index(i))
795           {
796 
797             if (this->get_dof_map()\&.has_adjoint_dirichlet_boundaries(i))
798               {
799                 AutoPtr<NumericVector<Number> > lift_func =
800                   this->get_adjoint_solution(i)\&.zero_clone();
801                 this->get_dof_map()\&.enforce_constraints_exactly
802                   (*this, lift_func\&.get(),
803                    /* homogeneous = */ false);
804                 sensitivities[i][j] = partialq_partialp[i] -
805                   partialR_partialp->dot(*lift_func) -
806                   partialR_partialp->dot(this->get_adjoint_solution(i));
807               }
808             else
809               sensitivities[i][j] = partialq_partialp[i] -
810                 partialR_partialp->dot(this->get_adjoint_solution(i));
811           }
812     }
813 
814   // All parameters have been reset\&.
815   // We didn't cache the original rhs or matrix for memory reasons,
816   // but we can restore them to a state consistent solution -
817   // principle of least surprise\&.
818   this->assembly(true, true);
819   this->rhs->close();
820   this->matrix->close();
821   this->assemble_qoi(qoi_indices);
822 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::ImplicitSystem::adjoint_solve (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system (dR/du)^T*z = dq/du, for those quantities of interest q specified by \fCqoi_indices\fP\&.
.PP
Leave \fCqoi_indices\fP empty to solve all adjoint problems\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Reimplemented in \fBlibMesh::DifferentiableSystem\fP\&.
.PP
Definition at line 382 of file implicit_system\&.C\&.
.PP
References libMesh::System::add_adjoint_solution(), libMesh::LinearSolver< T >::adjoint_solve(), libMesh::System::assemble_before_solve, libMesh::ExplicitSystem::assemble_qoi_derivative(), libMesh::ImplicitSystem::assembly(), libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::System::get_adjoint_rhs(), libMesh::System::get_adjoint_solution(), libMesh::System::get_dof_map(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::QoISet::has_index(), libMesh::ImplicitSystem::matrix, libMesh::System::qoi, libMesh::ImplicitSystem::release_linear_solver(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
Referenced by libMesh::DifferentiableSystem::adjoint_solve()\&.
.PP
.nf
383 {
384   // Log how long the linear solve takes\&.
385   START_LOG("adjoint_solve()", "ImplicitSystem");
386 
387   if (this->assemble_before_solve)
388     // Assemble the linear system
389     this->assembly (/* get_residual = */ false,
390                     /* get_jacobian = */ true);
391 
392   // The adjoint problem is linear
393   LinearSolver<Number> *linear_solver = this->get_linear_solver();
394 
395   // Reset and build the RHS from the QOI derivative
396   this->assemble_qoi_derivative(qoi_indices);
397 
398   // Our iteration counts and residuals will be sums of the individual
399   // results
400   std::pair<unsigned int, Real> solver_params =
401     this->get_linear_solve_parameters();
402   std::pair<unsigned int, Real> totalrval = std::make_pair(0,0\&.0);
403 
404   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
405     if (qoi_indices\&.has_index(i))
406       {
407         const std::pair<unsigned int, Real> rval =
408           linear_solver->adjoint_solve (*matrix, this->add_adjoint_solution(i),
409                                         this->get_adjoint_rhs(i),
410                                         solver_params\&.second,
411                                         solver_params\&.first);
412 
413         totalrval\&.first  += rval\&.first;
414         totalrval\&.second += rval\&.second;
415       }
416 
417   this->release_linear_solver(linear_solver);
418 
419   // The linear solver may not have fit our constraints exactly
420 #ifdef LIBMESH_ENABLE_CONSTRAINTS
421   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
422     if (qoi_indices\&.has_index(i))
423       this->get_dof_map()\&.enforce_adjoint_constraints_exactly
424         (this->get_adjoint_solution(i), i);
425 #endif
426 
427   // Stop logging the nonlinear solve
428   STOP_LOG("adjoint_solve()", "ImplicitSystem");
429 
430   return totalrval;
431 }
.fi
.SS "virtual void libMesh::TransientRBConstruction::allocate_data_structures ()\fC [protected]\fP, \fC [virtual]\fP"
Helper function that actually allocates all the data structures required by this class\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::LinearImplicitSystem::assemble ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Prepares \fCmatrix\fP and \fC_dof_map\fP for matrix assembly\&. Does not actually assemble anything\&. For matrix assembly, use the \fC\fBassemble()\fP\fP in derived classes\&. \fIShould\fP be overloaded in derived classes\&. 
.PP
Reimplemented from \fBlibMesh::ImplicitSystem\fP\&.
.PP
Reimplemented in \fBlibMesh::FrequencySystem\fP, and \fBlibMesh::NewmarkSystem\fP\&.
.PP
Definition at line 104 of file linear_implicit_system\&.h\&.
.PP
References libMesh::ImplicitSystem::assemble()\&.
.PP
Referenced by libMesh::NewmarkSystem::assemble(), libMesh::FrequencySystem::assemble(), libMesh::LinearImplicitSystem::assembly(), and libMesh::LinearImplicitSystem::solve()\&.
.PP
.nf
104 { ImplicitSystem::assemble(); }
.fi
.SS "virtual void libMesh::TransientRBConstruction::assemble_affine_expansion (boolskip_matrix_assembly, boolskip_vector_assembly)\fC [protected]\fP, \fC [virtual]\fP"
Override assemble_affine_expansion to also initialize RB_ic_proj_rhs_all_N, if necessary\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::TransientRBConstruction::assemble_all_affine_operators ()\fC [virtual]\fP"
Assemble and store all the affine operators\&. Overload to assemble the mass matrix operators\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::RBConstruction::assemble_all_affine_vectors ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Assemble and store the affine RHS vectors\&. 
.SS "virtual void libMesh::RBConstruction::assemble_all_output_vectors ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Assemble and store the output vectors\&. 
.SS "void libMesh::RBConstruction::assemble_and_add_constraint_matrix (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)\fC [inherited]\fP"
Assemble the constraint matrix and add it to input_matrix\&. 
.SS "void libMesh::RBConstruction::assemble_Aq_matrix (unsigned intq, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, boolapply_dof_constraints = \fCtrue\fP)\fC [inherited]\fP"
Assemble the q^th affine matrix and store it in input_matrix\&. 
.SS "void libMesh::RBConstruction::assemble_constraint_matrix (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)\fC [inherited]\fP"
Assemble the constraint matrix and store it in input_matrix\&. 
.SS "void libMesh::RBConstruction::assemble_Fq_vector (unsigned intq, \fBNumericVector\fP< \fBNumber\fP > *input_vector, boolapply_dof_constraints = \fCtrue\fP)\fC [inherited]\fP"
Assemble the q^th affine vector and store it in input_matrix\&. 
.SS "void libMesh::RBConstruction::assemble_inner_product_matrix (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, boolapply_dof_constraints = \fCtrue\fP)\fC [inherited]\fP"
Assemble the inner product matrix and store it in input_matrix\&. 
.SS "void libMesh::TransientRBConstruction::assemble_L2_matrix (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, boolapply_dirichlet_bc = \fCtrue\fP)"
Assemble the L2 matrix\&. 
.SS "void libMesh::TransientRBConstruction::assemble_mass_matrix (\fBSparseMatrix\fP< \fBNumber\fP > *input_matrix)"
Assemble the mass matrix at the current parameter and store it in input_matrix\&. 
.SS "virtual void libMesh::TransientRBConstruction::assemble_matrix_for_output_dual_solves ()\fC [protected]\fP, \fC [virtual]\fP"
Override to use the L2 product matrix for output dual norm solves for transient state problems\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::TransientRBConstruction::assemble_misc_matrices ()\fC [virtual]\fP"
Override to assemble the L2 matrix as well\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::TransientRBConstruction::assemble_Mq_matrix (unsigned intq, \fBSparseMatrix\fP< \fBNumber\fP > *input_matrix, boolapply_dirichlet_bc = \fCtrue\fP)"
Assemble the q^th affine term of the mass matrix and store it in input_matrix\&. 
.SS "void libMesh::ExplicitSystem::assemble_qoi (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Prepares \fCqoi\fP for quantity of interest assembly, then calls user qoi function\&. \fICan\fP be overloaded in derived classes\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Reimplemented in \fBlibMesh::FEMSystem\fP\&.
.PP
Definition at line 89 of file explicit_system\&.C\&.
.PP
References libMesh::System::assemble_qoi(), libMesh::QoISet::has_index(), and libMesh::System::qoi\&.
.PP
.nf
90 {
91   // The user quantity of interest assembly gets to expect to
92   // accumulate on initially zero values
93   for (unsigned int i=0; i != qoi\&.size(); ++i)
94     if (qoi_indices\&.has_index(i))
95       qoi[i] = 0;
96 
97   Parent::assemble_qoi (qoi_indices);
98 }
.fi
.SS "void libMesh::ExplicitSystem::assemble_qoi_derivative (const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Prepares \fCadjoint_rhs\fP for quantity of interest derivative assembly, then calls user qoi derivative function\&. \fICan\fP be overloaded in derived classes\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Reimplemented in \fBlibMesh::FEMSystem\fP\&.
.PP
Definition at line 102 of file explicit_system\&.C\&.
.PP
References libMesh::System::add_adjoint_rhs(), libMesh::System::assemble_qoi_derivative(), libMesh::QoISet::has_index(), libMesh::System::qoi, and libMesh::NumericVector< T >::zero()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
103 {
104   // The user quantity of interest derivative assembly gets to expect
105   // to accumulate on initially zero vectors
106   for (unsigned int i=0; i != qoi\&.size(); ++i)
107     if (qoi_indices\&.has_index(i))
108       this->add_adjoint_rhs(i)\&.zero();
109 
110   Parent::assemble_qoi_derivative (qoi_indices);
111 }
.fi
.SS "void libMesh::ImplicitSystem::assemble_residual_derivatives (const \fBParameterVector\fP &parameters)\fC [virtual]\fP, \fC [inherited]\fP"
Residual parameter derivative function\&.
.PP
Uses finite differences by default\&.
.PP
This will assemble the sensitivity rhs vectors to hold -(partial R / partial p_i), making them ready to solve the forward sensitivity equation\&.
.PP
\fICan\fP be overloaded in derived classes\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 665 of file implicit_system\&.C\&.
.PP
References libMesh::System::add_sensitivity_rhs(), libMesh::ImplicitSystem::assembly(), libMesh::NumericVector< T >::close(), libMesh::Real, libMesh::ExplicitSystem::rhs, libMesh::ParameterVector::size(), and libMesh::TOLERANCE\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
666 {
667   const unsigned int Np = libmesh_cast_int<unsigned int>
668     (parameters\&.size());
669   Real deltap = TOLERANCE;
670 
671   for (unsigned int p=0; p != Np; ++p)
672     {
673       NumericVector<Number> &sensitivity_rhs = this->add_sensitivity_rhs(p);
674 
675       // Approximate -(partial R / partial p) by
676       // (R(p-dp) - R(p+dp)) / (2*dp)
677 
678       Number old_parameter = *parameters[p];
679       *parameters[p] -= deltap;
680 
681       this->assembly(true, false);
682       this->rhs->close();
683       sensitivity_rhs = *this->rhs;
684 
685       *parameters[p] = old_parameter + deltap;
686 
687       this->assembly(true, false);
688       this->rhs->close();
689 
690       sensitivity_rhs -= *this->rhs;
691       sensitivity_rhs /= (2*deltap);
692       sensitivity_rhs\&.close();
693 
694       *parameters[p] = old_parameter;
695     }
696 }
.fi
.SS "void libMesh::LinearImplicitSystem::assembly (boolget_residual, boolget_jacobian)\fC [virtual]\fP, \fC [inherited]\fP"
Assembles a residual in \fCrhs\fP and/or a jacobian in \fCmatrix\fP, as requested\&. 
.PP
Reimplemented from \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 379 of file linear_implicit_system\&.C\&.
.PP
References libMesh::NumericVector< T >::add_vector(), libMesh::LinearImplicitSystem::assemble(), libMesh::NumericVector< T >::close(), libMesh::SparseMatrix< T >::close(), libMesh::ImplicitSystem::matrix, libMesh::ExplicitSystem::rhs, and libMesh::System::solution\&.
.PP
.nf
381 {
382   // Residual R(u(p),p) := A(p)*u(p) - b(p)
383   // partial R / partial u = A
384 
385   this->assemble();
386   this->rhs->close();
387   this->matrix->close();
388 
389   *(this->rhs) *= -1\&.0;
390   this->rhs->add_vector(*this->solution, *this->matrix);
391 }
.fi
.SS "void libMesh::System::attach_assemble_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function to use in assembling the system matrix and RHS\&. 
.PP
Definition at line 1754 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1756 {
1757   libmesh_assert(fptr);
1758 
1759   if (_assemble_system_object != NULL)
1760     {
1761       libmesh_here();
1762       libMesh::out << "WARNING:  Cannot specify both assembly function and object!"
1763                    << std::endl;
1764 
1765       _assemble_system_object = NULL;
1766     }
1767 
1768   _assemble_system_function = fptr;
1769 }
.fi
.SS "void libMesh::System::attach_assemble_object (\fBSystem::Assembly\fP &assemble_in)\fC [inherited]\fP"
Register a user object to use in assembling the system matrix and RHS\&. 
.PP
Definition at line 1773 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, and libMesh::out\&.
.PP
.nf
1774 {
1775   if (_assemble_system_function != NULL)
1776     {
1777       libmesh_here();
1778       libMesh::out << "WARNING:  Cannot specify both assembly object and function!"
1779                    << std::endl;
1780 
1781       _assemble_system_function = NULL;
1782     }
1783 
1784   _assemble_system_object = &assemble_in;
1785 }
.fi
.SS "void libMesh::System::attach_constraint_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function for imposing constraints\&. 
.PP
Definition at line 1789 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1791 {
1792   libmesh_assert(fptr);
1793 
1794   if (_constrain_system_object != NULL)
1795     {
1796       libmesh_here();
1797       libMesh::out << "WARNING:  Cannot specify both constraint function and object!"
1798                    << std::endl;
1799 
1800       _constrain_system_object = NULL;
1801     }
1802 
1803   _constrain_system_function = fptr;
1804 }
.fi
.SS "void libMesh::System::attach_constraint_object (\fBSystem::Constraint\fP &constrain)\fC [inherited]\fP"
Register a user object for imposing constraints\&. 
.PP
Definition at line 1808 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, and libMesh::out\&.
.PP
.nf
1809 {
1810   if (_constrain_system_function != NULL)
1811     {
1812       libmesh_here();
1813       libMesh::out << "WARNING:  Cannot specify both constraint object and function!"
1814                    << std::endl;
1815 
1816       _constrain_system_function = NULL;
1817     }
1818 
1819   _constrain_system_object = &constrain;
1820 }
.fi
.SS "void libMesh::System::attach_init_function (void fptrEquationSystems &es,const std::string &name)\fC [inherited]\fP"
Register a user function to use in initializing the system\&. 
.PP
Definition at line 1719 of file system\&.C\&.
.PP
References libMesh::System::_init_system_function, libMesh::System::_init_system_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1721 {
1722   libmesh_assert(fptr);
1723 
1724   if (_init_system_object != NULL)
1725     {
1726       libmesh_here();
1727       libMesh::out << "WARNING:  Cannot specify both initialization function and object!"
1728                    << std::endl;
1729 
1730       _init_system_object = NULL;
1731     }
1732 
1733   _init_system_function = fptr;
1734 }
.fi
.SS "void libMesh::System::attach_init_object (\fBSystem::Initialization\fP &init_in)\fC [inherited]\fP"
Register a user class to use to initialize the system\&. Note this is exclusive with the \fCattach_init_function\fP\&. 
.PP
Definition at line 1738 of file system\&.C\&.
.PP
References libMesh::System::_init_system_function, libMesh::System::_init_system_object, and libMesh::out\&.
.PP
.nf
1739 {
1740   if (_init_system_function != NULL)
1741     {
1742       libmesh_here();
1743       libMesh::out << "WARNING:  Cannot specify both initialization object and function!"
1744                    << std::endl;
1745 
1746       _init_system_function = NULL;
1747     }
1748 
1749   _init_system_object = &init_in;
1750 }
.fi
.SS "void libMesh::System::attach_QOI_derivative (void fptrEquationSystems &es,const std::string &name,const QoISet &qoi_indices)\fC [inherited]\fP"
Register a user function for evaluating derivatives of a quantity of interest with respect to test functions, whose values should be placed in \fCSystem::rhs\fP 
.PP
Definition at line 1860 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1863 {
1864   libmesh_assert(fptr);
1865 
1866   if (_qoi_evaluate_derivative_object != NULL)
1867     {
1868       libmesh_here();
1869       libMesh::out << "WARNING:  Cannot specify both QOI derivative function and object!"
1870                    << std::endl;
1871 
1872       _qoi_evaluate_derivative_object = NULL;
1873     }
1874 
1875   _qoi_evaluate_derivative_function = fptr;
1876 }
.fi
.SS "void libMesh::System::attach_QOI_derivative_object (\fBQOIDerivative\fP &qoi_derivative)\fC [inherited]\fP"
Register a user object for evaluating derivatives of a quantity of interest with respect to test functions, whose values should be placed in \fCSystem::rhs\fP 
.PP
Definition at line 1880 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, and libMesh::out\&.
.PP
.nf
1881 {
1882   if (_qoi_evaluate_derivative_function != NULL)
1883     {
1884       libmesh_here();
1885       libMesh::out << "WARNING:  Cannot specify both QOI derivative object and function!"
1886                    << std::endl;
1887 
1888       _qoi_evaluate_derivative_function = NULL;
1889     }
1890 
1891   _qoi_evaluate_derivative_object = &qoi_derivative;
1892 }
.fi
.SS "void libMesh::System::attach_QOI_function (void fptrEquationSystems &es,const std::string &name,const QoISet &qoi_indices)\fC [inherited]\fP"
Register a user function for evaluating the quantities of interest, whose values should be placed in \fC\fBSystem::qoi\fP\fP 
.PP
Definition at line 1824 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, libMesh::libmesh_assert(), and libMesh::out\&.
.PP
.nf
1827 {
1828   libmesh_assert(fptr);
1829 
1830   if (_qoi_evaluate_object != NULL)
1831     {
1832       libmesh_here();
1833       libMesh::out << "WARNING:  Cannot specify both QOI function and object!"
1834                    << std::endl;
1835 
1836       _qoi_evaluate_object = NULL;
1837     }
1838 
1839   _qoi_evaluate_function = fptr;
1840 }
.fi
.SS "void libMesh::System::attach_QOI_object (\fBQOI\fP &qoi)\fC [inherited]\fP"
Register a user object for evaluating the quantities of interest, whose values should be placed in \fC\fBSystem::qoi\fP\fP 
.PP
Definition at line 1844 of file system\&.C\&.
.PP
References libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, and libMesh::out\&.
.PP
.nf
1845 {
1846   if (_qoi_evaluate_function != NULL)
1847     {
1848       libmesh_here();
1849       libMesh::out << "WARNING:  Cannot specify both QOI object and function!"
1850                    << std::endl;
1851 
1852       _qoi_evaluate_function = NULL;
1853     }
1854 
1855   _qoi_evaluate_object = &qoi_in;
1856 }
.fi
.SS "void libMesh::LinearImplicitSystem::attach_shell_matrix (\fBShellMatrix\fP< \fBNumber\fP > *shell_matrix)\fC [inherited]\fP"
This function enables the user to provide a shell matrix, i\&.e\&. a matrix that is not stored element-wise, but as a function\&. When you register your shell matrix using this function, calling \fC\fBsolve()\fP\fP will no longer use the \fCmatrix\fP member but the registered shell matrix instead\&. You can reset this behaviour to its original state by supplying a \fCNULL\fP pointer to this function\&. 
.PP
Definition at line 171 of file linear_implicit_system\&.C\&.
.PP
References libMesh::LinearImplicitSystem::_shell_matrix\&.
.PP
Referenced by libMesh::LinearImplicitSystem::detach_shell_matrix()\&.
.PP
.nf
172 {
173   _shell_matrix = shell_matrix;
174 }
.fi
.SS "void libMesh::System::boundary_project_solution (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP)\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitary boundary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 665 of file system_projection\&.C\&.
.PP
.nf
669 {
670   this->boundary_project_vector(b, variables, *solution, f, g);
671 
672   solution->localize(*current_local_solution);
673 }
.fi
.SS "void libMesh::System::boundary_project_solution (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters)\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects components of an arbitrary boundary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 641 of file system_projection\&.C\&.
.PP
.nf
652 {
653   WrappedFunction<Number> f(*this, fptr, &parameters);
654   WrappedFunction<Gradient> g(*this, gptr, &parameters);
655   this->boundary_project_solution(b, variables, &f, &g);
656 }
.fi
.SS "void libMesh::System::boundary_project_vector (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 707 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::get_dof_map(), libMesh::Threads::parallel_for(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
712 {
713   START_LOG ("boundary_project_vector()", "System");
714 
715   Threads::parallel_for
716     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
717                      this->get_mesh()\&.active_local_elements_end() ),
718      BoundaryProjectSolution(b, variables, *this, f, g,
719                              this->get_equation_systems()\&.parameters,
720                              new_vector)
721      );
722 
723   // We don't do SCALAR dofs when just projecting the boundary, so
724   // we're done here\&.
725 
726   new_vector\&.close();
727 
728 #ifdef LIBMESH_ENABLE_CONSTRAINTS
729   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
730 #endif
731 
732   STOP_LOG("boundary_project_vector()", "System");
733 }
.fi
.SS "void libMesh::System::boundary_project_vector (const std::set< \fBboundary_id_type\fP > &b, const std::vector< unsigned int > &variables, \fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const\fC [inherited]\fP"
Projects arbitrary boundary functions onto a vector of degree of freedom values for the current system\&. Only degrees of freedom which affect the function's trace on a boundary in the set \fCb\fP are affected\&. Only degrees of freedom associated with the variables listed in the vector \fCvariables\fP are projected\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary boundary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 684 of file system_projection\&.C\&.
.PP
.nf
696 {
697   WrappedFunction<Number> f(*this, fptr, &parameters);
698   WrappedFunction<Gradient> g(*this, gptr, &parameters);
699   this->boundary_project_vector(b, variables, new_vector, &f, &g);
700 }
.fi
.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::broadcast_parameters (unsigned intproc_id)\fC [inherited]\fP"
Broadcasts parameters on processor proc_id to all processors\&. 
.SS "virtual \fBAutoPtr\fP<\fBDGFEMContext\fP> libMesh::RBConstruction::build_context ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Builds a \fBDGFEMContext\fP object with enough information to do evaluations on each element\&. We use \fBDGFEMContext\fP since it allows for both DG and continuous Galerkin formulations\&. 
.SS "static \fBAutoPtr\fP<\fBDirichletBoundary\fP> libMesh::RBConstruction::build_zero_dirichlet_boundary_object ()\fC [static]\fP, \fC [inherited]\fP"
It's helpful to be able to generate a \fBDirichletBoundary\fP that stores a \fBZeroFunction\fP in order to impose Dirichlet boundary conditions\&. 
.SS "\fBReal\fP libMesh::System::calculate_norm (const \fBNumericVector\fP< \fBNumber\fP > &v, unsigned intvar, \fBFEMNormType\fPnorm_type) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a norm of variable \fCvar\fP in the vector \fCv\fP, in the specified norm (e\&.g\&. L2, L_INF, H1) 
.RE
.PP

.PP
Definition at line 1380 of file system\&.C\&.
.PP
References libMesh::DISCRETE_L1, libMesh::DISCRETE_L2, libMesh::DISCRETE_L_INF, libMesh::System::discrete_var_norm(), libMesh::L2, libMesh::System::n_vars(), and libMesh::Real\&.
.PP
Referenced by libMesh::AdaptiveTimeSolver::calculate_norm(), and libMesh::UnsteadySolver::du()\&.
.PP
.nf
1383 {
1384   //short circuit to save time
1385   if(norm_type == DISCRETE_L1 ||
1386      norm_type == DISCRETE_L2 ||
1387      norm_type == DISCRETE_L_INF)
1388     return discrete_var_norm(v,var,norm_type);
1389 
1390   // Not a discrete norm
1391   std::vector<FEMNormType> norms(this->n_vars(), L2);
1392   std::vector<Real> weights(this->n_vars(), 0\&.0);
1393   norms[var] = norm_type;
1394   weights[var] = 1\&.0;
1395   Real val = this->calculate_norm(v, SystemNorm(norms, weights));
1396   return val;
1397 }
.fi
.SS "\fBReal\fP libMesh::System::calculate_norm (const \fBNumericVector\fP< \fBNumber\fP > &v, const \fBSystemNorm\fP &norm) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a norm of the vector \fCv\fP, using \fCcomponent_norm\fP and \fCcomponent_scale\fP to choose and weight the norms of each variable\&. 
.RE
.PP

.PP
Definition at line 1401 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, std::abs(), libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::TypeVector< T >::add_scaled(), libMesh::TypeTensor< T >::add_scaled(), libMesh::NumericVector< T >::build(), libMesh::FEGenericBase< T >::build(), libMesh::ParallelObject::comm(), libMesh::FEType::default_quadrature_rule(), libMesh::dim, libMesh::DISCRETE_L1, libMesh::DISCRETE_L2, libMesh::DISCRETE_L_INF, libMesh::System::discrete_var_norm(), libMesh::DofMap::dof_indices(), libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::H1, libMesh::H1_SEMINORM, libMesh::H2, libMesh::H2_SEMINORM, libMesh::SystemNorm::is_discrete(), libMesh::L1, libMesh::NumericVector< T >::l1_norm(), libMesh::L2, libMesh::NumericVector< T >::l2_norm(), libMesh::L_INF, libMesh::NumericVector< T >::linfty_norm(), libMesh::NumericVector< T >::localize(), std::max(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::System::n_vars(), libMesh::TensorTools::norm_sq(), libMesh::Real, libMesh::SERIAL, libMesh::TypeVector< T >::size(), libMesh::TypeTensor< T >::size(), libMesh::NumericVector< T >::size(), libMesh::TypeVector< T >::size_sq(), libMesh::TypeTensor< T >::size_sq(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Parallel::Communicator::sum(), libMesh::SystemNorm::type(), libMesh::DofMap::variable_type(), libMesh::W1_INF_SEMINORM, libMesh::W2_INF_SEMINORM, libMesh::SystemNorm::weight(), and libMesh::SystemNorm::weight_sq()\&.
.PP
.nf
1403 {
1404   // This function must be run on all processors at once
1405   parallel_object_only();
1406 
1407   START_LOG ("calculate_norm()", "System");
1408 
1409   // Zero the norm before summation
1410   Real v_norm = 0\&.;
1411 
1412   if (norm\&.is_discrete())
1413     {
1414       STOP_LOG ("calculate_norm()", "System");
1415       //Check to see if all weights are 1\&.0 and all types are equal
1416       FEMNormType norm_type0 = norm\&.type(0);
1417       unsigned int check_var = 0;
1418       for (; check_var != this->n_vars(); ++check_var)
1419         if((norm\&.weight(check_var) != 1\&.0) || (norm\&.type(check_var) != norm_type0))
1420           break;
1421 
1422       //All weights were 1\&.0 so just do the full vector discrete norm
1423       if(check_var == this->n_vars())
1424         {
1425           if(norm_type0 == DISCRETE_L1)
1426             return v\&.l1_norm();
1427           if(norm_type0 == DISCRETE_L2)
1428             return v\&.l2_norm();
1429           if(norm_type0 == DISCRETE_L_INF)
1430             return v\&.linfty_norm();
1431           else
1432             libmesh_error();
1433         }
1434 
1435       for (unsigned int var=0; var != this->n_vars(); ++var)
1436         {
1437           // Skip any variables we don't need to integrate
1438           if (norm\&.weight(var) == 0\&.0)
1439             continue;
1440 
1441           v_norm += norm\&.weight(var) * discrete_var_norm(v, var, norm\&.type(var));
1442         }
1443 
1444       return v_norm;
1445     }
1446 
1447   // Localize the potentially parallel vector
1448   AutoPtr<NumericVector<Number> > local_v = NumericVector<Number>::build(this->comm());
1449   local_v->init(v\&.size(), true, SERIAL);
1450   v\&.localize (*local_v, _dof_map->get_send_list());
1451 
1452   unsigned int dim = this->get_mesh()\&.mesh_dimension();
1453 
1454   // I'm not sure how best to mix Hilbert norms on some variables (for
1455   // which we'll want to square then sum then square root) with norms
1456   // like L_inf (for which we'll just want to take an absolute value
1457   // and then sum)\&.
1458   bool using_hilbert_norm = true,
1459     using_nonhilbert_norm = true;
1460 
1461   // Loop over all variables
1462   for (unsigned int var=0; var != this->n_vars(); ++var)
1463     {
1464       // Skip any variables we don't need to integrate
1465       Real norm_weight_sq = norm\&.weight_sq(var);
1466       if (norm_weight_sq == 0\&.0)
1467         continue;
1468       Real norm_weight = norm\&.weight(var);
1469 
1470       // Check for unimplemented norms (rather than just returning 0)\&.
1471       FEMNormType norm_type = norm\&.type(var);
1472       if((norm_type==H1) ||
1473          (norm_type==H2) ||
1474          (norm_type==L2) ||
1475          (norm_type==H1_SEMINORM) ||
1476          (norm_type==H2_SEMINORM))
1477         {
1478           if (!using_hilbert_norm)
1479             libmesh_not_implemented();
1480           using_nonhilbert_norm = false;
1481         }
1482       else if ((norm_type==L1) ||
1483                (norm_type==L_INF) ||
1484                (norm_type==W1_INF_SEMINORM) ||
1485                (norm_type==W2_INF_SEMINORM))
1486         {
1487           if (!using_nonhilbert_norm)
1488             libmesh_not_implemented();
1489           using_hilbert_norm = false;
1490         }
1491       else
1492         libmesh_not_implemented();
1493 
1494       const FEType& fe_type = this->get_dof_map()\&.variable_type(var);
1495       AutoPtr<QBase> qrule =
1496         fe_type\&.default_quadrature_rule (dim);
1497       AutoPtr<FEBase> fe
1498         (FEBase::build(dim, fe_type));
1499       fe->attach_quadrature_rule (qrule\&.get());
1500 
1501       const std::vector<Real>&               JxW = fe->get_JxW();
1502       const std::vector<std::vector<Real> >* phi = NULL;
1503       if (norm_type == H1 ||
1504           norm_type == H2 ||
1505           norm_type == L2 ||
1506           norm_type == L1 ||
1507           norm_type == L_INF)
1508         phi = &(fe->get_phi());
1509 
1510       const std::vector<std::vector<RealGradient> >* dphi = NULL;
1511       if (norm_type == H1 ||
1512           norm_type == H2 ||
1513           norm_type == H1_SEMINORM ||
1514           norm_type == W1_INF_SEMINORM)
1515         dphi = &(fe->get_dphi());
1516 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
1517       const std::vector<std::vector<RealTensor> >*   d2phi = NULL;
1518       if (norm_type == H2 ||
1519           norm_type == H2_SEMINORM ||
1520           norm_type == W2_INF_SEMINORM)
1521         d2phi = &(fe->get_d2phi());
1522 #endif
1523 
1524       std::vector<dof_id_type> dof_indices;
1525 
1526       // Begin the loop over the elements
1527       MeshBase::const_element_iterator       el     =
1528         this->get_mesh()\&.active_local_elements_begin();
1529       const MeshBase::const_element_iterator end_el =
1530         this->get_mesh()\&.active_local_elements_end();
1531 
1532       for ( ; el != end_el; ++el)
1533         {
1534           const Elem* elem = *el;
1535 
1536           fe->reinit (elem);
1537 
1538           this->get_dof_map()\&.dof_indices (elem, dof_indices, var);
1539 
1540           const unsigned int n_qp = qrule->n_points();
1541 
1542           const unsigned int n_sf = libmesh_cast_int<unsigned int>
1543             (dof_indices\&.size());
1544 
1545           // Begin the loop over the Quadrature points\&.
1546           for (unsigned int qp=0; qp<n_qp; qp++)
1547             {
1548               if (norm_type == L1)
1549                 {
1550                   Number u_h = 0\&.;
1551                   for (unsigned int i=0; i != n_sf; ++i)
1552                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1553                   v_norm += norm_weight *
1554                     JxW[qp] * std::abs(u_h);
1555                 }
1556 
1557               if (norm_type == L_INF)
1558                 {
1559                   Number u_h = 0\&.;
1560                   for (unsigned int i=0; i != n_sf; ++i)
1561                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1562                   v_norm = std::max(v_norm, norm_weight * std::abs(u_h));
1563                 }
1564 
1565               if (norm_type == H1 ||
1566                   norm_type == H2 ||
1567                   norm_type == L2)
1568                 {
1569                   Number u_h = 0\&.;
1570                   for (unsigned int i=0; i != n_sf; ++i)
1571                     u_h += (*phi)[i][qp] * (*local_v)(dof_indices[i]);
1572                   v_norm += norm_weight_sq *
1573                     JxW[qp] * TensorTools::norm_sq(u_h);
1574                 }
1575 
1576               if (norm_type == H1 ||
1577                   norm_type == H2 ||
1578                   norm_type == H1_SEMINORM)
1579                 {
1580                   Gradient grad_u_h;
1581                   for (unsigned int i=0; i != n_sf; ++i)
1582                     grad_u_h\&.add_scaled((*dphi)[i][qp], (*local_v)(dof_indices[i]));
1583                   v_norm += norm_weight_sq *
1584                     JxW[qp] * grad_u_h\&.size_sq();
1585                 }
1586 
1587               if (norm_type == W1_INF_SEMINORM)
1588                 {
1589                   Gradient grad_u_h;
1590                   for (unsigned int i=0; i != n_sf; ++i)
1591                     grad_u_h\&.add_scaled((*dphi)[i][qp], (*local_v)(dof_indices[i]));
1592                   v_norm = std::max(v_norm, norm_weight * grad_u_h\&.size());
1593                 }
1594 
1595 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
1596               if (norm_type == H2 ||
1597                   norm_type == H2_SEMINORM)
1598                 {
1599                   Tensor hess_u_h;
1600                   for (unsigned int i=0; i != n_sf; ++i)
1601                     hess_u_h\&.add_scaled((*d2phi)[i][qp], (*local_v)(dof_indices[i]));
1602                   v_norm += norm_weight_sq *
1603                     JxW[qp] * hess_u_h\&.size_sq();
1604                 }
1605 
1606               if (norm_type == W2_INF_SEMINORM)
1607                 {
1608                   Tensor hess_u_h;
1609                   for (unsigned int i=0; i != n_sf; ++i)
1610                     hess_u_h\&.add_scaled((*d2phi)[i][qp], (*local_v)(dof_indices[i]));
1611                   v_norm = std::max(v_norm, norm_weight * hess_u_h\&.size());
1612                 }
1613 #endif
1614             }
1615         }
1616     }
1617 
1618   if (using_hilbert_norm)
1619     {
1620       this->comm()\&.sum(v_norm);
1621       v_norm = std::sqrt(v_norm);
1622     }
1623   else
1624     {
1625       this->comm()\&.max(v_norm);
1626     }
1627 
1628   STOP_LOG ("calculate_norm()", "System");
1629 
1630   return v_norm;
1631 }
.fi
.SS "void libMesh::RBConstruction::check_convergence ()\fC [protected]\fP, \fC [inherited]\fP"
Check if the linear solver reports convergence\&. libmesh_error() is called when that is not the case\&. 
.SS "virtual void libMesh::TransientRBConstruction::clear ()\fC [virtual]\fP"
Clear all the data structures associated with the system\&. 
.PP
Reimplemented from \fBlibMesh::TransientSystem< RBConstruction >\fP\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "bool libMesh::System::compare (const \fBSystem\fP &other_system, const \fBReal\fPthreshold, const boolverbose) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the other system contains identical data, up to the given threshold\&. Outputs some diagnostic info when \fCverbose\fP is set\&. 
.RE
.PP

.PP
Definition at line 526 of file system\&.C\&.
.PP
References libMesh::System::_can_add_vectors, libMesh::System::_sys_name, libMesh::System::_vectors, libMesh::System::get_vector(), libMesh::libmesh_assert(), libMesh::System::n_vectors(), libMesh::System::name(), libMesh::out, and libMesh::System::solution\&.
.PP
Referenced by libMesh::EquationSystems::compare()\&.
.PP
.nf
529 {
530   // we do not care for matrices, but for vectors
531   libmesh_assert (!_can_add_vectors);
532   libmesh_assert (!other_system\&._can_add_vectors);
533 
534   if (verbose)
535     {
536       libMesh::out << "  Systems \"" << _sys_name << "\"" << std::endl;
537       libMesh::out << "   comparing matrices not supported\&." << std::endl;
538       libMesh::out << "   comparing names\&.\&.\&.";
539     }
540 
541   // compare the name: 0 means identical
542   const int name_result = _sys_name\&.compare(other_system\&.name());
543   if (verbose)
544     {
545       if (name_result == 0)
546         libMesh::out << " identical\&." << std::endl;
547       else
548         libMesh::out << "  names not identical\&." << std::endl;
549       libMesh::out << "   comparing solution vector\&.\&.\&.";
550     }
551 
552 
553   // compare the solution: -1 means identical
554   const int solu_result = solution->compare (*other_system\&.solution\&.get(),
555                                              threshold);
556 
557   if (verbose)
558     {
559       if (solu_result == -1)
560         libMesh::out << " identical up to threshold\&." << std::endl;
561       else
562         libMesh::out << "  first difference occured at index = "
563                      << solu_result << "\&." << std::endl;
564     }
565 
566 
567   // safety check, whether we handle at least the same number
568   // of vectors
569   std::vector<int> ov_result;
570 
571   if (this->n_vectors() != other_system\&.n_vectors())
572     {
573       if (verbose)
574         {
575           libMesh::out << "   Fatal difference\&. This system handles "
576                        << this->n_vectors() << " add'l vectors," << std::endl
577                        << "   while the other system handles "
578                        << other_system\&.n_vectors()
579                        << " add'l vectors\&." << std::endl
580                        << "   Aborting comparison\&." << std::endl;
581         }
582       return false;
583     }
584   else if (this->n_vectors() == 0)
585     {
586       // there are no additional vectors\&.\&.\&.
587       ov_result\&.clear ();
588     }
589   else
590     {
591       // compare other vectors
592       for (const_vectors_iterator pos = _vectors\&.begin();
593            pos != _vectors\&.end(); ++pos)
594         {
595           if (verbose)
596             libMesh::out << "   comparing vector \""
597                          << pos->first << "\" \&.\&.\&.";
598 
599           // assume they have the same name
600           const NumericVector<Number>& other_system_vector =
601             other_system\&.get_vector(pos->first);
602 
603           ov_result\&.push_back(pos->second->compare (other_system_vector,
604                                                     threshold));
605 
606           if (verbose)
607             {
608               if (ov_result[ov_result\&.size()-1] == -1)
609                 libMesh::out << " identical up to threshold\&." << std::endl;
610               else
611                 libMesh::out << " first difference occured at" << std::endl
612                              << "   index = " << ov_result[ov_result\&.size()-1] << "\&." << std::endl;
613             }
614 
615         }
616 
617     } // finished comparing additional vectors
618 
619 
620   bool overall_result;
621 
622   // sum up the results
623   if ((name_result==0) && (solu_result==-1))
624     {
625       if (ov_result\&.size()==0)
626         overall_result = true;
627       else
628         {
629           bool ov_identical;
630           unsigned int n    = 0;
631           do
632             {
633               ov_identical = (ov_result[n]==-1);
634               n++;
635             }
636           while (ov_identical && n<ov_result\&.size());
637           overall_result = ov_identical;
638         }
639     }
640   else
641     overall_result = false;
642 
643   if (verbose)
644     {
645       libMesh::out << "   finished comparisons, ";
646       if (overall_result)
647         libMesh::out << "found no differences\&." << std::endl << std::endl;
648       else
649         libMesh::out << "found differences\&." << std::endl << std::endl;
650     }
651 
652   return overall_result;
653 }
.fi
.SS "virtual void libMesh::RBConstruction::compute_Fq_representor_innerprods (boolcompute_inner_products = \fCtrue\fP)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Compute the terms that are combined `online' to determine the dual norm of the residual\&. Here we compute the terms associated with the right-hand side\&. These terms are basis independent, hence we separate them from the rest of the calculations that are done in update_residual_terms\&. By default, inner product terms are also computed, but you can turn this feature off e\&.g\&. if you are already reading in that data from files\&. 
.SS "virtual \fBReal\fP libMesh::RBConstruction::compute_max_error_bound ()\fC [virtual]\fP, \fC [inherited]\fP"
(i) Compute the a posteriori error bound for each set of parameters in the training set, (ii) set current_parameters to the parameters that maximize the error bound, and (iii) return the maximum error bound\&. 
.SS "virtual void libMesh::RBConstruction::compute_output_dual_innerprods ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Compute and store the dual norm of each output functional\&. 
.SS "\fBNumber\fP libMesh::System::current_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the current solution for the specified global DOF\&. 
.RE
.PP

.PP
Definition at line 184 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, and libMesh::System::current_local_solution\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::for(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::HPCoarsenTest::select_refinement(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
185 {
186   // Check the sizes
187   libmesh_assert_less (global_dof_number, _dof_map->n_dofs());
188   libmesh_assert_less (global_dof_number, current_local_solution->size());
189 
190   return (*current_local_solution)(global_dof_number);
191 }
.fi
.SS "void libMesh::System::deactivate ()\fC [inline]\fP, \fC [inherited]\fP"
Deactivates the system\&. Only active systems are solved\&. 
.PP
Definition at line 1935 of file system\&.h\&.
.PP
References libMesh::System::_active\&.
.PP
.nf
1936 {
1937   _active = false;
1938 }
.fi
.SS "void libMesh::LinearImplicitSystem::detach_shell_matrix (void)\fC [inline]\fP, \fC [inherited]\fP"
Detaches a shell matrix\&. Same as \fCattach_shell_matrix(NULL)\fP\&. 
.PP
Definition at line 176 of file linear_implicit_system\&.h\&.
.PP
References libMesh::LinearImplicitSystem::attach_shell_matrix()\&.
.PP
.nf
176 { attach_shell_matrix(NULL); }
.fi
.SS "void libMesh::ImplicitSystem::disable_cache ()\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system Ax=b\&. Avoids use of any cached data that might affect any solve result\&. Should be overloaded in derived systems\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 313 of file implicit_system\&.C\&.
.PP
References libMesh::System::assemble_before_solve, libMesh::ImplicitSystem::get_linear_solver(), and libMesh::LinearSolver< T >::reuse_preconditioner()\&.
.PP
.nf
313                                     {
314   this->assemble_before_solve = true;
315   this->get_linear_solver()->reuse_preconditioner(false);
316 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual void libMesh::TransientRBConstruction::enrich_RB_space ()\fC [protected]\fP, \fC [virtual]\fP"
Add a new basis functions to the RB space\&. In the transient case we first perform a POD of the time-dependent 'truth' and then add a certain number of POD modes to the reduced basis\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "\fBReal\fP libMesh::LinearImplicitSystem::final_linear_residual () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the final residual for the linear system solve\&. 
.PP
Definition at line 160 of file linear_implicit_system\&.h\&.
.PP
References libMesh::LinearImplicitSystem::_final_linear_residual\&.
.PP
.nf
160 { return _final_linear_residual; }
.fi
.SS "void libMesh::ImplicitSystem::forward_qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [virtual]\fP, \fC [inherited]\fP"
Solves for the derivative of each of the system's quantities of interest q in \fCqoi\fP[qoi_indices] with respect to each parameter in \fCparameters\fP, placing the result for qoi \fCi\fP and parameter \fCj\fP into \fCsensitivities\fP[i][j]\&.
.PP
Uses the forward sensitivity method\&.
.PP
Currently uses finite differenced derivatives (partial q / partial p) and (partial R / partial p)\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 827 of file implicit_system\&.C\&.
.PP
References libMesh::SensitivityData::allocate_data(), libMesh::QoISet::has_index(), libMesh::Real, libMesh::ParameterVector::size(), and libMesh::TOLERANCE\&.
.PP
.nf
830 {
831   const unsigned int Np = libmesh_cast_int<unsigned int>
832     (parameters\&.size());
833   const unsigned int Nq = libmesh_cast_int<unsigned int>
834     (qoi\&.size());
835 
836   // We currently get partial derivatives via central differencing
837   const Real delta_p = TOLERANCE;
838 
839   // An introduction to the problem:
840   //
841   // Residual R(u(p),p) = 0
842   // partial R / partial u = J = system matrix
843   //
844   // This implies that:
845   // d/dp(R) = 0
846   // (partial R / partial p) +
847   // (partial R / partial u) * (partial u / partial p) = 0
848 
849   // We first solve for (partial u / partial p) for each parameter:
850   // J * (partial u / partial p) = - (partial R / partial p)
851 
852   this->sensitivity_solve(parameters);
853 
854   // Get ready to fill in senstivities:
855   sensitivities\&.allocate_data(qoi_indices, *this, parameters);
856 
857   // We use the identity:
858   // dq/dp = (partial q / partial p) + (partial q / partial u) *
859   //         (partial u / partial p)
860 
861   // We get (partial q / partial u) from the user
862   this->assemble_qoi_derivative(qoi_indices);
863 
864   // FIXME: what do we do with adjoint boundary conditions here?
865 
866   // We don't need these to be closed() in this function, but libMesh
867   // standard practice is to have them closed() by the time the
868   // function exits
869   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
870     if (qoi_indices\&.has_index(i))
871       this->get_adjoint_rhs(i)\&.close();
872 
873   for (unsigned int j=0; j != Np; ++j)
874     {
875       // (partial q / partial p) ~= (q(p+dp)-q(p-dp))/(2*dp)
876 
877       Number old_parameter = *parameters[j];
878 
879       *parameters[j] = old_parameter - delta_p;
880       this->assemble_qoi();
881       std::vector<Number> qoi_minus = this->qoi;
882 
883       *parameters[j] = old_parameter + delta_p;
884       this->assemble_qoi();
885       std::vector<Number>& qoi_plus = this->qoi;
886 
887       std::vector<Number> partialq_partialp(Nq, 0);
888       for (unsigned int i=0; i != Nq; ++i)
889         if (qoi_indices\&.has_index(i))
890           partialq_partialp[i] = (qoi_plus[i] - qoi_minus[i]) / (2\&.*delta_p);
891 
892       // Don't leave the parameter changed
893       *parameters[j] = old_parameter;
894 
895       for (unsigned int i=0; i != Nq; ++i)
896         if (qoi_indices\&.has_index(i))
897           sensitivities[i][j] = partialq_partialp[i] +
898             this->get_adjoint_rhs(i)\&.dot(this->get_sensitivity_solution(j));
899     }
900 
901   // All parameters have been reset\&.
902   // We didn't cache the original rhs or matrix for memory reasons,
903   // but we can restore them to a state consistent solution -
904   // principle of least surprise\&.
905   this->assembly(true, true);
906   this->rhs->close();
907   this->matrix->close();
908   this->assemble_qoi(qoi_indices);
909 }
.fi
.SS "static void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::generate_training_parameters_deterministic (const \fBParallel::Communicator\fP &communicator, std::map< std::string, bool >log_param_scale, std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &training_parameters_in, unsigned intn_training_samples_in, const \fBRBParameters\fP &min_parameters, const \fBRBParameters\fP &max_parameters, boolserial_training_set = \fCfalse\fP)\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Static helper function for generating a deterministic set of parameters\&. Only works with 1 or 2 parameters (as defined by the lengths of min/max parameters vectors), otherwise throws an error\&. 
.SS "static void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::generate_training_parameters_random (const \fBParallel::Communicator\fP &communicator, std::map< std::string, bool >log_param_scale, std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &training_parameters_in, unsigned intn_training_samples_in, const \fBRBParameters\fP &min_parameters, const \fBRBParameters\fP &max_parameters, inttraining_parameters_random_seed = \fC-1\fP, boolserial_training_set = \fCfalse\fP)\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Static helper function for generating a randomized set of parameters\&. 
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. This what the user's QoI derivative code should assemble when setting up an adjoint problem 
.RE
.PP

.PP
Definition at line 1027 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
1028 {
1029   std::ostringstream adjoint_rhs_name;
1030   adjoint_rhs_name << "adjoint_rhs" << i;
1031 
1032   return this->get_vector(adjoint_rhs_name\&.str());
1033 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_rhs (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint rhs vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 1037 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1038 {
1039   std::ostringstream adjoint_rhs_name;
1040   adjoint_rhs_name << "adjoint_rhs" << i;
1041 
1042   return this->get_vector(adjoint_rhs_name\&.str());
1043 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 967 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
968 {
969   std::ostringstream adjoint_name;
970   adjoint_name << "adjoint_solution" << i;
971 
972   return this->get_vector(adjoint_name\&.str());
973 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_adjoint_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 977 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
978 {
979   std::ostringstream adjoint_name;
980   adjoint_name << "adjoint_solution" << i;
981 
982   return this->get_vector(adjoint_name\&.str());
983 }
.fi
.SS "virtual void libMesh::TransientRBConstruction::get_all_matrices (std::map< std::string, \fBSparseMatrix\fP< \fBNumber\fP > * > &all_matrices)\fC [virtual]\fP"
Get a map that stores pointers to all of the matrices\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::System::get_all_variable_numbers (std::vector< unsigned int > &all_variable_numbers) const\fC [inherited]\fP"
Fills \fCall_variable_numbers\fP with all the variable numbers for the variables that have been added to this system\&. 
.PP
Definition at line 1260 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers, and libMesh::System::n_vars()\&.
.PP
.nf
1261 {
1262   all_variable_numbers\&.resize(n_vars());
1263 
1264   // Make sure the variable exists
1265   std::map<std::string, unsigned short int>::const_iterator
1266     it = _variable_numbers\&.begin();
1267   std::map<std::string, unsigned short int>::const_iterator
1268     it_end = _variable_numbers\&.end();
1269 
1270   unsigned int count = 0;
1271   for( ; it != it_end; ++it)
1272     {
1273       all_variable_numbers[count] = it->second;
1274       count++;
1275     }
1276 }
.fi
.SS "virtual void libMesh::RBConstruction::get_all_vectors (std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &all_vectors)\fC [virtual]\fP, \fC [inherited]\fP"
Get a map that stores pointers to all of the vectors\&. 
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::RBConstruction::get_Aq (unsigned intq)\fC [inherited]\fP"
Get a pointer to Aq\&. 
.SS "static \fBReal\fP libMesh::RBParametrized::get_closest_value (\fBReal\fPvalue, const std::vector< \fBReal\fP > &list_of_values)\fC [static]\fP, \fC [inherited]\fP"
Helper function that returns the closest entry to \fCvalue\fP from \fClist_of_values\fP\&. 
.SS "\fBElemAssembly\fP& libMesh::RBConstruction::get_constraint_assembly ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the constraint assembly object 
.RE
.PP

.SS "bool libMesh::RBConstruction::get_convergence_assertion_flag () const\fC [protected]\fP, \fC [inherited]\fP"
Getter for the flag determining if convergence should be checked after each solve\&. 
.SS "unsigned int libMesh::RBConstruction::get_delta_N () const\fC [inline]\fP, \fC [inherited]\fP"
Get delta_N, the number of basis functions we add to the RB space per iteration of the greedy algorithm\&. For steady-state systems, this should be 1, but can be more than 1 for time-dependent systems\&. 
.PP
Definition at line 399 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::delta_N\&.
.PP
.nf
399 { return delta_N; }
.fi
.SS "\fBReal\fP libMesh::RBTemporalDiscretization::get_delta_t () const\fC [inherited]\fP"
Get/set delta_t, the time-step size\&. 
.SS "const std::string& \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_deterministic_training_parameter_name () const\fC [inherited]\fP"
Get the name of the parameter that we will generate deterministic training parameters for\&. 
.SS "unsigned int \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_deterministic_training_parameter_repeats () const\fC [inherited]\fP"
Get the number of times each sample of the deterministic training parameter is repeated\&. 
.SS "const std::map< std::string, std::vector<\fBReal\fP> >& libMesh::RBParametrized::get_discrete_parameter_values () const\fC [inherited]\fP"
Get a const reference to the discrete parameter values\&. 
.SS "const \fBDofMap\fP & libMesh::System::get_dof_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this system's \fC_dof_map\fP\&. 
.RE
.PP

.PP
Definition at line 1903 of file system\&.h\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::UnsteadySolver::advance_timestep(), libMesh::EquationSystems::allgather(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), DMlibMeshFunction(), DMLibMeshSetSystem(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::System::get_info(), libMesh::EquationSystems::get_solution(), libMesh::SystemSubsetBySubdomain::init(), libMesh::UnsteadySolver::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), libMesh::CondensedEigenSystem::initialize_condensed_dofs(), libMesh::System::local_dof_indices(), libMesh::DofMap::max_constraint_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::ErrorVector::plot_error(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_vector(), libMesh::System::re_update(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::UnsteadySolver::reinit(), libMesh::ImplicitSystem::reinit(), libMesh::EigenSystem::reinit(), libMesh::EquationSystems::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::HPCoarsenTest::select_refinement(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::NewtonSolver::solve(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), libMesh::ImplicitSystem::weighted_sensitivity_solve(), libMesh::System::write_parallel_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::System::write_SCALAR_dofs(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1904 {
1905   return *_dof_map;
1906 }
.fi
.SS "\fBDofMap\fP & libMesh::System::get_dof_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fC_dof_map\fP\&. 
.RE
.PP

.PP
Definition at line 1911 of file system\&.h\&.
.PP
References libMesh::System::_dof_map\&.
.PP
.nf
1912 {
1913   return *_dof_map;
1914 }
.fi
.SS "const \fBEquationSystems\fP& libMesh::System::get_equation_systems () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this system's parent \fBEquationSystems\fP object\&. 
.RE
.PP

.PP
Definition at line 681 of file system\&.h\&.
.PP
References libMesh::System::_equation_systems\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::NewmarkSystem::clear(), libMesh::FrequencySystem::clear_all(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::FrequencySystem::init_data(), libMesh::FrequencySystem::n_frequencies(), libMesh::System::project_vector(), libMesh::FrequencySystem::set_current_frequency(), libMesh::FrequencySystem::set_frequencies(), libMesh::FrequencySystem::set_frequencies_by_range(), libMesh::FrequencySystem::set_frequencies_by_steps(), libMesh::NewmarkSystem::set_newmark_parameters(), libMesh::NonlinearImplicitSystem::set_solver_parameters(), libMesh::CondensedEigenSystem::solve(), libMesh::EigenSystem::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), and libMesh::WrappedFunction< Output >::WrappedFunction()\&.
.PP
.nf
681 { return _equation_systems; }
.fi
.SS "\fBEquationSystems\fP& libMesh::System::get_equation_systems ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to this system's parent \fBEquationSystems\fP object\&. 
.RE
.PP

.PP
Definition at line 686 of file system\&.h\&.
.PP
References libMesh::System::_equation_systems\&.
.PP
.nf
686 { return _equation_systems; }
.fi
.SS "const \fBNumericVector\fP<\fBNumber\fP>& libMesh::TransientRBConstruction::get_error_temporal_data ()"
Get the column of temporal_data corresponding to the current time level\&. This gives access to the truth projection error data\&. If the RB basis is empty, then this corresponds to the truth solution data itself\&. 
.SS "\fBReal\fP libMesh::RBTemporalDiscretization::get_euler_theta () const\fC [inherited]\fP"
Get/set euler_theta, parameter that determines the temporal discretization\&. 
.SS "\fBnumeric_index_type\fP \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_first_local_training_index () const\fC [inherited]\fP"
Get the first local index of the training parameters\&. 
.SS "\fBNumericVector\fP<\fBNumber\fP>* libMesh::RBConstruction::get_Fq (unsigned intq)\fC [inherited]\fP"
Get a pointer to Fq\&. 
.SS "static void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_global_max_error_pair (const \fBParallel::Communicator\fP &communicator, std::pair< unsigned int, Real > &error_pair)\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Static function to return the error pair (index,error) that is corresponds to the largest error on all processors\&. 
.SS "const \fBRBParameters\fP& libMesh::RBConstruction::get_greedy_parameter (unsigned inti)\fC [inherited]\fP"
Return the parameters chosen during the i^th step of the Greedy algorithm\&. 
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::System::get_info () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a string containing information about the system\&. 
.RE
.PP

.PP
Definition at line 1635 of file system\&.C\&.
.PP
References libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::DofMap::get_info(), libMesh::FEType::inf_map, libMesh::System::n_constrained_dofs(), libMesh::System::n_dofs(), libMesh::System::n_local_constrained_dofs(), libMesh::System::n_local_dofs(), libMesh::System::n_matrices(), libMesh::System::n_variable_groups(), libMesh::VariableGroup::n_variables(), libMesh::System::n_vectors(), libMesh::VariableGroup::name(), libMesh::System::name(), libMesh::System::number(), libMesh::FEType::order, libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::System::system_type(), libMesh::Variable::type(), libMesh::DofMap::variable_group(), and libMesh::System::variable_group()\&.
.PP
.nf
1636 {
1637   std::ostringstream oss;
1638 
1639 
1640   const std::string& sys_name = this->name();
1641 
1642   oss << "   System #"  << this->number() << ", \"" << sys_name << "\"\n"
1643       << "    Type \""  << this->system_type() << "\"\n"
1644       << "    Variables=";
1645 
1646   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1647     {
1648       const VariableGroup &vg_description (this->variable_group(vg));
1649 
1650       if (vg_description\&.n_variables() > 1) oss << "{ ";
1651       for (unsigned int vn=0; vn<vg_description\&.n_variables(); vn++)
1652         oss << "\"" << vg_description\&.name(vn) << "\" ";
1653       if (vg_description\&.n_variables() > 1) oss << "} ";
1654     }
1655 
1656   oss << '\n';
1657 
1658   oss << "    Finite Element Types=";
1659 #ifndef LIBMESH_ENABLE_INFINITE_ELEMENTS
1660   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1661     oss << "\""
1662         << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.family)
1663         << "\" ";
1664 #else
1665   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1666     {
1667       oss << "\""
1668           << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.family)
1669           << "\", \""
1670           << Utility::enum_to_string<FEFamily>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.radial_family)
1671           << "\" ";
1672     }
1673 
1674   oss << '\n' << "    Infinite Element Mapping=";
1675   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1676     oss << "\""
1677         << Utility::enum_to_string<InfMapType>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.inf_map)
1678         << "\" ";
1679 #endif
1680 
1681   oss << '\n';
1682 
1683   oss << "    Approximation Orders=";
1684   for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
1685     {
1686 #ifndef LIBMESH_ENABLE_INFINITE_ELEMENTS
1687       oss << "\""
1688           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.order)
1689           << "\" ";
1690 #else
1691       oss << "\""
1692           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.order)
1693           << "\", \""
1694           << Utility::enum_to_string<Order>(this->get_dof_map()\&.variable_group(vg)\&.type()\&.radial_order)
1695           << "\" ";
1696 #endif
1697     }
1698 
1699   oss << '\n';
1700 
1701   oss << "    n_dofs()="             << this->n_dofs()             << '\n';
1702   oss << "    n_local_dofs()="       << this->n_local_dofs()       << '\n';
1703 #ifdef LIBMESH_ENABLE_CONSTRAINTS
1704   oss << "    n_constrained_dofs()=" << this->n_constrained_dofs() << '\n';
1705   oss << "    n_local_constrained_dofs()=" << this->n_local_constrained_dofs() << '\n';
1706 #endif
1707 
1708   oss << "    " << "n_vectors()="  << this->n_vectors()  << '\n';
1709   oss << "    " << "n_matrices()="  << this->n_matrices()  << '\n';
1710   //   oss << "    " << "n_additional_matrices()=" << this->n_additional_matrices() << '\n';
1711 
1712   oss << this->get_dof_map()\&.get_info();
1713 
1714   return oss\&.str();
1715 }
.fi
.SS "\fBElemAssembly\fP& libMesh::RBConstruction::get_inner_product_assembly ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the inner product assembly object 
.RE
.PP

.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::RBConstruction::get_inner_product_matrix ()\fC [inherited]\fP"
Get a pointer to inner_product_matrix\&. Accessing via this function, rather than directly through the class member allows us to do error checking (e\&.g\&. inner_product_matrix is not defined in low-memory mode)\&. 
.SS "\fBElemAssembly\fP& libMesh::TransientRBConstruction::get_L2_assembly ()"

.PP
\fBReturns:\fP
.RS 4
a reference to the L2 assembly object 
.RE
.PP

.SS "\fBnumeric_index_type\fP \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_last_local_training_index () const\fC [inherited]\fP"
Get the last local index of the training parameters\&. 
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::ImplicitSystem::get_linear_solve_parameters () const\fC [virtual]\fP, \fC [inherited]\fP"
Returns an integer corresponding to the upper iteration count limit and a Real corresponding to the convergence tolerance to be used in linear adjoint and/or sensitivity solves 
.PP
Reimplemented in \fBlibMesh::NonlinearImplicitSystem\fP, and \fBlibMesh::DifferentiableSystem\fP\&.
.PP
Definition at line 1401 of file implicit_system\&.C\&.
.PP
References libMesh::System::get_equation_systems(), and libMesh::Real\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
1402 {
1403   return std::make_pair(this->get_equation_systems()\&.parameters\&.get<unsigned int>("linear solver maximum iterations"),
1404                         this->get_equation_systems()\&.parameters\&.get<Real>("linear solver tolerance"));
1405 }
.fi
.SS "\fBLinearSolver\fP< \fBNumber\fP > * libMesh::LinearImplicitSystem::get_linear_solver () const\fC [virtual]\fP, \fC [inherited]\fP"
Returns a pointer to a linear solver appropriate for use in adjoint and/or sensitivity solves 
.PP
Reimplemented from \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 366 of file linear_implicit_system\&.C\&.
.PP
References libMesh::LinearImplicitSystem::linear_solver\&.
.PP
.nf
367 {
368   return linear_solver\&.get();
369 }
.fi
.SS "\fBnumeric_index_type\fP \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_local_n_training_samples () const\fC [inherited]\fP"
Get the total number of training samples local to this processor\&. 
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::TransientRBConstruction::get_M_q (unsigned intq)"
Get a pointer to M_q\&. 
.SS "const \fBSparseMatrix\fP< \fBNumber\fP > & libMesh::ImplicitSystem::get_matrix (const std::string &mat_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const reference to this system's \fIadditional\fP matrix named \fCmat_name\fP\&. \fINone\fP of these matrices is involved in the solution process\&. Access is only granted when the matrix is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 258 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_matrices, and libMesh::err\&.
.PP
Referenced by libMesh::NewmarkSystem::compute_matrix(), libMesh::EigenTimeSolver::solve(), and libMesh::NewmarkSystem::update_rhs()\&.
.PP
.nf
259 {
260   // Make sure the matrix exists
261   const_matrices_iterator pos = _matrices\&.find (mat_name);
262 
263   if (pos == _matrices\&.end())
264     {
265       libMesh::err << "ERROR: matrix "
266                    << mat_name
267                    << " does not exist in this system!"
268                    << std::endl;
269       libmesh_error();
270     }
271 
272   return *(pos->second);
273 }
.fi
.SS "\fBSparseMatrix\fP< \fBNumber\fP > & libMesh::ImplicitSystem::get_matrix (const std::string &mat_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fIadditional\fP matrix named \fCmat_name\fP\&. \fINone\fP of these matrices is involved in the solution process\&. Access is only granted when the matrix is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 277 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_matrices, and libMesh::err\&.
.PP
.nf
278 {
279   // Make sure the matrix exists
280   matrices_iterator pos = _matrices\&.find (mat_name);
281 
282   if (pos == _matrices\&.end())
283     {
284       libMesh::err << "ERROR: matrix "
285                    << mat_name
286                    << " does not exist in this system!"
287                    << std::endl;
288       libmesh_error();
289     }
290 
291   return *(pos->second);
292 }
.fi
.SS "int libMesh::TransientRBConstruction::get_max_truth_solves () const\fC [inline]\fP"
Get/set max_truth_solves, the maximum number of RB truth solves we are willing to compute in the transient case\&. Note in the steady state case max_truth_solves is not needed since equivalent to Nmax\&. 
.PP
Definition at line 202 of file transient_rb_construction\&.h\&.
.PP
References max_truth_solves\&.
.PP
.nf
202 { return max_truth_solves; }
.fi
.SS "const \fBMeshBase\fP & libMesh::System::get_mesh () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to this systems's \fC_mesh\fP\&. 
.RE
.PP

.PP
Definition at line 1887 of file system\&.h\&.
.PP
References libMesh::System::_mesh\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::System::calculate_norm(), DMCreateDomainDecomposition_libMesh(), DMCreateFieldDecomposition_libMesh(), DMLibMeshSetSystem(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::SystemSubsetBySubdomain::init(), libMesh::System::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ImplicitSystem::init_matrices(), libMesh::System::local_dof_indices(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::mesh_position_set(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::FEMSystem::postprocess(), libMesh::System::project_vector(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::ImplicitSystem::reinit(), libMesh::EigenSystem::reinit(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), and libMesh::System::zero_variable()\&.
.PP
.nf
1888 {
1889   return _mesh;
1890 }
.fi
.SS "\fBMeshBase\fP & libMesh::System::get_mesh ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to this systems's \fC_mesh\fP\&. 
.RE
.PP

.PP
Definition at line 1895 of file system\&.h\&.
.PP
References libMesh::System::_mesh\&.
.PP
.nf
1896 {
1897   return _mesh;
1898 }
.fi
.SS "unsigned int libMesh::RBParametrized::get_n_continuous_params () const\fC [inherited]\fP"
Get the number of continuous parameters\&. 
.SS "unsigned int libMesh::RBParametrized::get_n_discrete_params () const\fC [inherited]\fP"
Get the number of discrete parameters\&. 
.SS "unsigned int libMesh::RBParametrized::get_n_params () const\fC [inherited]\fP"
Get the number of parameters\&. 
.SS "unsigned int libMesh::RBTemporalDiscretization::get_n_time_steps () const\fC [inherited]\fP"
Get/set the total number of time-steps\&. 
.SS "\fBnumeric_index_type\fP \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_n_training_samples () const\fC [inherited]\fP"
Get the total number of training samples\&. 
.SS "unsigned int libMesh::RBConstruction::get_Nmax () const\fC [inline]\fP, \fC [inherited]\fP"
Get/set Nmax, the maximum number of RB functions we are willing to compute\&. 
.PP
Definition at line 182 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::Nmax\&.
.PP
.nf
182 { return Nmax; }
.fi
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::RBConstruction::get_non_dirichlet_Aq (unsigned intq)\fC [inherited]\fP"
Get a pointer to non_dirichlet_Aq\&. 
.SS "\fBNumericVector\fP<\fBNumber\fP>* libMesh::RBConstruction::get_non_dirichlet_Fq (unsigned intq)\fC [inherited]\fP"
Get a pointer to non-Dirichlet Fq\&. 
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::RBConstruction::get_non_dirichlet_inner_product_matrix ()\fC [inherited]\fP"
Get a pointer to non_dirichlet_inner_product_matrix\&. Accessing via this function, rather than directly through the class member allows us to do error checking (e\&.g\&. non_dirichlet_inner_product_matrix is not defined in low-memory mode, and we need store_non_dirichlet_operators==true)\&. 
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::TransientRBConstruction::get_non_dirichlet_M_q (unsigned intq)"
Get a pointer to non_dirichlet_M_q\&. 
.SS "\fBNumericVector\fP<\fBNumber\fP>* libMesh::RBConstruction::get_non_dirichlet_output_vector (unsigned intn, unsigned intq_l)\fC [inherited]\fP"
Get a pointer to non-Dirichlet output vector\&. 
.SS "\fBNumericVector\fP<\fBNumber\fP>* libMesh::RBConstruction::get_output_vector (unsigned intn, unsigned intq_l)\fC [inherited]\fP"
Get a pointer to the n^th output\&. 
.SS "virtual void libMesh::RBConstruction::get_output_vectors (std::map< std::string, \fBNumericVector\fP< \fBNumber\fP > * > &all_vectors)\fC [virtual]\fP, \fC [inherited]\fP"
Get a map that stores pointers to all of the vectors\&. 
.SS "\fBReal\fP libMesh::RBParametrized::get_parameter_max (const std::string &param_name) const\fC [inherited]\fP"
Get maximum allowable value of parameter \fCparam_name\fP\&. 
.SS "\fBReal\fP libMesh::RBParametrized::get_parameter_min (const std::string &param_name) const\fC [inherited]\fP"
Get minimum allowable value of parameter \fCparam_name\fP\&. 
.SS "std::set<std::string> libMesh::RBParametrized::get_parameter_names () const\fC [inherited]\fP"
Get a set that stores the parameter names\&. 
.SS "const \fBRBParameters\fP& libMesh::RBParametrized::get_parameters () const\fC [inherited]\fP"
Get the current parameters\&. 
.SS "const \fBRBParameters\fP& libMesh::RBParametrized::get_parameters_max () const\fC [inherited]\fP"
Get an \fBRBParameters\fP object that specifies the maximum allowable value for each parameter\&. 
.SS "const \fBRBParameters\fP& libMesh::RBParametrized::get_parameters_min () const\fC [inherited]\fP"
Get an \fBRBParameters\fP object that specifies the minimum allowable value for each parameter\&. 
.SS "\fBRBParameters\fP \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::get_params_from_training_set (unsigned intindex)\fC [protected]\fP, \fC [inherited]\fP"
Return the RBParameters in index \fCindex\fP of training set\&. 
.SS "\fBReal\fP libMesh::TransientRBConstruction::get_POD_tol () const\fC [inline]\fP"
Get/set POD_tol 
.PP
Definition at line 208 of file transient_rb_construction\&.h\&.
.PP
References POD_tol\&.
.PP
.nf
208 { return POD_tol; }
.fi
.SS "\fBRBAssemblyExpansion\fP& libMesh::RBConstruction::get_rb_assembly_expansion ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the rb_assembly_expansion object 
.RE
.PP

.SS "virtual \fBReal\fP libMesh::RBConstruction::get_RB_error_bound ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This function returns the RB error bound for the current parameters and is used in the Greedy algorithm to select the next parameter\&. 
.PP
Reimplemented in \fBlibMesh::RBEIMConstruction\fP\&.
.SS "\fBRBEvaluation\fP& libMesh::RBConstruction::get_rb_evaluation ()\fC [inherited]\fP"
Get a reference to the \fBRBEvaluation\fP object\&. 
.SS "\fBRBThetaExpansion\fP& libMesh::RBConstruction::get_rb_theta_expansion ()\fC [inherited]\fP"
Get a reference to the \fBRBThetaExpansion\fP object that that belongs to rb_eval\&. 
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_rhs (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. By default these vectors are built by the library, using finite differences, when \fC\fBassemble_residual_derivatives()\fP\fP is called\&.
.RE
.PP
When assembled, this vector should hold -(partial R / partial p_i) 
.PP
Definition at line 1057 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
1058 {
1059   std::ostringstream sensitivity_rhs_name;
1060   sensitivity_rhs_name << "sensitivity_rhs" << i;
1061 
1062   return this->get_vector(sensitivity_rhs_name\&.str());
1063 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_rhs (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's sensitivity rhs vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 1067 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1068 {
1069   std::ostringstream sensitivity_rhs_name;
1070   sensitivity_rhs_name << "sensitivity_rhs" << i;
1071 
1072   return this->get_vector(sensitivity_rhs_name\&.str());
1073 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 916 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve()\&.
.PP
.nf
917 {
918   std::ostringstream sensitivity_name;
919   sensitivity_name << "sensitivity_solution" << i;
920 
921   return this->get_vector(sensitivity_name\&.str());
922 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_sensitivity_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's solution sensitivity vectors, by default the one corresponding to the first parameter\&. 
.RE
.PP

.PP
Definition at line 926 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
927 {
928   std::ostringstream sensitivity_name;
929   sensitivity_name << "sensitivity_solution" << i;
930 
931   return this->get_vector(sensitivity_name\&.str());
932 }
.fi
.SS "\fBShellMatrix\fP<\fBNumber\fP>* libMesh::LinearImplicitSystem::get_shell_matrix (void)\fC [inline]\fP, \fC [inherited]\fP"
Returns a pointer to the currently attached shell matrix, if any, or \fCNULL\fP else\&. 
.PP
Definition at line 182 of file linear_implicit_system\&.h\&.
.PP
References libMesh::LinearImplicitSystem::_shell_matrix\&.
.PP
.nf
182 { return _shell_matrix; }
.fi
.SS "unsigned int libMesh::RBTemporalDiscretization::get_time_step () const\fC [inherited]\fP"
Get/set the current time-step\&. 
.SS "\fBReal\fP libMesh::RBConstruction::get_training_tolerance ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 176 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::training_tolerance\&.
.PP
.nf
176 { return training_tolerance; }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const reference to this system's \fIadditional\fP vector named \fCvec_name\fP\&. Access is only granted when the vector is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 785 of file system\&.C\&.
.PP
References libMesh::System::_vectors, and libMesh::err\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::System::compare(), libMesh::UnsteadySolver::du(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_adjoint_rhs(), libMesh::System::get_adjoint_solution(), libMesh::System::get_sensitivity_rhs(), libMesh::System::get_sensitivity_solution(), libMesh::System::get_weighted_sensitivity_adjoint_solution(), libMesh::System::get_weighted_sensitivity_solution(), libMesh::NewmarkSystem::initial_conditions(), libMesh::UnsteadySolver::reinit(), libMesh::MemorySolutionHistory::retrieve(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::TwostepTimeSolver::solve(), libMesh::FrequencySystem::solve(), libMesh::NewmarkSystem::update_rhs(), and libMesh::NewmarkSystem::update_u_v_a()\&.
.PP
.nf
786 {
787   // Make sure the vector exists
788   const_vectors_iterator pos = _vectors\&.find(vec_name);
789 
790   if (pos == _vectors\&.end())
791     {
792       libMesh::err << "ERROR: vector "
793                    << vec_name
794                    << " does not exist in this system!"
795                    << std::endl;
796       libmesh_error();
797     }
798 
799   return *(pos->second);
800 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const std::string &vec_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fIadditional\fP vector named \fCvec_name\fP\&. Access is only granted when the vector is already properly initialized\&. 
.RE
.PP

.PP
Definition at line 804 of file system\&.C\&.
.PP
References libMesh::System::_vectors, and libMesh::err\&.
.PP
.nf
805 {
806   // Make sure the vector exists
807   vectors_iterator pos = _vectors\&.find(vec_name);
808 
809   if (pos == _vectors\&.end())
810     {
811       libMesh::err << "ERROR: vector "
812                    << vec_name
813                    << " does not exist in this system!"
814                    << std::endl;
815       libmesh_error();
816     }
817 
818   return *(pos->second);
819 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const reference to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 823 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
824 {
825   const_vectors_iterator v = vectors_begin();
826   const_vectors_iterator v_end = vectors_end();
827   unsigned int num = 0;
828   while((num<vec_num) && (v!=v_end))
829     {
830       num++;
831       ++v;
832     }
833   libmesh_assert (v != v_end);
834   return *(v->second);
835 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_vector (const unsigned intvec_num)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 839 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
840 {
841   vectors_iterator v = vectors_begin();
842   vectors_iterator v_end = vectors_end();
843   unsigned int num = 0;
844   while((num<vec_num) && (v!=v_end))
845     {
846       num++;
847       ++v;
848     }
849   libmesh_assert (v != v_end);
850   return *(v->second);
851 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 997 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.PP
.nf
998 {
999   std::ostringstream adjoint_name;
1000   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
1001 
1002   return this->get_vector(adjoint_name\&.str());
1003 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_adjoint_solution (unsigned inti = \fC0\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to one of the system's weighted sensitivity adjoint solution vectors, by default the one corresponding to the first qoi\&. 
.RE
.PP

.PP
Definition at line 1007 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
1008 {
1009   std::ostringstream adjoint_name;
1010   adjoint_name << "weighted_sensitivity_adjoint_solution" << i;
1011 
1012   return this->get_vector(adjoint_name\&.str());
1013 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_solution ()\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve 
.RE
.PP

.PP
Definition at line 943 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
Referenced by libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.PP
.nf
944 {
945   return this->get_vector("weighted_sensitivity_solution");
946 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > & libMesh::System::get_weighted_sensitivity_solution () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the solution of the last weighted sensitivity solve 
.RE
.PP

.PP
Definition at line 950 of file system\&.C\&.
.PP
References libMesh::System::get_vector()\&.
.PP
.nf
951 {
952   return this->get_vector("weighted_sensitivity_solution");
953 }
.fi
.SS "virtual bool libMesh::TransientRBConstruction::greedy_termination_test (\fBReal\fPtraining_greedy_error, intcount)\fC [virtual]\fP"
Function that indicates when to terminate the Greedy basis training\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "bool libMesh::System::has_variable (const std::string &var) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if a variable named \fCvar\fP exists in this \fBSystem\fP 
.RE
.PP

.PP
Definition at line 1233 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers\&.
.PP
Referenced by libMesh::GMVIO::copy_nodal_solution()\&.
.PP
.nf
1234 {
1235   return _variable_numbers\&.count(var);
1236 }
.fi
.SS "bool libMesh::ImplicitSystem::have_matrix (const std::string &mat_name) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBSystem\fP\fP has a matrix associated with the given name, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 378 of file implicit_system\&.h\&.
.PP
References libMesh::ImplicitSystem::_matrices\&.
.PP
Referenced by libMesh::ImplicitSystem::add_matrix(), and libMesh::EigenTimeSolver::init()\&.
.PP
.nf
379 {
380   return (_matrices\&.count(mat_name));
381 }
.fi
.SS "bool libMesh::System::have_vector (const std::string &vec_name) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 2071 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::System::add_vector(), and libMesh::System::remove_vector()\&.
.PP
.nf
2072 {
2073   return (_vectors\&.count(vec_name));
2074 }
.fi
.SS "bool libMesh::System::identify_variable_groups () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when \fC\fBVariableGroup\fP\fP structures should be automatically identified, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 2047 of file system\&.h\&.
.PP
References libMesh::System::_identify_variable_groups\&.
.PP
Referenced by libMesh::System::add_variable()\&.
.PP
.nf
2048 {
2049   return _identify_variable_groups;
2050 }
.fi
.SS "void libMesh::System::identify_variable_groups (const boolivg)\fC [inline]\fP, \fC [inherited]\fP"
Toggle automatic \fC\fBVariableGroup\fP\fP identification\&. 
.PP
Definition at line 2055 of file system\&.h\&.
.PP
References libMesh::System::_identify_variable_groups\&.
.PP
.nf
2056 {
2057   _identify_variable_groups = ivg;
2058 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::System::init ()\fC [inherited]\fP"
Initializes degrees of freedom on the current mesh\&. Sets the 
.PP
Definition at line 226 of file system\&.C\&.
.PP
References libMesh::System::_basic_system_only, libMesh::System::init_data(), libMesh::System::n_vars(), and libMesh::System::user_initialization()\&.
.PP
.nf
227 {
228   // First initialize any required data:
229   // either only the basic System data
230   if (_basic_system_only)
231     System::init_data();
232   // or all the derived class' data too
233   else
234     this->init_data();
235 
236   // If no variables have been added to this system
237   // don't do anything
238   if(!this->n_vars())
239     return;
240 
241   // Then call the user-provided intialization function
242   this->user_initialization();
243 }
.fi
.SS "virtual void libMesh::RBConstruction::init_context (\fBFEMContext\fP &)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initialize the \fBFEMContext\fP prior to performing an element loop\&. Reimplement this in derived classes in order to call FE::get_*() as the particular physics requires\&. 
.PP
Reimplemented in \fBlibMesh::RBEIMConstruction\fP\&.
.PP
Definition at line 710 of file rb_construction\&.h\&.
.PP
.nf
710 {}
.fi
.SS "virtual void \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::init_data ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initializes the member data fields associated with the system, so that, e\&.g\&., \fC\fBassemble()\fP\fP may be used\&. 
.PP
Reimplemented from \fBlibMesh::RBConstructionBase< LinearImplicitSystem >\fP\&.
.SS "void libMesh::ImplicitSystem::init_matrices ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initializes the matrices associated with this system\&. 
.PP
Definition at line 105 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_can_add_matrices, libMesh::ImplicitSystem::_matrices, libMesh::DofMap::attach_matrix(), libMesh::DofMap::compute_sparsity(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::SparseMatrix< T >::initialized(), libMesh::DofMap::is_attached(), libMesh::libmesh_assert(), and libMesh::ImplicitSystem::matrix\&.
.PP
Referenced by libMesh::ImplicitSystem::init_data()\&.
.PP
.nf
106 {
107   libmesh_assert(matrix);
108 
109   // Check for quick return in case the system matrix
110   // (and by extension all the matrices) has already
111   // been initialized
112   if (matrix->initialized())
113     return;
114 
115   // Get a reference to the DofMap
116   DofMap& dof_map = this->get_dof_map();
117 
118   // no chance to add other matrices
119   _can_add_matrices = false;
120 
121   // Tell the matrices about the dof map, and vice versa
122   for (matrices_iterator pos = _matrices\&.begin();
123        pos != _matrices\&.end(); ++pos)
124     {
125       SparseMatrix<Number> &m = *(pos->second);
126       libmesh_assert (!m\&.initialized());
127 
128       // We want to allow repeated init() on systems, but we don't
129       // want to attach the same matrix to the DofMap twice
130       if (!dof_map\&.is_attached(m))
131         dof_map\&.attach_matrix (m);
132     }
133 
134   // Compute the sparsity pattern for the current
135   // mesh and DOF distribution\&.  This also updates
136   // additional matrices, \p DofMap now knows them
137   dof_map\&.compute_sparsity (this->get_mesh());
138 
139   // Initialize matrices
140   for (matrices_iterator pos = _matrices\&.begin();
141        pos != _matrices\&.end(); ++pos)
142     pos->second->init ();
143 
144   // Set the additional matrices to 0\&.
145   for (matrices_iterator pos = _matrices\&.begin();
146        pos != _matrices\&.end(); ++pos)
147     pos->second->zero ();
148 }
.fi
.SS "void libMesh::RBParametrized::initialize_parameters (const \fBRBParameters\fP &mu_min_in, const \fBRBParameters\fP &mu_max_in, const std::map< std::string, std::vector< \fBReal\fP > > &discrete_parameter_values)\fC [inherited]\fP"
Initialize the parameter ranges and set current_parameters\&. 
.SS "void libMesh::RBParametrized::initialize_parameters (const \fBRBParametrized\fP &rb_parametrized)\fC [inherited]\fP"
Initialize the parameter ranges and set current_parameters\&. 
.SS "virtual void libMesh::TransientRBConstruction::initialize_rb_construction (boolskip_matrix_assembly = \fCfalse\fP, boolskip_vector_assembly = \fCfalse\fP)\fC [virtual]\fP"
Allocate all the data structures necessary for the construction stage of the RB method\&. This function also performs matrix and vector assembly of the 'truth' affine expansion\&.
.PP
Override to check that theta and assembly expansions are consistently sized\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::initialize_training_parameters (const \fBRBParameters\fP &mu_min, const \fBRBParameters\fP &mu_max, unsigned intn_training_parameters, std::map< std::string, bool >log_param_scale, booldeterministic = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Initialize the parameter ranges and indicate whether deterministic or random training parameters should be used and whether or not we want the parameters to be scaled logarithmically\&. 
.SS "virtual void libMesh::TransientRBConstruction::initialize_truth ()\fC [protected]\fP, \fC [virtual]\fP"
This function imposes a truth initial condition, defaults to zero initial condition if the flag nonzero_initialization is true\&. 
.SS "bool libMesh::System::is_adjoint_already_solved () const\fC [inline]\fP, \fC [inherited]\fP"
Accessor for the adjoint_already_solved boolean 
.PP
Definition at line 361 of file system\&.h\&.
.PP
References libMesh::System::adjoint_already_solved\&.
.PP
Referenced by libMesh::AdjointResidualErrorEstimator::estimate_error()\&.
.PP
.nf
362   { return adjoint_already_solved;}
.fi
.SS "bool libMesh::RBParametrized::is_discrete_parameter (const std::string &mu_name) const\fC [inherited]\fP"
Is parameter \fCmu_name\fP discrete? 
.SS "bool libMesh::RBConstruction::is_quiet () const\fC [inline]\fP, \fC [inherited]\fP"
Is the system in quiet mode? 
.PP
Definition at line 196 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::quiet_mode\&.
.PP
.nf
197   { return this->quiet_mode; }
.fi
.SS "bool libMesh::RBConstruction::is_rb_eval_initialized () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if rb_eval is initialized\&. False, otherwise\&. 
.RE
.PP

.SS "virtual void libMesh::RBConstruction::load_basis_function (unsigned inti)\fC [virtual]\fP, \fC [inherited]\fP"
Load the i^th RB function into the \fBRBConstruction\fP solution vector\&. 
.SS "virtual void libMesh::TransientRBConstruction::load_rb_solution ()\fC [virtual]\fP"
Load the RB solution from the current time-level into the \fBlibMesh\fP solution vector\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::load_training_set (std::map< std::string, std::vector< \fBNumber\fP > > &new_training_set)\fC [virtual]\fP, \fC [inherited]\fP"
Overwrite the training parameters with new_training_set\&. 
.SS "void libMesh::System::local_dof_indices (const unsigned intvar, std::set< \fBdof_id_type\fP > &var_indices) const\fC [inherited]\fP"
Fills the std::set with the degrees of freedom on the local processor corresponding the the variable number passed in\&. 
.PP
Definition at line 1279 of file system\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::DofMap::dof_indices(), libMesh::DofMap::end_dof(), libMesh::DofMap::first_dof(), libMesh::System::get_dof_map(), and libMesh::System::get_mesh()\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
1281 {
1282   // Make sure the set is clear
1283   var_indices\&.clear();
1284 
1285   std::vector<dof_id_type> dof_indices;
1286 
1287   // Begin the loop over the elements
1288   MeshBase::const_element_iterator       el     =
1289     this->get_mesh()\&.active_local_elements_begin();
1290   const MeshBase::const_element_iterator end_el =
1291     this->get_mesh()\&.active_local_elements_end();
1292 
1293   const dof_id_type
1294     first_local = this->get_dof_map()\&.first_dof(),
1295     end_local   = this->get_dof_map()\&.end_dof();
1296 
1297   for ( ; el != end_el; ++el)
1298     {
1299       const Elem* elem = *el;
1300       this->get_dof_map()\&.dof_indices (elem, dof_indices, var);
1301 
1302       for(unsigned int i=0; i<dof_indices\&.size(); i++)
1303         {
1304           dof_id_type dof = dof_indices[i];
1305 
1306           //If the dof is owned by the local processor
1307           if(first_local <= dof && dof < end_local)
1308             var_indices\&.insert(dof_indices[i]);
1309         }
1310     }
1311 }
.fi
.SS "void libMesh::TransientRBConstruction::mass_matrix_scaled_matvec (\fBNumber\fPscalar, \fBNumericVector\fP< \fBNumber\fP > &dest, \fBNumericVector\fP< \fBNumber\fP > &arg)"
Perform a matrix-vector multiplication with the current mass matrix and store the result in dest\&. 
.SS "\fBdof_id_type\fP libMesh::System::n_active_dofs () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of active degrees of freedom for this \fBSystem\fP\&. 
.PP
Definition at line 2063 of file system\&.h\&.
.PP
References libMesh::System::n_constrained_dofs(), and libMesh::System::n_dofs()\&.
.PP
.nf
2064 {
2065   return this->n_dofs() - this->n_constrained_dofs();
2066 }
.fi
.SS "unsigned int libMesh::System::n_components () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of scalar components in the system's variables\&. This will equal \fC\fBn_vars()\fP\fP in the case of all scalar-valued variables\&. 
.RE
.PP

.PP
Definition at line 1967 of file system\&.h\&.
.PP
References libMesh::System::_variables, libMesh::Variable::first_scalar_number(), and libMesh::Variable::n_components()\&.
.PP
Referenced by libMesh::System::add_variables(), libMesh::WrappedFunction< Output >::operator()(), and libMesh::System::project_vector()\&.
.PP
.nf
1968 {
1969   if (_variables\&.empty())
1970     return 0;
1971 
1972   const Variable& last = _variables\&.back();
1973   return last\&.first_scalar_number() + last\&.n_components();
1974 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_constrained_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of constrained degrees of freedom in the system\&. 
.RE
.PP

.PP
Definition at line 147 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::get_info(), and libMesh::System::n_active_dofs()\&.
.PP
.nf
148 {
149 #ifdef LIBMESH_ENABLE_CONSTRAINTS
150 
151   return _dof_map->n_constrained_dofs();
152 
153 #else
154 
155   return 0;
156 
157 #endif
158 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom in the system 
.RE
.PP

.PP
Definition at line 140 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::add_vector(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_info(), libMesh::UnsteadySolver::init_data(), libMesh::System::init_data(), libMesh::System::n_active_dofs(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::System::project_vector(), libMesh::System::read_legacy_data(), libMesh::UnsteadySolver::reinit(), libMesh::System::reinit(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
141 {
142   return _dof_map->n_dofs();
143 }
.fi
.SS "unsigned int libMesh::LinearImplicitSystem::n_linear_iterations () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of iterations taken for the most recent linear solve\&. 
.PP
Definition at line 155 of file linear_implicit_system\&.h\&.
.PP
References libMesh::LinearImplicitSystem::_n_linear_iterations\&.
.PP
.nf
155 { return _n_linear_iterations; }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_local_constrained_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of constrained degrees of freedom on this processor\&. 
.RE
.PP

.PP
Definition at line 162 of file system\&.C\&.
.PP
References libMesh::System::_dof_map\&.
.PP
Referenced by libMesh::System::get_info()\&.
.PP
.nf
163 {
164 #ifdef LIBMESH_ENABLE_CONSTRAINTS
165 
166   return _dof_map->n_local_constrained_dofs();
167 
168 #else
169 
170   return 0;
171 
172 #endif
173 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::n_local_dofs () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom local to this processor 
.RE
.PP

.PP
Definition at line 177 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::System::add_vector(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_info(), libMesh::UnsteadySolver::init_data(), libMesh::System::init_data(), libMesh::System::project_vector(), libMesh::UnsteadySolver::reinit(), libMesh::System::reinit(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
178 {
179   return _dof_map->n_dofs_on_processor (this->processor_id());
180 }
.fi
.SS "unsigned int libMesh::ImplicitSystem::n_matrices () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of matrices handled by this system 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 385 of file implicit_system\&.h\&.
.PP
References libMesh::ImplicitSystem::_matrices\&.
.PP
.nf
386 {
387   return libmesh_cast_int<unsigned int>(_matrices\&.size());
388 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "unsigned int libMesh::System::n_variable_groups () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariableGroup\fP\fP variable groups in the system 
.RE
.PP

.PP
Definition at line 1959 of file system\&.h\&.
.PP
References libMesh::System::_variable_groups\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::get_info(), and libMesh::System::init_data()\&.
.PP
.nf
1960 {
1961   return libmesh_cast_int<unsigned int>(_variable_groups\&.size());
1962 }
.fi
.SS "unsigned int libMesh::System::n_vars () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of variables in the system 
.RE
.PP

.PP
Definition at line 1951 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::DiffContext::add_localized_vector(), libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::WrappedFunction< Output >::component(), libMesh::DGFEMContext::DGFEMContext(), libMesh::DiffContext::DiffContext(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::ErrorEstimator::estimate_errors(), libMesh::ExactSolution::ExactSolution(), libMesh::FEMContext::FEMContext(), libMesh::System::get_all_variable_numbers(), libMesh::EquationSystems::get_solution(), libMesh::System::init(), libMesh::FEMSystem::init_context(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), libMesh::WrappedFunction< Output >::operator()(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_vector(), libMesh::System::re_update(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::EquationSystems::reinit(), libMesh::System::reinit(), libMesh::HPCoarsenTest::select_refinement(), libMesh::SystemSubsetBySubdomain::set_var_nums(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), and libMesh::System::zero_variable()\&.
.PP
.nf
1952 {
1953   return libmesh_cast_int<unsigned int>(_variables\&.size());
1954 }
.fi
.SS "unsigned int libMesh::System::n_vectors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of vectors (in addition to the solution) handled by this system This is the size of the \fC_vectors\fP map 
.RE
.PP

.PP
Definition at line 2079 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::ExplicitSystem::add_system_rhs(), libMesh::System::compare(), libMesh::System::get_info(), and libMesh::System::write_header()\&.
.PP
.nf
2080 {
2081   return libmesh_cast_int<unsigned int>(_vectors\&.size());
2082 }
.fi
.SS "const std::string & libMesh::System::name () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the system name\&. 
.RE
.PP

.PP
Definition at line 1871 of file system\&.h\&.
.PP
References libMesh::System::_sys_name\&.
.PP
Referenced by libMesh::System::compare(), libMesh::WrappedFunction< Output >::component(), libMesh::ContinuationSystem::ContinuationSystem(), DMLibMeshSetUpName_Private(), libMesh::ExactSolution::ExactSolution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::for(), libMesh::System::get_info(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::NewtonSolver::init(), libMesh::TimeSolver::init_data(), libMesh::WrappedFunction< Output >::operator()(), libMesh::petsc_auto_fieldsplit(), libMesh::TimeSolver::reinit(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::System::user_assembly(), libMesh::System::user_constrain(), libMesh::System::user_initialization(), libMesh::System::user_QOI(), libMesh::System::user_QOI_derivative(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), and libMesh::System::write_serialized_data()\&.
.PP
.nf
1872 {
1873   return _sys_name;
1874 }
.fi
.SS "unsigned int libMesh::System::number () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the system number\&. 
.RE
.PP

.PP
Definition at line 1879 of file system\&.h\&.
.PP
References libMesh::System::_sys_number\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_solution_vector(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::System::get_info(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::HPCoarsenTest::select_refinement(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_blocked_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
1880 {
1881   return _sys_number;
1882 }
.fi
.SS "\fBNumber\fP \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::old_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the old solution (at the previous timestep) for the specified global DOF\&. 
.RE
.PP

.SS "\fBNumber\fP \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::older_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the older solution (two timesteps ago) for the specified global DOF\&. 
.RE
.PP

.SS "\fBGradient\fP libMesh::System::point_gradient (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the gradient of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2063 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
2064 {
2065   // This function must be called on every processor; there's no
2066   // telling where in the partition p falls\&.
2067   parallel_object_only();
2068 
2069   // And every processor had better agree about which point we're
2070   // looking for
2071 #ifndef NDEBUG
2072   this->comm()\&.verify(p);
2073 #endif // NDEBUG
2074 
2075   // Get a reference to the mesh object associated with the system object that calls this function
2076   const MeshBase &mesh = this->get_mesh();
2077 
2078   // Use an existing PointLocator or create a new one
2079   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
2080   PointLocatorBase& locator = *locator_ptr;
2081 
2082   if (!insist_on_success)
2083     locator\&.enable_out_of_mesh_mode();
2084 
2085   // Get a pointer to the element that contains P
2086   const Elem *e = locator(p);
2087 
2088   Gradient grad_u;
2089 
2090   if (e && e->processor_id() == this->processor_id())
2091     grad_u = point_gradient(var, p, *e);
2092 
2093   // If I have an element containing p, then let's let everyone know
2094   processor_id_type lowest_owner =
2095     (e && (e->processor_id() == this->processor_id())) ?
2096     this->processor_id() : this->n_processors();
2097   this->comm()\&.min(lowest_owner);
2098 
2099   // Everybody should get their value from a processor that was able
2100   // to compute it\&.
2101   // If nobody admits owning the point, we may have a problem\&.
2102   if (lowest_owner != this->n_processors())
2103     this->comm()\&.broadcast(grad_u, lowest_owner);
2104   else
2105     libmesh_assert(!insist_on_success);
2106 
2107   return grad_u;
2108 }
.fi
.SS "\fBGradient\fP libMesh::System::point_gradient (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the gradient of the solution variable \fCvar\fP at the physical point \fCp\fP in local \fBElem\fP \fCe\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2111 of file system\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2112 {
2113   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2114 
2115   // Ensuring that the given point is really in the element is an
2116   // expensive assert, but as long as debugging is turned on we might
2117   // as well try to catch a particularly nasty potential error
2118   libmesh_assert (e\&.contains_point(p));
2119 
2120   // Get the dof map to get the proper indices for our computation
2121   const DofMap& dof_map = this->get_dof_map();
2122 
2123   // Need dof_indices for phi[i][j]
2124   std::vector<dof_id_type> dof_indices;
2125 
2126   // Fill in the dof_indices for our element
2127   dof_map\&.dof_indices (&e, dof_indices, var);
2128 
2129   // Get the no of dofs assciated with this point
2130   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2131     (dof_indices\&.size());
2132 
2133   FEType fe_type = dof_map\&.variable_type(var);
2134 
2135   // Build a FE again so we can calculate u(p)
2136   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2137 
2138   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2139   // Build a vector of point co-ordinates to send to reinit
2140   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2141 
2142   // Get the values of the shape function derivatives
2143   const std::vector<std::vector<RealGradient> >&  dphi = fe->get_dphi();
2144 
2145   // Reinitialize the element and compute the shape function values at coor
2146   fe->reinit (&e, &coor);
2147 
2148   // Get ready to accumulate a gradient
2149   Gradient grad_u;
2150 
2151   for (unsigned int l=0; l<num_dofs; l++)
2152     {
2153       grad_u\&.add_scaled (dphi[l][0], this->current_solution (dof_indices[l]));
2154     }
2155 
2156   return grad_u;
2157 }
.fi
.SS "\fBTensor\fP libMesh::System::point_hessian (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the second derivative tensor of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2162 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
2163 {
2164   // This function must be called on every processor; there's no
2165   // telling where in the partition p falls\&.
2166   parallel_object_only();
2167 
2168   // And every processor had better agree about which point we're
2169   // looking for
2170 #ifndef NDEBUG
2171   this->comm()\&.verify(p);
2172 #endif // NDEBUG
2173 
2174   // Get a reference to the mesh object associated with the system object that calls this function
2175   const MeshBase &mesh = this->get_mesh();
2176 
2177   // Use an existing PointLocator or create a new one
2178   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
2179   PointLocatorBase& locator = *locator_ptr;
2180 
2181   if (!insist_on_success)
2182     locator\&.enable_out_of_mesh_mode();
2183 
2184   // Get a pointer to the element that contains P
2185   const Elem *e = locator(p);
2186 
2187   Tensor hess_u;
2188 
2189   if (e && e->processor_id() == this->processor_id())
2190     hess_u = point_hessian(var, p, *e);
2191 
2192   // If I have an element containing p, then let's let everyone know
2193   processor_id_type lowest_owner =
2194     (e && (e->processor_id() == this->processor_id())) ?
2195     this->processor_id() : this->n_processors();
2196   this->comm()\&.min(lowest_owner);
2197 
2198   // Everybody should get their value from a processor that was able
2199   // to compute it\&.
2200   // If nobody admits owning the point, we may have a problem\&.
2201   if (lowest_owner != this->n_processors())
2202     this->comm()\&.broadcast(hess_u, lowest_owner);
2203   else
2204     libmesh_assert(!insist_on_success);
2205 
2206   return hess_u;
2207 }
.fi
.SS "\fBTensor\fP libMesh::System::point_hessian (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the second derivative tensor of the solution variable \fCvar\fP at the physical point \fCp\fP in local \fBElem\fP \fCe\fP in the mesh, similarly to point_value\&. 
.PP
Definition at line 2209 of file system\&.C\&.
.PP
References libMesh::TypeTensor< T >::add_scaled(), libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2210 {
2211   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2212 
2213   // Ensuring that the given point is really in the element is an
2214   // expensive assert, but as long as debugging is turned on we might
2215   // as well try to catch a particularly nasty potential error
2216   libmesh_assert (e\&.contains_point(p));
2217 
2218   // Get the dof map to get the proper indices for our computation
2219   const DofMap& dof_map = this->get_dof_map();
2220 
2221   // Need dof_indices for phi[i][j]
2222   std::vector<dof_id_type> dof_indices;
2223 
2224   // Fill in the dof_indices for our element
2225   dof_map\&.dof_indices (&e, dof_indices, var);
2226 
2227   // Get the no of dofs assciated with this point
2228   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2229     (dof_indices\&.size());
2230 
2231   FEType fe_type = dof_map\&.variable_type(var);
2232 
2233   // Build a FE again so we can calculate u(p)
2234   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2235 
2236   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2237   // Build a vector of point co-ordinates to send to reinit
2238   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2239 
2240   // Get the values of the shape function derivatives
2241   const std::vector<std::vector<RealTensor> >&  d2phi = fe->get_d2phi();
2242 
2243   // Reinitialize the element and compute the shape function values at coor
2244   fe->reinit (&e, &coor);
2245 
2246   // Get ready to accumulate a hessian
2247   Tensor hess_u;
2248 
2249   for (unsigned int l=0; l<num_dofs; l++)
2250     {
2251       hess_u\&.add_scaled (d2phi[l][0], this->current_solution (dof_indices[l]));
2252     }
2253 
2254   return hess_u;
2255 }
.fi
.SS "\fBNumber\fP libMesh::System::point_value (unsigned intvar, const \fBPoint\fP &p, const boolinsist_on_success = \fCtrue\fP) const\fC [inherited]\fP"
Returns the value of the solution variable \fCvar\fP at the physical point \fCp\fP in the mesh, without knowing a priori which element contains \fCp\fP\&.
.PP
Note that this function uses \fC\fBMeshBase::sub_point_locator()\fP\fP; users may or may not want to call \fC\fBMeshBase::clear_point_locator()\fP\fP afterward\&. Also, point_locator() is expensive (N log N for initial construction, log N for evaluations)\&. Avoid using this function in any context where you are already looping over elements\&.
.PP
Because the element containing \fCp\fP may lie on any processor, this function is parallel-only\&.
.PP
By default this method expects the point to reside inside the domain and will abort if no element can be found which contains \fC\fP\&. The optional parameter \fCinsist_on_success\fP can be set to false to allow the method to return 0 when the point is not located\&. 
.PP
Definition at line 1966 of file system\&.C\&.
.PP
References libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::PointLocatorBase::enable_out_of_mesh_mode(), libMesh::System::get_mesh(), libMesh::libmesh_assert(), mesh, libMesh::Parallel::Communicator::min(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::MeshBase::sub_point_locator(), and libMesh::Parallel::Communicator::verify()\&.
.PP
.nf
1967 {
1968   // This function must be called on every processor; there's no
1969   // telling where in the partition p falls\&.
1970   parallel_object_only();
1971 
1972   // And every processor had better agree about which point we're
1973   // looking for
1974 #ifndef NDEBUG
1975   this->comm()\&.verify(p);
1976 #endif // NDEBUG
1977 
1978   // Get a reference to the mesh object associated with the system object that calls this function
1979   const MeshBase &mesh = this->get_mesh();
1980 
1981   // Use an existing PointLocator or create a new one
1982   AutoPtr<PointLocatorBase> locator_ptr = mesh\&.sub_point_locator();
1983   PointLocatorBase& locator = *locator_ptr;
1984 
1985   if (!insist_on_success)
1986     locator\&.enable_out_of_mesh_mode();
1987 
1988   // Get a pointer to the element that contains P
1989   const Elem *e = locator(p);
1990 
1991   Number u = 0;
1992 
1993   if (e && e->processor_id() == this->processor_id())
1994     u = point_value(var, p, *e);
1995 
1996   // If I have an element containing p, then let's let everyone know
1997   processor_id_type lowest_owner =
1998     (e && (e->processor_id() == this->processor_id())) ?
1999     this->processor_id() : this->n_processors();
2000   this->comm()\&.min(lowest_owner);
2001 
2002   // Everybody should get their value from a processor that was able
2003   // to compute it\&.
2004   // If nobody admits owning the point, we have a problem\&.
2005   if (lowest_owner != this->n_processors())
2006     this->comm()\&.broadcast(u, lowest_owner);
2007   else
2008     libmesh_assert(!insist_on_success);
2009 
2010   return u;
2011 }
.fi
.SS "\fBNumber\fP libMesh::System::point_value (unsigned intvar, const \fBPoint\fP &p, const \fBElem\fP &e) const\fC [inherited]\fP"
Returns the value of the solution variable \fCvar\fP at the physical point \fCp\fP contained in local \fBElem\fP \fCe\fP 
.PP
This version of point_value can be run in serial, but assumes \fCe\fP is in the local mesh partition\&. 
.PP
Definition at line 2013 of file system\&.C\&.
.PP
References libMesh::FEGenericBase< T >::build(), libMesh::Elem::contains_point(), libMesh::System::current_solution(), libMesh::Elem::dim(), libMesh::dof_map, libMesh::System::get_dof_map(), libMesh::FEInterface::inverse_map(), libMesh::libmesh_assert(), libMesh::ParallelObject::processor_id(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
2014 {
2015   libmesh_assert_equal_to (e\&.processor_id(), this->processor_id());
2016 
2017   // Ensuring that the given point is really in the element is an
2018   // expensive assert, but as long as debugging is turned on we might
2019   // as well try to catch a particularly nasty potential error
2020   libmesh_assert (e\&.contains_point(p));
2021 
2022   // Get the dof map to get the proper indices for our computation
2023   const DofMap& dof_map = this->get_dof_map();
2024 
2025   // Need dof_indices for phi[i][j]
2026   std::vector<dof_id_type> dof_indices;
2027 
2028   // Fill in the dof_indices for our element
2029   dof_map\&.dof_indices (&e, dof_indices, var);
2030 
2031   // Get the no of dofs assciated with this point
2032   const unsigned int num_dofs = libmesh_cast_int<unsigned int>
2033     (dof_indices\&.size());
2034 
2035   FEType fe_type = dof_map\&.variable_type(var);
2036 
2037   // Build a FE so we can calculate u(p)
2038   AutoPtr<FEBase> fe (FEBase::build(e\&.dim(), fe_type));
2039 
2040   // Map the physical co-ordinates to the master co-ordinates using the inverse_map from fe_interface\&.h
2041   // Build a vector of point co-ordinates to send to reinit
2042   std::vector<Point> coor(1, FEInterface::inverse_map(e\&.dim(), fe_type, &e, p));
2043 
2044   // Get the shape function values
2045   const std::vector<std::vector<Real> >& phi = fe->get_phi();
2046 
2047   // Reinitialize the element and compute the shape function values at coor
2048   fe->reinit (&e, &coor);
2049 
2050   // Get ready to accumulate a value
2051   Number u = 0;
2052 
2053   for (unsigned int l=0; l<num_dofs; l++)
2054     {
2055       u += phi[l][0]*this->current_solution (dof_indices[l]);
2056     }
2057 
2058   return u;
2059 }
.fi
.SS "void libMesh::RBConstruction::print_basis_function_orthogonality ()\fC [inherited]\fP"
Print out a matrix that shows the orthogonality of the RB basis functions\&. This is a helpful debugging tool, e\&.g\&. orthogonality can be degraded due to finite precision arithmetic\&. 
.SS "void libMesh::RBParametrized::print_discrete_parameter_values () const\fC [inherited]\fP"
Print out all the discrete parameter values\&. 
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "virtual void libMesh::TransientRBConstruction::print_info ()\fC [virtual]\fP"
Print out info that describes the current setup of this \fBRBConstruction\fP\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::RBParametrized::print_parameters () const\fC [inherited]\fP"
Print the current parameters\&. 
.SS "virtual void libMesh::TransientRBConstruction::process_parameters_file (const std::string &parameters_filename)\fC [virtual]\fP"
Read in the parameters from file and set up the system accordingly\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::RBTemporalDiscretization::process_temporal_parameters_file (const std::string &parameters_filename)\fC [inherited]\fP"
Read in and initialize parameters from \fCparameters_filename\fP\&. 
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "void libMesh::System::project_solution (\fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 470 of file system_projection\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::System::project_solution()\&.
.PP
.nf
472 {
473   this->project_vector(*solution, f, g);
474 
475   solution->localize(*current_local_solution, _dof_map->get_send_list());
476 }
.fi
.SS "void libMesh::System::project_solution (\fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 483 of file system_projection\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
.nf
485 {
486   this->project_vector(*solution, f, g);
487 
488   solution->localize(*current_local_solution, _dof_map->get_send_list());
489 }
.fi
.SS "void libMesh::System::project_solution (\fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters) const\fC [inherited]\fP"
Projects arbitrary functions onto the current solution\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary function onto the solution via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 450 of file system_projection\&.C\&.
.PP
References libMesh::System::project_solution()\&.
.PP
.nf
459 {
460   WrappedFunction<Number> f(*this, fptr, &parameters);
461   WrappedFunction<Gradient> g(*this, gptr, &parameters);
462   this->project_solution(&f, &g);
463 }
.fi
.SS "bool& libMesh::System::project_solution_on_reinit (void)\fC [inline]\fP, \fC [inherited]\fP"
Tells the \fBSystem\fP whether or not to project the solution vector onto new grids when the system is reinitialized\&. The solution will be projected unless \fBproject_solution_on_reinit()\fP = false is called\&. 
.PP
Definition at line 763 of file system\&.h\&.
.PP
References libMesh::System::_solution_projection\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::MemorySolutionHistory::store()\&.
.PP
.nf
764   { return _solution_projection; }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFunctionBase\fP< \fBNumber\fP > *f, \fBFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 516 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::close(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_equation_systems(), libMesh::System::get_mesh(), libMesh::System::n_components(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::Threads::parallel_for(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::NumericVector< T >::set(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::System::time, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::System::variable_scalar_number()\&.
.PP
Referenced by libMesh::System::project_solution(), libMesh::System::project_vector(), and libMesh::System::restrict_vectors()\&.
.PP
.nf
519 {
520   START_LOG ("project_vector()", "System");
521 
522   Threads::parallel_for
523     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
524                      this->get_mesh()\&.active_local_elements_end() ),
525      ProjectSolution(*this, f, g,
526                      this->get_equation_systems()\&.parameters,
527                      new_vector)
528      );
529 
530   // Also, load values into the SCALAR dofs
531   // Note: We assume that all SCALAR dofs are on the
532   // processor with highest ID
533   if(this->processor_id() == (this->n_processors()-1))
534     {
535       // We get different scalars as different
536       // components from a new-style f functor\&.
537       DenseVector<Number> fout(this->n_components());
538       bool filled_fout = false;
539 
540       const DofMap& dof_map = this->get_dof_map();
541       for (unsigned int var=0; var<this->n_vars(); var++)
542         if(this->variable(var)\&.type()\&.family == SCALAR)
543           {
544             if (!filled_fout)
545               {
546                 (*f) (Point(), this->time, fout);
547                 filled_fout = true;
548               }
549 
550             std::vector<dof_id_type> SCALAR_indices;
551             dof_map\&.SCALAR_dof_indices (SCALAR_indices, var);
552             const unsigned int n_SCALAR_dofs =
553               libmesh_cast_int<unsigned int>(SCALAR_indices\&.size());
554 
555             for (unsigned int i=0; i<n_SCALAR_dofs; i++)
556               {
557                 const dof_id_type global_index = SCALAR_indices[i];
558                 const unsigned int component_index =
559                   this->variable_scalar_number(var,i);
560                 new_vector\&.set(global_index, fout(component_index));
561               }
562           }
563     }
564 
565   new_vector\&.close();
566 
567 #ifdef LIBMESH_ENABLE_CONSTRAINTS
568   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
569 #endif
570 
571   STOP_LOG("project_vector()", "System");
572 }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &new_vector, \fBFEMFunctionBase\fP< \fBNumber\fP > *f, \fBFEMFunctionBase\fP< \fBGradient\fP > *g = \fCNULL\fP) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCf\fP and its gradient \fCg\fP are user-provided cloneable functors\&. A gradient \fCg\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&. If non-default \fC\fBParameters\fP\fP are to be used, they can be provided in the \fCparameters\fP argument\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 579 of file system_projection\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::NumericVector< T >::close(), libMesh::FEMFunctionBase< Output >::component(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::Threads::parallel_for(), libMesh::FEMContext::pre_fe_reinit(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::NumericVector< T >::set(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::System::time, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::System::variable_scalar_number()\&.
.PP
.nf
582 {
583   START_LOG ("project_fem_vector()", "System");
584 
585   Threads::parallel_for
586     (ConstElemRange (this->get_mesh()\&.active_local_elements_begin(),
587                      this->get_mesh()\&.active_local_elements_end() ),
588      ProjectFEMSolution(*this, f, g, new_vector)
589      );
590 
591   // Also, load values into the SCALAR dofs
592   // Note: We assume that all SCALAR dofs are on the
593   // processor with highest ID
594   if(this->processor_id() == (this->n_processors()-1))
595     {
596       // FIXME: Do we want to first check for SCALAR vars before building this? [PB]
597       FEMContext context( *this );
598 
599       const DofMap& dof_map = this->get_dof_map();
600       for (unsigned int var=0; var<this->n_vars(); var++)
601         if(this->variable(var)\&.type()\&.family == SCALAR)
602           {
603             // FIXME: We reinit with an arbitrary element in case the user
604             //        doesn't override FEMFunctionBase::component\&. Is there
605             //        any use case we're missing? [PB]
606             Elem *el = const_cast<Elem *>(*(this->get_mesh()\&.active_local_elements_begin()));
607             context\&.pre_fe_reinit( *this, el );
608 
609             std::vector<dof_id_type> SCALAR_indices;
610             dof_map\&.SCALAR_dof_indices (SCALAR_indices, var);
611             const unsigned int n_SCALAR_dofs =
612               libmesh_cast_int<unsigned int>(SCALAR_indices\&.size());
613 
614             for (unsigned int i=0; i<n_SCALAR_dofs; i++)
615               {
616                 const dof_id_type global_index = SCALAR_indices[i];
617                 const unsigned int component_index =
618                   this->variable_scalar_number(var,i);
619 
620                 new_vector\&.set(global_index, f->component(context, component_index, Point(), this->time));
621               }
622           }
623     }
624 
625   new_vector\&.close();
626 
627 #ifdef LIBMESH_ENABLE_CONSTRAINTS
628   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_vector);
629 #endif
630 
631   STOP_LOG("project_fem_vector()", "System");
632 }
.fi
.SS "void libMesh::System::project_vector (\fBNumber\fP fptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, \fBGradient\fP gptrconst Point &p,const Parameters &parameters,const std::string &sys_name,const std::string &unknown_name, const \fBParameters\fP &parameters, \fBNumericVector\fP< \fBNumber\fP > &new_vector) const\fC [inherited]\fP"
Projects arbitrary functions onto a vector of degree of freedom values for the current system\&. The function value \fCfptr\fP and its gradient \fCgptr\fP are represented by function pointers\&. A gradient \fCgptr\fP is only required/used for projecting onto finite element spaces with continuous derivatives\&.
.PP
This method projects an arbitrary function via L2 projections and nodal interpolations on each element\&. 
.PP
Definition at line 496 of file system_projection\&.C\&.
.PP
References libMesh::System::project_vector()\&.
.PP
.nf
506 {
507   WrappedFunction<Number> f(*this, fptr, &parameters);
508   WrappedFunction<Gradient> g(*this, gptr, &parameters);
509   this->project_vector(new_vector, &f, &g);
510 }
.fi
.SS "void libMesh::System::project_vector (\fBNumericVector\fP< \fBNumber\fP > &vector) const\fC [protected]\fP, \fC [inherited]\fP"
Projects the vector defined on the old mesh onto the new mesh\&. 
.PP
Definition at line 255 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::clone(), and libMesh::System::project_vector()\&.
.PP
.nf
256 {
257   // Create a copy of the vector, which currently
258   // contains the old data\&.
259   AutoPtr<NumericVector<Number> >
260     old_vector (vector\&.clone());
261 
262   // Project the old vector to the new vector
263   this->project_vector (*old_vector, vector);
264 }
.fi
.SS "void libMesh::System::project_vector (const \fBNumericVector\fP< \fBNumber\fP > &old_v, \fBNumericVector\fP< \fBNumber\fP > &new_v) const\fC [protected]\fP, \fC [inherited]\fP"
Projects the vector defined on the old mesh onto the new mesh\&. The original vector is unchanged and the new vector is passed through the second argument\&.
.PP
This method projects the vector via L2 projections or nodal interpolations on each element\&. This method projects a solution from an old mesh to a current, refined mesh\&. The input vector \fCold_v\fP gives the solution on the old mesh, while the \fCnew_v\fP gives the solution (to be computed) on the new mesh\&.
.PP
Definition at line 272 of file system_projection\&.C\&.
.PP
References libMesh::NumericVector< T >::build(), libMesh::NumericVector< T >::clear(), libMesh::NumericVector< T >::close(), libMesh::ParallelObject::comm(), libMesh::dof_map, libMesh::DofMap::enforce_constraints_exactly(), libMesh::err, libMesh::FEType::family, libMesh::AutoPtr< Tp >::get(), libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::GHOSTED, libMesh::NumericVector< T >::init(), libMesh::libmesh_assert(), libMesh::NumericVector< T >::local_size(), libMesh::NumericVector< T >::localize(), libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::PARALLEL, libMesh::Threads::parallel_for(), libMesh::Threads::parallel_reduce(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::BuildProjectionList::send_list, libMesh::SERIAL, libMesh::NumericVector< T >::set(), libMesh::NumericVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Variable::type(), libMesh::NumericVector< T >::type(), libMesh::BuildProjectionList::unique(), and libMesh::System::variable()\&.
.PP
.nf
274 {
275   START_LOG ("project_vector()", "System");
276 
283   new_v\&.clear();
284 
285 #ifdef LIBMESH_ENABLE_AMR
286 
287   // Resize the new vector and get a serial version\&.
288   NumericVector<Number> *new_vector_ptr = NULL;
289   AutoPtr<NumericVector<Number> > new_vector_built;
290   NumericVector<Number> *local_old_vector;
291   AutoPtr<NumericVector<Number> > local_old_vector_built;
292   const NumericVector<Number> *old_vector_ptr = NULL;
293 
294   ConstElemRange active_local_elem_range
295     (this->get_mesh()\&.active_local_elements_begin(),
296      this->get_mesh()\&.active_local_elements_end());
297 
298   // If the old vector was uniprocessor, make the new
299   // vector uniprocessor
300   if (old_v\&.type() == SERIAL)
301     {
302       new_v\&.init (this->n_dofs(), false, SERIAL);
303       new_vector_ptr = &new_v;
304       old_vector_ptr = &old_v;
305     }
306 
307   // Otherwise it is a parallel, distributed vector, which
308   // we need to localize\&.
309   else if (old_v\&.type() == PARALLEL)
310     {
311       // Build a send list for efficient localization
312       BuildProjectionList projection_list(*this);
313       Threads::parallel_reduce (active_local_elem_range,
314                                 projection_list);
315 
316       // Create a sorted, unique send_list
317       projection_list\&.unique();
318 
319       new_v\&.init (this->n_dofs(), this->n_local_dofs(), false, PARALLEL);
320       new_vector_built = NumericVector<Number>::build(this->comm());
321       local_old_vector_built = NumericVector<Number>::build(this->comm());
322       new_vector_ptr = new_vector_built\&.get();
323       local_old_vector = local_old_vector_built\&.get();
324       new_vector_ptr->init(this->n_dofs(), false, SERIAL);
325       local_old_vector->init(old_v\&.size(), false, SERIAL);
326       old_v\&.localize(*local_old_vector, projection_list\&.send_list);
327       local_old_vector->close();
328       old_vector_ptr = local_old_vector;
329     }
330   else if (old_v\&.type() == GHOSTED)
331     {
332       // Build a send list for efficient localization
333       BuildProjectionList projection_list(*this);
334       Threads::parallel_reduce (active_local_elem_range,
335                                 projection_list);
336 
337       // Create a sorted, unique send_list
338       projection_list\&.unique();
339 
340       new_v\&.init (this->n_dofs(), this->n_local_dofs(),
341                   this->get_dof_map()\&.get_send_list(), false, GHOSTED);
342 
343       local_old_vector_built = NumericVector<Number>::build(this->comm());
344       new_vector_ptr = &new_v;
345       local_old_vector = local_old_vector_built\&.get();
346       local_old_vector->init(old_v\&.size(), old_v\&.local_size(),
347                              projection_list\&.send_list, false, GHOSTED);
348       old_v\&.localize(*local_old_vector, projection_list\&.send_list);
349       local_old_vector->close();
350       old_vector_ptr = local_old_vector;
351     }
352   else // unknown old_v\&.type()
353     {
354       libMesh::err << "ERROR: Unknown old_v\&.type() == " << old_v\&.type()
355                    << std::endl;
356       libmesh_error();
357     }
358 
359   // Note that the above will have zeroed the new_vector\&.
360   // Just to be sure, assert that new_vector_ptr and old_vector_ptr
361   // were successfully set before trying to deref them\&.
362   libmesh_assert(new_vector_ptr);
363   libmesh_assert(old_vector_ptr);
364 
365   NumericVector<Number> &new_vector = *new_vector_ptr;
366   const NumericVector<Number> &old_vector = *old_vector_ptr;
367 
368   Threads::parallel_for (active_local_elem_range,
369                          ProjectVector(*this,
370                                        old_vector,
371                                        new_vector)
372                          );
373 
374   // Copy the SCALAR dofs from old_vector to new_vector
375   // Note: We assume that all SCALAR dofs are on the
376   // processor with highest ID
377   if(this->processor_id() == (this->n_processors()-1))
378     {
379       const DofMap& dof_map = this->get_dof_map();
380       for (unsigned int var=0; var<this->n_vars(); var++)
381         if(this->variable(var)\&.type()\&.family == SCALAR)
382           {
383             // We can just map SCALAR dofs directly across
384             std::vector<dof_id_type> new_SCALAR_indices, old_SCALAR_indices;
385             dof_map\&.SCALAR_dof_indices (new_SCALAR_indices, var, false);
386             dof_map\&.SCALAR_dof_indices (old_SCALAR_indices, var, true);
387             const unsigned int new_n_dofs =
388               libmesh_cast_int<unsigned int>(new_SCALAR_indices\&.size());
389 
390             for (unsigned int i=0; i<new_n_dofs; i++)
391               {
392                 new_vector\&.set( new_SCALAR_indices[i], old_vector(old_SCALAR_indices[i]) );
393               }
394           }
395     }
396 
397   new_vector\&.close();
398 
399   // If the old vector was serial, we probably need to send our values
400   // to other processors
401   //
402   // FIXME: I'm not sure how to make a NumericVector do that without
403   // creating a temporary parallel vector to use localize! - RHS
404   if (old_v\&.type() == SERIAL)
405     {
406       AutoPtr<NumericVector<Number> > dist_v = NumericVector<Number>::build(this->comm());
407       dist_v->init(this->n_dofs(), this->n_local_dofs(), false, PARALLEL);
408       dist_v->close();
409 
410       for (dof_id_type i=0; i!=dist_v->size(); i++)
411         if (new_vector(i) != 0\&.0)
412           dist_v->set(i, new_vector(i));
413 
414       dist_v->close();
415 
416       dist_v->localize (new_v, this->get_dof_map()\&.get_send_list());
417       new_v\&.close();
418     }
419   // If the old vector was parallel, we need to update it
420   // and free the localized copies
421   else if (old_v\&.type() == PARALLEL)
422     {
423       // We may have to set dof values that this processor doesn't
424       // own in certain special cases, like LAGRANGE FIRST or
425       // HERMITE THIRD elements on second-order meshes
426       for (dof_id_type i=0; i!=new_v\&.size(); i++)
427         if (new_vector(i) != 0\&.0)
428           new_v\&.set(i, new_vector(i));
429       new_v\&.close();
430     }
431 
432   this->get_dof_map()\&.enforce_constraints_exactly(*this, &new_v);
433 
434 #else
435 
436   // AMR is disabled: simply copy the vector
437   new_v = old_v;
438 
439 #endif // #ifdef LIBMESH_ENABLE_AMR
440 
441   STOP_LOG("project_vector()", "System");
442 }
.fi
.SS "void libMesh::System::prolong_vectors ()\fC [virtual]\fP, \fC [inherited]\fP"
Prolong vectors after the mesh has refined 
.PP
Definition at line 371 of file system\&.C\&.
.PP
References libMesh::System::restrict_vectors()\&.
.PP
Referenced by libMesh::EquationSystems::reinit()\&.
.PP
.nf
372 {
373 #ifdef LIBMESH_ENABLE_AMR
374   // Currently project_vector handles both restriction and prolongation
375   this->restrict_vectors();
376 #endif
377 }
.fi
.SS "void libMesh::RBTemporalDiscretization::pull_temporal_discretization_data (\fBRBTemporalDiscretization\fP &other)\fC [inherited]\fP"
Pull the temporal discretization data from \fCother\fP\&. 
.SS "void libMesh::ImplicitSystem::qoi_parameter_hessian (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &hessian)\fC [virtual]\fP, \fC [inherited]\fP"
For each of the system's quantities of interest q in \fCqoi\fP[qoi_indices], and for a vector of parameters p, the parameter sensitivity Hessian H_ij is defined as H_ij = (d^2 q)/(d p_i d p_j) This Hessian is the output of this method, where for each q_i, H_jk is stored in \fChessian\&.second_derivative(i,j,k)\fP\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 1114 of file implicit_system\&.C\&.
.PP
References libMesh::SensitivityData::allocate_hessian_data(), libMesh::QoISet::has_index(), libMesh::Real, libMesh::SensitivityData::second_derivative(), libMesh::ParameterVector::size(), and libMesh::TOLERANCE\&.
.PP
.nf
1117 {
1118   // We currently get partial derivatives via finite differencing
1119   const Real delta_p = TOLERANCE;
1120 
1121   // We'll use one temporary vector for matrix-vector-vector products
1122   AutoPtr<NumericVector<Number> > tempvec = this->solution->zero_clone();
1123 
1124   // And another temporary vector to hold a copy of the true solution
1125   // so we can safely perturb this->solution\&.
1126   AutoPtr<NumericVector<Number> > oldsolution = this->solution->clone();
1127 
1128   const unsigned int Np = libmesh_cast_int<unsigned int>
1129     (parameters\&.size());
1130   const unsigned int Nq = libmesh_cast_int<unsigned int>
1131     (qoi\&.size());
1132 
1133   // For each quantity of interest q, the parameter sensitivity
1134   // Hessian is defined as q''_{kl} = {d^2 q}/{d p_k d p_l}\&.
1135   //
1136   // We calculate it from values and partial derivatives of the
1137   // quantity of interest function Q, solution u, adjoint solution z,
1138   // and residual R, as:
1139   //
1140   // q''_{kl} =
1141   // Q''_{kl} + Q''_{uk}(u)*u'_l + Q''_{ul}(u) * u'_k +
1142   // Q''_{uu}(u)*u'_k*u'_l -
1143   // R''_{kl}(u,z) -
1144   // R''_{uk}(u,z)*u'_l - R''_{ul}(u,z)*u'_k -
1145   // R''_{uu}(u,z)*u'_k*u'_l
1146   //
1147   // See the adjoints model document for more details\&.
1148 
1149   // We first do an adjoint solve to get z for each quantity of
1150   // interest
1151   // if we havent already or dont have an initial condition for the adjoint
1152   if (!this->is_adjoint_already_solved())
1153     {
1154       this->adjoint_solve(qoi_indices);
1155     }
1156 
1157   // And a sensitivity solve to get u_k for each parameter
1158   this->sensitivity_solve(parameters);
1159 
1160   // Get ready to fill in second derivatives:
1161   sensitivities\&.allocate_hessian_data(qoi_indices, *this, parameters);
1162 
1163   for (unsigned int k=0; k != Np; ++k)
1164     {
1165       Number old_parameterk = *parameters[k];
1166 
1167       // The Hessian is symmetric, so we just calculate the lower
1168       // triangle and the diagonal, and we get the upper triangle from
1169       // the transpose of the lower
1170 
1171       for (unsigned int l=0; l != k+1; ++l)
1172         {
1173           // The second partial derivatives with respect to parameters
1174           // are all calculated via a central finite difference
1175           // stencil:
1176           // F''_{kl} ~= (F(p+dp*e_k+dp*e_l) - F(p+dp*e_k-dp*e_l) -
1177           //              F(p-dp*e_k+dp*e_l) + F(p-dp*e_k-dp*e_l))/(4*dp^2)
1178           // We will add Q''_{kl}(u) and subtract R''_{kl}(u,z) at the
1179           // same time\&.
1180           //
1181           // We have to be careful with the perturbations to handle
1182           // the k=l case
1183 
1184           Number old_parameterl = *parameters[l];
1185 
1186           *parameters[k] += delta_p;
1187           *parameters[l] += delta_p;
1188           this->assemble_qoi(qoi_indices);
1189           this->assembly(true, false);
1190           this->rhs->close();
1191           std::vector<Number> partial2q_term = this->qoi;
1192           std::vector<Number> partial2R_term(this->qoi\&.size());
1193           for (unsigned int i=0; i != Nq; ++i)
1194             if (qoi_indices\&.has_index(i))
1195               partial2R_term[i] = this->rhs->dot(this->get_adjoint_solution(i));
1196 
1197           *parameters[l] -= 2\&.*delta_p;
1198           this->assemble_qoi(qoi_indices);
1199           this->assembly(true, false);
1200           this->rhs->close();
1201           for (unsigned int i=0; i != Nq; ++i)
1202             if (qoi_indices\&.has_index(i))
1203               {
1204                 partial2q_term[i] -= this->qoi[i];
1205                 partial2R_term[i] -= this->rhs->dot(this->get_adjoint_solution(i));
1206               }
1207 
1208           *parameters[k] -= 2\&.*delta_p;
1209           this->assemble_qoi(qoi_indices);
1210           this->assembly(true, false);
1211           this->rhs->close();
1212           for (unsigned int i=0; i != Nq; ++i)
1213             if (qoi_indices\&.has_index(i))
1214               {
1215                 partial2q_term[i] += this->qoi[i];
1216                 partial2R_term[i] += this->rhs->dot(this->get_adjoint_solution(i));
1217               }
1218 
1219           *parameters[l] += 2\&.*delta_p;
1220           this->assemble_qoi(qoi_indices);
1221           this->assembly(true, false);
1222           this->rhs->close();
1223           for (unsigned int i=0; i != Nq; ++i)
1224             if (qoi_indices\&.has_index(i))
1225               {
1226                 partial2q_term[i] -= this->qoi[i];
1227                 partial2R_term[i] -= this->rhs->dot(this->get_adjoint_solution(i));
1228                 partial2q_term[i] /= (4\&. * delta_p * delta_p);
1229                 partial2R_term[i] /= (4\&. * delta_p * delta_p);
1230               }
1231 
1232           for (unsigned int i=0; i != Nq; ++i)
1233             if (qoi_indices\&.has_index(i))
1234               {
1235                 Number current_terms = partial2q_term[i] - partial2R_term[i];
1236                 sensitivities\&.second_derivative(i,k,l) += current_terms;
1237                 if (k != l)
1238                   sensitivities\&.second_derivative(i,l,k) += current_terms;
1239               }
1240 
1241           // Don't leave the parameters perturbed
1242           *parameters[l] = old_parameterl;
1243           *parameters[k] = old_parameterk;
1244         }
1245 
1246       // We get (partial q / partial u) and
1247       // (partial R / partial u) from the user, but centrally
1248       // difference to get q_uk and R_uk terms:
1249       // (partial^2 q / partial u partial k)
1250       // q_uk*u'_l = (q_u(p+dp*e_k)*u'_l - q_u(p-dp*e_k)*u'_l)/(2*dp)
1251       // R_uk*z*u'_l = (R_u(p+dp*e_k)*z*u'_l - R_u(p-dp*e_k)*z*u'_l)/(2*dp)
1252       //
1253       // To avoid creating Nq temporary vectors, we add these
1254       // subterms to the sensitivities output one by one\&.
1255       //
1256       // FIXME: this is probably a bad order of operations for
1257       // controlling floating point error\&.
1258 
1259       *parameters[k] = old_parameterk + delta_p;
1260       this->assembly(false, true);
1261       this->matrix->close();
1262       this->assemble_qoi_derivative(qoi_indices);
1263 
1264       for (unsigned int l=0; l != Np; ++l)
1265         {
1266           this->matrix->vector_mult(*tempvec, this->get_sensitivity_solution(l));
1267           for (unsigned int i=0; i != Nq; ++i)
1268             if (qoi_indices\&.has_index(i))
1269               {
1270                 this->get_adjoint_rhs(i)\&.close();
1271                 Number current_terms =
1272                   (this->get_adjoint_rhs(i)\&.dot(this->get_sensitivity_solution(l)) -
1273                    tempvec->dot(this->get_adjoint_solution(i))) / (2\&.*delta_p);
1274                 sensitivities\&.second_derivative(i,k,l) += current_terms;
1275 
1276                 // We use the _uk terms twice; symmetry lets us reuse
1277                 // these calculations for the _ul terms\&.
1278 
1279                 sensitivities\&.second_derivative(i,l,k) += current_terms;
1280               }
1281         }
1282 
1283       *parameters[k] = old_parameterk - delta_p;
1284       this->assembly(false, true);
1285       this->matrix->close();
1286       this->assemble_qoi_derivative(qoi_indices);
1287 
1288       for (unsigned int l=0; l != Np; ++l)
1289         {
1290           this->matrix->vector_mult(*tempvec, this->get_sensitivity_solution(l));
1291           for (unsigned int i=0; i != Nq; ++i)
1292             if (qoi_indices\&.has_index(i))
1293               {
1294                 this->get_adjoint_rhs(i)\&.close();
1295                 Number current_terms =
1296                   (-this->get_adjoint_rhs(i)\&.dot(this->get_sensitivity_solution(l)) +
1297                    tempvec->dot(this->get_adjoint_solution(i))) / (2\&.*delta_p);
1298                 sensitivities\&.second_derivative(i,k,l) += current_terms;
1299 
1300                 // We use the _uk terms twice; symmetry lets us reuse
1301                 // these calculations for the _ul terms\&.
1302 
1303                 sensitivities\&.second_derivative(i,l,k) += current_terms;
1304               }
1305         }
1306 
1307       // Don't leave the parameter perturbed
1308       *parameters[k] = old_parameterk;
1309 
1310       // Our last remaining terms are -R_uu(u,z)*u_k*u_l and
1311       // Q_uu(u)*u_k*u_l
1312       //
1313       // We take directional central finite differences of R_u and Q_u
1314       // to approximate these terms, e\&.g\&.:
1315       //
1316       // Q_uu(u)*u_k ~= (Q_u(u+dp*u_k) - Q_u(u-dp*u_k))/(2*dp)
1317 
1318       *this->solution = this->get_sensitivity_solution(k);
1319       *this->solution *= delta_p;
1320       *this->solution += *oldsolution;
1321       this->assembly(false, true);
1322       this->matrix->close();
1323       this->assemble_qoi_derivative(qoi_indices);
1324 
1325       // The Hessian is symmetric, so we just calculate the lower
1326       // triangle and the diagonal, and we get the upper triangle from
1327       // the transpose of the lower
1328       //
1329       // Note that, because we took the directional finite difference
1330       // with respect to k and not l, we've added an O(delta_p^2)
1331       // error to any permutational symmetry in the Hessian\&.\&.\&.
1332       for (unsigned int l=0; l != k+1; ++l)
1333         {
1334           this->matrix->vector_mult(*tempvec, this->get_sensitivity_solution(l));
1335           for (unsigned int i=0; i != Nq; ++i)
1336             if (qoi_indices\&.has_index(i))
1337               {
1338                 this->get_adjoint_rhs(i)\&.close();
1339                 Number current_terms =
1340                   (this->get_adjoint_rhs(i)\&.dot(this->get_sensitivity_solution(l)) -
1341                    tempvec->dot(this->get_adjoint_solution(i))) / (2\&.*delta_p);
1342                 sensitivities\&.second_derivative(i,k,l) += current_terms;
1343                 if (k != l)
1344                   sensitivities\&.second_derivative(i,l,k) += current_terms;
1345               }
1346         }
1347 
1348       *this->solution = this->get_sensitivity_solution(k);
1349       *this->solution *= -delta_p;
1350       *this->solution += *oldsolution;
1351       this->assembly(false, true);
1352       this->matrix->close();
1353       this->assemble_qoi_derivative(qoi_indices);
1354 
1355       for (unsigned int l=0; l != k+1; ++l)
1356         {
1357           this->matrix->vector_mult(*tempvec, this->get_sensitivity_solution(l));
1358           for (unsigned int i=0; i != Nq; ++i)
1359             if (qoi_indices\&.has_index(i))
1360               {
1361                 this->get_adjoint_rhs(i)\&.close();
1362                 Number current_terms =
1363                   (-this->get_adjoint_rhs(i)\&.dot(this->get_sensitivity_solution(l)) +
1364                    tempvec->dot(this->get_adjoint_solution(i))) / (2\&.*delta_p);
1365                 sensitivities\&.second_derivative(i,k,l) += current_terms;
1366                 if (k != l)
1367                   sensitivities\&.second_derivative(i,l,k) += current_terms;
1368               }
1369         }
1370 
1371       // Don't leave the solution perturbed
1372       *this->solution = *oldsolution;
1373     }
1374 
1375   // All parameters have been reset\&.
1376   // Don't leave the qoi or system changed - principle of least
1377   // surprise\&.
1378   this->assembly(true, true);
1379   this->rhs->close();
1380   this->matrix->close();
1381   this->assemble_qoi(qoi_indices);
1382 }
.fi
.SS "void libMesh::ImplicitSystem::qoi_parameter_hessian_vector_product (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &vector, \fBSensitivityData\fP &product)\fC [virtual]\fP, \fC [inherited]\fP"
For each of the system's quantities of interest q in \fCqoi\fP[qoi_indices], and for a vector of parameters p, the parameter sensitivity Hessian H_ij is defined as H_ij = (d^2 q)/(d p_i d p_j) The Hessian-vector product, for a vector v_k in parameter space, is S_j = H_jk v_k This product is the output of this method, where for each q_i, S_j is stored in \fCsensitivities\fP[i][j]\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 914 of file implicit_system\&.C\&.
.PP
References libMesh::SensitivityData::allocate_data(), libMesh::ParameterVector::deep_copy(), libMesh::QoISet::has_index(), libMesh::Real, libMesh::ParameterVector::size(), libMesh::TOLERANCE, and libMesh::ParameterVector::value_copy()\&.
.PP
.nf
918 {
919   // We currently get partial derivatives via finite differencing
920   const Real delta_p = TOLERANCE;
921 
922   // We'll use a single temporary vector for matrix-vector-vector products
923   AutoPtr<NumericVector<Number> > tempvec = this->solution->zero_clone();
924 
925   const unsigned int Np = libmesh_cast_int<unsigned int>
926     (parameters\&.size());
927   const unsigned int Nq = libmesh_cast_int<unsigned int>
928     (qoi\&.size());
929 
930   // For each quantity of interest q, the parameter sensitivity
931   // Hessian is defined as q''_{kl} = {d^2 q}/{d p_k d p_l}\&.
932   // Given a vector of parameter perturbation weights w_l, this
933   // function evaluates the hessian-vector product sum_l(q''_{kl}*w_l)
934   //
935   // We calculate it from values and partial derivatives of the
936   // quantity of interest function Q, solution u, adjoint solution z,
937   // parameter sensitivity adjoint solutions z^l, and residual R, as:
938   //
939   // sum_l(q''_{kl}*w_l) =
940   // sum_l(w_l * Q''_{kl}) + Q''_{uk}(u)*(sum_l(w_l u'_l)) -
941   // R'_k(u, sum_l(w_l*z^l)) - R'_{uk}(u,z)*(sum_l(w_l u'_l) -
942   // sum_l(w_l*R''_{kl}(u,z))
943   //
944   // See the adjoints model document for more details\&.
945 
946   // We first do an adjoint solve to get z for each quantity of
947   // interest
948   // if we havent already or dont have an initial condition for the adjoint
949   if (!this->is_adjoint_already_solved())
950     {
951       this->adjoint_solve(qoi_indices);
952     }
953 
954   // Get ready to fill in senstivities:
955   sensitivities\&.allocate_data(qoi_indices, *this, parameters);
956 
957   // We can't solve for all the solution sensitivities u'_l or for all
958   // of the parameter sensitivity adjoint solutions z^l without
959   // requiring O(Nq*Np) linear solves\&.  So we'll solve directly for their
960   // weighted sum - this is just O(Nq) solves\&.
961 
962   // First solve for sum_l(w_l u'_l)\&.
963   this->weighted_sensitivity_solve(parameters, vector);
964 
965   // Then solve for sum_l(w_l z^l)\&.
966   this->weighted_sensitivity_adjoint_solve(parameters, vector, qoi_indices);
967 
968   for (unsigned int k=0; k != Np; ++k)
969     {
970       // We approximate sum_l(w_l * Q''_{kl}) with a central
971       // differencing pertubation:
972       // sum_l(w_l * Q''_{kl}) ~=
973       // (Q(p + dp*w_l*e_l + dp*e_k) - Q(p - dp*w_l*e_l + dp*e_k) -
974       // Q(p + dp*w_l*e_l - dp*e_k) + Q(p - dp*w_l*e_l - dp*e_k))/(4*dp^2)
975 
976       // The sum(w_l*R''_kl) term requires the same sort of pertubation,
977       // and so we subtract it in at the same time:
978       // sum_l(w_l * R''_{kl}) ~=
979       // (R(p + dp*w_l*e_l + dp*e_k) - R(p - dp*w_l*e_l + dp*e_k) -
980       // R(p + dp*w_l*e_l - dp*e_k) + R(p - dp*w_l*e_l - dp*e_k))/(4*dp^2)
981 
982       ParameterVector oldparameters, parameterperturbation;
983       parameters\&.deep_copy(oldparameters);
984       vector\&.deep_copy(parameterperturbation);
985       parameterperturbation *= delta_p;
986       parameters += parameterperturbation;
987 
988       Number old_parameter = *parameters[k];
989 
990       *parameters[k] = old_parameter + delta_p;
991       this->assemble_qoi(qoi_indices);
992       this->assembly(true, false);
993       this->rhs->close();
994       std::vector<Number> partial2q_term = this->qoi;
995       std::vector<Number> partial2R_term(this->qoi\&.size());
996       for (unsigned int i=0; i != Nq; ++i)
997         if (qoi_indices\&.has_index(i))
998           partial2R_term[i] = this->rhs->dot(this->get_adjoint_solution(i));
999 
1000       *parameters[k] = old_parameter - delta_p;
1001       this->assemble_qoi(qoi_indices);
1002       this->assembly(true, false);
1003       this->rhs->close();
1004       for (unsigned int i=0; i != Nq; ++i)
1005         if (qoi_indices\&.has_index(i))
1006           {
1007             partial2q_term[i] -= this->qoi[i];
1008             partial2R_term[i] -= this->rhs->dot(this->get_adjoint_solution(i));
1009           }
1010 
1011       oldparameters\&.value_copy(parameters);
1012       parameterperturbation *= -1\&.0;
1013       parameters += parameterperturbation;
1014 
1015       // Re-center old_parameter, which may be affected by vector
1016       old_parameter = *parameters[k];
1017 
1018       *parameters[k] = old_parameter + delta_p;
1019       this->assemble_qoi(qoi_indices);
1020       this->assembly(true, false);
1021       this->rhs->close();
1022       for (unsigned int i=0; i != Nq; ++i)
1023         if (qoi_indices\&.has_index(i))
1024           {
1025             partial2q_term[i] -= this->qoi[i];
1026             partial2R_term[i] -= this->rhs->dot(this->get_adjoint_solution(i));
1027           }
1028 
1029       *parameters[k] = old_parameter - delta_p;
1030       this->assemble_qoi(qoi_indices);
1031       this->assembly(true, false);
1032       this->rhs->close();
1033       for (unsigned int i=0; i != Nq; ++i)
1034         if (qoi_indices\&.has_index(i))
1035           {
1036             partial2q_term[i] += this->qoi[i];
1037             partial2R_term[i] += this->rhs->dot(this->get_adjoint_solution(i));
1038           }
1039 
1040       for (unsigned int i=0; i != Nq; ++i)
1041         if (qoi_indices\&.has_index(i))
1042           {
1043             partial2q_term[i] /= (4\&. * delta_p * delta_p);
1044             partial2R_term[i] /= (4\&. * delta_p * delta_p);
1045           }
1046 
1047       for (unsigned int i=0; i != Nq; ++i)
1048         if (qoi_indices\&.has_index(i))
1049           sensitivities[i][k] = partial2q_term[i] - partial2R_term[i];
1050 
1051       // We get (partial q / partial u), R, and
1052       // (partial R / partial u) from the user, but centrally
1053       // difference to get q_uk, R_k, and R_uk terms:
1054       // (partial R / partial k)
1055       // R_k*sum(w_l*z^l) = (R(p+dp*e_k)*sum(w_l*z^l) - R(p-dp*e_k)*sum(w_l*z^l))/(2*dp)
1056       // (partial^2 q / partial u partial k)
1057       // q_uk = (q_u(p+dp*e_k) - q_u(p-dp*e_k))/(2*dp)
1058       // (partial^2 R / partial u partial k)
1059       // R_uk*z*sum(w_l*u'_l) = (R_u(p+dp*e_k)*z*sum(w_l*u'_l) - R_u(p-dp*e_k)*z*sum(w_l*u'_l))/(2*dp)
1060 
1061       // To avoid creating Nq temporary vectors for q_uk or R_uk, we add
1062       // subterms to the sensitivities output one by one\&.
1063       //
1064       // FIXME: this is probably a bad order of operations for
1065       // controlling floating point error\&.
1066 
1067       *parameters[k] = old_parameter + delta_p;
1068       this->assembly(true, true);
1069       this->rhs->close();
1070       this->matrix->close();
1071       this->assemble_qoi_derivative(qoi_indices);
1072 
1073       this->matrix->vector_mult(*tempvec, this->get_weighted_sensitivity_solution());
1074 
1075       for (unsigned int i=0; i != Nq; ++i)
1076         if (qoi_indices\&.has_index(i))
1077           {
1078             this->get_adjoint_rhs(i)\&.close();
1079             sensitivities[i][k] += (this->get_adjoint_rhs(i)\&.dot(this->get_weighted_sensitivity_solution()) -
1080                                     this->rhs->dot(this->get_weighted_sensitivity_adjoint_solution(i)) -
1081                                     this->get_adjoint_solution(i)\&.dot(*tempvec)) / (2\&.*delta_p);
1082           }
1083 
1084       *parameters[k] = old_parameter - delta_p;
1085       this->assembly(true, true);
1086       this->rhs->close();
1087       this->matrix->close();
1088       this->assemble_qoi_derivative(qoi_indices);
1089 
1090       this->matrix->vector_mult(*tempvec, this->get_weighted_sensitivity_solution());
1091 
1092       for (unsigned int i=0; i != Nq; ++i)
1093         if (qoi_indices\&.has_index(i))
1094           {
1095             this->get_adjoint_rhs(i)\&.close();
1096             sensitivities[i][k] += (-this->get_adjoint_rhs(i)\&.dot(this->get_weighted_sensitivity_solution()) +
1097                                     this->rhs->dot(this->get_weighted_sensitivity_adjoint_solution(i)) +
1098                                     this->get_adjoint_solution(i)\&.dot(*tempvec)) / (2\&.*delta_p);
1099           }
1100     }
1101 
1102   // All parameters have been reset\&.
1103   // Don't leave the qoi or system changed - principle of least
1104   // surprise\&.
1105   this->assembly(true, true);
1106   this->rhs->close();
1107   this->matrix->close();
1108   this->assemble_qoi(qoi_indices);
1109 }
.fi
.SS "void libMesh::System::qoi_parameter_sensitivity (const \fBQoISet\fP &qoi_indices, const \fBParameterVector\fP &parameters, \fBSensitivityData\fP &sensitivities)\fC [virtual]\fP, \fC [inherited]\fP"
Solves for the derivative of each of the system's quantities of interest q in \fCqoi\fP[qoi_indices] with respect to each parameter in \fCparameters\fP, placing the result for qoi \fCi\fP and parameter \fCj\fP into \fCsensitivities\fP[i][j]\&.
.PP
Note that parameters is a const vector, not a vector-of-const; parameter values in this vector need to be mutable for finite differencing to work\&.
.PP
Automatically chooses the forward method for problems with more quantities of interest than parameters, or the adjoint method otherwise\&.
.PP
This method is only usable in derived classes which overload an implementation\&. 
.PP
Definition at line 510 of file system\&.C\&.
.PP
References libMesh::ParameterVector::size(), and libMesh::QoISet::size()\&.
.PP
.nf
513 {
514   // Forward sensitivities are more efficient for Nq > Np
515   if (qoi_indices\&.size(*this) > parameters\&.size())
516     forward_qoi_parameter_sensitivity(qoi_indices, parameters, sensitivities);
517   // Adjoint sensitivities are more efficient for Np > Nq,
518   // and an adjoint may be more reusable than a forward
519   // solution sensitivity in the Np == Nq case\&.
520   else
521     adjoint_qoi_parameter_sensitivity(qoi_indices, parameters, sensitivities);
522 }
.fi
.SS "virtual void \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::re_update ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Re-update the local values when the mesh has changed\&. This method takes the data updated by \fC\fBupdate()\fP\fP and makes it up-to-date on the current mesh\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.SS "void libMesh::System::read_header (\fBXdr\fP &io, const std::string &version, const boolread_header = \fCtrue\fP, const boolread_additional_data = \fCtrue\fP, const boolread_legacy_format = \fCfalse\fP)\fC [inherited]\fP"
Reads the basic data header for this \fBSystem\fP\&. 
.PP
Definition at line 114 of file system_io\&.C\&.
.PP
References libMesh::System::_additional_data_written, libMesh::System::_written_var_indices, libMesh::System::add_variable(), libMesh::System::add_vector(), libMesh::Parallel::Communicator::broadcast(), libMesh::System::clear(), libMesh::ParallelObject::comm(), libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::FEType::inf_map, libMesh::libmesh_assert(), libMesh::MeshBase::mesh_dimension(), libMesh::MONOMIAL, libMesh::on_command_line(), libMesh::FEType::order, libMesh::out, libMesh::ParallelObject::processor_id(), libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::Xdr::reading(), libMesh::System::variable_number(), libMesh::Xdr::version(), and libMesh::XYZ\&.
.PP
Referenced by libMesh::EquationSystems::_read_impl()\&.
.PP
.nf
119 {
120   // This method implements the input of a
121   // System object, embedded in the output of
122   // an EquationSystems<T_sys>\&.  This warrants some
123   // documentation\&.  The output file essentially
124   // consists of 5 sections:
125   //
126   // for this system
127   //
128   //   5\&.) The number of variables in the system (unsigned int)
129   //
130   //   for each variable in the system
131   //
132   //     6\&.) The name of the variable (string)
133   //
134   //     6\&.1\&.) Variable subdmains
135   //
136   //     7\&.) Combined in an FEType:
137   //         - The approximation order(s) of the variable
138   //           (Order Enum, cast to int/s)
139   //         - The finite element family/ies of the variable
140   //           (FEFamily Enum, cast to int/s)
141   //
142   //   end variable loop
143   //
144   //   8\&.) The number of additional vectors (unsigned int),
145   //
146   //     for each additional vector in the system object
147   //
148   //     9\&.) the name of the additional vector  (string)
149   //
150   // end system
151   libmesh_assert (io\&.reading());
152 
153   // Possibly clear data structures and start from scratch\&.
154   if (read_header_in)
155     this->clear ();
156 
157   // Figure out if we need to read infinite element information\&.
158   // This will be true if the version string contains " with infinite elements"
159   const bool read_ifem_info =
160     (version\&.rfind(" with infinite elements") < version\&.size()) ||
161     libMesh::on_command_line ("--read_ifem_systems");
162 
163 
164   {
165     // 5\&.)
166     // Read the number of variables in the system
167     unsigned int nv=0;
168     if (this->processor_id() == 0)
169       io\&.data (nv);
170     this->comm()\&.broadcast(nv);
171 
172     _written_var_indices\&.clear();
173     _written_var_indices\&.resize(nv, 0);
174 
175     for (unsigned int var=0; var<nv; var++)
176       {
177         // 6\&.)
178         // Read the name of the var-th variable
179         std::string var_name;
180         if (this->processor_id() == 0)
181           io\&.data (var_name);
182         this->comm()\&.broadcast(var_name);
183 
184         // 6\&.1\&.)
185         std::set<subdomain_id_type> domains;
186         if (io\&.version() >= LIBMESH_VERSION_ID(0,7,2))
187           {
188             std::vector<subdomain_id_type> domain_array;
189             if (this->processor_id() == 0)
190               io\&.data (domain_array);
191             for (std::vector<subdomain_id_type>::iterator it = domain_array\&.begin(); it != domain_array\&.end(); ++it)
192               domains\&.insert(*it);
193           }
194         this->comm()\&.broadcast(domains);
195 
196         // 7\&.)
197         // Read the approximation order(s) of the var-th variable
198         int order=0;
199         if (this->processor_id() == 0)
200           io\&.data (order);
201         this->comm()\&.broadcast(order);
202 
203 
204         // do the same for infinite element radial_order
205         int rad_order=0;
206         if (read_ifem_info)
207           {
208             if (this->processor_id() == 0)
209               io\&.data(rad_order);
210             this->comm()\&.broadcast(rad_order);
211           }
212 
213         // Read the finite element type of the var-th variable
214         int fam=0;
215         if (this->processor_id() == 0)
216           io\&.data (fam);
217         this->comm()\&.broadcast(fam);
218         FEType type;
219         type\&.order  = static_cast<Order>(order);
220         type\&.family = static_cast<FEFamily>(fam);
221 
222         // Check for incompatibilities\&.  The shape function indexing was
223         // changed for the monomial and xyz finite element families to
224         // simplify extension to arbitrary p\&.  The consequence is that
225         // old restart files will not be read correctly\&.  This is expected
226         // to be an unlikely occurance, but catch it anyway\&.
227         if (read_legacy_format)
228           if ((type\&.family == MONOMIAL || type\&.family == XYZ) &&
229               ((type\&.order > 2 && this->get_mesh()\&.mesh_dimension() == 2) ||
230                (type\&.order > 1 && this->get_mesh()\&.mesh_dimension() == 3)))
231             {
232               libmesh_here();
233               libMesh::out << "*****************************************************************\n"
234                            << "* WARNING: reading a potentially incompatible restart file!!!   *\n"
235                            << "*  contact libmesh-users@lists\&.sourceforge\&.net for more details *\n"
236                            << "*****************************************************************"
237                            << std::endl;
238             }
239 
240         // Read additional information for infinite elements
241         int radial_fam=0;
242         int i_map=0;
243         if (read_ifem_info)
244           {
245             if (this->processor_id() == 0)
246               io\&.data (radial_fam);
247             this->comm()\&.broadcast(radial_fam);
248             if (this->processor_id() == 0)
249               io\&.data (i_map);
250             this->comm()\&.broadcast(i_map);
251           }
252 
253 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
254 
255         type\&.radial_order  = static_cast<Order>(rad_order);
256         type\&.radial_family = static_cast<FEFamily>(radial_fam);
257         type\&.inf_map       = static_cast<InfMapType>(i_map);
258 
259 #endif
260 
261         if (read_header_in)
262           {
263             if (domains\&.empty())
264               _written_var_indices[var] = this->add_variable (var_name, type);
265             else
266               _written_var_indices[var] = this->add_variable (var_name, type, &domains);
267           }
268         else
269           _written_var_indices[var] = this->variable_number(var_name);
270       }
271   }
272 
273   // 8\&.)
274   // Read the number of additional vectors\&.
275   unsigned int nvecs=0;
276   if (this->processor_id() == 0)
277     io\&.data (nvecs);
278   this->comm()\&.broadcast(nvecs);
279 
280   // If nvecs > 0, this means that write_additional_data
281   // was true when this file was written\&.  We will need to
282   // make use of this fact later\&.
283   if (nvecs > 0)
284     this->_additional_data_written = true;
285 
286   for (unsigned int vec=0; vec<nvecs; vec++)
287     {
288       // 9\&.)
289       // Read the name of the vec-th additional vector
290       std::string vec_name;
291       if (this->processor_id() == 0)
292         io\&.data (vec_name);
293       this->comm()\&.broadcast(vec_name);
294 
295       if (read_additional_data)
296         {
297           // Systems now can handle adding post-initialization vectors
298           //  libmesh_assert(this->_can_add_vectors);
299           // Some systems may have added their own vectors already
300           //  libmesh_assert_equal_to (this->_vectors\&.count(vec_name), 0);
301 
302           this->add_vector(vec_name);
303         }
304     }
305 }
.fi
.SS "void libMesh::System::read_legacy_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. 
.PP
Definition at line 309 of file system_io\&.C\&.
.PP
References libMesh::System::_additional_data_written, libMesh::System::_vectors, libMesh::System::_written_var_indices, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::Xdr::data(), end, libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::System::n_dofs(), libMesh::System::n_vars(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::Xdr::reading(), libMesh::System::solution, libMesh::sys, and libMesh::zero\&.
.PP
.nf
311 {
312   libmesh_deprecated();
313 
314   // This method implements the output of the vectors
315   // contained in this System object, embedded in the
316   // output of an EquationSystems<T_sys>\&.
317   //
318   //   10\&.) The global solution vector, re-ordered to be node-major
319   //       (More on this later\&.)
320   //
321   //      for each additional vector in the object
322   //
323   //      11\&.) The global additional vector, re-ordered to be
324   //           node-major (More on this later\&.)
325   libmesh_assert (io\&.reading());
326 
327   // read and reordering buffers
328   std::vector<Number> global_vector;
329   std::vector<Number> reordered_vector;
330 
331   // 10\&.)
332   // Read and set the solution vector
333   {
334     if (this->processor_id() == 0)
335       io\&.data (global_vector);
336     this->comm()\&.broadcast(global_vector);
337 
338     // Remember that the stored vector is node-major\&.
339     // We need to put it into whatever application-specific
340     // ordering we may have using the dof_map\&.
341     reordered_vector\&.resize(global_vector\&.size());
342 
343     //libMesh::out << "global_vector\&.size()=" << global_vector\&.size() << std::endl;
344     //libMesh::out << "this->n_dofs()=" << this->n_dofs() << std::endl;
345 
346     libmesh_assert_equal_to (global_vector\&.size(), this->n_dofs());
347 
348     dof_id_type cnt=0;
349 
350     const unsigned int sys = this->number();
351     const unsigned int nv  = this->_written_var_indices\&.size();
352     libmesh_assert_less_equal (nv, this->n_vars());
353 
354     for (unsigned int data_var=0; data_var<nv; data_var++)
355       {
356         const unsigned int var = _written_var_indices[data_var];
357 
358         // First reorder the nodal DOF values
359         {
360           MeshBase::node_iterator
361             it  = this->get_mesh()\&.nodes_begin(),
362             end = this->get_mesh()\&.nodes_end();
363 
364           for (; it != end; ++it)
365             for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
366               {
367                 libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
368                                              DofObject::invalid_id);
369 
370                 libmesh_assert_less (cnt, global_vector\&.size());
371 
372                 reordered_vector[(*it)->dof_number(sys, var, index)] =
373                   global_vector[cnt++];
374               }
375         }
376 
377         // Then reorder the element DOF values
378         {
379           MeshBase::element_iterator
380             it  = this->get_mesh()\&.active_elements_begin(),
381             end = this->get_mesh()\&.active_elements_end();
382 
383           for (; it != end; ++it)
384             for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
385               {
386                 libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
387                                              DofObject::invalid_id);
388 
389                 libmesh_assert_less (cnt, global_vector\&.size());
390 
391                 reordered_vector[(*it)->dof_number(sys, var, index)] =
392                   global_vector[cnt++];
393               }
394         }
395       }
396 
397     *(this->solution) = reordered_vector;
398   }
399 
400   // For each additional vector, simply go through the list\&.
401   // ONLY attempt to do this IF additional data was actually
402   // written to the file for this system (controlled by the
403   // _additional_data_written flag)\&.
404   if (this->_additional_data_written)
405     {
406       std::map<std::string, NumericVector<Number>* >::iterator
407         pos = this->_vectors\&.begin();
408 
409       for (; pos != this->_vectors\&.end(); ++pos)
410         {
411           // 11\&.)
412           // Read the values of the vec-th additional vector\&.
413           // Prior do _not_ clear, but fill with zero, since the
414           // additional vectors _have_ to have the same size
415           // as the solution vector
416           std::fill (global_vector\&.begin(), global_vector\&.end(), libMesh::zero);
417 
418           if (this->processor_id() == 0)
419             io\&.data (global_vector);
420           this->comm()\&.broadcast(global_vector);
421 
422           // If read_additional_data==true, then we will keep this vector, otherwise
423           // we are going to throw it away\&.
424           if (read_additional_data)
425             {
426               // Remember that the stored vector is node-major\&.
427               // We need to put it into whatever application-specific
428               // ordering we may have using the dof_map\&.
429               std::fill (reordered_vector\&.begin(),
430                          reordered_vector\&.end(),
431                          libMesh::zero);
432 
433               reordered_vector\&.resize(global_vector\&.size());
434 
435               libmesh_assert_equal_to (global_vector\&.size(), this->n_dofs());
436 
437               dof_id_type cnt=0;
438 
439               const unsigned int sys = this->number();
440               const unsigned int nv  = this->_written_var_indices\&.size();
441               libmesh_assert_less_equal (nv, this->n_vars());
442 
443               for (unsigned int data_var=0; data_var<nv; data_var++)
444                 {
445                   const unsigned int var = _written_var_indices[data_var];
446                   // First reorder the nodal DOF values
447                   {
448                     MeshBase::node_iterator
449                       it  = this->get_mesh()\&.nodes_begin(),
450                       end = this->get_mesh()\&.nodes_end();
451 
452                     for (; it!=end; ++it)
453                       for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
454                         {
455                           libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
456                                                        DofObject::invalid_id);
457 
458                           libmesh_assert_less (cnt, global_vector\&.size());
459 
460                           reordered_vector[(*it)->dof_number(sys, var, index)] =
461                             global_vector[cnt++];
462                         }
463                   }
464 
465                   // Then reorder the element DOF values
466                   {
467                     MeshBase::element_iterator
468                       it  = this->get_mesh()\&.active_elements_begin(),
469                       end = this->get_mesh()\&.active_elements_end();
470 
471                     for (; it!=end; ++it)
472                       for (unsigned int index=0; index<(*it)->n_comp(sys,var); index++)
473                         {
474                           libmesh_assert_not_equal_to ((*it)->dof_number(sys, var, index),
475                                                        DofObject::invalid_id);
476 
477                           libmesh_assert_less (cnt, global_vector\&.size());
478 
479                           reordered_vector[(*it)->dof_number(sys, var, index)] =
480                             global_vector[cnt++];
481                         }
482                   }
483                 }
484 
485               // use the overloaded operator=(std::vector) to assign the values
486               *(pos->second) = reordered_vector;
487             }
488         }
489     } // end if (_additional_data_written)
490 }
.fi
.SS "template<typename InValType > void libMesh::System::read_parallel_data (\fBXdr\fP &io, const boolread_additional_data)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will read an individual file for each processor in the simulation where the local solution components for that processor are stored\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Note that the actual IO is handled through the \fBXdr\fP class (to be renamed later?) which provides a uniform interface to both the XDR (eXternal Data Representation) interface and standard ASCII output\&. Thus this one section of code will read XDR or ASCII files with no changes\&.
.PP
Definition at line 495 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::System::_written_var_indices, libMesh::Xdr::data(), libMesh::dof_map, libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::Xdr::is_open(), libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::Xdr::reading(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::System::solution, libMesh::Variable::type(), and libMesh::System::variable()\&.
.PP
.nf
497 {
517   // PerfLog pl("IO Performance",false);
518   // pl\&.push("read_parallel_data");
519   dof_id_type total_read_size = 0;
520 
521   libmesh_assert (io\&.reading());
522   libmesh_assert (io\&.is_open());
523 
524   // build the ordered nodes and element maps\&.
525   // when writing/reading parallel files we need to iterate
526   // over our nodes/elements in order of increasing global id()\&.
527   // however, this is not guaranteed to be ordering we obtain
528   // by using the node_iterators/element_iterators directly\&.
529   // so build a set, sorted by id(), that provides the ordering\&.
530   // further, for memory economy build the set but then transfer
531   // its contents to vectors, which will be sorted\&.
532   std::vector<const DofObject*> ordered_nodes, ordered_elements;
533   {
534     std::set<const DofObject*, CompareDofObjectsByID>
535       ordered_nodes_set (this->get_mesh()\&.local_nodes_begin(),
536                          this->get_mesh()\&.local_nodes_end());
537 
538     ordered_nodes\&.insert(ordered_nodes\&.end(),
539                          ordered_nodes_set\&.begin(),
540                          ordered_nodes_set\&.end());
541   }
542   {
543     std::set<const DofObject*, CompareDofObjectsByID>
544       ordered_elements_set (this->get_mesh()\&.local_elements_begin(),
545                             this->get_mesh()\&.local_elements_end());
546 
547     ordered_elements\&.insert(ordered_elements\&.end(),
548                             ordered_elements_set\&.begin(),
549                             ordered_elements_set\&.end());
550   }
551 
552   //  std::vector<Number> io_buffer;
553   std::vector<InValType> io_buffer;
554 
555   // 9\&.)
556   //
557   // Actually read the solution components
558   // for the ith system to disk
559   io\&.data(io_buffer);
560 
561   total_read_size += io_buffer\&.size();
562 
563   const unsigned int sys_num = this->number();
564   const unsigned int nv      = this->_written_var_indices\&.size();
565   libmesh_assert_less_equal (nv, this->n_vars());
566 
567   dof_id_type cnt=0;
568 
569   // Loop over each non-SCALAR variable and each node, and read out the value\&.
570   for (unsigned int data_var=0; data_var<nv; data_var++)
571     {
572       const unsigned int var = _written_var_indices[data_var];
573       if(this->variable(var)\&.type()\&.family != SCALAR)
574         {
575           // First read the node DOF values
576           for (std::vector<const DofObject*>::const_iterator
577                  it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
578             for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
579               {
580                 libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
581                                              DofObject::invalid_id);
582                 libmesh_assert_less (cnt, io_buffer\&.size());
583                 this->solution->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
584               }
585 
586           // Then read the element DOF values
587           for (std::vector<const DofObject*>::const_iterator
588                  it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
589             for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
590               {
591                 libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
592                                              DofObject::invalid_id);
593                 libmesh_assert_less (cnt, io_buffer\&.size());
594                 this->solution->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
595               }
596         }
597     }
598 
599   // Finally, read the SCALAR variables on the last processor
600   for (unsigned int data_var=0; data_var<nv; data_var++)
601     {
602       const unsigned int var = _written_var_indices[data_var];
603       if(this->variable(var)\&.type()\&.family == SCALAR)
604         {
605           if (this->processor_id() == (this->n_processors()-1))
606             {
607               const DofMap& dof_map = this->get_dof_map();
608               std::vector<dof_id_type> SCALAR_dofs;
609               dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
610 
611               for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
612                 {
613                   this->solution->set( SCALAR_dofs[i], io_buffer[cnt++] );
614                 }
615             }
616         }
617     }
618 
619   // And we're done setting solution entries
620   this->solution->close();
621 
622   // Only read additional vectors if wanted
623   if (read_additional_data)
624     {
625       std::map<std::string, NumericVector<Number>* >::const_iterator
626         pos = _vectors\&.begin();
627 
628       for(; pos != this->_vectors\&.end(); ++pos)
629         {
630           cnt=0;
631           io_buffer\&.clear();
632 
633           // 10\&.)
634           //
635           // Actually read the additional vector components
636           // for the ith system to disk
637           io\&.data(io_buffer);
638 
639           total_read_size += io_buffer\&.size();
640 
641           // Loop over each non-SCALAR variable and each node, and read out the value\&.
642           for (unsigned int data_var=0; data_var<nv; data_var++)
643             {
644               const unsigned int var = _written_var_indices[data_var];
645               if(this->variable(var)\&.type()\&.family != SCALAR)
646                 {
647                   // First read the node DOF values
648                   for (std::vector<const DofObject*>::const_iterator
649                          it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
650                     for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
651                       {
652                         libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
653                                                      DofObject::invalid_id);
654                         libmesh_assert_less (cnt, io_buffer\&.size());
655                         pos->second->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
656                       }
657 
658                   // Then read the element DOF values
659                   for (std::vector<const DofObject*>::const_iterator
660                          it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
661                     for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
662                       {
663                         libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
664                                                      DofObject::invalid_id);
665                         libmesh_assert_less (cnt, io_buffer\&.size());
666                         pos->second->set((*it)->dof_number(sys_num, var, comp), io_buffer[cnt++]);
667                       }
668                 }
669             }
670 
671           // Finally, read the SCALAR variables on the last processor
672           for (unsigned int data_var=0; data_var<nv; data_var++)
673             {
674               const unsigned int var = _written_var_indices[data_var];
675               if(this->variable(var)\&.type()\&.family == SCALAR)
676                 {
677                   if (this->processor_id() == (this->n_processors()-1))
678                     {
679                       const DofMap& dof_map = this->get_dof_map();
680                       std::vector<dof_id_type> SCALAR_dofs;
681                       dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
682 
683                       for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
684                         {
685                           pos->second->set( SCALAR_dofs[i], io_buffer[cnt++] );
686                         }
687                     }
688                 }
689             }
690 
691           // And we're done setting entries for this variable
692           pos->second->close();
693         }
694     }
695 
696   // const Real
697   //   dt   = pl\&.get_elapsed_time(),
698   //   rate = total_read_size*sizeof(Number)/dt;
699 
700   // libMesh::err << "Read " << total_read_size << " \"Number\" values\n"
701   //     << " Elapsed time = " << dt << '\n'
702   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
703 
704   // pl\&.pop("read_parallel_data");
705 }
.fi
.SS "template void System::read_parallel_data< \fBReal\fP > (\fBXdr\fP &io, const boolread_additional_data)\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will read an individual file for each processor in the simulation where the local solution components for that processor are stored\&. 
.PP
Definition at line 1237 of file system\&.h\&.
.PP
.nf
1239   { read_parallel_data<Number>(io, read_additional_data); }
.fi
.SS "void libMesh::RBParametrized::read_parameter_data_from_files (const std::string &continuous_param_file_name, const std::string &discrete_param_file_name, const boolread_binary_data)\fC [inherited]\fP"
Read in the parameter ranges from files\&. 
.SS "virtual void libMesh::TransientRBConstruction::read_riesz_representors_from_files (const std::string &riesz_representors_dir, const boolwrite_binary_residual_representors)\fC [virtual]\fP"
Write out all the Riesz representor data to files\&. Override to read in transient data too\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "template<typename InValType > void libMesh::System::read_serialized_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inherited]\fP"
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. 
.PP
Definition at line 709 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::ParallelObject::processor_id(), and libMesh::System::solution\&.
.PP
.nf
711 {
712   // This method implements the input of the vectors
713   // contained in this System object, embedded in the
714   // output of an EquationSystems<T_sys>\&.
715   //
716   //   10\&.) The global solution vector, re-ordered to be node-major
717   //       (More on this later\&.)
718   //
719   //      for each additional vector in the object
720   //
721   //      11\&.) The global additional vector, re-ordered to be
722   //          node-major (More on this later\&.)
723   parallel_object_only();
724   std::string comment;
725 
726   // PerfLog pl("IO Performance",false);
727   // pl\&.push("read_serialized_data");
728   // std::size_t total_read_size = 0;
729 
730   // 10\&.)
731   // Read the global solution vector
732   {
733     // total_read_size +=
734     this->read_serialized_vector<InValType>(io, *this->solution);
735 
736     // get the comment
737     if (this->processor_id() == 0)
738       io\&.comment (comment);
739   }
740 
741   // 11\&.)
742   // Only read additional vectors if wanted
743   if (read_additional_data)
744     {
745       std::map<std::string, NumericVector<Number>* >::const_iterator
746         pos = _vectors\&.begin();
747 
748       for(; pos != this->_vectors\&.end(); ++pos)
749         {
750           // total_read_size +=
751           this->read_serialized_vector<InValType>(io, *pos->second);
752 
753           // get the comment
754           if (this->processor_id() == 0)
755             io\&.comment (comment);
756 
757         }
758     }
759 
760   // const Real
761   //   dt   = pl\&.get_elapsed_time(),
762   //   rate = total_read_size*sizeof(Number)/dt;
763 
764   // libMesh::out << "Read " << total_read_size << " \"Number\" values\n"
765   //     << " Elapsed time = " << dt << '\n'
766   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
767 
768   // pl\&.pop("read_serialized_data");
769 }
.fi
.SS "void libMesh::System::read_serialized_data (\fBXdr\fP &io, const boolread_additional_data = \fCtrue\fP)\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Reads additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. 
.PP
Definition at line 1195 of file system\&.h\&.
.PP
.nf
1197   { read_serialized_data<Number>(io, read_additional_data); }
.fi
.SS "template<typename InValType > std::size_t libMesh::System::read_serialized_vectors (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inherited]\fP"
Read a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 2193 of file system_io\&.C\&.
.PP
References libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshTools::n_elem(), n_nodes, libMesh::MeshBase::n_nodes(), libMesh::System::n_vars(), libMesh::ParallelObject::processor_id(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::Xdr::reading(), libMesh::SCALAR, libMesh::Variable::type(), and libMesh::System::variable()\&.
.PP
.nf
2195 {
2196   parallel_object_only();
2197 
2198   // Error checking
2199   // #ifndef NDEBUG
2200   //   // In parallel we better be reading a parallel vector -- if not
2201   //   // we will not set all of its components below!!
2202   //   if (this->n_processors() > 1)
2203   //     {
2204   //       libmesh_assert (vec\&.type() == PARALLEL ||
2205   //       vec\&.type() == GHOSTED);
2206   //     }
2207   // #endif
2208 
2209   libmesh_assert (io\&.reading());
2210 
2211   if (this->processor_id() == 0)
2212     {
2213       // sizes
2214       unsigned int num_vecs=0;
2215       dof_id_type vector_length=0;
2216 
2217       // Get the number of vectors
2218       io\&.data(num_vecs);
2219       // Get the buffer size
2220       io\&.data(vector_length);
2221 
2222       libmesh_assert_equal_to (num_vecs, vectors\&.size());
2223 
2224       if (num_vecs != 0)
2225         {
2226           libmesh_assert_not_equal_to (vectors[0], 0);
2227           libmesh_assert_equal_to     (vectors[0]->size(), vector_length);
2228         }
2229     }
2230 
2231   // no need to actually communicate these\&.
2232   // this->comm()\&.broadcast(num_vecs);
2233   // this->comm()\&.broadcast(vector_length);
2234 
2235   // Cache these - they are not free!
2236   const dof_id_type
2237     n_nodes = this->get_mesh()\&.n_nodes(),
2238     n_elem  = this->get_mesh()\&.n_elem();
2239 
2240   std::size_t read_length = 0\&.;
2241 
2242   //---------------------------------
2243   // Collect the values for all nodes
2244   read_length +=
2245     this->read_serialized_blocked_dof_objects (n_nodes,
2246                                                this->get_mesh()\&.local_nodes_begin(),
2247                                                this->get_mesh()\&.local_nodes_end(),
2248                                                InValType(),
2249                                                io,
2250                                                vectors);
2251 
2252   //------------------------------------
2253   // Collect the values for all elements
2254   read_length +=
2255     this->read_serialized_blocked_dof_objects (n_elem,
2256                                                this->get_mesh()\&.local_elements_begin(),
2257                                                this->get_mesh()\&.local_elements_end(),
2258                                                InValType(),
2259                                                io,
2260                                                vectors);
2261 
2262   //-------------------------------------------
2263   // Finally loop over all the SCALAR variables
2264   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2265     for (unsigned int var=0; var<this->n_vars(); var++)
2266       if(this->variable(var)\&.type()\&.family == SCALAR)
2267         {
2268           libmesh_assert_not_equal_to (vectors[vec], 0);
2269 
2270           read_length +=
2271             this->read_SCALAR_dofs (var, io, *vectors[vec]);
2272         }
2273 
2274   //---------------------------------------
2275   // last step - must close all the vectors
2276   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2277     {
2278       libmesh_assert_not_equal_to (vectors[vec], 0);
2279       vectors[vec]->close();
2280     }
2281 
2282   return read_length;
2283 }
.fi
.SS "std::size_t libMesh::System::read_serialized_vectors (\fBXdr\fP &io, const std::vector< \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inline]\fP, \fC [inherited]\fP"
Non-templated version for backward compatibility\&.
.PP
Read a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 1215 of file system\&.h\&.
.PP
.nf
1217   { return read_serialized_vectors<Number>(io, vectors); }
.fi
.SS "virtual void libMesh::RBConstruction::recompute_all_residual_terms (const boolcompute_inner_products = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
This function computes all of the residual representors, can be useful when restarting a basis training computation\&. If \fCcompute_inner_products\fP is false, we just compute the residual Riesz representors, whereas if true, we also compute all the corresponding inner product terms\&. 
.SS "virtual void \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::reinit ()\fC [virtual]\fP, \fC [inherited]\fP"
Reinitializes the member data fields associated with the system, so that, e\&.g\&., \fC\fBassemble()\fP\fP may be used\&. 
.PP
Reimplemented from \fBlibMesh::LinearImplicitSystem\fP\&.
.SS "void libMesh::LinearImplicitSystem::release_linear_solver (\fBLinearSolver\fP< \fBNumber\fP > *) const\fC [virtual]\fP, \fC [inherited]\fP"
Releases a pointer to a linear solver acquired by \fCthis->\fBget_linear_solver()\fP\fP 
.PP
Reimplemented from \fBlibMesh::ImplicitSystem\fP\&.
.PP
Definition at line 373 of file linear_implicit_system\&.C\&.
.PP
.nf
374 {
375 }
.fi
.SS "void libMesh::System::remove_vector (const std::string &vec_name)\fC [inherited]\fP"
Removes the additional vector \fCvec_name\fP from this system 
.PP
Definition at line 712 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, and libMesh::System::have_vector()\&.
.PP
Referenced by libMesh::AdjointRefinementEstimator::estimate_error()\&.
.PP
.nf
713 {
714   //Return if the vector does not exist
715   if ( !(this->have_vector(vec_name)) )
716     return;
717 
718   _vectors[vec_name]->clear();
719   delete _vectors[vec_name];
720   _vectors[vec_name] = NULL;
721 
722   _vectors\&.erase(vec_name);
723   _vector_projections\&.erase(vec_name);
724   _vector_types\&.erase(vec_name);
725 }
.fi
.SS "const \fBSparseMatrix\fP< \fBNumber\fP > * libMesh::ImplicitSystem::request_matrix (const std::string &mat_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to this system's \fIadditional\fP matrix named \fCmat_name\fP, or returns \fCNULL\fP if no matrix by that name exists\&. 
.RE
.PP

.PP
Definition at line 232 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_matrices\&.
.PP
Referenced by libMesh::ImplicitSystem::sensitivity_solve(), libMesh::NewtonSolver::solve(), and libMesh::LinearImplicitSystem::solve()\&.
.PP
.nf
233 {
234   // Make sure the matrix exists
235   const_matrices_iterator pos = _matrices\&.find (mat_name);
236 
237   if (pos == _matrices\&.end())
238     return NULL;
239 
240   return pos->second;
241 }
.fi
.SS "\fBSparseMatrix\fP< \fBNumber\fP > * libMesh::ImplicitSystem::request_matrix (const std::string &mat_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writable pointer to this system's \fIadditional\fP matrix named \fCmat_name\fP, or returns \fCNULL\fP if no matrix by that name exists\&. 
.RE
.PP

.PP
Definition at line 245 of file implicit_system\&.C\&.
.PP
References libMesh::ImplicitSystem::_matrices\&.
.PP
.nf
246 {
247   // Make sure the matrix exists
248   matrices_iterator pos = _matrices\&.find (mat_name);
249 
250   if (pos == _matrices\&.end())
251     return NULL;
252 
253   return pos->second;
254 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to the vector if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCNULL\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 727 of file system\&.C\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error()\&.
.PP
.nf
728 {
729   const_vectors_iterator pos = _vectors\&.find(vec_name);
730 
731   if (pos == _vectors\&.end())
732     return NULL;
733 
734   return pos->second;
735 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const std::string &vec_name)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the vector if this \fC\fBSystem\fP\fP has a vector associated with the given name, \fCNULL\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 739 of file system\&.C\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
740 {
741   vectors_iterator pos = _vectors\&.find(vec_name);
742 
743   if (pos == _vectors\&.end())
744     return NULL;
745 
746   return pos->second;
747 }
.fi
.SS "const \fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0), or returns \fCNULL\fP if the system has no such vector\&. 
.RE
.PP

.PP
Definition at line 751 of file system\&.C\&.
.PP
References libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
752 {
753   const_vectors_iterator v = vectors_begin();
754   const_vectors_iterator v_end = vectors_end();
755   unsigned int num = 0;
756   while((num<vec_num) && (v!=v_end))
757     {
758       num++;
759       ++v;
760     }
761   if (v==v_end)
762     return NULL;
763   return v->second;
764 }
.fi
.SS "\fBNumericVector\fP< \fBNumber\fP > * libMesh::System::request_vector (const unsigned intvec_num)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable pointer to this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0), or returns \fCNULL\fP if the system has no such vector\&. 
.RE
.PP

.PP
Definition at line 768 of file system\&.C\&.
.PP
References libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
769 {
770   vectors_iterator v = vectors_begin();
771   vectors_iterator v_end = vectors_end();
772   unsigned int num = 0;
773   while((num<vec_num) && (v!=v_end))
774     {
775       num++;
776       ++v;
777     }
778   if (v==v_end)
779     return NULL;
780   return v->second;
781 }
.fi
.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::reset_alternative_solver (\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > &ls, const std::pair< std::string, std::string > &orig)\fC [inherited]\fP"
Resets the PC (and iterative solver, if desired) in the passed-in LinearSolver object to the values specified in the pair of strings passed as the second argument\&. If the 'alternative_solver' string, defined below, is 'unchanged', this function does nothing\&. 
.SS "void libMesh::LinearImplicitSystem::restrict_solve_to (const \fBSystemSubset\fP *subset, const \fBSubsetSolveMode\fPsubset_solve_mode = \fC\fBSUBSET_ZERO\fP\fP)\fC [virtual]\fP, \fC [inherited]\fP"
After calling this method, any solve will be limited to the given subset\&. To disable this mode, call this method with \fCsubset\fP being a \fCNULL\fP pointer\&. 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 96 of file linear_implicit_system\&.C\&.
.PP
References libMesh::LinearImplicitSystem::_subset, libMesh::LinearImplicitSystem::_subset_solve_mode, and libMesh::SystemSubset::get_system()\&.
.PP
Referenced by libMesh::LinearImplicitSystem::clear()\&.
.PP
.nf
98 {
99   _subset = subset;
100   _subset_solve_mode = subset_solve_mode;
101   if(subset!=NULL)
102     {
103       libmesh_assert_equal_to (&subset->get_system(), this);
104     }
105 }
.fi
.SS "void libMesh::System::restrict_vectors ()\fC [virtual]\fP, \fC [inherited]\fP"
Restrict vectors after the mesh has coarsened 
.PP
Definition at line 319 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::_solution_projection, libMesh::System::_vector_projections, libMesh::System::_vector_types, libMesh::System::_vectors, libMesh::System::current_local_solution, libMesh::err, libMesh::GHOSTED, libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::System::project_vector(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::System::prolong_vectors(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
320 {
321 #ifdef LIBMESH_ENABLE_AMR
322   // Restrict the _vectors on the coarsened cells
323   for (vectors_iterator pos = _vectors\&.begin(); pos != _vectors\&.end(); ++pos)
324     {
325       NumericVector<Number>* v = pos->second;
326 
327       if (_vector_projections[pos->first])
328         this->project_vector (*v);
329       else
330         {
331           ParallelType type = _vector_types[pos->first];
332 
333           if(type == GHOSTED)
334             {
335 #ifdef LIBMESH_ENABLE_GHOSTED
336               pos->second->init (this->n_dofs(), this->n_local_dofs(),
337                                  _dof_map->get_send_list(), false,
338                                  GHOSTED);
339 #else
340               libMesh::err << "Cannot initialize ghosted vectors when they are not enabled\&." << std::endl;
341               libmesh_error();
342 #endif
343             }
344           else
345             pos->second->init (this->n_dofs(), this->n_local_dofs(), false, type);
346         }
347     }
348 
349   const std::vector<dof_id_type>& send_list = _dof_map->get_send_list ();
350 
351   // Restrict the solution on the coarsened cells
352   if (_solution_projection)
353     this->project_vector (*solution);
354 
355 #ifdef LIBMESH_ENABLE_GHOSTED
356   current_local_solution->init(this->n_dofs(),
357                                this->n_local_dofs(), send_list,
358                                false, GHOSTED);
359 #else
360   current_local_solution->init(this->n_dofs());
361 #endif
362 
363   if (_solution_projection)
364     solution->localize (*current_local_solution, send_list);
365 
366 #endif // LIBMESH_ENABLE_AMR
367 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::ImplicitSystem::sensitivity_solve (const \fBParameterVector\fP &parameters)\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system(s) (dR/du)*u_p = -dR/dp, for those parameters contained within \fCparameters\fP\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 321 of file implicit_system\&.C\&.
.PP
References libMesh::System::add_sensitivity_solution(), libMesh::System::assemble_before_solve, libMesh::ImplicitSystem::assemble_residual_derivatives(), libMesh::ImplicitSystem::assembly(), libMesh::SparseMatrix< T >::close(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::System::get_dof_map(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::System::get_sensitivity_rhs(), libMesh::System::get_sensitivity_solution(), libMesh::ImplicitSystem::matrix, libMesh::pc, libMesh::ImplicitSystem::release_linear_solver(), libMesh::ImplicitSystem::request_matrix(), libMesh::ParameterVector::size(), libMesh::LinearSolver< T >::solve(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
322 {
323   // Log how long the linear solve takes\&.
324   START_LOG("sensitivity_solve()", "ImplicitSystem");
325 
326   // The forward system should now already be solved\&.
327   // Now assemble the corresponding sensitivity system\&.
328 
329   if (this->assemble_before_solve)
330     {
331       // Build the Jacobian
332       this->assembly(false, true);
333       this->matrix->close();
334 
335       // Reset and build the RHS from the residual derivatives
336       this->assemble_residual_derivatives(parameters);
337     }
338 
339   // The sensitivity problem is linear
340   LinearSolver<Number> *linear_solver = this->get_linear_solver();
341 
342   // Our iteration counts and residuals will be sums of the individual
343   // results
344   std::pair<unsigned int, Real> solver_params =
345     this->get_linear_solve_parameters();
346   std::pair<unsigned int, Real> totalrval = std::make_pair(0,0\&.0);
347 
348   // Solve the linear system\&.
349   SparseMatrix<Number> *pc = this->request_matrix("Preconditioner");
350   for (unsigned int p=0; p != parameters\&.size(); ++p)
351     {
352       std::pair<unsigned int, Real> rval =
353         linear_solver->solve (*matrix, pc,
354                               this->add_sensitivity_solution(p),
355                               this->get_sensitivity_rhs(p),
356                               solver_params\&.second,
357                               solver_params\&.first);
358 
359       totalrval\&.first  += rval\&.first;
360       totalrval\&.second += rval\&.second;
361     }
362 
363   // The linear solver may not have fit our constraints exactly
364 #ifdef LIBMESH_ENABLE_CONSTRAINTS
365   for (unsigned int p=0; p != parameters\&.size(); ++p)
366     this->get_dof_map()\&.enforce_constraints_exactly
367       (*this, &this->get_sensitivity_solution(p),
368        /* homogeneous = */ true);
369 #endif
370 
371   this->release_linear_solver(linear_solver);
372 
373   // Stop logging the nonlinear solve
374   STOP_LOG("sensitivity_solve()", "ImplicitSystem");
375 
376   return totalrval;
377 }
.fi
.SS "void libMesh::System::set_adjoint_already_solved (boolsetting)\fC [inline]\fP, \fC [inherited]\fP"
Setter for the adjoint_already_solved boolean 
.PP
Definition at line 367 of file system\&.h\&.
.PP
References libMesh::System::adjoint_already_solved\&.
.PP
.nf
368   { adjoint_already_solved = setting;}
.fi
.SS "std::pair<std::string,std::string> \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_alternative_solver (\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > &ls)\fC [inherited]\fP"
Changes the current PC (and iterative solver, if desired) in the passed-in LinearSolver object to an alternative solver specified by the alternative_solver string stored in this class\&. You might use this to e\&.g\&. switch to a sparse direct solver for the multiple RHS solves executed during the update_residual_terms function\&. The return strings are names of the original PC and KSP objects, you can reset these using the \fBreset_alternative_solver()\fP function below\&. 
.SS "void libMesh::System::set_basic_system_only ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the system to be 'basic only': i\&.e\&. advanced system components such as \fBImplicitSystem\fP matrices may not be initialized\&. This is useful for efficiency in certain utility programs that never use \fBSystem::solve()\fP\&. This method must be called after the \fBSystem\fP or derived class is created but before it is initialized; e\&.g\&. from within \fBEquationSystems::read()\fP 
.PP
Definition at line 1943 of file system\&.h\&.
.PP
References libMesh::System::_basic_system_only\&.
.PP
Referenced by libMesh::EquationSystems::_read_impl()\&.
.PP
.nf
1944 {
1945   _basic_system_only = true;
1946 }
.fi
.SS "void libMesh::RBConstruction::set_constraint_assembly (\fBElemAssembly\fP &constraint_assembly_in)\fC [inherited]\fP"
Set the rb_assembly_expansion object\&. 
.SS "virtual void libMesh::RBConstruction::set_context_solution_vec (\fBNumericVector\fP< \fBNumber\fP > &vec)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Set current_local_solution = vec so that we can access vec from \fBFEMContext\fP during assembly\&. Override in subclasses if different behavior is required\&. 
.SS "void libMesh::RBConstruction::set_convergence_assertion_flag (boolflag)\fC [protected]\fP, \fC [inherited]\fP"
Setter for the flag determining if convergence should be checked after each solve\&. 
.SS "void libMesh::TransientRBConstruction::set_delta_N (const unsigned intnew_delta_N)\fC [inline]\fP"
Set delta_N, the number of basis functions we add to the RB space from each POD 
.PP
Definition at line 215 of file transient_rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::delta_N\&.
.PP
.nf
215 { this->delta_N = new_delta_N; }
.fi
.SS "void libMesh::RBTemporalDiscretization::set_delta_t (const \fBReal\fPdelta_t_in)\fC [inherited]\fP"

.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_deterministic_training_parameter_name (const std::string &name)\fC [inherited]\fP"
In some cases we only want to allow discrete parameter values, instead of parameters that may take any value in a specified interval\&. Here we provide a method to set the d Set the discrete values for parameter \fCmu\fP that are allowed in the training set\&. This must be called before the training set is generated\&. Set the name of the parameter that we will generate deterministic training parameters for\&. Defaults to 'NONE'\&. 
.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_deterministic_training_parameter_repeats (unsigned intrepeats)\fC [inherited]\fP"
Set the number of times each sample of the deterministic training parameter is repeated\&. 
.SS "\fBNumber\fP libMesh::TransientRBConstruction::set_error_temporal_data ()\fC [protected]\fP"
Set column k (i\&.e\&. the current time level) of temporal_data to the difference between the current solution and the orthogonal projection of the current solution onto the current RB space\&. 
.SS "void libMesh::RBTemporalDiscretization::set_euler_theta (const \fBReal\fPeuler_theta_in)\fC [inherited]\fP"

.SS "void libMesh::RBConstruction::set_inner_product_assembly (\fBElemAssembly\fP &inner_product_assembly_in)\fC [inherited]\fP"
Set the rb_assembly_expansion object\&. 
.SS "void libMesh::TransientRBConstruction::set_L2_assembly (\fBElemAssembly\fP &L2_assembly_in)"
Set the L2 object\&. 
.SS "void libMesh::TransientRBConstruction::set_max_truth_solves (intmax_truth_solves_in)\fC [inline]\fP"

.PP
Definition at line 203 of file transient_rb_construction\&.h\&.
.PP
References max_truth_solves\&.
.PP
.nf
203 { this->max_truth_solves = max_truth_solves_in; }
.fi
.SS "void libMesh::RBTemporalDiscretization::set_n_time_steps (const unsigned intK)\fC [inherited]\fP"

.SS "virtual void libMesh::RBConstruction::set_Nmax (unsigned intNmax)\fC [virtual]\fP, \fC [inherited]\fP"

.SS "void libMesh::RBParametrized::set_parameters (const \fBRBParameters\fP &params)\fC [inherited]\fP"
Set the current parameters to \fCparams\fP 
.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_params_from_training_set (unsigned intindex)\fC [protected]\fP, \fC [inherited]\fP"
Set parameters to the RBParameters stored in index \fCindex\fP of the training set\&. 
.SS "virtual void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_params_from_training_set_and_broadcast (unsigned intindex)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Load the specified training parameter and then broadcast to all processors\&. 
.SS "void libMesh::TransientRBConstruction::set_POD_tol (const \fBReal\fPPOD_tol_in)\fC [inline]\fP"

.PP
Definition at line 209 of file transient_rb_construction\&.h\&.
.PP
References POD_tol\&.
.PP
.nf
209 { this->POD_tol = POD_tol_in; }
.fi
.SS "void libMesh::RBConstruction::set_quiet_mode (boolquiet_mode_in)\fC [inline]\fP, \fC [inherited]\fP"
Set the quiet_mode flag\&. If quiet == false then we print out a lot of extra information during the Offline stage\&. 
.PP
Definition at line 190 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::quiet_mode\&.
.PP
.nf
191   { this->quiet_mode = quiet_mode_in; }
.fi
.SS "void libMesh::RBConstruction::set_rb_assembly_expansion (\fBRBAssemblyExpansion\fP &rb_assembly_expansion_in)\fC [inherited]\fP"
Set the rb_assembly_expansion object\&. 
.SS "void libMesh::RBConstruction::set_rb_construction_parameters (unsigned intn_training_samples_in, booldeterministic_training_in, std::stringalternative_solver_in, boolreuse_preconditioner_in, booluse_relative_bound_in_greedy_in, boolwrite_data_during_training_in, unsigned inttraining_parameters_random_seed_in, boolquiet_mode_in, unsigned intNmax_in, \fBReal\fPtraining_tolerance_in, \fBRBParameters\fPmu_min_in, \fBRBParameters\fPmu_max_in, std::map< std::string, std::vector< \fBReal\fP > >discrete_parameter_values_in, std::map< std::string, bool >log_scaling)\fC [inherited]\fP"
Set the state of this \fBRBConstruction\fP object based on the arguments to this function\&. 
.SS "void libMesh::RBConstruction::set_rb_evaluation (\fBRBEvaluation\fP &rb_eval_in)\fC [inherited]\fP"
Set the \fBRBEvaluation\fP object\&. 
.SS "void libMesh::RBTemporalDiscretization::set_time_step (const unsigned intk)\fC [inherited]\fP"

.SS "void \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::set_training_random_seed (unsigned intseed)\fC [inherited]\fP"
Set the seed that is used to randomly generate training parameters\&. 
.SS "void libMesh::RBConstruction::set_training_tolerance (\fBReal\fPnew_training_tolerance)\fC [inline]\fP, \fC [inherited]\fP"
Get/set the tolerance for the basis training\&. 
.PP
Definition at line 174 of file rb_construction\&.h\&.
.PP
References libMesh::RBConstruction::training_tolerance\&.
.PP
.nf
175   {this->training_tolerance = new_training_tolerance; }
.fi
.SS "void libMesh::System::set_vector_preservation (const std::string &vec_name, boolpreserve)\fC [inherited]\fP"
Allows one to set the boolean controlling whether the vector identified by vec_name should be 'preserved': projected to new meshes, saved, etc\&. 
.PP
Definition at line 888 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections\&.
.PP
.nf
890 {
891   _vector_projections[vec_name] = preserve;
892 }
.fi
.SS "void libMesh::LinearImplicitSystem::solve ()\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system A*x=b\&. 
.PP
Reimplemented from \fBlibMesh::ExplicitSystem\fP\&.
.PP
Reimplemented in \fBlibMesh::FrequencySystem\fP\&.
.PP
Definition at line 109 of file linear_implicit_system\&.C\&.
.PP
References libMesh::LinearImplicitSystem::_final_linear_residual, libMesh::LinearImplicitSystem::_n_linear_iterations, libMesh::LinearImplicitSystem::_shell_matrix, libMesh::LinearImplicitSystem::_subset, libMesh::LinearImplicitSystem::_subset_solve_mode, libMesh::LinearImplicitSystem::assemble(), libMesh::System::assemble_before_solve, libMesh::SystemSubset::dof_ids(), libMesh::Parameters::get(), libMesh::System::get_equation_systems(), libMesh::LinearImplicitSystem::linear_solver, libMesh::ImplicitSystem::matrix, libMesh::System::name(), libMesh::on_command_line(), libMesh::EquationSystems::parameters, libMesh::Real, libMesh::ImplicitSystem::request_matrix(), libMesh::ExplicitSystem::rhs, libMesh::System::solution, and libMesh::System::update()\&.
.PP
.nf
110 {
111   if (this->assemble_before_solve)
112     // Assemble the linear system
113     this->assemble ();
114 
115   // Log how long the linear solve takes\&.
116   // This gets done by the LinearSolver classes now [RHS]
117   // START_LOG("solve()", "System");
118 
119   // Get a reference to the EquationSystems
120   const EquationSystems& es =
121     this->get_equation_systems();
122 
123   // If the linear solver hasn't been initialized, we do so here\&.
124   if (libMesh::on_command_line("--solver_system_names"))
125     linear_solver->init((this->name()+"_")\&.c_str());
126   else
127     linear_solver->init();
128 
129   // Get the user-specifiied linear solver tolerance
130   const Real tol            =
131     es\&.parameters\&.get<Real>("linear solver tolerance");
132 
133   // Get the user-specified maximum # of linear solver iterations
134   const unsigned int maxits =
135     es\&.parameters\&.get<unsigned int>("linear solver maximum iterations");
136 
137   if(_subset!=NULL)
138     {
139       linear_solver->restrict_solve_to(&_subset->dof_ids(),_subset_solve_mode);
140     }
141 
142   // Solve the linear system\&.  Several cases:
143   std::pair<unsigned int, Real> rval = std::make_pair(0,0\&.0);
144   if(_shell_matrix)
145     // 1\&.) Shell matrix with or without user-supplied preconditioner\&.
146     rval = linear_solver->solve(*_shell_matrix, this->request_matrix("Preconditioner"), *solution, *rhs, tol, maxits);
147   else
148     // 2\&.) No shell matrix, with or without user-supplied preconditioner
149     rval = linear_solver->solve (*matrix, this->request_matrix("Preconditioner"), *solution, *rhs, tol, maxits);
150 
151   if(_subset!=NULL)
152     {
153       linear_solver->restrict_solve_to(NULL);
154     }
155 
156   // Store the number of linear iterations required to
157   // solve and the final residual\&.
158   _n_linear_iterations   = rval\&.first;
159   _final_linear_residual = rval\&.second;
160 
161   // Stop logging the linear solve
162   // This gets done by the LinearSolver classes now [RHS]
163   // STOP_LOG("solve()", "System");
164 
165   // Update the system after the solve
166   this->update();
167 }
.fi
.SS "\fBsys_type\fP& \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::system ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a clever pointer to the system\&. 
.RE
.PP

.PP
Definition at line 73 of file transient_system\&.h\&.
.PP
.nf
73 { return *this; }
.fi
.SS "virtual std::string \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::system_type () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC'Transient'\fP prepended to T::system_type()\&. Helps in identifying the system type in an equation system file\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual \fBReal\fP libMesh::TransientRBConstruction::train_reduced_basis (const std::string &directory_name = \fC'offline_data'\fP, const boolresize_rb_eval_data = \fCtrue\fP)\fC [virtual]\fP"
Train the reduced basis\&. Overloaded so that we can set the flag compute_truth_projection_error to true so that the calls to truth_solve during the basis construction will compute the projection error\&. Other calls to truth_solve generally do not need to perform these projection calculations\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::TransientRBConstruction::truth_assembly ()\fC [virtual]\fP"
Assemble the truth system in the transient linear case\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual \fBReal\fP libMesh::TransientRBConstruction::truth_solve (intwrite_interval)\fC [virtual]\fP"
Perform a truth solve at the current parameter\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::System::update ()\fC [virtual]\fP, \fC [inherited]\fP"
Update the local values to reflect the solution on neighboring processors\&. 
.PP
Definition at line 411 of file system\&.C\&.
.PP
References libMesh::System::_dof_map, libMesh::System::current_local_solution, libMesh::libmesh_assert(), and libMesh::System::solution\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::FEMSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), DMlibMeshFunction(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::EquationSystems::get_solution(), libMesh::FEMSystem::mesh_position_get(), libMesh::FEMSystem::postprocess(), libMesh::NewtonSolver::solve(), libMesh::ExplicitSystem::solve(), libMesh::LinearImplicitSystem::solve(), and libMesh::NonlinearImplicitSystem::solve()\&.
.PP
.nf
412 {
413   libmesh_assert(solution->closed());
414 
415   const std::vector<dof_id_type>& send_list = _dof_map->get_send_list ();
416 
417   // Check sizes
418   libmesh_assert_equal_to (current_local_solution->size(), solution->size());
419   // More processors than elements => empty send_list
420   //  libmesh_assert (!send_list\&.empty());
421   libmesh_assert_less_equal (send_list\&.size(), solution->size());
422 
423   // Create current_local_solution from solution\&.  This will
424   // put a local copy of solution into current_local_solution\&.
425   // Only the necessary values (specified by the send_list)
426   // are copied to minimize communication
427   solution->localize (*current_local_solution, send_list);
428 }
.fi
.SS "void libMesh::System::update_global_solution (std::vector< \fBNumber\fP > &global_soln) const\fC [inherited]\fP"
Fill the input vector \fCglobal_soln\fP so that it contains the global solution on all processors\&. Requires communication with all other processors\&. 
.PP
Definition at line 657 of file system\&.C\&.
.PP
References libMesh::System::solution\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::EquationSystems::build_discontinuous_solution_vector(), and libMesh::for()\&.
.PP
.nf
658 {
659   global_soln\&.resize (solution->size());
660 
661   solution->localize (global_soln);
662 }
.fi
.SS "void libMesh::System::update_global_solution (std::vector< \fBNumber\fP > &global_soln, const unsigned intdest_proc) const\fC [inherited]\fP"
Fill the input vector \fCglobal_soln\fP so that it contains the global solution on processor \fCdest_proc\fP\&. Requires communication with all other processors\&. 
.PP
Definition at line 666 of file system\&.C\&.
.PP
References libMesh::System::solution\&.
.PP
.nf
668 {
669   global_soln\&.resize        (solution->size());
670 
671   solution->localize_to_one (global_soln, dest_proc);
672 }
.fi
.SS "void libMesh::RBConstruction::update_greedy_param_list ()\fC [protected]\fP, \fC [inherited]\fP"
Update the list of Greedily chosen parameters with current_parameters\&. 
.SS "void libMesh::TransientRBConstruction::update_RB_initial_condition_all_N ()"
Compute the L2 projection of the initial condition onto the RB space for 1 <= N <= RB_size and store each projection in RB_initial_condition_matrix\&. 
.SS "virtual void libMesh::TransientRBConstruction::update_RB_system_matrices ()\fC [protected]\fP, \fC [virtual]\fP"
Compute the reduced basis matrices for the current basis\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::TransientRBConstruction::update_residual_terms (boolcompute_inner_products)\fC [protected]\fP, \fC [virtual]\fP"
Compute the terms that are combined `online' to determine the dual norm of the residual\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "virtual void libMesh::TransientRBConstruction::update_system ()\fC [protected]\fP, \fC [virtual]\fP"
Update the system after enriching the RB space\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::System::user_assembly ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached assembly function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1910 of file system\&.C\&.
.PP
References libMesh::System::_assemble_system_function, libMesh::System::_assemble_system_object, libMesh::System::_equation_systems, libMesh::System::Assembly::assemble(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::System::assemble()\&.
.PP
.nf
1911 {
1912   // Call the user-provided assembly function,
1913   // if it was provided
1914   if (_assemble_system_function != NULL)
1915     this->_assemble_system_function (_equation_systems, this->name());
1916 
1917   // \&.\&.\&.or the user-provided assembly object\&.
1918   else if (_assemble_system_object != NULL)
1919     this->_assemble_system_object->assemble();
1920 }
.fi
.SS "void libMesh::System::user_constrain ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached constraint function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1924 of file system\&.C\&.
.PP
References libMesh::System::_constrain_system_function, libMesh::System::_constrain_system_object, libMesh::System::_equation_systems, libMesh::System::Constraint::constrain(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), libMesh::System::init_data(), and libMesh::EquationSystems::reinit()\&.
.PP
.nf
1925 {
1926   // Call the user-provided constraint function,
1927   // if it was provided
1928   if (_constrain_system_function!= NULL)
1929     this->_constrain_system_function(_equation_systems, this->name());
1930 
1931   // \&.\&.\&.or the user-provided constraint object\&.
1932   else if (_constrain_system_object != NULL)
1933     this->_constrain_system_object->constrain();
1934 }
.fi
.SS "void libMesh::System::user_initialization ()\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached initialization function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1896 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_init_system_function, libMesh::System::_init_system_object, libMesh::System::Initialization::initialize(), and libMesh::System::name()\&.
.PP
Referenced by libMesh::System::init(), and libMesh::NewmarkSystem::initial_conditions()\&.
.PP
.nf
1897 {
1898   // Call the user-provided intialization function,
1899   // if it was provided
1900   if (_init_system_function != NULL)
1901     this->_init_system_function (_equation_systems, this->name());
1902 
1903   // \&.\&.\&.or the user-provided initialization object\&.
1904   else if (_init_system_object != NULL)
1905     this->_init_system_object->initialize();
1906 }
.fi
.SS "void libMesh::System::user_QOI (const \fBQoISet\fP &qoi_indices)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached quantity of interest function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1938 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_qoi_evaluate_function, libMesh::System::_qoi_evaluate_object, libMesh::System::name(), and libMesh::System::QOI::qoi()\&.
.PP
Referenced by libMesh::System::assemble_qoi()\&.
.PP
.nf
1939 {
1940   // Call the user-provided quantity of interest function,
1941   // if it was provided
1942   if (_qoi_evaluate_function != NULL)
1943     this->_qoi_evaluate_function(_equation_systems, this->name(), qoi_indices);
1944 
1945   // \&.\&.\&.or the user-provided QOI function object\&.
1946   else if (_qoi_evaluate_object != NULL)
1947     this->_qoi_evaluate_object->qoi(qoi_indices);
1948 }
.fi
.SS "void libMesh::System::user_QOI_derivative (const \fBQoISet\fP &qoi_indices)\fC [virtual]\fP, \fC [inherited]\fP"
Calls user's attached quantity of interest derivative function, or is overloaded by the user in derived classes\&. 
.PP
Definition at line 1952 of file system\&.C\&.
.PP
References libMesh::System::_equation_systems, libMesh::System::_qoi_evaluate_derivative_function, libMesh::System::_qoi_evaluate_derivative_object, libMesh::System::name(), and libMesh::System::QOIDerivative::qoi_derivative()\&.
.PP
Referenced by libMesh::System::assemble_qoi_derivative()\&.
.PP
.nf
1953 {
1954   // Call the user-provided quantity of interest derivative,
1955   // if it was provided
1956   if (_qoi_evaluate_derivative_function != NULL)
1957     this->_qoi_evaluate_derivative_function(_equation_systems, this->name(), qoi_indices);
1958 
1959   // \&.\&.\&.or the user-provided QOI derivative function object\&.
1960   else if (_qoi_evaluate_derivative_object != NULL)
1961     this->_qoi_evaluate_derivative_object->qoi_derivative(qoi_indices);
1962 }
.fi
.SS "const \fBVariable\fP & libMesh::System::variable (unsigned intvar) const\fC [inline]\fP, \fC [inherited]\fP"
Return a constant reference to \fC\fBVariable\fP\fP \fCvar\fP\&. 
.PP
Definition at line 1979 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::WrappedFunction< Output >::component(), libMesh::EquationSystems::get_solution(), libMesh::WrappedFunction< Output >::operator()(), libMesh::System::project_vector(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::System::write_header(), libMesh::System::write_parallel_data(), libMesh::System::write_serialized_vector(), and libMesh::System::write_serialized_vectors()\&.
.PP
.nf
1980 {
1981   libmesh_assert_less (i, _variables\&.size());
1982 
1983   return _variables[i];
1984 }
.fi
.SS "const \fBVariableGroup\fP & libMesh::System::variable_group (unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"
Return a constant reference to \fC\fBVariableGroup\fP\fP \fCvg\fP\&. 
.PP
Definition at line 1989 of file system\&.h\&.
.PP
References libMesh::System::_variable_groups\&.
.PP
Referenced by libMesh::System::get_info()\&.
.PP
.nf
1990 {
1991   libmesh_assert_less (vg, _variable_groups\&.size());
1992 
1993   return _variable_groups[vg];
1994 }
.fi
.SS "const std::string & libMesh::System::variable_name (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of variable \fCi\fP\&. 
.RE
.PP

.PP
Definition at line 1999 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::DiscontinuityMeasure::boundary_side_integration(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::WrappedFunction< Output >::component(), libMesh::ExactSolution::ExactSolution(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::WrappedFunction< Output >::operator()(), libMesh::petsc_auto_fieldsplit(), and libMesh::System::write_header()\&.
.PP
.nf
2000 {
2001   libmesh_assert_less (i, _variables\&.size());
2002 
2003   return _variables[i]\&.name();
2004 }
.fi
.SS "unsigned short int libMesh::System::variable_number (const std::string &var) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the variable number assoicated with the user-specified variable named \fCvar\fP\&. 
.RE
.PP

.PP
Definition at line 1240 of file system\&.C\&.
.PP
References libMesh::System::_variable_numbers, libMesh::System::_variables, and libMesh::err\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::for(), libMesh::System::read_header(), libMesh::System::variable_scalar_number(), libMesh::System::variable_type(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1241 {
1242   // Make sure the variable exists
1243   std::map<std::string, unsigned short int>::const_iterator
1244     pos = _variable_numbers\&.find(var);
1245 
1246   if (pos == _variable_numbers\&.end())
1247     {
1248       libMesh::err << "ERROR: variable "
1249                    << var
1250                    << " does not exist in this system!"
1251                    << std::endl;
1252       libmesh_error();
1253     }
1254   libmesh_assert_equal_to (_variables[pos->second]\&.name(), var);
1255 
1256   return pos->second;
1257 }
.fi
.SS "unsigned int libMesh::System::variable_scalar_number (const std::string &var, unsigned intcomponent) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
an index, starting from 0 for the first component of the first variable, and incrementing for each component of each (potentially vector-valued) variable in the system in order\&. For systems with only scalar-valued variables, this will be the same as \fCvariable_number(var)\fP 
.RE
.PP
Irony: currently our only non-scalar-valued variable type is SCALAR\&. 
.PP
Definition at line 2010 of file system\&.h\&.
.PP
References libMesh::System::variable_number()\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::WrappedFunction< Output >::component(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::WrappedFunction< Output >::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), and libMesh::System::project_vector()\&.
.PP
.nf
2012 {
2013   return variable_scalar_number(this->variable_number(var), component);
2014 }
.fi
.SS "unsigned int libMesh::System::variable_scalar_number (unsigned intvar_num, unsigned intcomponent) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
an index, starting from 0 for the first component of the first variable, and incrementing for each component of each (potentially vector-valued) variable in the system in order\&. For systems with only scalar-valued variables, this will be the same as \fCvar_num\fP 
.RE
.PP
Irony: currently our only non-scalar-valued variable type is SCALAR\&. 
.PP
Definition at line 2020 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
.nf
2022 {
2023   return _variables[var_num]\&.first_scalar_number() + component;
2024 }
.fi
.SS "const \fBFEType\fP & libMesh::System::variable_type (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type variable number \fCi\fP\&. 
.RE
.PP

.PP
Definition at line 2029 of file system\&.h\&.
.PP
References libMesh::System::_variables\&.
.PP
Referenced by libMesh::System::add_variable(), libMesh::System::add_variables(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::GMVIO::copy_nodal_solution(), libMesh::DGFEMContext::DGFEMContext(), libMesh::FEMContext::FEMContext(), libMesh::EquationSystems::get_solution(), libMesh::FEMSystem::init_context(), libMesh::System::write_header(), libMesh::EnsightIO::write_scalar_ascii(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
2030 {
2031   libmesh_assert_less (i, _variables\&.size());
2032 
2033   return _variables[i]\&.type();
2034 }
.fi
.SS "const \fBFEType\fP & libMesh::System::variable_type (const std::string &var) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element type for variable \fCvar\fP\&. 
.RE
.PP

.PP
Definition at line 2039 of file system\&.h\&.
.PP
References libMesh::System::_variables, and libMesh::System::variable_number()\&.
.PP
.nf
2040 {
2041   return _variables[this->variable_number(var)]\&.type();
2042 }
.fi
.SS "const std::string & libMesh::System::vector_name (const unsigned intvec_num) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of this system's \fIadditional\fP vector number \fCvec_num\fP (where the vectors are counted starting with 0)\&. 
.RE
.PP

.PP
Definition at line 855 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
856 {
857   const_vectors_iterator v = vectors_begin();
858   const_vectors_iterator v_end = vectors_end();
859   unsigned int num = 0;
860   while((num<vec_num) && (v!=v_end))
861     {
862       num++;
863       ++v;
864     }
865   libmesh_assert (v != v_end);
866   return v->first;
867 }
.fi
.SS "const std::string & libMesh::System::vector_name (const \fBNumericVector\fP< \fBNumber\fP > &vec_reference) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the name of a system vector, given a reference to that vector 
.RE
.PP

.PP
Definition at line 869 of file system\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::System::vectors_begin(), and libMesh::System::vectors_end()\&.
.PP
.nf
870 {
871   const_vectors_iterator v = vectors_begin();
872   const_vectors_iterator v_end = vectors_end();
873 
874   for(; v != v_end; ++v)
875     {
876       // Check if the current vector is the one whose name we want
877       if(&vec_reference == v->second)
878         break; // exit loop if it is
879     }
880 
881   // Before returning, make sure we didnt loop till the end and not find any match
882   libmesh_assert (v != v_end);
883 
884   // Return the string associated with the current vector
885   return v->first;
886 }
.fi
.SS "bool libMesh::System::vector_preservation (const std::string &vec_name) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the boolean describing whether the vector identified by vec_name should be 'preserved': projected to new meshes, saved, etc\&. 
.RE
.PP

.PP
Definition at line 896 of file system\&.C\&.
.PP
References libMesh::System::_vector_projections\&.
.PP
Referenced by libMesh::MemorySolutionHistory::store()\&.
.PP
.nf
897 {
898   if (_vector_projections\&.find(vec_name) == _vector_projections\&.end())
899     return false;
900 
901   return _vector_projections\&.find(vec_name)->second;
902 }
.fi
.SS "\fBSystem::vectors_iterator\fP libMesh::System::vectors_begin ()\fC [inline]\fP, \fC [inherited]\fP"
Beginning of vectors container 
.PP
Definition at line 2091 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_vector(), libMesh::System::request_vector(), libMesh::MemorySolutionHistory::store(), libMesh::VTKIO::system_vectors_to_vtk(), and libMesh::System::vector_name()\&.
.PP
.nf
2092 {
2093   return _vectors\&.begin();
2094 }
.fi
.SS "\fBSystem::const_vectors_iterator\fP libMesh::System::vectors_begin () const\fC [inline]\fP, \fC [inherited]\fP"
Beginning of vectors container 
.PP
Definition at line 2097 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
2098 {
2099   return _vectors\&.begin();
2100 }
.fi
.SS "\fBSystem::vectors_iterator\fP libMesh::System::vectors_end ()\fC [inline]\fP, \fC [inherited]\fP"
End of vectors container 
.PP
Definition at line 2103 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::System::get_vector(), libMesh::System::request_vector(), libMesh::MemorySolutionHistory::store(), libMesh::VTKIO::system_vectors_to_vtk(), and libMesh::System::vector_name()\&.
.PP
.nf
2104 {
2105   return _vectors\&.end();
2106 }
.fi
.SS "\fBSystem::const_vectors_iterator\fP libMesh::System::vectors_end () const\fC [inline]\fP, \fC [inherited]\fP"
End of vectors container 
.PP
Definition at line 2109 of file system\&.h\&.
.PP
References libMesh::System::_vectors\&.
.PP
.nf
2110 {
2111   return _vectors\&.end();
2112 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights, const \fBQoISet\fP &qoi_indices = \fC\fBQoISet\fP()\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system(s) (dR/du)^T*z_w = sum(w_p*(d^2q/dudp - d^2R/dudp*z)), for those parameters p contained within \fCparameters\fP, weighted by the values w_p found within \fCweights\fP\&.
.PP
Assumes that adjoint_solve has already calculated z for each qoi in \fCqoi_indices\fP\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 436 of file implicit_system\&.C\&.
.PP
References libMesh::System::add_weighted_sensitivity_adjoint_solution(), libMesh::ExplicitSystem::assemble_qoi_derivative(), libMesh::ImplicitSystem::assembly(), libMesh::NumericVector< T >::close(), libMesh::SparseMatrix< T >::close(), libMesh::ParameterVector::deep_copy(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::System::get_adjoint_rhs(), libMesh::System::get_adjoint_solution(), libMesh::System::get_dof_map(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::SparseMatrix< T >::get_transpose(), libMesh::System::get_weighted_sensitivity_adjoint_solution(), libMesh::DofMap::has_adjoint_dirichlet_boundaries(), libMesh::QoISet::has_index(), libMesh::libmesh_assert(), libMesh::ImplicitSystem::matrix, libMesh::System::qoi, libMesh::Real, libMesh::ImplicitSystem::release_linear_solver(), libMesh::ExplicitSystem::rhs, libMesh::LinearSolver< T >::solve(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TOLERANCE, libMesh::ParameterVector::value_copy(), libMesh::SparseMatrix< T >::vector_mult_add(), and libMesh::NumericVector< T >::zero_clone()\&.
.PP
.nf
439 {
440   // Log how long the linear solve takes\&.
441   START_LOG("weighted_sensitivity_adjoint_solve()", "ImplicitSystem");
442 
443   // We currently get partial derivatives via central differencing
444   const Real delta_p = TOLERANCE;
445 
446   // The forward system should now already be solved\&.
447   // The adjoint system should now already be solved\&.
448   // Now we're assembling a weighted sum of adjoint-adjoint systems:
449   //
450   // dR/du (u, sum_l(w_l*z^l)) = sum_l(w_l*(Q''_ul - R''_ul (u, z)))
451 
452   // FIXME: The derivation here does not yet take adjoint boundary
453   // conditions into account\&.
454   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
455     if (qoi_indices\&.has_index(i))
456       libmesh_assert(!this->get_dof_map()\&.has_adjoint_dirichlet_boundaries(i));
457 
458   // We'll assemble the rhs first, because the R'' term will require
459   // perturbing the jacobian
460 
461   // We'll use temporary rhs vectors, because we haven't (yet) found
462   // any good reasons why users might want to save these:
463 
464   std::vector<NumericVector<Number> *> temprhs(this->qoi\&.size());
465   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
466     if (qoi_indices\&.has_index(i))
467       temprhs[i] = this->rhs->zero_clone()\&.release();
468 
469   // We approximate the _l partial derivatives via a central
470   // differencing perturbation in the w_l direction:
471   //
472   // sum_l(w_l*v_l) ~= (v(p + dp*w_l*e_l) - v(p - dp*w_l*e_l))/(2*dp)
473 
474   // PETSc doesn't implement SGEMX, so neither does NumericVector,
475   // so we want to avoid calculating f -= R'*z\&.  We'll thus evaluate
476   // the above equation by first adding -v(p+dp\&.\&.\&.), then multiplying
477   // the intermediate result vectors by -1, then adding -v(p-dp\&.\&.\&.),
478   // then finally dividing by 2*dp\&.
479 
480   ParameterVector oldparameters, parameterperturbation;
481   parameters\&.deep_copy(oldparameters);
482   weights\&.deep_copy(parameterperturbation);
483   parameterperturbation *= delta_p;
484   parameters += parameterperturbation;
485 
486   this->assembly(false, true);
487   this->matrix->close();
488 
489   // Take the discrete adjoint, so that we can calculate R_u(u,z) with
490   // a matrix-vector product of R_u and z\&.
491   matrix->get_transpose(*matrix);
492 
493   this->assemble_qoi_derivative(qoi_indices);
494   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
495     if (qoi_indices\&.has_index(i))
496       {
497         this->get_adjoint_rhs(i)\&.close();
498         *(temprhs[i]) -= this->get_adjoint_rhs(i);
499         this->matrix->vector_mult_add(*(temprhs[i]), this->get_adjoint_solution(i));
500         *(temprhs[i]) *= -1\&.0;
501       }
502 
503   oldparameters\&.value_copy(parameters);
504   parameterperturbation *= -1\&.0;
505   parameters += parameterperturbation;
506 
507   this->assembly(false, true);
508   this->matrix->close();
509   matrix->get_transpose(*matrix);
510 
511   this->assemble_qoi_derivative(qoi_indices);
512   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
513     if (qoi_indices\&.has_index(i))
514       {
515         this->get_adjoint_rhs(i)\&.close();
516         *(temprhs[i]) -= this->get_adjoint_rhs(i);
517         this->matrix->vector_mult_add(*(temprhs[i]), this->get_adjoint_solution(i));
518         *(temprhs[i]) /= (2\&.0*delta_p);
519       }
520 
521   // Finally, assemble the jacobian at the non-perturbed parameter
522   // values\&.  Ignore assemble_before_solve; if we had a good
523   // non-perturbed matrix before we've already overwritten it\&.
524   oldparameters\&.value_copy(parameters);
525 
526   // if (this->assemble_before_solve)
527   {
528     // Build the Jacobian
529     this->assembly(false, true);
530     this->matrix->close();
531 
532     // Take the discrete adjoint
533     matrix->get_transpose(*matrix);
534   }
535 
536   // The weighted adjoint-adjoint problem is linear
537   LinearSolver<Number> *linear_solver = this->get_linear_solver();
538 
539   // Our iteration counts and residuals will be sums of the individual
540   // results
541   std::pair<unsigned int, Real> solver_params =
542     this->get_linear_solve_parameters();
543   std::pair<unsigned int, Real> totalrval = std::make_pair(0,0\&.0);
544 
545   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
546     if (qoi_indices\&.has_index(i))
547       {
548         const std::pair<unsigned int, Real> rval =
549           linear_solver->solve (*matrix, this->add_weighted_sensitivity_adjoint_solution(i),
550                                 *(temprhs[i]),
551                                 solver_params\&.second,
552                                 solver_params\&.first);
553 
554         totalrval\&.first  += rval\&.first;
555         totalrval\&.second += rval\&.second;
556       }
557 
558   this->release_linear_solver(linear_solver);
559 
560   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
561     if (qoi_indices\&.has_index(i))
562       delete temprhs[i];
563 
564   // The linear solver may not have fit our constraints exactly
565 #ifdef LIBMESH_ENABLE_CONSTRAINTS
566   for (unsigned int i=0; i != this->qoi\&.size(); ++i)
567     if (qoi_indices\&.has_index(i))
568       this->get_dof_map()\&.enforce_constraints_exactly
569         (*this, &this->get_weighted_sensitivity_adjoint_solution(i),
570          /* homogeneous = */ true);
571 #endif
572 
573   // Stop logging the nonlinear solve
574   STOP_LOG("weighted_sensitivity_adjoint_solve()", "ImplicitSystem");
575 
576   return totalrval;
577 }
.fi
.SS "std::pair< unsigned int, \fBReal\fP > libMesh::ImplicitSystem::weighted_sensitivity_solve (const \fBParameterVector\fP &parameters, const \fBParameterVector\fP &weights)\fC [virtual]\fP, \fC [inherited]\fP"
Assembles & solves the linear system(s) (dR/du)*u_w = sum(w_p*-dR/dp), for those parameters p contained within \fCparameters\fP weighted by the values w_p found within \fCweights\fP\&.
.PP
Returns a pair with the total number of linear iterations performed and the (sum of the) final residual norms 
.PP
Reimplemented from \fBlibMesh::System\fP\&.
.PP
Definition at line 582 of file implicit_system\&.C\&.
.PP
References libMesh::System::add_weighted_sensitivity_solution(), libMesh::ImplicitSystem::assembly(), libMesh::NumericVector< T >::clone(), libMesh::NumericVector< T >::close(), libMesh::SparseMatrix< T >::close(), libMesh::ParameterVector::deep_copy(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::System::get_dof_map(), libMesh::ImplicitSystem::get_linear_solve_parameters(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::System::get_weighted_sensitivity_solution(), libMesh::ImplicitSystem::matrix, libMesh::Real, libMesh::ImplicitSystem::release_linear_solver(), libMesh::ExplicitSystem::rhs, libMesh::LinearSolver< T >::solve(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TOLERANCE, and libMesh::ParameterVector::value_copy()\&.
.PP
.nf
584 {
585   // Log how long the linear solve takes\&.
586   START_LOG("weighted_sensitivity_solve()", "ImplicitSystem");
587 
588   // We currently get partial derivatives via central differencing
589   const Real delta_p = TOLERANCE;
590 
591   // The forward system should now already be solved\&.
592 
593   // Now we're assembling a weighted sum of sensitivity systems:
594   //
595   // dR/du (u, v)(sum(w_l*u'_l)) = -sum_l(w_l*R'_l (u, v)) forall v
596 
597   // We'll assemble the rhs first, because the R' term will require
598   // perturbing the system, and some applications may not be able to
599   // assemble a perturbed residual without simultaneously constructing
600   // a perturbed jacobian\&.
601 
602   // We approximate the _l partial derivatives via a central
603   // differencing perturbation in the w_l direction:
604   //
605   // sum_l(w_l*v_l) ~= (v(p + dp*w_l*e_l) - v(p - dp*w_l*e_l))/(2*dp)
606 
607   ParameterVector oldparameters, parameterperturbation;
608   parameters\&.deep_copy(oldparameters);
609   weights\&.deep_copy(parameterperturbation);
610   parameterperturbation *= delta_p;
611   parameters += parameterperturbation;
612 
613   this->assembly(true, false);
614   this->rhs->close();
615 
616   AutoPtr<NumericVector<Number> > temprhs = this->rhs->clone();
617 
618   oldparameters\&.value_copy(parameters);
619   parameterperturbation *= -1\&.0;
620   parameters += parameterperturbation;
621 
622   this->assembly(true, false);
623   this->rhs->close();
624 
625   *temprhs -= *(this->rhs);
626   *temprhs /= (2\&.0*delta_p);
627 
628   // Finally, assemble the jacobian at the non-perturbed parameter
629   // values
630   oldparameters\&.value_copy(parameters);
631 
632   // Build the Jacobian
633   this->assembly(false, true);
634   this->matrix->close();
635 
636   // The weighted sensitivity problem is linear
637   LinearSolver<Number> *linear_solver = this->get_linear_solver();
638 
639   std::pair<unsigned int, Real> solver_params =
640     this->get_linear_solve_parameters();
641 
642   const std::pair<unsigned int, Real> rval =
643     linear_solver->solve (*matrix, this->add_weighted_sensitivity_solution(),
644                           *temprhs,
645                           solver_params\&.second,
646                           solver_params\&.first);
647 
648   this->release_linear_solver(linear_solver);
649 
650   // The linear solver may not have fit our constraints exactly
651 #ifdef LIBMESH_ENABLE_CONSTRAINTS
652   this->get_dof_map()\&.enforce_constraints_exactly
653     (*this, &this->get_weighted_sensitivity_solution(),
654      /* homogeneous = */ true);
655 #endif
656 
657   // Stop logging the nonlinear solve
658   STOP_LOG("weighted_sensitivity_solve()", "ImplicitSystem");
659 
660   return rval;
661 }
.fi
.SS "void libMesh::System::write_header (\fBXdr\fP &io, const std::string &version, const boolwrite_additional_data) const\fC [inherited]\fP"
Writes the basic data header for this \fBSystem\fP\&. This method implements the output of a \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&. This warrants some documentation\&. The output of this part consists of 5 sections:
.PP
for this system
.PP
5\&.) The number of variables in the system (unsigned int)
.PP
for each variable in the system
.PP
6\&.) The name of the variable (string)
.PP
6\&.1\&.) subdomain where the variable lives
.PP
7\&.) Combined in an \fBFEType\fP:
.IP "\(bu" 2
The approximation order(s) of the variable (Order Enum, cast to int/s)
.IP "\(bu" 2
The finite element family/ies of the variable (FEFamily Enum, cast to int/s)
.PP
.PP
end variable loop
.PP
8\&.) The number of additional vectors (unsigned int),
.PP
for each additional vector in the system object
.PP
9\&.) the name of the additional vector (string)
.PP
end system
.PP
Definition at line 1268 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Variable::active_subdomains(), libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::FEType::inf_map, libMesh::libmesh_assert(), libMesh::System::n_vars(), libMesh::System::n_vectors(), libMesh::System::name(), libMesh::FEType::order, libMesh::ParallelObject::processor_id(), libMesh::FEType::radial_family, libMesh::FEType::radial_order, libMesh::System::variable(), libMesh::System::variable_name(), libMesh::System::variable_type(), and libMesh::Xdr::writing()\&.
.PP
.nf
1271 {
1305   libmesh_assert (io\&.writing());
1306 
1307 
1308   // Only write the header information
1309   // if we are processor 0\&.
1310   if (this->get_mesh()\&.processor_id() != 0)
1311     return;
1312 
1313   std::string comment;
1314   char buf[80];
1315 
1316   // 5\&.)
1317   // Write the number of variables in the system
1318 
1319   {
1320     // set up the comment
1321     comment = "# No\&. of Variables in System \"";
1322     comment += this->name();
1323     comment += "\"";
1324 
1325     unsigned int nv = this->n_vars();
1326     io\&.data (nv, comment\&.c_str());
1327   }
1328 
1329 
1330   for (unsigned int var=0; var<this->n_vars(); var++)
1331     {
1332       // 6\&.)
1333       // Write the name of the var-th variable
1334       {
1335         // set up the comment
1336         comment  = "#   Name, Variable No\&. ";
1337         std::sprintf(buf, "%u", var);
1338         comment += buf;
1339         comment += ", System \"";
1340         comment += this->name();
1341         comment += "\"";
1342 
1343         std::string var_name = this->variable_name(var);
1344         io\&.data (var_name, comment\&.c_str());
1345       }
1346 
1347       // 6\&.1\&.) Variable subdomains
1348       {
1349         // set up the comment
1350         comment  = "#     Subdomains, Variable \"";
1351         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1352         comment += buf;
1353         comment += "\", System \"";
1354         comment += this->name();
1355         comment += "\"";
1356 
1357         const std::set<subdomain_id_type> & domains = this->variable(var)\&.active_subdomains();
1358         std::vector<subdomain_id_type> domain_array;
1359         domain_array\&.assign(domains\&.begin(), domains\&.end());
1360         io\&.data (domain_array, comment\&.c_str());
1361       }
1362 
1363       // 7\&.)
1364       // Write the approximation order of the var-th variable
1365       // in this system
1366       {
1367         // set up the comment
1368         comment = "#     Approximation Order, Variable \"";
1369         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1370         comment += buf;
1371         comment += "\", System \"";
1372         comment += this->name();
1373         comment += "\"";
1374 
1375         int order = static_cast<int>(this->variable_type(var)\&.order);
1376         io\&.data (order, comment\&.c_str());
1377       }
1378 
1379 
1380 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
1381 
1382       // do the same for radial_order
1383       {
1384         comment = "#     Radial Approximation Order, Variable \"";
1385         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1386         comment += buf;
1387         comment += "\", System \"";
1388         comment += this->name();
1389         comment += "\"";
1390 
1391         int rad_order = static_cast<int>(this->variable_type(var)\&.radial_order);
1392         io\&.data (rad_order, comment\&.c_str());
1393       }
1394 
1395 #endif
1396 
1397       // Write the Finite Element type of the var-th variable
1398       // in this System
1399       {
1400         // set up the comment
1401         comment = "#     FE Family, Variable \"";
1402         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1403         comment += buf;
1404         comment += "\", System \"";
1405         comment += this->name();
1406         comment += "\"";
1407 
1408         const FEType& type = this->variable_type(var);
1409         int fam = static_cast<int>(type\&.family);
1410         io\&.data (fam, comment\&.c_str());
1411 
1412 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
1413 
1414         comment = "#     Radial FE Family, Variable \"";
1415         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1416         comment += buf;
1417         comment += "\", System \"";
1418         comment += this->name();
1419         comment += "\"";
1420 
1421         int radial_fam = static_cast<int>(type\&.radial_family);
1422         io\&.data (radial_fam, comment\&.c_str());
1423 
1424         comment = "#     Infinite Mapping Type, Variable \"";
1425         std::sprintf(buf, "%s", this->variable_name(var)\&.c_str());
1426         comment += buf;
1427         comment += "\", System \"";
1428         comment += this->name();
1429         comment += "\"";
1430 
1431         int i_map = static_cast<int>(type\&.inf_map);
1432         io\&.data (i_map, comment\&.c_str());
1433 #endif
1434       }
1435     } // end of the variable loop
1436 
1437   // 8\&.)
1438   // Write the number of additional vectors in the System\&.
1439   // If write_additional_data==false, then write zero for
1440   // the number of additional vectors\&.
1441   {
1442     {
1443       // set up the comment
1444       comment = "# No\&. of Additional Vectors, System \"";
1445       comment += this->name();
1446       comment += "\"";
1447 
1448       unsigned int nvecs = write_additional_data ? this->n_vectors () : 0;
1449       io\&.data (nvecs, comment\&.c_str());
1450     }
1451 
1452     if (write_additional_data)
1453       {
1454         std::map<std::string, NumericVector<Number>* >::const_iterator
1455           vec_pos = this->_vectors\&.begin();
1456         unsigned int cnt=0;
1457 
1458         for (; vec_pos != this->_vectors\&.end(); ++vec_pos)
1459           {
1460             // 9\&.)
1461             // write the name of the cnt-th additional vector
1462             comment =  "# Name of ";
1463             std::sprintf(buf, "%d", cnt++);
1464             comment += buf;
1465             comment += "th vector";
1466             std::string vec_name = vec_pos->first;
1467 
1468             io\&.data (vec_name, comment\&.c_str());
1469           }
1470       }
1471   }
1472 }
.fi
.SS "void libMesh::System::write_parallel_data (\fBXdr\fP &io, const boolwrite_additional_data) const\fC [inherited]\fP"
Writes additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method will create an individual file for each processor in the simulation where the local solution components for that processor will be stored\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Note that the actual IO is handled through the \fBXdr\fP class (to be renamed later?) which provides a uniform interface to both the XDR (eXternal Data Representation) interface and standard ASCII output\&. Thus this one section of code will read XDR or ASCII files with no changes\&.
.PP
Definition at line 1476 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Xdr::data(), libMesh::dof_map, libMesh::FEType::family, libMesh::System::get_dof_map(), libMesh::System::get_mesh(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::System::n_vars(), libMesh::System::name(), libMesh::System::number(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::DofMap::SCALAR_dof_indices(), libMesh::System::solution, libMesh::Variable::type(), libMesh::System::variable(), and libMesh::Xdr::writing()\&.
.PP
.nf
1478 {
1498   // PerfLog pl("IO Performance",false);
1499   // pl\&.push("write_parallel_data");
1500   // std::size_t total_written_size = 0;
1501 
1502   std::string comment;
1503 
1504   libmesh_assert (io\&.writing());
1505 
1506   std::vector<Number> io_buffer; io_buffer\&.reserve(this->solution->local_size());
1507 
1508   // build the ordered nodes and element maps\&.
1509   // when writing/reading parallel files we need to iterate
1510   // over our nodes/elements in order of increasing global id()\&.
1511   // however, this is not guaranteed to be ordering we obtain
1512   // by using the node_iterators/element_iterators directly\&.
1513   // so build a set, sorted by id(), that provides the ordering\&.
1514   // further, for memory economy build the set but then transfer
1515   // its contents to vectors, which will be sorted\&.
1516   std::vector<const DofObject*> ordered_nodes, ordered_elements;
1517   {
1518     std::set<const DofObject*, CompareDofObjectsByID>
1519       ordered_nodes_set (this->get_mesh()\&.local_nodes_begin(),
1520                          this->get_mesh()\&.local_nodes_end());
1521 
1522     ordered_nodes\&.insert(ordered_nodes\&.end(),
1523                          ordered_nodes_set\&.begin(),
1524                          ordered_nodes_set\&.end());
1525   }
1526   {
1527     std::set<const DofObject*, CompareDofObjectsByID>
1528       ordered_elements_set (this->get_mesh()\&.local_elements_begin(),
1529                             this->get_mesh()\&.local_elements_end());
1530 
1531     ordered_elements\&.insert(ordered_elements\&.end(),
1532                             ordered_elements_set\&.begin(),
1533                             ordered_elements_set\&.end());
1534   }
1535 
1536   const unsigned int sys_num = this->number();
1537   const unsigned int nv      = this->n_vars();
1538 
1539   // Loop over each non-SCALAR variable and each node, and write out the value\&.
1540   for (unsigned int var=0; var<nv; var++)
1541     if (this->variable(var)\&.type()\&.family != SCALAR)
1542       {
1543         // First write the node DOF values
1544         for (std::vector<const DofObject*>::const_iterator
1545                it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
1546           for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1547             {
1548               //libMesh::out << "(*it)->id()=" << (*it)->id() << std::endl;
1549               libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1550                                            DofObject::invalid_id);
1551 
1552               io_buffer\&.push_back((*this->solution)((*it)->dof_number(sys_num, var, comp)));
1553             }
1554 
1555         // Then write the element DOF values
1556         for (std::vector<const DofObject*>::const_iterator
1557                it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
1558           for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1559             {
1560               libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1561                                            DofObject::invalid_id);
1562 
1563               io_buffer\&.push_back((*this->solution)((*it)->dof_number(sys_num, var, comp)));
1564             }
1565       }
1566 
1567   // Finally, write the SCALAR data on the last processor
1568   for (unsigned int var=0; var<this->n_vars(); var++)
1569     if(this->variable(var)\&.type()\&.family == SCALAR)
1570       {
1571         if (this->processor_id() == (this->n_processors()-1))
1572           {
1573             const DofMap& dof_map = this->get_dof_map();
1574             std::vector<dof_id_type> SCALAR_dofs;
1575             dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
1576 
1577             for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
1578               {
1579                 io_buffer\&.push_back( (*this->solution)(SCALAR_dofs[i]) );
1580               }
1581           }
1582       }
1583 
1584   // 9\&.)
1585   //
1586   // Actually write the reordered solution vector
1587   // for the ith system to disk
1588 
1589   // set up the comment
1590   {
1591     comment = "# System \"";
1592     comment += this->name();
1593     comment += "\" Solution Vector";
1594   }
1595 
1596   io\&.data (io_buffer, comment\&.c_str());
1597 
1598   // total_written_size += io_buffer\&.size();
1599 
1600   // Only write additional vectors if wanted
1601   if (write_additional_data)
1602     {
1603       std::map<std::string, NumericVector<Number>* >::const_iterator
1604         pos = _vectors\&.begin();
1605 
1606       for(; pos != this->_vectors\&.end(); ++pos)
1607         {
1608           io_buffer\&.clear(); io_buffer\&.reserve( pos->second->local_size());
1609 
1610           // Loop over each non-SCALAR variable and each node, and write out the value\&.
1611           for (unsigned int var=0; var<nv; var++)
1612             if(this->variable(var)\&.type()\&.family != SCALAR)
1613               {
1614                 // First write the node DOF values
1615                 for (std::vector<const DofObject*>::const_iterator
1616                        it = ordered_nodes\&.begin(); it != ordered_nodes\&.end(); ++it)
1617                   for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1618                     {
1619                       libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1620                                                    DofObject::invalid_id);
1621 
1622                       io_buffer\&.push_back((*pos->second)((*it)->dof_number(sys_num, var, comp)));
1623                     }
1624 
1625                 // Then write the element DOF values
1626                 for (std::vector<const DofObject*>::const_iterator
1627                        it = ordered_elements\&.begin(); it != ordered_elements\&.end(); ++it)
1628                   for (unsigned int comp=0; comp<(*it)->n_comp(sys_num, var); comp++)
1629                     {
1630                       libmesh_assert_not_equal_to ((*it)->dof_number(sys_num, var, comp),
1631                                                    DofObject::invalid_id);
1632 
1633                       io_buffer\&.push_back((*pos->second)((*it)->dof_number(sys_num, var, comp)));
1634                     }
1635               }
1636 
1637           // Finally, write the SCALAR data on the last processor
1638           for (unsigned int var=0; var<this->n_vars(); var++)
1639             if(this->variable(var)\&.type()\&.family == SCALAR)
1640               {
1641                 if (this->processor_id() == (this->n_processors()-1))
1642                   {
1643                     const DofMap& dof_map = this->get_dof_map();
1644                     std::vector<dof_id_type> SCALAR_dofs;
1645                     dof_map\&.SCALAR_dof_indices(SCALAR_dofs, var);
1646 
1647                     for(unsigned int i=0; i<SCALAR_dofs\&.size(); i++)
1648                       {
1649                         io_buffer\&.push_back( (*pos->second)(SCALAR_dofs[i]) );
1650                       }
1651                   }
1652               }
1653 
1654           // 10\&.)
1655           //
1656           // Actually write the reordered additional vector
1657           // for this system to disk
1658 
1659           // set up the comment
1660           {
1661             comment = "# System \"";
1662             comment += this->name();
1663             comment += "\" Additional Vector \"";
1664             comment += pos->first;
1665             comment += "\"";
1666           }
1667 
1668           io\&.data (io_buffer, comment\&.c_str());
1669 
1670           // total_written_size += io_buffer\&.size();
1671         }
1672     }
1673 
1674   // const Real
1675   //   dt   = pl\&.get_elapsed_time(),
1676   //   rate = total_written_size*sizeof(Number)/dt;
1677 
1678   // libMesh::err << "Write " << total_written_size << " \"Number\" values\n"
1679   //     << " Elapsed time = " << dt << '\n'
1680   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
1681 
1682   // pl\&.pop("write_parallel_data");
1683 }
.fi
.SS "void libMesh::RBParametrized::write_parameter_data_to_files (const std::string &continuous_param_file_name, const std::string &discrete_param_file_name, const boolwrite_binary_data)\fC [inherited]\fP"
Write out the parameter ranges to files\&. 
.SS "virtual void libMesh::TransientRBConstruction::write_riesz_representors_to_files (const std::string &riesz_representors_dir, const boolwrite_binary_residual_representors)\fC [virtual]\fP"
Write out all the Riesz representor data to files\&. Override to write out transient data too\&. 
.PP
Reimplemented from \fBlibMesh::RBConstruction\fP\&.
.SS "void libMesh::System::write_serialized_data (\fBXdr\fP &io, const boolwrite_additional_data = \fCtrue\fP) const\fC [inherited]\fP"
Writes additional data, namely vectors, for this \fBSystem\fP\&. This method may safely be called on a distributed-memory mesh\&. This method implements the output of the vectors contained in this \fBSystem\fP object, embedded in the output of an EquationSystems<T_sys>\&.
.PP
9\&.) The global solution vector, re-ordered to be node-major (More on this later\&.)
.PP
for each additional vector in the object
.PP
10\&.) The global additional vector, re-ordered to be node-major (More on this later\&.)
.PP
Definition at line 1687 of file system_io\&.C\&.
.PP
References libMesh::System::_vectors, libMesh::Xdr::comment(), libMesh::System::name(), libMesh::ParallelObject::processor_id(), libMesh::System::solution, and libMesh::System::write_serialized_vector()\&.
.PP
.nf
1689 {
1703   parallel_object_only();
1704   std::string comment;
1705 
1706   // PerfLog pl("IO Performance",false);
1707   // pl\&.push("write_serialized_data");
1708   // std::size_t total_written_size = 0;
1709 
1710   // total_written_size +=
1711   this->write_serialized_vector(io, *this->solution);
1712 
1713   // set up the comment
1714   if (this->processor_id() == 0)
1715     {
1716       comment = "# System \"";
1717       comment += this->name();
1718       comment += "\" Solution Vector";
1719 
1720       io\&.comment (comment);
1721     }
1722 
1723   // Only write additional vectors if wanted
1724   if (write_additional_data)
1725     {
1726       std::map<std::string, NumericVector<Number>* >::const_iterator
1727         pos = _vectors\&.begin();
1728 
1729       for(; pos != this->_vectors\&.end(); ++pos)
1730         {
1731           // total_written_size +=
1732           this->write_serialized_vector(io, *pos->second);
1733 
1734           // set up the comment
1735           if (this->processor_id() == 0)
1736             {
1737               comment = "# System \"";
1738               comment += this->name();
1739               comment += "\" Additional Vector \"";
1740               comment += pos->first;
1741               comment += "\"";
1742               io\&.comment (comment);
1743             }
1744         }
1745     }
1746 
1747   // const Real
1748   //   dt   = pl\&.get_elapsed_time(),
1749   //   rate = total_written_size*sizeof(Number)/dt;
1750 
1751   // libMesh::out << "Write " << total_written_size << " \"Number\" values\n"
1752   //     << " Elapsed time = " << dt << '\n'
1753   //     << " Rate = " << rate/1\&.e6 << "(MB/sec)\n\n";
1754 
1755   // pl\&.pop("write_serialized_data");
1756 
1757 
1758 
1759 
1760   // // test the new method
1761   // {
1762   //   std::vector<std::string> names;
1763   //   std::vector<NumericVector<Number>*> vectors_to_write;
1764 
1765   //   names\&.push_back("Solution Vector");
1766   //   vectors_to_write\&.push_back(this->solution\&.get());
1767 
1768   //   // Only write additional vectors if wanted
1769   //   if (write_additional_data)
1770   //     {
1771   // std::map<std::string, NumericVector<Number>* >::const_iterator
1772   //   pos = _vectors\&.begin();
1773 
1774   // for(; pos != this->_vectors\&.end(); ++pos)
1775   //   {
1776   //     names\&.push_back("Additional Vector " + pos->first);
1777   //     vectors_to_write\&.push_back(pos->second);
1778   //   }
1779   //     }
1780 
1781   //   total_written_size =
1782   //     this->write_serialized_vectors (io, names, vectors_to_write);
1783 
1784   //   const Real
1785   //     dt2   = pl\&.get_elapsed_time(),
1786   //     rate2 = total_written_size*sizeof(Number)/(dt2-dt);
1787 
1788   //   libMesh::out << "Write (new) " << total_written_size << " \"Number\" values\n"
1789   //       << " Elapsed time = " << (dt2-dt) << '\n'
1790   //       << " Rate = " << rate2/1\&.e6 << "(MB/sec)\n\n";
1791 
1792   // }
1793 }
.fi
.SS "\fBdof_id_type\fP libMesh::System::write_serialized_vectors (\fBXdr\fP &io, const std::vector< const \fBNumericVector\fP< \fBNumber\fP > * > &vectors) const\fC [inherited]\fP"
Serialize & write a number of identically distributed vectors\&. This method allows for optimization for the multiple vector case by only communicating the metadata once\&. 
.PP
Definition at line 2287 of file system_io\&.C\&.
.PP
References libMesh::Xdr::data(), libMesh::FEType::family, libMesh::System::get_mesh(), libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshTools::n_elem(), n_nodes, libMesh::MeshBase::n_nodes(), libMesh::System::n_vars(), libMesh::ParallelObject::processor_id(), libMesh::SCALAR, libMesh::Variable::type(), libMesh::System::variable(), libMesh::System::write_SCALAR_dofs(), libMesh::System::write_serialized_blocked_dof_objects(), and libMesh::Xdr::writing()\&.
.PP
.nf
2289 {
2290   parallel_object_only();
2291 
2292   libmesh_assert (io\&.writing());
2293 
2294   // Cache these - they are not free!
2295   const dof_id_type
2296     n_nodes       = this->get_mesh()\&.n_nodes(),
2297     n_elem        = this->get_mesh()\&.n_elem();
2298 
2299   dof_id_type written_length = 0\&.;
2300 
2301   if (this->processor_id() == 0)
2302     {
2303       unsigned int
2304         n_vec    = libmesh_cast_int<unsigned int>(vectors\&.size());
2305       dof_id_type
2306         vec_size = vectors\&.empty() ? 0 : vectors[0]->size();
2307       // Set the number of vectors
2308       io\&.data(n_vec, "# number of vectors");
2309       // Set the buffer size
2310       io\&.data(vec_size, "# vector length");
2311     }
2312 
2313   //---------------------------------
2314   // Collect the values for all nodes
2315   written_length +=
2316     this->write_serialized_blocked_dof_objects (vectors,
2317                                                 n_nodes,
2318                                                 this->get_mesh()\&.local_nodes_begin(),
2319                                                 this->get_mesh()\&.local_nodes_end(),
2320                                                 io);
2321 
2322   //------------------------------------
2323   // Collect the values for all elements
2324   written_length +=
2325     this->write_serialized_blocked_dof_objects (vectors,
2326                                                 n_elem,
2327                                                 this->get_mesh()\&.local_elements_begin(),
2328                                                 this->get_mesh()\&.local_elements_end(),
2329                                                 io);
2330 
2331   //-------------------------------------------
2332   // Finally loop over all the SCALAR variables
2333   for (unsigned int vec=0; vec<vectors\&.size(); vec++)
2334     for (unsigned int var=0; var<this->n_vars(); var++)
2335       if(this->variable(var)\&.type()\&.family == SCALAR)
2336         {
2337           libmesh_assert_not_equal_to (vectors[vec], 0);
2338 
2339           written_length +=
2340             this->write_SCALAR_dofs (*vectors[vec], var, io);
2341         }
2342 
2343   return written_length;
2344 }
.fi
.SS "void libMesh::RBConstruction::zero_constrained_dofs_on_vector (\fBNumericVector\fP< \fBNumber\fP > &vector)\fC [inherited]\fP"
It is sometimes useful to be able to zero vector entries that correspond to constrained dofs\&. 
.SS "void libMesh::System::zero_variable (\fBNumericVector\fP< \fBNumber\fP > &v, unsigned intvar_num) const\fC [inherited]\fP"
Zeroes all dofs in \fCv\fP that correspond to variable number \fCvar_num\fP\&. 
.PP
Definition at line 1315 of file system\&.C\&.
.PP
References libMesh::MeshBase::active_local_elements_begin(), libMesh::MeshBase::active_local_elements_end(), libMesh::DofObject::dof_number(), libMesh::System::get_mesh(), libMesh::MeshBase::local_nodes_begin(), libMesh::MeshBase::local_nodes_end(), mesh, libMesh::DofObject::n_comp(), libMesh::System::n_vars(), libMesh::System::number(), and libMesh::NumericVector< T >::set()\&.
.PP
.nf
1316 {
1317   /* Make sure the call makes sense\&.  */
1318   libmesh_assert_less (var_num, this->n_vars());
1319 
1320   /* Get a reference to the mesh\&.  */
1321   const MeshBase& mesh = this->get_mesh();
1322 
1323   /* Check which system we are\&.  */
1324   const unsigned int sys_num = this->number();
1325 
1326   /* Loop over nodes\&.  */
1327   {
1328     MeshBase::const_node_iterator it = mesh\&.local_nodes_begin();
1329     const MeshBase::const_node_iterator end_it = mesh\&.local_nodes_end();
1330     for ( ; it != end_it; ++it)
1331       {
1332         const Node* node = *it;
1333         unsigned int n_comp = node->n_comp(sys_num,var_num);
1334         for(unsigned int i=0; i<n_comp; i++)
1335           {
1336             const dof_id_type index = node->dof_number(sys_num,var_num,i);
1337             v\&.set(index,0\&.0);
1338           }
1339       }
1340   }
1341 
1342   /* Loop over elements\&.  */
1343   {
1344     MeshBase::const_element_iterator it = mesh\&.active_local_elements_begin();
1345     const MeshBase::const_element_iterator end_it = mesh\&.active_local_elements_end();
1346     for ( ; it != end_it; ++it)
1347       {
1348         const Elem* elem = *it;
1349         unsigned int n_comp = elem->n_comp(sys_num,var_num);
1350         for(unsigned int i=0; i<n_comp; i++)
1351           {
1352             const dof_id_type index = elem->dof_number(sys_num,var_num,i);
1353             v\&.set(index,0\&.0);
1354           }
1355       }
1356   }
1357 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBReal\fP libMesh::LinearImplicitSystem::_final_linear_residual\fC [protected]\fP, \fC [inherited]\fP"
The final residual for the linear system Ax=b\&. 
.PP
Definition at line 195 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::final_linear_residual(), libMesh::LinearImplicitSystem::solve(), and libMesh::FrequencySystem::solve()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "unsigned int libMesh::LinearImplicitSystem::_n_linear_iterations\fC [protected]\fP, \fC [inherited]\fP"
The number of linear iterations required to solve the linear system Ax=b\&. 
.PP
Definition at line 190 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::n_linear_iterations(), libMesh::LinearImplicitSystem::solve(), and libMesh::FrequencySystem::solve()\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBShellMatrix\fP<\fBNumber\fP>* libMesh::LinearImplicitSystem::_shell_matrix\fC [protected]\fP, \fC [inherited]\fP"
User supplies shell matrix or \fCNULL\fP if no shell matrix is used\&. 
.PP
Definition at line 200 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::attach_shell_matrix(), libMesh::LinearImplicitSystem::get_shell_matrix(), and libMesh::LinearImplicitSystem::solve()\&.
.SS "const \fBSystemSubset\fP* libMesh::LinearImplicitSystem::_subset\fC [protected]\fP, \fC [inherited]\fP"
The current subset on which to solve (or \fCNULL\fP if none)\&. 
.PP
Definition at line 205 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::restrict_solve_to(), and libMesh::LinearImplicitSystem::solve()\&.
.SS "\fBSubsetSolveMode\fP libMesh::LinearImplicitSystem::_subset_solve_mode\fC [protected]\fP, \fC [inherited]\fP"
If restrict-solve-to-subset mode is active, this member decides what happens with the dofs outside the subset\&. 
.PP
Definition at line 211 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::restrict_solve_to(), and libMesh::LinearImplicitSystem::solve()\&.
.SS "std::string \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::alternative_solver\fC [protected]\fP, \fC [inherited]\fP"
Set this string to specify an alternative solver used in the \fBset_alternative_solver()\fP function above\&. Currently-supported values are: \&.) unchanged, to continue using the default truth solve solver \&.) amg, to use the BoomerAMG from Hypre (NOT for indefinite problems!) \&.) mumps, to use a sparse direct solver Note1: mumps and amg will only be available if PETSc has been compiled with them\&. Note2: RBConstruction::process_parameters_file() is responsible for reading in this value ('rb_alternative_solver') from file for RBConstruction-derived subclasses Note3: RBSCMSystem::process_parameters_file() reads this value ('scm_alternative_solver') for RBSCMSystem-derived subclasses 
.PP
Definition at line 271 of file rb_construction_base\&.h\&.
.SS "bool libMesh::System::assemble_before_solve\fC [inherited]\fP"
Flag which tells the system to whether or not to call the user assembly function during each call to \fBsolve()\fP\&. By default, every call to \fBsolve()\fP begins with a call to the user assemble, so this flag is true\&. (For explicit systems, 'solving' the system occurs during the assembly step, so this flag is always true for explicit systems\&.)
.PP
You will only want to set this to false if you need direct control over when the system is assembled, and are willing to track the state of its assembly yourself\&. An example of such a case is an implicit system with multiple right hand sides\&. In this instance, a single assembly would likely be followed with multiple calls to solve\&.
.PP
The frequency system and Newmark system have their own versions of this flag, called _finished_assemble, which might be able to be replaced with this more general concept\&. 
.PP
Definition at line 1410 of file system\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::adjoint_solve(), libMesh::ImplicitSystem::disable_cache(), libMesh::System::disable_cache(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::CondensedEigenSystem::solve(), libMesh::EigenSystem::solve(), and libMesh::LinearImplicitSystem::solve()\&.
.SS "bool libMesh::RBConstruction::assert_convergence\fC [protected]\fP, \fC [inherited]\fP"
A boolean flag to indicate whether to check for proper convergence after each solve\&. 
.PP
Definition at line 768 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::compute_RB_inner_product\fC [inherited]\fP"
Boolean flag to indicate whether we compute the RB_inner_product_matrix\&. This is false by default in \fBRBConstruction\fP since (in the default implementation) the RB inner-product matrix will just be the identity\&. But we may need the inner-product matrix subclasses\&. 
.PP
Definition at line 544 of file rb_construction\&.h\&.
.SS "bool libMesh::TransientRBConstruction::compute_truth_projection_error"
Boolean flag that indicates whether we will compute the projection error for the truth solution into the RB space (at every time level)\&. This typically only needs to true during a call to train_reduced_basis\&. 
.PP
Definition at line 295 of file transient_rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::constrained_problem\fC [inherited]\fP"
Boolean flag to indicate whether this is a constrained problem (e\&.g\&. Stokes) or not\&. 
.PP
Definition at line 494 of file rb_construction\&.h\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::RBConstruction::constraint_matrix\fC [inherited]\fP"
The constraint matrix, e\&.g\&. the pressure matrix entries in a Stokes problem\&. 
.PP
Definition at line 459 of file rb_construction\&.h\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::System::current_local_solution\fC [inherited]\fP"
All the values I need to compute my contribution to the simulation at hand\&. Think of this as the current solution with any ghost values needed from other processors\&. This vector is necessarily larger than the \fCsolution\fP vector in the case of a parallel simulation\&. The \fC\fBupdate()\fP\fP member is used to synchronize the contents of the \fCsolution\fP and \fCcurrent_local_solution\fP vectors\&. 
.PP
Definition at line 1469 of file system\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_snes_residual(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::clear(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::System::current_solution(), DMlibMeshFunction(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::EquationSystems::get_solution(), libMesh::System::init_data(), libMesh::FEMContext::pre_fe_reinit(), libMesh::System::project_solution(), libMesh::System::re_update(), libMesh::System::reinit(), libMesh::System::restrict_vectors(), and libMesh::System::update()\&.
.SS "unsigned int libMesh::RBConstruction::delta_N\fC [protected]\fP, \fC [inherited]\fP"
The number of basis functions that we add at each greedy step\&. This defaults to 1 in the steady case\&. 
.PP
Definition at line 742 of file rb_construction\&.h\&.
.PP
Referenced by libMesh::RBConstruction::get_delta_N(), and set_delta_N()\&.
.SS "bool libMesh::RBConstruction::enforce_constraints_exactly\fC [inherited]\fP"
Public member variable which we use to determine whether or not we enforce hanging-dof and/or periodic constraints exactly\&. This is primarily important in nonlinear problems where we may 'undersolve' Newton iterates for the sake of efficiency\&. 
.PP
Definition at line 559 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::exit_on_repeated_greedy_parameters\fC [inherited]\fP"
Boolean flag to indicate whether we exit the greedy if we select the same parameters twice in a row\&. In some problems this indicates that the greedy has 'saturated' typically due to numerical rounding effects\&. 
.PP
Definition at line 515 of file rb_construction\&.h\&.
.SS "int libMesh::System::extra_quadrature_order\fC [inherited]\fP"
A member int that can be employed to indicate increased or reduced quadrature order\&.
.PP
Note for \fBFEMSystem\fP users: By default, when calling the user-defined residual functions, the \fBFEMSystem\fP will first set up an appropriate \fBFEType::default_quadrature_rule()\fP object for performing the integration\&. This rule will integrate elements of order up to 2*p+1 exactly (where p is the sum of the base \fBFEType\fP and local p refinement levels), but if additional (or reduced) quadrature accuracy is desired then this extra_quadrature_order (default 0) will be added\&. 
.PP
Definition at line 1442 of file system\&.h\&.
.PP
Referenced by libMesh::FEMContext::FEMContext()\&.
.SS "std::vector< \fBNumericVector\fP<\fBNumber\fP>* > libMesh::RBConstruction::Fq_representor\fC [inherited]\fP"
Vector storing the residual representors associated with the right-hand side\&. These are basis independent and hence stored here, whereas the Aq_representors are stored in \fBRBEvaluation\fP 
.PP
Definition at line 479 of file rb_construction\&.h\&.
.SS "std::vector<\fBNumber\fP> libMesh::RBConstruction::Fq_representor_innerprods\fC [inherited]\fP"
Vectors storing the residual representor inner products to be used in computing the residuals online\&. We store the Fq representor norms here because they are independent of a reduced basis space\&. The basis dependent representors are stored in \fBRBEvaluation\fP\&. 
.PP
Definition at line 488 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::Fq_representor_innerprods_computed\fC [protected]\fP, \fC [inherited]\fP"
A boolean flag to indicate whether or not the Fq representor norms have already been computed --- used to make sure that we don't recompute them unnecessarily\&. 
.PP
Definition at line 762 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::impose_internal_dirichlet_BCs\fC [inherited]\fP"
Boolean flag to indicate whether we require a Dirichlet boundary condition on internal mesh dofs\&. This is useful for example in problems with subdomain-only-variables\&. 
.PP
Definition at line 529 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::impose_internal_fluxes\fC [inherited]\fP"
Boolean flag to indicate whether we impose 'fluxes' (i\&.e\&. element boundary contributions to the weak form) on internal element boundaries in the assembly routines\&. 
.PP
Definition at line 536 of file rb_construction\&.h\&.
.SS "std::string libMesh::TransientRBConstruction::init_filename"
The filename of the file containing the initial condition projected onto the truth mesh\&. 
.PP
Definition at line 301 of file transient_rb_construction\&.h\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::RBConstruction::inner_product_matrix\fC [inherited]\fP"
The inner product matrix\&. 
.PP
Definition at line 447 of file rb_construction\&.h\&.
.SS "\fBAutoPtr\fP< \fBNumericVector\fP<\fBNumber\fP> > \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::inner_product_storage_vector\fC [protected]\fP, \fC [inherited]\fP"
We keep an extra temporary vector that is useful for performing inner products (avoids unnecessary memory allocation/deallocation)\&. 
.PP
Definition at line 257 of file rb_construction_base\&.h\&.
.SS "\fBElemAssembly\fP* libMesh::TransientRBConstruction::L2_assembly\fC [protected]\fP"
Function pointer for assembling the L2 matrix\&. 
.PP
Definition at line 387 of file transient_rb_construction\&.h\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::TransientRBConstruction::L2_matrix"
The L2 matrix\&. 
.PP
Definition at line 258 of file transient_rb_construction\&.h\&.
.SS "\fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> > libMesh::LinearImplicitSystem::linear_solver\fC [inherited]\fP"
The \fC\fBLinearSolver\fP\fP defines the interface used to solve the linear_implicit system\&. This class handles all the details of interfacing with various linear algebra packages like PETSc or LASPACK\&. 
.PP
Definition at line 149 of file linear_implicit_system\&.h\&.
.PP
Referenced by libMesh::LinearImplicitSystem::clear(), libMesh::LinearImplicitSystem::get_linear_solver(), libMesh::LinearImplicitSystem::init_data(), libMesh::LinearImplicitSystem::reinit(), libMesh::LinearImplicitSystem::solve(), and libMesh::FrequencySystem::solve()\&.
.SS "std::vector< \fBSparseMatrix\fP<\fBNumber\fP>* > libMesh::TransientRBConstruction::M_q_vector"
Vector storing the Q_m matrices from the mass operator 
.PP
Definition at line 269 of file transient_rb_construction\&.h\&.
.SS "\fBSparseMatrix\fP<\fBNumber\fP>* libMesh::ImplicitSystem::matrix\fC [inherited]\fP"
The system matrix\&. Implicit systems are characterized by the need to solve the linear system Ax=b\&. This is the system matrix A\&. 
.PP
Definition at line 335 of file implicit_system\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::add_system_matrix(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::ImplicitSystem::assemble(), libMesh::FEMSystem::assembly(), libMesh::LinearImplicitSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::ImplicitSystem::clear(), libMesh::NewmarkSystem::compute_matrix(), libMesh::ContinuationSystem::continuation_solve(), libMesh::ImplicitSystem::init_matrices(), libMesh::ImplicitSystem::sensitivity_solve(), libMesh::NewtonSolver::solve(), libMesh::NoxNonlinearSolver< T >::solve(), libMesh::EigenTimeSolver::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.SS "int libMesh::TransientRBConstruction::max_truth_solves\fC [protected]\fP"
Maximum number of truth solves in the POD-Greedy\&. This can be different from Nmax in the transient case since we may add more than one basis function per truth solve\&. If negative, it's ignored\&. 
.PP
Definition at line 382 of file transient_rb_construction\&.h\&.
.PP
Referenced by get_max_truth_solves(), and set_max_truth_solves()\&.
.SS "unsigned int libMesh::RBConstruction::Nmax\fC [protected]\fP, \fC [inherited]\fP"
Maximum number of reduced basis functions we are willing to use\&. 
.PP
Definition at line 736 of file rb_construction\&.h\&.
.PP
Referenced by libMesh::RBConstruction::get_Nmax()\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::RBConstruction::non_dirichlet_inner_product_matrix\fC [inherited]\fP"
The inner product matrix without Dirichlet conditions enforced\&. (This is only computed if store_non_dirichlet_operators == true\&.) 
.PP
Definition at line 453 of file rb_construction\&.h\&.
.SS "\fBAutoPtr\fP< \fBSparseMatrix\fP<\fBNumber\fP> > libMesh::TransientRBConstruction::non_dirichlet_L2_matrix"
The L2 matrix without Dirichlet conditions enforced\&. (This is only computed if store_non_dirichlet_operators == true\&.) 
.PP
Definition at line 264 of file transient_rb_construction\&.h\&.
.SS "std::vector< \fBSparseMatrix\fP<\fBNumber\fP>* > libMesh::TransientRBConstruction::non_dirichlet_M_q_vector"
We sometimes also need a second set of M_q matrices that do not have the Dirichlet boundary conditions enforced\&. 
.PP
Definition at line 276 of file transient_rb_construction\&.h\&.
.SS "bool libMesh::TransientRBConstruction::nonzero_initialization"
Boolean flag to indicate whether we are using a non-zero initialization\&. If we are, then an initialization function must be attached to the system\&. 
.PP
Definition at line 288 of file transient_rb_construction\&.h\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::old_local_solution\fC [inherited]\fP"
All the values I need to compute my contribution to the simulation at hand\&. Think of this as the current solution with any ghost values needed from other processors\&. 
.PP
Definition at line 116 of file transient_system\&.h\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > \fBlibMesh::TransientSystem\fP< \fBRBConstruction\fP  >::older_local_solution\fC [inherited]\fP"
All the values I need to compute my contribution to the simulation at hand\&. Think of this as the current solution with any ghost values needed from other processors\&. 
.PP
Definition at line 124 of file transient_system\&.h\&.
.SS "std::vector< std::vector< \fBNumber\fP > > libMesh::RBConstruction::output_dual_innerprods\fC [inherited]\fP"
The vector storing the dual norm inner product terms for each output\&. 
.PP
Definition at line 471 of file rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::output_dual_innerprods_computed\fC [protected]\fP, \fC [inherited]\fP"
A boolean flag to indicate whether or not the output dual norms have already been computed --- used to make sure that we don't recompute them unnecessarily\&. 
.PP
Definition at line 755 of file rb_construction\&.h\&.
.SS "\fBReal\fP libMesh::TransientRBConstruction::POD_tol\fC [protected]\fP"
If positive, this tolerance determines the number of POD modes we add to the space on a call to \fBenrich_RB_space()\fP\&. If negative, we add delta_N POD modes\&. 
.PP
Definition at line 374 of file transient_rb_construction\&.h\&.
.PP
Referenced by get_POD_tol(), and set_POD_tol()\&.
.SS "std::vector<\fBNumber\fP> libMesh::System::qoi\fC [inherited]\fP"
Values of the quantities of interest\&. This vector needs to be both resized and filled by the user before any quantity of interest assembly is done and before any sensitivities are calculated\&. 
.PP
Definition at line 1488 of file system\&.h\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::ImplicitSystem::adjoint_solve(), libMesh::SensitivityData::allocate_data(), libMesh::SensitivityData::allocate_hessian_data(), libMesh::ExplicitSystem::assemble_qoi(), libMesh::FEMSystem::assemble_qoi(), libMesh::ExplicitSystem::assemble_qoi_derivative(), libMesh::FEMSystem::assemble_qoi_derivative(), libMesh::DifferentiableSystem::attach_qoi(), libMesh::DiffContext::DiffContext(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::FEMContext::pre_fe_reinit(), libMesh::QoISet::size(), and libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve()\&.
.SS "bool libMesh::RBConstruction::quiet_mode\fC [protected]\fP, \fC [inherited]\fP"
Flag to indicate whether we print out extra information during the Offline stage\&. 
.PP
Definition at line 748 of file rb_construction\&.h\&.
.PP
Referenced by libMesh::RBConstruction::is_quiet(), and libMesh::RBConstruction::set_quiet_mode()\&.
.SS "\fBDenseVector\fP<\fBNumber\fP> libMesh::TransientRBConstruction::RB_ic_proj_rhs_all_N\fC [protected]\fP"
The vector that stores the right-hand side for the initial condition projections\&. 
.PP
Definition at line 393 of file transient_rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::reuse_preconditioner\fC [inherited]\fP"
Boolean flag to indicate whether we reuse the preconditioner on consecutive Offline solves for updating residual data\&. 
.PP
Definition at line 500 of file rb_construction\&.h\&.
.SS "\fBNumericVector\fP<\fBNumber\fP>* libMesh::ExplicitSystem::rhs\fC [inherited]\fP"
The system matrix\&. Implicit systems are characterized by the need to solve the linear system Ax=b\&. This is the right-hand-side vector b\&. 
.PP
Definition at line 122 of file explicit_system\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::ExplicitSystem::add_system_rhs(), libMesh::ImplicitSystem::assemble(), libMesh::ImplicitSystem::assemble_residual_derivatives(), libMesh::FEMSystem::assembly(), libMesh::LinearImplicitSystem::assembly(), libMesh::NonlinearImplicitSystem::assembly(), libMesh::ExplicitSystem::clear(), libMesh::Problem_Interface::computeF(), libMesh::ContinuationSystem::continuation_solve(), DMlibMeshFunction(), libMesh::NewtonSolver::line_search(), libMesh::NewtonSolver::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::NewmarkSystem::update_rhs(), libMesh::ImplicitSystem::weighted_sensitivity_adjoint_solve(), and libMesh::ImplicitSystem::weighted_sensitivity_solve()\&.
.SS "bool \fBlibMesh::RBConstructionBase\fP< \fBLinearImplicitSystem\fP  >::serial_training_set\fC [protected]\fP, \fC [inherited]\fP"
This boolean flag indicates whether or not the training set should be the same on all processors\&. By default it is false, but in the case of the Empirical Interpolation Method (RBEIMConstruction), for example, we need the training set to be identical on all processors\&. 
.PP
Definition at line 250 of file rb_construction_base\&.h\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::System::solution\fC [inherited]\fP"
Data structure to hold solution values\&. 
.PP
Definition at line 1457 of file system\&.h\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::ContinuationSystem::apply_predictor(), libMesh::FEMSystem::assembly(), libMesh::LinearImplicitSystem::assembly(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::clear(), libMesh::System::compare(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::ContinuationSystem::continuation_solve(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::GMVIO::copy_nodal_solution(), DMCreateGlobalVector_libMesh(), DMlibMeshFunction(), libMesh::UnsteadySolver::du(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::AdjointResidualErrorEstimator::estimate_error(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::EigenSystem::get_eigenpair(), libMesh::EquationSystems::get_solution(), libMesh::System::init_data(), libMesh::ContinuationSystem::initialize_tangent(), libMesh::DofMap::max_constraint_error(), libMesh::FEMSystem::mesh_position_get(), libMesh::ErrorVector::plot_error(), libMesh::System::project_solution(), libMesh::System::re_update(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::System::read_serialized_data(), libMesh::System::reinit(), libMesh::System::restrict_vectors(), libMesh::MemorySolutionHistory::retrieve(), libMesh::ContinuationSystem::save_current_solution(), libMesh::TwostepTimeSolver::solve(), libMesh::NewtonSolver::solve(), libMesh::LinearImplicitSystem::solve(), libMesh::FrequencySystem::solve(), libMesh::NonlinearImplicitSystem::solve(), libMesh::ContinuationSystem::solve_tangent(), libMesh::MemorySolutionHistory::store(), libMesh::System::update(), libMesh::System::update_global_solution(), libMesh::ContinuationSystem::update_solution(), libMesh::NewmarkSystem::update_u_v_a(), libMesh::System::write_parallel_data(), and libMesh::System::write_serialized_data()\&.
.SS "bool libMesh::RBConstruction::store_non_dirichlet_operators\fC [inherited]\fP"
Boolean flag to indicate whether we store a second copy of each affine operator and vector which does not have Dirichlet bcs enforced\&. 
.PP
Definition at line 551 of file rb_construction\&.h\&.
.SS "std::vector< \fBNumericVector\fP<\fBNumber\fP>* > libMesh::TransientRBConstruction::temporal_data\fC [private]\fP"
Dense matrix to store the data that we use for the temporal POD\&. 
.PP
Definition at line 402 of file transient_rb_construction\&.h\&.
.SS "\fBReal\fP libMesh::System::time\fC [inherited]\fP"
For time-dependent problems, this is the time t at the beginning of the current timestep\&.
.PP
Note for \fBDifferentiableSystem\fP users: do \fInot\fP access this time during an assembly! Use the \fBDiffContext::time\fP value instead to get correct results\&. 
.PP
Definition at line 1480 of file system\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::AdaptiveTimeSolver::advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::EquationSystems::allgather(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::MemorySolutionHistory::find_stored_entry(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::System::project_vector(), libMesh::EquationSystems::reinit(), libMesh::MemorySolutionHistory::retrieve(), libMesh::TwostepTimeSolver::solve(), and libMesh::MemorySolutionHistory::store()\&.
.SS "std::vector<\fBReal\fP> libMesh::RBConstruction::training_error_bounds\fC [inherited]\fP"
Vector storing the values of the error bound for each parameter in the training set --- the parameter giving the largest error bound is chosen for the next snapshot in the Greedy basis training\&. 
.PP
Definition at line 442 of file rb_construction\&.h\&.
.SS "std::vector< \fBNumber\fP > libMesh::RBConstruction::truth_outputs\fC [inherited]\fP"
Vector storing the truth output values from the most recent truth solve\&. 
.PP
Definition at line 465 of file rb_construction\&.h\&.
.SS "std::vector< std::vector<\fBNumber\fP> > libMesh::TransientRBConstruction::truth_outputs_all_k"
The truth outputs for all time-levels from the most recent truth_solve\&. 
.PP
Definition at line 282 of file transient_rb_construction\&.h\&.
.SS "bool libMesh::RBConstruction::use_empty_rb_solve_in_greedy\fC [inherited]\fP"
A boolean flag to indicate whether or not we initialize the Greedy algorithm by performing rb_solves on the training set with an 'empty' (i\&.e\&. N=0) reduced basis space\&. 
.PP
Definition at line 566 of file rb_construction\&.h\&.
.SS "bool libMesh::System::use_fixed_solution\fC [inherited]\fP"
A boolean to be set to true by systems using elem_fixed_solution, for optional use by e\&.g\&. stabilized methods\&. False by default\&.
.PP
Note for \fBFEMSystem\fP users: Warning: if this variable is set to true, it must be before \fBinit_data()\fP is called\&. 
.PP
Definition at line 1427 of file system\&.h\&.
.PP
Referenced by libMesh::DifferentiableSystem::clear(), libMesh::DiffContext::DiffContext(), libMesh::EulerSolver::element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::SteadySolver::element_residual(), libMesh::FEMContext::pre_fe_reinit(), libMesh::EulerSolver::side_residual(), libMesh::Euler2Solver::side_residual(), and libMesh::SteadySolver::side_residual()\&.
.SS "bool libMesh::RBConstruction::use_relative_bound_in_greedy\fC [inherited]\fP"
Boolean flag to indicate whether we use an absolute or relative error bound in the Greedy algorithm for training a Reduced Basis\&. 
.PP
Definition at line 507 of file rb_construction\&.h\&.
.SS "bool libMesh::RBParametrized::verbose_mode\fC [inherited]\fP"
Public boolean to toggle verbose mode\&. 
.PP
Definition at line 172 of file rb_parametrized\&.h\&.
.SS "bool libMesh::RBConstruction::write_data_during_training\fC [inherited]\fP"
Boolean flag to indicate whether train_reduced_basis writes out offline data after each truth solve (to allow continuing in case the code crashes or something)\&. 
.PP
Definition at line 522 of file rb_construction\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
