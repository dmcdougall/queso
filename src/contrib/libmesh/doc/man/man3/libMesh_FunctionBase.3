.TH "libMesh::FunctionBase< Output >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FunctionBase< Output > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <exact_solution\&.h>\fP
.PP
Inherited by \fBlibMesh::AnalyticFunction< Output >\fP, \fBlibMesh::ConstFunction< Output >\fP, \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::ParsedFunction< Output >\fP, and \fBlibMesh::WrappedFunction< Output >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~FunctionBase\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBFunctionBase\fP
.br
< Output > > \fBclone\fP () const =0"
.br
.ti -1c
.RI "virtual Output \fBoperator()\fP (const \fBPoint\fP &p, const \fBReal\fP time=0\&.)=0"
.br
.ti -1c
.RI "void \fBoperator()\fP (const \fBPoint\fP &p, \fBDenseVector\fP< Output > &output)"
.br
.ti -1c
.RI "virtual void \fBoperator()\fP (const \fBPoint\fP &p, const \fBReal\fP time, \fBDenseVector\fP< Output > &output)=0"
.br
.ti -1c
.RI "virtual Output \fBcomponent\fP (unsigned int i, const \fBPoint\fP &p, \fBReal\fP time=0\&.)"
.br
.ti -1c
.RI "bool \fBinitialized\fP () const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBFunctionBase\fP (const \fBFunctionBase\fP *master=NULL)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const \fBFunctionBase\fP * \fB_master\fP"
.br
.ti -1c
.RI "bool \fB_initialized\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename Output>class libMesh::FunctionBase< Output >"
This is the base class for functor-like classes\&. These entities are functions (in the mathematical sense) of time and space, $ f(\mathbf{x},t) = \mbox{\texttt{v}} $, where \fCv\fP may be either a \fCNumber\fP or a \fC\fBDenseVector<Number>\fP\fP\&. Children of this base class implement different styles of data retrieval for these functions\&. Use the constructors of the derived classes for creating new objects\&. The required input of each derived class thwarts the effective use of the commonly used \fCbuild()\fP member\&. But afterwards the virtual members allow the convenient and libMesh-common usage through a \fCFunctionBase*\fP\&. Note that for functor objects for vector-valued variables, it is assumed each component is indexed contiguously; i\&.e\&. if u_var is index 3, then \fBlibMesh\fP expects the x-component of u_var is index 3, the y-component is index 4, and the z-component is index 5\&. Note that for 2-D elements in 3 spatial dimensions, \fBlibMesh\fP is expecting 2 components (i\&.e\&. mesh_dimension() number of components)\&.
.PP
\fBAuthor:\fP
.RS 4
Daniel Dreyer, 2003 
.RE
.PP

.PP
Definition at line 39 of file exact_solution\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename Output > \fBlibMesh::FunctionBase\fP< Output >::\fBFunctionBase\fP (const \fBFunctionBase\fP< Output > *master = \fCNULL\fP)\fC [inline]\fP, \fC [explicit]\fP, \fC [protected]\fP"
Constructor\&. Optionally takes a master\&. 
.PP
Definition at line 176 of file function_base\&.h\&.
.PP
.nf
176                                                               :
177   _master             (master),
178   _initialized        (false)
179 {
180 }
.fi
.SS "template<typename Output > \fBlibMesh::FunctionBase\fP< Output >::~\fBFunctionBase\fP ()\fC [inline]\fP, \fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 186 of file function_base\&.h\&.
.PP
.nf
187 {
188 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename Output> virtual void \fBlibMesh::FunctionBase\fP< Output >::clear ()\fC [inline]\fP, \fC [virtual]\fP"
Clears the function\&. 
.PP
Reimplemented in \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::MeshFunction\fP, and \fBlibMesh::AnalyticFunction< Output >\fP\&.
.PP
Definition at line 90 of file function_base\&.h\&.
.PP
.nf
90 {}
.fi
.SS "template<typename Output> virtual \fBAutoPtr\fP<\fBFunctionBase\fP<Output> > \fBlibMesh::FunctionBase\fP< Output >::clone () const\fC [pure virtual]\fP"
Returns a new copy of the function\&. The new copy should be as ``deep'' as necessary to allow independent destruction and simultaneous evaluations of the copies in different threads\&. 
.PP
Implemented in \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::MeshFunction\fP, \fBlibMesh::AnalyticFunction< Output >\fP, \fBlibMesh::WrappedFunction< Output >\fP, \fBlibMesh::ConstFunction< Output >\fP, and \fBlibMesh::ZeroFunction< Output >\fP\&.
.PP
Referenced by libMesh::ExactErrorEstimator::attach_exact_deriv(), libMesh::ExactSolution::attach_exact_deriv(), libMesh::ExactErrorEstimator::attach_exact_hessian(), libMesh::ExactSolution::attach_exact_hessian(), libMesh::ExactErrorEstimator::attach_exact_value(), libMesh::ExactSolution::attach_exact_value(), and libMesh::MeshTools::Modification::redistribute()\&.
.SS "template<typename Output > Output \fBlibMesh::FunctionBase\fP< Output >::component (unsigned inti, const \fBPoint\fP &p, \fBReal\fPtime = \fC0\&.\fP)\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the vector component \fCi\fP at coordinate \fCp\fP and time \fCtime\fP\&. Subclasses aren't required to overload this, since the default implementation is based on the full vector evaluation, which is often correct\&. Subclasses are recommended to overload this, since the default implementation is based on a vector evaluation, which is usually unnecessarily inefficient\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::ParsedFunction< Output >\fP, and \fBlibMesh::WrappedFunction< Output >\fP\&.
.PP
Definition at line 203 of file function_base\&.h\&.
.PP
Referenced by libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), and libMesh::BoundaryProjectSolution::operator()()\&.
.PP
.nf
206 {
207   DenseVector<Output> outvec(i+1);
208   (*this)(p, time, outvec);
209   return outvec(i);
210 }
.fi
.SS "template<typename Output> virtual void \fBlibMesh::FunctionBase\fP< Output >::init ()\fC [inline]\fP, \fC [virtual]\fP"
The actual initialization process\&. 
.PP
Reimplemented in \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::MeshFunction\fP, and \fBlibMesh::AnalyticFunction< Output >\fP\&.
.PP
Definition at line 85 of file function_base\&.h\&.
.PP
.nf
85 {}
.fi
.SS "template<typename Output > bool \fBlibMesh::FunctionBase\fP< Output >::initialized () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when this object is properly initialized and ready for use, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 194 of file function_base\&.h\&.
.PP
.nf
195 {
196   return (this->_initialized);
197 }
.fi
.SS "template<typename Output> virtual Output \fBlibMesh::FunctionBase\fP< Output >::operator() (const \fBPoint\fP &p, const \fBReal\fPtime = \fC0\&.\fP)\fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the scalar value at coordinate \fCp\fP and time \fCtime\fP, which defaults to zero\&. Purely virtual, so you have to overload it\&. Note that this cannot be a const method, check \fC\fBMeshFunction\fP\fP\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::MeshFunction\fP, \fBlibMesh::AnalyticFunction< Output >\fP, \fBlibMesh::WrappedFunction< Output >\fP, and \fBlibMesh::ConstFunction< Output >\fP\&.
.SS "template<typename Output> void \fBlibMesh::FunctionBase\fP< Output >::operator() (const \fBPoint\fP &p, \fBDenseVector\fP< Output > &output)\fC [inline]\fP"
Return function for vectors\&. Returns in \fCoutput\fP the values of the data at the coordinate \fCp\fP\&. 
.PP
Definition at line 216 of file function_base\&.h\&.
.PP
.nf
218 {
219   // Call the time-dependent function with t=0\&.
220   this->operator()(p, 0\&., output);
221 }
.fi
.SS "template<typename Output> virtual void \fBlibMesh::FunctionBase\fP< Output >::operator() (const \fBPoint\fP &p, const \fBReal\fPtime, \fBDenseVector\fP< Output > &output)\fC [pure virtual]\fP"
Return function for vectors\&. Returns in \fCoutput\fP the values of the data at the coordinate \fCp\fP and for time \fCtime\fP\&. Purely virtual, so you have to overload it\&. Note that this cannot be a const method, check \fC\fBMeshFunction\fP\fP\&. 
.PP
Implemented in \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::ParsedFunction< Output >\fP, \fBlibMesh::MeshFunction\fP, \fBlibMesh::AnalyticFunction< Output >\fP, \fBlibMesh::WrappedFunction< Output >\fP, and \fBlibMesh::ConstFunction< Output >\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename Output> bool \fBlibMesh::FunctionBase\fP< Output >::_initialized\fC [protected]\fP"
When \fC\fBinit()\fP\fP was called so that everything is ready for calls to \fCoperator()\fP (\&.\&.\&.), then this \fCbool\fP is true\&. 
.PP
Definition at line 166 of file function_base\&.h\&.
.PP
Referenced by libMesh::AnalyticFunction< Output >::AnalyticFunction(), libMesh::ConstFunction< Output >::ConstFunction(), libMesh::ParsedFunction< Output >::ParsedFunction(), and libMesh::WrappedFunction< Output >::WrappedFunction()\&.
.SS "template<typename Output> const \fBFunctionBase\fP* \fBlibMesh::FunctionBase\fP< Output >::_master\fC [protected]\fP"
Const pointer to our master, initialized to \fCNULL\fP\&. There may be cases where multiple functions are required, but to save memory, one master handles some centralized data\&. 
.PP
Definition at line 160 of file function_base\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
