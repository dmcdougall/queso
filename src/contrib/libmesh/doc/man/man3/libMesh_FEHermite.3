.TH "libMesh::FEHermite< Dim >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FEHermite< Dim > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe\&.h>\fP
.PP
Inherits \fBlibMesh::FE< Dim, HERMITE >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBFEGenericBase\fP
.br
< typename \fBFEOutputType\fP< T >
.br
::type >::\fBOutputShape\fP \fBOutputShape\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputGradient\fP >::type \fBOutputTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputDivergence\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::MakeNumber\fP
.br
< \fBOutputShape\fP >::type \fBOutputNumber\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumberGradient\fP >::type \fBOutputNumberTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberDivergence\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFEHermite\fP (const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBhermite_raw_shape_second_deriv\fP (const unsigned int i, const \fBReal\fP xi)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBhermite_raw_shape_deriv\fP (const unsigned int i, const \fBReal\fP xi)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBhermite_raw_shape\fP (const unsigned int i, const \fBReal\fP xi)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const"
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const unsigned int \fBside\fP, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *elem, const \fBElem\fP *\fBside\fP, const unsigned int s, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)"
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const"
.br
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputGradient\fP > > & \fBget_dphi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_curl_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputDivergence\fP > > & \fBget_div_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidx\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidxi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputTensor\fP > > & \fBget_d2phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidx2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidy2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidydz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidz2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxi2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phideta2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidetadzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidzeta2\fP () const"
.br
.ti -1c
.RI "const std::vector
.br
< \fBOutputGradient\fP > & \fBget_dphase\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_Sobolev_weight\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_Sobolev_dweight\fP () const"
.br
.ti -1c
.RI "void \fBprint_phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_dphi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_d2phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBReal\fP \fBhermite_raw_shape_second_deriv\fP (const unsigned int basis_num, const \fBReal\fP xi)"
.br
.ti -1c
.RI "static \fBReal\fP \fBhermite_raw_shape_deriv\fP (const unsigned int basis_num, const \fBReal\fP xi)"
.br
.ti -1c
.RI "static \fBReal\fP \fBhermite_raw_shape\fP (const unsigned int basis_num, const \fBReal\fP xi)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "static unsigned int \fBn_shape_functions\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static void \fBdofs_on_side\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int s, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static void \fBdofs_on_edge\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int e, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBinverse_map\fP (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBinverse_map\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_xi\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_eta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_zeta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static void \fBcompute_proj_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcoarsened_dof_values\fP (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &\fBdof_map\fP, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned int var, const bool use_old_dof_indices=false)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBinit_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBinit_base_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBPoint\fP > \fBcached_nodes\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBlast_side\fP"
.br
.ti -1c
.RI "unsigned int \fBlast_edge\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFETransformationBase\fP
.br
< OutputType > > \fB_fe_trans\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputGradient\fP > > \fBdphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBcurl_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputDivergence\fP > > \fBdiv_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidxi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidx\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputTensor\fP > > \fBd2phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxi2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phideta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidetadzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidzeta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidx2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidy2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidydz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidz2\fP"
.br
.ti -1c
.RI "std::vector< \fBOutputGradient\fP > \fBdphase\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdweight\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBweight\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int Dim>class libMesh::FEHermite< Dim >"
Hermite finite elements\&. Still templated on the dimension, \fCDim\fP\&.
.PP
\fBAuthor:\fP
.RS 4
Roy Stogner 
.RE
.PP
\fBDate:\fP
.RS 4
2005 
.RE
.PP

.PP
Definition at line 521 of file fe\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 138 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputGradient\fP\fC [inherited]\fP"

.PP
Definition at line 136 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::MakeNumber\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumber\fP\fC [inherited]\fP"

.PP
Definition at line 139 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 142 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberGradient\fP\fC [inherited]\fP"

.PP
Definition at line 140 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumberGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberTensor\fP\fC [inherited]\fP"

.PP
Definition at line 141 of file fe_base\&.h\&.
.SS "typedef \fBFEGenericBase\fP<typename \fBFEOutputType\fP<T>::type>::\fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::\fBOutputShape\fP\fC [inherited]\fP"

.PP
Definition at line 103 of file fe\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputTensor\fP\fC [inherited]\fP"

.PP
Definition at line 137 of file fe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int Dim> \fBlibMesh::FEHermite\fP< Dim >::\fBFEHermite\fP (const \fBFEType\fP &fet)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. Creates a hierarchic finite element to be used in dimension \fCDim\fP\&. 
.PP
Definition at line 1071 of file fe\&.h\&.
.PP
.nf
1071                                             :
1072   FE<Dim,HERMITE> (fet)
1073 {
1074 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::attach_quadrature_rule (\fBQBase\fP *q)\fC [virtual]\fP, \fC [inherited]\fP"
Provides the class with the quadrature rule, which provides the locations (on a reference element) where the shape functions are to be calculated\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputType of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build_InfFE (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific infinite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputShape of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::coarsened_dof_values (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &dof_map, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned intvar, const booluse_old_dof_indices = \fCfalse\fP)\fC [static]\fP, \fC [inherited]\fP"
Creates a local projection on \fCcoarse_elem\fP, based on the DoF values in \fCglobal_vector\fP for it's children\&. 
.SS "static void \fBlibMesh::FE\fP< Dim, T >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using element-specific optimizations if possible\&. 
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_periodic_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for meshes with periodic boundary conditions) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_proj_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "virtual void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_shape_functions (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
After having updated the jacobian and the transformation from local to global coordinates in \fCFEAbstract::compute_map()\fP, the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx\fP, \fCdphidy\fP, and \fCdphidz\fP\&. This method should rarely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "static void \fBlibMesh::FE\fP< Dim, T >::dofs_on_edge (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned inte, std::vector< unsigned int > &di)\fC [static]\fP, \fC [inherited]\fP"
Fills the vector di with the local degree of freedom indices associated with edge \fCe\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static void \fBlibMesh::FE\fP< Dim, T >::dofs_on_side (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned ints, std::vector< unsigned int > &di)\fC [static]\fP, \fC [inherited]\fP"
Fills the vector di with the local degree of freedom indices associated with side \fCs\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const Realtolerance = \fCTOLERANCE\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< Real > *constweights = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference \fIside\fP element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual \fBFEContinuity\fP \fBlibMesh::FE\fP< Dim, T >::get_continuity () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_curl_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curl of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 225 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_curl_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::curl_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
226   { libmesh_assert(!calculations_started || calculate_curl_phi);
227     calculate_curl_phi = calculate_dphiref = true; return curl_phi; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "const std::vector<std::vector<\fBOutputTensor\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phi, and libMesh::libmesh_assert()\&.
.PP
.nf
292   { libmesh_assert(!calculations_started || calculate_d2phi);
293     calculate_d2phi = calculate_dphiref = true; return d2phi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phideta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 371 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phideta2, and libMesh::libmesh_assert()\&.
.PP
.nf
372   { libmesh_assert(!calculations_started || calculate_d2phi);
373     calculate_d2phi = calculate_dphiref = true; return d2phideta2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 379 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidetadzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
380   { libmesh_assert(!calculations_started || calculate_d2phi);
381     calculate_d2phi = calculate_dphiref = true; return d2phidetadzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidx2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidx2, and libMesh::libmesh_assert()\&.
.PP
.nf
300   { libmesh_assert(!calculations_started || calculate_d2phi);
301     calculate_d2phi = calculate_dphiref = true; return d2phidx2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 307 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdy, and libMesh::libmesh_assert()\&.
.PP
.nf
308   { libmesh_assert(!calculations_started || calculate_d2phi);
309     calculate_d2phi = calculate_dphiref = true; return d2phidxdy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 315 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdz, and libMesh::libmesh_assert()\&.
.PP
.nf
316   { libmesh_assert(!calculations_started || calculate_d2phi);
317     calculate_d2phi = calculate_dphiref = true; return d2phidxdz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 347 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxi2, and libMesh::libmesh_assert()\&.
.PP
.nf
348   { libmesh_assert(!calculations_started || calculate_d2phi);
349     calculate_d2phi = calculate_dphiref = true; return d2phidxi2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 355 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxideta, and libMesh::libmesh_assert()\&.
.PP
.nf
356   { libmesh_assert(!calculations_started || calculate_d2phi);
357     calculate_d2phi = calculate_dphiref = true; return d2phidxideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 363 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
364   { libmesh_assert(!calculations_started || calculate_d2phi);
365     calculate_d2phi = calculate_dphiref = true; return d2phidxidzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidy2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 323 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidy2, and libMesh::libmesh_assert()\&.
.PP
.nf
324   { libmesh_assert(!calculations_started || calculate_d2phi);
325     calculate_d2phi =  calculate_dphiref = true; return d2phidy2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidydz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 331 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidydz, and libMesh::libmesh_assert()\&.
.PP
.nf
332   { libmesh_assert(!calculations_started || calculate_d2phi);
333     calculate_d2phi = calculate_dphiref = true; return d2phidydz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidz2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 339 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidz2, and libMesh::libmesh_assert()\&.
.PP
.nf
340   { libmesh_assert(!calculations_started || calculate_d2phi);
341     calculate_d2phi = calculate_dphiref = true; return d2phidz2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 387 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidzeta2, and libMesh::libmesh_assert()\&.
.PP
.nf
388   { libmesh_assert(!calculations_started || calculate_d2phi);
389     calculate_d2phi = calculate_dphiref = true; return d2phidzeta2; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "const std::vector<std::vector<\fBOutputDivergence\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_div_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the divergence of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 233 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_div_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::div_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
234   { libmesh_assert(!calculations_started || calculate_div_phi);
235     calculate_div_phi = calculate_dphiref = true; return div_phi; }
.fi
.SS "const std::vector<\fBOutputGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphase () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global first derivative of the phase term which is used in infinite elements, evaluated at the quadrature points\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all zero, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 405 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dphase\&.
.PP
.nf
406   { return dphase; }
.fi
.SS "const std::vector<std::vector<\fBOutputGradient\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 217 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphi, and libMesh::libmesh_assert()\&.
.PP
.nf
218   { libmesh_assert(!calculations_started || calculate_dphi);
219     calculate_dphi = calculate_dphiref = true; return dphi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function eta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 273 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphideta, and libMesh::libmesh_assert()\&.
.PP
.nf
274   { libmesh_assert(!calculations_started || calculate_dphiref);
275     calculate_dphiref = true; return dphideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function x-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidx, and libMesh::libmesh_assert()\&.
.PP
.nf
242   { libmesh_assert(!calculations_started || calculate_dphi);
243     calculate_dphi = calculate_dphiref = true; return dphidx; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function xi-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 265 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidxi, and libMesh::libmesh_assert()\&.
.PP
.nf
266   { libmesh_assert(!calculations_started || calculate_dphiref);
267     calculate_dphiref = true; return dphidxi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function y-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 249 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidy, and libMesh::libmesh_assert()\&.
.PP
.nf
250   { libmesh_assert(!calculations_started || calculate_dphi);
251     calculate_dphi = calculate_dphiref = true; return dphidy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function z-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidz, and libMesh::libmesh_assert()\&.
.PP
.nf
258   { libmesh_assert(!calculations_started || calculate_dphi);
259     calculate_dphi = calculate_dphiref = true; return dphidz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function zeta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 281 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
282   { libmesh_assert(!calculations_started || calculate_dphiref);
283     calculate_dphiref = true; return dphidzeta; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level, libMesh::FEAbstract::fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function values at the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 209 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_phi, libMesh::FEAbstract::calculations_started, libMesh::libmesh_assert(), and libMesh::FEGenericBase< T >::phi\&.
.PP
.nf
210   { libmesh_assert(!calculations_started || calculate_phi);
211     calculate_phi = true; return phi; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP, \fC [inherited]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "const std::vector<\fBRealGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_dweight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the first global derivative of the multiplicative weight at each quadrature point\&. See \fC\fBget_Sobolev_weight()\fP\fP for details\&. In case of \fCFE\fP initialized to all zero\&. 
.RE
.PP

.PP
Definition at line 429 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dweight\&.
.PP
.nf
430   { return dweight; }
.fi
.SS "const std::vector<\fBReal\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_weight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the multiplicative weight at each quadrature point\&. This weight is used for certain infinite element weak formulations, so that \fIweighted\fP Sobolev spaces are used for the trial function space\&. This renders the variational form easily computable\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all ones, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 421 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::weight\&.
.PP
.nf
422   { return weight; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FEHermite\fP< 1 >::hermite_raw_shape (const unsigned inti, const \fBReal\fPxi)"

.PP
Definition at line 151 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
152 {
153   switch (i)
154     {
155     case 0:
156       return 0\&.25 * (2\&. - 3\&.*xi + xi*xi*xi);
157     case 1:
158       return 0\&.25 * (2\&. + 3\&.*xi - xi*xi*xi);
159     case 2:
160       return 0\&.25 * (1\&. - xi - xi*xi + xi*xi*xi);
161     case 3:
162       return 0\&.25 * (-1\&. - xi + xi*xi + xi*xi*xi);
163       // All high order terms have the form x^(p-4)(x^2-1)^2/p!
164     case 4:
165       return (xi*xi-1\&.) * (xi*xi-1\&.)/24\&.;
166     case 5:
167       return xi * (xi*xi-1\&.) * (xi*xi-1\&.)/120\&.;
168       //      case 6:
169       //        return xi*xi * (xi*xi-1\&.) * (xi*xi-1\&.)/720\&.;
170     default:
171       Real denominator = 720\&., xipower = 1\&.;
172       for (unsigned n=6; n != i; ++n)
173         {
174           xipower *= xi;
175           denominator *= (n+1);
176         }
177       return (xi*xi*xipower*(xi*xi-1\&.)*(xi*xi-1\&.))/denominator;
178 
179     }
180 
181   libmesh_error();
182   return 0\&.;
183 }
.fi
.SS "template<unsigned int Dim> static \fBReal\fP \fBlibMesh::FEHermite\fP< Dim >::hermite_raw_shape (const unsigned intbasis_num, const \fBReal\fPxi)\fC [static]\fP"

.PP
Referenced by libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.SS "template<> \fBReal\fP \fBlibMesh::FEHermite\fP< 1 >::hermite_raw_shape_deriv (const unsigned inti, const \fBReal\fPxi)"

.PP
Definition at line 116 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
117 {
118   switch (i)
119     {
120     case 0:
121       return 0\&.75 * (-1\&. + xi*xi);
122     case 1:
123       return 0\&.75 * (1\&. - xi*xi);
124     case 2:
125       return 0\&.25 * (-1\&. - 2\&.*xi + 3\&.*xi*xi);
126     case 3:
127       return 0\&.25 * (-1\&. + 2\&.*xi + 3\&.*xi*xi);
128     case 4:
129       return 4\&.*xi * (xi*xi-1\&.)/24\&.;
130     case 5:
131       return (4*xi*xi*(xi*xi-1\&.) + (xi*xi-1\&.)*(xi*xi-1\&.))/120\&.;
132       //      case 6:
133       //        return (4*xi*xi*xi*(xi*xi-1\&.) + 2*xi*(xi*xi-1\&.)*(xi*xi-1\&.))/720\&.;
134     default:
135       Real denominator = 720\&., xipower = 1\&.;
136       for (unsigned n=6; n != i; ++n)
137         {
138           xipower *= xi;
139           denominator *= (n+1);
140         }
141       return (4*xi*xi*xi*xipower*(xi*xi-1\&.) +
142               (i-4)*xi*xipower*(xi*xi-1\&.)*(xi*xi-1\&.))/denominator;
143     }
144 
145   libmesh_error();
146   return 0\&.;
147 }
.fi
.SS "template<unsigned int Dim> static \fBReal\fP \fBlibMesh::FEHermite\fP< Dim >::hermite_raw_shape_deriv (const unsigned intbasis_num, const \fBReal\fPxi)\fC [static]\fP"

.PP
Referenced by libMesh::FE< Dim, T >::shape_deriv(), and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.SS "template<> \fBReal\fP \fBlibMesh::FEHermite\fP< 1 >::hermite_raw_shape_second_deriv (const unsigned inti, const \fBReal\fPxi)"

.PP
Definition at line 75 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
76 {
77   using Utility::pow;
78 
79   switch (i)
80     {
81     case 0:
82       return 1\&.5 * xi;
83     case 1:
84       return -1\&.5 * xi;
85     case 2:
86       return 0\&.5 * (-1\&. + 3\&.*xi);
87     case 3:
88       return 0\&.5 * (1\&. + 3\&.*xi);
89     case 4:
90       return (8\&.*xi*xi + 4\&.*(xi*xi-1\&.))/24\&.;
91     case 5:
92       return (8\&.*xi*xi*xi + 12\&.*xi*(xi*xi-1\&.))/120\&.;
93       //      case 6:
94       //        return (8\&.*pow<4>(xi) + 20\&.*xi*xi*(xi*xi-1\&.) +
95       //          2\&.*(xi*xi-1)*(xi*xi-1))/720\&.;
96     default:
97       Real denominator = 720\&., xipower = 1\&.;
98       for (unsigned n=6; n != i; ++n)
99         {
100           xipower *= xi;
101           denominator *= (n+1);
102         }
103       return (8\&.*pow<4>(xi)*xipower +
104               (8\&.*(i-4)+4\&.)*xi*xi*xipower*(xi*xi-1\&.) +
105               (i-4)*(i-5)*xipower*(xi*xi-1\&.)*(xi*xi-1\&.))/denominator;
106     }
107 
108   libmesh_error();
109   return 0\&.;
110 }
.fi
.SS "template<unsigned int Dim> static \fBReal\fP \fBlibMesh::FEHermite\fP< Dim >::hermite_raw_shape_second_deriv (const unsigned intbasis_num, const \fBReal\fPxi)\fC [static]\fP"
1D hermite functions on unit interval 
.PP
Referenced by libMesh::FE< Dim, T >::shape_second_deriv()\&.
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::init_base_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initialize the data fields for the base of an an infinite element\&. 
.PP
Implements \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::init_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Update the various member data fields \fCphi\fP, \fCdphidxi\fP, \fCdphideta\fP, \fCdphidzeta\fP, etc\&. for the current element\&. These data will be computed at the points \fCqp\fP, which are generally (but need not be) the quadrature points\&. 
.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const \fBPoint\fP &p, const Realtolerance = \fCTOLERANCE\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (on the reference element) of the point \fCp\fP located in physical space\&. This function requires inverting the (possibly nonlinear) transformation map, so it is not trivial\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.RE
.PP

.SS "static void \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const Realtolerance = \fCTOLERANCE\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP, \fC [inherited]\fP"
Takes a number points in physical space (in the \fCphysical_points\fP vector) and finds their location on the reference element for the input element \fCelem\fP\&. The values on the reference element are returned in the vector \fCreference_points\fP\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.SS "virtual bool \fBlibMesh::FE\fP< Dim, T >::is_hierarchic () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_eta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/deta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_xi (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dxi (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_zeta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dzeta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs at node \fCn\fP for a finite element of type \fCt\fP and order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs interior to the element, not associated with any interior nodes\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "virtual unsigned int \fBlibMesh::FE\fP< Dim, T >::n_quadrature_points () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Call this to get an upper bound for the \fCfor\fP loop in your simulation for matrix assembly of the current element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "virtual unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions (const \fBElemType\fPt, const \fBOrder\fPo)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with a finite element of type \fCt\fP and approximation order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Definition at line 226 of file fe\&.h\&.
.PP
.nf
228   { return FE<Dim,T>::n_dofs (t,o); }
.fi
.SS "static void \fBlibMesh::FE\fP< Dim, T >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPo, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)\fC [static]\fP, \fC [inherited]\fP"
Build the nodal soln from the element soln\&. This is the solution that will be plotted\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_d2phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_dphi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const\fC [inherited]\fP"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_dphi(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_phi(), and libMesh::FEAbstract::print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< Real > *constweights = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
This is at the core of this class\&. Use this for each new element in the mesh\&. Reinitializes all the physical element-dependent data based on the current element \fCelem\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::reinit (const \fBElem\fP *elem, const unsigned intside, const Realtolerance = \fCTOLERANCE\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< Real > *constweights = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Reinitializes all the physical element-dependent data based on the \fCside\fP of \fCface\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference \fIside\fP element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the dimension, element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function\&. You must specify element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "virtual bool \fBlibMesh::FE\fP< Dim, T >::shapes_need_reinit () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigned ints, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [virtual]\fP, \fC [inherited]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_curvatures(), libMesh::FEAbstract::get_d2xyzdeta2(), libMesh::FEAbstract::get_d2xyzdetadzeta(), libMesh::FEAbstract::get_d2xyzdxi2(), libMesh::FEAbstract::get_d2xyzdxideta(), libMesh::FEAbstract::get_d2xyzdxidzeta(), libMesh::FEAbstract::get_d2xyzdzeta2(), libMesh::FEAbstract::get_detadx(), libMesh::FEAbstract::get_detady(), libMesh::FEAbstract::get_detadz(), libMesh::FEAbstract::get_dxidx(), libMesh::FEAbstract::get_dxidy(), libMesh::FEAbstract::get_dxidz(), libMesh::FEAbstract::get_dxyzdeta(), libMesh::FEAbstract::get_dxyzdxi(), libMesh::FEAbstract::get_dxyzdzeta(), libMesh::FEAbstract::get_dzetadx(), libMesh::FEAbstract::get_dzetady(), libMesh::FEAbstract::get_dzetadz(), libMesh::FEAbstract::get_fe_map(), libMesh::FEAbstract::get_JxW(), libMesh::FEAbstract::get_normals(), libMesh::FEAbstract::get_tangents(), libMesh::FEAbstract::get_xyz(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_xyz(), and libMesh::FESubdivision::reinit()\&.
.SS "\fBAutoPtr\fP<\fBFETransformationBase\fP<OutputType> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::_fe_trans\fC [protected]\fP, \fC [inherited]\fP"
Object that handles computing shape function values, gradients, etc in the physical domain\&. 
.PP
Definition at line 489 of file fe_base\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP, \fC [inherited]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_order(), and libMesh::FEAbstract::get_p_level()\&.
.SS "std::vector<\fBPoint\fP> \fBlibMesh::FE\fP< Dim, T >::cached_nodes\fC [protected]\fP, \fC [inherited]\fP"
An array of the node locations on the last element we computed on 
.PP
Definition at line 473 of file fe\&.h\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::curl_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function curl values\&. Only defined for vector types\&. 
.PP
Definition at line 504 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputTensor\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivative values\&. 
.PP
Definition at line 547 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phideta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta direction\&. 
.PP
Definition at line 567 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidetadzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta-zeta direction\&. 
.PP
Definition at line 572 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidx2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x direction\&. 
.PP
Definition at line 582 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdy\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-y direction\&. 
.PP
Definition at line 587 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-z direction\&. 
.PP
Definition at line 592 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxi2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi direction\&. 
.PP
Definition at line 552 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-eta direction\&. 
.PP
Definition at line 557 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-zeta direction\&. 
.PP
Definition at line 562 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidy2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y direction\&. 
.PP
Definition at line 597 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidydz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y-z direction\&. 
.PP
Definition at line 602 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidz2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the z direction\&. 
.PP
Definition at line 607 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidzeta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the zeta direction\&. 
.PP
Definition at line 577 of file fe_base\&.h\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP, \fC [inherited]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "std::vector<std::vector<\fBOutputDivergence\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::div_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function divergence values\&. Only defined for vector types\&. 
.PP
Definition at line 509 of file fe_base\&.h\&.
.SS "std::vector<\fBOutputGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphase\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the first derivatives of the phase term in global coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 625 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputGradient\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivative values\&. 
.PP
Definition at line 499 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the eta direction\&. 
.PP
Definition at line 519 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidx\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the x direction\&. 
.PP
Definition at line 529 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidxi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the xi direction\&. 
.PP
Definition at line 514 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidy\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the y direction\&. 
.PP
Definition at line 534 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidz\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the z direction\&. 
.PP
Definition at line 539 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the zeta direction\&. 
.PP
Definition at line 524 of file fe_base\&.h\&.
.SS "std::vector<\fBRealGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dweight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the global derivative of the additional radial weight $ 1/{r^2} $, over \fIall\fP quadrature points\&. 
.PP
Definition at line 632 of file fe_base\&.h\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP, \fC [inherited]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FEAbstract::get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP, \fC [inherited]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::compute_node_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEAbstract::get_family(), libMesh::FEAbstract::get_fe_type(), libMesh::FEAbstract::get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "unsigned int \fBlibMesh::FE\fP< Dim, T >::last_edge\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 480 of file fe\&.h\&.
.SS "\fBElemType\fP \fBlibMesh::FE\fP< Dim, T >::last_side\fC [protected]\fP, \fC [inherited]\fP"
The last side and last edge we did a reinit on 
.PP
Definition at line 478 of file fe\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function values\&. 
.PP
Definition at line 494 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP, \fC [inherited]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FESubdivision::reinit()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP, \fC [inherited]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "std::vector<\fBReal\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::weight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the additional radial weight $ 1/{r^2} $ in local coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 639 of file fe_base\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
