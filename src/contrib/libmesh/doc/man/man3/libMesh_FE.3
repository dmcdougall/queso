.TH "libMesh::FE< Dim, T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FE< Dim, T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe\&.h>\fP
.PP
Inherits \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBFEGenericBase\fP
.br
< typename \fBFEOutputType\fP< T >
.br
::type >::\fBOutputShape\fP \fBOutputShape\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputGradient\fP >::type \fBOutputTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputDivergence\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::MakeNumber\fP
.br
< \fBOutputShape\fP >::type \fBOutputNumber\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumberGradient\fP >::type \fBOutputNumberTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberDivergence\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFE\fP (const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const "
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const "
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const unsigned int \fBside\fP, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *elem, const \fBElem\fP *\fBside\fP, const unsigned int s, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)"
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const "
.br
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const "
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int i, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int i, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP order, const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *, const \fBOrder\fP, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *, const \fBOrder\fP, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBRealGradient\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP type, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBside_map\fP (const \fBElem\fP *, const \fBElem\fP *, const unsigned int, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &)"
.br
.ti -1c
.RI "template<> void \fBedge_reinit\fP (\fBElem\fP const *, unsigned int, \fBReal\fP, const std::vector< \fBPoint\fP > *const, const std::vector< \fBReal\fP > *const)"
.br
.ti -1c
.RI "template<> \fBPoint\fP \fBinverse_map\fP (const \fBElem\fP *, const \fBPoint\fP &, const \fBReal\fP, const bool)"
.br
.ti -1c
.RI "template<> void \fBinverse_map\fP (const \fBElem\fP *, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &, \fBReal\fP, bool)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP, const \fBOrder\fP)"
.br
.ti -1c
.RI "template<> void \fBdofs_on_side\fP (const \fBElem\fP *const, const \fBOrder\fP, unsigned int, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "template<> void \fBdofs_on_edge\fP (const \fBElem\fP *const, const \fBOrder\fP, unsigned int, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> void \fBcompute_constraints\fP (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsigned int, const \fBElem\fP *)"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int \fBlibmesh_dbg_var\fP(i), const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int \fBlibmesh_dbg_var\fP(j), const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElemType\fP, const \fBOrder\fP, const unsigned int, const unsigned int, const \fBPoint\fP &)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP \fBlibmesh_dbg_var\fP(order), const unsigned int i, const unsigned int j, const \fBPoint\fP &point_in)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "template<> \fBReal\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP order, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputGradient\fP > > & \fBget_dphi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_curl_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputDivergence\fP > > & \fBget_div_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidx\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidxi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputTensor\fP > > & \fBget_d2phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidx2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidy2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidydz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidz2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxi2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phideta2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidetadzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidzeta2\fP () const"
.br
.ti -1c
.RI "const std::vector
.br
< \fBOutputGradient\fP > & \fBget_dphase\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_Sobolev_weight\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_Sobolev_dweight\fP () const"
.br
.ti -1c
.RI "void \fBprint_phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_dphi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_d2phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "static unsigned int \fBn_shape_functions\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static void \fBdofs_on_side\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int s, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static void \fBdofs_on_edge\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int e, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBinverse_map\fP (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBinverse_map\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_xi\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_eta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_zeta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static void \fBcompute_proj_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcoarsened_dof_values\fP (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &\fBdof_map\fP, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned int var, const bool use_old_dof_indices=false)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBinit_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBinit_base_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBPoint\fP > \fBcached_nodes\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBlast_side\fP"
.br
.ti -1c
.RI "unsigned int \fBlast_edge\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFETransformationBase\fP
.br
< OutputType > > \fB_fe_trans\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputGradient\fP > > \fBdphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBcurl_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputDivergence\fP > > \fBdiv_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidxi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidx\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputTensor\fP > > \fBd2phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxi2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phideta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidetadzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidzeta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidx2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidy2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidydz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidz2\fP"
.br
.ti -1c
.RI "std::vector< \fBOutputGradient\fP > \fBdphase\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdweight\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBweight\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> class \fBInfFE\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int Dim, FEFamily T>class libMesh::FE< Dim, T >"
A specific instatiation of the \fCFEBase\fP class\&. This class is templated, and specific template instantiations will result in different Finite Element families\&. Full specialization of the template for specific dimensions(\fCDim\fP) and families (\fCT\fP) provide support for specific finite element types\&. The use of templates allows for compile-time optimization, however it requires that the specific finite element family and dimension is also known at compile time\&. If this is too restricting for your application you can use the \fC\fBFEBase::build()\fP\fP member to create abstract (but still optimized) finite elements\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk 
.RE
.PP
\fBDate:\fP
.RS 4
2002-2007 
.RE
.PP

.PP
Definition at line 91 of file fe\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 138 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputGradient\fP\fC [inherited]\fP"

.PP
Definition at line 136 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::MakeNumber\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumber\fP\fC [inherited]\fP"

.PP
Definition at line 139 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 142 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberGradient\fP\fC [inherited]\fP"

.PP
Definition at line 140 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumberGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberTensor\fP\fC [inherited]\fP"

.PP
Definition at line 141 of file fe_base\&.h\&.
.SS "template<unsigned int Dim, FEFamily T> typedef \fBFEGenericBase\fP<typename \fBFEOutputType\fP<T>::type>::\fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::\fBOutputShape\fP"

.PP
Definition at line 103 of file fe\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputTensor\fP\fC [inherited]\fP"

.PP
Definition at line 137 of file fe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int Dim, FEFamily T> \fBlibMesh::FE\fP< Dim, T >::\fBFE\fP (const \fBFEType\fP &fet)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. 
.PP
Definition at line 1043 of file fe\&.h\&.
.PP
References libMesh::FEAbstract::get_family()\&.
.PP
.nf
1043                                 :
1044   FEGenericBase<typename FEOutputType<T>::type> (Dim,fet),
1045   last_side(INVALID_ELEM),
1046   last_edge(libMesh::invalid_uint)
1047 {
1048   // Sanity check\&.  Make sure the
1049   // Family specified in the template instantiation
1050   // matches the one in the FEType object
1051   libmesh_assert_equal_to (T, this->get_family());
1052 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::attach_quadrature_rule (\fBQBase\fP *q)\fC [virtual]\fP"
Provides the class with the quadrature rule, which provides the locations (on a reference element) where the shape functions are to be calculated\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FESubdivision\fP\&.
.PP
Definition at line 44 of file fe\&.C\&.
.PP
References libMesh::INVALID_ELEM, and libMesh::libmesh_assert()\&.
.PP
.nf
45 {
46   libmesh_assert(q);
47   this->qrule = q;
48   // make sure we don't cache results from a previous quadrature rule
49   this->elem_type = INVALID_ELEM;
50   return;
51 }
.fi
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputType of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build_InfFE (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific infinite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputShape of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::coarsened_dof_values (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &dof_map, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned intvar, const booluse_old_dof_indices = \fCfalse\fP)\fC [static]\fP, \fC [inherited]\fP"
Creates a local projection on \fCcoarse_elem\fP, based on the DoF values in \fCglobal_vector\fP for it's children\&. 
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 122 of file fe_scalar\&.C\&.
.PP
.nf
126 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 129 of file fe_scalar\&.C\&.
.PP
.nf
133 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 203 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
207 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 210 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
214 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 310 of file fe_clough\&.C\&.
.PP
.nf
314 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 317 of file fe_clough\&.C\&.
.PP
.nf
321 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 339 of file fe_hermite\&.C\&.
.PP
.nf
343 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 346 of file fe_hermite\&.C\&.
.PP
.nf
350 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 365 of file fe_hierarchic\&.C\&.
.PP
.nf
369 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 372 of file fe_hierarchic\&.C\&.
.PP
.nf
376 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 393 of file fe_monomial\&.C\&.
.PP
.nf
393 {}
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 394 of file fe_monomial\&.C\&.
.PP
.nf
394 {}
.fi
.SS "template<unsigned int Dim, FEFamily T> static void \fBlibMesh::FE\fP< Dim, T >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using element-specific optimizations if possible\&. 
.PP
Referenced by libMesh::FEInterface::compute_constraints()\&.
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 434 of file fe_bernstein\&.C\&.
.PP
.nf
438 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 441 of file fe_bernstein\&.C\&.
.PP
.nf
445 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 485 of file fe_l2_lagrange\&.C\&.
.PP
.nf
489 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 492 of file fe_l2_lagrange\&.C\&.
.PP
.nf
496 { }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 565 of file fe_nedelec_one\&.C\&.
.PP
.nf
569 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 572 of file fe_nedelec_one\&.C\&.
.PP
.nf
576 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 579 of file fe_nedelec_one\&.C\&.
.PP
.nf
583 { nedelec_one_compute_constraints(constraints, dof_map, variable_number, elem, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 586 of file fe_nedelec_one\&.C\&.
.PP
.nf
590 { nedelec_one_compute_constraints(constraints, dof_map, variable_number, elem, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 877 of file fe_lagrange\&.C\&.
.PP
.nf
881 { lagrange_compute_constraints(constraints, dof_map, variable_number, elem, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 884 of file fe_lagrange\&.C\&.
.PP
.nf
888 { lagrange_compute_constraints(constraints, dof_map, variable_number, elem, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 889 of file fe_xyz\&.C\&.
.PP
.nf
889 {}
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::compute_constraints (\fBDofConstraints\fP &, \fBDofMap\fP &, const unsignedint, const \fBElem\fP *)"

.PP
Definition at line 890 of file fe_xyz\&.C\&.
.PP
.nf
890 {}
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 950 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FEGenericBase< T >::compute_proj_constraints()\&.
.PP
.nf
954 { //libmesh_not_implemented();
955   FEVectorBase::compute_proj_constraints(constraints, dof_map, variable_number, elem);
956 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 959 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FEGenericBase< T >::compute_proj_constraints()\&.
.PP
.nf
963 { //libmesh_not_implemented();
964   FEVectorBase::compute_proj_constraints(constraints, dof_map, variable_number, elem);
965 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 1242 of file fe_szabab\&.C\&.
.PP
.nf
1246 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)"

.PP
Definition at line 1249 of file fe_szabab\&.C\&.
.PP
.nf
1253 { compute_proj_constraints(constraints, dof_map, variable_number, elem); }
.fi
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_periodic_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for meshes with periodic boundary conditions) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_proj_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "virtual void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_shape_functions (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
After having updated the jacobian and the transformation from local to global coordinates in \fCFEAbstract::compute_map()\fP, the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx\fP, \fCdphidy\fP, and \fCdphidz\fP\&. This method should rarely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::dofs_on_edge (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned inte, std::vector< unsigned int > &di)\fC [static]\fP"
Fills the vector di with the local degree of freedom indices associated with edge \fCe\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.PP
Definition at line 89 of file fe\&.C\&.
.PP
References libMesh::Elem::is_node_on_edge(), libMesh::libmesh_assert(), libMesh::Elem::n_edges(), n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::p_level(), and libMesh::Elem::type()\&.
.PP
.nf
93 {
94   libmesh_assert(elem);
95   libmesh_assert_less (e, elem->n_edges());
96 
97   di\&.clear();
98   unsigned int nodenum = 0;
99   const unsigned int n_nodes = elem->n_nodes();
100   for (unsigned int n = 0; n != n_nodes; ++n)
101     {
102       const unsigned int n_dofs = n_dofs_at_node(elem->type(),
103                                                  static_cast<Order>(o + elem->p_level()), n);
104       if (elem->is_node_on_edge(n, e))
105         for (unsigned int i = 0; i != n_dofs; ++i)
106           di\&.push_back(nodenum++);
107       else
108         nodenum += n_dofs;
109     }
110 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::dofs_on_edge (const \fBElem\fP *const, const \fBOrder\fP, unsignedint, std::vector< unsigned int > &di)"

.PP
Definition at line 942 of file fe_subdivision_2D\&.C\&.
.PP
.nf
942 { di\&.resize(0); }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::dofs_on_side (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned ints, std::vector< unsigned int > &di)\fC [static]\fP"
Fills the vector di with the local degree of freedom indices associated with side \fCs\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.PP
Definition at line 63 of file fe\&.C\&.
.PP
References libMesh::Elem::is_node_on_side(), libMesh::libmesh_assert(), n_nodes, libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::p_level(), and libMesh::Elem::type()\&.
.PP
.nf
67 {
68   libmesh_assert(elem);
69   libmesh_assert_less (s, elem->n_sides());
70 
71   di\&.clear();
72   unsigned int nodenum = 0;
73   const unsigned int n_nodes = elem->n_nodes();
74   for (unsigned int n = 0; n != n_nodes; ++n)
75     {
76       const unsigned int n_dofs = n_dofs_at_node(elem->type(),
77                                                  static_cast<Order>(o + elem->p_level()), n);
78       if (elem->is_node_on_side(n, s))
79         for (unsigned int i = 0; i != n_dofs; ++i)
80           di\&.push_back(nodenum++);
81       else
82         nodenum += n_dofs;
83     }
84 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::dofs_on_side (const \fBElem\fP *const, const \fBOrder\fP, unsignedint, std::vector< unsigned int > &di)"

.PP
Definition at line 941 of file fe_subdivision_2D\&.C\&.
.PP
.nf
941 { di\&.resize(0); }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference \fIside\fP element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 250 of file fe_boundary\&.C\&.
.PP
References libMesh::Elem::build_edge(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), and libMesh::Elem::type()\&.
.PP
.nf
255 {
256   libmesh_assert(elem);
257   libmesh_assert (this->qrule != NULL || pts != NULL);
258   // We don't do this for 1D elements!
259   libmesh_assert_not_equal_to (Dim, 1);
260 
261   // Build the side of interest
262   const AutoPtr<Elem> edge(elem->build_edge(e));
263 
264   // Initialize the shape functions at the user-specified
265   // points
266   if (pts != NULL)
267     {
268       // The shape functions do not correspond to the qrule
269       this->shapes_on_quadrature = false;
270 
271       // Initialize the edge shape functions
272       this->_fe_map->template init_edge_shape_functions<Dim> (*pts, edge\&.get());
273 
274       // Compute the Jacobian*Weight on the face for integration
275       if (weights != NULL)
276         {
277           this->_fe_map->compute_edge_map (Dim, *weights, edge\&.get());
278         }
279       else
280         {
281           std::vector<Real> dummy_weights (pts->size(), 1\&.);
282           this->_fe_map->compute_edge_map (Dim, dummy_weights, edge\&.get());
283         }
284     }
285   // If there are no user specified points, we use the
286   // quadrature rule
287   else
288     {
289       // initialize quadrature rule
290       this->qrule->init(edge->type(), elem->p_level());
291 
292       if(this->qrule->shapes_need_reinit())
293         this->shapes_on_quadrature = false;
294 
295       // We might not need to reinitialize the shape functions
296       if ((this->get_type() != elem->type())                   ||
297           (edge->type() != static_cast<int>(last_edge))        || // Comparison between enum and unsigned, cast the unsigned to int
298           this->shapes_need_reinit()                           ||
299           !this->shapes_on_quadrature)
300         {
301           // Set the element type
302           this->elem_type = elem->type();
303 
304           // Set the last_edge
305           last_edge = edge->type();
306 
307           // Initialize the edge shape functions
308           this->_fe_map->template init_edge_shape_functions<Dim> (this->qrule->get_points(), edge\&.get());
309         }
310 
311       // Compute the Jacobian*Weight on the face for integration
312       this->_fe_map->compute_edge_map (Dim, this->qrule->get_weights(), edge\&.get());
313 
314       // The shape functions correspond to the qrule
315       this->shapes_on_quadrature = true;
316     }
317 
318   // make a copy of the Jacobian for integration
319   const std::vector<Real> JxW_int(this->_fe_map->get_JxW());
320 
321   // Find where the integration points are located on the
322   // full element\&.
323   std::vector<Point> qp;
324   this->inverse_map (elem, this->_fe_map->get_xyz(), qp, tolerance);
325 
326   // compute the shape function and derivative values
327   // at the points qp
328   this->reinit  (elem, &qp);
329 
330   // copy back old data
331   this->_fe_map->get_JxW() = JxW_int;
332 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::edge_reinit (\fBElem\fP const *elem, unsignededge, \fBReal\fPtolerance, const std::vector< \fBPoint\fP > *pts, const std::vector< \fBReal\fP > *weights)\fC [virtual]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP of the element \fCelem\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference \fIedge\fP element may be specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 901 of file fe_subdivision_2D\&.C\&.
.PP
.nf
906 {
907   libmesh_error();
908 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 107 of file fe_scalar\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
107 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 108 of file fe_scalar\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
108 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 109 of file fe_scalar\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
109 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 110 of file fe_scalar\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
110 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 189 of file fe_l2_hierarchic\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
189 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 190 of file fe_l2_hierarchic\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
190 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 191 of file fe_l2_hierarchic\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
191 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 192 of file fe_l2_hierarchic\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
192 { return DISCONTINUOUS; }
.fi
.SS "template<unsigned int Dim, FEFamily T> virtual \fBFEContinuity\fP \fBlibMesh::FE\fP< Dim, T >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 296 of file fe_clough\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
296 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 297 of file fe_clough\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
297 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 298 of file fe_clough\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
298 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 299 of file fe_clough\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
299 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 324 of file fe_hermite\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
324 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 325 of file fe_hermite\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
325 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 326 of file fe_hermite\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
326 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 327 of file fe_hermite\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
327 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 351 of file fe_hierarchic\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
351 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 352 of file fe_hierarchic\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
352 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 353 of file fe_hierarchic\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
353 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 354 of file fe_hierarchic\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
354 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 376 of file fe_monomial\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
376 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 377 of file fe_monomial\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
377 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 378 of file fe_monomial\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
378 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 379 of file fe_monomial\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
379 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 420 of file fe_bernstein\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
420 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 421 of file fe_bernstein\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
421 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 422 of file fe_bernstein\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
422 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 423 of file fe_bernstein\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
423 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 464 of file fe_l2_lagrange\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
464 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 465 of file fe_l2_lagrange\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
465 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 466 of file fe_l2_lagrange\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
466 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 467 of file fe_l2_lagrange\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
467 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 546 of file fe_nedelec_one\&.C\&.
.PP
.nf
546 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 547 of file fe_nedelec_one\&.C\&.
.PP
.nf
547 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 548 of file fe_nedelec_one\&.C\&.
.PP
References libMesh::H_CURL\&.
.PP
.nf
548 { return H_CURL; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 549 of file fe_nedelec_one\&.C\&.
.PP
References libMesh::H_CURL\&.
.PP
.nf
549 { return H_CURL; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 854 of file fe_lagrange\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
854 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 855 of file fe_lagrange\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
855 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 856 of file fe_lagrange\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
856 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 857 of file fe_lagrange\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
857 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 872 of file fe_xyz\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
872 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 873 of file fe_xyz\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
873 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 874 of file fe_xyz\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
874 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 875 of file fe_xyz\&.C\&.
.PP
References libMesh::DISCONTINUOUS\&.
.PP
.nf
875 { return DISCONTINUOUS; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 927 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
927 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 928 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
928 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 929 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
929 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 930 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
930 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 945 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::C_ONE\&.
.PP
.nf
945 { return C_ONE; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1228 of file fe_szabab\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
1228 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1229 of file fe_szabab\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
1229 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1230 of file fe_szabab\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
1230 { return C_ZERO; }
.fi
.SS "template<> \fBFEContinuity\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::get_continuity () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1231 of file fe_szabab\&.C\&.
.PP
References libMesh::C_ZERO\&.
.PP
.nf
1231 { return C_ZERO; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_curl_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curl of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 225 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_curl_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::curl_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
226   { libmesh_assert(!calculations_started || calculate_curl_phi);
227     calculate_curl_phi = calculate_dphiref = true; return curl_phi; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "const std::vector<std::vector<\fBOutputTensor\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phi, and libMesh::libmesh_assert()\&.
.PP
.nf
292   { libmesh_assert(!calculations_started || calculate_d2phi);
293     calculate_d2phi = calculate_dphiref = true; return d2phi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phideta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 371 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phideta2, and libMesh::libmesh_assert()\&.
.PP
.nf
372   { libmesh_assert(!calculations_started || calculate_d2phi);
373     calculate_d2phi = calculate_dphiref = true; return d2phideta2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 379 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidetadzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
380   { libmesh_assert(!calculations_started || calculate_d2phi);
381     calculate_d2phi = calculate_dphiref = true; return d2phidetadzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidx2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidx2, and libMesh::libmesh_assert()\&.
.PP
.nf
300   { libmesh_assert(!calculations_started || calculate_d2phi);
301     calculate_d2phi = calculate_dphiref = true; return d2phidx2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 307 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdy, and libMesh::libmesh_assert()\&.
.PP
.nf
308   { libmesh_assert(!calculations_started || calculate_d2phi);
309     calculate_d2phi = calculate_dphiref = true; return d2phidxdy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 315 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdz, and libMesh::libmesh_assert()\&.
.PP
.nf
316   { libmesh_assert(!calculations_started || calculate_d2phi);
317     calculate_d2phi = calculate_dphiref = true; return d2phidxdz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 347 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxi2, and libMesh::libmesh_assert()\&.
.PP
.nf
348   { libmesh_assert(!calculations_started || calculate_d2phi);
349     calculate_d2phi = calculate_dphiref = true; return d2phidxi2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 355 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxideta, and libMesh::libmesh_assert()\&.
.PP
.nf
356   { libmesh_assert(!calculations_started || calculate_d2phi);
357     calculate_d2phi = calculate_dphiref = true; return d2phidxideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 363 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
364   { libmesh_assert(!calculations_started || calculate_d2phi);
365     calculate_d2phi = calculate_dphiref = true; return d2phidxidzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidy2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 323 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidy2, and libMesh::libmesh_assert()\&.
.PP
.nf
324   { libmesh_assert(!calculations_started || calculate_d2phi);
325     calculate_d2phi =  calculate_dphiref = true; return d2phidy2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidydz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 331 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidydz, and libMesh::libmesh_assert()\&.
.PP
.nf
332   { libmesh_assert(!calculations_started || calculate_d2phi);
333     calculate_d2phi = calculate_dphiref = true; return d2phidydz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidz2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 339 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidz2, and libMesh::libmesh_assert()\&.
.PP
.nf
340   { libmesh_assert(!calculations_started || calculate_d2phi);
341     calculate_d2phi = calculate_dphiref = true; return d2phidz2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 387 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidzeta2, and libMesh::libmesh_assert()\&.
.PP
.nf
388   { libmesh_assert(!calculations_started || calculate_d2phi);
389     calculate_d2phi = calculate_dphiref = true; return d2phidzeta2; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "const std::vector<std::vector<\fBOutputDivergence\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_div_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the divergence of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 233 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_div_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::div_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
234   { libmesh_assert(!calculations_started || calculate_div_phi);
235     calculate_div_phi = calculate_dphiref = true; return div_phi; }
.fi
.SS "const std::vector<\fBOutputGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphase () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global first derivative of the phase term which is used in infinite elements, evaluated at the quadrature points\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all zero, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 405 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dphase\&.
.PP
.nf
406   { return dphase; }
.fi
.SS "const std::vector<std::vector<\fBOutputGradient\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 217 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphi, and libMesh::libmesh_assert()\&.
.PP
.nf
218   { libmesh_assert(!calculations_started || calculate_dphi);
219     calculate_dphi = calculate_dphiref = true; return dphi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function eta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 273 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphideta, and libMesh::libmesh_assert()\&.
.PP
.nf
274   { libmesh_assert(!calculations_started || calculate_dphiref);
275     calculate_dphiref = true; return dphideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function x-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidx, and libMesh::libmesh_assert()\&.
.PP
.nf
242   { libmesh_assert(!calculations_started || calculate_dphi);
243     calculate_dphi = calculate_dphiref = true; return dphidx; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function xi-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 265 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidxi, and libMesh::libmesh_assert()\&.
.PP
.nf
266   { libmesh_assert(!calculations_started || calculate_dphiref);
267     calculate_dphiref = true; return dphidxi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function y-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 249 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidy, and libMesh::libmesh_assert()\&.
.PP
.nf
250   { libmesh_assert(!calculations_started || calculate_dphi);
251     calculate_dphi = calculate_dphiref = true; return dphidy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function z-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidz, and libMesh::libmesh_assert()\&.
.PP
.nf
258   { libmesh_assert(!calculations_started || calculate_dphi);
259     calculate_dphi = calculate_dphiref = true; return dphidz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function zeta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 281 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
282   { libmesh_assert(!calculations_started || calculate_dphiref);
283     calculate_dphiref = true; return dphidzeta; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level, libMesh::FEAbstract::fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function values at the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 209 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_phi, libMesh::FEAbstract::calculations_started, libMesh::libmesh_assert(), and libMesh::FEGenericBase< T >::phi\&.
.PP
.nf
210   { libmesh_assert(!calculations_started || calculate_phi);
211     calculate_phi = true; return phi; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP, \fC [inherited]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "const std::vector<\fBRealGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_dweight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the first global derivative of the multiplicative weight at each quadrature point\&. See \fC\fBget_Sobolev_weight()\fP\fP for details\&. In case of \fCFE\fP initialized to all zero\&. 
.RE
.PP

.PP
Definition at line 429 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dweight\&.
.PP
.nf
430   { return dweight; }
.fi
.SS "const std::vector<\fBReal\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_weight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the multiplicative weight at each quadrature point\&. This weight is used for certain infinite element weak formulations, so that \fIweighted\fP Sobolev spaces are used for the trial function space\&. This renders the variational form easily computable\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all ones, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 421 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::weight\&.
.PP
.nf
422   { return weight; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::init_base_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [virtual]\fP"
Initialize the data fields for the base of an an infinite element\&. 
.PP
Implements \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.PP
Definition at line 530 of file fe\&.C\&.
.PP
References libMesh::Elem::type()\&.
.PP
.nf
532 {
533   // I don't understand infinite elements well enough to risk
534   // calculating too little\&.  :-(  RHS
535   this->calculate_phi = this->calculate_dphi = this->calculate_d2phi = true;
536 
537   this->elem_type = e->type();
538   this->_fe_map->template init_reference_to_physical_map<Dim>(qp, e);
539   init_shape_functions(qp, e);
540 }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::init_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [virtual]\fP"
Update the various member data fields \fCphi\fP, \fCdphidxi\fP, \fCdphideta\fP, \fCdphidzeta\fP, etc\&. for the current element\&. These data will be computed at the points \fCqp\fP, which are generally (but need not be) the quadrature points\&. 
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::FESubdivision\fP\&.
.PP
Definition at line 241 of file fe\&.C\&.
.PP
References libMesh::FEInterface::field_type(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TYPE_VECTOR, and libMesh::MeshTools::weight()\&.
.PP
.nf
243 {
244   libmesh_assert(elem);
245   this->calculations_started = true;
246 
247   // If the user forgot to request anything, we'll be safe and
248   // calculate everything:
249 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
250   if (!this->calculate_phi && !this->calculate_dphi && !this->calculate_d2phi
251       && !this->calculate_curl_phi && !this->calculate_div_phi)
252     {
253       this->calculate_phi = this->calculate_dphi = this->calculate_d2phi = this->calculate_dphiref = true;
254       if( FEInterface::field_type(T) == TYPE_VECTOR )
255         {
256           this->calculate_curl_phi = true;
257           this->calculate_div_phi  = true;
258         }
259     }
260 #else
261   if (!this->calculate_phi && !this->calculate_dphi && !this->calculate_curl_phi && !this->calculate_div_phi)
262     {
263       this->calculate_phi = this->calculate_dphi = this->calculate_dphiref = true;
264       if( FEInterface::field_type(T) == TYPE_VECTOR )
265         {
266           this->calculate_curl_phi = true;
267           this->calculate_div_phi  = true;
268         }
269     }
270 #endif // LIBMESH_ENABLE_SECOND_DERIVATIVES
271 
272   // Start logging the shape function initialization
273   START_LOG("init_shape_functions()", "FE");
274 
275 
276   // The number of quadrature points\&.
277   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qp\&.size());
278 
279   // Number of shape functions in the finite element approximation
280   // space\&.
281   const unsigned int n_approx_shape_functions =
282     this->n_shape_functions(this->get_type(),
283                             this->get_order());
284 
285   // resize the vectors to hold current data
286   // Phi are the shape functions used for the FE approximation
287   // Phi_map are the shape functions used for the FE mapping
288   if (this->calculate_phi)
289     this->phi\&.resize     (n_approx_shape_functions);
290 
291   if (this->calculate_dphi)
292     {
293       this->dphi\&.resize    (n_approx_shape_functions);
294       this->dphidx\&.resize  (n_approx_shape_functions);
295       this->dphidy\&.resize  (n_approx_shape_functions);
296       this->dphidz\&.resize  (n_approx_shape_functions);
297     }
298 
299   if(this->calculate_dphiref)
300     {
301       if (Dim > 0)
302         this->dphidxi\&.resize (n_approx_shape_functions);
303 
304       if (Dim > 1)
305         this->dphideta\&.resize      (n_approx_shape_functions);
306 
307       if (Dim > 2)
308         this->dphidzeta\&.resize     (n_approx_shape_functions);
309     }
310 
311   if( this->calculate_curl_phi && (FEInterface::field_type(T) == TYPE_VECTOR) )
312     this->curl_phi\&.resize(n_approx_shape_functions);
313 
314   if( this->calculate_div_phi && (FEInterface::field_type(T) == TYPE_VECTOR) )
315     this->div_phi\&.resize(n_approx_shape_functions);
316 
317 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
318   if (this->calculate_d2phi)
319     {
320       this->d2phi\&.resize     (n_approx_shape_functions);
321       this->d2phidx2\&.resize  (n_approx_shape_functions);
322       this->d2phidxdy\&.resize (n_approx_shape_functions);
323       this->d2phidxdz\&.resize (n_approx_shape_functions);
324       this->d2phidy2\&.resize  (n_approx_shape_functions);
325       this->d2phidydz\&.resize (n_approx_shape_functions);
326       this->d2phidz2\&.resize  (n_approx_shape_functions);
327 
328       if (Dim > 0)
329         this->d2phidxi2\&.resize (n_approx_shape_functions);
330 
331       if (Dim > 1)
332         {
333           this->d2phidxideta\&.resize (n_approx_shape_functions);
334           this->d2phideta2\&.resize   (n_approx_shape_functions);
335         }
336       if (Dim > 2)
337         {
338           this->d2phidxidzeta\&.resize  (n_approx_shape_functions);
339           this->d2phidetadzeta\&.resize (n_approx_shape_functions);
340           this->d2phidzeta2\&.resize    (n_approx_shape_functions);
341         }
342     }
343 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
344 
345   for (unsigned int i=0; i<n_approx_shape_functions; i++)
346     {
347       if (this->calculate_phi)
348         this->phi[i]\&.resize         (n_qp);
349       if (this->calculate_dphi)
350         {
351           this->dphi[i]\&.resize        (n_qp);
352           this->dphidx[i]\&.resize      (n_qp);
353           this->dphidy[i]\&.resize      (n_qp);
354           this->dphidz[i]\&.resize      (n_qp);
355         }
356 
357       if(this->calculate_dphiref)
358         {
359           if (Dim > 0)
360             this->dphidxi[i]\&.resize(n_qp);
361 
362           if (Dim > 1)
363             this->dphideta[i]\&.resize(n_qp);
364 
365           if (Dim > 2)
366             this->dphidzeta[i]\&.resize(n_qp);
367         }
368 
369       if(this->calculate_curl_phi && (FEInterface::field_type(T) == TYPE_VECTOR) )
370         this->curl_phi[i]\&.resize(n_qp);
371 
372       if(this->calculate_div_phi && (FEInterface::field_type(T) == TYPE_VECTOR) )
373         this->div_phi[i]\&.resize(n_qp);
374 
375 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
376       if (this->calculate_d2phi)
377         {
378           this->d2phi[i]\&.resize     (n_qp);
379           this->d2phidx2[i]\&.resize  (n_qp);
380           this->d2phidxdy[i]\&.resize (n_qp);
381           this->d2phidxdz[i]\&.resize (n_qp);
382           this->d2phidy2[i]\&.resize  (n_qp);
383           this->d2phidydz[i]\&.resize (n_qp);
384           this->d2phidz2[i]\&.resize  (n_qp);
385           if (Dim > 0)
386             this->d2phidxi2[i]\&.resize (n_qp);
387           if (Dim > 1)
388             {
389               this->d2phidxideta[i]\&.resize (n_qp);
390               this->d2phideta2[i]\&.resize   (n_qp);
391             }
392           if (Dim > 2)
393             {
394               this->d2phidxidzeta[i]\&.resize  (n_qp);
395               this->d2phidetadzeta[i]\&.resize (n_qp);
396               this->d2phidzeta2[i]\&.resize    (n_qp);
397             }
398         }
399 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
400     }
401 
402 
403 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
404   //------------------------------------------------------------
405   // Initialize the data fields, which should only be used for infinite
406   // elements, to some sensible values, so that using a FE with the
407   // variational formulation of an InfFE, correct element matrices are
408   // returned
409 
410   {
411     this->weight\&.resize  (n_qp);
412     this->dweight\&.resize (n_qp);
413     this->dphase\&.resize  (n_qp);
414 
415     for (unsigned int p=0; p<n_qp; p++)
416       {
417         this->weight[p] = 1\&.;
418         this->dweight[p]\&.zero();
419         this->dphase[p]\&.zero();
420       }
421 
422   }
423 #endif // ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
424 
425   switch (Dim)
426     {
427 
428       //------------------------------------------------------------
429       // 0D
430     case 0:
431       {
432         break;
433       }
434 
435       //------------------------------------------------------------
436       // 1D
437     case 1:
438       {
439         // Compute the value of the approximation shape function i at quadrature point p
440         if (this->calculate_dphiref)
441           for (unsigned int i=0; i<n_approx_shape_functions; i++)
442             for (unsigned int p=0; p<n_qp; p++)
443               this->dphidxi[i][p]  = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
444 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
445         if (this->calculate_d2phi)
446           for (unsigned int i=0; i<n_approx_shape_functions; i++)
447             for (unsigned int p=0; p<n_qp; p++)
448               this->d2phidxi2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
449 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
450 
451         break;
452       }
453 
454 
455 
456       //------------------------------------------------------------
457       // 2D
458     case 2:
459       {
460         // Compute the value of the approximation shape function i at quadrature point p
461         if (this->calculate_dphiref)
462           for (unsigned int i=0; i<n_approx_shape_functions; i++)
463             for (unsigned int p=0; p<n_qp; p++)
464               {
465                 this->dphidxi[i][p]  = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
466                 this->dphideta[i][p] = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 1, qp[p]);
467               }
468 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
469         if (this->calculate_d2phi)
470           for (unsigned int i=0; i<n_approx_shape_functions; i++)
471             for (unsigned int p=0; p<n_qp; p++)
472               {
473                 this->d2phidxi2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
474                 this->d2phidxideta[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 1, qp[p]);
475                 this->d2phideta2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 2, qp[p]);
476               }
477 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
478 
479 
480         break;
481       }
482 
483 
484 
485       //------------------------------------------------------------
486       // 3D
487     case 3:
488       {
489         // Compute the value of the approximation shape function i at quadrature point p
490         if (this->calculate_dphiref)
491           for (unsigned int i=0; i<n_approx_shape_functions; i++)
492             for (unsigned int p=0; p<n_qp; p++)
493               {
494                 this->dphidxi[i][p]   = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
495                 this->dphideta[i][p]  = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 1, qp[p]);
496                 this->dphidzeta[i][p] = FE<Dim,T>::shape_deriv (elem, this->fe_type\&.order, i, 2, qp[p]);
497               }
498 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
499         if (this->calculate_d2phi)
500           for (unsigned int i=0; i<n_approx_shape_functions; i++)
501             for (unsigned int p=0; p<n_qp; p++)
502               {
503                 this->d2phidxi2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 0, qp[p]);
504                 this->d2phidxideta[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 1, qp[p]);
505                 this->d2phideta2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 2, qp[p]);
506                 this->d2phidxidzeta[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 3, qp[p]);
507                 this->d2phidetadzeta[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 4, qp[p]);
508                 this->d2phidzeta2[i][p] = FE<Dim,T>::shape_second_deriv (elem, this->fe_type\&.order, i, 5, qp[p]);
509               }
510 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
511 
512         break;
513       }
514 
515 
516     default:
517       libmesh_error();
518     }
519 
520   // Stop logging the shape function initialization
521   STOP_LOG("init_shape_functions()", "FE");
522 }
.fi
.SS "template<unsigned int Dim, FEFamily T> \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (on the reference element) of the point \fCp\fP located in physical space\&. This function requires inverting the (possibly nonlinear) transformation map, so it is not trivial\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.RE
.PP

.PP
Definition at line 861 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add(), libMesh::err, libMesh::DofObject::id(), libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::FE< Dim, T >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), libMesh::FEAbstract::on_reference_element(), libMesh::Elem::print_info(), libMesh::Real, libMesh::TypeVector< T >::size(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEMap::compute_face_map()\&.
.PP
.nf
865 {
866   libmesh_assert(elem);
867   libmesh_assert_greater_equal (tolerance, 0\&.);
868 
869 
870   // Start logging the map inversion\&.
871   START_LOG("inverse_map()", "FE");
872 
873   // How much did the point on the reference
874   // element change by in this Newton step?
875   Real inverse_map_error = 0\&.;
876 
877   //  The point on the reference element\&.  This is
878   //  the "initial guess" for Newton's method\&.  The
879   //  centroid seems like a good idea, but computing
880   //  it is a little more intensive than, say taking
881   //  the zero point\&.
882   //
883   //  Convergence should be insensitive of this choice
884   //  for "good" elements\&.
885   Point p; // the zero point\&.  No computation required
886 
887   //  The number of iterations in the map inversion process\&.
888   unsigned int cnt = 0;
889 
890   //  The number of iterations after which we give up and declare
891   //  divergence
892   const unsigned int max_cnt = 10;
893 
894   //  The distance (in master element space) beyond which we give up
895   //  and declare divergence\&.  This is no longer used\&.\&.\&.
896   // Real max_step_length = 4\&.;
897 
898 
899 
900   //  Newton iteration loop\&.
901   do
902     {
903       //  Where our current iterate \p p maps to\&.
904       const Point physical_guess = FE<Dim,T>::map (elem, p);
905 
906       //  How far our current iterate is from the actual point\&.
907       const Point delta = physical_point - physical_guess;
908 
909       //  Increment in current iterate \p p, will be computed\&.
910       Point dp;
911 
912 
913       //  The form of the map and how we invert it depends
914       //  on the dimension that we are in\&.
915       switch (Dim)
916         {
917           // ------------------------------------------------------------------
918           //  0D map inversion is trivial
919         case 0:
920           {
921             break;
922           }
923 
924           // ------------------------------------------------------------------
925           //  1D map inversion
926           //
927           //  Here we find the point on a 1D reference element that maps to
928           //  the point \p physical_point in the domain\&.  This is a bit tricky
929           //  since we do not want to assume that the point \p physical_point
930           //  is also in a 1D domain\&.  In particular, this method might get
931           //  called on the edge of a 3D element, in which case
932           //  \p physical_point actually lives in 3D\&.
933         case 1:
934           {
935             const Point dxi = FE<Dim,T>::map_xi (elem, p);
936 
937             //  Newton's method in this case looks like
938             //
939             //  {X} - {X_n} = [J]*dp
940             //
941             //  Where {X}, {X_n} are 3x1 vectors, [J] is a 3x1 matrix
942             //  d(x,y,z)/dxi, and we seek dp, a scalar\&.  Since the above
943             //  system is either overdetermined or rank-deficient, we will
944             //  solve the normal equations for this system
945             //
946             //  [J]^T ({X} - {X_n}) = [J]^T [J] {dp}
947             //
948             //  which involves the trivial inversion of the scalar
949             //  G = [J]^T [J]
950             const Real G = dxi*dxi;
951 
952             if (secure)
953               libmesh_assert_greater (G, 0\&.);
954 
955             const Real Ginv = 1\&./G;
956 
957             const Real  dxidelta = dxi*delta;
958 
959             dp(0) = Ginv*dxidelta;
960 
961             // No master elements have radius > 4, but sometimes we
962             // can take a step that big while still converging
963             // if (secure)
964             // libmesh_assert_less (dp\&.size(), max_step_length);
965 
966             break;
967           }
968 
969 
970 
971           // ------------------------------------------------------------------
972           //  2D map inversion
973           //
974           //  Here we find the point on a 2D reference element that maps to
975           //  the point \p physical_point in the domain\&.  This is a bit tricky
976           //  since we do not want to assume that the point \p physical_point
977           //  is also in a 2D domain\&.  In particular, this method might get
978           //  called on the face of a 3D element, in which case
979           //  \p physical_point actually lives in 3D\&.
980         case 2:
981           {
982             const Point dxi  = FE<Dim,T>::map_xi  (elem, p);
983             const Point deta = FE<Dim,T>::map_eta (elem, p);
984 
985             //  Newton's method in this case looks like
986             //
987             //  {X} - {X_n} = [J]*{dp}
988             //
989             //  Where {X}, {X_n} are 3x1 vectors, [J] is a 3x2 matrix
990             //  d(x,y,z)/d(xi,eta), and we seek {dp}, a 2x1 vector\&.  Since
991             //  the above system is either overdermined or rank-deficient,
992             //  we will solve the normal equations for this system
993             //
994             //  [J]^T ({X} - {X_n}) = [J]^T [J] {dp}
995             //
996             //  which involves the inversion of the 2x2 matrix
997             //  [G] = [J]^T [J]
998             const Real
999               G11 = dxi*dxi,  G12 = dxi*deta,
1000               G21 = dxi*deta, G22 = deta*deta;
1001 
1002 
1003             const Real det = (G11*G22 - G12*G21);
1004 
1005             if (secure)
1006               libmesh_assert_not_equal_to (det, 0\&.);
1007 
1008             const Real inv_det = 1\&./det;
1009 
1010             const Real
1011               Ginv11 =  G22*inv_det,
1012               Ginv12 = -G12*inv_det,
1013 
1014               Ginv21 = -G21*inv_det,
1015               Ginv22 =  G11*inv_det;
1016 
1017 
1018             const Real  dxidelta  = dxi*delta;
1019             const Real  detadelta = deta*delta;
1020 
1021             dp(0) = (Ginv11*dxidelta + Ginv12*detadelta);
1022             dp(1) = (Ginv21*dxidelta + Ginv22*detadelta);
1023 
1024             // No master elements have radius > 4, but sometimes we
1025             // can take a step that big while still converging
1026             // if (secure)
1027             // libmesh_assert_less (dp\&.size(), max_step_length);
1028 
1029             break;
1030           }
1031 
1032 
1033 
1034           // ------------------------------------------------------------------
1035           //  3D map inversion
1036           //
1037           //  Here we find the point in a 3D reference element that maps to
1038           //  the point \p physical_point in a 3D domain\&. Nothing special
1039           //  has to happen here, since (unless the map is singular because
1040           //  you have a BAD element) the map will be invertable and we can
1041           //  apply Newton's method directly\&.
1042         case 3:
1043           {
1044             const Point dxi   = FE<Dim,T>::map_xi   (elem, p);
1045             const Point deta  = FE<Dim,T>::map_eta  (elem, p);
1046             const Point dzeta = FE<Dim,T>::map_zeta (elem, p);
1047 
1048             //  Newton's method in this case looks like
1049             //
1050             //  {X} = {X_n} + [J]*{dp}
1051             //
1052             //  Where {X}, {X_n} are 3x1 vectors, [J] is a 3x3 matrix
1053             //  d(x,y,z)/d(xi,eta,zeta), and we seek {dp}, a 3x1 vector\&.
1054             //  Since the above system is nonsingular for invertable maps
1055             //  we will solve
1056             //
1057             //  {dp} = [J]^-1 ({X} - {X_n})
1058             //
1059             //  which involves the inversion of the 3x3 matrix [J]
1060             const Real
1061               J11 = dxi(0), J12 = deta(0), J13 = dzeta(0),
1062               J21 = dxi(1), J22 = deta(1), J23 = dzeta(1),
1063               J31 = dxi(2), J32 = deta(2), J33 = dzeta(2);
1064 
1065             const Real det = (J11*(J22*J33 - J23*J32) +
1066                               J12*(J23*J31 - J21*J33) +
1067                               J13*(J21*J32 - J22*J31));
1068 
1069             if (secure)
1070               libmesh_assert_not_equal_to (det, 0\&.);
1071 
1072             const Real inv_det = 1\&./det;
1073 
1074             const Real
1075               Jinv11 =  (J22*J33 - J23*J32)*inv_det,
1076               Jinv12 = -(J12*J33 - J13*J32)*inv_det,
1077               Jinv13 =  (J12*J23 - J13*J22)*inv_det,
1078 
1079               Jinv21 = -(J21*J33 - J23*J31)*inv_det,
1080               Jinv22 =  (J11*J33 - J13*J31)*inv_det,
1081               Jinv23 = -(J11*J23 - J13*J21)*inv_det,
1082 
1083               Jinv31 =  (J21*J32 - J22*J31)*inv_det,
1084               Jinv32 = -(J11*J32 - J12*J31)*inv_det,
1085               Jinv33 =  (J11*J22 - J12*J21)*inv_det;
1086 
1087             dp(0) = (Jinv11*delta(0) +
1088                      Jinv12*delta(1) +
1089                      Jinv13*delta(2));
1090 
1091             dp(1) = (Jinv21*delta(0) +
1092                      Jinv22*delta(1) +
1093                      Jinv23*delta(2));
1094 
1095             dp(2) = (Jinv31*delta(0) +
1096                      Jinv32*delta(1) +
1097                      Jinv33*delta(2));
1098 
1099             // No master elements have radius > 4, but sometimes we
1100             // can take a step that big while still converging
1101             // if (secure)
1102             // libmesh_assert_less (dp\&.size(), max_step_length);
1103 
1104             break;
1105           }
1106 
1107 
1108           //  Some other dimension?
1109         default:
1110           libmesh_error();
1111         } // end switch(Dim), dp now computed
1112 
1113 
1114 
1115       //  ||P_n+1 - P_n||
1116       inverse_map_error = dp\&.size();
1117 
1118       //  P_n+1 = P_n + dp
1119       p\&.add (dp);
1120 
1121       //  Increment the iteration count\&.
1122       cnt++;
1123 
1124       //  Watch for divergence of Newton's
1125       //  method\&.  Here's how it goes:
1126       //  (1) For good elements, we expect convergence in 10
1127       //      iterations, with no too-large steps\&.
1128       //      - If called with (secure == true) and we have not yet converged
1129       //        print out a warning message\&.
1130       //      - If called with (secure == true) and we have not converged in
1131       //        20 iterations abort
1132       //  (2) This method may be called in cases when the target point is not
1133       //      inside the element and we have no business expecting convergence\&.
1134       //      For these cases if we have not converged in 10 iterations forget
1135       //      about it\&.
1136       if (cnt > max_cnt)
1137         {
1138           //  Warn about divergence when secure is true - this
1139           //  shouldn't happen
1140           if (secure)
1141             {
1142               // Print every time in devel/dbg modes
1143 #ifndef NDEBUG
1144               libmesh_here();
1145               libMesh::err << "WARNING: Newton scheme has not converged in "
1146                            << cnt << " iterations:" << std::endl
1147                            << "   physical_point="
1148                            << physical_point
1149                            << "   physical_guess="
1150                            << physical_guess
1151                            << "   dp="
1152                            << dp
1153                            << "   p="
1154                            << p
1155                            << "   error=" << inverse_map_error
1156                            << "   in element " << elem->id()
1157                            << std::endl;
1158 
1159               elem->print_info(libMesh::err);
1160 #else
1161               // In optimized mode, just print once that an inverse_map() call
1162               // had trouble converging its Newton iteration\&.
1163               libmesh_do_once(libMesh::err << "WARNING: At least one element took more than "
1164                               << max_cnt
1165                               << " iterations to converge in inverse_map()\&.\&.\&.\n"
1166                               << "Rerun in devel/dbg mode for more details\&."
1167                               << std::endl;);
1168 
1169 #endif // NDEBUG
1170 
1171               if (cnt > 2*max_cnt)
1172                 {
1173                   libMesh::err << "ERROR: Newton scheme FAILED to converge in "
1174                                << cnt
1175                                << " iterations!"
1176                                << " in element " << elem->id()
1177                                << std::endl;
1178 
1179                   elem->print_info(libMesh::err);
1180 
1181                   libmesh_error();
1182                 }
1183             }
1184           //  Return a far off point when secure is false - this
1185           //  should only happen when we're trying to map a point
1186           //  that's outside the element
1187           else
1188             {
1189               for (unsigned int i=0; i != Dim; ++i)
1190                 p(i) = 1e6;
1191 
1192               STOP_LOG("inverse_map()", "FE");
1193               return p;
1194             }
1195         }
1196     }
1197   while (inverse_map_error > tolerance);
1198 
1199 
1200 
1201   //  If we are in debug mode do two sanity checks\&.
1202 #ifdef DEBUG
1203 
1204   if (secure)
1205     {
1206       // Make sure the point \p p on the reference element actually
1207       // does map to the point \p physical_point within a tolerance\&.
1208 
1209       const Point check = FE<Dim,T>::map (elem, p);
1210       const Point diff  = physical_point - check;
1211 
1212       if (diff\&.size() > tolerance)
1213         {
1214           libmesh_here();
1215           libMesh::err << "WARNING:  diff is "
1216                        << diff\&.size()
1217                        << std::endl
1218                        << " point="
1219                        << physical_point;
1220           libMesh::err << " local=" << check;
1221           libMesh::err << " lref= " << p;
1222 
1223           elem->print_info(libMesh::err);
1224         }
1225 
1226       // Make sure the point \p p on the reference element actually
1227       // is
1228 
1229       if (!FEAbstract::on_reference_element(p, elem->type(), 2*tolerance))
1230         {
1231           libmesh_here();
1232           libMesh::err << "WARNING:  inverse_map of physical point "
1233                        << physical_point
1234                        << "is not on element\&." << '\n';
1235           elem->print_info(libMesh::err);
1236         }
1237     }
1238 
1239 #endif
1240 
1241 
1242 
1243   //  Stop logging the map inversion\&.
1244   STOP_LOG("inverse_map()", "FE");
1245 
1246   return p;
1247 }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP"
Takes a number points in physical space (in the \fCphysical_points\fP vector) and finds their location on the reference element for the input element \fCelem\fP\&. The values on the reference element are returned in the vector \fCreference_points\fP\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.PP
Definition at line 1253 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::size()\&.
.PP
.nf
1258 {
1259   // The number of points to find the
1260   // inverse map of
1261   const std::size_t n_points = physical_points\&.size();
1262 
1263   // Resize the vector to hold the points
1264   // on the reference element
1265   reference_points\&.resize(n_points);
1266 
1267   // Find the coordinates on the reference
1268   // element of each point in physical space
1269   for (std::size_t p=0; p<n_points; p++)
1270     reference_points[p] =
1271       FE<Dim,T>::inverse_map (elem, physical_points[p], tolerance, secure);
1272 }
.fi
.SS "template<> \fBPoint\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::inverse_map (const \fBElem\fP *, const \fBPoint\fP &, const \fBReal\fP, const bool)"

.PP
Definition at line 911 of file fe_subdivision_2D\&.C\&.
.PP
.nf
915 {
916   libmesh_error();
917 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::inverse_map (const \fBElem\fP *, const std::vector< \fBPoint\fP > &, std::vector< \fBPoint\fP > &, \fBReal\fP, bool)"

.PP
Definition at line 920 of file fe_subdivision_2D\&.C\&.
.PP
.nf
925 {
926   libmesh_error();
927 }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 113 of file fe_scalar\&.C\&.
.PP
.nf
113 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 114 of file fe_scalar\&.C\&.
.PP
.nf
114 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 115 of file fe_scalar\&.C\&.
.PP
.nf
115 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 116 of file fe_scalar\&.C\&.
.PP
.nf
116 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 195 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
195 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 196 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
196 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 197 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
197 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 198 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
198 { return true; }
.fi
.SS "template<unsigned int Dim, FEFamily T> virtual bool \fBlibMesh::FE\fP< Dim, T >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 302 of file fe_clough\&.C\&.
.PP
.nf
302 { return false; } // FIXME - this will be changed
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 303 of file fe_clough\&.C\&.
.PP
.nf
303 { return false; } // FIXME - this will be changed
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 304 of file fe_clough\&.C\&.
.PP
.nf
304 { return false; } // FIXME - this will be changed
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 305 of file fe_clough\&.C\&.
.PP
.nf
305 { return false; } // FIXME - this will be changed
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 330 of file fe_hermite\&.C\&.
.PP
.nf
330 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 331 of file fe_hermite\&.C\&.
.PP
.nf
331 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 332 of file fe_hermite\&.C\&.
.PP
.nf
332 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 333 of file fe_hermite\&.C\&.
.PP
.nf
333 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 357 of file fe_hierarchic\&.C\&.
.PP
.nf
357 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 358 of file fe_hierarchic\&.C\&.
.PP
.nf
358 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 359 of file fe_hierarchic\&.C\&.
.PP
.nf
359 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 360 of file fe_hierarchic\&.C\&.
.PP
.nf
360 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 383 of file fe_monomial\&.C\&.
.PP
.nf
383 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 384 of file fe_monomial\&.C\&.
.PP
.nf
384 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 385 of file fe_monomial\&.C\&.
.PP
.nf
385 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 386 of file fe_monomial\&.C\&.
.PP
.nf
386 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 426 of file fe_bernstein\&.C\&.
.PP
.nf
426 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 427 of file fe_bernstein\&.C\&.
.PP
.nf
427 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 428 of file fe_bernstein\&.C\&.
.PP
.nf
428 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 429 of file fe_bernstein\&.C\&.
.PP
.nf
429 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 470 of file fe_l2_lagrange\&.C\&.
.PP
.nf
470 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 471 of file fe_l2_lagrange\&.C\&.
.PP
.nf
471 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 472 of file fe_l2_lagrange\&.C\&.
.PP
.nf
472 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 473 of file fe_l2_lagrange\&.C\&.
.PP
.nf
473 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 552 of file fe_nedelec_one\&.C\&.
.PP
.nf
552 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 553 of file fe_nedelec_one\&.C\&.
.PP
.nf
553 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 554 of file fe_nedelec_one\&.C\&.
.PP
.nf
554 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 555 of file fe_nedelec_one\&.C\&.
.PP
.nf
555 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 860 of file fe_lagrange\&.C\&.
.PP
.nf
860 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 861 of file fe_lagrange\&.C\&.
.PP
.nf
861 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 862 of file fe_lagrange\&.C\&.
.PP
.nf
862 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 863 of file fe_lagrange\&.C\&.
.PP
.nf
863 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 879 of file fe_xyz\&.C\&.
.PP
.nf
879 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 880 of file fe_xyz\&.C\&.
.PP
.nf
880 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 881 of file fe_xyz\&.C\&.
.PP
.nf
881 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 882 of file fe_xyz\&.C\&.
.PP
.nf
882 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 933 of file fe_lagrange_vec\&.C\&.
.PP
.nf
933 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 934 of file fe_lagrange_vec\&.C\&.
.PP
.nf
934 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 935 of file fe_lagrange_vec\&.C\&.
.PP
.nf
935 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 936 of file fe_lagrange_vec\&.C\&.
.PP
.nf
936 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 948 of file fe_subdivision_2D\&.C\&.
.PP
.nf
948 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1234 of file fe_szabab\&.C\&.
.PP
.nf
1234 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1235 of file fe_szabab\&.C\&.
.PP
.nf
1235 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1236 of file fe_szabab\&.C\&.
.PP
.nf
1236 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::is_hierarchic () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1237 of file fe_szabab\&.C\&.
.PP
.nf
1237 { return true; }
.fi
.SS "template<unsigned int Dim, FEFamily T> \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.PP
Definition at line 1278 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::Elem::default_order(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::Elem::point(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map()\&.
.PP
.nf
1280 {
1281   libmesh_assert(elem);
1282 
1283   Point p;
1284 
1285   const ElemType type     = elem->type();
1286   const Order order       = elem->default_order();
1287   const unsigned int n_sf = FE<Dim,LAGRANGE>::n_shape_functions(type, order);
1288 
1289   // Lagrange basis functions are used for mapping
1290   for (unsigned int i=0; i<n_sf; i++)
1291     p\&.add_scaled (elem->point(i),
1292                   FE<Dim,LAGRANGE>::shape(type,
1293                                           order,
1294                                           i,
1295                                           reference_point)
1296                   );
1297 
1298   return p;
1299 }
.fi
.SS "template<unsigned int Dim, FEFamily T> \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_eta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/deta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.PP
Definition at line 1333 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::Elem::default_order(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::Elem::point(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEMap::compute_face_map(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map()\&.
.PP
.nf
1335 {
1336   libmesh_assert(elem);
1337 
1338   Point p;
1339 
1340   const ElemType type     = elem->type();
1341   const Order order       = elem->default_order();
1342   const unsigned int n_sf = FE<Dim,LAGRANGE>::n_shape_functions(type, order);
1343 
1344   // Lagrange basis functions are used for mapping
1345   for (unsigned int i=0; i<n_sf; i++)
1346     p\&.add_scaled (elem->point(i),
1347                   FE<Dim,LAGRANGE>::shape_deriv(type,
1348                                                 order,
1349                                                 i,
1350                                                 1,
1351                                                 reference_point)
1352                   );
1353 
1354   return p;
1355 }
.fi
.SS "template<unsigned int Dim, FEFamily T> \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_xi (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dxi (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.PP
Definition at line 1305 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::Elem::default_order(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::Elem::point(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEMap::compute_face_map(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map()\&.
.PP
.nf
1307 {
1308   libmesh_assert(elem);
1309 
1310   Point p;
1311 
1312   const ElemType type     = elem->type();
1313   const Order order       = elem->default_order();
1314   const unsigned int n_sf = FE<Dim,LAGRANGE>::n_shape_functions(type, order);
1315 
1316   // Lagrange basis functions are used for mapping
1317   for (unsigned int i=0; i<n_sf; i++)
1318     p\&.add_scaled (elem->point(i),
1319                   FE<Dim,LAGRANGE>::shape_deriv(type,
1320                                                 order,
1321                                                 i,
1322                                                 0,
1323                                                 reference_point)
1324                   );
1325 
1326   return p;
1327 }
.fi
.SS "template<unsigned int Dim, FEFamily T> \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_zeta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dzeta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.PP
Definition at line 1361 of file fe_map\&.C\&.
.PP
References libMesh::TypeVector< T >::add_scaled(), libMesh::Elem::default_order(), libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::Elem::point(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FE< Dim, T >::inverse_map()\&.
.PP
.nf
1363 {
1364   libmesh_assert(elem);
1365 
1366   Point p;
1367 
1368   const ElemType type     = elem->type();
1369   const Order order       = elem->default_order();
1370   const unsigned int n_sf = FE<Dim,LAGRANGE>::n_shape_functions(type, order);
1371 
1372   // Lagrange basis functions are used for mapping
1373   for (unsigned int i=0; i<n_sf; i++)
1374     p\&.add_scaled (elem->point(i),
1375                   FE<Dim,LAGRANGE>::shape_deriv(type,
1376                                                 order,
1377                                                 i,
1378                                                 2,
1379                                                 reference_point)
1380                   );
1381 
1382   return p;
1383 }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fPo)"

.PP
Definition at line 87 of file fe_scalar\&.C\&.
.PP
.nf
87 { return o; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fPo)"

.PP
Definition at line 88 of file fe_scalar\&.C\&.
.PP
.nf
88 { return o; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fPo)"

.PP
Definition at line 89 of file fe_scalar\&.C\&.
.PP
.nf
89 { return o; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fPo)"

.PP
Definition at line 90 of file fe_scalar\&.C\&.
.PP
.nf
90 { return o; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 170 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
170 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 171 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
171 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 172 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
172 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 173 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
173 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<unsigned int Dim, FEFamily T> static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Referenced by libMesh::FE< Dim, T >::n_dofs(), libMesh::FE< Dim, T >::n_shape_functions(), and libMesh::FE< Dim, LAGRANGE_VEC >::n_shape_functions()\&.
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 277 of file fe_clough\&.C\&.
.PP
.nf
277 { return clough_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 278 of file fe_clough\&.C\&.
.PP
.nf
278 { return clough_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 279 of file fe_clough\&.C\&.
.PP
.nf
279 { return clough_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 280 of file fe_clough\&.C\&.
.PP
.nf
280 { return clough_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 305 of file fe_hermite\&.C\&.
.PP
.nf
305 { return hermite_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 306 of file fe_hermite\&.C\&.
.PP
.nf
306 { return hermite_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 307 of file fe_hermite\&.C\&.
.PP
.nf
307 { return hermite_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 308 of file fe_hermite\&.C\&.
.PP
.nf
308 { return hermite_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 333 of file fe_hierarchic\&.C\&.
.PP
.nf
333 { return hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 334 of file fe_hierarchic\&.C\&.
.PP
.nf
334 { return hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 335 of file fe_hierarchic\&.C\&.
.PP
.nf
335 { return hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 336 of file fe_hierarchic\&.C\&.
.PP
.nf
336 { return hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 356 of file fe_monomial\&.C\&.
.PP
.nf
356 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 357 of file fe_monomial\&.C\&.
.PP
.nf
357 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 358 of file fe_monomial\&.C\&.
.PP
.nf
358 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 359 of file fe_monomial\&.C\&.
.PP
.nf
359 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 402 of file fe_bernstein\&.C\&.
.PP
.nf
402 { return bernstein_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 403 of file fe_bernstein\&.C\&.
.PP
.nf
403 { return bernstein_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 404 of file fe_bernstein\&.C\&.
.PP
.nf
404 { return bernstein_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 405 of file fe_bernstein\&.C\&.
.PP
.nf
405 { return bernstein_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 444 of file fe_l2_lagrange\&.C\&.
.PP
.nf
444 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 445 of file fe_l2_lagrange\&.C\&.
.PP
.nf
445 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 446 of file fe_l2_lagrange\&.C\&.
.PP
.nf
446 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 447 of file fe_l2_lagrange\&.C\&.
.PP
.nf
447 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 524 of file fe_nedelec_one\&.C\&.
.PP
.nf
524 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 525 of file fe_nedelec_one\&.C\&.
.PP
.nf
525 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 526 of file fe_nedelec_one\&.C\&.
.PP
.nf
526 { return nedelec_one_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 527 of file fe_nedelec_one\&.C\&.
.PP
.nf
527 { return nedelec_one_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 832 of file fe_lagrange\&.C\&.
.PP
.nf
832 { return lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 833 of file fe_lagrange\&.C\&.
.PP
.nf
833 { return lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 834 of file fe_lagrange\&.C\&.
.PP
.nf
834 { return lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 835 of file fe_lagrange\&.C\&.
.PP
.nf
835 { return lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 853 of file fe_xyz\&.C\&.
.PP
.nf
853 { return xyz_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 854 of file fe_xyz\&.C\&.
.PP
.nf
854 { return xyz_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 855 of file fe_xyz\&.C\&.
.PP
.nf
855 { return xyz_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 856 of file fe_xyz\&.C\&.
.PP
.nf
856 { return xyz_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 905 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs()\&.
.PP
.nf
905 { return FE<0,LAGRANGE>::n_dofs(t,o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 906 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs()\&.
.PP
.nf
906 { return FE<1,LAGRANGE>::n_dofs(t,o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 907 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs()\&.
.PP
.nf
907 { return 2*FE<2,LAGRANGE>::n_dofs(t,o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 908 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs()\&.
.PP
.nf
908 { return 3*FE<3,LAGRANGE>::n_dofs(t,o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::n_dofs (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 932 of file fe_subdivision_2D\&.C\&.
.PP
.nf
932 { libmesh_error(); return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1210 of file fe_szabab\&.C\&.
.PP
.nf
1210 { return szabab_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1211 of file fe_szabab\&.C\&.
.PP
.nf
1211 { return szabab_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1212 of file fe_szabab\&.C\&.
.PP
.nf
1212 { return szabab_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1213 of file fe_szabab\&.C\&.
.PP
.nf
1213 { return szabab_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 94 of file fe_scalar\&.C\&.
.PP
.nf
94 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 95 of file fe_scalar\&.C\&.
.PP
.nf
95 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 96 of file fe_scalar\&.C\&.
.PP
.nf
96 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 97 of file fe_scalar\&.C\&.
.PP
.nf
97 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 177 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
177 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 178 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
178 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 179 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
179 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 180 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
180 { return 0; }
.fi
.SS "template<unsigned int Dim, FEFamily T> static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs at node \fCn\fP for a finite element of type \fCt\fP and order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Referenced by libMesh::FE< Dim, T >::n_dofs_at_node()\&.
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 284 of file fe_clough\&.C\&.
.PP
.nf
284 { return clough_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 285 of file fe_clough\&.C\&.
.PP
.nf
285 { return clough_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 286 of file fe_clough\&.C\&.
.PP
.nf
286 { return clough_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 287 of file fe_clough\&.C\&.
.PP
.nf
287 { return clough_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 312 of file fe_hermite\&.C\&.
.PP
.nf
312 { return hermite_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 313 of file fe_hermite\&.C\&.
.PP
.nf
313 { return hermite_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 314 of file fe_hermite\&.C\&.
.PP
.nf
314 { return hermite_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 315 of file fe_hermite\&.C\&.
.PP
.nf
315 { return hermite_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 339 of file fe_hierarchic\&.C\&.
.PP
.nf
339 { return hierarchic_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 340 of file fe_hierarchic\&.C\&.
.PP
.nf
340 { return hierarchic_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 341 of file fe_hierarchic\&.C\&.
.PP
.nf
341 { return hierarchic_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 342 of file fe_hierarchic\&.C\&.
.PP
.nf
342 { return hierarchic_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 363 of file fe_monomial\&.C\&.
.PP
.nf
363 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 364 of file fe_monomial\&.C\&.
.PP
.nf
364 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 365 of file fe_monomial\&.C\&.
.PP
.nf
365 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 366 of file fe_monomial\&.C\&.
.PP
.nf
366 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 408 of file fe_bernstein\&.C\&.
.PP
.nf
408 { return bernstein_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 409 of file fe_bernstein\&.C\&.
.PP
.nf
409 { return bernstein_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 410 of file fe_bernstein\&.C\&.
.PP
.nf
410 { return bernstein_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 411 of file fe_bernstein\&.C\&.
.PP
.nf
411 { return bernstein_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 451 of file fe_l2_lagrange\&.C\&.
.PP
.nf
451 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 452 of file fe_l2_lagrange\&.C\&.
.PP
.nf
452 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 453 of file fe_l2_lagrange\&.C\&.
.PP
.nf
453 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 454 of file fe_l2_lagrange\&.C\&.
.PP
.nf
454 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 532 of file fe_nedelec_one\&.C\&.
.PP
.nf
532 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 533 of file fe_nedelec_one\&.C\&.
.PP
.nf
533 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 534 of file fe_nedelec_one\&.C\&.
.PP
.nf
534 { return nedelec_one_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 535 of file fe_nedelec_one\&.C\&.
.PP
.nf
535 { return nedelec_one_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 840 of file fe_lagrange\&.C\&.
.PP
.nf
840 { return lagrange_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 841 of file fe_lagrange\&.C\&.
.PP
.nf
841 { return lagrange_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 842 of file fe_lagrange\&.C\&.
.PP
.nf
842 { return lagrange_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 843 of file fe_lagrange\&.C\&.
.PP
.nf
843 { return lagrange_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 860 of file fe_xyz\&.C\&.
.PP
.nf
860 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 861 of file fe_xyz\&.C\&.
.PP
.nf
861 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 862 of file fe_xyz\&.C\&.
.PP
.nf
862 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 863 of file fe_xyz\&.C\&.
.PP
.nf
863 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 913 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs_at_node()\&.
.PP
.nf
913 { return FE<0,LAGRANGE>::n_dofs_at_node(t,o,n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 914 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs_at_node()\&.
.PP
.nf
914 { return FE<1,LAGRANGE>::n_dofs_at_node(t,o,n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 915 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs_at_node()\&.
.PP
.nf
915 { return 2*FE<2,LAGRANGE>::n_dofs_at_node(t,o,n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 916 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs_at_node()\&.
.PP
.nf
916 { return 3*FE<2,LAGRANGE>::n_dofs_at_node(t,o,n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::n_dofs_at_node (const \fBElemType\fP, const \fBOrder\fP, const unsignedint)"

.PP
Definition at line 935 of file fe_subdivision_2D\&.C\&.
.PP
.nf
935 { return 1; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 1216 of file fe_szabab\&.C\&.
.PP
.nf
1216 { return szabab_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 1217 of file fe_szabab\&.C\&.
.PP
.nf
1217 { return szabab_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 1218 of file fe_szabab\&.C\&.
.PP
.nf
1218 { return szabab_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)"

.PP
Definition at line 1219 of file fe_szabab\&.C\&.
.PP
.nf
1219 { return szabab_n_dofs_at_node(t, o, n); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 101 of file fe_scalar\&.C\&.
.PP
.nf
101 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 102 of file fe_scalar\&.C\&.
.PP
.nf
102 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 103 of file fe_scalar\&.C\&.
.PP
.nf
103 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 104 of file fe_scalar\&.C\&.
.PP
.nf
104 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 183 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
183 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 184 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
184 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 185 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
185 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 186 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
186 { return l2_hierarchic_n_dofs(t, o); }
.fi
.SS "template<unsigned int Dim, FEFamily T> static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs interior to the element, not associated with any interior nodes\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 290 of file fe_clough\&.C\&.
.PP
.nf
290 { return clough_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 291 of file fe_clough\&.C\&.
.PP
.nf
291 { return clough_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 292 of file fe_clough\&.C\&.
.PP
.nf
292 { return clough_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 293 of file fe_clough\&.C\&.
.PP
.nf
293 { return clough_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 318 of file fe_hermite\&.C\&.
.PP
.nf
318 { return hermite_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 319 of file fe_hermite\&.C\&.
.PP
.nf
319 { return hermite_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 320 of file fe_hermite\&.C\&.
.PP
.nf
320 { return hermite_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 321 of file fe_hermite\&.C\&.
.PP
.nf
321 { return hermite_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 345 of file fe_hierarchic\&.C\&.
.PP
.nf
345 { return hierarchic_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 346 of file fe_hierarchic\&.C\&.
.PP
.nf
346 { return hierarchic_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 347 of file fe_hierarchic\&.C\&.
.PP
.nf
347 { return hierarchic_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 348 of file fe_hierarchic\&.C\&.
.PP
.nf
348 { return hierarchic_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 369 of file fe_monomial\&.C\&.
.PP
.nf
369 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 370 of file fe_monomial\&.C\&.
.PP
.nf
370 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 371 of file fe_monomial\&.C\&.
.PP
.nf
371 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 372 of file fe_monomial\&.C\&.
.PP
.nf
372 { return monomial_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 414 of file fe_bernstein\&.C\&.
.PP
.nf
414 { return bernstein_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 415 of file fe_bernstein\&.C\&.
.PP
.nf
415 { return bernstein_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 416 of file fe_bernstein\&.C\&.
.PP
.nf
416 { return bernstein_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 417 of file fe_bernstein\&.C\&.
.PP
.nf
417 { return bernstein_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 458 of file fe_l2_lagrange\&.C\&.
.PP
.nf
458 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 459 of file fe_l2_lagrange\&.C\&.
.PP
.nf
459 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 460 of file fe_l2_lagrange\&.C\&.
.PP
.nf
460 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 461 of file fe_l2_lagrange\&.C\&.
.PP
.nf
461 { return l2_lagrange_n_dofs(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 540 of file fe_nedelec_one\&.C\&.
.PP
.nf
540 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 541 of file fe_nedelec_one\&.C\&.
.PP
.nf
541 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 542 of file fe_nedelec_one\&.C\&.
.PP
.nf
542 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 543 of file fe_nedelec_one\&.C\&.
.PP
.nf
543 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 848 of file fe_lagrange\&.C\&.
.PP
.nf
848 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 849 of file fe_lagrange\&.C\&.
.PP
.nf
849 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 850 of file fe_lagrange\&.C\&.
.PP
.nf
850 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 851 of file fe_lagrange\&.C\&.
.PP
.nf
851 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 866 of file fe_xyz\&.C\&.
.PP
.nf
866 { return xyz_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 867 of file fe_xyz\&.C\&.
.PP
.nf
867 { return xyz_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 868 of file fe_xyz\&.C\&.
.PP
.nf
868 { return xyz_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 869 of file fe_xyz\&.C\&.
.PP
.nf
869 { return xyz_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 921 of file fe_lagrange_vec\&.C\&.
.PP
.nf
921 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 922 of file fe_lagrange_vec\&.C\&.
.PP
.nf
922 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 923 of file fe_lagrange_vec\&.C\&.
.PP
.nf
923 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 924 of file fe_lagrange_vec\&.C\&.
.PP
.nf
924 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::n_dofs_per_elem (const \fBElemType\fP, const \fBOrder\fP)"

.PP
Definition at line 938 of file fe_subdivision_2D\&.C\&.
.PP
.nf
938 { return 0; }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1222 of file fe_szabab\&.C\&.
.PP
.nf
1222 { return szabab_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1223 of file fe_szabab\&.C\&.
.PP
.nf
1223 { return szabab_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1224 of file fe_szabab\&.C\&.
.PP
.nf
1224 { return szabab_n_dofs_per_elem(t, o); }
.fi
.SS "template<> unsigned int \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)"

.PP
Definition at line 1225 of file fe_szabab\&.C\&.
.PP
.nf
1225 { return szabab_n_dofs_per_elem(t, o); }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "template<unsigned int Dim, FEFamily T> unsigned int \fBlibMesh::FE\fP< Dim, T >::n_quadrature_points () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Call this to get an upper bound for the \fCfor\fP loop in your simulation for matrix assembly of the current element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 55 of file fe\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
56 {
57   libmesh_assert(this->qrule);
58   return this->qrule->n_points();
59 }
.fi
.SS "template<unsigned int Dim, FEFamily T> unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 36 of file fe\&.C\&.
.PP
References libMesh::FE< Dim, T >::n_dofs()\&.
.PP
Referenced by libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FE< Dim, T >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::Base::n_base_mapping_sf()\&.
.PP
.nf
37 {
38   return FE<Dim,T>::n_dofs (this->elem_type,
39                             static_cast<Order>(this->fe_type\&.order + this->_p_level));
40 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions (const \fBElemType\fPt, const \fBOrder\fPo)\fC [inline]\fP, \fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with a finite element of type \fCt\fP and approximation order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Definition at line 226 of file fe\&.h\&.
.PP
.nf
228   { return FE<Dim,T>::n_dofs (t,o); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 58 of file fe_scalar\&.C\&.
.PP
.nf
62 { scalar_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 65 of file fe_scalar\&.C\&.
.PP
.nf
69 { scalar_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 72 of file fe_scalar\&.C\&.
.PP
.nf
76 { scalar_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 79 of file fe_scalar\&.C\&.
.PP
.nf
83 { scalar_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 142 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
146 { l2_hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 149 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
153 { l2_hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 156 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
160 { l2_hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 163 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
167 { l2_hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<unsigned int Dim, FEFamily T> static void \fBlibMesh::FE\fP< Dim, T >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPo, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)\fC [static]\fP"
Build the nodal soln from the element soln\&. This is the solution that will be plotted\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.PP
Referenced by libMesh::FE< Dim, T >::nodal_soln()\&.
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 248 of file fe_clough\&.C\&.
.PP
.nf
252 { clough_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 255 of file fe_clough\&.C\&.
.PP
.nf
259 { clough_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 262 of file fe_clough\&.C\&.
.PP
.nf
266 { clough_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 269 of file fe_clough\&.C\&.
.PP
.nf
273 { clough_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 272 of file fe_hermite\&.C\&.
.PP
.nf
276 { hermite_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 279 of file fe_hermite\&.C\&.
.PP
.nf
283 { hermite_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 286 of file fe_hermite\&.C\&.
.PP
.nf
290 { hermite_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 293 of file fe_hermite\&.C\&.
.PP
.nf
297 { hermite_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 304 of file fe_hierarchic\&.C\&.
.PP
.nf
308 { hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 311 of file fe_hierarchic\&.C\&.
.PP
.nf
315 { hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 318 of file fe_hierarchic\&.C\&.
.PP
.nf
322 { hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 325 of file fe_hierarchic\&.C\&.
.PP
.nf
329 { hierarchic_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 327 of file fe_monomial\&.C\&.
.PP
.nf
331 { monomial_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 334 of file fe_monomial\&.C\&.
.PP
.nf
338 { monomial_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 341 of file fe_monomial\&.C\&.
.PP
.nf
345 { monomial_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 348 of file fe_monomial\&.C\&.
.PP
.nf
352 { monomial_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 373 of file fe_bernstein\&.C\&.
.PP
.nf
377 { bernstein_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 380 of file fe_bernstein\&.C\&.
.PP
.nf
384 { bernstein_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 387 of file fe_bernstein\&.C\&.
.PP
.nf
391 { bernstein_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 394 of file fe_bernstein\&.C\&.
.PP
.nf
398 { bernstein_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 413 of file fe_l2_lagrange\&.C\&.
.PP
.nf
417 { l2_lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 420 of file fe_l2_lagrange\&.C\&.
.PP
.nf
424 { l2_lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 427 of file fe_l2_lagrange\&.C\&.
.PP
.nf
431 { l2_lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 434 of file fe_l2_lagrange\&.C\&.
.PP
.nf
438 { l2_lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::nodal_soln (const \fBElem\fP *, const \fBOrder\fP, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &)"

.PP
Definition at line 493 of file fe_nedelec_one\&.C\&.
.PP
.nf
497 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::nodal_soln (const \fBElem\fP *, const \fBOrder\fP, const std::vector< \fBNumber\fP > &, std::vector< \fBNumber\fP > &)"

.PP
Definition at line 500 of file fe_nedelec_one\&.C\&.
.PP
.nf
504 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 507 of file fe_nedelec_one\&.C\&.
.PP
.nf
511 { nedelec_one_nodal_soln(elem, order, elem_soln, 2 /*dim*/, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 507 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::nodal_soln()\&.
.PP
.nf
511 { FE<0,LAGRANGE>::nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 514 of file fe_nedelec_one\&.C\&.
.PP
.nf
518 { nedelec_one_nodal_soln(elem, order, elem_soln, 3 /*dim*/, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 514 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::FE< Dim, T >::nodal_soln()\&.
.PP
.nf
518 { FE<1,LAGRANGE>::nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 521 of file fe_lagrange_vec\&.C\&.
.PP
.nf
525 { lagrange_vec_nodal_soln(elem, order, elem_soln, 2 /*dimension*/, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 528 of file fe_lagrange_vec\&.C\&.
.PP
.nf
532 { lagrange_vec_nodal_soln(elem, order, elem_soln, 3 /*dimension*/, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 801 of file fe_lagrange\&.C\&.
.PP
.nf
805 { lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 808 of file fe_lagrange\&.C\&.
.PP
.nf
812 { lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 815 of file fe_lagrange\&.C\&.
.PP
.nf
819 { lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 822 of file fe_lagrange\&.C\&.
.PP
.nf
826 { lagrange_nodal_soln(elem, order, elem_soln, nodal_soln); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 823 of file fe_xyz\&.C\&.
.PP
.nf
827 { xyz_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 830 of file fe_xyz\&.C\&.
.PP
.nf
834 { xyz_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 837 of file fe_xyz\&.C\&.
.PP
.nf
841 { xyz_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 844 of file fe_xyz\&.C\&.
.PP
.nf
848 { xyz_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fP, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 853 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Tri3Subdivision::local_node_number(), libMesh::TRI3SUBDIVISION, and libMesh::Elem::type()\&.
.PP
.nf
857 {
858   libmesh_assert(elem);
859   libmesh_assert_equal_to(elem->type(), TRI3SUBDIVISION);
860   const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
861 
862   nodal_soln\&.resize(3); // three nodes per element
863 
864   // Ghost nodes are auxiliary\&.
865   if (sd_elem->is_ghost())
866     {
867       nodal_soln[0] = 0;
868       nodal_soln[1] = 0;
869       nodal_soln[2] = 0;
870       return;
871     }
872 
873   // First node (node 0 in the element patch):
874   unsigned int j = sd_elem->local_node_number(sd_elem->get_ordered_node(0)->id());
875   nodal_soln[j] = elem_soln[0];
876 
877   // Second node (node 1 in the element patch):
878   j = sd_elem->local_node_number(sd_elem->get_ordered_node(1)->id());
879   nodal_soln[j] = elem_soln[1];
880 
881   // Third node (node 'valence' in the element patch):
882   j = sd_elem->local_node_number(sd_elem->get_ordered_node(2)->id());
883   nodal_soln[j] = elem_soln[sd_elem->get_ordered_valence(0)];
884 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 1181 of file fe_szabab\&.C\&.
.PP
.nf
1185 { szabab_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/0); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 1188 of file fe_szabab\&.C\&.
.PP
.nf
1192 { szabab_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/1); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 1195 of file fe_szabab\&.C\&.
.PP
.nf
1199 { szabab_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/2); }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPorder, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"

.PP
Definition at line 1202 of file fe_szabab\&.C\&.
.PP
.nf
1206 { szabab_nodal_soln(elem, order, elem_soln, nodal_soln, /*Dim=*/3); }
.fi
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_d2phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_dphi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const\fC [inherited]\fP"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_dphi(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_phi(), and libMesh::FEAbstract::print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
This is at the core of this class\&. Use this for each new element in the mesh\&. Reinitializes all the physical element-dependent data based on the current element \fCelem\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::FESubdivision\fP\&.
.PP
Definition at line 115 of file fe\&.C\&.
.PP
References libMesh::dim, libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::Elem::p_level(), libMesh::Elem::point(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::FEXYZ< Dim >::reinit()\&.
.PP
.nf
118 {
119   libmesh_assert(elem);
120 
121   // Try to avoid calling init_shape_functions
122   // even when shapes_need_reinit
123   bool cached_nodes_still_fit = false;
124 
125   // Initialize the shape functions at the user-specified
126   // points
127   if (pts != NULL)
128     {
129       // Set the type and p level for this element
130       this->elem_type = elem->type();
131       this->_p_level = elem->p_level();
132 
133       // Initialize the shape functions
134       this->_fe_map->template init_reference_to_physical_map<Dim>(*pts, elem);
135       this->init_shape_functions (*pts, elem);
136 
137       // The shape functions do not correspond to the qrule
138       this->shapes_on_quadrature = false;
139     }
140 
141   // If there are no user specified points, we use the
142   // quadrature rule
143 
144   // update the type in accordance to the current cell
145   // and reinit if the cell type has changed or (as in
146   // the case of the hierarchics) the shape functions need
147   // reinit, since they depend on the particular element shape
148   else
149     {
150       libmesh_assert(this->qrule);
151       this->qrule->init(elem->type(), elem->p_level());
152 
153       if(this->qrule->shapes_need_reinit())
154         this->shapes_on_quadrature = false;
155 
156       if (this->elem_type != elem->type() ||
157           this->_p_level != elem->p_level() ||
158           !this->shapes_on_quadrature)
159         {
160           // Set the type and p level for this element
161           this->elem_type = elem->type();
162           this->_p_level = elem->p_level();
163           // Initialize the shape functions
164           this->_fe_map->template init_reference_to_physical_map<Dim>(this->qrule->get_points(), elem);
165           this->init_shape_functions (this->qrule->get_points(), elem);
166 
167           if (this->shapes_need_reinit())
168             {
169               cached_nodes\&.resize(elem->n_nodes());
170               for (unsigned int n = 0; n != elem->n_nodes(); ++n)
171                 {
172                   cached_nodes[n] = elem->point(n);
173                 }
174             }
175         }
176       else
177         {
178           // libmesh_assert_greater (elem->n_nodes(), 1);
179 
180           cached_nodes_still_fit = true;
181           if (cached_nodes\&.size() != elem->n_nodes())
182             cached_nodes_still_fit = false;
183           else
184             for (unsigned int n = 1; n < elem->n_nodes(); ++n)
185               {
186                 if (!(elem->point(n) - elem->point(0))\&.relative_fuzzy_equals(
187                                                                              (cached_nodes[n] - cached_nodes[0]), 1e-13))
188                   {
189                     cached_nodes_still_fit = false;
190                     break;
191                   }
192               }
193 
194           if (this->shapes_need_reinit() && !cached_nodes_still_fit)
195             {
196               this->_fe_map->template init_reference_to_physical_map<Dim>(this->qrule->get_points(), elem);
197               this->init_shape_functions (this->qrule->get_points(), elem);
198               cached_nodes\&.resize(elem->n_nodes());
199               for (unsigned int n = 0; n != elem->n_nodes(); ++n)
200                 cached_nodes[n] = elem->point(n);
201             }
202         }
203 
204       // The shape functions correspond to the qrule
205       this->shapes_on_quadrature = true;
206     }
207 
208   // Compute the map for this element\&.  In the future we can specify
209   // different types of maps
210   if (pts != NULL)
211     {
212       if (weights != NULL)
213         {
214           this->_fe_map->compute_map (this->dim,*weights, elem);
215         }
216       else
217         {
218           std::vector<Real> dummy_weights (pts->size(), 1\&.);
219           this->_fe_map->compute_map (this->dim,dummy_weights, elem);
220         }
221     }
222   else
223     {
224       this->_fe_map->compute_map (this->dim,this->qrule->get_weights(), elem);
225     }
226 
227   // Compute the shape functions and the derivatives at all of the
228   // quadrature points\&.
229   if (!cached_nodes_still_fit)
230     {
231       if (pts != NULL)
232         this->compute_shape_functions (elem,*pts);
233       else
234         this->compute_shape_functions(elem,this->qrule->get_points());
235     }
236 }
.fi
.SS "template<unsigned int Dim, FEFamily T> virtual void \fBlibMesh::FE\fP< Dim, T >::reinit (const \fBElem\fP *elem, const unsigned intside, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
Reinitializes all the physical element-dependent data based on the \fCside\fP of \fCface\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference \fIside\fP element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::FESubdivision\fP, \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
33 {
34 #if LIBMESH_DIM > 1
35   libMesh::err << "Nedelec elements require the element type\n"
36                << "because edge orientation is needed\&."
37                << std::endl;
38   libmesh_error();
39 #endif // LIBMESH_DIM > 1
40 
41   libmesh_error();
42   return RealGradient();
43 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
33 {
34 #if LIBMESH_DIM == 3
35   libMesh::err << "Nedelec elements require the element type\n"
36                << "because edge orientation is needed\&."
37                << std::endl;
38   libmesh_error();
39 #endif
40 
41   libmesh_error();
42   return RealGradient();
43 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
33 {
34   return 1\&.;
35 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
33 {
34   return 1\&.;
35 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
33 {
34   return 1\&.;
35 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 29 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
33 {
34   return 1\&.;
35 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
36 {
37   const Real xi = p(0);
38 
39   libmesh_assert_less_equal (i, static_cast<unsigned int>(order));
40 
41   // monomials\&. since they are hierarchic we only need one case block\&.
42   switch (i)
43     {
44     case 0:
45       return 1\&.;
46 
47     case 1:
48       return xi;
49 
50     case 2:
51       return xi*xi;
52 
53     case 3:
54       return xi*xi*xi;
55 
56     case 4:
57       return xi*xi*xi*xi;
58 
59     default:
60       Real val = 1\&.;
61       for (unsigned int index = 0; index != i; ++index)
62         val *= xi;
63       return val;
64     }
65 
66   libmesh_error();
67   return 0\&.;
68 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned inti, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
36 {
37   libMesh::err << "Hierarchic polynomials require the element type\n"
38                << "because edge orientation is needed\&."
39                << std::endl;
40 
41   libmesh_error();
42   return 0\&.;
43 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
36 {
37   const Real xi = p(0);
38 
39 
40   switch (order)
41     {
42       // Lagrange linears
43     case FIRST:
44       {
45         libmesh_assert_less (i, 2);
46 
47         switch (i)
48           {
49           case 0:
50             return \&.5*(1\&. - xi);
51 
52           case 1:
53             return \&.5*(1\&. + xi);
54 
55           default:
56             libMesh::err << "Invalid shape function index!" << std::endl;
57             libmesh_error();
58           }
59       }
60 
61 
62 
63       // Lagrange quadratics
64     case SECOND:
65       {
66         libmesh_assert_less (i, 3);
67 
68         switch (i)
69           {
70           case 0:
71             return \&.5*xi*(xi - 1\&.);
72 
73           case 1:
74             return \&.5*xi*(xi + 1);
75 
76           case 2:
77             return (1\&. - xi*xi);
78 
79           default:
80             libMesh::err << "Invalid shape function index!" << std::endl;
81             libmesh_error();
82           }
83       }
84 
85 
86 
87       // Lagrange cubics
88     case THIRD:
89       {
90         libmesh_assert_less (i, 4);
91 
92         switch (i)
93           {
94           case 0:
95             return 9\&./16\&.*(1\&./9\&.-xi*xi)*(xi-1\&.);
96 
97           case 1:
98             return -9\&./16\&.*(1\&./9\&.-xi*xi)*(xi+1\&.);
99 
100           case 2:
101             return 27\&./16\&.*(1\&.-xi*xi)*(1\&./3\&.-xi);
102 
103           case 3:
104             return 27\&./16\&.*(1\&.-xi*xi)*(1\&./3\&.+xi);
105 
106           default:
107             libMesh::err << "Invalid shape function index!" << std::endl;
108             libmesh_error();
109           }
110       }
111 
112     default:
113       {
114         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
115         libmesh_error();
116       }
117     }
118 
119 
120   libmesh_error();
121   return 0\&.;
122 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM > 1
38 
39   switch (order)
40     {
41       // linear Lagrange shape functions
42     case FIRST:
43       {
44         switch (type)
45           {
46           case QUAD4:
47           case QUAD8:
48           case QUAD9:
49             {
50               // Compute quad shape functions as a tensor-product
51               const Real xi  = p(0);
52               const Real eta = p(1);
53 
54               libmesh_assert_less (i, 4);
55 
56               //                                0  1  2  3
57               static const unsigned int i0[] = {0, 1, 1, 0};
58               static const unsigned int i1[] = {0, 0, 1, 1};
59 
60               return (FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i0[i], xi)*
61                       FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i1[i], eta));
62             }
63 
64           case TRI3:
65           case TRI6:
66             {
67               const Real zeta1 = p(0);
68               const Real zeta2 = p(1);
69               const Real zeta0 = 1\&. - zeta1 - zeta2;
70 
71               libmesh_assert_less (i, 3);
72 
73               switch(i)
74                 {
75                 case 0:
76                   return zeta0;
77 
78                 case 1:
79                   return zeta1;
80 
81                 case 2:
82                   return zeta2;
83 
84                 default:
85                   libmesh_error();
86 
87                 }
88             }
89 
90           default:
91             {
92               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
93                            << std::endl;
94               libmesh_error();
95             }
96           }
97       }
98 
99 
100       // quadratic Lagrange shape functions
101     case SECOND:
102       {
103         switch (type)
104           {
105           case QUAD8:
106             {
107               const Real xi  = p(0);
108               const Real eta = p(1);
109 
110               libmesh_assert_less (i, 8);
111 
112               switch (i)
113                 {
114                 case 0:
115                   return \&.25*(1\&. - xi)*(1\&. - eta)*(-1\&. - xi - eta);
116 
117                 case 1:
118                   return \&.25*(1\&. + xi)*(1\&. - eta)*(-1\&. + xi - eta);
119 
120                 case 2:
121                   return \&.25*(1\&. + xi)*(1\&. + eta)*(-1\&. + xi + eta);
122 
123                 case 3:
124                   return \&.25*(1\&. - xi)*(1\&. + eta)*(-1\&. - xi + eta);
125 
126                 case 4:
127                   return \&.5*(1\&. - xi*xi)*(1\&. - eta);
128 
129                 case 5:
130                   return \&.5*(1\&. + xi)*(1\&. - eta*eta);
131 
132                 case 6:
133                   return \&.5*(1\&. - xi*xi)*(1\&. + eta);
134 
135                 case 7:
136                   return \&.5*(1\&. - xi)*(1\&. - eta*eta);
137 
138                 default:
139                   libmesh_error();
140                 }
141             }
142 
143           case QUAD9:
144             {
145               // Compute quad shape functions as a tensor-product
146               const Real xi  = p(0);
147               const Real eta = p(1);
148 
149               libmesh_assert_less (i, 9);
150 
151               //                                0  1  2  3  4  5  6  7  8
152               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
153               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
154 
155               return (FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], xi)*
156                       FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i1[i], eta));
157             }
158 
159           case TRI6:
160             {
161               const Real zeta1 = p(0);
162               const Real zeta2 = p(1);
163               const Real zeta0 = 1\&. - zeta1 - zeta2;
164 
165               libmesh_assert_less (i, 6);
166 
167               switch(i)
168                 {
169                 case 0:
170                   return 2\&.*zeta0*(zeta0-0\&.5);
171 
172                 case 1:
173                   return 2\&.*zeta1*(zeta1-0\&.5);
174 
175                 case 2:
176                   return 2\&.*zeta2*(zeta2-0\&.5);
177 
178                 case 3:
179                   return 4\&.*zeta0*zeta1;
180 
181                 case 4:
182                   return 4\&.*zeta1*zeta2;
183 
184                 case 5:
185                   return 4\&.*zeta2*zeta0;
186 
187                 default:
188                   libmesh_error();
189 
190                 }
191             }
192 
193           default:
194             {
195               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
196                            << std::endl;
197               libmesh_error();
198             }
199           }
200       }
201 
202 
203 
204       // unsupported order
205     default:
206       {
207         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
208                      << std::endl;
209         libmesh_error();
210       }
211     }
212 
213   libmesh_error();
214   return 0\&.;
215 
216 #endif
217 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID5, libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI6, and libMesh::x\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM == 3
38 
39 
40   switch (order)
41     {
42       // linear Lagrange shape functions
43     case FIRST:
44       {
45         switch (type)
46           {
47             // trilinear hexahedral shape functions
48           case HEX8:
49           case HEX20:
50           case HEX27:
51             {
52               libmesh_assert_less (i, 8);
53 
54               // Compute hex shape functions as a tensor-product
55               const Real xi   = p(0);
56               const Real eta  = p(1);
57               const Real zeta = p(2);
58 
59               //                                0  1  2  3  4  5  6  7
60               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
61               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
62               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
63 
64               return (FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i0[i], xi)*
65                       FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i1[i], eta)*
66                       FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i2[i], zeta));
67             }
68 
69             // linear tetrahedral shape functions
70           case TET4:
71           case TET10:
72             {
73               libmesh_assert_less (i, 4);
74 
75               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
76               const Real zeta1 = p(0);
77               const Real zeta2 = p(1);
78               const Real zeta3 = p(2);
79               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
80 
81               switch(i)
82                 {
83                 case 0:
84                   return zeta0;
85 
86                 case 1:
87                   return zeta1;
88 
89                 case 2:
90                   return zeta2;
91 
92                 case 3:
93                   return zeta3;
94 
95                 default:
96                   libmesh_error();
97                 }
98             }
99 
100             // linear prism shape functions
101           case PRISM6:
102           case PRISM15:
103           case PRISM18:
104             {
105               libmesh_assert_less (i, 6);
106 
107               // Compute prism shape functions as a tensor-product
108               // of a triangle and an edge
109 
110               Point p2d(p(0),p(1));
111               Point p1d(p(2));
112 
113               //                                0  1  2  3  4  5
114               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1};
115               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2};
116 
117               return (FE<2,L2_LAGRANGE>::shape(TRI3,  FIRST, i1[i], p2d)*
118                       FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
119             }
120 
121             // linear pyramid shape functions
122           case PYRAMID5:
123             {
124               libmesh_assert_less (i, 5);
125 
126               const Real xi   = p(0);
127               const Real eta  = p(1);
128               const Real zeta = p(2);
129               const Real eps  = 1\&.e-35;
130 
131               switch(i)
132                 {
133                 case 0:
134                   return \&.25*(zeta + xi - 1\&.)*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
135 
136                 case 1:
137                   return \&.25*(zeta - xi - 1\&.)*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
138 
139                 case 2:
140                   return \&.25*(zeta - xi - 1\&.)*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
141 
142                 case 3:
143                   return \&.25*(zeta + xi - 1\&.)*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
144 
145                 case 4:
146                   return zeta;
147 
148                 default:
149                   libmesh_error();
150                 }
151             }
152 
153 
154           default:
155             {
156               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
157                            << std::endl;
158               libmesh_error();
159             }
160           }
161       }
162 
163 
164       // quadratic Lagrange shape functions
165     case SECOND:
166       {
167         switch (type)
168           {
169 
170             // serendipity hexahedral quadratic shape functions
171           case HEX20:
172             {
173               libmesh_assert_less (i, 20);
174 
175               const Real xi   = p(0);
176               const Real eta  = p(1);
177               const Real zeta = p(2);
178 
179               // these functions are defined for (x,y,z) in [0,1]^3
180               // so transform the locations
181               const Real x = \&.5*(xi   + 1\&.);
182               const Real y = \&.5*(eta  + 1\&.);
183               const Real z = \&.5*(zeta + 1\&.);
184 
185               switch (i)
186                 {
187                 case 0:
188                   return (1\&. - x)*(1\&. - y)*(1\&. - z)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z);
189 
190                 case 1:
191                   return x*(1\&. - y)*(1\&. - z)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.);
192 
193                 case 2:
194                   return x*y*(1\&. - z)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.);
195 
196                 case 3:
197                   return (1\&. - x)*y*(1\&. - z)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.);
198 
199                 case 4:
200                   return (1\&. - x)*(1\&. - y)*z*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.);
201 
202                 case 5:
203                   return x*(1\&. - y)*z*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.);
204 
205                 case 6:
206                   return x*y*z*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.);
207 
208                 case 7:
209                   return (1\&. - x)*y*z*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.);
210 
211                 case 8:
212                   return 4\&.*x*(1\&. - x)*(1\&. - y)*(1\&. - z);
213 
214                 case 9:
215                   return 4\&.*x*y*(1\&. - y)*(1\&. - z);
216 
217                 case 10:
218                   return 4\&.*x*(1\&. - x)*y*(1\&. - z);
219 
220                 case 11:
221                   return 4\&.*(1\&. - x)*y*(1\&. - y)*(1\&. - z);
222 
223                 case 12:
224                   return 4\&.*(1\&. - x)*(1\&. - y)*z*(1\&. - z);
225 
226                 case 13:
227                   return 4\&.*x*(1\&. - y)*z*(1\&. - z);
228 
229                 case 14:
230                   return 4\&.*x*y*z*(1\&. - z);
231 
232                 case 15:
233                   return 4\&.*(1\&. - x)*y*z*(1\&. - z);
234 
235                 case 16:
236                   return 4\&.*x*(1\&. - x)*(1\&. - y)*z;
237 
238                 case 17:
239                   return 4\&.*x*y*(1\&. - y)*z;
240 
241                 case 18:
242                   return 4\&.*x*(1\&. - x)*y*z;
243 
244                 case 19:
245                   return 4\&.*(1\&. - x)*y*(1\&. - y)*z;
246 
247                 default:
248                   libmesh_error();
249                 }
250             }
251 
252             // triquadraic hexahedral shape funcions
253           case HEX27:
254             {
255               libmesh_assert_less (i, 27);
256 
257               // Compute hex shape functions as a tensor-product
258               const Real xi   = p(0);
259               const Real eta  = p(1);
260               const Real zeta = p(2);
261 
262               // The only way to make any sense of this
263               // is to look at the mgflo/mg2/mgf documentation
264               // and make the cut-out cube!
265               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
266               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
267               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
268               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
269 
270               return (FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], xi)*
271                       FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i1[i], eta)*
272                       FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i2[i], zeta));
273             }
274 
275             // quadratic tetrahedral shape functions
276           case TET10:
277             {
278               libmesh_assert_less (i, 10);
279 
280               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
281               const Real zeta1 = p(0);
282               const Real zeta2 = p(1);
283               const Real zeta3 = p(2);
284               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
285 
286               switch(i)
287                 {
288                 case 0:
289                   return zeta0*(2\&.*zeta0 - 1\&.);
290 
291                 case 1:
292                   return zeta1*(2\&.*zeta1 - 1\&.);
293 
294                 case 2:
295                   return zeta2*(2\&.*zeta2 - 1\&.);
296 
297                 case 3:
298                   return zeta3*(2\&.*zeta3 - 1\&.);
299 
300                 case 4:
301                   return 4\&.*zeta0*zeta1;
302 
303                 case 5:
304                   return 4\&.*zeta1*zeta2;
305 
306                 case 6:
307                   return 4\&.*zeta2*zeta0;
308 
309                 case 7:
310                   return 4\&.*zeta0*zeta3;
311 
312                 case 8:
313                   return 4\&.*zeta1*zeta3;
314 
315                 case 9:
316                   return 4\&.*zeta2*zeta3;
317 
318                 default:
319                   libmesh_error();
320                 }
321             }
322 
323             // quadradic prism shape functions
324           case PRISM18:
325             {
326               libmesh_assert_less (i, 18);
327 
328               // Compute prism shape functions as a tensor-product
329               // of a triangle and an edge
330 
331               Point p2d(p(0),p(1));
332               Point p1d(p(2));
333 
334               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
335               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
336               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
337 
338               return (FE<2,L2_LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
339                       FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
340             }
341 
342 
343           default:
344             {
345               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
346                            << std::endl;
347               libmesh_error();
348             }
349           }
350       }
351 
352 
353       // unsupported order
354     default:
355       {
356         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
357                      << std::endl;
358         libmesh_error();
359       }
360     }
361 
362 #endif
363 
364   libmesh_error();
365   return 0\&.;
366 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
36 {
37   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
38   libmesh_error();
39   return 0\&.;
40 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
36 {
37   const Real xi = p(0);
38 
39 
40   switch (order)
41     {
42       // Lagrange linears
43     case FIRST:
44       {
45         libmesh_assert_less (i, 2);
46 
47         switch (i)
48           {
49           case 0:
50             return \&.5*(1\&. - xi);
51 
52           case 1:
53             return \&.5*(1\&. + xi);
54 
55           default:
56             libMesh::err << "Invalid shape function index!" << std::endl;
57             libmesh_error();
58           }
59       }
60 
61 
62 
63       // Lagrange quadratics
64     case SECOND:
65       {
66         libmesh_assert_less (i, 3);
67 
68         switch (i)
69           {
70           case 0:
71             return \&.5*xi*(xi - 1\&.);
72 
73           case 1:
74             return \&.5*xi*(xi + 1);
75 
76           case 2:
77             return (1\&. - xi*xi);
78 
79           default:
80             libMesh::err << "Invalid shape function index!" << std::endl;
81             libmesh_error();
82           }
83       }
84 
85 
86 
87       // Lagrange cubics
88     case THIRD:
89       {
90         libmesh_assert_less (i, 4);
91 
92         switch (i)
93           {
94           case 0:
95             return 9\&./16\&.*(1\&./9\&.-xi*xi)*(xi-1\&.);
96 
97           case 1:
98             return -9\&./16\&.*(1\&./9\&.-xi*xi)*(xi+1\&.);
99 
100           case 2:
101             return 27\&./16\&.*(1\&.-xi*xi)*(1\&./3\&.-xi);
102 
103           case 3:
104             return 27\&./16\&.*(1\&.-xi*xi)*(1\&./3\&.+xi);
105 
106           default:
107             libMesh::err << "Invalid shape function index!" << std::endl;
108             libmesh_error();
109           }
110       }
111 
112     default:
113       {
114         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
115         libmesh_error();
116       }
117     }
118 
119 
120   libmesh_error();
121   return 0\&.;
122 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI6, and libMesh::x\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM == 3
38 
39 
40   switch (order)
41     {
42       // linear Lagrange shape functions
43     case FIRST:
44       {
45         switch (type)
46           {
47             // trilinear hexahedral shape functions
48           case HEX8:
49           case HEX20:
50           case HEX27:
51             {
52               libmesh_assert_less (i, 8);
53 
54               // Compute hex shape functions as a tensor-product
55               const Real xi   = p(0);
56               const Real eta  = p(1);
57               const Real zeta = p(2);
58 
59               //                                0  1  2  3  4  5  6  7
60               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
61               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
62               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
63 
64               return (FE<1,LAGRANGE>::shape(EDGE2, FIRST, i0[i], xi)*
65                       FE<1,LAGRANGE>::shape(EDGE2, FIRST, i1[i], eta)*
66                       FE<1,LAGRANGE>::shape(EDGE2, FIRST, i2[i], zeta));
67             }
68 
69             // linear tetrahedral shape functions
70           case TET4:
71           case TET10:
72             {
73               libmesh_assert_less (i, 4);
74 
75               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
76               const Real zeta1 = p(0);
77               const Real zeta2 = p(1);
78               const Real zeta3 = p(2);
79               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
80 
81               switch(i)
82                 {
83                 case 0:
84                   return zeta0;
85 
86                 case 1:
87                   return zeta1;
88 
89                 case 2:
90                   return zeta2;
91 
92                 case 3:
93                   return zeta3;
94 
95                 default:
96                   libmesh_error();
97                 }
98             }
99 
100             // linear prism shape functions
101           case PRISM6:
102           case PRISM15:
103           case PRISM18:
104             {
105               libmesh_assert_less (i, 6);
106 
107               // Compute prism shape functions as a tensor-product
108               // of a triangle and an edge
109 
110               Point p2d(p(0),p(1));
111               Point p1d(p(2));
112 
113               //                                0  1  2  3  4  5
114               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1};
115               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2};
116 
117               return (FE<2,LAGRANGE>::shape(TRI3,  FIRST, i1[i], p2d)*
118                       FE<1,LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
119             }
120 
121             // linear pyramid shape functions
122           case PYRAMID5:
123           case PYRAMID13:
124           case PYRAMID14:
125             {
126               libmesh_assert_less (i, 5);
127 
128               const Real xi   = p(0);
129               const Real eta  = p(1);
130               const Real zeta = p(2);
131               const Real eps  = 1\&.e-35;
132 
133               switch(i)
134                 {
135                 case 0:
136                   return \&.25*(zeta + xi - 1\&.)*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
137 
138                 case 1:
139                   return \&.25*(zeta - xi - 1\&.)*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
140 
141                 case 2:
142                   return \&.25*(zeta - xi - 1\&.)*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
143 
144                 case 3:
145                   return \&.25*(zeta + xi - 1\&.)*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
146 
147                 case 4:
148                   return zeta;
149 
150                 default:
151                   libmesh_error();
152                 }
153             }
154 
155 
156           default:
157             {
158               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
159                            << std::endl;
160               libmesh_error();
161             }
162           }
163       }
164 
165 
166       // quadratic Lagrange shape functions
167     case SECOND:
168       {
169         switch (type)
170           {
171 
172             // serendipity hexahedral quadratic shape functions
173           case HEX20:
174             {
175               libmesh_assert_less (i, 20);
176 
177               const Real xi   = p(0);
178               const Real eta  = p(1);
179               const Real zeta = p(2);
180 
181               // these functions are defined for (x,y,z) in [0,1]^3
182               // so transform the locations
183               const Real x = \&.5*(xi   + 1\&.);
184               const Real y = \&.5*(eta  + 1\&.);
185               const Real z = \&.5*(zeta + 1\&.);
186 
187               switch (i)
188                 {
189                 case 0:
190                   return (1\&. - x)*(1\&. - y)*(1\&. - z)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z);
191 
192                 case 1:
193                   return x*(1\&. - y)*(1\&. - z)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.);
194 
195                 case 2:
196                   return x*y*(1\&. - z)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.);
197 
198                 case 3:
199                   return (1\&. - x)*y*(1\&. - z)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.);
200 
201                 case 4:
202                   return (1\&. - x)*(1\&. - y)*z*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.);
203 
204                 case 5:
205                   return x*(1\&. - y)*z*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.);
206 
207                 case 6:
208                   return x*y*z*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.);
209 
210                 case 7:
211                   return (1\&. - x)*y*z*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.);
212 
213                 case 8:
214                   return 4\&.*x*(1\&. - x)*(1\&. - y)*(1\&. - z);
215 
216                 case 9:
217                   return 4\&.*x*y*(1\&. - y)*(1\&. - z);
218 
219                 case 10:
220                   return 4\&.*x*(1\&. - x)*y*(1\&. - z);
221 
222                 case 11:
223                   return 4\&.*(1\&. - x)*y*(1\&. - y)*(1\&. - z);
224 
225                 case 12:
226                   return 4\&.*(1\&. - x)*(1\&. - y)*z*(1\&. - z);
227 
228                 case 13:
229                   return 4\&.*x*(1\&. - y)*z*(1\&. - z);
230 
231                 case 14:
232                   return 4\&.*x*y*z*(1\&. - z);
233 
234                 case 15:
235                   return 4\&.*(1\&. - x)*y*z*(1\&. - z);
236 
237                 case 16:
238                   return 4\&.*x*(1\&. - x)*(1\&. - y)*z;
239 
240                 case 17:
241                   return 4\&.*x*y*(1\&. - y)*z;
242 
243                 case 18:
244                   return 4\&.*x*(1\&. - x)*y*z;
245 
246                 case 19:
247                   return 4\&.*(1\&. - x)*y*(1\&. - y)*z;
248 
249                 default:
250                   libmesh_error();
251                 }
252             }
253 
254             // triquadraic hexahedral shape funcions
255           case HEX27:
256             {
257               libmesh_assert_less (i, 27);
258 
259               // Compute hex shape functions as a tensor-product
260               const Real xi   = p(0);
261               const Real eta  = p(1);
262               const Real zeta = p(2);
263 
264               // The only way to make any sense of this
265               // is to look at the mgflo/mg2/mgf documentation
266               // and make the cut-out cube!
267               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
268               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
269               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
270               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
271 
272               return (FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], xi)*
273                       FE<1,LAGRANGE>::shape(EDGE3, SECOND, i1[i], eta)*
274                       FE<1,LAGRANGE>::shape(EDGE3, SECOND, i2[i], zeta));
275             }
276 
277             // quadratic tetrahedral shape functions
278           case TET10:
279             {
280               libmesh_assert_less (i, 10);
281 
282               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
283               const Real zeta1 = p(0);
284               const Real zeta2 = p(1);
285               const Real zeta3 = p(2);
286               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
287 
288               switch(i)
289                 {
290                 case 0:
291                   return zeta0*(2\&.*zeta0 - 1\&.);
292 
293                 case 1:
294                   return zeta1*(2\&.*zeta1 - 1\&.);
295 
296                 case 2:
297                   return zeta2*(2\&.*zeta2 - 1\&.);
298 
299                 case 3:
300                   return zeta3*(2\&.*zeta3 - 1\&.);
301 
302                 case 4:
303                   return 4\&.*zeta0*zeta1;
304 
305                 case 5:
306                   return 4\&.*zeta1*zeta2;
307 
308                 case 6:
309                   return 4\&.*zeta2*zeta0;
310 
311                 case 7:
312                   return 4\&.*zeta0*zeta3;
313 
314                 case 8:
315                   return 4\&.*zeta1*zeta3;
316 
317                 case 9:
318                   return 4\&.*zeta2*zeta3;
319 
320                 default:
321                   libmesh_error();
322                 }
323             }
324 
325             // "serendipity" prism
326           case PRISM15:
327             {
328               libmesh_assert_less (i, 15);
329 
330               const Real xi   = p(0);
331               const Real eta  = p(1);
332               const Real zeta = p(2);
333 
334               switch(i)
335                 {
336                 case 0:
337                   return (1\&. - zeta)*(xi + eta - 1\&.)*(xi + eta + 0\&.5*zeta);
338 
339                 case 1:
340                   return (1\&. - zeta)*xi*(xi - 1\&. - 0\&.5*zeta);
341 
342                 case 2: // phi1 with xi <- eta
343                   return (1\&. - zeta)*eta*(eta - 1\&. - 0\&.5*zeta);
344 
345                 case 3: // phi0 with zeta <- (-zeta)
346                   return (1\&. + zeta)*(xi + eta - 1\&.)*(xi + eta - 0\&.5*zeta);
347 
348                 case 4: // phi1 with zeta <- (-zeta)
349                   return (1\&. + zeta)*xi*(xi - 1\&. + 0\&.5*zeta);
350 
351                 case 5: // phi4 with xi <- eta
352                   return (1\&. + zeta)*eta*(eta - 1\&. + 0\&.5*zeta);
353 
354                 case 6:
355                   return 2\&.*(1\&. - zeta)*xi*(1\&. - xi - eta);
356 
357                 case 7:
358                   return 2\&.*(1\&. - zeta)*xi*eta;
359 
360                 case 8:
361                   return 2\&.*(1\&. - zeta)*eta*(1\&. - xi - eta);
362 
363                 case 9:
364                   return (1\&. - zeta)*(1\&. + zeta)*(1\&. - xi - eta);
365 
366                 case 10:
367                   return (1\&. - zeta)*(1\&. + zeta)*xi;
368 
369                 case 11: // phi10 with xi <-> eta
370                   return (1\&. - zeta)*(1\&. + zeta)*eta;
371 
372                 case 12: // phi6 with zeta <- (-zeta)
373                   return 2\&.*(1\&. + zeta)*xi*(1\&. - xi - eta);
374 
375                 case 13: // phi7 with zeta <- (-zeta)
376                   return 2\&.*(1\&. + zeta)*xi*eta;
377 
378                 case 14: // phi8 with zeta <- (-zeta)
379                   return 2\&.*(1\&. + zeta)*eta*(1\&. - xi - eta);
380 
381                 default:
382                   libmesh_error();
383                 }
384             }
385 
386             // quadradic prism shape functions
387           case PRISM18:
388             {
389               libmesh_assert_less (i, 18);
390 
391               // Compute prism shape functions as a tensor-product
392               // of a triangle and an edge
393 
394               Point p2d(p(0),p(1));
395               Point p1d(p(2));
396 
397               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
398               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
399               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
400 
401               return (FE<2,LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
402                       FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
403             }
404 
405             // G\&. Bedrosian, "Shape functions and integration formulas for
406             // three-dimensional finite element analysis", Int\&. J\&. Numerical
407             // Methods Engineering, vol 35, p\&. 95-108, 1992\&.
408           case PYRAMID13:
409             {
410               libmesh_assert_less (i, 13);
411 
412               const Real xi   = p(0);
413               const Real eta  = p(1);
414               const Real zeta = p(2);
415               const Real eps  = 1\&.e-35;
416 
417               // Denominators are perturbed by epsilon to avoid
418               // divide-by-zero issues\&.
419               Real den = (1\&. - zeta + eps);
420 
421               switch(i)
422                 {
423                 case 0:
424                   return 0\&.25*(-xi - eta - 1\&.)*((1\&. - xi)*(1\&. - eta) - zeta + xi*eta*zeta/den);
425 
426                 case 1:
427                   return 0\&.25*(-eta + xi - 1\&.)*((1\&. + xi)*(1\&. - eta) - zeta - xi*eta*zeta/den);
428 
429                 case 2:
430                   return 0\&.25*(xi + eta - 1\&.)*((1\&. + xi)*(1\&. + eta) - zeta + xi*eta*zeta/den);
431 
432                 case 3:
433                   return 0\&.25*(eta - xi - 1\&.)*((1\&. - xi)*(1\&. + eta) - zeta - xi*eta*zeta/den);
434 
435                 case 4:
436                   return zeta*(2\&.*zeta - 1\&.);
437 
438                 case 5:
439                   return 0\&.5*(1\&. + xi - zeta)*(1\&. - xi - zeta)*(1\&. - eta - zeta)/den;
440 
441                 case 6:
442                   return 0\&.5*(1\&. + eta - zeta)*(1\&. - eta - zeta)*(1\&. + xi - zeta)/den;
443 
444                 case 7:
445                   return 0\&.5*(1\&. + xi - zeta)*(1\&. - xi - zeta)*(1\&. + eta - zeta)/den;
446 
447                 case 8:
448                   return 0\&.5*(1\&. + eta - zeta)*(1\&. - eta - zeta)*(1\&. - xi - zeta)/den;
449 
450                 case 9:
451                   return zeta*(1\&. - xi - zeta)*(1\&. - eta - zeta)/den;
452 
453                 case 10:
454                   return zeta*(1\&. + xi - zeta)*(1\&. - eta - zeta)/den;
455 
456                 case 11:
457                   return zeta*(1\&. + eta - zeta)*(1\&. + xi - zeta)/den;
458 
459                 case 12:
460                   return zeta*(1\&. - xi - zeta)*(1\&. + eta - zeta)/den;
461 
462                 default:
463                   libmesh_error();
464                 }
465             }
466 
467             // Quadratic shape functions, as defined in R\&. Graglia, "Higher order
468             // bases on pyramidal elements", IEEE Trans Antennas and Propagation,
469             // vol 47, no 5, May 1999\&.
470           case PYRAMID14:
471             {
472               libmesh_assert_less (i, 14);
473 
474               const Real xi   = p(0);
475               const Real eta  = p(1);
476               const Real zeta = p(2);
477               const Real eps  = 1\&.e-35;
478 
479               // The "normalized coordinates" defined by Graglia\&.  These are
480               // the planes which define the faces of the pyramid\&.
481               Real
482                 p1 = 0\&.5*(1\&. - eta - zeta), // back
483                 p2 = 0\&.5*(1\&. + xi  - zeta), // left
484                 p3 = 0\&.5*(1\&. + eta - zeta), // front
485                 p4 = 0\&.5*(1\&. - xi  - zeta); // right
486 
487               // Denominators are perturbed by epsilon to avoid
488               // divide-by-zero issues\&.
489               Real
490                 den = (-1\&. + zeta + eps),
491                 den2 = den*den;
492 
493               switch(i)
494                 {
495                 case 0:
496                   return p4*p1*(xi*eta - zeta + zeta*zeta)/den2;
497 
498                 case 1:
499                   return -p1*p2*(xi*eta + zeta - zeta*zeta)/den2;
500 
501                 case 2:
502                   return p2*p3*(xi*eta - zeta + zeta*zeta)/den2;
503 
504                 case 3:
505                   return -p3*p4*(xi*eta + zeta - zeta*zeta)/den2;
506 
507                 case 4:
508                   return zeta*(2\&.*zeta - 1\&.);
509 
510                 case 5:
511                   return -4\&.*p2*p1*p4*eta/den2;
512 
513                 case 6:
514                   return 4\&.*p1*p2*p3*xi/den2;
515 
516                 case 7:
517                   return 4\&.*p2*p3*p4*eta/den2;
518 
519                 case 8:
520                   return -4\&.*p3*p4*p1*xi/den2;
521 
522                 case 9:
523                   return -4\&.*p1*p4*zeta/den;
524 
525                 case 10:
526                   return -4\&.*p2*p1*zeta/den;
527 
528                 case 11:
529                   return -4\&.*p3*p2*zeta/den;
530 
531                 case 12:
532                   return -4\&.*p4*p3*zeta/den;
533 
534                 case 13:
535                   return 16\&.*p1*p2*p3*p4/den2;
536 
537                 default:
538                   libmesh_error();
539                 }
540             }
541 
542 
543           default:
544             {
545               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
546                            << std::endl;
547               libmesh_error();
548             }
549           }
550       }
551 
552 
553       // unsupported order
554     default:
555       {
556         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
557                      << std::endl;
558         libmesh_error();
559       }
560     }
561 
562 #endif
563 
564   libmesh_error();
565   return 0\&.;
566 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM > 1
38 
39   switch (order)
40     {
41       // linear Lagrange shape functions
42     case FIRST:
43       {
44         switch (type)
45           {
46           case QUAD4:
47           case QUAD8:
48           case QUAD9:
49             {
50               // Compute quad shape functions as a tensor-product
51               const Real xi  = p(0);
52               const Real eta = p(1);
53 
54               libmesh_assert_less (i, 4);
55 
56               //                                0  1  2  3
57               static const unsigned int i0[] = {0, 1, 1, 0};
58               static const unsigned int i1[] = {0, 0, 1, 1};
59 
60               return (FE<1,LAGRANGE>::shape(EDGE2, FIRST, i0[i], xi)*
61                       FE<1,LAGRANGE>::shape(EDGE2, FIRST, i1[i], eta));
62             }
63 
64           case TRI3:
65           case TRI6:
66             {
67               const Real zeta1 = p(0);
68               const Real zeta2 = p(1);
69               const Real zeta0 = 1\&. - zeta1 - zeta2;
70 
71               libmesh_assert_less (i, 3);
72 
73               switch(i)
74                 {
75                 case 0:
76                   return zeta0;
77 
78                 case 1:
79                   return zeta1;
80 
81                 case 2:
82                   return zeta2;
83 
84                 default:
85                   libmesh_error();
86 
87                 }
88             }
89 
90           default:
91             {
92               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
93                            << std::endl;
94               libmesh_error();
95             }
96           }
97       }
98 
99 
100       // quadratic Lagrange shape functions
101     case SECOND:
102       {
103         switch (type)
104           {
105           case QUAD8:
106             {
107               const Real xi  = p(0);
108               const Real eta = p(1);
109 
110               libmesh_assert_less (i, 8);
111 
112               switch (i)
113                 {
114                 case 0:
115                   return \&.25*(1\&. - xi)*(1\&. - eta)*(-1\&. - xi - eta);
116 
117                 case 1:
118                   return \&.25*(1\&. + xi)*(1\&. - eta)*(-1\&. + xi - eta);
119 
120                 case 2:
121                   return \&.25*(1\&. + xi)*(1\&. + eta)*(-1\&. + xi + eta);
122 
123                 case 3:
124                   return \&.25*(1\&. - xi)*(1\&. + eta)*(-1\&. - xi + eta);
125 
126                 case 4:
127                   return \&.5*(1\&. - xi*xi)*(1\&. - eta);
128 
129                 case 5:
130                   return \&.5*(1\&. + xi)*(1\&. - eta*eta);
131 
132                 case 6:
133                   return \&.5*(1\&. - xi*xi)*(1\&. + eta);
134 
135                 case 7:
136                   return \&.5*(1\&. - xi)*(1\&. - eta*eta);
137 
138                 default:
139                   libmesh_error();
140                 }
141             }
142 
143           case QUAD9:
144             {
145               // Compute quad shape functions as a tensor-product
146               const Real xi  = p(0);
147               const Real eta = p(1);
148 
149               libmesh_assert_less (i, 9);
150 
151               //                                0  1  2  3  4  5  6  7  8
152               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
153               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
154 
155               return (FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], xi)*
156                       FE<1,LAGRANGE>::shape(EDGE3, SECOND, i1[i], eta));
157             }
158 
159           case TRI6:
160             {
161               const Real zeta1 = p(0);
162               const Real zeta2 = p(1);
163               const Real zeta0 = 1\&. - zeta1 - zeta2;
164 
165               libmesh_assert_less (i, 6);
166 
167               switch(i)
168                 {
169                 case 0:
170                   return 2\&.*zeta0*(zeta0-0\&.5);
171 
172                 case 1:
173                   return 2\&.*zeta1*(zeta1-0\&.5);
174 
175                 case 2:
176                   return 2\&.*zeta2*(zeta2-0\&.5);
177 
178                 case 3:
179                   return 4\&.*zeta0*zeta1;
180 
181                 case 4:
182                   return 4\&.*zeta1*zeta2;
183 
184                 case 5:
185                   return 4\&.*zeta2*zeta0;
186 
187                 default:
188                   libmesh_error();
189 
190                 }
191             }
192 
193           default:
194             {
195               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
196                            << std::endl;
197               libmesh_error();
198             }
199           }
200       }
201 
202 
203 
204       // unsupported order
205     default:
206       {
207         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
208                      << std::endl;
209         libmesh_error();
210       }
211     }
212 
213   libmesh_error();
214 #endif // LIBMESH_DIM > 1
215   return 0\&.;
216 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
36 {
37   libMesh::err << "Hierarchic polynomials require the element type\n"
38                << "because edge orientation is needed\&."
39                << std::endl;
40 
41   libmesh_error();
42   return 0\&.;
43 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM > 1
38 
39   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
40                        (static_cast<unsigned int>(order)+2)/2);
41 
42   const Real xi  = p(0);
43   const Real eta = p(1);
44 
45   switch (i)
46     {
47       // constant
48     case 0:
49       return 1\&.;
50 
51       // linear
52     case 1:
53       return xi;
54 
55     case 2:
56       return eta;
57 
58       // quadratics
59     case 3:
60       return xi*xi;
61 
62     case 4:
63       return xi*eta;
64 
65     case 5:
66       return eta*eta;
67 
68       // cubics
69     case 6:
70       return xi*xi*xi;
71 
72     case 7:
73       return xi*xi*eta;
74 
75     case 8:
76       return xi*eta*eta;
77 
78     case 9:
79       return eta*eta*eta;
80 
81       // quartics
82     case 10:
83       return xi*xi*xi*xi;
84 
85     case 11:
86       return xi*xi*xi*eta;
87 
88     case 12:
89       return xi*xi*eta*eta;
90 
91     case 13:
92       return xi*eta*eta*eta;
93 
94     case 14:
95       return eta*eta*eta*eta;
96 
97     default:
98       unsigned int o = 0;
99       for (; i >= (o+1)*(o+2)/2; o++) { }
100       unsigned int ny = i - (o*(o+1)/2);
101       unsigned int nx = o - ny;
102       Real val = 1\&.;
103       for (unsigned int index=0; index != nx; index++)
104         val *= xi;
105       for (unsigned int index=0; index != ny; index++)
106         val *= eta;
107       return val;
108     }
109 
110   libmesh_error();
111   return 0\&.;
112 
113 #endif
114 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 32 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
36 {
37   libmesh_assert_less (i, 1);
38   return 1\&.;
39 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 32 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
36 {
37 #if LIBMESH_DIM == 3
38 
39   const Real xi   = p(0);
40   const Real eta  = p(1);
41   const Real zeta = p(2);
42 
43   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
44                        (static_cast<unsigned int>(order)+2)*
45                        (static_cast<unsigned int>(order)+3)/6);
46 
47   // monomials\&. since they are hierarchic we only need one case block\&.
48   switch (i)
49     {
50       // constant
51     case 0:
52       return 1\&.;
53 
54       // linears
55     case 1:
56       return xi;
57 
58     case 2:
59       return eta;
60 
61     case 3:
62       return zeta;
63 
64       // quadratics
65     case 4:
66       return xi*xi;
67 
68     case 5:
69       return xi*eta;
70 
71     case 6:
72       return eta*eta;
73 
74     case 7:
75       return xi*zeta;
76 
77     case 8:
78       return zeta*eta;
79 
80     case 9:
81       return zeta*zeta;
82 
83       // cubics
84     case 10:
85       return xi*xi*xi;
86 
87     case 11:
88       return xi*xi*eta;
89 
90     case 12:
91       return xi*eta*eta;
92 
93     case 13:
94       return eta*eta*eta;
95 
96     case 14:
97       return xi*xi*zeta;
98 
99     case 15:
100       return xi*eta*zeta;
101 
102     case 16:
103       return eta*eta*zeta;
104 
105     case 17:
106       return xi*zeta*zeta;
107 
108     case 18:
109       return eta*zeta*zeta;
110 
111     case 19:
112       return zeta*zeta*zeta;
113 
114       // quartics
115     case 20:
116       return xi*xi*xi*xi;
117 
118     case 21:
119       return xi*xi*xi*eta;
120 
121     case 22:
122       return xi*xi*eta*eta;
123 
124     case 23:
125       return xi*eta*eta*eta;
126 
127     case 24:
128       return eta*eta*eta*eta;
129 
130     case 25:
131       return xi*xi*xi*zeta;
132 
133     case 26:
134       return xi*xi*eta*zeta;
135 
136     case 27:
137       return xi*eta*eta*zeta;
138 
139     case 28:
140       return eta*eta*eta*zeta;
141 
142     case 29:
143       return xi*xi*zeta*zeta;
144 
145     case 30:
146       return xi*eta*zeta*zeta;
147 
148     case 31:
149       return eta*eta*zeta*zeta;
150 
151     case 32:
152       return xi*zeta*zeta*zeta;
153 
154     case 33:
155       return eta*zeta*zeta*zeta;
156 
157     case 34:
158       return zeta*zeta*zeta*zeta;
159 
160     default:
161       unsigned int o = 0;
162       for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
163       unsigned int i2 = i - (o*(o+1)*(o+2)/6);
164       unsigned int block=o, nz = 0;
165       for (; block < i2; block += (o-nz+1)) { nz++; }
166       const unsigned int nx = block - i2;
167       const unsigned int ny = o - nx - nz;
168       Real val = 1\&.;
169       for (unsigned int index=0; index != nx; index++)
170         val *= xi;
171       for (unsigned int index=0; index != ny; index++)
172         val *= eta;
173       for (unsigned int index=0; index != nz; index++)
174         val *= zeta;
175       return val;
176     }
177 
178 #endif
179 
180   libmesh_error();
181   return 0\&.;
182 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 33 of file fe_clough_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
37 {
38   libMesh::err << "Clough-Tocher elements require the real element\n"
39                << "to construct gradient-based degrees of freedom\&."
40                << std::endl;
41 
42   libmesh_error();
43   return 0\&.;
44 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 33 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
37 {
38   libmesh_assert_less (i, order+1u);
39 
40   // Declare that we are using our own special power function
41   // from the Utility namespace\&.  This saves typing later\&.
42   using Utility::pow;
43 
44   const Real xi = p(0);
45 
46   Real returnval = 1\&.;
47 
48   switch (i)
49     {
50     case 0:
51       returnval = \&.5*(1\&. - xi);
52       break;
53     case 1:
54       returnval = \&.5*(1\&.  + xi);
55       break;
56       // All even-terms have the same form\&.
57       // (xi^p - 1\&.)/p!
58     case 2:
59       returnval = (xi*xi - 1\&.)/2\&.;
60       break;
61     case 4:
62       returnval = (pow<4>(xi) - 1\&.)/24\&.;
63       break;
64     case 6:
65       returnval = (pow<6>(xi) - 1\&.)/720\&.;
66       break;
67 
68       // All odd-terms have the same form\&.
69       // (xi^p - xi)/p!
70     case 3:
71       returnval = (xi*xi*xi - xi)/6\&.;
72       break;
73     case 5:
74       returnval = (pow<5>(xi) - xi)/120\&.;
75       break;
76     case 7:
77       returnval = (pow<7>(xi) - xi)/5040\&.;
78       break;
79     default:
80       Real denominator = 1\&.;
81       for (unsigned int n=1; n <= i; ++n)
82         {
83           returnval *= xi;
84           denominator *= n;
85         }
86       // Odd:
87       if (i % 2)
88         returnval = (returnval - xi)/denominator;
89       // Even:
90       else
91         returnval = (returnval - 1\&.)/denominator;
92       break;
93     }
94 
95   return returnval;
96 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 33 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
37 {
38   libmesh_assert_less (i, order+1u);
39 
40   // Declare that we are using our own special power function
41   // from the Utility namespace\&.  This saves typing later\&.
42   using Utility::pow;
43 
44   const Real xi = p(0);
45 
46   Real returnval = 1\&.;
47 
48   switch (i)
49     {
50     case 0:
51       returnval = \&.5*(1\&. - xi);
52       break;
53     case 1:
54       returnval = \&.5*(1\&.  + xi);
55       break;
56       // All even-terms have the same form\&.
57       // (xi^p - 1\&.)/p!
58     case 2:
59       returnval = (xi*xi - 1\&.)/2\&.;
60       break;
61     case 4:
62       returnval = (pow<4>(xi) - 1\&.)/24\&.;
63       break;
64     case 6:
65       returnval = (pow<6>(xi) - 1\&.)/720\&.;
66       break;
67 
68       // All odd-terms have the same form\&.
69       // (xi^p - xi)/p!
70     case 3:
71       returnval = (xi*xi*xi - xi)/6\&.;
72       break;
73     case 5:
74       returnval = (pow<5>(xi) - xi)/120\&.;
75       break;
76     case 7:
77       returnval = (pow<7>(xi) - xi)/5040\&.;
78       break;
79     default:
80       Real denominator = 1\&.;
81       for (unsigned int n=1; n <= i; ++n)
82         {
83           returnval *= xi;
84           denominator *= n;
85         }
86       // Odd:
87       if (i % 2)
88         returnval = (returnval - xi)/denominator;
89       // Even:
90       else
91         returnval = (returnval - 1\&.)/denominator;
92       break;
93     }
94 
95   return returnval;
96 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 34 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
38 {
39   libMesh::err << "Bernstein polynomials require the element type\n"
40                << "because edge orientation is needed\&."
41                << std::endl;
42 
43   libmesh_error();
44   return 0\&.;
45 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 35 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::Real, and libMesh::SEVENTH\&.
.PP
.nf
39 {
40   const Real xi  = p(0);
41   const Real xi2 = xi*xi;
42 
43 
44   // Use this libmesh_assert rather than a switch with a single entry\&.\&.\&.
45   // It will go away in optimized mode, essentially has the same effect\&.
46   libmesh_assert_less_equal (order, SEVENTH);
47 
48   //   switch (order)
49   //     {
50   //     case FIRST:
51   //     case SECOND:
52   //     case THIRD:
53   //     case FOURTH:
54   //     case FIFTH:
55   //     case SIXTH:
56   //     case SEVENTH:
57 
58   switch(i)
59     {
60       //nodal shape functions
61     case 0: return 1\&./2\&.-1\&./2\&.*xi;
62     case 1: return 1\&./2\&.+1\&./2\&.*xi;
63     case 2: return 1\&./4\&.  *2\&.4494897427831780982*(xi2-1\&.);
64     case 3: return 1\&./4\&.  *3\&.1622776601683793320*(xi2-1\&.)*xi;
65     case 4: return 1\&./16\&. *3\&.7416573867739413856*((5\&.*xi2-6\&.)*xi2+1\&.);
66     case 5: return 3\&./16\&. *1\&.4142135623730950488*(3\&.+(-10\&.+7\&.*xi2)*xi2)*xi;
67     case 6: return 1\&./32\&. *4\&.6904157598234295546*(-1\&.+(15\&.+(-35\&.+21\&.*xi2)*xi2)*xi2);
68     case 7: return 1\&./32\&. *5\&.0990195135927848300*(-5\&.+(35\&.+(-63\&.+33\&.*xi2)*xi2)*xi2)*xi;
69     case 8: return 1\&./256\&.*5\&.4772255750516611346*(5\&.+(-140\&.+(630\&.+(-924\&.+429\&.*xi2)*xi2)*xi2)*xi2);
70 
71     default:
72       libMesh::err << "Invalid shape function index!" << std::endl;
73       libmesh_error();
74     }
75 
76   //     default:
77   //       {
78   // libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
79   // libmesh_error();
80   //       }
81   //     }
82 
83   libmesh_error();
84   return 0\&.;
85 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 36 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
40 {
41   libMesh::err << "Bernstein polynomials require the element type\n"
42                << "because edge and face orientation is needed\&."
43                << std::endl;
44 
45   libmesh_error();
46   return 0\&.;
47 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 38 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::Utility::factorial(), libMesh::FIFTH, libMesh::FIRST, libMesh::FOURTH, libMesh::libmesh_assert(), std::pow(), libMesh::Utility::pow(), libMesh::Real, libMesh::SECOND, libMesh::SIXTH, and libMesh::THIRD\&.
.PP
.nf
42 {
43   const Real xi = p(0);
44   using Utility::pow;
45 
46   switch (order)
47     {
48     case FIRST:
49 
50       switch(i)
51         {
52         case 0:
53           return (1\&.-xi)/2\&.;
54         case 1:
55           return (1\&.+xi)/2\&.;
56         default:
57           libMesh::err << "Invalid shape function index!" << std::endl;
58           libmesh_error();
59         }
60 
61     case SECOND:
62 
63       switch(i)
64         {
65         case 0:
66           return (1\&./4\&.)*pow<2>(1\&.-xi);
67         case 1:
68           return (1\&./4\&.)*pow<2>(1\&.+xi);
69         case 2:
70           return (1\&./2\&.)*(1\&.-xi)*(1\&.+xi);
71         default:
72           libMesh::err << "Invalid shape function index!" << std::endl;
73           libmesh_error();
74         }
75 
76     case THIRD:
77 
78       switch(i)
79         {
80         case 0:
81           return (1\&./8\&.)*pow<3>(1\&.-xi);
82         case 1:
83           return (1\&./8\&.)*pow<3>(1\&.+xi);
84         case 2:
85           return (3\&./8\&.)*(1\&.+xi)*pow<2>(1\&.-xi);
86         case 3:
87           return (3\&./8\&.)*pow<2>(1\&.+xi)*(1\&.-xi);
88         default:
89           libMesh::err << "Invalid shape function index!" << std::endl;
90           libmesh_error();
91         }
92 
93     case FOURTH:
94 
95       switch(i)
96         {
97         case 0:
98           return (1\&./16\&.)*pow<4>(1\&.-xi);
99         case 1:
100           return (1\&./16\&.)*pow<4>(1\&.+xi);
101         case 2:
102           return (1\&./ 4\&.)*(1\&.+xi)*pow<3>(1\&.-xi);
103         case 3:
104           return (3\&./ 8\&.)*pow<2>(1\&.+xi)*pow<2>(1\&.-xi);
105         case 4:
106           return (1\&./ 4\&.)*pow<3>(1\&.+xi)*(1\&.-xi);
107         default:
108           libMesh::err << "Invalid shape function index!" << std::endl;
109           libmesh_error();
110         }
111 
112 
113     case FIFTH:
114 
115       switch(i)
116         {
117         case 0:
118           return (1\&./32\&.)*pow<5>(1\&.-xi);
119         case 1:
120           return (1\&./32\&.)*pow<5>(1\&.+xi);
121         case 2:
122           return (5\&./32\&.)*(1\&.+xi)*pow<4>(1\&.-xi);
123         case 3:
124           return (5\&./16\&.)*pow<2>(1\&.+xi)*pow<3>(1\&.-xi);
125         case 4:
126           return (5\&./16\&.)*pow<3>(1\&.+xi)*pow<2>(1\&.-xi);
127         case 5:
128           return (5\&./32\&.)*pow<4>(1\&.+xi)*(1\&.-xi);
129         default:
130           libMesh::err << "Invalid shape function index!" << std::endl;
131           libmesh_error();
132         }
133 
134 
135     case SIXTH:
136 
137       switch (i)
138         {
139         case 0:
140           return ( 1\&./64\&.)*pow<6>(1\&.-xi);
141         case 1:
142           return ( 1\&./64\&.)*pow<6>(1\&.+xi);
143         case 2:
144           return ( 3\&./32\&.)*(1\&.+xi)*pow<5>(1\&.-xi);
145         case 3:
146           return (15\&./64\&.)*pow<2>(1\&.+xi)*pow<4>(1\&.-xi);
147         case 4:
148           return ( 5\&./16\&.)*pow<3>(1\&.+xi)*pow<3>(1\&.-xi);
149         case 5:
150           return (15\&./64\&.)*pow<4>(1\&.+xi)*pow<2>(1\&.-xi);
151         case 6:
152           return ( 3\&./32\&.)*pow<5>(1\&.+xi)*(1\&.-xi);
153         default:
154           libMesh::err << "Invalid shape function index!" << std::endl;
155           libmesh_error();
156         }
157 
158     default:
159       {
160         libmesh_assert (order>6);
161 
162         // Use this for arbitrary orders\&.
163         // Note that this implementation is less efficient\&.
164         const int p_order = static_cast<unsigned int>(order);
165         const int m       = p_order-i+1;
166         const int n       = (i-1);
167 
168         unsigned int binomial_p_i = 1;
169 
170         // the binomial coefficient (p choose n)
171         if (i>1)
172           binomial_p_i = Utility::factorial(p_order)
173             / (Utility::factorial(n)*Utility::factorial(p_order-n));
174 
175 
176         switch(i)
177           {
178           case 0:
179             return binomial_p_i * std::pow((1-xi)/2,static_cast<int>(p_order));
180           case 1:
181             return binomial_p_i * std::pow((1+xi)/2,static_cast<int>(p_order));
182           default:
183             {
184               return binomial_p_i * std::pow((1+xi)/2,n)
185                 * std::pow((1-xi)/2,m);
186             }
187           }
188 
189         // we should never get here
190         libmesh_error();
191       }
192     }
193 
194   libmesh_error();
195   return 0\&.;
196 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 38 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
42 {
43   return 1\&.;
44 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 38 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
42 {
43   return 1\&.;
44 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 38 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
42 {
43   return 1\&.;
44 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 38 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
42 {
43   return 1\&.;
44 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned inti, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsigned int libmesh_dbg_vari, const \fBPoint\fP &)"

.PP
Definition at line 44 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
48 {
49   libmesh_assert_less (i, 1);
50   return 1\&.;
51 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 45 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
49 {
50   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
51   libmesh_error();
52   return 0\&.;
53 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 46 of file fe_xyz_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
50 {
51   libMesh::err << "XYZ polynomials require the element\n"
52                << "because the centroid is needed\&."
53                << std::endl;
54 
55   libmesh_error();
56   return 0\&.;
57 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 46 of file fe_xyz_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
50 {
51   libMesh::err << "XYZ polynomials require the element\n"
52                << "because the centroid is needed\&."
53                << std::endl;
54 
55   libmesh_error();
56   return 0\&.;
57 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 46 of file fe_xyz_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
50 {
51   libMesh::err << "XYZ polynomials require the element\n"
52                << "because the centroid is needed\&."
53                << std::endl;
54 
55   libmesh_error();
56   return 0\&.;
57 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 48 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, libMesh::TET10, libMesh::TOLERANCE, and libMesh::Elem::type()\&.
.PP
.nf
52 {
53 #if LIBMESH_DIM == 3
54   libmesh_assert(elem);
55 
56   const Order totalorder = static_cast<Order>(order + elem->p_level());
57 
58   switch (totalorder)
59     {
60       // linear Lagrange shape functions
61     case FIRST:
62       {
63         switch (elem->type())
64           {
65           case HEX20:
66           case HEX27:
67             {
68               libmesh_assert_less (i, 12);
69 
70               const Real xi   = p(0);
71               const Real eta  = p(1);
72               const Real zeta = p(2);
73 
74               // Even with a loose inverse_map tolerance we ought to
75               // be nearly on the element interior in master
76               // coordinates
77               libmesh_assert_less_equal ( std::fabs(xi),   1\&.0+10*TOLERANCE );
78               libmesh_assert_less_equal ( std::fabs(eta),  1\&.0+10*TOLERANCE );
79               libmesh_assert_less_equal ( std::fabs(zeta), 1\&.0+10*TOLERANCE );
80 
81               switch(i)
82                 {
83                 case 0:
84                   {
85                     if( elem->point(0) > elem->point(1) )
86                       return RealGradient( -0\&.125*(1\&.0-eta-zeta+eta*zeta), 0\&.0, 0\&.0 );
87                     else
88                       return RealGradient(  0\&.125*(1\&.0-eta-zeta+eta*zeta), 0\&.0, 0\&.0 );
89                   }
90                 case 1:
91                   {
92                     if( elem->point(1) > elem->point(2) )
93                       return RealGradient( 0\&.0, -0\&.125*(1\&.0+xi-zeta-xi*zeta), 0\&.0 );
94                     else
95                       return RealGradient( 0\&.0,  0\&.125*(1\&.0+xi-zeta-xi*zeta), 0\&.0 );
96                   }
97                 case 2:
98                   {
99                     if( elem->point(2) > elem->point(3) )
100                       return RealGradient(  0\&.125*(1\&.0+eta-zeta-eta*zeta), 0\&.0, 0\&.0 );
101                     else
102                       return RealGradient( -0\&.125*(1\&.0+eta-zeta-eta*zeta), 0\&.0, 0\&.0 );
103                   }
104                 case 3:
105                   {
106                     if( elem->point(3) > elem->point(0) )
107                       return RealGradient( 0\&.0,  0\&.125*(1\&.0-xi-zeta+xi*zeta), 0\&.0 );
108                     else
109                       return RealGradient( 0\&.0, -0\&.125*(1\&.0-xi-zeta+xi*zeta), 0\&.0 );
110                   }
111                 case 4:
112                   {
113                     if( elem->point(0) > elem->point(4) )
114                       return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0-xi-eta+xi*eta) );
115                     else
116                       return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0-xi-eta+xi*eta) );
117                   }
118                 case 5:
119                   {
120                     if( elem->point(1) > elem->point(5) )
121                       return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0+xi-eta-xi*eta) );
122                     else
123                       return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0+xi-eta-xi*eta) );
124                   }
125                 case 6:
126                   {
127                     if( elem->point(2) > elem->point(6) )
128                       return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0+xi+eta+xi*eta) );
129                     else
130                       return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0+xi+eta+xi*eta) );
131                   }
132                 case 7:
133                   {
134                     if( elem->point(3) > elem->point(7) )
135                       return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0-xi+eta-xi*eta) );
136                     else
137                       return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0-xi+eta-xi*eta) );
138                   }
139                 case 8:
140                   {
141                     if( elem->point(4) > elem->point(5) )
142                       return RealGradient( -0\&.125*(1\&.0-eta+zeta-eta*zeta), 0\&.0, 0\&.0 );
143                     else
144                       return RealGradient(  0\&.125*(1\&.0-eta+zeta-eta*zeta), 0\&.0, 0\&.0 );
145                   }
146                 case 9:
147                   {
148                     if( elem->point(5) > elem->point(6) )
149                       return RealGradient( 0\&.0, -0\&.125*(1\&.0+xi+zeta+xi*zeta), 0\&.0 );
150                     else
151                       return RealGradient( 0\&.0,  0\&.125*(1\&.0+xi+zeta+xi*zeta), 0\&.0 );
152                   }
153                 case 10:
154                   {
155                     if( elem->point(7) > elem->point(6) )
156                       return RealGradient( -0\&.125*(1\&.0+eta+zeta+eta*zeta), 0\&.0, 0\&.0 );
157                     else
158                       return RealGradient(  0\&.125*(1\&.0+eta+zeta+eta*zeta), 0\&.0, 0\&.0 );
159                   }
160                 case 11:
161                   {
162                     if( elem->point(4) > elem->point(7) )
163                       return RealGradient( 0\&.0, -0\&.125*(1\&.0-xi+zeta-xi*zeta), 0\&.0 );
164                     else
165                       return RealGradient( 0\&.0,  0\&.125*(1\&.0-xi+zeta-xi*zeta), 0\&.0 );
166                   }
167 
168                 default:
169                   libmesh_error();
170                 }
171 
172               return RealGradient();
173             }
174 
175           case TET10:
176             {
177               libmesh_assert_less (i, 6);
178 
179               libmesh_not_implemented();
180               return RealGradient();
181             }
182 
183           default:
184             {
185               libMesh::err << "ERROR: Unsupported 3D element type!: " << elem->type()
186                            << std::endl;
187               libmesh_error();
188             }
189           }
190       }
191 
192       // unsupported order
193     default:
194       {
195         libMesh::err << "ERROR: Unsupported 3D FE order!: " << totalorder
196                      << std::endl;
197 
198         libmesh_error();
199       }
200     }
201 #endif
202 
203   libmesh_error();
204   return RealGradient();
205 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 48 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::square_number_column, libMesh::square_number_row, libMesh::TRI3, libMesh::TRI6, libMesh::triangular_number_column, libMesh::triangular_number_row, and libMesh::Elem::type()\&.
.PP
.nf
52 {
53   libmesh_assert(elem);
54 
55   const Order totalorder = static_cast<Order>(order+elem->p_level());
56   libmesh_assert_greater (totalorder, 0);
57 
58   switch (elem->type())
59     {
60     case TRI3:
61     case TRI6:
62       {
63         const Real zeta1 = p(0);
64         const Real zeta2 = p(1);
65         const Real zeta0 = 1\&. - zeta1 - zeta2;
66 
67         libmesh_assert_less (i, (totalorder+1u)*(totalorder+2u)/2);
68         libmesh_assert (elem->type() == TRI6 || totalorder < 2);
69 
70         // Vertex DoFs
71         if (i == 0)
72           return zeta0;
73         else if (i == 1)
74           return zeta1;
75         else if (i == 2)
76           return zeta2;
77         // Edge DoFs
78         else if (i < totalorder + 2u)
79           {
80             // Avoid returning NaN on vertices!
81             if (zeta0 + zeta1 == 0\&.)
82               return 0\&.;
83 
84             const unsigned int basisorder = i - 1;
85             // Get factors to account for edge-flipping
86             Real f0 = 1;
87             if (basisorder%2 && (elem->point(0) > elem->point(1)))
88               f0 = -1\&.;
89 
90             Real edgeval = (zeta1 - zeta0) / (zeta1 + zeta0);
91             Real crossfunc = zeta0 + zeta1;
92             for (unsigned int n=1; n != basisorder; ++n)
93               crossfunc *= (zeta0 + zeta1);
94 
95             return f0 * crossfunc *
96               FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder,
97                                          basisorder, edgeval);
98           }
99         else if (i < 2u*totalorder + 1)
100           {
101             // Avoid returning NaN on vertices!
102             if (zeta1 + zeta2 == 0\&.)
103               return 0\&.;
104 
105             const unsigned int basisorder = i - totalorder;
106             // Get factors to account for edge-flipping
107             Real f1 = 1;
108             if (basisorder%2 && (elem->point(1) > elem->point(2)))
109               f1 = -1\&.;
110 
111             Real edgeval = (zeta2 - zeta1) / (zeta2 + zeta1);
112             Real crossfunc = zeta2 + zeta1;
113             for (unsigned int n=1; n != basisorder; ++n)
114               crossfunc *= (zeta2 + zeta1);
115 
116             return f1 * crossfunc *
117               FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder,
118                                          basisorder, edgeval);
119           }
120         else if (i < 3u*totalorder)
121           {
122             // Avoid returning NaN on vertices!
123             if (zeta0 + zeta2 == 0\&.)
124               return 0\&.;
125 
126             const unsigned int basisorder = i - (2u*totalorder) + 1;
127             // Get factors to account for edge-flipping
128             Real f2 = 1;
129             if (basisorder%2 && (elem->point(2) > elem->point(0)))
130               f2 = -1\&.;
131 
132             Real edgeval = (zeta0 - zeta2) / (zeta0 + zeta2);
133             Real crossfunc = zeta0 + zeta2;
134             for (unsigned int n=1; n != basisorder; ++n)
135               crossfunc *= (zeta0 + zeta2);
136 
137             return f2 * crossfunc *
138               FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder,
139                                          basisorder, edgeval);
140           }
141         // Interior DoFs
142         else
143           {
144             const unsigned int basisnum = i - (3u*totalorder);
145             unsigned int exp0 = triangular_number_column[basisnum] + 1;
146             unsigned int exp1 = triangular_number_row[basisnum] + 1 -
147               triangular_number_column[basisnum];
148 
149             Real returnval = 1;
150             for (unsigned int n = 0; n != exp0; ++n)
151               returnval *= zeta0;
152             for (unsigned int n = 0; n != exp1; ++n)
153               returnval *= zeta1;
154             returnval *= zeta2;
155             return returnval;
156           }
157       }
158 
159       // Hierarchic shape functions on the quadrilateral\&.
160     case QUAD4:
161       libmesh_assert_less (totalorder, 2);
162     case QUAD8:
163     case QUAD9:
164       {
165         // Compute quad shape functions as a tensor-product
166         const Real xi  = p(0);
167         const Real eta = p(1);
168 
169         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
170 
171         // Example i, i0, i1 values for totalorder = 5:
172         //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
173         //  static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 3, 2, 4, 4, 4, 3, 2, 5, 5, 5, 5, 4, 3, 2};
174         //  static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 3, 3, 2, 3, 4, 4, 4, 2, 3, 4, 5, 5, 5, 5};
175 
176         unsigned int i0, i1;
177 
178         // Vertex DoFs
179         if (i == 0)
180           { i0 = 0; i1 = 0; }
181         else if (i == 1)
182           { i0 = 1; i1 = 0; }
183         else if (i == 2)
184           { i0 = 1; i1 = 1; }
185         else if (i == 3)
186           { i0 = 0; i1 = 1; }
187         // Edge DoFs
188         else if (i < totalorder + 3u)
189           { i0 = i - 2; i1 = 0; }
190         else if (i < 2u*totalorder + 2)
191           { i0 = 1; i1 = i - totalorder - 1; }
192         else if (i < 3u*totalorder + 1)
193           { i0 = i - 2u*totalorder; i1 = 1; }
194         else if (i < 4u*totalorder)
195           { i0 = 0; i1 = i - 3u*totalorder + 1; }
196         // Interior DoFs
197         else
198           {
199             unsigned int basisnum = i - 4*totalorder;
200             i0 = square_number_column[basisnum] + 2;
201             i1 = square_number_row[basisnum] + 2;
202           }
203 
204         // Flip odd degree of freedom values if necessary
205         // to keep continuity on sides
206         Real f = 1\&.;
207 
208         if ((i0%2) && (i0 > 2) && (i1 == 0))
209           f = (elem->point(0) > elem->point(1))?-1\&.:1\&.;
210         else if ((i0%2) && (i0>2) && (i1 == 1))
211           f = (elem->point(3) > elem->point(2))?-1\&.:1\&.;
212         else if ((i0 == 0) && (i1%2) && (i1>2))
213           f = (elem->point(0) > elem->point(3))?-1\&.:1\&.;
214         else if ((i0 == 1) && (i1%2) && (i1>2))
215           f = (elem->point(1) > elem->point(2))?-1\&.:1\&.;
216 
217         return f*(FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder, i0, xi)*
218                   FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder, i1, eta));
219       }
220 
221     default:
222       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
223       libmesh_error();
224     }
225 
226   return 0\&.;
227 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 48 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::square_number_column, libMesh::square_number_row, libMesh::TRI3, libMesh::TRI6, libMesh::triangular_number_column, libMesh::triangular_number_row, and libMesh::Elem::type()\&.
.PP
.nf
52 {
53   libmesh_assert(elem);
54 
55   const Order totalorder = static_cast<Order>(order+elem->p_level());
56   libmesh_assert_greater (totalorder, 0);
57 
58   switch (elem->type())
59     {
60     case TRI3:
61     case TRI6:
62       {
63         const Real zeta1 = p(0);
64         const Real zeta2 = p(1);
65         const Real zeta0 = 1\&. - zeta1 - zeta2;
66 
67         libmesh_assert_less (i, (totalorder+1u)*(totalorder+2u)/2);
68         libmesh_assert (elem->type() == TRI6 || totalorder < 2);
69 
70         // Vertex DoFs
71         if (i == 0)
72           return zeta0;
73         else if (i == 1)
74           return zeta1;
75         else if (i == 2)
76           return zeta2;
77         // Edge DoFs
78         else if (i < totalorder + 2u)
79           {
80             // Avoid returning NaN on vertices!
81             if (zeta0 + zeta1 == 0\&.)
82               return 0\&.;
83 
84             const unsigned int basisorder = i - 1;
85             // Get factors to account for edge-flipping
86             Real f0 = 1;
87             if (basisorder%2 && (elem->point(0) > elem->point(1)))
88               f0 = -1\&.;
89 
90             Real edgeval = (zeta1 - zeta0) / (zeta1 + zeta0);
91             Real crossfunc = zeta0 + zeta1;
92             for (unsigned int n=1; n != basisorder; ++n)
93               crossfunc *= (zeta0 + zeta1);
94 
95             return f0 * crossfunc *
96               FE<1,HIERARCHIC>::shape(EDGE3, totalorder,
97                                       basisorder, edgeval);
98           }
99         else if (i < 2u*totalorder + 1)
100           {
101             // Avoid returning NaN on vertices!
102             if (zeta1 + zeta2 == 0\&.)
103               return 0\&.;
104 
105             const unsigned int basisorder = i - totalorder;
106             // Get factors to account for edge-flipping
107             Real f1 = 1;
108             if (basisorder%2 && (elem->point(1) > elem->point(2)))
109               f1 = -1\&.;
110 
111             Real edgeval = (zeta2 - zeta1) / (zeta2 + zeta1);
112             Real crossfunc = zeta2 + zeta1;
113             for (unsigned int n=1; n != basisorder; ++n)
114               crossfunc *= (zeta2 + zeta1);
115 
116             return f1 * crossfunc *
117               FE<1,HIERARCHIC>::shape(EDGE3, totalorder,
118                                       basisorder, edgeval);
119           }
120         else if (i < 3u*totalorder)
121           {
122             // Avoid returning NaN on vertices!
123             if (zeta0 + zeta2 == 0\&.)
124               return 0\&.;
125 
126             const unsigned int basisorder = i - (2u*totalorder) + 1;
127             // Get factors to account for edge-flipping
128             Real f2 = 1;
129             if (basisorder%2 && (elem->point(2) > elem->point(0)))
130               f2 = -1\&.;
131 
132             Real edgeval = (zeta0 - zeta2) / (zeta0 + zeta2);
133             Real crossfunc = zeta0 + zeta2;
134             for (unsigned int n=1; n != basisorder; ++n)
135               crossfunc *= (zeta0 + zeta2);
136 
137             return f2 * crossfunc *
138               FE<1,HIERARCHIC>::shape(EDGE3, totalorder,
139                                       basisorder, edgeval);
140           }
141         // Interior DoFs
142         else
143           {
144             const unsigned int basisnum = i - (3u*totalorder);
145             unsigned int exp0 = triangular_number_column[basisnum] + 1;
146             unsigned int exp1 = triangular_number_row[basisnum] + 1 -
147               triangular_number_column[basisnum];
148 
149             Real returnval = 1;
150             for (unsigned int n = 0; n != exp0; ++n)
151               returnval *= zeta0;
152             for (unsigned int n = 0; n != exp1; ++n)
153               returnval *= zeta1;
154             returnval *= zeta2;
155             return returnval;
156           }
157       }
158 
159       // Hierarchic shape functions on the quadrilateral\&.
160     case QUAD4:
161       libmesh_assert_less (totalorder, 2);
162     case QUAD8:
163     case QUAD9:
164       {
165         // Compute quad shape functions as a tensor-product
166         const Real xi  = p(0);
167         const Real eta = p(1);
168 
169         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
170 
171         // Example i, i0, i1 values for totalorder = 5:
172         //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
173         //  static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 3, 2, 4, 4, 4, 3, 2, 5, 5, 5, 5, 4, 3, 2};
174         //  static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 3, 3, 2, 3, 4, 4, 4, 2, 3, 4, 5, 5, 5, 5};
175 
176         unsigned int i0, i1;
177 
178         // Vertex DoFs
179         if (i == 0)
180           { i0 = 0; i1 = 0; }
181         else if (i == 1)
182           { i0 = 1; i1 = 0; }
183         else if (i == 2)
184           { i0 = 1; i1 = 1; }
185         else if (i == 3)
186           { i0 = 0; i1 = 1; }
187         // Edge DoFs
188         else if (i < totalorder + 3u)
189           { i0 = i - 2; i1 = 0; }
190         else if (i < 2u*totalorder + 2)
191           { i0 = 1; i1 = i - totalorder - 1; }
192         else if (i < 3u*totalorder + 1)
193           { i0 = i - 2u*totalorder; i1 = 1; }
194         else if (i < 4u*totalorder)
195           { i0 = 0; i1 = i - 3u*totalorder + 1; }
196         // Interior DoFs
197         else
198           {
199             unsigned int basisnum = i - 4*totalorder;
200             i0 = square_number_column[basisnum] + 2;
201             i1 = square_number_row[basisnum] + 2;
202           }
203 
204         // Flip odd degree of freedom values if necessary
205         // to keep continuity on sides
206         Real f = 1\&.;
207 
208         if ((i0%2) && (i0 > 2) && (i1 == 0))
209           f = (elem->point(0) > elem->point(1))?-1\&.:1\&.;
210         else if ((i0%2) && (i0>2) && (i1 == 1))
211           f = (elem->point(3) > elem->point(2))?-1\&.:1\&.;
212         else if ((i0 == 0) && (i1%2) && (i1>2))
213           f = (elem->point(0) > elem->point(3))?-1\&.:1\&.;
214         else if ((i0 == 1) && (i1%2) && (i1>2))
215           f = (elem->point(1) > elem->point(2))?-1\&.:1\&.;
216 
217         return f*(FE<1,HIERARCHIC>::shape(EDGE3, totalorder, i0, xi)*
218                   FE<1,HIERARCHIC>::shape(EDGE3, totalorder, i1, eta));
219       }
220 
221     default:
222       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
223       libmesh_error();
224     }
225 
226   return 0\&.;
227 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 49 of file fe_clough_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
53 {
54   libmesh_assert(elem);
55 
56   libmesh_not_implemented();
57   return 0\&.;
58 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 49 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TOLERANCE, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
53 {
54 #if LIBMESH_DIM > 1
55   libmesh_assert(elem);
56 
57   const Order total_order = static_cast<Order>(order + elem->p_level());
58 
59   switch (total_order)
60     {
61     case FIRST:
62       {
63         switch (elem->type())
64           {
65           case QUAD8:
66           case QUAD9:
67             {
68               libmesh_assert_less (i, 4);
69 
70               const Real xi  = p(0);
71               const Real eta = p(1);
72 
73               // Even with a loose inverse_map tolerance we ought to
74               // be nearly on the element interior in master
75               // coordinates
76               libmesh_assert_less_equal ( std::fabs(xi), 1\&.0+10*TOLERANCE );
77               libmesh_assert_less_equal ( std::fabs(eta), 1\&.0+10*TOLERANCE );
78 
79               switch(i)
80                 {
81                 case 0:
82                   {
83                     if( elem->point(0) > elem->point(1) )
84                       return RealGradient( -0\&.25*(1\&.0-eta), 0\&.0 );
85                     else
86                       return RealGradient( 0\&.25*(1\&.0-eta), 0\&.0 );
87                   }
88                 case 1:
89                   {
90                     if( elem->point(1) > elem->point(2) )
91                       return RealGradient( 0\&.0, -0\&.25*(1\&.0+xi) );
92                     else
93                       return RealGradient( 0\&.0, 0\&.25*(1\&.0+xi) );
94                   }
95 
96                 case 2:
97                   {
98                     if( elem->point(2) > elem->point(3) )
99                       return RealGradient( 0\&.25*(1\&.0+eta), 0\&.0 );
100                     else
101                       return RealGradient( -0\&.25*(1\&.0+eta), 0\&.0 );
102                   }
103                 case 3:
104                   {
105                     if( elem->point(3) > elem->point(0) )
106                       return RealGradient( 0\&.0, -0\&.25*(xi-1\&.0) );
107                     else
108                       return RealGradient( 0\&.0, 0\&.25*(xi-1\&.0) );
109                   }
110 
111                 default:
112                   libmesh_error();
113 
114                 }
115 
116               return RealGradient();
117             }
118 
119           case TRI6:
120             {
121               const Real xi  = p(0);
122               const Real eta = p(1);
123 
124               libmesh_assert_less (i, 3);
125 
126               switch(i)
127                 {
128                 case 0:
129                   {
130                     if( elem->point(0) > elem->point(1) )
131                       return RealGradient( -1\&.0+eta, -xi );
132                     else
133                       return RealGradient( 1\&.0-eta, xi );
134                   }
135                 case 1:
136                   {
137                     if( elem->point(1) > elem->point(2) )
138                       return RealGradient( eta, -xi );
139                     else
140                       return RealGradient( -eta, xi );
141                   }
142 
143                 case 2:
144                   {
145                     if( elem->point(2) > elem->point(0) )
146                       return RealGradient( eta, -xi+1\&.0 );
147                     else
148                       return RealGradient( -eta, xi-1\&.0 );
149                   }
150 
151                 default:
152                   libmesh_error();
153 
154                 }
155             }
156 
157           default:
158             {
159               libMesh::err << "ERROR: Unsupported 2D element type!: " << elem->type()
160                            << std::endl;
161               libmesh_error();
162             }
163           }
164       }
165 
166       // unsupported order
167     default:
168       {
169         libMesh::err << "ERROR: Unsupported 2D FE order!: " << total_order
170                      << std::endl;
171         libmesh_error();
172       }
173     }
174 #endif // LIBMESH_DIM > 1
175 
176   libmesh_error();
177   return RealGradient();
178 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 50 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::FIFTH, libMesh::FIRST, libMesh::FOURTH, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Utility::pow(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::FE< Dim, T >::shape(), libMesh::SIXTH, libMesh::square_number_column, libMesh::square_number_row, libMesh::THIRD, libMesh::TRI3, libMesh::TRI6, libMesh::Elem::type(), and libMesh::x\&.
.PP
.nf
54 {
55   libmesh_assert(elem);
56 
57   const ElemType type = elem->type();
58 
59   const Order totalorder = static_cast<Order>(order + elem->p_level());
60 
61   // Declare that we are using our own special power function
62   // from the Utility namespace\&.  This saves typing later\&.
63   using Utility::pow;
64 
65   switch (type)
66     {
67       // Hierarchic shape functions on the quadrilateral\&.
68     case QUAD4:
69     case QUAD9:
70       {
71         // Compute quad shape functions as a tensor-product
72         const Real xi  = p(0);
73         const Real eta = p(1);
74 
75         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
76 
77         // Example i, i0, i1 values for totalorder = 5:
78         //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
79         //  static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 3, 2, 4, 4, 4, 3, 2, 5, 5, 5, 5, 4, 3, 2};
80         //  static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 3, 3, 2, 3, 4, 4, 4, 2, 3, 4, 5, 5, 5, 5};
81 
82         unsigned int i0, i1;
83 
84         // Vertex DoFs
85         if (i == 0)
86           { i0 = 0; i1 = 0; }
87         else if (i == 1)
88           { i0 = 1; i1 = 0; }
89         else if (i == 2)
90           { i0 = 1; i1 = 1; }
91         else if (i == 3)
92           { i0 = 0; i1 = 1; }
93 
94 
95         // Edge DoFs
96         else if (i < totalorder + 3u)
97           { i0 = i - 2; i1 = 0; }
98         else if (i < 2u*totalorder + 2)
99           { i0 = 1; i1 = i - totalorder - 1; }
100         else if (i < 3u*totalorder + 1)
101           { i0 = i - 2u*totalorder; i1 = 1; }
102         else if (i < 4u*totalorder)
103           { i0 = 0; i1 = i - 3u*totalorder + 1; }
104         // Interior DoFs\&. Use Roy's number look up
105         else
106           {
107             unsigned int basisnum = i - 4*totalorder;
108             i0 = square_number_column[basisnum] + 2;
109             i1 = square_number_row[basisnum] + 2;
110           }
111 
112 
113         // Flip odd degree of freedom values if necessary
114         // to keep continuity on sides\&.
115         if     ((i>= 4                 && i<= 4+  totalorder-2u) && elem->point(0) > elem->point(1)) i0=totalorder+2-i0;//
116         else if((i>= 4+  totalorder-1u && i<= 4+2*totalorder-3u) && elem->point(1) > elem->point(2)) i1=totalorder+2-i1;
117         else if((i>= 4+2*totalorder-2u && i<= 4+3*totalorder-4u) && elem->point(3) > elem->point(2)) i0=totalorder+2-i0;
118         else if((i>= 4+3*totalorder-3u && i<= 4+4*totalorder-5u) && elem->point(0) > elem->point(3)) i1=totalorder+2-i1;
119 
120 
121         return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0, xi)*
122                 FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1, eta));
123       }
124       // handle serendipity QUAD8 element separately
125     case QUAD8:
126       {
127         libmesh_assert_less (totalorder, 3);
128 
129         const Real xi  = p(0);
130         const Real eta = p(1);
131 
132         libmesh_assert_less (i, 8);
133 
134         //                                0  1  2  3  4  5  6  7  8
135         static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
136         static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
137         static const Real scal[] = {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.5, 0\&.5, 0\&.5, 0\&.5};
138 
139         //B_t,i0(i)|xi * B_s,i1(i)|eta + scal(i) * B_t,2|xi * B_t,2|eta
140         return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
141                 FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta)
142                 +scal[i]*
143                 FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[8], xi)*
144                 FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[8], eta));
145 
146       }
147 
148     case TRI3:
149       libmesh_assert_less (totalorder, 2);
150     case TRI6:
151       switch (totalorder)
152         {
153         case FIRST:
154           {
155             const Real x=p(0);
156             const Real y=p(1);
157             const Real r=1\&.-x-y;
158 
159             libmesh_assert_less (i, 3);
160 
161             switch(i)
162               {
163               case 0: return r;  //f0,0,1
164               case 1: return x;  //f0,1,1
165               case 2: return y;  //f1,0,1
166 
167               default: libmesh_error(); return 0;
168               }
169           }
170         case SECOND:
171           {
172             const Real x=p(0);
173             const Real y=p(1);
174             const Real r=1\&.-x-y;
175 
176             libmesh_assert_less (i, 6);
177 
178             switch(i)
179               {
180               case 0: return r*r;
181               case 1: return x*x;
182               case 2: return y*y;
183 
184               case 3: return 2\&.*x*r;
185               case 4: return 2\&.*x*y;
186               case 5: return 2\&.*r*y;
187 
188               default: libmesh_error(); return 0;
189               }
190           }
191         case THIRD:
192           {
193             const Real x=p(0);
194             const Real y=p(1);
195             const Real r=1\&.-x-y;
196             libmesh_assert_less (i, 10);
197 
198             unsigned int shape=i;
199 
200 
201             if((i==3||i==4) && elem->point(0) > elem->point(1)) shape=7-i;
202             if((i==5||i==6) && elem->point(1) > elem->point(2)) shape=11-i;
203             if((i==7||i==8) && elem->point(0) > elem->point(2)) shape=15-i;
204 
205             switch(shape)
206               {
207               case 0: return r*r*r;
208               case 1: return x*x*x;
209               case 2: return y*y*y;
210 
211               case 3: return 3\&.*x*r*r;
212               case 4: return 3\&.*x*x*r;
213 
214               case 5: return 3\&.*y*x*x;
215               case 6: return 3\&.*y*y*x;
216 
217               case 7: return 3\&.*y*r*r;
218               case 8: return 3\&.*y*y*r;
219 
220               case 9: return 6\&.*x*y*r;
221 
222               default: libmesh_error(); return 0;
223               }
224           }
225         case FOURTH:
226           {
227             const Real x=p(0);
228             const Real y=p(1);
229             const Real r=1-x-y;
230             unsigned int shape=i;
231 
232             libmesh_assert_less (i, 15);
233 
234             if((i==3||i== 5) && elem->point(0) > elem->point(1))shape=8-i;
235             if((i==6||i== 8) && elem->point(1) > elem->point(2))shape=14-i;
236             if((i==9||i==11) && elem->point(0) > elem->point(2))shape=20-i;
237 
238 
239             switch(shape)
240               {
241                 // point functions
242               case  0: return r*r*r*r;
243               case  1: return x*x*x*x;
244               case  2: return y*y*y*y;
245 
246                 // edge functions
247               case  3: return 4\&.*x*r*r*r;
248               case  4: return 6\&.*x*x*r*r;
249               case  5: return 4\&.*x*x*x*r;
250 
251               case  6: return 4\&.*y*x*x*x;
252               case  7: return 6\&.*y*y*x*x;
253               case  8: return 4\&.*y*y*y*x;
254 
255               case  9: return 4\&.*y*r*r*r;
256               case 10: return 6\&.*y*y*r*r;
257               case 11: return 4\&.*y*y*y*r;
258 
259                 // inner functions
260               case 12: return 12\&.*x*y*r*r;
261               case 13: return 12\&.*x*x*y*r;
262               case 14: return 12\&.*x*y*y*r;
263 
264               default: libmesh_error(); return 0;
265               }
266           }
267         case FIFTH:
268           {
269             const Real x=p(0);
270             const Real y=p(1);
271             const Real r=1-x-y;
272             unsigned int shape=i;
273 
274             libmesh_assert_less (i, 21);
275 
276             if((i>= 3&&i<= 6) && elem->point(0) > elem->point(1))shape=9-i;
277             if((i>= 7&&i<=10) && elem->point(1) > elem->point(2))shape=17-i;
278             if((i>=11&&i<=14) && elem->point(0) > elem->point(2))shape=25-i;
279 
280             switch(shape)
281               {
282                 //point functions
283               case  0: return pow<5>(r);
284               case  1: return pow<5>(x);
285               case  2: return pow<5>(y);
286 
287                 //edge functions
288               case  3: return  5\&.*x        *pow<4>(r);
289               case  4: return 10\&.*pow<2>(x)*pow<3>(r);
290               case  5: return 10\&.*pow<3>(x)*pow<2>(r);
291               case  6: return  5\&.*pow<4>(x)*r;
292 
293               case  7: return  5\&.*y   *pow<4>(x);
294               case  8: return 10\&.*pow<2>(y)*pow<3>(x);
295               case  9: return 10\&.*pow<3>(y)*pow<2>(x);
296               case 10: return  5\&.*pow<4>(y)*x;
297 
298               case 11: return  5\&.*y   *pow<4>(r);
299               case 12: return 10\&.*pow<2>(y)*pow<3>(r);
300               case 13: return 10\&.*pow<3>(y)*pow<2>(r);
301               case 14: return  5\&.*pow<4>(y)*r;
302 
303                 //inner functions
304               case 15: return 20\&.*x*y*pow<3>(r);
305               case 16: return 30\&.*x*pow<2>(y)*pow<2>(r);
306               case 17: return 30\&.*pow<2>(x)*y*pow<2>(r);
307               case 18: return 20\&.*x*pow<3>(y)*r;
308               case 19: return 20\&.*pow<3>(x)*y*r;
309               case 20: return 30\&.*pow<2>(x)*pow<2>(y)*r;
310 
311               default: libmesh_error(); return 0;
312               }
313           }
314         case SIXTH:
315           {
316             const Real x=p(0);
317             const Real y=p(1);
318             const Real r=1-x-y;
319             unsigned int shape=i;
320 
321             libmesh_assert_less (i, 28);
322 
323             if((i>= 3&&i<= 7) && elem->point(0) > elem->point(1))shape=10-i;
324             if((i>= 8&&i<=12) && elem->point(1) > elem->point(2))shape=20-i;
325             if((i>=13&&i<=17) && elem->point(0) > elem->point(2))shape=30-i;
326 
327             switch(shape)
328               {
329                 //point functions
330               case  0: return pow<6>(r);
331               case  1: return pow<6>(x);
332               case  2: return pow<6>(y);
333 
334                 //edge functions
335               case  3: return  6\&.*x        *pow<5>(r);
336               case  4: return 15\&.*pow<2>(x)*pow<4>(r);
337               case  5: return 20\&.*pow<3>(x)*pow<3>(r);
338               case  6: return 15\&.*pow<4>(x)*pow<2>(r);
339               case  7: return  6\&.*pow<5>(x)*r;
340 
341               case  8: return  6\&.*y        *pow<5>(x);
342               case  9: return 15\&.*pow<2>(y)*pow<4>(x);
343               case 10: return 20\&.*pow<3>(y)*pow<3>(x);
344               case 11: return 15\&.*pow<4>(y)*pow<2>(x);
345               case 12: return  6\&.*pow<5>(y)*x;
346 
347               case 13: return  6\&.*y        *pow<5>(r);
348               case 14: return 15\&.*pow<2>(y)*pow<4>(r);
349               case 15: return 20\&.*pow<3>(y)*pow<3>(r);
350               case 16: return 15\&.*pow<4>(y)*pow<2>(r);
351               case 17: return  6\&.*pow<5>(y)*r;
352 
353                 //inner functions
354               case 18: return 30\&.*x*y*pow<4>(r);
355               case 19: return 60\&.*x*pow<2>(y)*pow<3>(r);
356               case 20: return 60\&.*  pow<2>(x)*y*pow<3>(r);
357               case 21: return 60\&.*x*pow<3>(y)*pow<2>(r);
358               case 22: return 60\&.*pow<3>(x)*y*pow<2>(r);
359               case 23: return 90\&.*pow<2>(x)*pow<2>(y)*pow<2>(r);
360               case 24: return 30\&.*x*pow<4>(y)*r;
361               case 25: return 60\&.*pow<2>(x)*pow<3>(y)*r;
362               case 26: return 60\&.*pow<3>(x)*pow<2>(y)*r;
363               case 27: return 30\&.*pow<4>(x)*y*r;
364 
365               default: libmesh_error(); return 0;
366               } // switch shape
367           } // case TRI6
368         default:
369           {
370             libMesh::err << "ERROR: element order!" << std::endl;
371             libmesh_error();
372           }
373 
374 
375         } // switch order
376 
377 
378     default:
379       {
380         libMesh::err << "ERROR: Unsupported element type!" << std::endl;
381         libmesh_error();
382       }
383 
384     } // switch type
385 
386 
387   // old code
388   //   switch (totalorder)
389   //     {
390 
391   //     case FIRST:
392 
393   //       switch(type)
394   // {
395 
396   // case TRI6:
397   //   {
398   //     const Real x=p(0);
399   //     const Real y=p(1);
400   //     const Real r=1\&.-x-y;
401 
402   //     libmesh_assert_less (i, 3);
403 
404   //     switch(i)
405   //       {
406   //       case 0: return r;  //f0,0,1
407   //       case 1: return x;      //f0,1,1
408   //       case 2: return y;      //f1,0,1
409   //       }
410   //   }
411 
412   // case QUAD8:
413   // case QUAD9:
414   //   {
415   //     // Compute quad shape functions as a tensor-product
416   //     const Real xi  = p(0);
417   //     const Real eta = p(1);
418 
419   //     libmesh_assert_less (i, 4);
420 
421   //     //                                0  1  2  3
422   //     static const unsigned int i0[] = {0, 1, 1, 0};
423   //     static const unsigned int i1[] = {0, 0, 1, 1};
424 
425   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
426   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta));
427 
428   //   }
429   // default:
430   //   libmesh_error();
431   // }
432 
433   //     case SECOND:
434   //       switch(type)
435   // {
436   // case TRI6:
437   //   {
438   //     const Real x=p(0);
439   //     const Real y=p(1);
440   //     const Real r=1\&.-x-y;
441 
442   //     libmesh_assert_less (i, 6);
443 
444   //     switch(i)
445   //       {
446   //       case 0: return r*r;
447   //       case 1: return x*x;
448   //       case 2: return y*y;
449 
450   //       case 3: return 2\&.*x*r;
451   //       case 4: return 2\&.*x*y;
452   //       case 5: return 2\&.*r*y;
453   //       }
454   //   }
455 
456   //   // Bernstein shape functions on the 8-noded quadrilateral\&.
457   // case QUAD8:
458   //   {
459   //     const Real xi  = p(0);
460   //     const Real eta = p(1);
461 
462   //     libmesh_assert_less (i, 8);
463 
464   //     //                                0  1  2  3  4  5  6  7  8
465   //     static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
466   //     static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
467   //     static const Real scal[] = {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.5, 0\&.5, 0\&.5, 0\&.5};
468 
469   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
470   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta)
471   //     +scal[i]*
472   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[8], xi)*
473   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[8], eta));
474 
475   //     //B_t,i0(i)|xi * B_s,i1(i)|eta + scal(i) * B_t,2|xi * B_t,2|eta
476   //   }
477 
478   //   // Bernstein shape functions on the 9-noded quadrilateral\&.
479   // case QUAD9:
480   //   {
481   //     // Compute quad shape functions as a tensor-product
482   //     const Real xi  = p(0);
483   //     const Real eta = p(1);
484 
485   //     libmesh_assert_less (i, 9);
486 
487   //     //                                0  1  2  3  4  5  6  7  8
488   //     static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
489   //     static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
490 
491   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
492   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta));
493 
494   //   }
495   // default:
496   //   libmesh_error();
497   // }
498 
499   //     case THIRD:
500   //       switch(type)
501   // {
502   // case TRI6:
503   //   {
504   //     const Real x=p(0);
505   //     const Real y=p(1);
506   //     const Real r=1\&.-x-y;
507   //     libmesh_assert_less (i, 10);
508 
509   //     unsigned int shape=i;
510 
511 
512   //     if((i==3||i==4) && elem->node(0) > elem->node(1))shape=7-i;
513   //     if((i==5||i==6) && elem->node(1) > elem->node(2))shape=11-i;
514   //     if((i==7||i==8) && elem->node(0) > elem->node(2))shape=15-i;
515 
516 
517   //     switch(shape)
518   //       {
519   //       case 0: return r*r*r;
520   //       case 1: return x*x*x;
521   //       case 2: return y*y*y;
522 
523   //       case 3: return 3\&.*x*r*r;
524   //       case 4: return 3\&.*x*x*r;
525 
526   //       case 5: return 3\&.*y*x*x;
527   //       case 6: return 3\&.*y*y*x;
528 
529   //       case 7: return 3\&.*y*r*r;
530   //       case 8: return 3\&.*y*y*r;
531 
532   //       case 9: return 6\&.*x*y*r;
533   //       }
534   //   }
535 
536   //   // Bernstein shape functions on the quadrilateral\&.
537   // case QUAD8:
538   // case QUAD9:
539   //   {
540   //     // Compute quad shape functions as a tensor-product
541   //     Real xi  = p(0);
542   //     Real eta = p(1);
543 
544   //     libmesh_assert_less (i, 16);
545 
546   //     //                                    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
547   //     static const unsigned int i0_reg[] = {0,  1,  1,  0,  2,  3,  1,  1,  2,  3,  0,  0,  2,  3,  2,  3};
548   //     static const unsigned int i1_reg[] = {0,  0,  1,  1,  0,  0,  2,  3,  1,  1,  2,  3,  2,  2,  3,  3};
549 
550   //     unsigned int i0=i0_reg[i];
551   //     unsigned int i1=i1_reg[i];
552 
553   //     if((i== 4||i== 5) && elem->node(0) > elem->node(1)) i0=5-i0;  // 2->3   3->2
554   //     if((i== 6||i== 7) && elem->node(1) > elem->node(2)) i1=5-i1;
555   //     if((i== 8||i== 9) && elem->node(3) > elem->node(2)) i0=5-i0;
556   //     if((i==10||i==11) && elem->node(0) > elem->node(3)) i1=5-i1;
557 
558   //     // element dof orientation is needed when used with ifems
559   // //     if(i > 11)
560   // //       {
561   // // const unsigned int min_node = std::min(elem->node(1),
562   // //        std::min(elem->node(2),
563   // // std::min(elem->node(0),
564   // //  elem->node(3))));
565   // // if (elem->node(0) == min_node)
566   // //   if (elem->node(1) == std::min(elem->node(1), elem->node(3)))
567   // //     {
568   // //       // Case 1
569   // //       xi  = xi;
570   // //       eta = eta;
571   // //     }
572   // //   else
573   // //     {
574   // //       // Case 2
575   // //       xi  = eta;
576   // //       eta = xi;
577   // //     }
578 
579   // // else if (elem->node(3) == min_node)
580   // //   if (elem->node(0) == std::min(elem->node(0), elem->node(2)))
581   // //     {
582   // //       // Case 3
583   // //       xi  = -eta;
584   // //       eta = xi;
585   // //     }
586   // //   else
587   // //     {
588   // //       // Case 4
589   // //       xi  = xi;
590   // //       eta = -eta;
591   // //     }
592 
593   // // else if (elem->node(2) == min_node)
594   // //   if (elem->node(3) == std::min(elem->node(3), elem->node(1)))
595   // //     {
596   // //       // Case 5
597   // //       xi  = -xi;
598   // //       eta = -eta;
599   // //     }
600   // //   else
601   // //     {
602   // //       // Case 6
603   // //       xi  = -eta;
604   // //       eta = -xi;
605   // //     }
606 
607   // // else if (elem->node(1) == min_node)
608   // //   if (elem->node(2) == std::min(elem->node(2), elem->node(0)))
609   // //     {
610   // //       // Case 7
611   // //       xi  = eta;
612   // //       eta = -xi;
613   // //     }
614   // //   else
615   // //     {
616   // //       // Case 8
617   // //       xi  = -xi;
618   // //       eta = eta;
619   // //     }
620   // //       }
621 
622 
623   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0, xi)*
624   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1, eta));
625 
626   //   }
627 
628   // default:
629   //   libmesh_error();
630 
631   // }
632 
633   //     case FOURTH:
634   //       switch(type)
635   // {
636   // case TRI6:
637   //   {
638   //     const Real x=p(0);
639   //     const Real y=p(1);
640   //     const Real r=1-x-y;
641   //     unsigned int shape=i;
642 
643   //     libmesh_assert_less (i, 15);
644 
645   //     if((i==3||i== 5) && elem->node(0) > elem->node(1))shape=8-i;
646   //     if((i==6||i== 8) && elem->node(1) > elem->node(2))shape=14-i;
647   //     if((i==9||i==11) && elem->node(0) > elem->node(2))shape=20-i;
648 
649 
650   //     switch(shape)
651   //       {
652   // // point functions
653   //       case  0: return r*r*r*r;
654   //       case  1: return x*x*x*x;
655   //       case  2: return y*y*y*y;
656 
657   // // edge functions
658   //       case  3: return 4\&.*x*r*r*r;
659   //       case  4: return 6\&.*x*x*r*r;
660   //       case  5: return 4\&.*x*x*x*r;
661 
662   //       case  6: return 4\&.*y*x*x*x;
663   //       case  7: return 6\&.*y*y*x*x;
664   //       case  8: return 4\&.*y*y*y*x;
665 
666   //       case  9: return 4\&.*y*r*r*r;
667   //       case 10: return 6\&.*y*y*r*r;
668   //       case 11: return 4\&.*y*y*y*r;
669 
670   // // inner functions
671   //       case 12: return 12\&.*x*y*r*r;
672   //       case 13: return 12\&.*x*x*y*r;
673   //       case 14: return 12\&.*x*y*y*r;
674 
675   //       }
676   //   }
677 
678 
679   //   // Bernstein shape functions on the quadrilateral\&.
680   // case QUAD8:
681   // case QUAD9:
682   //   {
683   //     // Compute quad shape functions as a tensor-product
684   //     const Real xi  = p(0);
685   //     const Real eta = p(1);
686 
687   //     libmesh_assert_less (i, 25);
688 
689   //     //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
690   //     static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4};
691   //     static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
692 
693   //     unsigned int i0=i0_reg[i];
694   //     unsigned int i1=i1_reg[i];
695 
696   //     if((i>= 4&&i<= 6) && elem->node(0) > elem->node(1)) i0=6-i0;// 2->4,  4->2
697   //     if((i>= 7&&i<= 9) && elem->node(1) > elem->node(2)) i1=6-i1;
698   //     if((i>=10&&i<=12) && elem->node(3) > elem->node(2)) i0=6-i0;
699   //     if((i>=13&&i<=15) && elem->node(0) > elem->node(3)) i1=6-i1;
700 
701   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0, xi)*
702   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1, eta));
703 
704   //   }
705 
706   // default:
707   //   libmesh_error();
708 
709   // }
710 
711   //     case FIFTH:
712   //       switch(type)
713   // {
714   // case TRI6:
715   //   {
716   //     const Real x=p(0);
717   //     const Real y=p(1);
718   //     const Real r=1-x-y;
719   //     unsigned int shape=i;
720 
721   //     libmesh_assert_less (i, 21);
722 
723   //     if((i>= 3&&i<= 6) && elem->node(0) > elem->node(1))shape=9-i;
724   //     if((i>= 7&&i<=10) && elem->node(1) > elem->node(2))shape=17-i;
725   //     if((i>=11&&i<=14) && elem->node(0) > elem->node(2))shape=25-i;
726 
727   //     switch(shape)
728   //       {
729   // //point functions
730   //       case  0: return pow<5>(r);
731   //       case  1: return pow<5>(x);
732   //       case  2: return pow<5>(y);
733 
734   // //edge functions
735   //       case  3: return  5\&.*x        *pow<4>(r);
736   //       case  4: return 10\&.*pow<2>(x)*pow<3>(r);
737   //       case  5: return 10\&.*pow<3>(x)*pow<2>(r);
738   //       case  6: return  5\&.*pow<4>(x)*r;
739 
740   //       case  7: return  5\&.*y   *pow<4>(x);
741   //       case  8: return 10\&.*pow<2>(y)*pow<3>(x);
742   //       case  9: return 10\&.*pow<3>(y)*pow<2>(x);
743   //       case 10: return  5\&.*pow<4>(y)*x;
744 
745   //       case 11: return  5\&.*y   *pow<4>(r);
746   //       case 12: return 10\&.*pow<2>(y)*pow<3>(r);
747   //       case 13: return 10\&.*pow<3>(y)*pow<2>(r);
748   //       case 14: return  5\&.*pow<4>(y)*r;
749 
750   // //inner functions
751   //       case 15: return 20\&.*x*y*pow<3>(r);
752   //       case 16: return 30\&.*x*pow<2>(y)*pow<2>(r);
753   //       case 17: return 30\&.*pow<2>(x)*y*pow<2>(r);
754   //       case 18: return 20\&.*x*pow<3>(y)*r;
755   //       case 19: return 20\&.*pow<3>(x)*y*r;
756   //       case 20: return 30\&.*pow<2>(x)*pow<2>(y)*r;
757 
758   //       }
759   //   }
760 
761 
762   //   // Bernstein shape functions on the quadrilateral\&.
763   // case QUAD8:
764   // case QUAD9:
765   //   {
766   //     // Compute quad shape functions as a tensor-product
767   //     const Real xi  = p(0);
768   //     const Real eta = p(1);
769 
770   //     libmesh_assert_less (i, 36);
771 
772   //     //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
773   //     static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
774   //     static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
775 
776   //     unsigned int i0=i0_reg[i];
777   //     unsigned int i1=i1_reg[i];
778 
779   //     if((i>= 4&&i<= 7) && elem->node(0) > elem->node(1)) i0=7-i0;
780   //     if((i>= 8&&i<=11) && elem->node(1) > elem->node(2)) i1=7-i1;
781   //     if((i>=12&&i<=15) && elem->node(3) > elem->node(2)) i0=7-i0;
782   //     if((i>=16&&i<=19) && elem->node(0) > elem->node(3)) i1=7-i1;
783 
784   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0, xi)*
785   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1, eta));
786 
787   //   }
788   // default:
789   //   libmesh_error();
790   // }
791 
792   //     case SIXTH:
793   //       switch(type)
794   // {
795   // case TRI6:
796   //   {
797   //     const Real x=p(0);
798   //     const Real y=p(1);
799   //     const Real r=1-x-y;
800   //     unsigned int shape=i;
801 
802   //     libmesh_assert_less (i, 28);
803 
804   //     if((i>= 3&&i<= 7) && elem->node(0) > elem->node(1))shape=10-i;
805   //     if((i>= 8&&i<=12) && elem->node(1) > elem->node(2))shape=20-i;
806   //     if((i>=13&&i<=17) && elem->node(0) > elem->node(2))shape=30-i;
807 
808   //     switch(shape)
809   //       {
810   // //point functions
811   //       case  0: return pow<6>(r);
812   //       case  1: return pow<6>(x);
813   //       case  2: return pow<6>(y);
814 
815   // //edge functions
816   //       case  3: return  6\&.*x        *pow<5>(r);
817   //       case  4: return 15\&.*pow<2>(x)*pow<4>(r);
818   //       case  5: return 20\&.*pow<3>(x)*pow<3>(r);
819   //       case  6: return 15\&.*pow<4>(x)*pow<2>(r);
820   //       case  7: return  6\&.*pow<5>(x)*r;
821 
822   //       case  8: return  6\&.*y        *pow<5>(x);
823   //       case  9: return 15\&.*pow<2>(y)*pow<4>(x);
824   //       case 10: return 20\&.*pow<3>(y)*pow<3>(x);
825   //       case 11: return 15\&.*pow<4>(y)*pow<2>(x);
826   //       case 12: return  6\&.*pow<5>(y)*x;
827 
828   //       case 13: return  6\&.*y        *pow<5>(r);
829   //       case 14: return 15\&.*pow<2>(y)*pow<4>(r);
830   //       case 15: return 20\&.*pow<3>(y)*pow<3>(r);
831   //       case 16: return 15\&.*pow<4>(y)*pow<2>(r);
832   //       case 17: return  6\&.*pow<5>(y)*r;
833 
834   // //inner functions
835   //       case 18: return 30\&.*x*y*pow<4>(r);
836   //       case 19: return 60\&.*x*pow<2>(y)*pow<3>(r);
837   //       case 20: return 60\&.*  pow<2>(x)*y*pow<3>(r);
838   //       case 21: return 60\&.*x*pow<3>(y)*pow<2>(r);
839   //       case 22: return 60\&.*pow<3>(x)*y*pow<2>(r);
840   //       case 23: return 90\&.*pow<2>(x)*pow<2>(y)*pow<2>(r);
841   //       case 24: return 30\&.*x*pow<4>(y)*r;
842   //       case 25: return 60\&.*pow<2>(x)*pow<3>(y)*r;
843   //       case 26: return 60\&.*pow<3>(x)*pow<2>(y)*r;
844   //       case 27: return 30\&.*pow<4>(x)*y*r;
845 
846   //       } // switch shape
847   //   } // case TRI6
848 
849 
850 
851   //   // Bernstein shape functions on the quadrilateral\&.
852   // case QUAD8:
853   // case QUAD9:
854   //   {
855   //     // Compute quad shape functions as a tensor-product
856   //     const Real xi  = p(0);
857   //     const Real eta = p(1);
858 
859   //     libmesh_assert_less (i, 49);
860 
861   //     //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
862   //     static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6};
863   //     static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6};
864 
865   //     unsigned int i0=i0_reg[i];
866   //     unsigned int i1=i1_reg[i];
867 
868   //     if((i>= 4&&i<= 8) && elem->node(0) > elem->node(1)) i0=8-i0;
869   //     if((i>= 9&&i<=13) && elem->node(1) > elem->node(2)) i1=8-i1;
870   //     if((i>=14&&i<=18) && elem->node(3) > elem->node(2)) i0=8-i0;
871   //     if((i>=19&&i<=23) && elem->node(0) > elem->node(3)) i1=8-i1;
872 
873   //     return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0, xi)*
874   //     FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1, eta));
875 
876   //   } // case QUAD8/9
877 
878   // default:
879   //   libmesh_error();
880 
881   // }
882   //       // 7th-order Bernstein\&.
883   //     case SEVENTH:
884   //       {
885   // switch (type)
886   //   {
887 
888   //     // Szabo-Babuska shape functions on the quadrilateral\&.
889   //   case QUAD9:
890   //     {
891   //       // Compute quad shape functions as a tensor-product
892   //       const Real xi  = p(0);
893   //       const Real eta = p(1);
894 
895   //       libmesh_assert_less (i, 64);
896 
897   //       //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
898   //       static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7};
899   //       static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7};
900 
901   //       Real f=1\&.;
902 
903   //       switch(i)
904   // {
905   // case  5: // edge 0 nodes
906   // case  7:
907   // case  9:
908   //   if (elem->node(0) > elem->node(1))f = -1\&.;
909   //   break;
910   //       case 11: // edge 1 nodes
911   //       case 13:
912   // case 15:
913   //   if (elem->node(1) > elem->node(2))f = -1\&.;
914   //   break;
915   //         case 17: // edge 2 nodes
916   //         case 19:
917   // case 21:
918   //   if (elem->node(3) > elem->node(2))f = -1\&.;
919   //   break;
920   //         case 23: // edge 3 nodes
921   //         case 25:
922   // case 27:
923   //   if (elem->node(0) > elem->node(3))f = -1\&.;
924   //   break;
925   // }
926 
927   //       return f*(FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
928   // FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta));
929 
930   //     } // case QUAD8/QUAD9
931 
932   //   default:
933   //     libmesh_error();
934 
935   //   } // switch type
936 
937   //       } // case SEVENTH
938 
939 
940   //       // by default throw an error
941   //     default:
942   //       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
943   //       libmesh_error();
944   //     }
945 
946   libmesh_error();
947   return 0\&.;
948 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 52 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::FIRST, libMesh::FOURTH, libMesh::HEX20, libMesh::HEX27, libMesh::libmesh_assert(), std::min(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, libMesh::SECOND, libMesh::FE< Dim, T >::shape(), libMesh::TET10, libMesh::TET4, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
56 {
57 
58 #if LIBMESH_DIM == 3
59 
60   libmesh_assert(elem);
61   const ElemType type = elem->type();
62 
63   const Order totalorder = static_cast<Order>(order + elem->p_level());
64 
65   switch (totalorder)
66     {
67 
68       // 1st order Bernstein\&.
69     case FIRST:
70       {
71         switch (type)
72           {
73 
74             // Bernstein shape functions on the tetrahedron\&.
75           case TET4:
76           case TET10:
77             {
78               libmesh_assert_less (i, 4);
79 
80               // Area coordinates
81               const Real zeta1 = p(0);
82               const Real zeta2 = p(1);
83               const Real zeta3 = p(2);
84               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
85 
86               switch(i)
87                 {
88                 case  0:  return zeta0;
89                 case  1:  return zeta1;
90                 case  2:  return zeta2;
91                 case  3:  return zeta3;
92 
93                 default:
94                   libmesh_error();
95                 }
96             }
97 
98             // Bernstein shape functions on the hexahedral\&.
99           case HEX20:
100           case HEX27:
101             {
102               libmesh_assert_less (i, 8);
103 
104               // Compute hex shape functions as a tensor-product
105               const Real xi   = p(0);
106               const Real eta  = p(1);
107               const Real zeta = p(2);
108 
109               // The only way to make any sense of this
110               // is to look at the mgflo/mg2/mgf documentation
111               // and make the cut-out cube!
112               //                                0  1  2  3  4  5  6  7
113               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
114               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
115               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
116 
117               return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
118                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta)*
119                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[i], zeta));
120             }
121 
122 
123           default:
124             libmesh_error();
125           }
126       }
127 
128 
129 
130 
131     case SECOND:
132       {
133         switch (type)
134           {
135 
136             // Bernstein shape functions on the tetrahedron\&.
137           case TET10:
138             {
139               libmesh_assert_less (i, 10);
140 
141               // Area coordinates
142               const Real zeta1 = p(0);
143               const Real zeta2 = p(1);
144               const Real zeta3 = p(2);
145               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
146 
147               switch(i)
148                 {
149                 case  0:  return zeta0*zeta0;
150                 case  1:  return zeta1*zeta1;
151                 case  2:  return zeta2*zeta2;
152                 case  3:  return zeta3*zeta3;
153                 case  4:  return 2\&.*zeta0*zeta1;
154                 case  5:  return 2\&.*zeta1*zeta2;
155                 case  6:  return 2\&.*zeta0*zeta2;
156                 case  7:  return 2\&.*zeta3*zeta0;
157                 case  8:  return 2\&.*zeta1*zeta3;
158                 case  9:  return 2\&.*zeta2*zeta3;
159 
160                 default:
161                   libmesh_error();
162                 }
163             }
164 
165             // Bernstein shape functions on the 20-noded hexahedral\&.
166           case HEX20:
167             {
168               libmesh_assert_less (i, 20);
169 
170               // Compute hex shape functions as a tensor-product
171               const Real xi   = p(0);
172               const Real eta  = p(1);
173               const Real zeta = p(2);
174 
175               // The only way to make any sense of this
176               // is to look at the mgflo/mg2/mgf documentation
177               // and make the cut-out cube!
178               //                                0      1      2      3      4      5      6      7      8      9      10     11     12     13     14     15     16     17     18     19  20 21 22 23 24 25 26
179               static const unsigned int i0[] = {0,     1,     1,     0,     0,     1,     1,     0,     2,     1,     2,     0,     0,     1,     1,     0,     2,     1,     2,     0,  2, 2, 1, 2, 0, 2, 2};
180               static const unsigned int i1[] = {0,     0,     1,     1,     0,     0,     1,     1,     0,     2,     1,     2,     0,     0,     1,     1,     0,     2,     1,     2,  2, 0, 2, 1, 2, 2, 2};
181               static const unsigned int i2[] = {0,     0,     0,     0,     1,     1,     1,     1,     0,     0,     0,     0,     2,     2,     2,     2,     1,     1,     1,     1,  0, 2, 2, 2, 2, 1, 2};
182               //To compute the hex20 shape functions the original shape functions for hex27 are used\&.
183               //scalx[i] tells how often the original x-th shape function has to be added to the original i-th shape function
184               //to compute the new i-th shape function for hex20
185               //example: B_0^HEX20 = B_0^HEX27 - 0\&.25*B_20^HEX27 - 0\&.25*B_21^HEX27 + 0*B_22^HEX27 + 0*B_23^HEX27 - 0\&.25*B_24^HEX27 + 0*B_25^HEX27 - 0\&.25*B_26^HEX27
186               //         B_0^HEX20 = B_0^HEX27 + scal20[0]*B_20^HEX27 + scal21[0]*B_21^HEX27 + \&.\&.\&.
187               static const Real scal20[] =     {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0,     0,     0,     0,     0\&.5,   0\&.5,   0\&.5,   0\&.5,   0,     0,     0,     0,     0,     0,     0,     0};
188               static const Real scal21[] =     {-0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0,     0};
189               static const Real scal22[] =     {0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0};
190               static const Real scal23[] =     {0,     0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0};
191               static const Real scal24[] =     {-0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, 0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0,     0,     0\&.5};
192               static const Real scal25[] =     {0,     0,     0,     0,     -0\&.25, -0\&.25, -0\&.25, -0\&.25, 0,     0,     0,     0,     0,     0,     0,     0,     0\&.5,   0\&.5,   0\&.5,   0\&.5};
193               static const Real scal26[] =     {-0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25};
194 
195               return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
196                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta)*
197                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[i], zeta)
198                       +scal20[i]*
199                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[20], xi)*
200                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[20], eta)*
201                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[20], zeta)
202                       +scal21[i]*
203                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[21], xi)*
204                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[21], eta)*
205                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[21], zeta)
206                       +scal22[i]*
207                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[22], xi)*
208                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[22], eta)*
209                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[22], zeta)
210                       +scal23[i]*
211                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[23], xi)*
212                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[23], eta)*
213                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[23], zeta)
214                       +scal24[i]*
215                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[24], xi)*
216                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[24], eta)*
217                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[24], zeta)
218                       +scal25[i]*
219                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[25], xi)*
220                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[25], eta)*
221                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[25], zeta)
222                       +scal26[i]*
223                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[26], xi)*
224                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[26], eta)*
225                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[26], zeta));
226             }
227 
228             // Bernstein shape functions on the hexahedral\&.
229           case HEX27:
230             {
231               libmesh_assert_less (i, 27);
232 
233               // Compute hex shape functions as a tensor-product
234               const Real xi   = p(0);
235               const Real eta  = p(1);
236               const Real zeta = p(2);
237 
238               // The only way to make any sense of this
239               // is to look at the mgflo/mg2/mgf documentation
240               // and make the cut-out cube!
241               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
242               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
243               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
244               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
245 
246               return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi)*
247                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta)*
248                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[i], zeta));
249             }
250 
251 
252           default:
253             libmesh_error();
254           }
255 
256       }
257 
258 
259 
260       // 3rd-order Bernstein\&.
261     case THIRD:
262       {
263         switch (type)
264           {
265 
266             //     // Bernstein shape functions on the tetrahedron\&.
267             //   case TET10:
268             //     {
269             //       libmesh_assert_less (i, 20);
270 
271             //       // Area coordinates
272             //       const Real zeta1 = p(0);
273             //       const Real zeta2 = p(1);
274             //       const Real zeta3 = p(2);
275             //       const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
276 
277 
278             //       unsigned int shape=i;
279 
280             //       // handle the edge orientation
281 
282             //       if ((i== 4||i== 5) && elem->node(0) > elem->node(1))shape= 9-i;   //Edge 0
283             //       if ((i== 6||i== 7) && elem->node(1) > elem->node(2))shape=13-i;   //Edge 1
284             //       if ((i== 8||i== 9) && elem->node(0) > elem->node(2))shape=17-i;   //Edge 2
285             //       if ((i==10||i==11) && elem->node(0) > elem->node(3))shape=21-i;   //Edge 3
286             //       if ((i==12||i==13) && elem->node(1) > elem->node(3))shape=25-i;   //Edge 4
287             //       if ((i==14||i==15) && elem->node(2) > elem->node(3))shape=29-i;   //Edge 5
288 
289             //       // No need to handle face orientation in 3rd order\&.
290 
291 
292             //       switch(shape)
293             // {
294             //   //point function
295             // case  0:  return zeta0*zeta0*zeta0;
296             // case  1:  return zeta1*zeta1*zeta1;
297             // case  2:  return zeta2*zeta2*zeta2;
298             // case  3:  return zeta3*zeta3*zeta3;
299 
300             //   //edge functions
301             // case  4:  return 3\&.*zeta0*zeta0*zeta1;
302             // case  5:  return 3\&.*zeta1*zeta1*zeta0;
303 
304             // case  6:  return 3\&.*zeta1*zeta1*zeta2;
305             // case  7:  return 3\&.*zeta2*zeta2*zeta1;
306 
307             // case  8:  return 3\&.*zeta0*zeta0*zeta2;
308             // case  9:  return 3\&.*zeta2*zeta2*zeta0;
309 
310             // case 10:  return 3\&.*zeta0*zeta0*zeta3;
311             // case 11:  return 3\&.*zeta3*zeta3*zeta0;
312 
313             // case 12:  return 3\&.*zeta1*zeta1*zeta3;
314             // case 13:  return 3\&.*zeta3*zeta3*zeta1;
315 
316             // case 14:  return 3\&.*zeta2*zeta2*zeta3;
317             // case 15:  return 3\&.*zeta3*zeta3*zeta2;
318 
319             //   //face functions
320             // case 16:  return 6\&.*zeta0*zeta1*zeta2;
321             // case 17:  return 6\&.*zeta0*zeta1*zeta3;
322             // case 18:  return 6\&.*zeta1*zeta2*zeta3;
323             // case 19:  return 6\&.*zeta2*zeta0*zeta3;
324 
325             // default:
326             //   libmesh_error();
327             // }
328             //     }
329 
330 
331             // Bernstein shape functions on the hexahedral\&.
332           case HEX27:
333             {
334               libmesh_assert_less (i, 64);
335 
336               // Compute hex shape functions as a tensor-product
337               const Real xi    = p(0);
338               const Real eta   = p(1);
339               const Real zeta  = p(2);
340               Real xi_mapped   = p(0);
341               Real eta_mapped  = p(1);
342               Real zeta_mapped = p(2);
343 
344               // The only way to make any sense of this
345               // is to look at the mgflo/mg2/mgf documentation
346               // and make the cut-out cube!
347               //  Nodes                         0  1  2  3  4  5  6  7  8  8  9  9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 20 20 21 21 21 21 22 22 22 22 23 23 23 23 24 24 24 24 25 25 25 25 26 26 26 26 26 26 26 26
348               //  DOFS                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 18 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 60 62 63
349               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 3, 1, 1, 2, 3, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 2, 3, 2, 3, 0, 0, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3};
350               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 2, 2, 3, 3, 0, 0, 0, 0, 2, 3, 2, 3, 1, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3};
351               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3};
352 
353 
354 
355               // handle the edge orientation
356               {
357                 // Edge 0
358                 if ( (i0[i] >= 2) && (i1[i] == 0) && (i2[i] == 0))
359                   {
360                     if (elem->point(0) != std::min(elem->point(0), elem->point(1)))
361                       xi_mapped = -xi;
362                   }
363                 // Edge 1
364                 else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] == 0))
365                   {
366                     if (elem->point(1) != std::min(elem->point(1), elem->point(2)))
367                       eta_mapped = -eta;
368                   }
369                 // Edge 2
370                 else if ((i0[i] >= 2) && (i1[i] == 1) && (i2[i] == 0))
371                   {
372                     if (elem->point(3) != std::min(elem->point(3), elem->point(2)))
373                       xi_mapped = -xi;
374                   }
375                 // Edge 3
376                 else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] == 0))
377                   {
378                     if (elem->point(0) != std::min(elem->point(0), elem->point(3)))
379                       eta_mapped = -eta;
380                   }
381                 // Edge 4
382                 else if ((i0[i] == 0) && (i1[i] == 0) && (i2[i] >=2 ))
383                   {
384                     if (elem->point(0) != std::min(elem->point(0), elem->point(4)))
385                       zeta_mapped = -zeta;
386                   }
387                 // Edge 5
388                 else if ((i0[i] == 1) && (i1[i] == 0) && (i2[i] >=2 ))
389                   {
390                     if (elem->point(1) != std::min(elem->point(1), elem->point(5)))
391                       zeta_mapped = -zeta;
392                   }
393                 // Edge 6
394                 else if ((i0[i] == 1) && (i1[i] == 1) && (i2[i] >=2 ))
395                   {
396                     if (elem->point(2) != std::min(elem->point(2), elem->point(6)))
397                       zeta_mapped = -zeta;
398                   }
399                 // Edge 7
400                 else if ((i0[i] == 0) && (i1[i] == 1) && (i2[i] >=2 ))
401                   {
402                     if (elem->point(3) != std::min(elem->point(3), elem->point(7)))
403                       zeta_mapped = -zeta;
404                   }
405                 // Edge 8
406                 else if ((i0[i] >=2 ) && (i1[i] == 0) && (i2[i] == 1))
407                   {
408                     if (elem->point(4) != std::min(elem->point(4), elem->point(5)))
409                       xi_mapped = -xi;
410                   }
411                 // Edge 9
412                 else if ((i0[i] == 1) && (i1[i] >=2 ) && (i2[i] == 1))
413                   {
414                     if (elem->point(5) != std::min(elem->point(5), elem->point(6)))
415                       eta_mapped = -eta;
416                   }
417                 // Edge 10
418                 else if ((i0[i] >=2 ) && (i1[i] == 1) && (i2[i] == 1))
419                   {
420                     if (elem->point(7) != std::min(elem->point(7), elem->point(6)))
421                       xi_mapped = -xi;
422                   }
423                 // Edge 11
424                 else if ((i0[i] == 0) && (i1[i] >=2 ) && (i2[i] == 1))
425                   {
426                     if (elem->point(4) != std::min(elem->point(4), elem->point(7)))
427                       eta_mapped = -eta;
428                   }
429               }
430 
431 
432               // handle the face orientation
433               {
434                 // Face 0
435                 if (     (i2[i] == 0) && (i0[i] >= 2) && (i1[i] >= 2))
436                   {
437                     const Point min_point = std::min(elem->point(1),
438                                                      std::min(elem->point(2),
439                                                               std::min(elem->point(0),
440                                                                        elem->point(3))));
441                     if (elem->point(0) == min_point)
442                       if (elem->point(1) == std::min(elem->point(1), elem->point(3)))
443                         {
444                           // Case 1
445                           xi_mapped  = xi;
446                           eta_mapped = eta;
447                         }
448                       else
449                         {
450                           // Case 2
451                           xi_mapped  = eta;
452                           eta_mapped = xi;
453                         }
454 
455                     else if (elem->point(3) == min_point)
456                       if (elem->point(0) == std::min(elem->point(0), elem->point(2)))
457                         {
458                           // Case 3
459                           xi_mapped  = -eta;
460                           eta_mapped = xi;
461                         }
462                       else
463                         {
464                           // Case 4
465                           xi_mapped  = xi;
466                           eta_mapped = -eta;
467                         }
468 
469                     else if (elem->point(2) == min_point)
470                       if (elem->point(3) == std::min(elem->point(3), elem->point(1)))
471                         {
472                           // Case 5
473                           xi_mapped  = -xi;
474                           eta_mapped = -eta;
475                         }
476                       else
477                         {
478                           // Case 6
479                           xi_mapped  = -eta;
480                           eta_mapped = -xi;
481                         }
482 
483                     else if (elem->point(1) == min_point)
484                       {
485                         if (elem->point(2) == std::min(elem->point(2), elem->point(0)))
486                           {
487                             // Case 7
488                             xi_mapped  = eta;
489                             eta_mapped = -xi;
490                           }
491                         else
492                           {
493                             // Case 8
494                             xi_mapped  = -xi;
495                             eta_mapped = eta;
496                           }
497                       }
498                   }
499 
500 
501                 // Face 1
502                 else if ((i1[i] == 0) && (i0[i] >= 2) && (i2[i] >= 2))
503                   {
504                     const Point min_point = std::min(elem->point(0),
505                                                      std::min(elem->point(1),
506                                                               std::min(elem->point(5),
507                                                                        elem->point(4))));
508                     if (elem->point(0) == min_point)
509                       if (elem->point(1) == std::min(elem->point(1), elem->point(4)))
510                         {
511                           // Case 1
512                           xi_mapped   = xi;
513                           zeta_mapped = zeta;
514                         }
515                       else
516                         {
517                           // Case 2
518                           xi_mapped   = zeta;
519                           zeta_mapped = xi;
520                         }
521 
522                     else if (elem->point(1) == min_point)
523                       if (elem->point(5) == std::min(elem->point(5), elem->point(0)))
524                         {
525                           // Case 3
526                           xi_mapped   = zeta;
527                           zeta_mapped = -xi;
528                         }
529                       else
530                         {
531                           // Case 4
532                           xi_mapped   = -xi;
533                           zeta_mapped = zeta;
534                         }
535 
536                     else if (elem->point(5) == min_point)
537                       if (elem->point(4) == std::min(elem->point(4), elem->point(1)))
538                         {
539                           // Case 5
540                           xi_mapped   = -xi;
541                           zeta_mapped = -zeta;
542                         }
543                       else
544                         {
545                           // Case 6
546                           xi_mapped   = -zeta;
547                           zeta_mapped = -xi;
548                         }
549 
550                     else if (elem->point(4) == min_point)
551                       {
552                         if (elem->point(0) == std::min(elem->point(0), elem->point(5)))
553                           {
554                             // Case 7
555                             xi_mapped   = -xi;
556                             zeta_mapped = zeta;
557                           }
558                         else
559                           {
560                             // Case 8
561                             xi_mapped   = xi;
562                             zeta_mapped = -zeta;
563                           }
564                       }
565                   }
566 
567 
568                 // Face 2
569                 else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] >= 2))
570                   {
571                     const Point min_point = std::min(elem->point(1),
572                                                      std::min(elem->point(2),
573                                                               std::min(elem->point(6),
574                                                                        elem->point(5))));
575                     if (elem->point(1) == min_point)
576                       if (elem->point(2) == std::min(elem->point(2), elem->point(5)))
577                         {
578                           // Case 1
579                           eta_mapped  = eta;
580                           zeta_mapped = zeta;
581                         }
582                       else
583                         {
584                           // Case 2
585                           eta_mapped  = zeta;
586                           zeta_mapped = eta;
587                         }
588 
589                     else if (elem->point(2) == min_point)
590                       if (elem->point(6) == std::min(elem->point(6), elem->point(1)))
591                         {
592                           // Case 3
593                           eta_mapped  = zeta;
594                           zeta_mapped = -eta;
595                         }
596                       else
597                         {
598                           // Case 4
599                           eta_mapped  = -eta;
600                           zeta_mapped = zeta;
601                         }
602 
603                     else if (elem->point(6) == min_point)
604                       if (elem->point(5) == std::min(elem->point(5), elem->point(2)))
605                         {
606                           // Case 5
607                           eta_mapped  = -eta;
608                           zeta_mapped = -zeta;
609                         }
610                       else
611                         {
612                           // Case 6
613                           eta_mapped  = -zeta;
614                           zeta_mapped = -eta;
615                         }
616 
617                     else if (elem->point(5) == min_point)
618                       {
619                         if (elem->point(1) == std::min(elem->point(1), elem->point(6)))
620                           {
621                             // Case 7
622                             eta_mapped  = -zeta;
623                             zeta_mapped = eta;
624                           }
625                         else
626                           {
627                             // Case 8
628                             eta_mapped   = eta;
629                             zeta_mapped = -zeta;
630                           }
631                       }
632                   }
633 
634 
635                 // Face 3
636                 else if ((i1[i] == 1) && (i0[i] >= 2) && (i2[i] >= 2))
637                   {
638                     const Point min_point = std::min(elem->point(2),
639                                                      std::min(elem->point(3),
640                                                               std::min(elem->point(7),
641                                                                        elem->point(6))));
642                     if (elem->point(3) == min_point)
643                       if (elem->point(2) == std::min(elem->point(2), elem->point(7)))
644                         {
645                           // Case 1
646                           xi_mapped   = xi;
647                           zeta_mapped = zeta;
648                         }
649                       else
650                         {
651                           // Case 2
652                           xi_mapped   = zeta;
653                           zeta_mapped = xi;
654                         }
655 
656                     else if (elem->point(7) == min_point)
657                       if (elem->point(3) == std::min(elem->point(3), elem->point(6)))
658                         {
659                           // Case 3
660                           xi_mapped   = -zeta;
661                           zeta_mapped = xi;
662                         }
663                       else
664                         {
665                           // Case 4
666                           xi_mapped   = xi;
667                           zeta_mapped = -zeta;
668                         }
669 
670                     else if (elem->point(6) == min_point)
671                       if (elem->point(7) == std::min(elem->point(7), elem->point(2)))
672                         {
673                           // Case 5
674                           xi_mapped   = -xi;
675                           zeta_mapped = -zeta;
676                         }
677                       else
678                         {
679                           // Case 6
680                           xi_mapped   = -zeta;
681                           zeta_mapped = -xi;
682                         }
683 
684                     else if (elem->point(2) == min_point)
685                       {
686                         if (elem->point(6) == std::min(elem->point(3), elem->point(6)))
687                           {
688                             // Case 7
689                             xi_mapped   = zeta;
690                             zeta_mapped = -xi;
691                           }
692                         else
693                           {
694                             // Case 8
695                             xi_mapped   = -xi;
696                             zeta_mapped = zeta;
697                           }
698                       }
699                   }
700 
701 
702                 // Face 4
703                 else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] >= 2))
704                   {
705                     const Point min_point = std::min(elem->point(3),
706                                                      std::min(elem->point(0),
707                                                               std::min(elem->point(4),
708                                                                        elem->point(7))));
709                     if (elem->point(0) == min_point)
710                       if (elem->point(3) == std::min(elem->point(3), elem->point(4)))
711                         {
712                           // Case 1
713                           eta_mapped  = eta;
714                           zeta_mapped = zeta;
715                         }
716                       else
717                         {
718                           // Case 2
719                           eta_mapped  = zeta;
720                           zeta_mapped = eta;
721                         }
722 
723                     else if (elem->point(4) == min_point)
724                       if (elem->point(0) == std::min(elem->point(0), elem->point(7)))
725                         {
726                           // Case 3
727                           eta_mapped  = -zeta;
728                           zeta_mapped = eta;
729                         }
730                       else
731                         {
732                           // Case 4
733                           eta_mapped  = eta;
734                           zeta_mapped = -zeta;
735                         }
736 
737                     else if (elem->point(7) == min_point)
738                       if (elem->point(4) == std::min(elem->point(4), elem->point(3)))
739                         {
740                           // Case 5
741                           eta_mapped  = -eta;
742                           zeta_mapped = -zeta;
743                         }
744                       else
745                         {
746                           // Case 6
747                           eta_mapped  = -zeta;
748                           zeta_mapped = -eta;
749                         }
750 
751                     else if (elem->point(3) == min_point)
752                       {
753                         if (elem->point(7) == std::min(elem->point(7), elem->point(0)))
754                           {
755                             // Case 7
756                             eta_mapped   = zeta;
757                             zeta_mapped = -eta;
758                           }
759                         else
760                           {
761                             // Case 8
762                             eta_mapped  = -eta;
763                             zeta_mapped = zeta;
764                           }
765                       }
766                   }
767 
768 
769                 // Face 5
770                 else if ((i2[i] == 1) && (i0[i] >= 2) && (i1[i] >= 2))
771                   {
772                     const Point min_point = std::min(elem->point(4),
773                                                      std::min(elem->point(5),
774                                                               std::min(elem->point(6),
775                                                                        elem->point(7))));
776                     if (elem->point(4) == min_point)
777                       if (elem->point(5) == std::min(elem->point(5), elem->point(7)))
778                         {
779                           // Case 1
780                           xi_mapped  = xi;
781                           eta_mapped = eta;
782                         }
783                       else
784                         {
785                           // Case 2
786                           xi_mapped  = eta;
787                           eta_mapped = xi;
788                         }
789 
790                     else if (elem->point(5) == min_point)
791                       if (elem->point(6) == std::min(elem->point(6), elem->point(4)))
792                         {
793                           // Case 3
794                           xi_mapped  = eta;
795                           eta_mapped = -xi;
796                         }
797                       else
798                         {
799                           // Case 4
800                           xi_mapped  = -xi;
801                           eta_mapped = eta;
802                         }
803 
804                     else if (elem->point(6) == min_point)
805                       if (elem->point(7) == std::min(elem->point(7), elem->point(5)))
806                         {
807                           // Case 5
808                           xi_mapped  = -xi;
809                           eta_mapped = -eta;
810                         }
811                       else
812                         {
813                           // Case 6
814                           xi_mapped  = -eta;
815                           eta_mapped = -xi;
816                         }
817 
818                     else if (elem->point(7) == min_point)
819                       {
820                         if (elem->point(4) == std::min(elem->point(4), elem->point(6)))
821                           {
822                             // Case 7
823                             xi_mapped  = -eta;
824                             eta_mapped = xi;
825                           }
826                         else
827                           {
828                             // Case 8
829                             xi_mapped  = xi;
830                             eta_mapped = eta;
831                           }
832                       }
833                   }
834               }
835 
836               return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi_mapped)*
837                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta_mapped)*
838                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[i], zeta_mapped));
839             }
840 
841 
842           default:
843             libmesh_error();
844 
845           } //case HEX27
846 
847       }//case THIRD
848 
849 
850       // 4th-order Bernstein\&.
851     case FOURTH:
852       {
853         switch (type)
854           {
855 
856             // Bernstein shape functions on the hexahedral\&.
857           case HEX27:
858             {
859               libmesh_assert_less (i, 125);
860 
861               // Compute hex shape functions as a tensor-product
862               const Real xi    = p(0);
863               const Real eta   = p(1);
864               const Real zeta  = p(2);
865               Real xi_mapped   = p(0);
866               Real eta_mapped  = p(1);
867               Real zeta_mapped = p(2);
868 
869               // The only way to make any sense of this
870               // is to look at the mgflo/mg2/mgf documentation
871               // and make the cut-out cube!
872               //  Nodes                         0  1  2  3  4  5  6  7  8  8  9  9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 20 20 21 21 21 21 22 22 22 22 23 23 23 23 24 24 24 24 25 25 25 25 26 26 26 26 26 26 26 26
873               //  DOFS                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 18 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 60 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
874               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4};
875               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
876               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4};
877 
878 
879 
880               // handle the edge orientation
881               {
882                 // Edge 0
883                 if ( (i0[i] >= 2) && (i1[i] == 0) && (i2[i] == 0))
884                   {
885                     if (elem->point(0) != std::min(elem->point(0), elem->point(1)))
886                       xi_mapped = -xi;
887                   }
888                 // Edge 1
889                 else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] == 0))
890                   {
891                     if (elem->point(1) != std::min(elem->point(1), elem->point(2)))
892                       eta_mapped = -eta;
893                   }
894                 // Edge 2
895                 else if ((i0[i] >= 2) && (i1[i] == 1) && (i2[i] == 0))
896                   {
897                     if (elem->point(3) != std::min(elem->point(3), elem->point(2)))
898                       xi_mapped = -xi;
899                   }
900                 // Edge 3
901                 else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] == 0))
902                   {
903                     if (elem->point(0) != std::min(elem->point(0), elem->point(3)))
904                       eta_mapped = -eta;
905                   }
906                 // Edge 4
907                 else if ((i0[i] == 0) && (i1[i] == 0) && (i2[i] >=2 ))
908                   {
909                     if (elem->point(0) != std::min(elem->point(0), elem->point(4)))
910                       zeta_mapped = -zeta;
911                   }
912                 // Edge 5
913                 else if ((i0[i] == 1) && (i1[i] == 0) && (i2[i] >=2 ))
914                   {
915                     if (elem->point(1) != std::min(elem->point(1), elem->point(5)))
916                       zeta_mapped = -zeta;
917                   }
918                 // Edge 6
919                 else if ((i0[i] == 1) && (i1[i] == 1) && (i2[i] >=2 ))
920                   {
921                     if (elem->point(2) != std::min(elem->point(2), elem->point(6)))
922                       zeta_mapped = -zeta;
923                   }
924                 // Edge 7
925                 else if ((i0[i] == 0) && (i1[i] == 1) && (i2[i] >=2 ))
926                   {
927                     if (elem->point(3) != std::min(elem->point(3), elem->point(7)))
928                       zeta_mapped = -zeta;
929                   }
930                 // Edge 8
931                 else if ((i0[i] >=2 ) && (i1[i] == 0) && (i2[i] == 1))
932                   {
933                     if (elem->point(4) != std::min(elem->point(4), elem->point(5)))
934                       xi_mapped = -xi;
935                   }
936                 // Edge 9
937                 else if ((i0[i] == 1) && (i1[i] >=2 ) && (i2[i] == 1))
938                   {
939                     if (elem->point(5) != std::min(elem->point(5), elem->point(6)))
940                       eta_mapped = -eta;
941                   }
942                 // Edge 10
943                 else if ((i0[i] >=2 ) && (i1[i] == 1) && (i2[i] == 1))
944                   {
945                     if (elem->point(7) != std::min(elem->point(7), elem->point(6)))
946                       xi_mapped = -xi;
947                   }
948                 // Edge 11
949                 else if ((i0[i] == 0) && (i1[i] >=2 ) && (i2[i] == 1))
950                   {
951                     if (elem->point(4) != std::min(elem->point(4), elem->point(7)))
952                       eta_mapped = -eta;
953                   }
954               }
955 
956 
957               // handle the face orientation
958               {
959                 // Face 0
960                 if (     (i2[i] == 0) && (i0[i] >= 2) && (i1[i] >= 2))
961                   {
962                     const Point min_point = std::min(elem->point(1),
963                                                      std::min(elem->point(2),
964                                                               std::min(elem->point(0),
965                                                                        elem->point(3))));
966                     if (elem->point(0) == min_point)
967                       if (elem->point(1) == std::min(elem->point(1), elem->point(3)))
968                         {
969                           // Case 1
970                           xi_mapped  = xi;
971                           eta_mapped = eta;
972                         }
973                       else
974                         {
975                           // Case 2
976                           xi_mapped  = eta;
977                           eta_mapped = xi;
978                         }
979 
980                     else if (elem->point(3) == min_point)
981                       if (elem->point(0) == std::min(elem->point(0), elem->point(2)))
982                         {
983                           // Case 3
984                           xi_mapped  = -eta;
985                           eta_mapped = xi;
986                         }
987                       else
988                         {
989                           // Case 4
990                           xi_mapped  = xi;
991                           eta_mapped = -eta;
992                         }
993 
994                     else if (elem->point(2) == min_point)
995                       if (elem->point(3) == std::min(elem->point(3), elem->point(1)))
996                         {
997                           // Case 5
998                           xi_mapped  = -xi;
999                           eta_mapped = -eta;
1000                         }
1001                       else
1002                         {
1003                           // Case 6
1004                           xi_mapped  = -eta;
1005                           eta_mapped = -xi;
1006                         }
1007 
1008                     else if (elem->point(1) == min_point)
1009                       {
1010                         if (elem->point(2) == std::min(elem->point(2), elem->point(0)))
1011                           {
1012                             // Case 7
1013                             xi_mapped  = eta;
1014                             eta_mapped = -xi;
1015                           }
1016                         else
1017                           {
1018                             // Case 8
1019                             xi_mapped  = -xi;
1020                             eta_mapped = eta;
1021                           }
1022                       }
1023                   }
1024 
1025 
1026                 // Face 1
1027                 else if ((i1[i] == 0) && (i0[i] >= 2) && (i2[i] >= 2))
1028                   {
1029                     const Point min_point = std::min(elem->point(0),
1030                                                      std::min(elem->point(1),
1031                                                               std::min(elem->point(5),
1032                                                                        elem->point(4))));
1033                     if (elem->point(0) == min_point)
1034                       if (elem->point(1) == std::min(elem->point(1), elem->point(4)))
1035                         {
1036                           // Case 1
1037                           xi_mapped   = xi;
1038                           zeta_mapped = zeta;
1039                         }
1040                       else
1041                         {
1042                           // Case 2
1043                           xi_mapped   = zeta;
1044                           zeta_mapped = xi;
1045                         }
1046 
1047                     else if (elem->point(1) == min_point)
1048                       if (elem->point(5) == std::min(elem->point(5), elem->point(0)))
1049                         {
1050                           // Case 3
1051                           xi_mapped   = zeta;
1052                           zeta_mapped = -xi;
1053                         }
1054                       else
1055                         {
1056                           // Case 4
1057                           xi_mapped   = -xi;
1058                           zeta_mapped = zeta;
1059                         }
1060 
1061                     else if (elem->point(5) == min_point)
1062                       if (elem->point(4) == std::min(elem->point(4), elem->point(1)))
1063                         {
1064                           // Case 5
1065                           xi_mapped   = -xi;
1066                           zeta_mapped = -zeta;
1067                         }
1068                       else
1069                         {
1070                           // Case 6
1071                           xi_mapped   = -zeta;
1072                           zeta_mapped = -xi;
1073                         }
1074 
1075                     else if (elem->point(4) == min_point)
1076                       {
1077                         if (elem->point(0) == std::min(elem->point(0), elem->point(5)))
1078                           {
1079                             // Case 7
1080                             xi_mapped   = -xi;
1081                             zeta_mapped = zeta;
1082                           }
1083                         else
1084                           {
1085                             // Case 8
1086                             xi_mapped   = xi;
1087                             zeta_mapped = -zeta;
1088                           }
1089                       }
1090                   }
1091 
1092 
1093                 // Face 2
1094                 else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] >= 2))
1095                   {
1096                     const Point min_point = std::min(elem->point(1),
1097                                                      std::min(elem->point(2),
1098                                                               std::min(elem->point(6),
1099                                                                        elem->point(5))));
1100                     if (elem->point(1) == min_point)
1101                       if (elem->point(2) == std::min(elem->point(2), elem->point(5)))
1102                         {
1103                           // Case 1
1104                           eta_mapped  = eta;
1105                           zeta_mapped = zeta;
1106                         }
1107                       else
1108                         {
1109                           // Case 2
1110                           eta_mapped  = zeta;
1111                           zeta_mapped = eta;
1112                         }
1113 
1114                     else if (elem->point(2) == min_point)
1115                       if (elem->point(6) == std::min(elem->point(6), elem->point(1)))
1116                         {
1117                           // Case 3
1118                           eta_mapped  = zeta;
1119                           zeta_mapped = -eta;
1120                         }
1121                       else
1122                         {
1123                           // Case 4
1124                           eta_mapped  = -eta;
1125                           zeta_mapped = zeta;
1126                         }
1127 
1128                     else if (elem->point(6) == min_point)
1129                       if (elem->point(5) == std::min(elem->point(5), elem->point(2)))
1130                         {
1131                           // Case 5
1132                           eta_mapped  = -eta;
1133                           zeta_mapped = -zeta;
1134                         }
1135                       else
1136                         {
1137                           // Case 6
1138                           eta_mapped  = -zeta;
1139                           zeta_mapped = -eta;
1140                         }
1141 
1142                     else if (elem->point(5) == min_point)
1143                       {
1144                         if (elem->point(1) == std::min(elem->point(1), elem->point(6)))
1145                           {
1146                             // Case 7
1147                             eta_mapped  = -zeta;
1148                             zeta_mapped = eta;
1149                           }
1150                         else
1151                           {
1152                             // Case 8
1153                             eta_mapped   = eta;
1154                             zeta_mapped = -zeta;
1155                           }
1156                       }
1157                   }
1158 
1159 
1160                 // Face 3
1161                 else if ((i1[i] == 1) && (i0[i] >= 2) && (i2[i] >= 2))
1162                   {
1163                     const Point min_point = std::min(elem->point(2),
1164                                                      std::min(elem->point(3),
1165                                                               std::min(elem->point(7),
1166                                                                        elem->point(6))));
1167                     if (elem->point(3) == min_point)
1168                       if (elem->point(2) == std::min(elem->point(2), elem->point(7)))
1169                         {
1170                           // Case 1
1171                           xi_mapped   = xi;
1172                           zeta_mapped = zeta;
1173                         }
1174                       else
1175                         {
1176                           // Case 2
1177                           xi_mapped   = zeta;
1178                           zeta_mapped = xi;
1179                         }
1180 
1181                     else if (elem->point(7) == min_point)
1182                       if (elem->point(3) == std::min(elem->point(3), elem->point(6)))
1183                         {
1184                           // Case 3
1185                           xi_mapped   = -zeta;
1186                           zeta_mapped = xi;
1187                         }
1188                       else
1189                         {
1190                           // Case 4
1191                           xi_mapped   = xi;
1192                           zeta_mapped = -zeta;
1193                         }
1194 
1195                     else if (elem->point(6) == min_point)
1196                       if (elem->point(7) == std::min(elem->point(7), elem->point(2)))
1197                         {
1198                           // Case 5
1199                           xi_mapped   = -xi;
1200                           zeta_mapped = -zeta;
1201                         }
1202                       else
1203                         {
1204                           // Case 6
1205                           xi_mapped   = -zeta;
1206                           zeta_mapped = -xi;
1207                         }
1208 
1209                     else if (elem->point(2) == min_point)
1210                       {
1211                         if (elem->point(6) == std::min(elem->point(3), elem->point(6)))
1212                           {
1213                             // Case 7
1214                             xi_mapped   = zeta;
1215                             zeta_mapped = -xi;
1216                           }
1217                         else
1218                           {
1219                             // Case 8
1220                             xi_mapped   = -xi;
1221                             zeta_mapped = zeta;
1222                           }
1223                       }
1224                   }
1225 
1226 
1227                 // Face 4
1228                 else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] >= 2))
1229                   {
1230                     const Point min_point = std::min(elem->point(3),
1231                                                      std::min(elem->point(0),
1232                                                               std::min(elem->point(4),
1233                                                                        elem->point(7))));
1234                     if (elem->point(0) == min_point)
1235                       if (elem->point(3) == std::min(elem->point(3), elem->point(4)))
1236                         {
1237                           // Case 1
1238                           eta_mapped  = eta;
1239                           zeta_mapped = zeta;
1240                         }
1241                       else
1242                         {
1243                           // Case 2
1244                           eta_mapped  = zeta;
1245                           zeta_mapped = eta;
1246                         }
1247 
1248                     else if (elem->point(4) == min_point)
1249                       if (elem->point(0) == std::min(elem->point(0), elem->point(7)))
1250                         {
1251                           // Case 3
1252                           eta_mapped  = -zeta;
1253                           zeta_mapped = eta;
1254                         }
1255                       else
1256                         {
1257                           // Case 4
1258                           eta_mapped  = eta;
1259                           zeta_mapped = -zeta;
1260                         }
1261 
1262                     else if (elem->point(7) == min_point)
1263                       if (elem->point(4) == std::min(elem->point(4), elem->point(3)))
1264                         {
1265                           // Case 5
1266                           eta_mapped  = -eta;
1267                           zeta_mapped = -zeta;
1268                         }
1269                       else
1270                         {
1271                           // Case 6
1272                           eta_mapped  = -zeta;
1273                           zeta_mapped = -eta;
1274                         }
1275 
1276                     else if (elem->point(3) == min_point)
1277                       {
1278                         if (elem->point(7) == std::min(elem->point(7), elem->point(0)))
1279                           {
1280                             // Case 7
1281                             eta_mapped   = zeta;
1282                             zeta_mapped = -eta;
1283                           }
1284                         else
1285                           {
1286                             // Case 8
1287                             eta_mapped  = -eta;
1288                             zeta_mapped = zeta;
1289                           }
1290                       }
1291                   }
1292 
1293 
1294                 // Face 5
1295                 else if ((i2[i] == 1) && (i0[i] >= 2) && (i1[i] >= 2))
1296                   {
1297                     const Point min_point = std::min(elem->point(4),
1298                                                      std::min(elem->point(5),
1299                                                               std::min(elem->point(6),
1300                                                                        elem->point(7))));
1301                     if (elem->point(4) == min_point)
1302                       if (elem->point(5) == std::min(elem->point(5), elem->point(7)))
1303                         {
1304                           // Case 1
1305                           xi_mapped  = xi;
1306                           eta_mapped = eta;
1307                         }
1308                       else
1309                         {
1310                           // Case 2
1311                           xi_mapped  = eta;
1312                           eta_mapped = xi;
1313                         }
1314 
1315                     else if (elem->point(5) == min_point)
1316                       if (elem->point(6) == std::min(elem->point(6), elem->point(4)))
1317                         {
1318                           // Case 3
1319                           xi_mapped  = eta;
1320                           eta_mapped = -xi;
1321                         }
1322                       else
1323                         {
1324                           // Case 4
1325                           xi_mapped  = -xi;
1326                           eta_mapped = eta;
1327                         }
1328 
1329                     else if (elem->point(6) == min_point)
1330                       if (elem->point(7) == std::min(elem->point(7), elem->point(5)))
1331                         {
1332                           // Case 5
1333                           xi_mapped  = -xi;
1334                           eta_mapped = -eta;
1335                         }
1336                       else
1337                         {
1338                           // Case 6
1339                           xi_mapped  = -eta;
1340                           eta_mapped = -xi;
1341                         }
1342 
1343                     else if (elem->point(7) == min_point)
1344                       {
1345                         if (elem->point(4) == std::min(elem->point(4), elem->point(6)))
1346                           {
1347                             // Case 7
1348                             xi_mapped  = -eta;
1349                             eta_mapped = xi;
1350                           }
1351                         else
1352                           {
1353                             // Case 8
1354                             xi_mapped  = xi;
1355                             eta_mapped = eta;
1356                           }
1357                       }
1358                   }
1359 
1360 
1361               }
1362 
1363 
1364               return (FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i0[i], xi_mapped)*
1365                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i1[i], eta_mapped)*
1366                       FE<1,BERNSTEIN>::shape(EDGE3, totalorder, i2[i], zeta_mapped));
1367             }
1368 
1369 
1370           default:
1371             libmesh_error();
1372           }
1373       }
1374 
1375 
1376     default:
1377       libmesh_error();
1378     }
1379 
1380 #endif
1381 
1382   libmesh_error();
1383   return 0\&.;
1384 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 53 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
57 {
58   libMesh::err << "Szabo-Babuska polynomials require the element type\n"
59                << "because edge orientation is needed\&."
60                << std::endl;
61 
62   libmesh_error();
63   return 0\&.;
64 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &point_in)"

.PP
Definition at line 62 of file fe_xyz_shape_1D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
66 {
67   libmesh_assert(elem);
68   libmesh_assert_less_equal (i, order + elem->p_level());
69 
70   // Only recompute the centroid if the element
71   // has changed from the last one we computed\&.
72   // This avoids repeated centroid calculations
73   // when called in succession with the same element\&.
74   if (elem->id() != old_elem_id)
75     {
76       centroid = elem->centroid();
77       old_elem_id = elem->id();
78       max_distance = 0\&.;
79       for (unsigned int p = 0; p < elem->n_nodes(); p++)
80         {
81           const Real distance = std::abs(centroid(0) - elem->point(p)(0));
82           max_distance = std::max(distance, max_distance);
83         }
84     }
85 
86   // Using static globals for old_elem_id, etc\&. will fail
87   // horribly with more than one thread\&.
88   libmesh_assert_equal_to (libMesh::n_threads(), 1);
89 
90   const Real x  = point_in(0);
91   const Real xc = centroid(0);
92   const Real dx = (x - xc)/max_distance;
93 
94   // monomials\&. since they are hierarchic we only need one case block\&.
95   switch (i)
96     {
97     case 0:
98       return 1\&.;
99 
100     case 1:
101       return dx;
102 
103     case 2:
104       return dx*dx;
105 
106     case 3:
107       return dx*dx*dx;
108 
109     case 4:
110       return dx*dx*dx*dx;
111 
112     default:
113       Real val = 1\&.;
114       for (unsigned int index = 0; index != i; ++index)
115         val *= dx;
116       return val;
117     }
118 
119   libmesh_error();
120   return 0\&.;
121 
122 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &point_in)"

.PP
Definition at line 62 of file fe_xyz_shape_2D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
66 {
67 #if LIBMESH_DIM > 1
68 
69   libmesh_assert(elem);
70 
71   // Only recompute the centroid if the element
72   // has changed from the last one we computed\&.
73   // This avoids repeated centroid calculations
74   // when called in succession with the same element\&.
75   if (elem->id() != old_elem_id)
76     {
77       centroid = elem->centroid();
78       old_elem_id = elem->id();
79       max_distance = Point(0\&.,0\&.,0\&.);
80       for (unsigned int p = 0; p < elem->n_nodes(); p++)
81         for (unsigned int d = 0; d < 2; d++)
82           {
83             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
84             max_distance(d) = std::max(distance, max_distance(d));
85           }
86     }
87 
88   // Using static globals for old_elem_id, etc\&. will fail
89   // horribly with more than one thread\&.
90   libmesh_assert_equal_to (libMesh::n_threads(), 1);
91 
92   const Real x  = point_in(0);
93   const Real y  = point_in(1);
94   const Real xc = centroid(0);
95   const Real yc = centroid(1);
96   const Real distx = max_distance(0);
97   const Real disty = max_distance(1);
98   const Real dx = (x - xc)/distx;
99   const Real dy = (y - yc)/disty;
100 
101 #ifndef NDEBUG
102   // totalorder is only used in the assertion below, so
103   // we avoid declaring it when asserts are not active\&.
104   const unsigned int totalorder = order + elem->p_level();
105 #endif
106   libmesh_assert_less (i, (totalorder+1)*(totalorder+2)/2);
107 
108 
109   // monomials\&. since they are hierarchic we only need one case block\&.
110   switch (i)
111     {
112       // constant
113     case 0:
114       return 1\&.;
115 
116       // linear
117     case 1:
118       return dx;
119 
120     case 2:
121       return dy;
122 
123       // quadratics
124     case 3:
125       return dx*dx;
126 
127     case 4:
128       return dx*dy;
129 
130     case 5:
131       return dy*dy;
132 
133       // cubics
134     case 6:
135       return dx*dx*dx;
136 
137     case 7:
138       return dx*dx*dy;
139 
140     case 8:
141       return dx*dy*dy;
142 
143     case 9:
144       return dy*dy*dy;
145 
146       // quartics
147     case 10:
148       return dx*dx*dx*dx;
149 
150     case 11:
151       return dx*dx*dx*dy;
152 
153     case 12:
154       return dx*dx*dy*dy;
155 
156     case 13:
157       return dx*dy*dy*dy;
158 
159     case 14:
160       return dy*dy*dy*dy;
161 
162     default:
163       unsigned int o = 0;
164       for (; i >= (o+1)*(o+2)/2; o++) { }
165       unsigned int i2 = i - (o*(o+1)/2);
166       Real val = 1\&.;
167       for (unsigned int index=i2; index != o; index++)
168         val *= dx;
169       for (unsigned int index=0; index != i2; index++)
170         val *= dy;
171       return val;
172     }
173 
174   libmesh_error();
175   return 0\&.;
176 
177 #endif
178 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const \fBPoint\fP &point_in)"

.PP
Definition at line 62 of file fe_xyz_shape_3D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
66 {
67 #if LIBMESH_DIM == 3
68   libmesh_assert(elem);
69 
70   // Only recompute the centroid if the element
71   // has changed from the last one we computed\&.
72   // This avoids repeated centroid calculations
73   // when called in succession with the same element\&.
74   if (elem->id() != old_elem_id)
75     {
76       centroid = elem->centroid();
77       old_elem_id = elem->id();
78       max_distance = Point(0\&.,0\&.,0\&.);
79       for (unsigned int p = 0; p < elem->n_nodes(); p++)
80         for (unsigned int d = 0; d < 3; d++)
81           {
82             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
83             max_distance(d) = std::max(distance, max_distance(d));
84           }
85     }
86 
87   // Using static globals for old_elem_id, etc\&. will fail
88   // horribly with more than one thread\&.
89   libmesh_assert_equal_to (libMesh::n_threads(), 1);
90 
91   const Real x  = point_in(0);
92   const Real y  = point_in(1);
93   const Real z  = point_in(2);
94   const Real xc = centroid(0);
95   const Real yc = centroid(1);
96   const Real zc = centroid(2);
97   const Real distx = max_distance(0);
98   const Real disty = max_distance(1);
99   const Real distz = max_distance(2);
100   const Real dx = (x - xc)/distx;
101   const Real dy = (y - yc)/disty;
102   const Real dz = (z - zc)/distz;
103 
104 #ifndef NDEBUG
105   // totalorder is only used in the assertion below, so
106   // we avoid declaring it when asserts are not active\&.
107   const unsigned int totalorder = order + elem->p_level();
108 #endif
109   libmesh_assert_less (i, (static_cast<unsigned int>(totalorder)+1)*
110                        (static_cast<unsigned int>(totalorder)+2)*
111                        (static_cast<unsigned int>(totalorder)+3)/6);
112 
113   // monomials\&. since they are hierarchic we only need one case block\&.
114   switch (i)
115     {
116       // constant
117     case 0:
118       return 1\&.;
119 
120       // linears
121     case 1:
122       return dx;
123 
124     case 2:
125       return dy;
126 
127     case 3:
128       return dz;
129 
130       // quadratics
131     case 4:
132       return dx*dx;
133 
134     case 5:
135       return dx*dy;
136 
137     case 6:
138       return dy*dy;
139 
140     case 7:
141       return dx*dz;
142 
143     case 8:
144       return dz*dy;
145 
146     case 9:
147       return dz*dz;
148 
149       // cubics
150     case 10:
151       return dx*dx*dx;
152 
153     case 11:
154       return dx*dx*dy;
155 
156     case 12:
157       return dx*dy*dy;
158 
159     case 13:
160       return dy*dy*dy;
161 
162     case 14:
163       return dx*dx*dz;
164 
165     case 15:
166       return dx*dy*dz;
167 
168     case 16:
169       return dy*dy*dz;
170 
171     case 17:
172       return dx*dz*dz;
173 
174     case 18:
175       return dy*dz*dz;
176 
177     case 19:
178       return dz*dz*dz;
179 
180       // quartics
181     case 20:
182       return dx*dx*dx*dx;
183 
184     case 21:
185       return dx*dx*dx*dy;
186 
187     case 22:
188       return dx*dx*dy*dy;
189 
190     case 23:
191       return dx*dy*dy*dy;
192 
193     case 24:
194       return dy*dy*dy*dy;
195 
196     case 25:
197       return dx*dx*dx*dz;
198 
199     case 26:
200       return dx*dx*dy*dz;
201 
202     case 27:
203       return dx*dy*dy*dz;
204 
205     case 28:
206       return dy*dy*dy*dz;
207 
208     case 29:
209       return dx*dx*dz*dz;
210 
211     case 30:
212       return dx*dy*dz*dz;
213 
214     case 31:
215       return dy*dy*dz*dz;
216 
217     case 32:
218       return dx*dz*dz*dz;
219 
220     case 33:
221       return dy*dz*dz*dz;
222 
223     case 34:
224       return dz*dz*dz*dz;
225 
226     default:
227       unsigned int o = 0;
228       for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
229       unsigned int i2 = i - (o*(o+1)*(o+2)/6);
230       unsigned int block=o, nz = 0;
231       for (; block < i2; block += (o-nz+1)) { nz++; }
232       const unsigned int nx = block - i2;
233       const unsigned int ny = o - nx - nz;
234       Real val = 1\&.;
235       for (unsigned int index=0; index != nx; index++)
236         val *= dx;
237       for (unsigned int index=0; index != ny; index++)
238         val *= dy;
239       for (unsigned int index=0; index != nz; index++)
240         val *= dz;
241       return val;
242     }
243 
244 #endif
245 
246   libmesh_error();
247   return 0\&.;
248 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 69 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::FIFTH, libMesh::FIRST, libMesh::FOURTH, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Utility::pow(), libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::SEVENTH, libMesh::FE< Dim, T >::shape(), libMesh::SIXTH, libMesh::THIRD, libMesh::TRI6, libMesh::Elem::type(), and libMesh::x\&.
.PP
.nf
73 {
74   libmesh_assert(elem);
75 
76   const ElemType type = elem->type();
77 
78   const Order totalorder = static_cast<Order>(order + elem->p_level());
79 
80   // Declare that we are using our own special power function
81   // from the Utility namespace\&.  This saves typing later\&.
82   using Utility::pow;
83 
84   switch (totalorder)
85     {
86       // 1st & 2nd-order Szabo-Babuska\&.
87     case FIRST:
88     case SECOND:
89       {
90         switch (type)
91           {
92 
93             // Szabo-Babuska shape functions on the triangle\&.
94           case TRI6:
95             {
96               const Real l1 = 1-p(0)-p(1);
97               const Real l2 = p(0);
98               const Real l3 = p(1);
99 
100               libmesh_assert_less (i, 6);
101 
102               switch (i)
103                 {
104                 case 0: return l1;
105                 case 1: return l2;
106                 case 2: return l3;
107 
108                 case 3: return l1*l2*(-4\&.*sqrt6);
109                 case 4: return l2*l3*(-4\&.*sqrt6);
110                 case 5: return l3*l1*(-4\&.*sqrt6);
111 
112                 default:
113                   libmesh_error();
114                 }
115             }
116 
117 
118             // Szabo-Babuska shape functions on the quadrilateral\&.
119           case QUAD8:
120           case QUAD9:
121             {
122               // Compute quad shape functions as a tensor-product
123               const Real xi  = p(0);
124               const Real eta = p(1);
125 
126               libmesh_assert_less (i, 9);
127 
128               //                                0  1  2  3  4  5  6  7  8
129               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
130               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
131 
132               return (FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
133                       FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
134 
135             }
136 
137 
138           default:
139             libmesh_error();
140           }
141       }
142 
143 
144       // 3rd-order Szabo-Babuska\&.
145     case THIRD:
146       {
147         switch (type)
148           {
149 
150             // Szabo-Babuska shape functions on the triangle\&.
151           case TRI6:
152             {
153               Real l1 = 1-p(0)-p(1);
154               Real l2 = p(0);
155               Real l3 = p(1);
156 
157               Real f=1;
158 
159               libmesh_assert_less (i, 10);
160 
161 
162               if (i==4 && (elem->point(0) > elem->point(1)))f=-1;
163               if (i==6 && (elem->point(1) > elem->point(2)))f=-1;
164               if (i==8 && (elem->point(2) > elem->point(0)))f=-1;
165 
166 
167               switch (i)
168                 {
169                   //nodal modes
170                 case 0: return l1;
171                 case 1: return l2;
172                 case 2: return l3;
173 
174                   //side modes
175                 case 3: return   l1*l2*(-4\&.*sqrt6);
176                 case 4: return f*l1*l2*(-4\&.*sqrt10)*(l2-l1);
177 
178                 case 5: return   l2*l3*(-4\&.*sqrt6);
179                 case 6: return f*l2*l3*(-4\&.*sqrt10)*(l3-l2);
180 
181                 case 7: return   l3*l1*(-4\&.*sqrt6);
182                 case 8: return f*l3*l1*(-4\&.*sqrt10)*(l1-l3);
183 
184                   //internal modes
185                 case 9: return l1*l2*l3;
186 
187                 default:
188                   libmesh_error();
189                 }
190             }
191 
192 
193             // Szabo-Babuska shape functions on the quadrilateral\&.
194           case QUAD8:
195           case QUAD9:
196             {
197               // Compute quad shape functions as a tensor-product
198               const Real xi  = p(0);
199               const Real eta = p(1);
200 
201               libmesh_assert_less (i, 16);
202 
203               //                                0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
204               static const unsigned int i0[] = {0,  1,  1,  0,  2,  3,  1,  1,  2,  3,  0,  0,  2,  3,  2,  3};
205               static const unsigned int i1[] = {0,  0,  1,  1,  0,  0,  2,  3,  1,  1,  2,  3,  2,  2,  3,  3};
206 
207               Real f=1\&.;
208 
209               // take care of edge orientation, this is needed at
210               // edge shapes with (y=0)-asymmetric 1D shapes, these have
211               // one 1D shape index being 0 or 1, the other one being odd and >=3
212 
213               switch(i)
214                 {
215                 case  5: // edge 0 points
216                   if (elem->point(0) > elem->point(1))f = -1\&.;
217                   break;
218                 case  7: // edge 1 points
219                   if (elem->point(1) > elem->point(2))f = -1\&.;
220                   break;
221                 case  9: // edge 2 points
222                   if (elem->point(3) > elem->point(2))f = -1\&.;
223                   break;
224                 case 11: // edge 3 points
225                   if (elem->point(0) > elem->point(3))f = -1\&.;
226                   break;
227                 }
228 
229               return f*(FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
230                         FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
231             }
232 
233           default:
234             libmesh_error();
235           }
236       }
237 
238 
239 
240 
241       // 4th-order Szabo-Babuska\&.
242     case FOURTH:
243       {
244         switch (type)
245           {
246             // Szabo-Babuska shape functions on the triangle\&.
247           case TRI6:
248             {
249               Real l1 = 1-p(0)-p(1);
250               Real l2 = p(0);
251               Real l3 = p(1);
252 
253               Real f=1;
254 
255               libmesh_assert_less (i, 15);
256 
257 
258               if (i== 4 && (elem->point(0) > elem->point(1)))f=-1;
259               if (i== 7 && (elem->point(1) > elem->point(2)))f=-1;
260               if (i==10 && (elem->point(2) > elem->point(0)))f=-1;
261 
262 
263               switch (i)
264                 {
265                   //nodal modes
266                 case  0: return l1;
267                 case  1: return l2;
268                 case  2: return l3;
269 
270                   //side modes
271                 case  3: return   l1*l2*(-4\&.*sqrt6);
272                 case  4: return f*l1*l2*(-4\&.*sqrt10)*(l2-l1);
273                 case  5: return   l1*l2*(-sqrt14)*(5\&.*pow<2>(l2-l1)-1);
274 
275                 case  6: return   l2*l3*(-4\&.*sqrt6);
276                 case  7: return f*l2*l3*(-4\&.*sqrt10)*(l3-l2);
277                 case  8: return   l2*l3*(-sqrt14)*(5\&.*pow<2>(l3-l2)-1);
278 
279                 case  9: return   l3*l1*(-4\&.*sqrt6);
280                 case 10: return f*l3*l1*(-4\&.*sqrt10)*(l1-l3);
281                 case 11: return   l3*l1*(-sqrt14)*(5\&.*pow<2>(l1-l3)-1);
282 
283                   //internal modes
284                 case 12: return l1*l2*l3;
285 
286                 case 13: return l1*l2*l3*(l2-l1);
287                 case 14: return l1*l2*l3*(2*l3-1);
288 
289                 default:
290                   libmesh_error();
291                 }
292             }
293 
294 
295             // Szabo-Babuska shape functions on the quadrilateral\&.
296           case QUAD8:
297           case QUAD9:
298             {
299               // Compute quad shape functions as a tensor-product
300               const Real xi  = p(0);
301               const Real eta = p(1);
302 
303               libmesh_assert_less (i, 25);
304 
305               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
306               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4};
307               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
308 
309               Real f=1\&.;
310 
311               switch(i)
312                 {
313                 case  5: // edge 0 points
314                   if (elem->point(0) > elem->point(1))f = -1\&.;
315                   break;
316                 case  8: // edge 1 points
317                   if (elem->point(1) > elem->point(2))f = -1\&.;
318                   break;
319                 case 11: // edge 2 points
320                   if (elem->point(3) > elem->point(2))f = -1\&.;
321                   break;
322                 case 14: // edge 3 points
323                   if (elem->point(0) > elem->point(3))f = -1\&.;
324                   break;
325                 }
326 
327               return f*(FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
328                         FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
329             }
330 
331           default:
332             libmesh_error();
333           }
334       }
335 
336 
337 
338 
339       // 5th-order Szabo-Babuska\&.
340     case FIFTH:
341       {
342         switch (type)
343           {
344             // Szabo-Babuska shape functions on the triangle\&.
345           case TRI6:
346             {
347               Real l1 = 1-p(0)-p(1);
348               Real l2 = p(0);
349               Real l3 = p(1);
350 
351               const Real x=l2-l1;
352               const Real y=2\&.*l3-1;
353 
354               Real f=1;
355 
356               libmesh_assert_less (i, 21);
357 
358 
359               if ((i== 4||i== 6) && (elem->point(0) > elem->point(1)))f=-1;
360               if ((i== 8||i==10) && (elem->point(1) > elem->point(2)))f=-1;
361               if ((i==12||i==14) && (elem->point(2) > elem->point(0)))f=-1;
362 
363 
364               switch (i)
365                 {
366                   //nodal modes
367                 case  0: return l1;
368                 case  1: return l2;
369                 case  2: return l3;
370 
371                   //side modes
372                 case  3: return   l1*l2*(-4\&.*sqrt6);
373                 case  4: return f*l1*l2*(-4\&.*sqrt10)*(l2-l1);
374                 case  5: return   -sqrt14*l1*l2*(5\&.0*l1*l1-1\&.0+(-10\&.0*l1+5\&.0*l2)*l2);
375                 case  6: return f*(-sqrt2)*l1*l2*((9\&.-21\&.*l1*l1)*l1+(-9\&.+63\&.*l1*l1+(-63\&.*l1+21\&.*l2)*l2)*l2);
376 
377                 case  7: return   l2*l3*(-4\&.*sqrt6);
378                 case  8: return f*l2*l3*(-4\&.*sqrt10)*(l3-l2);
379                 case  9: return   -sqrt14*l2*l3*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l2)*l2);
380                 case 10: return -f*sqrt2*l2*l3*((-9\&.0+21\&.0*l3*l3)*l3+(-63\&.0*l3*l3+9\&.0+(63\&.0*l3-21\&.0*l2)*l2)*l2);
381 
382                 case 11: return   l3*l1*(-4\&.*sqrt6);
383                 case 12: return f*l3*l1*(-4\&.*sqrt10)*(l1-l3);
384                 case 13: return -sqrt14*l3*l1*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l1)*l1);
385                 case 14: return f*(-sqrt2)*l3*l1*((9\&.0-21\&.0*l3*l3)*l3+(-9\&.0+63\&.0*l3*l3+(-63\&.0*l3+21\&.0*l1)*l1)*l1);
386 
387                   //internal modes
388                 case 15: return l1*l2*l3;
389 
390                 case 16: return l1*l2*l3*x;
391                 case 17: return l1*l2*l3*y;
392 
393                 case 18: return l1*l2*l3*(1\&.5*l1*l1-\&.5+(-3\&.0*l1+1\&.5*l2)*l2);
394                 case 19: return l1*l2*l3*x*y;
395                 case 20: return l1*l2*l3*(1\&.0+(-6\&.0+6\&.0*l3)*l3);
396 
397                 default:
398                   libmesh_error();
399                 }
400             } // case TRI6
401 
402             // Szabo-Babuska shape functions on the quadrilateral\&.
403           case QUAD8:
404           case QUAD9:
405             {
406               // Compute quad shape functions as a tensor-product
407               const Real xi  = p(0);
408               const Real eta = p(1);
409 
410               libmesh_assert_less (i, 36);
411 
412               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
413               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
414               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
415 
416               Real f=1\&.;
417 
418               switch(i)
419                 {
420                 case  5: // edge 0 points
421                 case  7:
422                   if (elem->point(0) > elem->point(1))f = -1\&.;
423                   break;
424                 case  9: // edge 1 points
425                 case 11:
426                   if (elem->point(1) > elem->point(2))f = -1\&.;
427                   break;
428                 case 13: // edge 2 points
429                 case 15:
430                   if (elem->point(3) > elem->point(2))f = -1\&.;
431                   break;
432                 case 14: // edge 3 points
433                 case 19:
434                   if (elem->point(0) > elem->point(3))f = -1\&.;
435                   break;
436                 }
437 
438               return f*(FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
439                         FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
440 
441             } // case QUAD8/QUAD9
442 
443           default:
444             libmesh_error();
445 
446           } // switch type
447 
448       } // case FIFTH
449 
450       // 6th-order Szabo-Babuska\&.
451     case SIXTH:
452       {
453         switch (type)
454           {
455             // Szabo-Babuska shape functions on the triangle\&.
456           case TRI6:
457             {
458               Real l1 = 1-p(0)-p(1);
459               Real l2 = p(0);
460               Real l3 = p(1);
461 
462               const Real x=l2-l1;
463               const Real y=2\&.*l3-1;
464 
465               Real f=1;
466 
467               libmesh_assert_less (i, 28);
468 
469 
470               if ((i== 4||i== 6) && (elem->point(0) > elem->point(1)))f=-1;
471               if ((i== 9||i==11) && (elem->point(1) > elem->point(2)))f=-1;
472               if ((i==14||i==16) && (elem->point(2) > elem->point(0)))f=-1;
473 
474 
475               switch (i)
476                 {
477                   //nodal modes
478                 case  0: return l1;
479                 case  1: return l2;
480                 case  2: return l3;
481 
482                   //side modes
483                 case  3: return   l1*l2*(-4\&.*sqrt6);
484                 case  4: return f*l1*l2*(-4\&.*sqrt10)*(l2-l1);
485                 case  5: return   -sqrt14*l1*l2*(5\&.0*l1*l1-1\&.0+(-10\&.0*l1+5\&.0*l2)*l2);
486                 case  6: return f*(-sqrt2)*l1*l2*((9\&.0-21\&.0*l1*l1)*l1+(-9\&.0+63\&.0*l1*l1+(-63\&.0*l1+21\&.0*l2)*l2)*l2);
487                 case  7: return   -sqrt22*l1*l2*(0\&.5+(-7\&.0+0\&.105E2*l1*l1)*l1*l1+((14\&.0-0\&.42E2*l1*l1)*l1+(-7\&.0+0\&.63E2*l1*l1+(-0\&.42E2*l1+0\&.105E2*l2)*l2)*l2)*l2);
488 
489                 case  8: return   l2*l3*(-4\&.*sqrt6);
490                 case  9: return f*l2*l3*(-4\&.*sqrt10)*(l3-l2);
491                 case 10: return   -sqrt14*l2*l3*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l2)*l2);
492                 case 11: return f*(-sqrt2)*l2*l3*((-9\&.0+21\&.0*l3*l3)*l3+(-63\&.0*l3*l3+9\&.0+(63\&.0*l3-21\&.0*l2)*l2)*l2);
493                 case 12: return   -sqrt22*l2*l3*(0\&.5+(-7\&.0+0\&.105E2*l3*l3)*l3*l3+((14\&.0-0\&.42E2*l3*l3)*l3+(-7\&.0+0\&.63E2*l3*l3+(-0\&.42E2*l3+0\&.105E2*l2)*l2)*l2)*l2);
494 
495                 case 13: return   l3*l1*(-4\&.*sqrt6);
496                 case 14: return f*l3*l1*(-4\&.*sqrt10)*(l1-l3);
497                 case 15: return   -sqrt14*l3*l1*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l1)*l1);
498                 case 16: return f*(-sqrt2)*l3*l1*((9\&.0-21\&.0*l3*l3)*l3+(-9\&.0+63\&.0*l3*l3+(-63\&.0*l3+21\&.0*l1)*l1)*l1);
499                 case 17: return   -sqrt22*l3*l1*(0\&.5+(-7\&.0+0\&.105E2*l3*l3)*l3*l3+((14\&.0-0\&.42E2*l3*l3)*l3+(-7\&.0+0\&.63E2*l3*l3+(-0\&.42E2*l3+0\&.105E2*l1)*l1)*l1)*l1);
500 
501 
502 
503                   //internal modes
504                 case 18: return l1*l2*l3;
505 
506                 case 19: return l1*l2*l3*x;
507                 case 20: return l1*l2*l3*y;
508 
509                 case 21: return 0\&.5*l1*l2*l3*(3\&.0*l1*l1-1\&.0+(-6\&.0*l1+3\&.0*l2)*l2);
510                 case 22: return l1*l2*l3*(l2-l1)*(2\&.0*l3-1\&.0);
511                 case 23: return 0\&.5*l1*l2*l3*(2\&.0+(-12\&.0+12\&.0*l3)*l3);
512                 case 24: return 0\&.5*l1*l2*l3*((3\&.0-5\&.0*l1*l1)*l1+(-3\&.0+15\&.0*l1*l1+(-15\&.0*l1+5\&.0*l2)*l2)*l2);
513                 case 25: return 0\&.5*l1*l2*l3*(3\&.0*l1*l1-1\&.0+(-6\&.0*l1+3\&.0*l2)*l2)*(2\&.0*l3-1\&.0);
514                 case 26: return 0\&.5*l1*l2*l3*(2\&.0+(-12\&.0+12\&.0*l3)*l3)*(l2-l1);
515                 case 27: return 0\&.5*l1*l2*l3*(-2\&.0+(24\&.0+(-60\&.0+40\&.0*l3)*l3)*l3);
516 
517 
518                 default:
519                   libmesh_error();
520                 }
521             } // case TRI6
522 
523             // Szabo-Babuska shape functions on the quadrilateral\&.
524           case QUAD8:
525           case QUAD9:
526             {
527               // Compute quad shape functions as a tensor-product
528               const Real xi  = p(0);
529               const Real eta = p(1);
530 
531               libmesh_assert_less (i, 49);
532 
533               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
534               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6};
535               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6};
536 
537               Real f=1\&.;
538 
539               switch(i)
540                 {
541                 case  5: // edge 0 points
542                 case  7:
543                   if (elem->point(0) > elem->point(1))f = -1\&.;
544                   break;
545                 case 10: // edge 1 points
546                 case 12:
547                   if (elem->point(1) > elem->point(2))f = -1\&.;
548                   break;
549                 case 15: // edge 2 points
550                 case 17:
551                   if (elem->point(3) > elem->point(2))f = -1\&.;
552                   break;
553                 case 20: // edge 3 points
554                 case 22:
555                   if (elem->point(0) > elem->point(3))f = -1\&.;
556                   break;
557                 }
558 
559               return f*(FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
560                         FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
561 
562             } // case QUAD8/QUAD9
563 
564           default:
565             libmesh_error();
566 
567           } // switch type
568 
569       } // case SIXTH
570 
571 
572       // 7th-order Szabo-Babuska\&.
573     case SEVENTH:
574       {
575         switch (type)
576           {
577             // Szabo-Babuska shape functions on the triangle\&.
578           case TRI6:
579             {
580 
581               Real l1 = 1-p(0)-p(1);
582               Real l2 = p(0);
583               Real l3 = p(1);
584 
585               const Real x=l2-l1;
586               const Real y=2\&.*l3-1\&.;
587 
588               Real f=1;
589 
590               libmesh_assert_less (i, 36);
591 
592 
593               if ((i>= 4&&i<= 8) && (elem->point(0) > elem->point(1)))f=-1;
594               if ((i>=10&&i<=14) && (elem->point(1) > elem->point(2)))f=-1;
595               if ((i>=16&&i<=20) && (elem->point(2) > elem->point(0)))f=-1;
596 
597 
598               switch (i)
599                 {
600                   //nodal modes
601                 case  0: return l1;
602                 case  1: return l2;
603                 case  2: return l3;
604 
605                   //side modes
606                 case  3: return   l1*l2*(-4\&.*sqrt6);
607                 case  4: return f*l1*l2*(-4\&.*sqrt10)*(l2-l1);
608 
609                 case  5: return   -sqrt14*l1*l2*(5\&.0*l1*l1-1\&.0+(-10\&.0*l1+5\&.0*l2)*l2);
610                 case  6: return f*-sqrt2*l1*l2*((9\&.0-21\&.0*l1*l1)*l1+(-9\&.0+63\&.0*l1*l1+(-63\&.0*l1+21\&.0*l2)*l2)*l2);
611                 case  7: return   -sqrt22*l1*l2*(0\&.5+(-7\&.0+0\&.105E2*l1*l1)*l1*l1+((14\&.0-0\&.42E2*l1*l1)*l1+(-7\&.0+0\&.63E2*l1*l1+(-0\&.42E2*l1+0\&.105E2*l2)*l2)*l2)*l2);
612                 case  8: return f*-sqrt26*l1*l2*((-0\&.25E1+(15\&.0-0\&.165E2*l1*l1)*l1*l1)*l1+(0\&.25E1+(-45\&.0+0\&.825E2*l1*l1)*l1*l1+((45\&.0-0\&.165E3*l1*l1)*l1+(-15\&.0+0\&.165E3*l1*l1+(-0\&.825E2*l1+0\&.165E2*l2)*l2)*l2)*l2)*l2);
613 
614                 case  9: return   l2*l3*(-4\&.*sqrt6);
615                 case 10: return f*l2*l3*(-4\&.*sqrt10)*(l3-l2);
616 
617                 case 11: return   -sqrt14*l2*l3*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l2)*l2);
618                 case 12: return f*-sqrt2*l2*l3*((-9\&.0+21\&.0*l3*l3)*l3+(-63\&.0*l3*l3+9\&.0+(63\&.0*l3-21\&.0*l2)*l2)*l2);
619                 case 13: return   -sqrt22*l2*l3*(0\&.5+(-7\&.0+0\&.105E2*l3*l3)*l3*l3+((14\&.0-0\&.42E2*l3*l3)*l3+(-7\&.0+0\&.63E2*l3*l3+(-0\&.42E2*l3+0\&.105E2*l2)*l2)*l2)*l2);
620                 case 14: return f*-sqrt26*l2*l3*((0\&.25E1+(-15\&.0+0\&.165E2*l3*l3)*l3*l3)*l3+(-0\&.25E1+(45\&.0-0\&.825E2*l3*l3)*l3*l3+((-45\&.0+0\&.165E3*l3*l3)*l3+(15\&.0-0\&.165E3*l3*l3+(0\&.825E2*l3-0\&.165E2*l2)*l2)*l2)*l2)*l2);
621 
622                 case 15: return   l3*l1*(-4\&.*sqrt6);
623                 case 16: return f*l3*l1*(-4\&.*sqrt10)*(l1-l3);
624 
625                 case 17: return   -sqrt14*l3*l1*(5\&.0*l3*l3-1\&.0+(-10\&.0*l3+5\&.0*l1)*l1);
626                 case 18: return -f*sqrt2*l3*l1*((9\&.-21\&.*l3*l3)*l3+(-9\&.+63\&.*l3*l3+(-63\&.*l3+21\&.*l1)*l1)*l1);
627                 case 19: return   -sqrt22*l3*l1*(0\&.5+(-7\&.0+0\&.105E2*l3*l3)*l3*l3+((14\&.0-0\&.42E2*l3*l3)*l3+(-7\&.0+0\&.63E2*l3*l3+(-0\&.42E2*l3+0\&.105E2*l1)*l1)*l1)*l1);
628                 case 20: return f*-sqrt26*l3*l1*((-0\&.25E1+(15\&.0-0\&.165E2*l3*l3)*l3*l3)*l3+(0\&.25E1+(-45\&.0+0\&.825E2*l3*l3)*l3*l3+((45\&.0-0\&.165E3*l3*l3)*l3+(-15\&.0+0\&.165E3*l3*l3+(-0\&.825E2*l3+0\&.165E2*l1)*l1)*l1)*l1)*l1);
629 
630 
631                   //internal modes
632                 case 21: return l1*l2*l3;
633 
634                 case 22: return l1*l2*l3*x;
635                 case 23: return l1*l2*l3*y;
636 
637                 case 24: return l1*l2*l3*0\&.5*(3\&.*pow<2>(x)-1\&.);
638                 case 25: return l1*l2*l3*x*y;
639                 case 26: return l1*l2*l3*0\&.5*(3\&.*pow<2>(y)-1\&.);
640 
641                 case 27: return 0\&.5*l1*l2*l3*((3\&.0-5\&.0*l1*l1)*l1+(-3\&.0+15\&.0*l1*l1+(-15\&.0*l1+5\&.0*l2)*l2)*l2);
642                 case 28: return 0\&.5*l1*l2*l3*(3\&.0*l1*l1-1\&.0+(-6\&.0*l1+3\&.0*l2)*l2)*(2\&.0*l3-1\&.0);
643                 case 29: return 0\&.5*l1*l2*l3*(2\&.0+(-12\&.0+12\&.0*l3)*l3)*(l2-l1);
644                 case 30: return 0\&.5*l1*l2*l3*(-2\&.0+(24\&.0+(-60\&.0+40\&.0*l3)*l3)*l3);
645                 case 31: return 0\&.125*l1*l2*l3*((-15\&.0+(70\&.0-63\&.0*l1*l1)*l1*l1)*l1+(15\&.0+(-210\&.0+315\&.0*l1*l1)*l1*l1+((210\&.0-630\&.0*l1*l1)*l1+(-70\&.0+630\&.0*l1*l1+(-315\&.0*l1+63\&.0*l2)*l2)*l2)*l2)*l2);
646                 case 32: return 0\&.5*l1*l2*l3*((3\&.0-5\&.0*l1*l1)*l1+(-3\&.0+15\&.0*l1*l1+(-15\&.0*l1+5\&.0*l2)*l2)*l2)*(2\&.0*l3-1\&.0);
647                 case 33: return 0\&.25*l1*l2*l3*(3\&.0*l1*l1-1\&.0+(-6\&.0*l1+3\&.0*l2)*l2)*(2\&.0+(-12\&.0+12\&.0*l3)*l3);
648                 case 34: return 0\&.5*l1*l2*l3*(-2\&.0+(24\&.0+(-60\&.0+40\&.0*l3)*l3)*l3)*(l2-l1);
649                 case 35: return 0\&.125*l1*l2*l3*(-8\&.0+(240\&.0+(-1680\&.0+(4480\&.0+(-5040\&.0+2016\&.0*l3)*l3)*l3)*l3)*l3);
650 
651                 default:
652                   libmesh_error();
653                 }
654             } // case TRI6
655 
656             // Szabo-Babuska shape functions on the quadrilateral\&.
657           case QUAD8:
658           case QUAD9:
659             {
660               // Compute quad shape functions as a tensor-product
661               const Real xi  = p(0);
662               const Real eta = p(1);
663 
664               libmesh_assert_less (i, 64);
665 
666               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
667               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7};
668               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7};
669 
670               Real f=1\&.;
671 
672               switch(i)
673                 {
674                 case  5: // edge 0 points
675                 case  7:
676                 case  9:
677                   if (elem->point(0) > elem->point(1))f = -1\&.;
678                   break;
679                 case 11: // edge 1 points
680                 case 13:
681                 case 15:
682                   if (elem->point(1) > elem->point(2))f = -1\&.;
683                   break;
684                 case 17: // edge 2 points
685                 case 19:
686                 case 21:
687                   if (elem->point(3) > elem->point(2))f = -1\&.;
688                   break;
689                 case 23: // edge 3 points
690                 case 25:
691                 case 27:
692                   if (elem->point(0) > elem->point(3))f = -1\&.;
693                   break;
694                 }
695 
696               return f*(FE<1,SZABAB>::shape(EDGE3, totalorder, i0[i], xi)*
697                         FE<1,SZABAB>::shape(EDGE3, totalorder, i1[i], eta));
698 
699             } // case QUAD8/QUAD9
700 
701           default:
702             libmesh_error();
703 
704           } // switch type
705 
706       } // case SEVENTH
707 
708 
709       // by default throw an error
710     default:
711       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
712       libmesh_error();
713 
714     } // switch order
715 
716   libmesh_error();
717   return 0\&.;
718 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 73 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
77 {
78   libmesh_assert(elem);
79 
80   return FE<1,MONOMIAL>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
81 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 90 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
94 {
95   libmesh_assert(elem);
96 
97   return FE<1,SZABAB>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
98 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 101 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
105 {
106   libmesh_assert(elem);
107 
108   return FE<1,L2_HIERARCHIC>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
109 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 101 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
105 {
106   libmesh_assert(elem);
107 
108   return FE<1,HIERARCHIC>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
109 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::FEXYZ< Dim >::compute_face_values(), libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FESubdivision::init_shape_functions(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::FE< Dim, T >::map(), libMesh::FE< Dim, T >::shape(), and libMesh::FE< Dim, T >::shape_deriv()\&.
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 119 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
123 {
124   libmesh_assert(elem);
125 
126   // by default call the orientation-independent shape functions
127   return FE<2,MONOMIAL>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
128 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 127 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
131 {
132   libmesh_assert(elem);
133 
134   return FE<1,L2_LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
135 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 127 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
131 {
132   libmesh_assert(elem);
133 
134   return FE<1,LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
135 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 181 of file fe_clough_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
185 {
186   libMesh::err << "Clough-Tocher elements require the real element\n"
187                << "to construct gradient-based degrees of freedom\&."
188                << std::endl;
189 
190   libmesh_error();
191   return 0\&.;
192 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 187 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
191 {
192   libMesh::err << "Hermite elements require the real element\n"
193                << "to construct gradient-based degrees of freedom\&."
194                << std::endl;
195 
196   libmesh_error();
197   return 0\&.;
198 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 187 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
191 {
192   libmesh_assert(elem);
193 
194   // call the orientation-independent shape functions
195   return FE<3,MONOMIAL>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
196 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 188 of file fe_hermite_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
192 {
193   libMesh::err << "Hermite elements require the real element\n"
194                << "to construct gradient-based degrees of freedom\&."
195                << std::endl;
196 
197   libmesh_error();
198   return 0\&.;
199 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 197 of file fe_clough_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
201 {
202   libmesh_assert(elem);
203 
204   clough_compute_coefs(elem);
205 
206   const ElemType type = elem->type();
207 
208   const Order totalorder = static_cast<Order>(order + elem->p_level());
209 
210   switch (totalorder)
211     {
212       // 3rd-order C1 cubic element
213     case THIRD:
214       {
215         switch (type)
216           {
217             // C1 functions on the C1 cubic edge
218           case EDGE2:
219           case EDGE3:
220             {
221               libmesh_assert_less (i, 4);
222 
223               switch (i)
224                 {
225                 case 0:
226                   return clough_raw_shape(0, p);
227                 case 1:
228                   return clough_raw_shape(1, p);
229                 case 2:
230                   return d1xd1x * clough_raw_shape(2, p);
231                 case 3:
232                   return d2xd2x * clough_raw_shape(3, p);
233                 default:
234                   libmesh_error();
235                 }
236             }
237           default:
238             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
239             libmesh_error();
240           }
241       }
242       // by default throw an error
243     default:
244       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
245       libmesh_error();
246     }
247 
248   libmesh_error();
249   return 0\&.;
250 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 201 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
205 {
206   libmesh_assert(elem);
207 
208   return FE<1,BERNSTEIN>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
209 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 203 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
207 {
208   libmesh_assert(elem);
209 
210   // Coefficient naming: d(1)d(2n) is the coefficient of the
211   // global shape function corresponding to value 1 in terms of the
212   // local shape function corresponding to normal derivative 2
213   Real d1xd1x, d2xd2x;
214 
215   hermite_compute_coefs(elem, d1xd1x, d2xd2x);
216 
217   const ElemType type = elem->type();
218 
219   const Order totalorder = static_cast<Order>(order + elem->p_level());
220 
221   switch (totalorder)
222     {
223       // Hermite cubic shape functions
224     case THIRD:
225       {
226         switch (type)
227           {
228             // C1 functions on the C1 cubic edge
229           case EDGE2:
230           case EDGE3:
231             {
232               libmesh_assert_less (i, 4);
233 
234               switch (i)
235                 {
236                 case 0:
237                   return FEHermite<1>::hermite_raw_shape(0, p(0));
238                 case 1:
239                   return d1xd1x * FEHermite<1>::hermite_raw_shape(2, p(0));
240                 case 2:
241                   return FEHermite<1>::hermite_raw_shape(1, p(0));
242                 case 3:
243                   return d2xd2x * FEHermite<1>::hermite_raw_shape(3, p(0));
244                 default:
245                   return FEHermite<1>::hermite_raw_shape(i, p(0));
246                 }
247             }
248           default:
249             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
250             libmesh_error();
251           }
252       }
253       // by default throw an error
254     default:
255       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
256       libmesh_error();
257     }
258 
259   libmesh_error();
260   return 0\&.;
261 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 204 of file fe_hermite_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, and libMesh::Elem::type()\&.
.PP
.nf
208 {
209   libmesh_assert(elem);
210 
211   std::vector<std::vector<Real> > dxdxi(2, std::vector<Real>(2, 0));
212 
213 #ifdef DEBUG
214   std::vector<Real> dxdeta(2), dydxi(2);
215 #endif
216 
217   hermite_compute_coefs(elem,dxdxi
218 #ifdef DEBUG
219                         ,dxdeta,dydxi
220 #endif
221                         );
222 
223   const ElemType type = elem->type();
224 
225   const Order totalorder = static_cast<Order>(order + elem->p_level());
226 
227   switch (type)
228     {
229     case QUAD4:
230       libmesh_assert_less (totalorder, 4);
231     case QUAD8:
232     case QUAD9:
233       {
234         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
235 
236         std::vector<unsigned int> bases1D;
237 
238         Real coef = hermite_bases_2D(bases1D, dxdxi, totalorder, i);
239 
240         return coef * FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
241           FEHermite<1>::hermite_raw_shape(bases1D[1],p(1));
242       }
243     default:
244       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
245       libmesh_error();
246     }
247 
248   libmesh_error();
249   return 0\&.;
250 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 221 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
225 {
226   libmesh_assert(elem);
227 
228   // call the orientation-independent shape functions
229   return FE<2,LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
230 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 222 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
226 {
227   libmesh_assert(elem);
228 
229   // call the orientation-independent shape functions
230   return FE<2,L2_LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
231 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 369 of file fe_hermite_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
373 {
374   libMesh::err << "Hermite elements require the real element\n"
375                << "to construct gradient-based degrees of freedom\&."
376                << std::endl;
377 
378   libmesh_error();
379   return 0\&.;
380 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 371 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
375 {
376   libmesh_assert(elem);
377 
378   // call the orientation-independent shape functions
379   return FE<3,L2_LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
380 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 385 of file fe_hermite_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
389 {
390   libmesh_assert(elem);
391 
392   std::vector<std::vector<Real> > dxdxi(3, std::vector<Real>(2, 0));
393 
394 #ifdef DEBUG
395   std::vector<Real> dydxi(2), dzdeta(2), dxdzeta(2);
396   std::vector<Real> dzdxi(2), dxdeta(2), dydzeta(2);
397 #endif //DEBUG
398 
399   hermite_compute_coefs(elem, dxdxi
400 #ifdef DEBUG
401                         , dydxi, dzdeta, dxdzeta, dzdxi, dxdeta, dydzeta
402 #endif
403                         );
404 
405   const ElemType type = elem->type();
406 
407   const Order totalorder = static_cast<Order>(order + elem->p_level());
408 
409   switch (totalorder)
410     {
411       // 3rd-order tricubic Hermite functions
412     case THIRD:
413       {
414         switch (type)
415           {
416           case HEX8:
417           case HEX20:
418           case HEX27:
419             {
420               libmesh_assert_less (i, 64);
421 
422               std::vector<unsigned int> bases1D;
423 
424               Real coef = hermite_bases_3D(bases1D, dxdxi, totalorder, i);
425 
426               return coef *
427                 FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
428                 FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
429                 FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
430             }
431           default:
432             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
433             libmesh_error();
434           }
435       }
436       // by default throw an error
437     default:
438       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
439       libmesh_error();
440     }
441 
442   libmesh_error();
443   return 0\&.;
444 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 538 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape()\&.
.PP
.nf
540 {
541   Real value = FE<0,LAGRANGE>::shape( type, order, i, p );
542   return libMesh::RealGradient( value );
543 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"
Subdivision finite elements\&. 
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 560 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape()\&.
.PP
.nf
562 {
563   Real value = FE<1,LAGRANGE>::shape( type, order, i, p );
564   return libMesh::RealGradient( value );
565 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 571 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
575 {
576   libmesh_assert(elem);
577 
578   // call the orientation-independent shape functions
579   return FE<3,LAGRANGE>::shape(elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
580 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 582 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape()\&.
.PP
.nf
584 {
585   Real value = FE<2,LAGRANGE>::shape( type, order, i/2, p );
586 
587   switch( i%2 )
588     {
589     case 0:
590       return libMesh::RealGradient( value );
591 
592     case 1:
593       return libMesh::RealGradient( Real(0), value );
594 
595     default:
596       libmesh_error();
597     }
598 
599   //dummy
600   return libMesh::RealGradient();
601 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 595 of file fe_nedelec_one\&.C\&.
.PP
.nf
596 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 598 of file fe_nedelec_one\&.C\&.
.PP
.nf
599 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 618 of file fe_nedelec_one\&.C\&.
.PP
.nf
619 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 621 of file fe_nedelec_one\&.C\&.
.PP
.nf
622 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 645 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
649 {
650   libMesh::err << "Hierarchic polynomials require the element type\n"
651                << "because edge and face orientation is needed\&."
652                << std::endl;
653 
654   libmesh_error();
655   return 0\&.;
656 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 645 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
649 {
650   libMesh::err << "Hierarchic polynomials require the element type\n"
651                << "because edge and face orientation is needed\&."
652                << std::endl;
653 
654   libmesh_error();
655   return 0\&.;
656 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 647 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape()\&.
.PP
.nf
649 {
650   Real value = FE<3,LAGRANGE>::shape( type, order, i/3, p );
651 
652   switch( i%3 )
653     {
654     case 0:
655       return libMesh::RealGradient( value );
656 
657     case 1:
658       return libMesh::RealGradient( Real(0), value );
659 
660     case 2:
661       return libMesh::RealGradient( Real(0), Real(0), value );
662 
663     default:
664       libmesh_error();
665     }
666 
667   //dummy
668   return libMesh::RealGradient();
669 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 661 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, and libMesh::Elem::type()\&.
.PP
.nf
665 {
666 #if LIBMESH_DIM == 3
667 
668   libmesh_assert(elem);
669   const ElemType type = elem->type();
670 
671   const Order totalorder = static_cast<Order>(order+elem->p_level());
672 
673   switch (type)
674     {
675     case HEX8:
676     case HEX20:
677       libmesh_assert_less (totalorder, 2);
678     case HEX27:
679       {
680         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u)*(totalorder+1u));
681 
682         // Compute hex shape functions as a tensor-product
683         Real xi   = p(0);
684         Real eta  = p(1);
685         Real zeta = p(2);
686 
687         unsigned int i0, i1, i2;
688 
689         cube_indices(elem, totalorder, i, xi, eta, zeta, i0, i1, i2);
690 
691         return (FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder, i0, xi)*
692                 FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder, i1, eta)*
693                 FE<1,L2_HIERARCHIC>::shape(EDGE3, totalorder, i2, zeta));
694       }
695 
696     default:
697       libmesh_error();
698     }
699 
700 #endif
701 
702   libmesh_error();
703   return 0\&.;
704 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 661 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, and libMesh::Elem::type()\&.
.PP
.nf
665 {
666 #if LIBMESH_DIM == 3
667 
668   libmesh_assert(elem);
669   const ElemType type = elem->type();
670 
671   const Order totalorder = static_cast<Order>(order+elem->p_level());
672 
673   switch (type)
674     {
675     case HEX8:
676     case HEX20:
677       libmesh_assert_less (totalorder, 2);
678     case HEX27:
679       {
680         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u)*(totalorder+1u));
681 
682         // Compute hex shape functions as a tensor-product
683         Real xi   = p(0);
684         Real eta  = p(1);
685         Real zeta = p(2);
686 
687         unsigned int i0, i1, i2;
688 
689         cube_indices(elem, totalorder, i, xi, eta, zeta, i0, i1, i2);
690 
691         return (FE<1,HIERARCHIC>::shape(EDGE3, totalorder, i0, xi)*
692                 FE<1,HIERARCHIC>::shape(EDGE3, totalorder, i1, eta)*
693                 FE<1,HIERARCHIC>::shape(EDGE3, totalorder, i2, zeta));
694       }
695 
696     default:
697       libmesh_error();
698     }
699 
700 #endif
701 
702   libmesh_error();
703   return 0\&.;
704 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 720 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FOURTH, and libMesh::TRI3SUBDIVISION\&.
.PP
.nf
724 {
725   switch (order)
726     {
727     case FOURTH:
728       {
729         switch (type)
730           {
731           case TRI3SUBDIVISION:
732             libmesh_assert_less(i, 12);
733             return FESubdivision::regular_shape(i,p(0),p(1));
734           default:
735             std::cerr << "ERROR: Unsupported element type!" << std::endl;
736             libmesh_error();
737           }
738       }
739     default:
740       std::cerr << "ERROR: Unsupported polynomial order!" << std::endl;
741       libmesh_error();
742     }
743 
744   libmesh_error();
745   return 0\&.;
746 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 722 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
724 {
725   Real value = FE<0,LAGRANGE>::shape( elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
726   return libMesh::RealGradient( value );
727 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 744 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
746 {
747   Real value = FE<1,LAGRANGE>::shape( elem->type(), static_cast<Order>(order + elem->p_level()), i, p);
748   return libMesh::RealGradient( value );
749 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 751 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), and libMesh::Elem::type()\&.
.PP
.nf
755 {
756   libmesh_assert(elem);
757   return FE<2,SUBDIVISION>::shape(elem->type(), order, i, p);
758 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 766 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
768 {
769   Real value = FE<2,LAGRANGE>::shape( elem->type(), static_cast<Order>(order + elem->p_level()), i/2, p );
770 
771   switch( i%2 )
772     {
773     case 0:
774       return libMesh::RealGradient( value );
775 
776     case 1:
777       return libMesh::RealGradient( Real(0), value );
778 
779     default:
780       libmesh_error();
781     }
782 
783   //dummy
784   return libMesh::RealGradient();
785 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 830 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape(), and libMesh::Elem::type()\&.
.PP
.nf
832 {
833   Real value = FE<3,LAGRANGE>::shape( elem->type(), static_cast<Order>(order + elem->p_level()), i/3, p );
834 
835   switch( i%3 )
836     {
837     case 0:
838       return libMesh::RealGradient( value );
839 
840     case 1:
841       return libMesh::RealGradient( Real(0), value );
842 
843     case 2:
844       return libMesh::RealGradient( Real(0), Real(0), value );
845 
846     default:
847       libmesh_error();
848     }
849 
850   //dummy
851   return libMesh::RealGradient();
852 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shape (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1443 of file fe_clough_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1447 {
1448   libMesh::err << "Clough-Tocher elements require the real element\n"
1449                << "to construct gradient-based degrees of freedom\&."
1450                << std::endl;
1451 
1452   libmesh_error();
1453   return 0\&.;
1454 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shape (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const \fBPoint\fP &p)"

.PP
Definition at line 1459 of file fe_clough_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::SECOND, libMesh::THIRD, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
1463 {
1464   libmesh_assert(elem);
1465 
1466   clough_compute_coefs(elem);
1467 
1468   const ElemType type = elem->type();
1469 
1470   const Order totalorder = static_cast<Order>(order + elem->p_level());
1471 
1472   switch (totalorder)
1473     {
1474       // 2nd-order restricted Clough-Tocher element
1475     case SECOND:
1476       {
1477         // There may be a bug in the 2nd order case; the 3rd order
1478         // Clough-Tocher elements are pretty uniformly better anyways
1479         // so use those instead\&.
1480         libmesh_experimental();
1481         switch (type)
1482           {
1483             // C1 functions on the Clough-Tocher triangle\&.
1484           case TRI6:
1485             {
1486               libmesh_assert_less (i, 9);
1487               // FIXME: it would be nice to calculate (and cache)
1488               // clough_raw_shape(j,p) only once per triangle, not 1-7
1489               // times
1490               switch (i)
1491                 {
1492                   // Note: these DoF numbers are "scrambled" because my
1493                   // initial numbering conventions didn't match libMesh
1494                 case 0:
1495                   return clough_raw_shape(0, p)
1496                     + d1d2n * clough_raw_shape(10, p)
1497                     + d1d3n * clough_raw_shape(11, p);
1498                 case 3:
1499                   return clough_raw_shape(1, p)
1500                     + d2d3n * clough_raw_shape(11, p)
1501                     + d2d1n * clough_raw_shape(9, p);
1502                 case 6:
1503                   return clough_raw_shape(2, p)
1504                     + d3d1n * clough_raw_shape(9, p)
1505                     + d3d2n * clough_raw_shape(10, p);
1506                 case 1:
1507                   return d1xd1x * clough_raw_shape(3, p)
1508                     + d1xd1y * clough_raw_shape(4, p)
1509                     + d1xd2n * clough_raw_shape(10, p)
1510                     + d1xd3n * clough_raw_shape(11, p)
1511                     + 0\&.5 * N01x * d3nd3n * clough_raw_shape(11, p)
1512                     + 0\&.5 * N02x * d2nd2n * clough_raw_shape(10, p);
1513                 case 2:
1514                   return d1yd1y * clough_raw_shape(4, p)
1515                     + d1yd1x * clough_raw_shape(3, p)
1516                     + d1yd2n * clough_raw_shape(10, p)
1517                     + d1yd3n * clough_raw_shape(11, p)
1518                     + 0\&.5 * N01y * d3nd3n * clough_raw_shape(11, p)
1519                     + 0\&.5 * N02y * d2nd2n * clough_raw_shape(10, p);
1520                 case 4:
1521                   return d2xd2x * clough_raw_shape(5, p)
1522                     + d2xd2y * clough_raw_shape(6, p)
1523                     + d2xd3n * clough_raw_shape(11, p)
1524                     + d2xd1n * clough_raw_shape(9, p)
1525                     + 0\&.5 * N10x * d3nd3n * clough_raw_shape(11, p)
1526                     + 0\&.5 * N12x * d1nd1n * clough_raw_shape(9, p);
1527                 case 5:
1528                   return d2yd2y * clough_raw_shape(6, p)
1529                     + d2yd2x * clough_raw_shape(5, p)
1530                     + d2yd3n * clough_raw_shape(11, p)
1531                     + d2yd1n * clough_raw_shape(9, p)
1532                     + 0\&.5 * N10y * d3nd3n * clough_raw_shape(11, p)
1533                     + 0\&.5 * N12y * d1nd1n * clough_raw_shape(9, p);
1534                 case 7:
1535                   return d3xd3x * clough_raw_shape(7, p)
1536                     + d3xd3y * clough_raw_shape(8, p)
1537                     + d3xd1n * clough_raw_shape(9, p)
1538                     + d3xd2n * clough_raw_shape(10, p)
1539                     + 0\&.5 * N20x * d2nd2n * clough_raw_shape(10, p)
1540                     + 0\&.5 * N21x * d1nd1n * clough_raw_shape(9, p);
1541                 case 8:
1542                   return d3yd3y * clough_raw_shape(8, p)
1543                     + d3yd3x * clough_raw_shape(7, p)
1544                     + d3yd1n * clough_raw_shape(9, p)
1545                     + d3yd2n * clough_raw_shape(10, p)
1546                     + 0\&.5 * N20y * d2nd2n * clough_raw_shape(10, p)
1547                     + 0\&.5 * N21y * d1nd1n * clough_raw_shape(9, p);
1548                 default:
1549                   libmesh_error();
1550                 }
1551             }
1552           default:
1553             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1554             libmesh_error();
1555           }
1556       }
1557       // 3rd-order Clough-Tocher element
1558     case THIRD:
1559       {
1560         switch (type)
1561           {
1562             // C1 functions on the Clough-Tocher triangle\&.
1563           case TRI6:
1564             {
1565               libmesh_assert_less (i, 12);
1566 
1567               // FIXME: it would be nice to calculate (and cache)
1568               // clough_raw_shape(j,p) only once per triangle, not 1-7
1569               // times
1570               switch (i)
1571                 {
1572                   // Note: these DoF numbers are "scrambled" because my
1573                   // initial numbering conventions didn't match libMesh
1574                 case 0:
1575                   return clough_raw_shape(0, p)
1576                     + d1d2n * clough_raw_shape(10, p)
1577                     + d1d3n * clough_raw_shape(11, p);
1578                 case 3:
1579                   return clough_raw_shape(1, p)
1580                     + d2d3n * clough_raw_shape(11, p)
1581                     + d2d1n * clough_raw_shape(9, p);
1582                 case 6:
1583                   return clough_raw_shape(2, p)
1584                     + d3d1n * clough_raw_shape(9, p)
1585                     + d3d2n * clough_raw_shape(10, p);
1586                 case 1:
1587                   return d1xd1x * clough_raw_shape(3, p)
1588                     + d1xd1y * clough_raw_shape(4, p)
1589                     + d1xd2n * clough_raw_shape(10, p)
1590                     + d1xd3n * clough_raw_shape(11, p);
1591                 case 2:
1592                   return d1yd1y * clough_raw_shape(4, p)
1593                     + d1yd1x * clough_raw_shape(3, p)
1594                     + d1yd2n * clough_raw_shape(10, p)
1595                     + d1yd3n * clough_raw_shape(11, p);
1596                 case 4:
1597                   return d2xd2x * clough_raw_shape(5, p)
1598                     + d2xd2y * clough_raw_shape(6, p)
1599                     + d2xd3n * clough_raw_shape(11, p)
1600                     + d2xd1n * clough_raw_shape(9, p);
1601                 case 5:
1602                   return d2yd2y * clough_raw_shape(6, p)
1603                     + d2yd2x * clough_raw_shape(5, p)
1604                     + d2yd3n * clough_raw_shape(11, p)
1605                     + d2yd1n * clough_raw_shape(9, p);
1606                 case 7:
1607                   return d3xd3x * clough_raw_shape(7, p)
1608                     + d3xd3y * clough_raw_shape(8, p)
1609                     + d3xd1n * clough_raw_shape(9, p)
1610                     + d3xd2n * clough_raw_shape(10, p);
1611                 case 8:
1612                   return d3yd3y * clough_raw_shape(8, p)
1613                     + d3yd3x * clough_raw_shape(7, p)
1614                     + d3yd1n * clough_raw_shape(9, p)
1615                     + d3yd2n * clough_raw_shape(10, p);
1616                 case 10:
1617                   return d1nd1n * clough_raw_shape(9, p);
1618                 case 11:
1619                   return d2nd2n * clough_raw_shape(10, p);
1620                 case 9:
1621                   return d3nd3n * clough_raw_shape(11, p);
1622 
1623                 default:
1624                   libmesh_error();
1625                 }
1626             }
1627           default:
1628             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1629             libmesh_error();
1630           }
1631       }
1632       // by default throw an error
1633     default:
1634       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
1635       libmesh_error();
1636     }
1637 
1638   libmesh_error();
1639   return 0\&.;
1640 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 47 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
52 {
53   return 0\&.;
54 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 47 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
52 {
53   return 0\&.;
54 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 47 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
52 {
53   return 0\&.;
54 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 48 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
53 {
54   return 0\&.;
55 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 56 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
61 {
62   // No spatial derivatives in 0D!
63   libmesh_error();
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 57 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
62 {
63   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
64   libmesh_error();
65   return 0\&.;
66 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 57 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
62 {
63   return 0\&.;
64 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 57 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
62 {
63   return 0\&.;
64 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 57 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
62 {
63   return 0\&.;
64 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 58 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
63 {
64   return 0\&.;
65 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 63 of file fe_clough_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
68 {
69   libMesh::err << "Clough-Tocher elements require the real element\n"
70                << "to construct gradient-based degrees of freedom\&."
71                << std::endl;
72 
73   libmesh_error();
74   return 0\&.;
75 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 70 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
75 {
76   // No spatial derivatives in 0D!
77   libmesh_error();
78   return 0\&.;
79 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 71 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
76 {
77   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
78   libmesh_error();
79   return 0\&.;
80 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 80 of file fe_clough_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
85 {
86   libmesh_assert(elem);
87   libmesh_not_implemented();
88   return 0\&.;
89 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 86 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
91 {
92   // only d()/dxi in 1D!
93 
94   libmesh_assert_equal_to (j, 0);
95 
96   const Real xi = p(0);
97 
98   libmesh_assert_less_equal (i, static_cast<unsigned int>(order));
99 
100   // monomials\&. since they are hierarchic we only need one case block\&.
101   switch (i)
102     {
103     case 0:
104       return 0\&.;
105 
106     case 1:
107       return 1\&.;
108 
109     case 2:
110       return 2\&.*xi;
111 
112     case 3:
113       return 3\&.*xi*xi;
114 
115     case 4:
116       return 4\&.*xi*xi*xi;
117 
118     default:
119       Real val = i;
120       for (unsigned int index = 1; index != i; ++index)
121         val *= xi;
122       return val;
123     }
124 
125   libmesh_error();
126   return 0\&.;
127 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 103 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::Real, and libMesh::SEVENTH\&.
.PP
.nf
108 {
109   // only d()/dxi in 1D!
110   libmesh_assert_equal_to (j, 0);
111 
112   const Real xi  = p(0);
113   const Real xi2 = xi*xi;
114 
115   // Use this libmesh_assert rather than a switch with a single entry\&.\&.\&.
116   // It will go away in optimized mode, essentially has the same effect\&.
117   libmesh_assert_less_equal (order, SEVENTH);
118 
119   //   switch (order)
120   //     {
121   //     case FIRST:
122   //     case SECOND:
123   //     case THIRD:
124   //     case FOURTH:
125   //     case FIFTH:
126   //     case SIXTH:
127   //     case SEVENTH:
128 
129   switch(i)
130     {
131     case 0:return -1\&./2\&.;
132     case 1:return 1\&./2\&.;
133     case 2:return 1\&./2\&.*2\&.4494897427831780982*xi;
134     case 3:return -1\&./4\&.*3\&.1622776601683793320+3\&./4\&.*3\&.1622776601683793320*xi2;
135     case 4:return 1\&./16\&.*3\&.7416573867739413856*(-12\&.+20*xi2)*xi;
136     case 5:return 9\&./16\&.*1\&.4142135623730950488+(-45\&./8\&.*1\&.4142135623730950488+105\&./16\&.*1\&.4142135623730950488*xi2)*xi2;
137     case 6:return 1\&./32\&.*4\&.6904157598234295546*(30\&.+(-140\&.+126\&.*xi2)*xi2)*xi;
138     case 7:return -5\&./32\&.*5\&.0990195135927848300+(105\&./32\&.*5\&.0990195135927848300+(-315\&./32\&.*5\&.0990195135927848300+231\&./32\&.*5\&.0990195135927848300*xi2)*xi2)*xi2;
139     case 8:return 1\&./256\&.*5\&.4772255750516611346*(-280\&.+(2520\&.+(-5544\&.+3432\&.*xi2)*xi2)*xi2)*xi;
140 
141     default:
142       libMesh::err << "Invalid shape function index!" << std::endl;
143       libmesh_error();
144     }
145 
146   //     default:
147   //       {
148   // libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
149   // libmesh_error();
150   //       }
151   //     }
152 
153   libmesh_error();
154   return 0\&.;
155 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 114 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
119 {
120   // only d()/dxi in 1D!
121 
122   libmesh_assert_equal_to (j, 0);
123   libmesh_assert_less (i, order+1u);
124 
125   // Declare that we are using our own special power function
126   // from the Utility namespace\&.  This saves typing later\&.
127   using Utility::pow;
128 
129   const Real xi = p(0);
130 
131   Real returnval = 1\&.;
132 
133   switch (i)
134     {
135     case 0:
136       returnval = -\&.5;
137       break;
138     case 1:
139       returnval =  \&.5;
140       break;
141       // All even-terms have the same form\&.
142       // xi^(p-1)/(p-1)!
143     case 2:
144       returnval = xi;
145       break;
146     case 4:
147       returnval = pow<3>(xi)/6\&.;
148       break;
149     case 6:
150       returnval = pow<5>(xi)/120\&.;
151       break;
152       // All odd-terms have the same form\&.
153       // (p*xi^(p-1) - 1\&.)/p!
154     case 3:
155       returnval = (3*xi*xi - 1\&.)/6\&.;
156       break;
157     case 5:
158       returnval = (5\&.*pow<4>(xi) - 1\&.)/120\&.;
159       break;
160     case 7:
161       returnval = (7\&.*pow<6>(xi) - 1\&.)/5040\&.;
162       break;
163     default:
164       Real denominator = 1\&.;
165       for (unsigned int n=1; n != i; ++n)
166         {
167           returnval *= xi;
168           denominator *= n;
169         }
170       // Odd:
171       if (i % 2)
172         returnval = (i * returnval - 1\&.)/denominator/i;
173       // Even:
174       else
175         returnval = returnval/denominator;
176       break;
177     }
178 
179   return returnval;
180 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 114 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
119 {
120   // only d()/dxi in 1D!
121 
122   libmesh_assert_equal_to (j, 0);
123   libmesh_assert_less (i, order+1u);
124 
125   // Declare that we are using our own special power function
126   // from the Utility namespace\&.  This saves typing later\&.
127   using Utility::pow;
128 
129   const Real xi = p(0);
130 
131   Real returnval = 1\&.;
132 
133   switch (i)
134     {
135     case 0:
136       returnval = -\&.5;
137       break;
138     case 1:
139       returnval =  \&.5;
140       break;
141       // All even-terms have the same form\&.
142       // xi^(p-1)/(p-1)!
143     case 2:
144       returnval = xi;
145       break;
146     case 4:
147       returnval = pow<3>(xi)/6\&.;
148       break;
149     case 6:
150       returnval = pow<5>(xi)/120\&.;
151       break;
152       // All odd-terms have the same form\&.
153       // (p*xi^(p-1) - 1\&.)/p!
154     case 3:
155       returnval = (3*xi*xi - 1\&.)/6\&.;
156       break;
157     case 5:
158       returnval = (5\&.*pow<4>(xi) - 1\&.)/120\&.;
159       break;
160     case 7:
161       returnval = (7\&.*pow<6>(xi) - 1\&.)/5040\&.;
162       break;
163     default:
164       Real denominator = 1\&.;
165       for (unsigned int n=1; n != i; ++n)
166         {
167           returnval *= xi;
168           denominator *= n;
169         }
170       // Odd:
171       if (i % 2)
172         returnval = (i * returnval - 1\&.)/denominator/i;
173       // Even:
174       else
175         returnval = returnval/denominator;
176       break;
177     }
178 
179   return returnval;
180 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 127 of file fe_xyz_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
132 {
133   libMesh::err << "XYZ polynomials require the element\n"
134                << "because the centroid is needed\&."
135                << std::endl;
136 
137   libmesh_error();
138   return 0\&.;
139 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 132 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
137 {
138   libmesh_assert(elem);
139 
140   return FE<1,MONOMIAL>::shape_deriv(elem->type(),
141                                      static_cast<Order>(order + elem->p_level()), i, j, p);
142 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 133 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
138 {
139 #if LIBMESH_DIM > 1
140 
141 
142   libmesh_assert_less (j, 2);
143 
144   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
145                        (static_cast<unsigned int>(order)+2)/2);
146 
147   const Real xi  = p(0);
148   const Real eta = p(1);
149 
150   // monomials\&. since they are hierarchic we only need one case block\&.
151 
152   switch (j)
153     {
154       // d()/dxi
155     case 0:
156       {
157         switch (i)
158           {
159             // constants
160           case 0:
161             return 0\&.;
162 
163             // linears
164           case 1:
165             return 1\&.;
166 
167           case 2:
168             return 0\&.;
169 
170             // quadratics
171           case 3:
172             return 2\&.*xi;
173 
174           case 4:
175             return eta;
176 
177           case 5:
178             return 0\&.;
179 
180             // cubics
181           case 6:
182             return 3\&.*xi*xi;
183 
184           case 7:
185             return 2\&.*xi*eta;
186 
187           case 8:
188             return eta*eta;
189 
190           case 9:
191             return 0\&.;
192 
193             // quartics
194           case 10:
195             return 4\&.*xi*xi*xi;
196 
197           case 11:
198             return 3\&.*xi*xi*eta;
199 
200           case 12:
201             return 2\&.*xi*eta*eta;
202 
203           case 13:
204             return eta*eta*eta;
205 
206           case 14:
207             return 0\&.;
208 
209           default:
210             unsigned int o = 0;
211             for (; i >= (o+1)*(o+2)/2; o++) { }
212             unsigned int ny = i - (o*(o+1)/2);
213             unsigned int nx = o - ny;
214             Real val = nx;
215             for (unsigned int index=1; index < nx; index++)
216               val *= xi;
217             for (unsigned int index=0; index != ny; index++)
218               val *= eta;
219             return val;
220           }
221       }
222 
223 
224       // d()/deta
225     case 1:
226       {
227         switch (i)
228           {
229             // constants
230           case 0:
231             return 0\&.;
232 
233             // linears
234           case 1:
235             return 0\&.;
236 
237           case 2:
238             return 1\&.;
239 
240             // quadratics
241           case 3:
242             return 0\&.;
243 
244           case 4:
245             return xi;
246 
247           case 5:
248             return 2\&.*eta;
249 
250             // cubics
251           case 6:
252             return 0\&.;
253 
254           case 7:
255             return xi*xi;
256 
257           case 8:
258             return 2\&.*xi*eta;
259 
260           case 9:
261             return 3\&.*eta*eta;
262 
263             // quartics
264           case 10:
265             return 0\&.;
266 
267           case 11:
268             return xi*xi*xi;
269 
270           case 12:
271             return 2\&.*xi*xi*eta;
272 
273           case 13:
274             return 3\&.*xi*eta*eta;
275 
276           case 14:
277             return 4\&.*eta*eta*eta;
278 
279           default:
280             unsigned int o = 0;
281             for (; i >= (o+1)*(o+2)/2; o++) { }
282             unsigned int ny = i - (o*(o+1)/2);
283             unsigned int nx = o - ny;
284             Real val = ny;
285             for (unsigned int index=0; index != nx; index++)
286               val *= xi;
287             for (unsigned int index=1; index < ny; index++)
288               val *= eta;
289             return val;
290           }
291       }
292     }
293 
294   libmesh_error();
295   return 0\&.;
296 
297 #endif
298 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the dimension, element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Referenced by libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FE< Dim, T >::init_shape_functions(), libMesh::FESubdivision::init_shape_functions(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), and libMesh::FE< Dim, T >::shape_deriv()\&.
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 140 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
145 {
146   // only d()/dxi in 1D!
147 
148   libmesh_assert_equal_to (j, 0);
149 
150   const Real xi = p(0);
151 
152 
153   switch (order)
154     {
155       // Lagrange linear shape function derivatives
156     case FIRST:
157       {
158         libmesh_assert_less (i, 2);
159 
160         switch (i)
161           {
162           case 0:
163             return -\&.5;
164 
165           case 1:
166             return \&.5;
167 
168           default:
169             libMesh::err << "Invalid shape function index!" << std::endl;
170             libmesh_error();
171           }
172       }
173 
174 
175       // Lagrange quadratic shape function derivatives
176     case SECOND:
177       {
178         libmesh_assert_less (i, 3);
179 
180         switch (i)
181           {
182           case 0:
183             return xi-\&.5;
184 
185           case 1:
186             return xi+\&.5;
187 
188           case 2:
189             return -2\&.*xi;
190 
191           default:
192             libMesh::err << "Invalid shape function index!" << std::endl;
193             libmesh_error();
194           }
195       }
196 
197 
198       // Lagrange cubic shape function derivatives
199     case THIRD:
200       {
201         libmesh_assert_less (i, 4);
202 
203         switch (i)
204           {
205           case 0:
206             return -9\&./16\&.*(3\&.*xi*xi-2\&.*xi-1\&./9\&.);
207 
208           case 1:
209             return -9\&./16\&.*(-3\&.*xi*xi-2\&.*xi+1\&./9\&.);
210 
211           case 2:
212             return 27\&./16\&.*(3\&.*xi*xi-2\&./3\&.*xi-1\&.);
213 
214           case 3:
215             return 27\&./16\&.*(-3\&.*xi*xi-2\&./3\&.*xi+1\&.);
216 
217           default:
218             libMesh::err << "Invalid shape function index!" << std::endl;
219             libmesh_error();
220           }
221       }
222 
223 
224     default:
225       {
226         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
227         libmesh_error();
228       }
229     }
230 
231   libmesh_error();
232   return 0\&.;
233 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 140 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
145 {
146   // only d()/dxi in 1D!
147 
148   libmesh_assert_equal_to (j, 0);
149 
150   const Real xi = p(0);
151 
152 
153   switch (order)
154     {
155       // Lagrange linear shape function derivatives
156     case FIRST:
157       {
158         libmesh_assert_less (i, 2);
159 
160         switch (i)
161           {
162           case 0:
163             return -\&.5;
164 
165           case 1:
166             return \&.5;
167 
168           default:
169             libMesh::err << "Invalid shape function index!" << std::endl;
170             libmesh_error();
171           }
172       }
173 
174 
175       // Lagrange quadratic shape function derivatives
176     case SECOND:
177       {
178         libmesh_assert_less (i, 3);
179 
180         switch (i)
181           {
182           case 0:
183             return xi-\&.5;
184 
185           case 1:
186             return xi+\&.5;
187 
188           case 2:
189             return -2\&.*xi;
190 
191           default:
192             libMesh::err << "Invalid shape function index!" << std::endl;
193             libmesh_error();
194           }
195       }
196 
197 
198       // Lagrange cubic shape function derivatives
199     case THIRD:
200       {
201         libmesh_assert_less (i, 4);
202 
203         switch (i)
204           {
205           case 0:
206             return -9\&./16\&.*(3\&.*xi*xi-2\&.*xi-1\&./9\&.);
207 
208           case 1:
209             return -9\&./16\&.*(-3\&.*xi*xi-2\&.*xi+1\&./9\&.);
210 
211           case 2:
212             return 27\&./16\&.*(3\&.*xi*xi-2\&./3\&.*xi-1\&.);
213 
214           case 3:
215             return 27\&./16\&.*(-3\&.*xi*xi-2\&./3\&.*xi+1\&.);
216 
217           default:
218             libMesh::err << "Invalid shape function index!" << std::endl;
219             libmesh_error();
220           }
221       }
222 
223 
224     default:
225       {
226         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
227         libmesh_error();
228       }
229     }
230 
231   libmesh_error();
232   return 0\&.;
233 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &point_in)"

.PP
Definition at line 144 of file fe_xyz_shape_1D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
149 {
150   libmesh_assert(elem);
151   libmesh_assert_less_equal (i, order + elem->p_level());
152 
153   // only d()/dxi in 1D!
154 
155   libmesh_assert_equal_to (j, 0);
156 
157   // Only recompute the centroid if the element
158   // has changed from the last one we computed\&.
159   // This avoids repeated centroid calculations
160   // when called in succession with the same element\&.
161   if (elem->id() != old_elem_id)
162     {
163       centroid = elem->centroid();
164       old_elem_id = elem->id();
165       max_distance = 0\&.;
166       for (unsigned int p = 0; p < elem->n_nodes(); p++)
167         {
168           const Real distance = std::abs(centroid(0) - elem->point(p)(0));
169           max_distance = std::max(distance, max_distance);
170         }
171     }
172 
173   // Using static globals for old_elem_id, etc\&. will fail
174   // horribly with more than one thread\&.
175   libmesh_assert_equal_to (libMesh::n_threads(), 1);
176 
177   const Real x  = point_in(0);
178   const Real xc = centroid(0);
179   const Real dx = (x - xc)/max_distance;
180 
181   // monomials\&. since they are hierarchic we only need one case block\&.
182   switch (i)
183     {
184     case 0:
185       return 0\&.;
186 
187     case 1:
188       return 1\&.;
189 
190     case 2:
191       return 2\&.*dx/max_distance;
192 
193     case 3:
194       return 3\&.*dx*dx/max_distance;
195 
196     case 4:
197       return 4\&.*dx*dx*dx/max_distance;
198 
199     default:
200       Real val = i;
201       for (unsigned int index = 1; index != i; ++index)
202         val *= dx;
203       return val/max_distance;
204     }
205 
206   libmesh_error();
207   return 0\&.;
208 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function\&. You must specify element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 160 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
165 {
166   libmesh_assert(elem);
167 
168   return FE<1,SZABAB>::shape_deriv(elem->type(),
169                                    static_cast<Order>(order + elem->p_level()), i, j, p);
170 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 183 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
188 {
189 #if LIBMESH_DIM > 1
190   libMesh::err << "Nedelec elements require the element type\n"
191                << "because edge orientation is needed\&."
192                << std::endl;
193   libmesh_error();
194 #endif // LIBMESH_DIM > 1
195 
196   libmesh_error();
197   return RealGradient();
198 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 183 of file fe_xyz_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
188 {
189   libMesh::err << "XYZ polynomials require the element\n"
190                << "because the centroid is needed\&."
191                << std::endl;
192 
193   libmesh_error();
194   return 0\&.;
195 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 185 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
190 {
191   libmesh_assert(elem);
192 
193   return FE<1,L2_HIERARCHIC>::shape_deriv(elem->type(),
194                                           static_cast<Order>(order + elem->p_level()), i, j, p);
195 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 185 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
190 {
191   libmesh_assert(elem);
192 
193   return FE<1,HIERARCHIC>::shape_deriv(elem->type(),
194                                        static_cast<Order>(order + elem->p_level()), i, j, p);
195 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &point_in)"

.PP
Definition at line 200 of file fe_xyz_shape_2D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
205 {
206 #if LIBMESH_DIM > 1
207 
208 
209   libmesh_assert_less (j, 2);
210   libmesh_assert(elem);
211 
212   // Only recompute the centroid if the element
213   // has changed from the last one we computed\&.
214   // This avoids repeated centroid calculations
215   // when called in succession with the same element\&.
216   if (elem->id() != old_elem_id)
217     {
218       centroid = elem->centroid();
219       old_elem_id = elem->id();
220       max_distance = Point(0\&.,0\&.,0\&.);
221       for (unsigned int p = 0; p < elem->n_nodes(); p++)
222         for (unsigned int d = 0; d < 2; d++)
223           {
224             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
225             max_distance(d) = std::max(distance, max_distance(d));
226           }
227     }
228 
229   // Using static globals for old_elem_id, etc\&. will fail
230   // horribly with more than one thread\&.
231   libmesh_assert_equal_to (libMesh::n_threads(), 1);
232 
233   const Real x  = point_in(0);
234   const Real y  = point_in(1);
235   const Real xc = centroid(0);
236   const Real yc = centroid(1);
237   const Real distx = max_distance(0);
238   const Real disty = max_distance(1);
239   const Real dx = (x - xc)/distx;
240   const Real dy = (y - yc)/disty;
241 
242 #ifndef NDEBUG
243   // totalorder is only used in the assertion below, so
244   // we avoid declaring it when asserts are not active\&.
245   const unsigned int totalorder = order + elem->p_level();
246 #endif
247   libmesh_assert_less (i, (totalorder+1)*(totalorder+2)/2);
248 
249   // monomials\&. since they are hierarchic we only need one case block\&.
250 
251   switch (j)
252     {
253       // d()/dx
254     case 0:
255       {
256         switch (i)
257           {
258             // constants
259           case 0:
260             return 0\&.;
261 
262             // linears
263           case 1:
264             return 1\&./distx;
265 
266           case 2:
267             return 0\&.;
268 
269             // quadratics
270           case 3:
271             return 2\&.*dx/distx;
272 
273           case 4:
274             return dy/distx;
275 
276           case 5:
277             return 0\&.;
278 
279             // cubics
280           case 6:
281             return 3\&.*dx*dx/distx;
282 
283           case 7:
284             return 2\&.*dx*dy/distx;
285 
286           case 8:
287             return dy*dy/distx;
288 
289           case 9:
290             return 0\&.;
291 
292             // quartics
293           case 10:
294             return 4\&.*dx*dx*dx/distx;
295 
296           case 11:
297             return 3\&.*dx*dx*dy/distx;
298 
299           case 12:
300             return 2\&.*dx*dy*dy/distx;
301 
302           case 13:
303             return dy*dy*dy/distx;
304 
305           case 14:
306             return 0\&.;
307 
308           default:
309             unsigned int o = 0;
310             for (; i >= (o+1)*(o+2)/2; o++) { }
311             unsigned int i2 = i - (o*(o+1)/2);
312             Real val = o - i2;
313             for (unsigned int index=i2+1; index < o; index++)
314               val *= dx;
315             for (unsigned int index=0; index != i2; index++)
316               val *= dy;
317             return val/distx;
318           }
319       }
320 
321 
322       // d()/dy
323     case 1:
324       {
325         switch (i)
326           {
327             // constants
328           case 0:
329             return 0\&.;
330 
331             // linears
332           case 1:
333             return 0\&.;
334 
335           case 2:
336             return 1\&./disty;
337 
338             // quadratics
339           case 3:
340             return 0\&.;
341 
342           case 4:
343             return dx/disty;
344 
345           case 5:
346             return 2\&.*dy/disty;
347 
348             // cubics
349           case 6:
350             return 0\&.;
351 
352           case 7:
353             return dx*dx/disty;
354 
355           case 8:
356             return 2\&.*dx*dy/disty;
357 
358           case 9:
359             return 3\&.*dy*dy/disty;
360 
361             // quartics
362           case 10:
363             return 0\&.;
364 
365           case 11:
366             return dx*dx*dx/disty;
367 
368           case 12:
369             return 2\&.*dx*dx*dy/disty;
370 
371           case 13:
372             return 3\&.*dx*dy*dy/disty;
373 
374           case 14:
375             return 4\&.*dy*dy*dy/disty;
376 
377           default:
378             unsigned int o = 0;
379             for (; i >= (o+1)*(o+2)/2; o++) { }
380             unsigned int i2 = i - (o*(o+1)/2);
381             Real val = i2;
382             for (unsigned int index=i2; index != o; index++)
383               val *= dx;
384             for (unsigned int index=1; index <= i2; index++)
385               val *= dy;
386             return val/disty;
387           }
388       }
389 
390 
391     default:
392       libmesh_error();
393     }
394 
395   libmesh_error();
396   return 0\&.;
397 
398 #endif
399 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 201 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
206 {
207 #if LIBMESH_DIM == 3
208 
209   libmesh_assert_less (j, 3);
210 
211   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
212                        (static_cast<unsigned int>(order)+2)*
213                        (static_cast<unsigned int>(order)+3)/6);
214 
215 
216   const Real xi   = p(0);
217   const Real eta  = p(1);
218   const Real zeta = p(2);
219 
220   // monomials\&. since they are hierarchic we only need one case block\&.
221   switch (j)
222     {
223       // d()/dxi
224     case 0:
225       {
226         switch (i)
227           {
228             // constant
229           case 0:
230             return 0\&.;
231 
232             // linear
233           case 1:
234             return 1\&.;
235 
236           case 2:
237             return 0\&.;
238 
239           case 3:
240             return 0\&.;
241 
242             // quadratic
243           case 4:
244             return 2\&.*xi;
245 
246           case 5:
247             return eta;
248 
249           case 6:
250             return 0\&.;
251 
252           case 7:
253             return zeta;
254 
255           case 8:
256             return 0\&.;
257 
258           case 9:
259             return 0\&.;
260 
261             // cubic
262           case 10:
263             return 3\&.*xi*xi;
264 
265           case 11:
266             return 2\&.*xi*eta;
267 
268           case 12:
269             return eta*eta;
270 
271           case 13:
272             return 0\&.;
273 
274           case 14:
275             return 2\&.*xi*zeta;
276 
277           case 15:
278             return eta*zeta;
279 
280           case 16:
281             return 0\&.;
282 
283           case 17:
284             return zeta*zeta;
285 
286           case 18:
287             return 0\&.;
288 
289           case 19:
290             return 0\&.;
291 
292             // quartics
293           case 20:
294             return 4\&.*xi*xi*xi;
295 
296           case 21:
297             return 3\&.*xi*xi*eta;
298 
299           case 22:
300             return 2\&.*xi*eta*eta;
301 
302           case 23:
303             return eta*eta*eta;
304 
305           case 24:
306             return 0\&.;
307 
308           case 25:
309             return 3\&.*xi*xi*zeta;
310 
311           case 26:
312             return 2\&.*xi*eta*zeta;
313 
314           case 27:
315             return eta*eta*zeta;
316 
317           case 28:
318             return 0\&.;
319 
320           case 29:
321             return 2\&.*xi*zeta*zeta;
322 
323           case 30:
324             return eta*zeta*zeta;
325 
326           case 31:
327             return 0\&.;
328 
329           case 32:
330             return zeta*zeta*zeta;
331 
332           case 33:
333             return 0\&.;
334 
335           case 34:
336             return 0\&.;
337 
338           default:
339             unsigned int o = 0;
340             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
341             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
342             unsigned int block=o, nz = 0;
343             for (; block < i2; block += (o-nz+1)) { nz++; }
344             const unsigned int nx = block - i2;
345             const unsigned int ny = o - nx - nz;
346             Real val = nx;
347             for (unsigned int index=1; index < nx; index++)
348               val *= xi;
349             for (unsigned int index=0; index != ny; index++)
350               val *= eta;
351             for (unsigned int index=0; index != nz; index++)
352               val *= zeta;
353             return val;
354           }
355       }
356 
357 
358       // d()/deta
359     case 1:
360       {
361         switch (i)
362           {
363             // constant
364           case 0:
365             return 0\&.;
366 
367             // linear
368           case 1:
369             return 0\&.;
370 
371           case 2:
372             return 1\&.;
373 
374           case 3:
375             return 0\&.;
376 
377             // quadratic
378           case 4:
379             return 0\&.;
380 
381           case 5:
382             return xi;
383 
384           case 6:
385             return 2\&.*eta;
386 
387           case 7:
388             return 0\&.;
389 
390           case 8:
391             return zeta;
392 
393           case 9:
394             return 0\&.;
395 
396             // cubic
397           case 10:
398             return 0\&.;
399 
400           case 11:
401             return xi*xi;
402 
403           case 12:
404             return 2\&.*xi*eta;
405 
406           case 13:
407             return 3\&.*eta*eta;
408 
409           case 14:
410             return 0\&.;
411 
412           case 15:
413             return xi*zeta;
414 
415           case 16:
416             return 2\&.*eta*zeta;
417 
418           case 17:
419             return 0\&.;
420 
421           case 18:
422             return zeta*zeta;
423 
424           case 19:
425             return 0\&.;
426 
427             // quartics
428           case 20:
429             return 0\&.;
430 
431           case 21:
432             return xi*xi*xi;
433 
434           case 22:
435             return 2\&.*xi*xi*eta;
436 
437           case 23:
438             return 3\&.*xi*eta*eta;
439 
440           case 24:
441             return 4\&.*eta*eta*eta;
442 
443           case 25:
444             return 0\&.;
445 
446           case 26:
447             return xi*xi*zeta;
448 
449           case 27:
450             return 2\&.*xi*eta*zeta;
451 
452           case 28:
453             return 3\&.*eta*eta*zeta;
454 
455           case 29:
456             return 0\&.;
457 
458           case 30:
459             return xi*zeta*zeta;
460 
461           case 31:
462             return 2\&.*eta*zeta*zeta;
463 
464           case 32:
465             return 0\&.;
466 
467           case 33:
468             return zeta*zeta*zeta;
469 
470           case 34:
471             return 0\&.;
472 
473           default:
474             unsigned int o = 0;
475             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
476             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
477             unsigned int block=o, nz = 0;
478             for (; block < i2; block += (o-nz+1)) { nz++; }
479             const unsigned int nx = block - i2;
480             const unsigned int ny = o - nx - nz;
481             Real val = ny;
482             for (unsigned int index=0; index != nx; index++)
483               val *= xi;
484             for (unsigned int index=1; index < ny; index++)
485               val *= eta;
486             for (unsigned int index=0; index != nz; index++)
487               val *= zeta;
488             return val;
489           }
490       }
491 
492 
493       // d()/dzeta
494     case 2:
495       {
496         switch (i)
497           {
498             // constant
499           case 0:
500             return 0\&.;
501 
502             // linear
503           case 1:
504             return 0\&.;
505 
506           case 2:
507             return 0\&.;
508 
509           case 3:
510             return 1\&.;
511 
512             // quadratic
513           case 4:
514             return 0\&.;
515 
516           case 5:
517             return 0\&.;
518 
519           case 6:
520             return 0\&.;
521 
522           case 7:
523             return xi;
524 
525           case 8:
526             return eta;
527 
528           case 9:
529             return 2\&.*zeta;
530 
531             // cubic
532           case 10:
533             return 0\&.;
534 
535           case 11:
536             return 0\&.;
537 
538           case 12:
539             return 0\&.;
540 
541           case 13:
542             return 0\&.;
543 
544           case 14:
545             return xi*xi;
546 
547           case 15:
548             return xi*eta;
549 
550           case 16:
551             return eta*eta;
552 
553           case 17:
554             return 2\&.*xi*zeta;
555 
556           case 18:
557             return 2\&.*eta*zeta;
558 
559           case 19:
560             return 3\&.*zeta*zeta;
561 
562             // quartics
563           case 20:
564             return 0\&.;
565 
566           case 21:
567             return 0\&.;
568 
569           case 22:
570             return 0\&.;
571 
572           case 23:
573             return 0\&.;
574 
575           case 24:
576             return 0\&.;
577 
578           case 25:
579             return xi*xi*xi;
580 
581           case 26:
582             return xi*xi*eta;
583 
584           case 27:
585             return xi*eta*eta;
586 
587           case 28:
588             return eta*eta*eta;
589 
590           case 29:
591             return 2\&.*xi*xi*zeta;
592 
593           case 30:
594             return 2\&.*xi*eta*zeta;
595 
596           case 31:
597             return 2\&.*eta*eta*zeta;
598 
599           case 32:
600             return 3\&.*xi*zeta*zeta;
601 
602           case 33:
603             return 3\&.*eta*zeta*zeta;
604 
605           case 34:
606             return 4\&.*zeta*zeta*zeta;
607 
608           default:
609             unsigned int o = 0;
610             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
611             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
612             unsigned int block=o, nz = 0;
613             for (; block < i2; block += (o-nz+1)) { nz++; }
614             const unsigned int nx = block - i2;
615             const unsigned int ny = o - nx - nz;
616             Real val = nz;
617             for (unsigned int index=0; index != nx; index++)
618               val *= xi;
619             for (unsigned int index=0; index != ny; index++)
620               val *= eta;
621             for (unsigned int index=1; index < nz; index++)
622               val *= zeta;
623             return val;
624           }
625       }
626     }
627 
628 #endif
629 
630   libmesh_error();
631   return 0\&.;
632 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &)"

.PP
Definition at line 203 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
208 {
209 #if LIBMESH_DIM > 1
210   libmesh_assert(elem);
211   libmesh_assert_less (j, 2);
212 
213   const Order total_order = static_cast<Order>(order + elem->p_level());
214 
215   switch (total_order)
216     {
217       // linear Lagrange shape functions
218     case FIRST:
219       {
220         switch (elem->type())
221           {
222           case QUAD8:
223           case QUAD9:
224             {
225               libmesh_assert_less (i, 4);
226 
227               switch (j)
228                 {
229                   // d()/dxi
230                 case 0:
231                   {
232                     switch(i)
233                       {
234                       case 0:
235                       case 2:
236                         return RealGradient();
237                       case 1:
238                         {
239                           if( elem->point(1) > elem->point(2) )
240                             return RealGradient( 0\&.0, -0\&.25 );
241                           else
242                             return RealGradient( 0\&.0, 0\&.25 );
243                         }
244                       case 3:
245                         {
246                           if( elem->point(3) > elem->point(0) )
247                             return RealGradient( 0\&.0, -0\&.25 );
248                           else
249                             return RealGradient( 0\&.0, 0\&.25 );
250                         }
251                       default:
252                         libmesh_error();
253                       }
254                   } // j=0
255 
256                   // d()/deta
257                 case 1:
258                   {
259                     switch(i)
260                       {
261                       case 1:
262                       case 3:
263                         return RealGradient();
264                       case 0:
265                         {
266                           if( elem->point(0) > elem->point(1) )
267                             return RealGradient( 0\&.25 );
268                           else
269                             return RealGradient( -0\&.25 );
270                         }
271                       case 2:
272                         {
273                           if( elem->point(2) > elem->point(3) )
274                             return RealGradient( 0\&.25 );
275                           else
276                             return RealGradient( -0\&.25 );
277                         }
278                       default:
279                         libmesh_error();
280                       }
281                   } // j=1
282 
283                 default:
284                   libmesh_error();
285                 }
286 
287               return RealGradient();
288             }
289 
290           case TRI6:
291             {
292               libmesh_assert_less (i, 3);
293 
294               // Account for edge flipping
295               Real f = 1\&.0;
296 
297               switch(i)
298                 {
299                 case 0:
300                   {
301                     if( elem->point(0) > elem->point(1) )
302                       f = -1\&.0;
303                     break;
304                   }
305                 case 1:
306                   {
307                     if( elem->point(1) > elem->point(2) )
308                       f = -1\&.0;
309                     break;
310                   }
311                 case 2:
312                   {
313                     if( elem->point(2) > elem->point(0) )
314                       f = -1\&.0;
315                     break;
316                   }
317                 default:
318                   libmesh_error();
319                 }
320 
321               switch (j)
322                 {
323                   // d()/dxi
324                 case 0:
325                   {
326                     return RealGradient( 0\&.0, f*1\&.0);
327                   }
328                   // d()/deta
329                 case 1:
330                   {
331                     return RealGradient( f*(-1\&.0) );
332                   }
333                 default:
334                   libmesh_error();
335                 }
336             }
337 
338           default:
339             {
340               libMesh::err << "ERROR: Unsupported 2D element type!: " << elem->type()
341                            << std::endl;
342               libmesh_error();
343             }
344           }
345       }
346       // unsupported order
347     default:
348       {
349         libMesh::err << "ERROR: Unsupported 2D FE order!: " << total_order
350                      << std::endl;
351         libmesh_error();
352       }
353     }
354 #endif // LIBMESH_DIM > 1
355 
356   libmesh_error();
357   return RealGradient();
358 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 211 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
216 {
217 #if LIBMESH_DIM == 3
218   libMesh::err << "Nedelec elements require the element type\n"
219                << "because edge orientation is needed\&."
220                << std::endl;
221   libmesh_error();
222 #endif
223 
224   libmesh_error();
225   return RealGradient();
226 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 214 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::Utility::factorial(), libMesh::FIFTH, libMesh::FIRST, libMesh::FOURTH, libMesh::libmesh_assert(), std::pow(), libMesh::Utility::pow(), libMesh::Real, libMesh::SECOND, libMesh::SIXTH, and libMesh::THIRD\&.
.PP
.nf
219 {
220   // only d()/dxi in 1D!
221 
222   libmesh_assert_equal_to (j, 0);
223 
224   const Real xi = p(0);
225 
226   using Utility::pow;
227 
228   switch (order)
229     {
230     case FIRST:
231 
232       switch(i)
233         {
234         case 0:
235           return -\&.5;
236         case 1:
237           return \&.5;
238         default:
239           libMesh::err << "Invalid shape function index " << i << std::endl;
240           libmesh_error();
241         }
242 
243     case SECOND:
244 
245       switch(i)
246         {
247         case 0:
248           return (xi-1\&.)*\&.5;
249         case 1:
250           return (xi+1\&.)*\&.5;
251         case 2:
252           return -xi;
253         default:
254           libMesh::err << "Invalid shape function index!" << std::endl;
255           libmesh_error();
256         }
257 
258     case THIRD:
259 
260       switch(i)
261         {
262         case 0:
263           return -0\&.375*pow<2>(1\&.-xi);
264         case 1:
265           return  0\&.375*pow<2>(1\&.+xi);
266         case 2:
267           return -0\&.375 -\&.75*xi +1\&.125*pow<2>(xi);
268         case 3:
269           return  0\&.375 -\&.75*xi -1\&.125*pow<2>(xi);
270         default:
271           libMesh::err << "Invalid shape function index!" << std::endl;
272           libmesh_error();
273         }
274 
275     case FOURTH:
276 
277       switch(i)
278         {
279         case 0:
280           return -0\&.25*pow<3>(1\&.-xi);
281         case 1:
282           return  0\&.25*pow<3>(1\&.+xi);
283         case 2:
284           return -0\&.5 +1\&.5*pow<2>(xi)-pow<3>(xi);
285         case 3:
286           return  1\&.5*(pow<3>(xi)-xi);
287         case 4:
288           return  0\&.5 -1\&.5*pow<2>(xi)-pow<3>(xi);
289         default:
290           libMesh::err << "Invalid shape function index!" << std::endl;
291           libmesh_error();
292         }
293 
294     case FIFTH:
295 
296       switch(i)
297         {
298         case 0:
299           return -(5\&./32\&.)*pow<4>(xi-1\&.);
300         case 1:
301           return  (5\&./32\&.)*pow<4>(xi+1\&.);
302         case 2:
303           return  (5\&./32\&.)*pow<4>(1\&.-xi)         -(5\&./8\&.)*(1\&.+xi)*pow<3>(1\&.-xi);
304         case 3:
305           return  (5\&./ 8\&.)*(1\&.+xi)*pow<3>(1\&.-xi) -(15\&./16\&.)*pow<2>(1\&.+xi)*pow<2>(1\&.-xi);
306         case 4:
307           return -(5\&./ 8\&.)*pow<3>(1\&.+xi)*(1\&.-xi) +(15\&./16\&.)*pow<2>(1\&.+xi)*pow<2>(1\&.-xi);
308         case 5:
309           return  (5\&./ 8\&.)*pow<3>(1\&.+xi)*(1\&.-xi) -(5\&./32\&.)*pow<4>(1\&.+xi);
310         default:
311           libMesh::err << "Invalid shape function index!" << std::endl;
312           libmesh_error();
313         }
314 
315     case SIXTH:
316 
317       switch(i)
318         {
319         case 0:
320           return -( 3\&./32\&.)*pow<5>(1\&.-xi);
321         case 1:
322           return  ( 3\&./32\&.)*pow<5>(1\&.+xi);
323         case 2:
324           return  ( 3\&./32\&.)*pow<5>(1\&.-xi)-(15\&./32\&.)*(1\&.+xi)*pow<4>(1\&.-xi);
325         case 3:
326           return  (15\&./32\&.)*(1\&.+xi)*pow<4>(1\&.-xi)-(15\&./16\&.)*pow<2>(1\&.+xi)*pow<3>(1\&.-xi);
327         case 4:
328           return -(15\&./ 8\&.)*xi +(15\&./4\&.)*pow<3>(xi)-(15\&./8\&.)*pow<5>(xi);
329         case 5:
330           return -(15\&./32\&.)*(1\&.-xi)*pow<4>(1\&.+xi)+(15\&./16\&.)*pow<2>(1\&.-xi)*pow<3>(1\&.+xi);
331         case 6:
332           return  (15\&./32\&.)*pow<4>(1\&.+xi)*(1\&.-xi)-(3\&./32\&.)*pow<5>(1\&.+xi);
333         default:
334           libMesh::err << "Invalid shape function index!" << std::endl;
335           libmesh_error();
336         }
337 
338 
339     default:
340       {
341         libmesh_assert (order>6);
342 
343         // Use this for arbitrary orders
344         const int p_order = static_cast<unsigned int>(order);
345         const int m       = p_order-(i-1);
346         const int n       = (i-1);
347 
348         unsigned int binomial_p_i = 1;
349 
350         // the binomial coefficient (p choose n)
351         if (i>1)
352           binomial_p_i = Utility::factorial(p_order)
353             / (Utility::factorial(n)*Utility::factorial(p_order-n));
354 
355 
356 
357         switch(i)
358           {
359           case 0:
360             return binomial_p_i * (-1\&./2\&.) * p_order * std::pow((1-xi)/2,static_cast<int>(p_order-1));
361           case 1:
362             return binomial_p_i * ( 1\&./2\&.) * p_order * std::pow((1+xi)/2,static_cast<int>(p_order-1));
363 
364           default:
365             {
366               return binomial_p_i * (1\&./2\&. * n * std::pow((1+xi)/2,n-1) * std::pow((1-xi)/2,m)
367                                      - 1\&./2\&. * m * std::pow((1+xi)/2,n)   * std::pow((1-xi)/2,m-1));
368             }
369           }
370 
371         // we should never get here
372         libmesh_error();
373       }
374 
375     }
376 
377   libmesh_error();
378   return 0\&.;
379 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 229 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, libMesh::TET10, libMesh::TOLERANCE, and libMesh::Elem::type()\&.
.PP
.nf
234 {
235 #if LIBMESH_DIM == 3
236   libmesh_assert(elem);
237   libmesh_assert_less (j, 3);
238 
239   const Order totalorder = static_cast<Order>(order + elem->p_level());
240 
241   switch (totalorder)
242     {
243     case FIRST:
244       {
245         switch (elem->type())
246           {
247           case HEX20:
248           case HEX27:
249             {
250               libmesh_assert_less (i, 12);
251 
252               const Real xi   = p(0);
253               const Real eta  = p(1);
254               const Real zeta = p(2);
255 
256               // Even with a loose inverse_map tolerance we ought to
257               // be nearly on the element interior in master
258               // coordinates
259               libmesh_assert_less_equal ( std::fabs(xi),   1\&.0+TOLERANCE );
260               libmesh_assert_less_equal ( std::fabs(eta),  1\&.0+TOLERANCE );
261               libmesh_assert_less_equal ( std::fabs(zeta), 1\&.0+TOLERANCE );
262 
263               switch (j)
264                 {
265                   // d()/dxi
266                 case 0:
267                   {
268                     switch(i)
269                       {
270                       case 0:
271                       case 2:
272                       case 8:
273                       case 10:
274                         return RealGradient();
275                       case 1:
276                         {
277                           if( elem->point(1) > elem->point(2) )
278                             return RealGradient( 0\&.0, -0\&.125*(1\&.0-zeta) );
279                           else
280                             return RealGradient( 0\&.0, 0\&.125*(1\&.0-zeta) );
281                         }
282                       case 3:
283                         {
284                           if( elem->point(3) > elem->point(0) )
285                             return RealGradient( 0\&.0, 0\&.125*(-1\&.0+zeta) );
286                           else
287                             return RealGradient( 0\&.0, -0\&.125*(-1\&.0+zeta) );
288                         }
289                       case 4:
290                         {
291                           if( elem->point(0) > elem->point(4) )
292                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(-1\&.0+eta) );
293                           else
294                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(-1\&.0+eta) );
295                         }
296                       case 5:
297                         {
298                           if( elem->point(1) > elem->point(5) )
299                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0-eta) );
300                           else
301                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0-eta) );
302                         }
303                       case 6:
304                         {
305                           if( elem->point(2) > elem->point(6) )
306                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0+eta) );
307                           else
308                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0+eta) );
309                         }
310                       case 7:
311                         {
312                           if( elem->point(3) > elem->point(7) )
313                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(-1\&.0-eta) );
314                           else
315                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(-1\&.0-eta) );
316                         }
317                       case 9:
318                         {
319                           if( elem->point(5) > elem->point(6) )
320                             return RealGradient( 0\&.0, -0\&.125*(1\&.0+zeta), 0\&.0 );
321                           else
322                             return RealGradient( 0\&.0,  0\&.125*(1\&.0+zeta), 0\&.0 );
323                         }
324                       case 11:
325                         {
326                           if( elem->point(4) > elem->point(7) )
327                             return RealGradient( 0\&.0, -0\&.125*(-1\&.0-zeta), 0\&.0 );
328                           else
329                             return RealGradient( 0\&.0,  0\&.125*(-1\&.0-zeta), 0\&.0 );
330                         }
331                       default:
332                         libmesh_error();
333                       } // switch(i)
334 
335                   } // j=0
336 
337                   // d()/deta
338                 case 1:
339                   {
340                     switch(i)
341                       {
342                       case 1:
343                       case 3:
344                       case 9:
345                       case 11:
346                         return RealGradient();
347                       case 0:
348                         {
349                           if( elem->point(0) > elem->point(1) )
350                             return RealGradient( -0\&.125*(-1\&.0+zeta), 0\&.0, 0\&.0 );
351                           else
352                             return RealGradient(  0\&.125*(-1\&.0+zeta), 0\&.0, 0\&.0 );
353                         }
354                       case 2:
355                         {
356                           if( elem->point(2) > elem->point(3) )
357                             return RealGradient( 0\&.125*(1\&.0-zeta), 0\&.0, 0\&.0 );
358                           else
359                             return RealGradient( -0\&.125*(1\&.0-zeta), 0\&.0, 0\&.0 );
360                         }
361                       case 4:
362                         {
363                           if( elem->point(0) > elem->point(4) )
364                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(-1\&.0+xi) );
365                           else
366                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(-1\&.0+xi) );
367                         }
368                       case 5:
369                         {
370                           if( elem->point(1) > elem->point(5) )
371                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(-1\&.0-xi) );
372                           else
373                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(-1\&.0-xi) );
374                         }
375                       case 6:
376                         {
377                           if( elem->point(2) > elem->point(6) )
378                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0+xi) );
379                           else
380                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0+xi) );
381                         }
382                       case 7:
383                         {
384                           if( elem->point(3) > elem->point(7) )
385                             return RealGradient( 0\&.0, 0\&.0, -0\&.125*(1\&.0-xi) );
386                           else
387                             return RealGradient( 0\&.0, 0\&.0,  0\&.125*(1\&.0-xi) );
388                         }
389                       case 8:
390                         {
391                           if( elem->point(4) > elem->point(5) )
392                             return RealGradient( -0\&.125*(-1\&.0-zeta), 0\&.0, 0\&.0 );
393                           else
394                             return RealGradient(  0\&.125*(-1\&.0-zeta), 0\&.0, 0\&.0 );
395                         }
396                       case 10:
397                         {
398                           if( elem->point(7) > elem->point(6) )
399                             return RealGradient( -0\&.125*(1\&.0+zeta), 0\&.0, 0\&.0 );
400                           else
401                             return RealGradient(  0\&.125*(1\&.0+zeta), 0\&.0, 0\&.0 );
402                         }
403                       default:
404                         libmesh_error();
405                       } // switch(i)
406 
407                   } // j=1
408 
409                   // d()/dzeta
410                 case 2:
411                   {
412                     switch(i)
413                       {
414                       case 4:
415                       case 5:
416                       case 6:
417                       case 7:
418                         return RealGradient();
419 
420                       case 0:
421                         {
422                           if( elem->point(0) > elem->point(1) )
423                             return RealGradient( -0\&.125*(-1\&.0+eta), 0\&.0, 0\&.0 );
424                           else
425                             return RealGradient(  0\&.125*(-1\&.0+eta), 0\&.0, 0\&.0 );
426                         }
427                       case 1:
428                         {
429                           if( elem->point(1) > elem->point(2) )
430                             return RealGradient( 0\&.0, -0\&.125*(-1\&.0-xi), 0\&.0 );
431                           else
432                             return RealGradient( 0\&.0,  0\&.125*(-1\&.0-xi), 0\&.0 );
433                         }
434                       case 2:
435                         {
436                           if( elem->point(2) > elem->point(3) )
437                             return RealGradient( 0\&.125*(-1\&.0-eta), 0\&.0, 0\&.0 );
438                           else
439                             return RealGradient( -0\&.125*(-1\&.0-eta), 0\&.0, 0\&.0 );
440                         }
441                       case 3:
442                         {
443                           if( elem->point(3) > elem->point(0) )
444                             return RealGradient( 0\&.0, 0\&.125*(-1\&.0+xi), 0\&.0 );
445                           else
446                             return RealGradient( 0\&.0,  -0\&.125*(-1\&.0+xi), 0\&.0 );
447                         }
448                       case 8:
449                         {
450                           if( elem->point(4) > elem->point(5) )
451                             return RealGradient( -0\&.125*(1\&.0-eta), 0\&.0, 0\&.0 );
452                           else
453                             return RealGradient(  0\&.125*(1\&.0-eta), 0\&.0, 0\&.0 );
454                         }
455                       case 9:
456                         {
457                           if( elem->point(5) > elem->point(6) )
458                             return RealGradient( 0\&.0, -0\&.125*(1\&.0+xi), 0\&.0 );
459                           else
460                             return RealGradient( 0\&.0,  0\&.125*(1\&.0+xi), 0\&.0 );
461                         }
462                       case 10:
463                         {
464                           if( elem->point(7) > elem->point(6) )
465                             return RealGradient( -0\&.125*(1\&.0+eta), 0\&.0, 0\&.0 );
466                           else
467                             return RealGradient(  0\&.125*(1\&.0+eta), 0\&.0, 0\&.0 );
468                         }
469                       case 11:
470                         {
471                           if( elem->point(4) > elem->point(7) )
472                             return RealGradient( 0\&.0, -0\&.125*(1\&.0-xi), 0\&.0 );
473                           else
474                             return RealGradient( 0\&.0,  0\&.125*(1\&.0-xi), 0\&.0 );
475                         }
476                       default:
477                         libmesh_error();
478                       } // switch(i)
479 
480                   } // j = 2
481 
482                 default:
483                   libmesh_error();
484                 }
485 
486               return RealGradient();
487             }
488 
489           case TET10:
490             {
491               libmesh_assert_less (i, 6);
492 
493               libmesh_not_implemented();
494               return RealGradient();
495             }
496 
497           default:
498             {
499               libMesh::err << "ERROR: Unsupported 3D element type!: " << elem->type()
500                            << std::endl;
501               libmesh_error();
502             }
503           }
504       }
505 
506       // unsupported order
507     default:
508       {
509         libMesh::err << "ERROR: Unsupported 3D FE order!: " << totalorder
510                      << std::endl;
511         libmesh_error();
512       }
513     }
514 
515 #endif
516 
517   libmesh_error();
518   return RealGradient();
519 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 232 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
237 {
238   libMesh::err << "Hierarchic polynomials require the element type\n"
239                << "because edge orientation is needed\&."
240                << std::endl;
241 
242   libmesh_error();
243   return 0\&.;
244 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 232 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
237 {
238   libMesh::err << "Hierarchic polynomials require the element type\n"
239                << "because edge orientation is needed\&."
240                << std::endl;
241 
242   libmesh_error();
243   return 0\&.;
244 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 235 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
240 {
241 #if LIBMESH_DIM > 1
242 
243 
244   libmesh_assert_less (j, 2);
245 
246   switch (order)
247     {
248       // linear Lagrange shape functions
249     case FIRST:
250       {
251         switch (type)
252           {
253           case QUAD4:
254           case QUAD8:
255           case QUAD9:
256             {
257               // Compute quad shape functions as a tensor-product
258               const Real xi  = p(0);
259               const Real eta = p(1);
260 
261               libmesh_assert_less (i, 4);
262 
263               //                                0  1  2  3
264               static const unsigned int i0[] = {0, 1, 1, 0};
265               static const unsigned int i1[] = {0, 0, 1, 1};
266 
267               switch (j)
268                 {
269                   // d()/dxi
270                 case 0:
271                   return (FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
272                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta));
273 
274                   // d()/deta
275                 case 1:
276                   return (FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
277                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta));
278 
279                 default:
280                   libmesh_error();
281                 }
282             }
283 
284           case TRI3:
285           case TRI6:
286             {
287               libmesh_assert_less (i, 3);
288 
289               const Real dzeta0dxi  = -1\&.;
290               const Real dzeta1dxi  = 1\&.;
291               const Real dzeta2dxi  = 0\&.;
292 
293               const Real dzeta0deta = -1\&.;
294               const Real dzeta1deta = 0\&.;
295               const Real dzeta2deta = 1\&.;
296 
297               switch (j)
298                 {
299                   // d()/dxi
300                 case 0:
301                   {
302                     switch(i)
303                       {
304                       case 0:
305                         return dzeta0dxi;
306 
307                       case 1:
308                         return dzeta1dxi;
309 
310                       case 2:
311                         return dzeta2dxi;
312 
313                       default:
314                         libmesh_error();
315                       }
316                   }
317                   // d()/deta
318                 case 1:
319                   {
320                     switch(i)
321                       {
322                       case 0:
323                         return dzeta0deta;
324 
325                       case 1:
326                         return dzeta1deta;
327 
328                       case 2:
329                         return dzeta2deta;
330 
331                       default:
332                         libmesh_error();
333 
334                       }
335                   }
336                 default:
337                   libmesh_error();
338                 }
339             }
340 
341           default:
342             {
343               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
344                            << std::endl;
345               libmesh_error();
346             }
347           }
348       }
349 
350 
351       // quadratic Lagrange shape functions
352     case SECOND:
353       {
354         switch (type)
355           {
356           case QUAD8:
357             {
358               const Real xi  = p(0);
359               const Real eta = p(1);
360 
361               libmesh_assert_less (i, 8);
362 
363               switch (j)
364                 {
365                   // d/dxi
366                 case 0:
367                   switch (i)
368                     {
369                     case 0:
370                       return \&.25*(1\&. - eta)*((1\&. - xi)*(-1\&.) +
371                                              (-1\&.)*(-1\&. - xi - eta));
372 
373                     case 1:
374                       return \&.25*(1\&. - eta)*((1\&. + xi)*(1\&.) +
375                                              (1\&.)*(-1\&. + xi - eta));
376 
377                     case 2:
378                       return \&.25*(1\&. + eta)*((1\&. + xi)*(1\&.) +
379                                              (1\&.)*(-1\&. + xi + eta));
380 
381                     case 3:
382                       return \&.25*(1\&. + eta)*((1\&. - xi)*(-1\&.) +
383                                              (-1\&.)*(-1\&. - xi + eta));
384 
385                     case 4:
386                       return \&.5*(-2\&.*xi)*(1\&. - eta);
387 
388                     case 5:
389                       return \&.5*(1\&.)*(1\&. - eta*eta);
390 
391                     case 6:
392                       return \&.5*(-2\&.*xi)*(1\&. + eta);
393 
394                     case 7:
395                       return \&.5*(-1\&.)*(1\&. - eta*eta);
396 
397                     default:
398                       libmesh_error();
399                     }
400 
401                   // d/deta
402                 case 1:
403                   switch (i)
404                     {
405                     case 0:
406                       return \&.25*(1\&. - xi)*((1\&. - eta)*(-1\&.) +
407                                             (-1\&.)*(-1\&. - xi - eta));
408 
409                     case 1:
410                       return \&.25*(1\&. + xi)*((1\&. - eta)*(-1\&.) +
411                                             (-1\&.)*(-1\&. + xi - eta));
412 
413                     case 2:
414                       return \&.25*(1\&. + xi)*((1\&. + eta)*(1\&.) +
415                                             (1\&.)*(-1\&. + xi + eta));
416 
417                     case 3:
418                       return \&.25*(1\&. - xi)*((1\&. + eta)*(1\&.) +
419                                             (1\&.)*(-1\&. - xi + eta));
420 
421                     case 4:
422                       return \&.5*(1\&. - xi*xi)*(-1\&.);
423 
424                     case 5:
425                       return \&.5*(1\&. + xi)*(-2\&.*eta);
426 
427                     case 6:
428                       return \&.5*(1\&. - xi*xi)*(1\&.);
429 
430                     case 7:
431                       return \&.5*(1\&. - xi)*(-2\&.*eta);
432 
433                     default:
434                       libmesh_error();
435                     }
436 
437                 default:
438                   libmesh_error();
439                 }
440             }
441 
442           case QUAD9:
443             {
444               // Compute quad shape functions as a tensor-product
445               const Real xi  = p(0);
446               const Real eta = p(1);
447 
448               libmesh_assert_less (i, 9);
449 
450               //                                0  1  2  3  4  5  6  7  8
451               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
452               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
453 
454               switch (j)
455                 {
456                   // d()/dxi
457                 case 0:
458                   return (FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
459                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta));
460 
461                   // d()/deta
462                 case 1:
463                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
464                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta));
465 
466                 default:
467                   libmesh_error();
468                 }
469             }
470 
471           case TRI6:
472             {
473               libmesh_assert_less (i, 6);
474 
475               const Real zeta1 = p(0);
476               const Real zeta2 = p(1);
477               const Real zeta0 = 1\&. - zeta1 - zeta2;
478 
479               const Real dzeta0dxi  = -1\&.;
480               const Real dzeta1dxi  = 1\&.;
481               const Real dzeta2dxi  = 0\&.;
482 
483               const Real dzeta0deta = -1\&.;
484               const Real dzeta1deta = 0\&.;
485               const Real dzeta2deta = 1\&.;
486 
487               switch(j)
488                 {
489                 case 0:
490                   {
491                     switch(i)
492                       {
493                       case 0:
494                         return (4\&.*zeta0-1\&.)*dzeta0dxi;
495 
496                       case 1:
497                         return (4\&.*zeta1-1\&.)*dzeta1dxi;
498 
499                       case 2:
500                         return (4\&.*zeta2-1\&.)*dzeta2dxi;
501 
502                       case 3:
503                         return 4\&.*zeta1*dzeta0dxi + 4\&.*zeta0*dzeta1dxi;
504 
505                       case 4:
506                         return 4\&.*zeta2*dzeta1dxi + 4\&.*zeta1*dzeta2dxi;
507 
508                       case 5:
509                         return 4\&.*zeta2*dzeta0dxi + 4*zeta0*dzeta2dxi;
510 
511                       default:
512                         libmesh_error();
513                       }
514                   }
515 
516                 case 1:
517                   {
518                     switch(i)
519                       {
520                       case 0:
521                         return (4\&.*zeta0-1\&.)*dzeta0deta;
522 
523                       case 1:
524                         return (4\&.*zeta1-1\&.)*dzeta1deta;
525 
526                       case 2:
527                         return (4\&.*zeta2-1\&.)*dzeta2deta;
528 
529                       case 3:
530                         return 4\&.*zeta1*dzeta0deta + 4\&.*zeta0*dzeta1deta;
531 
532                       case 4:
533                         return 4\&.*zeta2*dzeta1deta + 4\&.*zeta1*dzeta2deta;
534 
535                       case 5:
536                         return 4\&.*zeta2*dzeta0deta + 4*zeta0*dzeta2deta;
537 
538                       default:
539                         libmesh_error();
540                       }
541                   }
542                 default:
543                   libmesh_error();
544                 }
545             }
546 
547           default:
548             {
549               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
550                            << std::endl;
551               libmesh_error();
552             }
553           }
554       }
555 
556 
557 
558       // unsupported order
559     default:
560       {
561         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
562                      << std::endl;
563         libmesh_error();
564       }
565     }
566 
567 
568   libmesh_error();
569 #endif // LIBMESH_DIM > 1
570   return 0\&.;
571 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 236 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
241 {
242 #if LIBMESH_DIM > 1
243 
244 
245   libmesh_assert_less (j, 2);
246 
247   switch (order)
248     {
249       // linear Lagrange shape functions
250     case FIRST:
251       {
252         switch (type)
253           {
254           case QUAD4:
255           case QUAD8:
256           case QUAD9:
257             {
258               // Compute quad shape functions as a tensor-product
259               const Real xi  = p(0);
260               const Real eta = p(1);
261 
262               libmesh_assert_less (i, 4);
263 
264               //                                0  1  2  3
265               static const unsigned int i0[] = {0, 1, 1, 0};
266               static const unsigned int i1[] = {0, 0, 1, 1};
267 
268               switch (j)
269                 {
270                   // d()/dxi
271                 case 0:
272                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
273                           FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta));
274 
275                   // d()/deta
276                 case 1:
277                   return (FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
278                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta));
279 
280                 default:
281                   libmesh_error();
282                 }
283             }
284 
285           case TRI3:
286           case TRI6:
287             {
288               libmesh_assert_less (i, 3);
289 
290               const Real dzeta0dxi  = -1\&.;
291               const Real dzeta1dxi  = 1\&.;
292               const Real dzeta2dxi  = 0\&.;
293 
294               const Real dzeta0deta = -1\&.;
295               const Real dzeta1deta = 0\&.;
296               const Real dzeta2deta = 1\&.;
297 
298               switch (j)
299                 {
300                   // d()/dxi
301                 case 0:
302                   {
303                     switch(i)
304                       {
305                       case 0:
306                         return dzeta0dxi;
307 
308                       case 1:
309                         return dzeta1dxi;
310 
311                       case 2:
312                         return dzeta2dxi;
313 
314                       default:
315                         libmesh_error();
316                       }
317                   }
318                   // d()/deta
319                 case 1:
320                   {
321                     switch(i)
322                       {
323                       case 0:
324                         return dzeta0deta;
325 
326                       case 1:
327                         return dzeta1deta;
328 
329                       case 2:
330                         return dzeta2deta;
331 
332                       default:
333                         libmesh_error();
334 
335                       }
336                   }
337                 default:
338                   libmesh_error();
339                 }
340             }
341 
342           default:
343             {
344               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
345                            << std::endl;
346               libmesh_error();
347             }
348           }
349       }
350 
351 
352       // quadratic Lagrange shape functions
353     case SECOND:
354       {
355         switch (type)
356           {
357           case QUAD8:
358             {
359               const Real xi  = p(0);
360               const Real eta = p(1);
361 
362               libmesh_assert_less (i, 8);
363 
364               switch (j)
365                 {
366                   // d/dxi
367                 case 0:
368                   switch (i)
369                     {
370                     case 0:
371                       return \&.25*(1\&. - eta)*((1\&. - xi)*(-1\&.) +
372                                              (-1\&.)*(-1\&. - xi - eta));
373 
374                     case 1:
375                       return \&.25*(1\&. - eta)*((1\&. + xi)*(1\&.) +
376                                              (1\&.)*(-1\&. + xi - eta));
377 
378                     case 2:
379                       return \&.25*(1\&. + eta)*((1\&. + xi)*(1\&.) +
380                                              (1\&.)*(-1\&. + xi + eta));
381 
382                     case 3:
383                       return \&.25*(1\&. + eta)*((1\&. - xi)*(-1\&.) +
384                                              (-1\&.)*(-1\&. - xi + eta));
385 
386                     case 4:
387                       return \&.5*(-2\&.*xi)*(1\&. - eta);
388 
389                     case 5:
390                       return \&.5*(1\&.)*(1\&. - eta*eta);
391 
392                     case 6:
393                       return \&.5*(-2\&.*xi)*(1\&. + eta);
394 
395                     case 7:
396                       return \&.5*(-1\&.)*(1\&. - eta*eta);
397 
398                     default:
399                       libmesh_error();
400                     }
401 
402                   // d/deta
403                 case 1:
404                   switch (i)
405                     {
406                     case 0:
407                       return \&.25*(1\&. - xi)*((1\&. - eta)*(-1\&.) +
408                                             (-1\&.)*(-1\&. - xi - eta));
409 
410                     case 1:
411                       return \&.25*(1\&. + xi)*((1\&. - eta)*(-1\&.) +
412                                             (-1\&.)*(-1\&. + xi - eta));
413 
414                     case 2:
415                       return \&.25*(1\&. + xi)*((1\&. + eta)*(1\&.) +
416                                             (1\&.)*(-1\&. + xi + eta));
417 
418                     case 3:
419                       return \&.25*(1\&. - xi)*((1\&. + eta)*(1\&.) +
420                                             (1\&.)*(-1\&. - xi + eta));
421 
422                     case 4:
423                       return \&.5*(1\&. - xi*xi)*(-1\&.);
424 
425                     case 5:
426                       return \&.5*(1\&. + xi)*(-2\&.*eta);
427 
428                     case 6:
429                       return \&.5*(1\&. - xi*xi)*(1\&.);
430 
431                     case 7:
432                       return \&.5*(1\&. - xi)*(-2\&.*eta);
433 
434                     default:
435                       libmesh_error();
436                     }
437 
438                 default:
439                   libmesh_error();
440                 }
441             }
442 
443           case QUAD9:
444             {
445               // Compute quad shape functions as a tensor-product
446               const Real xi  = p(0);
447               const Real eta = p(1);
448 
449               libmesh_assert_less (i, 9);
450 
451               //                                0  1  2  3  4  5  6  7  8
452               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
453               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
454 
455               switch (j)
456                 {
457                   // d()/dxi
458                 case 0:
459                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
460                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta));
461 
462                   // d()/deta
463                 case 1:
464                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
465                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta));
466 
467                 default:
468                   libmesh_error();
469                 }
470             }
471 
472           case TRI6:
473             {
474               libmesh_assert_less (i, 6);
475 
476               const Real zeta1 = p(0);
477               const Real zeta2 = p(1);
478               const Real zeta0 = 1\&. - zeta1 - zeta2;
479 
480               const Real dzeta0dxi  = -1\&.;
481               const Real dzeta1dxi  = 1\&.;
482               const Real dzeta2dxi  = 0\&.;
483 
484               const Real dzeta0deta = -1\&.;
485               const Real dzeta1deta = 0\&.;
486               const Real dzeta2deta = 1\&.;
487 
488               switch(j)
489                 {
490                 case 0:
491                   {
492                     switch(i)
493                       {
494                       case 0:
495                         return (4\&.*zeta0-1\&.)*dzeta0dxi;
496 
497                       case 1:
498                         return (4\&.*zeta1-1\&.)*dzeta1dxi;
499 
500                       case 2:
501                         return (4\&.*zeta2-1\&.)*dzeta2dxi;
502 
503                       case 3:
504                         return 4\&.*zeta1*dzeta0dxi + 4\&.*zeta0*dzeta1dxi;
505 
506                       case 4:
507                         return 4\&.*zeta2*dzeta1dxi + 4\&.*zeta1*dzeta2dxi;
508 
509                       case 5:
510                         return 4\&.*zeta2*dzeta0dxi + 4*zeta0*dzeta2dxi;
511 
512                       default:
513                         libmesh_error();
514                       }
515                   }
516 
517                 case 1:
518                   {
519                     switch(i)
520                       {
521                       case 0:
522                         return (4\&.*zeta0-1\&.)*dzeta0deta;
523 
524                       case 1:
525                         return (4\&.*zeta1-1\&.)*dzeta1deta;
526 
527                       case 2:
528                         return (4\&.*zeta2-1\&.)*dzeta2deta;
529 
530                       case 3:
531                         return 4\&.*zeta1*dzeta0deta + 4\&.*zeta0*dzeta1deta;
532 
533                       case 4:
534                         return 4\&.*zeta2*dzeta1deta + 4\&.*zeta1*dzeta2deta;
535 
536                       case 5:
537                         return 4\&.*zeta2*dzeta0deta + 4*zeta0*dzeta2deta;
538 
539                       default:
540                         libmesh_error();
541                       }
542                   }
543                 default:
544                   libmesh_error();
545                 }
546             }
547 
548           default:
549             {
550               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
551                            << std::endl;
552               libmesh_error();
553             }
554           }
555       }
556 
557 
558 
559       // unsupported order
560     default:
561       {
562         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
563                      << std::endl;
564         libmesh_error();
565       }
566     }
567 
568 
569   libmesh_error();
570   return 0\&.;
571 
572 #endif
573 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 238 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
243 {
244   libmesh_assert(elem);
245 
246   return FE<1,L2_LAGRANGE>::shape_deriv(elem->type(),
247                                         static_cast<Order>(order + elem->p_level()), i, j, p);
248 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 238 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
243 {
244   libmesh_assert(elem);
245 
246   return FE<1,LAGRANGE>::shape_deriv(elem->type(),
247                                      static_cast<Order>(order + elem->p_level()), i, j, p);
248 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 249 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::square_number_column, libMesh::square_number_row, libMesh::TRI3, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
254 {
255   libmesh_assert(elem);
256 
257   const ElemType type = elem->type();
258 
259   const Order totalorder = static_cast<Order>(order+elem->p_level());
260 
261   libmesh_assert_greater (totalorder, 0);
262 
263   switch (type)
264     {
265       // 1st & 2nd-order Hierarchics\&.
266     case TRI3:
267     case TRI6:
268       {
269         const Real eps = 1\&.e-6;
270 
271         libmesh_assert_less (j, 2);
272 
273         switch (j)
274           {
275             //  d()/dxi
276           case 0:
277             {
278               const Point pp(p(0)+eps, p(1));
279               const Point pm(p(0)-eps, p(1));
280 
281               return (FE<2,L2_HIERARCHIC>::shape(elem, order, i, pp) -
282                       FE<2,L2_HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
283             }
284 
285             // d()/deta
286           case 1:
287             {
288               const Point pp(p(0), p(1)+eps);
289               const Point pm(p(0), p(1)-eps);
290 
291               return (FE<2,L2_HIERARCHIC>::shape(elem, order, i, pp) -
292                       FE<2,L2_HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
293             }
294 
295 
296           default:
297             libmesh_error();
298           }
299       }
300 
301     case QUAD4:
302       libmesh_assert_less (totalorder, 2);
303     case QUAD8:
304     case QUAD9:
305       {
306         // Compute quad shape functions as a tensor-product
307         const Real xi  = p(0);
308         const Real eta = p(1);
309 
310         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
311 
312         // Example i, i0, i1 values for totalorder = 5:
313         //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
314         //  static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
315         //  static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
316 
317         unsigned int i0, i1;
318 
319         // Vertex DoFs
320         if (i == 0)
321           { i0 = 0; i1 = 0; }
322         else if (i == 1)
323           { i0 = 1; i1 = 0; }
324         else if (i == 2)
325           { i0 = 1; i1 = 1; }
326         else if (i == 3)
327           { i0 = 0; i1 = 1; }
328         // Edge DoFs
329         else if (i < totalorder + 3u)
330           { i0 = i - 2; i1 = 0; }
331         else if (i < 2u*totalorder + 2)
332           { i0 = 1; i1 = i - totalorder - 1; }
333         else if (i < 3u*totalorder + 1u)
334           { i0 = i - 2u*totalorder; i1 = 1; }
335         else if (i < 4u*totalorder)
336           { i0 = 0; i1 = i - 3u*totalorder + 1; }
337         // Interior DoFs
338         else
339           {
340             unsigned int basisnum = i - 4*totalorder;
341             i0 = square_number_column[basisnum] + 2;
342             i1 = square_number_row[basisnum] + 2;
343           }
344 
345         // Flip odd degree of freedom values if necessary
346         // to keep continuity on sides
347         Real f = 1\&.;
348 
349         if ((i0%2) && (i0 > 2) && (i1 == 0))
350           f = (elem->point(0) > elem->point(1))?-1\&.:1\&.;
351         else if ((i0%2) && (i0>2) && (i1 == 1))
352           f = (elem->point(3) > elem->point(2))?-1\&.:1\&.;
353         else if ((i0 == 0) && (i1%2) && (i1>2))
354           f = (elem->point(0) > elem->point(3))?-1\&.:1\&.;
355         else if ((i0 == 1) && (i1%2) && (i1>2))
356           f = (elem->point(1) > elem->point(2))?-1\&.:1\&.;
357 
358         switch (j)
359           {
360             // d()/dxi
361           case 0:
362             return f*(FE<1,L2_HIERARCHIC>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
363                       FE<1,L2_HIERARCHIC>::shape      (EDGE3, totalorder, i1,    eta));
364 
365             // d()/deta
366           case 1:
367             return f*(FE<1,L2_HIERARCHIC>::shape      (EDGE3, totalorder, i0,    xi)*
368                       FE<1,L2_HIERARCHIC>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
369 
370           default:
371             libmesh_error();
372           }
373 
374       }
375 
376     default:
377       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
378       libmesh_error();
379     }
380 
381   return 0\&.;
382 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 249 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::square_number_column, libMesh::square_number_row, libMesh::TRI3, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
254 {
255   libmesh_assert(elem);
256 
257   const ElemType type = elem->type();
258 
259   const Order totalorder = static_cast<Order>(order+elem->p_level());
260 
261   libmesh_assert_greater (totalorder, 0);
262 
263   switch (type)
264     {
265       // 1st & 2nd-order Hierarchics\&.
266     case TRI3:
267     case TRI6:
268       {
269         const Real eps = 1\&.e-6;
270 
271         libmesh_assert_less (j, 2);
272 
273         switch (j)
274           {
275             //  d()/dxi
276           case 0:
277             {
278               const Point pp(p(0)+eps, p(1));
279               const Point pm(p(0)-eps, p(1));
280 
281               return (FE<2,HIERARCHIC>::shape(elem, order, i, pp) -
282                       FE<2,HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
283             }
284 
285             // d()/deta
286           case 1:
287             {
288               const Point pp(p(0), p(1)+eps);
289               const Point pm(p(0), p(1)-eps);
290 
291               return (FE<2,HIERARCHIC>::shape(elem, order, i, pp) -
292                       FE<2,HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
293             }
294 
295 
296           default:
297             libmesh_error();
298           }
299       }
300 
301     case QUAD4:
302       libmesh_assert_less (totalorder, 2);
303     case QUAD8:
304     case QUAD9:
305       {
306         // Compute quad shape functions as a tensor-product
307         const Real xi  = p(0);
308         const Real eta = p(1);
309 
310         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
311 
312         // Example i, i0, i1 values for totalorder = 5:
313         //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
314         //  static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
315         //  static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
316 
317         unsigned int i0, i1;
318 
319         // Vertex DoFs
320         if (i == 0)
321           { i0 = 0; i1 = 0; }
322         else if (i == 1)
323           { i0 = 1; i1 = 0; }
324         else if (i == 2)
325           { i0 = 1; i1 = 1; }
326         else if (i == 3)
327           { i0 = 0; i1 = 1; }
328         // Edge DoFs
329         else if (i < totalorder + 3u)
330           { i0 = i - 2; i1 = 0; }
331         else if (i < 2u*totalorder + 2)
332           { i0 = 1; i1 = i - totalorder - 1; }
333         else if (i < 3u*totalorder + 1u)
334           { i0 = i - 2u*totalorder; i1 = 1; }
335         else if (i < 4u*totalorder)
336           { i0 = 0; i1 = i - 3u*totalorder + 1; }
337         // Interior DoFs
338         else
339           {
340             unsigned int basisnum = i - 4*totalorder;
341             i0 = square_number_column[basisnum] + 2;
342             i1 = square_number_row[basisnum] + 2;
343           }
344 
345         // Flip odd degree of freedom values if necessary
346         // to keep continuity on sides
347         Real f = 1\&.;
348 
349         if ((i0%2) && (i0 > 2) && (i1 == 0))
350           f = (elem->point(0) > elem->point(1))?-1\&.:1\&.;
351         else if ((i0%2) && (i0>2) && (i1 == 1))
352           f = (elem->point(3) > elem->point(2))?-1\&.:1\&.;
353         else if ((i0 == 0) && (i1%2) && (i1>2))
354           f = (elem->point(0) > elem->point(3))?-1\&.:1\&.;
355         else if ((i0 == 1) && (i1%2) && (i1>2))
356           f = (elem->point(1) > elem->point(2))?-1\&.:1\&.;
357 
358         switch (j)
359           {
360             // d()/dxi
361           case 0:
362             return f*(FE<1,HIERARCHIC>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
363                       FE<1,HIERARCHIC>::shape      (EDGE3, totalorder, i1,    eta));
364 
365             // d()/deta
366           case 1:
367             return f*(FE<1,HIERARCHIC>::shape      (EDGE3, totalorder, i0,    xi)*
368                       FE<1,HIERARCHIC>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
369 
370           default:
371             libmesh_error();
372           }
373 
374       }
375 
376     default:
377       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
378       libmesh_error();
379     }
380 
381   return 0\&.;
382 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 253 of file fe_xyz_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
258 {
259   libMesh::err << "XYZ polynomials require the element\n"
260                << "because the centroid is needed\&."
261                << std::endl;
262 
263   libmesh_error();
264   return 0\&.;
265 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 255 of file fe_clough_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
260 {
261   libMesh::err << "Clough-Tocher elements require the real element\n"
262                << "to construct gradient-based degrees of freedom\&."
263                << std::endl;
264 
265   libmesh_error();
266   return 0\&.;
267 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 255 of file fe_hermite_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
260 {
261   libMesh::err << "Hermite elements require the real element\n"
262                << "to construct gradient-based degrees of freedom\&."
263                << std::endl;
264 
265   libmesh_error();
266   return 0\&.;
267 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 266 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
271 {
272   libMesh::err << "Hermite elements require the real element\n"
273                << "to construct gradient-based degrees of freedom\&."
274                << std::endl;
275 
276   libmesh_error();
277   return 0\&.;
278 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &point_in)"

.PP
Definition at line 270 of file fe_xyz_shape_3D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, and libMesh::x\&.
.PP
.nf
275 {
276 #if LIBMESH_DIM == 3
277 
278   libmesh_assert(elem);
279   libmesh_assert_less (j, 3);
280 
281   // Only recompute the centroid if the element
282   // has changed from the last one we computed\&.
283   // This avoids repeated centroid calculations
284   // when called in succession with the same element\&.
285   if (elem->id() != old_elem_id)
286     {
287       centroid = elem->centroid();
288       old_elem_id = elem->id();
289       max_distance = Point(0\&.,0\&.,0\&.);
290       for (unsigned int p = 0; p < elem->n_nodes(); p++)
291         for (unsigned int d = 0; d < 3; d++)
292           {
293             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
294             max_distance(d) = std::max(distance, max_distance(d));
295           }
296     }
297 
298   // Using static globals for old_elem_id, etc\&. will fail
299   // horribly with more than one thread\&.
300   libmesh_assert_equal_to (libMesh::n_threads(), 1);
301 
302   const Real x  = point_in(0);
303   const Real y  = point_in(1);
304   const Real z  = point_in(2);
305   const Real xc = centroid(0);
306   const Real yc = centroid(1);
307   const Real zc = centroid(2);
308   const Real distx = max_distance(0);
309   const Real disty = max_distance(1);
310   const Real distz = max_distance(2);
311   const Real dx = (x - xc)/distx;
312   const Real dy = (y - yc)/disty;
313   const Real dz = (z - zc)/distz;
314 
315 #ifndef NDEBUG
316   // totalorder is only used in the assertion below, so
317   // we avoid declaring it when asserts are not active\&.
318   const unsigned int totalorder = static_cast<Order>(order + elem->p_level());
319 #endif
320   libmesh_assert_less (i, (static_cast<unsigned int>(totalorder)+1)*
321                        (static_cast<unsigned int>(totalorder)+2)*
322                        (static_cast<unsigned int>(totalorder)+3)/6);
323 
324   switch (j)
325     {
326       // d()/dx
327     case 0:
328       {
329         switch (i)
330           {
331             // constant
332           case 0:
333             return 0\&.;
334 
335             // linear
336           case 1:
337             return 1\&./distx;
338 
339           case 2:
340             return 0\&.;
341 
342           case 3:
343             return 0\&.;
344 
345             // quadratic
346           case 4:
347             return 2\&.*dx/distx;
348 
349           case 5:
350             return dy/distx;
351 
352           case 6:
353             return 0\&.;
354 
355           case 7:
356             return dz/distx;
357 
358           case 8:
359             return 0\&.;
360 
361           case 9:
362             return 0\&.;
363 
364             // cubic
365           case 10:
366             return 3\&.*dx*dx/distx;
367 
368           case 11:
369             return 2\&.*dx*dy/distx;
370 
371           case 12:
372             return dy*dy/distx;
373 
374           case 13:
375             return 0\&.;
376 
377           case 14:
378             return 2\&.*dx*dz/distx;
379 
380           case 15:
381             return dy*dz/distx;
382 
383           case 16:
384             return 0\&.;
385 
386           case 17:
387             return dz*dz/distx;
388 
389           case 18:
390             return 0\&.;
391 
392           case 19:
393             return 0\&.;
394 
395             // quartics
396           case 20:
397             return 4\&.*dx*dx*dx/distx;
398 
399           case 21:
400             return 3\&.*dx*dx*dy/distx;
401 
402           case 22:
403             return 2\&.*dx*dy*dy/distx;
404 
405           case 23:
406             return dy*dy*dy/distx;
407 
408           case 24:
409             return 0\&.;
410 
411           case 25:
412             return 3\&.*dx*dx*dz/distx;
413 
414           case 26:
415             return 2\&.*dx*dy*dz/distx;
416 
417           case 27:
418             return dy*dy*dz/distx;
419 
420           case 28:
421             return 0\&.;
422 
423           case 29:
424             return 2\&.*dx*dz*dz/distx;
425 
426           case 30:
427             return dy*dz*dz/distx;
428 
429           case 31:
430             return 0\&.;
431 
432           case 32:
433             return dz*dz*dz/distx;
434 
435           case 33:
436             return 0\&.;
437 
438           case 34:
439             return 0\&.;
440 
441           default:
442             unsigned int o = 0;
443             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
444             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
445             unsigned int block=o, nz = 0;
446             for (; block < i2; block += (o-nz+1)) { nz++; }
447             const unsigned int nx = block - i2;
448             const unsigned int ny = o - nx - nz;
449             Real val = nx;
450             for (unsigned int index=1; index < nx; index++)
451               val *= dx;
452             for (unsigned int index=0; index != ny; index++)
453               val *= dy;
454             for (unsigned int index=0; index != nz; index++)
455               val *= dz;
456             return val/distx;
457           }
458       }
459 
460 
461       // d()/dy
462     case 1:
463       {
464         switch (i)
465           {
466             // constant
467           case 0:
468             return 0\&.;
469 
470             // linear
471           case 1:
472             return 0\&.;
473 
474           case 2:
475             return 1\&./disty;
476 
477           case 3:
478             return 0\&.;
479 
480             // quadratic
481           case 4:
482             return 0\&.;
483 
484           case 5:
485             return dx/disty;
486 
487           case 6:
488             return 2\&.*dy/disty;
489 
490           case 7:
491             return 0\&.;
492 
493           case 8:
494             return dz/disty;
495 
496           case 9:
497             return 0\&.;
498 
499             // cubic
500           case 10:
501             return 0\&.;
502 
503           case 11:
504             return dx*dx/disty;
505 
506           case 12:
507             return 2\&.*dx*dy/disty;
508 
509           case 13:
510             return 3\&.*dy*dy/disty;
511 
512           case 14:
513             return 0\&.;
514 
515           case 15:
516             return dx*dz/disty;
517 
518           case 16:
519             return 2\&.*dy*dz/disty;
520 
521           case 17:
522             return 0\&.;
523 
524           case 18:
525             return dz*dz/disty;
526 
527           case 19:
528             return 0\&.;
529 
530             // quartics
531           case 20:
532             return 0\&.;
533 
534           case 21:
535             return dx*dx*dx/disty;
536 
537           case 22:
538             return 2\&.*dx*dx*dy/disty;
539 
540           case 23:
541             return 3\&.*dx*dy*dy/disty;
542 
543           case 24:
544             return 4\&.*dy*dy*dy/disty;
545 
546           case 25:
547             return 0\&.;
548 
549           case 26:
550             return dx*dx*dz/disty;
551 
552           case 27:
553             return 2\&.*dx*dy*dz/disty;
554 
555           case 28:
556             return 3\&.*dy*dy*dz/disty;
557 
558           case 29:
559             return 0\&.;
560 
561           case 30:
562             return dx*dz*dz/disty;
563 
564           case 31:
565             return 2\&.*dy*dz*dz/disty;
566 
567           case 32:
568             return 0\&.;
569 
570           case 33:
571             return dz*dz*dz/disty;
572 
573           case 34:
574             return 0\&.;
575 
576           default:
577             unsigned int o = 0;
578             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
579             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
580             unsigned int block=o, nz = 0;
581             for (; block < i2; block += (o-nz+1)) { nz++; }
582             const unsigned int nx = block - i2;
583             const unsigned int ny = o - nx - nz;
584             Real val = ny;
585             for (unsigned int index=0; index != nx; index++)
586               val *= dx;
587             for (unsigned int index=1; index < ny; index++)
588               val *= dy;
589             for (unsigned int index=0; index != nz; index++)
590               val *= dz;
591             return val/disty;
592           }
593       }
594 
595 
596       // d()/dz
597     case 2:
598       {
599         switch (i)
600           {
601             // constant
602           case 0:
603             return 0\&.;
604 
605             // linear
606           case 1:
607             return 0\&.;
608 
609           case 2:
610             return 0\&.;
611 
612           case 3:
613             return 1\&./distz;
614 
615             // quadratic
616           case 4:
617             return 0\&.;
618 
619           case 5:
620             return 0\&.;
621 
622           case 6:
623             return 0\&.;
624 
625           case 7:
626             return dx/distz;
627 
628           case 8:
629             return dy/distz;
630 
631           case 9:
632             return 2\&.*dz/distz;
633 
634             // cubic
635           case 10:
636             return 0\&.;
637 
638           case 11:
639             return 0\&.;
640 
641           case 12:
642             return 0\&.;
643 
644           case 13:
645             return 0\&.;
646 
647           case 14:
648             return dx*dx/distz;
649 
650           case 15:
651             return dx*dy/distz;
652 
653           case 16:
654             return dy*dy/distz;
655 
656           case 17:
657             return 2\&.*dx*dz/distz;
658 
659           case 18:
660             return 2\&.*dy*dz/distz;
661 
662           case 19:
663             return 3\&.*dz*dz/distz;
664 
665             // quartics
666           case 20:
667             return 0\&.;
668 
669           case 21:
670             return 0\&.;
671 
672           case 22:
673             return 0\&.;
674 
675           case 23:
676             return 0\&.;
677 
678           case 24:
679             return 0\&.;
680 
681           case 25:
682             return dx*dx*dx/distz;
683 
684           case 26:
685             return dx*dx*dy/distz;
686 
687           case 27:
688             return dx*dy*dy/distz;
689 
690           case 28:
691             return dy*dy*dy/distz;
692 
693           case 29:
694             return 2\&.*dx*dx*dz/distz;
695 
696           case 30:
697             return 2\&.*dx*dy*dz/distz;
698 
699           case 31:
700             return 2\&.*dy*dy*dz/distz;
701 
702           case 32:
703             return 3\&.*dx*dz*dz/distz;
704 
705           case 33:
706             return 3\&.*dy*dz*dz/distz;
707 
708           case 34:
709             return 4\&.*dz*dz*dz/distz;
710 
711           default:
712             unsigned int o = 0;
713             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
714             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
715             unsigned int block=o, nz = 0;
716             for (; block < i2; block += (o-nz+1)) { nz++; }
717             const unsigned int nx = block - i2;
718             const unsigned int ny = o - nx - nz;
719             Real val = nz;
720             for (unsigned int index=0; index != nx; index++)
721               val *= dx;
722             for (unsigned int index=0; index != ny; index++)
723               val *= dy;
724             for (unsigned int index=1; index < nz; index++)
725               val *= dz;
726             return val/distz;
727           }
728       }
729 
730 
731     default:
732       libmesh_error();
733     }
734 
735 #endif
736 
737   libmesh_error();
738   return 0\&.;
739 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 272 of file fe_hermite_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, and libMesh::Elem::type()\&.
.PP
.nf
277 {
278   libmesh_assert(elem);
279   libmesh_assert (j == 0 || j == 1);
280 
281   std::vector<std::vector<Real> > dxdxi(2, std::vector<Real>(2, 0));
282 
283 #ifdef DEBUG
284   std::vector<Real> dxdeta(2), dydxi(2);
285 #endif
286 
287   hermite_compute_coefs(elem,dxdxi
288 #ifdef DEBUG
289                         ,dxdeta,dydxi
290 #endif
291                         );
292 
293   const ElemType type = elem->type();
294 
295   const Order totalorder = static_cast<Order>(order + elem->p_level());
296 
297   switch (type)
298     {
299     case QUAD4:
300       libmesh_assert_less (totalorder, 4);
301     case QUAD8:
302     case QUAD9:
303       {
304         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
305 
306         std::vector<unsigned int> bases1D;
307 
308         Real coef = hermite_bases_2D(bases1D, dxdxi, totalorder, i);
309 
310         switch (j)
311           {
312           case 0:
313             return coef *
314               FEHermite<1>::hermite_raw_shape_deriv(bases1D[0],p(0)) *
315               FEHermite<1>::hermite_raw_shape(bases1D[1],p(1));
316           case 1:
317             return coef *
318               FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
319               FEHermite<1>::hermite_raw_shape_deriv(bases1D[1],p(1));
320           default:
321             libmesh_error();
322           }
323       }
324     default:
325       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
326       libmesh_error();
327     }
328 
329   libmesh_error();
330   return 0\&.;
331 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 272 of file fe_clough_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
277 {
278   libmesh_assert(elem);
279 
280   clough_compute_coefs(elem);
281 
282   const ElemType type = elem->type();
283 
284   const Order totalorder = static_cast<Order>(order + elem->p_level());
285 
286   switch (totalorder)
287     {
288       // 3rd-order C1 cubic element
289     case THIRD:
290       {
291         switch (type)
292           {
293             // C1 functions on the C1 cubic edge
294           case EDGE2:
295           case EDGE3:
296             {
297               switch (i)
298                 {
299                 case 0:
300                   return clough_raw_shape_deriv(0, j, p);
301                 case 1:
302                   return clough_raw_shape_deriv(1, j, p);
303                 case 2:
304                   return d1xd1x * clough_raw_shape_deriv(2, j, p);
305                 case 3:
306                   return d2xd2x * clough_raw_shape_deriv(3, j, p);
307                 default:
308                   libmesh_error();
309                 }
310             }
311           default:
312             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
313             libmesh_error();
314           }
315       }
316       // by default throw an error
317     default:
318       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
319       libmesh_error();
320     }
321 
322   libmesh_error();
323   return 0\&.;
324 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsignedint, const \fBPoint\fP &p)"

.PP
Definition at line 283 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
288 {
289   libmesh_assert(elem);
290 
291   // Coefficient naming: d(1)d(2n) is the coefficient of the
292   // global shape function corresponding to value 1 in terms of the
293   // local shape function corresponding to normal derivative 2
294   Real d1xd1x, d2xd2x;
295 
296   hermite_compute_coefs(elem, d1xd1x, d2xd2x);
297 
298   const ElemType type = elem->type();
299 
300   const Order totalorder = static_cast<Order>(order + elem->p_level());
301 
302   switch (totalorder)
303     {
304       // Hermite cubic shape functions
305     case THIRD:
306       {
307         switch (type)
308           {
309             // C1 functions on the C1 cubic edge
310           case EDGE2:
311           case EDGE3:
312             {
313               switch (i)
314                 {
315                 case 0:
316                   return FEHermite<1>::hermite_raw_shape_deriv(0, p(0));
317                 case 1:
318                   return d1xd1x * FEHermite<1>::hermite_raw_shape_deriv(2, p(0));
319                 case 2:
320                   return FEHermite<1>::hermite_raw_shape_deriv(1, p(0));
321                 case 3:
322                   return d2xd2x * FEHermite<1>::hermite_raw_shape_deriv(3, p(0));
323                 default:
324                   return FEHermite<1>::hermite_raw_shape_deriv(i, p(0));
325                 }
326             }
327           default:
328             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
329             libmesh_error();
330           }
331       }
332       // by default throw an error
333     default:
334       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
335       libmesh_error();
336     }
337 
338   libmesh_error();
339   return 0\&.;
340 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 303 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
308 {
309   libmesh_assert(elem);
310 
311   // by default call the orientation-independent shape functions
312   return FE<2,MONOMIAL>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
313 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 384 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
389 {
390   libmesh_assert(elem);
391 
392   return FE<1,BERNSTEIN>::shape_deriv(elem->type(),
393                                       static_cast<Order>(order + elem->p_level()), i, j, p);
394 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 386 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID5, libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI6, and libMesh::x\&.
.PP
.nf
391 {
392 #if LIBMESH_DIM == 3
393 
394   libmesh_assert_less (j, 3);
395 
396   switch (order)
397     {
398       // linear Lagrange shape functions
399     case FIRST:
400       {
401         switch (type)
402           {
403             // trilinear hexahedral shape functions
404           case HEX8:
405           case HEX20:
406           case HEX27:
407             {
408               libmesh_assert_less (i, 8);
409 
410               // Compute hex shape functions as a tensor-product
411               const Real xi   = p(0);
412               const Real eta  = p(1);
413               const Real zeta = p(2);
414 
415               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
416               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
417               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
418 
419               switch(j)
420                 {
421                 case 0:
422                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
423                           FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta)*
424                           FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i2[i], zeta));
425 
426                 case 1:
427                   return (FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
428                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta)*
429                           FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i2[i], zeta));
430 
431                 case 2:
432                   return (FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
433                           FE<1,L2_LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta)*
434                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i2[i], 0, zeta));
435 
436                 default:
437                   {
438                     libmesh_error();
439                   }
440                 }
441             }
442 
443             // linear tetrahedral shape functions
444           case TET4:
445           case TET10:
446             {
447               libmesh_assert_less (i, 4);
448 
449               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
450               const Real dzeta0dxi = -1\&.;
451               const Real dzeta1dxi =  1\&.;
452               const Real dzeta2dxi =  0\&.;
453               const Real dzeta3dxi =  0\&.;
454 
455               const Real dzeta0deta = -1\&.;
456               const Real dzeta1deta =  0\&.;
457               const Real dzeta2deta =  1\&.;
458               const Real dzeta3deta =  0\&.;
459 
460               const Real dzeta0dzeta = -1\&.;
461               const Real dzeta1dzeta =  0\&.;
462               const Real dzeta2dzeta =  0\&.;
463               const Real dzeta3dzeta =  1\&.;
464 
465               switch (j)
466                 {
467                   // d()/dxi
468                 case 0:
469                   {
470                     switch(i)
471                       {
472                       case 0:
473                         return dzeta0dxi;
474 
475                       case 1:
476                         return dzeta1dxi;
477 
478                       case 2:
479                         return dzeta2dxi;
480 
481                       case 3:
482                         return dzeta3dxi;
483 
484                       default:
485                         libmesh_error();
486                       }
487                   }
488 
489                   // d()/deta
490                 case 1:
491                   {
492                     switch(i)
493                       {
494                       case 0:
495                         return dzeta0deta;
496 
497                       case 1:
498                         return dzeta1deta;
499 
500                       case 2:
501                         return dzeta2deta;
502 
503                       case 3:
504                         return dzeta3deta;
505 
506                       default:
507                         libmesh_error();
508                       }
509                   }
510 
511                   // d()/dzeta
512                 case 2:
513                   {
514                     switch(i)
515                       {
516                       case 0:
517                         return dzeta0dzeta;
518 
519                       case 1:
520                         return dzeta1dzeta;
521 
522                       case 2:
523                         return dzeta2dzeta;
524 
525                       case 3:
526                         return dzeta3dzeta;
527 
528                       default:
529                         libmesh_error();
530                       }
531                   }
532                 }
533             }
534 
535             // linear prism shape functions
536           case PRISM6:
537           case PRISM15:
538           case PRISM18:
539             {
540               libmesh_assert_less (i, 6);
541 
542               // Compute prism shape functions as a tensor-product
543               // of a triangle and an edge
544 
545               Point p2d(p(0),p(1));
546               Point p1d(p(2));
547 
548               //                                0  1  2  3  4  5
549               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1};
550               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2};
551 
552               switch (j)
553                 {
554                   // d()/dxi
555                 case 0:
556                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 0, p2d)*
557                           FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
558 
559                   // d()/deta
560                 case 1:
561                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 1, p2d)*
562                           FE<1,L2_LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
563 
564                   // d()/dzeta
565                 case 2:
566                   return (FE<2,L2_LAGRANGE>::shape(TRI3,  FIRST, i1[i], p2d)*
567                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, p1d));
568                 }
569             }
570 
571             // linear pyramid shape functions
572           case PYRAMID5:
573             {
574               libmesh_assert_less (i, 5);
575 
576               const Real xi   = p(0);
577               const Real eta  = p(1);
578               const Real zeta = p(2);
579               const Real eps  = 1\&.e-35;
580 
581               switch (j)
582                 {
583                   // d/dxi
584                 case 0:
585                   switch(i)
586                     {
587                     case 0:
588                       return  \&.25*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
589 
590                     case 1:
591                       return -\&.25*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
592 
593                     case 2:
594                       return -\&.25*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
595 
596                     case 3:
597                       return  \&.25*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
598 
599                     case 4:
600                       return 0;
601 
602                     default:
603                       libmesh_error();
604                     }
605 
606 
607                   // d/deta
608                 case 1:
609                   switch(i)
610                     {
611                     case 0:
612                       return  \&.25*(zeta + xi - 1\&.)/((1\&. - zeta) + eps);
613 
614                     case 1:
615                       return  \&.25*(zeta - xi - 1\&.)/((1\&. - zeta) + eps);
616 
617                     case 2:
618                       return -\&.25*(zeta - xi - 1\&.)/((1\&. - zeta) + eps);
619 
620                     case 3:
621                       return -\&.25*(zeta + xi - 1\&.)/((1\&. - zeta) + eps);
622 
623                     case 4:
624                       return 0;
625 
626                     default:
627                       libmesh_error();
628                     }
629 
630 
631                   // d/dzeta
632                 case 2:
633                   switch(i)
634                     {
635                     case 0:
636                       {
637                         const Real a=1\&.;
638                         const Real b=1\&.;
639 
640                         return \&.25*(((zeta + a*xi - 1\&.)*(zeta + b*eta - 1\&.) +
641                                      (1\&. - zeta)*((zeta + a*xi -1\&.) + (zeta + b*eta - 1\&.)))/
642                                     ((1\&. - zeta)*(1\&. - zeta) + eps));
643                       }
644 
645                     case 1:
646                       {
647                         const Real a=-1\&.;
648                         const Real b=1\&.;
649 
650                         return \&.25*(((zeta + a*xi - 1\&.)*(zeta + b*eta - 1\&.) +
651                                      (1\&. - zeta)*((zeta + a*xi -1\&.) + (zeta + b*eta - 1\&.)))/
652                                     ((1\&. - zeta)*(1\&. - zeta) + eps));
653                       }
654 
655                     case 2:
656                       {
657                         const Real a=-1\&.;
658                         const Real b=-1\&.;
659 
660                         return \&.25*(((zeta + a*xi - 1\&.)*(zeta + b*eta - 1\&.) +
661                                      (1\&. - zeta)*((zeta + a*xi -1\&.) + (zeta + b*eta - 1\&.)))/
662                                     ((1\&. - zeta)*(1\&. - zeta) + eps));
663                       }
664 
665                     case 3:
666                       {
667                         const Real a=1\&.;
668                         const Real b=-1\&.;
669 
670                         return \&.25*(((zeta + a*xi - 1\&.)*(zeta + b*eta - 1\&.) +
671                                      (1\&. - zeta)*((zeta + a*xi -1\&.) + (zeta + b*eta - 1\&.)))/
672                                     ((1\&. - zeta)*(1\&. - zeta) + eps));
673                       }
674 
675                     case 4:
676                       return 1\&.;
677 
678                     default:
679                       libmesh_error();
680                     }
681 
682 
683                 default:
684                   libmesh_error();
685                 }
686             }
687 
688 
689           default:
690             {
691               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
692                            << std::endl;
693               libmesh_error();
694             }
695           }
696       }
697 
698 
699       // quadratic Lagrange shape functions
700     case SECOND:
701       {
702         switch (type)
703           {
704 
705             // serendipity hexahedral quadratic shape functions
706           case HEX20:
707             {
708               libmesh_assert_less (i, 20);
709 
710               const Real xi   = p(0);
711               const Real eta  = p(1);
712               const Real zeta = p(2);
713 
714               // these functions are defined for (x,y,z) in [0,1]^3
715               // so transform the locations
716               const Real x = \&.5*(xi   + 1\&.);
717               const Real y = \&.5*(eta  + 1\&.);
718               const Real z = \&.5*(zeta + 1\&.);
719 
720               // and don't forget the chain rule!
721 
722               switch (j)
723                 {
724 
725                   // d/dx*dx/dxi
726                 case 0:
727                   switch (i)
728                     {
729                     case 0:
730                       return \&.5*(1\&. - y)*(1\&. - z)*((1\&. - x)*(-2\&.) +
731                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
732 
733                     case 1:
734                       return \&.5*(1\&. - y)*(1\&. - z)*(x*(2\&.) +
735                                                    (1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
736 
737                     case 2:
738                       return \&.5*y*(1\&. - z)*(x*(2\&.) +
739                                             (1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
740 
741                     case 3:
742                       return \&.5*y*(1\&. - z)*((1\&. - x)*(-2\&.) +
743                                             (-1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
744 
745                     case 4:
746                       return \&.5*(1\&. - y)*z*((1\&. - x)*(-2\&.) +
747                                             (-1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
748 
749                     case 5:
750                       return \&.5*(1\&. - y)*z*(x*(2\&.) +
751                                             (1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
752 
753                     case 6:
754                       return \&.5*y*z*(x*(2\&.) +
755                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
756 
757                     case 7:
758                       return \&.5*y*z*((1\&. - x)*(-2\&.) +
759                                      (-1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
760 
761                     case 8:
762                       return 2\&.*(1\&. - y)*(1\&. - z)*(1\&. - 2\&.*x);
763 
764                     case 9:
765                       return 2\&.*y*(1\&. - y)*(1\&. - z);
766 
767                     case 10:
768                       return 2\&.*y*(1\&. - z)*(1\&. - 2\&.*x);
769 
770                     case 11:
771                       return 2\&.*y*(1\&. - y)*(1\&. - z)*(-1\&.);
772 
773                     case 12:
774                       return 2\&.*(1\&. - y)*z*(1\&. - z)*(-1\&.);
775 
776                     case 13:
777                       return 2\&.*(1\&. - y)*z*(1\&. - z);
778 
779                     case 14:
780                       return 2\&.*y*z*(1\&. - z);
781 
782                     case 15:
783                       return 2\&.*y*z*(1\&. - z)*(-1\&.);
784 
785                     case 16:
786                       return 2\&.*(1\&. - y)*z*(1\&. - 2\&.*x);
787 
788                     case 17:
789                       return 2\&.*y*(1\&. - y)*z;
790 
791                     case 18:
792                       return 2\&.*y*z*(1\&. - 2\&.*x);
793 
794                     case 19:
795                       return 2\&.*y*(1\&. - y)*z*(-1\&.);
796 
797                     default:
798                       libmesh_error();
799                     }
800 
801 
802                   // d/dy*dy/deta
803                 case 1:
804                   switch (i)
805                     {
806                     case 0:
807                       return \&.5*(1\&. - x)*(1\&. - z)*((1\&. - y)*(-2\&.) +
808                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
809 
810                     case 1:
811                       return \&.5*x*(1\&. - z)*((1\&. - y)*(-2\&.) +
812                                             (-1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
813 
814                     case 2:
815                       return \&.5*x*(1\&. - z)*(y*(2\&.) +
816                                             (1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
817 
818                     case 3:
819                       return \&.5*(1\&. - x)*(1\&. - z)*(y*(2\&.) +
820                                                    (1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
821 
822                     case 4:
823                       return \&.5*(1\&. - x)*z*((1\&. - y)*(-2\&.) +
824                                             (-1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
825 
826                     case 5:
827                       return \&.5*x*z*((1\&. - y)*(-2\&.) +
828                                      (-1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
829 
830                     case 6:
831                       return \&.5*x*z*(y*(2\&.) +
832                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
833 
834                     case 7:
835                       return \&.5*(1\&. - x)*z*(y*(2\&.) +
836                                             (1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
837 
838                     case 8:
839                       return 2\&.*x*(1\&. - x)*(1\&. - z)*(-1\&.);
840 
841                     case 9:
842                       return 2\&.*x*(1\&. - z)*(1\&. - 2\&.*y);
843 
844                     case 10:
845                       return 2\&.*x*(1\&. - x)*(1\&. - z);
846 
847                     case 11:
848                       return 2\&.*(1\&. - x)*(1\&. - z)*(1\&. - 2\&.*y);
849 
850                     case 12:
851                       return 2\&.*(1\&. - x)*z*(1\&. - z)*(-1\&.);
852 
853                     case 13:
854                       return 2\&.*x*z*(1\&. - z)*(-1\&.);
855 
856                     case 14:
857                       return 2\&.*x*z*(1\&. - z);
858 
859                     case 15:
860                       return 2\&.*(1\&. - x)*z*(1\&. - z);
861 
862                     case 16:
863                       return 2\&.*x*(1\&. - x)*z*(-1\&.);
864 
865                     case 17:
866                       return 2\&.*x*z*(1\&. - 2\&.*y);
867 
868                     case 18:
869                       return 2\&.*x*(1\&. - x)*z;
870 
871                     case 19:
872                       return 2\&.*(1\&. - x)*z*(1\&. - 2\&.*y);
873 
874                     default:
875                       libmesh_error();
876                     }
877 
878 
879                   // d/dz*dz/dzeta
880                 case 2:
881                   switch (i)
882                     {
883                     case 0:
884                       return \&.5*(1\&. - x)*(1\&. - y)*((1\&. - z)*(-2\&.) +
885                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
886 
887                     case 1:
888                       return \&.5*x*(1\&. - y)*((1\&. - z)*(-2\&.) +
889                                             (-1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
890 
891                     case 2:
892                       return \&.5*x*y*((1\&. - z)*(-2\&.) +
893                                      (-1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
894 
895                     case 3:
896                       return \&.5*(1\&. - x)*y*((1\&. - z)*(-2\&.) +
897                                             (-1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
898 
899                     case 4:
900                       return \&.5*(1\&. - x)*(1\&. - y)*(z*(2\&.) +
901                                                    (1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
902 
903                     case 5:
904                       return \&.5*x*(1\&. - y)*(z*(2\&.) +
905                                             (1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
906 
907                     case 6:
908                       return \&.5*x*y*(z*(2\&.) +
909                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
910 
911                     case 7:
912                       return \&.5*(1\&. - x)*y*(z*(2\&.) +
913                                             (1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
914 
915                     case 8:
916                       return 2\&.*x*(1\&. - x)*(1\&. - y)*(-1\&.);
917 
918                     case 9:
919                       return 2\&.*x*y*(1\&. - y)*(-1\&.);
920 
921                     case 10:
922                       return 2\&.*x*(1\&. - x)*y*(-1\&.);
923 
924                     case 11:
925                       return 2\&.*(1\&. - x)*y*(1\&. - y)*(-1\&.);
926 
927                     case 12:
928                       return 2\&.*(1\&. - x)*(1\&. - y)*(1\&. - 2\&.*z);
929 
930                     case 13:
931                       return 2\&.*x*(1\&. - y)*(1\&. - 2\&.*z);
932 
933                     case 14:
934                       return 2\&.*x*y*(1\&. - 2\&.*z);
935 
936                     case 15:
937                       return 2\&.*(1\&. - x)*y*(1\&. - 2\&.*z);
938 
939                     case 16:
940                       return 2\&.*x*(1\&. - x)*(1\&. - y);
941 
942                     case 17:
943                       return 2\&.*x*y*(1\&. - y);
944 
945                     case 18:
946                       return 2\&.*x*(1\&. - x)*y;
947 
948                     case 19:
949                       return 2\&.*(1\&. - x)*y*(1\&. - y);
950 
951                     default:
952                       libmesh_error();
953                     }
954                 }
955             }
956 
957             // triquadraic hexahedral shape funcions
958           case HEX27:
959             {
960               libmesh_assert_less (i, 27);
961 
962               // Compute hex shape functions as a tensor-product
963               const Real xi   = p(0);
964               const Real eta  = p(1);
965               const Real zeta = p(2);
966 
967               // The only way to make any sense of this
968               // is to look at the mgflo/mg2/mgf documentation
969               // and make the cut-out cube!
970               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
971               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
972               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
973               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
974 
975               switch(j)
976                 {
977                 case 0:
978                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
979                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
980                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
981 
982                 case 1:
983                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
984                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
985                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
986 
987                 case 2:
988                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
989                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
990                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
991 
992                 default:
993                   {
994                     libmesh_error();
995                   }
996                 }
997             }
998 
999             // quadratic tetrahedral shape functions
1000           case TET10:
1001             {
1002               libmesh_assert_less (i, 10);
1003 
1004               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
1005               const Real zeta1 = p(0);
1006               const Real zeta2 = p(1);
1007               const Real zeta3 = p(2);
1008               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
1009 
1010               const Real dzeta0dxi = -1\&.;
1011               const Real dzeta1dxi =  1\&.;
1012               const Real dzeta2dxi =  0\&.;
1013               const Real dzeta3dxi =  0\&.;
1014 
1015               const Real dzeta0deta = -1\&.;
1016               const Real dzeta1deta =  0\&.;
1017               const Real dzeta2deta =  1\&.;
1018               const Real dzeta3deta =  0\&.;
1019 
1020               const Real dzeta0dzeta = -1\&.;
1021               const Real dzeta1dzeta =  0\&.;
1022               const Real dzeta2dzeta =  0\&.;
1023               const Real dzeta3dzeta =  1\&.;
1024 
1025               switch (j)
1026                 {
1027                   // d()/dxi
1028                 case 0:
1029                   {
1030                     switch(i)
1031                       {
1032                       case 0:
1033                         return (4\&.*zeta0 - 1\&.)*dzeta0dxi;
1034 
1035                       case 1:
1036                         return (4\&.*zeta1 - 1\&.)*dzeta1dxi;
1037 
1038                       case 2:
1039                         return (4\&.*zeta2 - 1\&.)*dzeta2dxi;
1040 
1041                       case 3:
1042                         return (4\&.*zeta3 - 1\&.)*dzeta3dxi;
1043 
1044                       case 4:
1045                         return 4\&.*(zeta0*dzeta1dxi + dzeta0dxi*zeta1);
1046 
1047                       case 5:
1048                         return 4\&.*(zeta1*dzeta2dxi + dzeta1dxi*zeta2);
1049 
1050                       case 6:
1051                         return 4\&.*(zeta0*dzeta2dxi + dzeta0dxi*zeta2);
1052 
1053                       case 7:
1054                         return 4\&.*(zeta0*dzeta3dxi + dzeta0dxi*zeta3);
1055 
1056                       case 8:
1057                         return 4\&.*(zeta1*dzeta3dxi + dzeta1dxi*zeta3);
1058 
1059                       case 9:
1060                         return 4\&.*(zeta2*dzeta3dxi + dzeta2dxi*zeta3);
1061 
1062                       default:
1063                         libmesh_error();
1064                       }
1065                   }
1066 
1067                   // d()/deta
1068                 case 1:
1069                   {
1070                     switch(i)
1071                       {
1072                       case 0:
1073                         return (4\&.*zeta0 - 1\&.)*dzeta0deta;
1074 
1075                       case 1:
1076                         return (4\&.*zeta1 - 1\&.)*dzeta1deta;
1077 
1078                       case 2:
1079                         return (4\&.*zeta2 - 1\&.)*dzeta2deta;
1080 
1081                       case 3:
1082                         return (4\&.*zeta3 - 1\&.)*dzeta3deta;
1083 
1084                       case 4:
1085                         return 4\&.*(zeta0*dzeta1deta + dzeta0deta*zeta1);
1086 
1087                       case 5:
1088                         return 4\&.*(zeta1*dzeta2deta + dzeta1deta*zeta2);
1089 
1090                       case 6:
1091                         return 4\&.*(zeta0*dzeta2deta + dzeta0deta*zeta2);
1092 
1093                       case 7:
1094                         return 4\&.*(zeta0*dzeta3deta + dzeta0deta*zeta3);
1095 
1096                       case 8:
1097                         return 4\&.*(zeta1*dzeta3deta + dzeta1deta*zeta3);
1098 
1099                       case 9:
1100                         return 4\&.*(zeta2*dzeta3deta + dzeta2deta*zeta3);
1101 
1102                       default:
1103                         libmesh_error();
1104                       }
1105                   }
1106 
1107                   // d()/dzeta
1108                 case 2:
1109                   {
1110                     switch(i)
1111                       {
1112                       case 0:
1113                         return (4\&.*zeta0 - 1\&.)*dzeta0dzeta;
1114 
1115                       case 1:
1116                         return (4\&.*zeta1 - 1\&.)*dzeta1dzeta;
1117 
1118                       case 2:
1119                         return (4\&.*zeta2 - 1\&.)*dzeta2dzeta;
1120 
1121                       case 3:
1122                         return (4\&.*zeta3 - 1\&.)*dzeta3dzeta;
1123 
1124                       case 4:
1125                         return 4\&.*(zeta0*dzeta1dzeta + dzeta0dzeta*zeta1);
1126 
1127                       case 5:
1128                         return 4\&.*(zeta1*dzeta2dzeta + dzeta1dzeta*zeta2);
1129 
1130                       case 6:
1131                         return 4\&.*(zeta0*dzeta2dzeta + dzeta0dzeta*zeta2);
1132 
1133                       case 7:
1134                         return 4\&.*(zeta0*dzeta3dzeta + dzeta0dzeta*zeta3);
1135 
1136                       case 8:
1137                         return 4\&.*(zeta1*dzeta3dzeta + dzeta1dzeta*zeta3);
1138 
1139                       case 9:
1140                         return 4\&.*(zeta2*dzeta3dzeta + dzeta2dzeta*zeta3);
1141 
1142                       default:
1143                         libmesh_error();
1144                       }
1145                   }
1146 
1147                 default:
1148                   libmesh_error();
1149                 }
1150             }
1151 
1152 
1153 
1154             // quadradic prism shape functions
1155           case PRISM18:
1156             {
1157               libmesh_assert_less (i, 18);
1158 
1159               // Compute prism shape functions as a tensor-product
1160               // of a triangle and an edge
1161 
1162               Point p2d(p(0),p(1));
1163               Point p1d(p(2));
1164 
1165               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
1166               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
1167               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
1168 
1169               switch (j)
1170                 {
1171                   // d()/dxi
1172                 case 0:
1173                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 0, p2d)*
1174                           FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1175 
1176                   // d()/deta
1177                 case 1:
1178                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 1, p2d)*
1179                           FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1180 
1181                   // d()/dzeta
1182                 case 2:
1183                   return (FE<2,L2_LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
1184                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
1185                 }
1186             }
1187 
1188 
1189 
1190           default:
1191             {
1192               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
1193                            << std::endl;
1194               libmesh_error();
1195             }
1196           }
1197       }
1198 
1199 
1200       // unsupported order
1201     default:
1202       {
1203         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
1204                      << std::endl;
1205         libmesh_error();
1206       }
1207     }
1208 
1209 #endif
1210 
1211   libmesh_error();
1212   return 0\&.;
1213 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 449 of file fe_hermite_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
454 {
455   libMesh::err << "Hermite elements require the real element\n"
456                << "to construct gradient-based degrees of freedom\&."
457                << std::endl;
458 
459   libmesh_error();
460   return 0\&.;
461 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 466 of file fe_hermite_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
471 {
472   libmesh_assert(elem);
473   libmesh_assert (j == 0 || j == 1 || j == 2);
474 
475   std::vector<std::vector<Real> > dxdxi(3, std::vector<Real>(2, 0));
476 
477 #ifdef DEBUG
478   std::vector<Real> dydxi(2), dzdeta(2), dxdzeta(2);
479   std::vector<Real> dzdxi(2), dxdeta(2), dydzeta(2);
480 #endif //DEBUG
481 
482   hermite_compute_coefs(elem, dxdxi
483 #ifdef DEBUG
484                         , dydxi, dzdeta, dxdzeta, dzdxi, dxdeta, dydzeta
485 #endif
486                         );
487 
488   const ElemType type = elem->type();
489 
490   const Order totalorder = static_cast<Order>(order + elem->p_level());
491 
492   switch (totalorder)
493     {
494       // 3rd-order tricubic Hermite functions
495     case THIRD:
496       {
497         switch (type)
498           {
499           case HEX8:
500           case HEX20:
501           case HEX27:
502             {
503               libmesh_assert_less (i, 64);
504 
505               std::vector<unsigned int> bases1D;
506 
507               Real coef = hermite_bases_3D(bases1D, dxdxi, totalorder, i);
508 
509               switch (j) // Derivative type
510                 {
511                 case 0:
512                   return coef *
513                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[0],p(0)) *
514                     FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
515                     FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
516                   break;
517                 case 1:
518                   return coef *
519                     FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
520                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[1],p(1)) *
521                     FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
522                   break;
523                 case 2:
524                   return coef *
525                     FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
526                     FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
527                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[2],p(2));
528                   break;
529                 }
530 
531             }
532           default:
533             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
534             libmesh_error();
535           }
536       }
537       // by default throw an error
538     default:
539       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
540       libmesh_error();
541     }
542 
543   libmesh_error();
544   return 0\&.;
545 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 544 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_deriv()\&.
.PP
.nf
547 {
548   Real value = FE<0,LAGRANGE>::shape_deriv( type, order, i, j, p );
549   return libMesh::RealGradient( value );
550 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 566 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_deriv()\&.
.PP
.nf
569 {
570   Real value = FE<1,LAGRANGE>::shape_deriv( type, order, i, j, p );
571   return libMesh::RealGradient( value );
572 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 576 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
581 {
582   libmesh_assert(elem);
583 
584 
585   // call the orientation-independent shape functions
586   return FE<2,LAGRANGE>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
587 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 578 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
583 {
584   libmesh_assert(elem);
585 
586 
587   // call the orientation-independent shape functions
588   return FE<2,L2_LAGRANGE>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
589 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 586 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI6, and libMesh::x\&.
.PP
.nf
591 {
592 #if LIBMESH_DIM == 3
593 
594   libmesh_assert_less (j, 3);
595 
596   switch (order)
597     {
598       // linear Lagrange shape functions
599     case FIRST:
600       {
601         switch (type)
602           {
603             // trilinear hexahedral shape functions
604           case HEX8:
605           case HEX20:
606           case HEX27:
607             {
608               libmesh_assert_less (i, 8);
609 
610               // Compute hex shape functions as a tensor-product
611               const Real xi   = p(0);
612               const Real eta  = p(1);
613               const Real zeta = p(2);
614 
615               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
616               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
617               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
618 
619               switch(j)
620                 {
621                 case 0:
622                   return (FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
623                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta)*
624                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i2[i], zeta));
625 
626                 case 1:
627                   return (FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
628                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta)*
629                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i2[i], zeta));
630 
631                 case 2:
632                   return (FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
633                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta)*
634                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i2[i], 0, zeta));
635 
636                 default:
637                   {
638                     libmesh_error();
639                   }
640                 }
641             }
642 
643             // linear tetrahedral shape functions
644           case TET4:
645           case TET10:
646             {
647               libmesh_assert_less (i, 4);
648 
649               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
650               const Real dzeta0dxi = -1\&.;
651               const Real dzeta1dxi =  1\&.;
652               const Real dzeta2dxi =  0\&.;
653               const Real dzeta3dxi =  0\&.;
654 
655               const Real dzeta0deta = -1\&.;
656               const Real dzeta1deta =  0\&.;
657               const Real dzeta2deta =  1\&.;
658               const Real dzeta3deta =  0\&.;
659 
660               const Real dzeta0dzeta = -1\&.;
661               const Real dzeta1dzeta =  0\&.;
662               const Real dzeta2dzeta =  0\&.;
663               const Real dzeta3dzeta =  1\&.;
664 
665               switch (j)
666                 {
667                   // d()/dxi
668                 case 0:
669                   {
670                     switch(i)
671                       {
672                       case 0:
673                         return dzeta0dxi;
674 
675                       case 1:
676                         return dzeta1dxi;
677 
678                       case 2:
679                         return dzeta2dxi;
680 
681                       case 3:
682                         return dzeta3dxi;
683 
684                       default:
685                         libmesh_error();
686                       }
687                   }
688 
689                   // d()/deta
690                 case 1:
691                   {
692                     switch(i)
693                       {
694                       case 0:
695                         return dzeta0deta;
696 
697                       case 1:
698                         return dzeta1deta;
699 
700                       case 2:
701                         return dzeta2deta;
702 
703                       case 3:
704                         return dzeta3deta;
705 
706                       default:
707                         libmesh_error();
708                       }
709                   }
710 
711                   // d()/dzeta
712                 case 2:
713                   {
714                     switch(i)
715                       {
716                       case 0:
717                         return dzeta0dzeta;
718 
719                       case 1:
720                         return dzeta1dzeta;
721 
722                       case 2:
723                         return dzeta2dzeta;
724 
725                       case 3:
726                         return dzeta3dzeta;
727 
728                       default:
729                         libmesh_error();
730                       }
731                   }
732                 }
733             }
734 
735             // linear prism shape functions
736           case PRISM6:
737           case PRISM15:
738           case PRISM18:
739             {
740               libmesh_assert_less (i, 6);
741 
742               // Compute prism shape functions as a tensor-product
743               // of a triangle and an edge
744 
745               Point p2d(p(0),p(1));
746               Point p1d(p(2));
747 
748               //                                0  1  2  3  4  5
749               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1};
750               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2};
751 
752               switch (j)
753                 {
754                   // d()/dxi
755                 case 0:
756                   return (FE<2,LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 0, p2d)*
757                           FE<1,LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
758 
759                   // d()/deta
760                 case 1:
761                   return (FE<2,LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 1, p2d)*
762                           FE<1,LAGRANGE>::shape(EDGE2, FIRST, i0[i], p1d));
763 
764                   // d()/dzeta
765                 case 2:
766                   return (FE<2,LAGRANGE>::shape(TRI3,  FIRST, i1[i], p2d)*
767                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, p1d));
768                 }
769             }
770 
771             // linear pyramid shape functions
772           case PYRAMID5:
773           case PYRAMID13:
774           case PYRAMID14:
775             {
776               libmesh_assert_less (i, 5);
777 
778               const Real xi   = p(0);
779               const Real eta  = p(1);
780               const Real zeta = p(2);
781               const Real eps  = 1\&.e-35;
782 
783               switch (j)
784                 {
785                   // d/dxi
786                 case 0:
787                   switch(i)
788                     {
789                     case 0:
790                       return  \&.25*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
791 
792                     case 1:
793                       return -\&.25*(zeta + eta - 1\&.)/((1\&. - zeta) + eps);
794 
795                     case 2:
796                       return -\&.25*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
797 
798                     case 3:
799                       return  \&.25*(zeta - eta - 1\&.)/((1\&. - zeta) + eps);
800 
801                     case 4:
802                       return 0;
803 
804                     default:
805                       libmesh_error();
806                     }
807 
808 
809                   // d/deta
810                 case 1:
811                   switch(i)
812                     {
813                     case 0:
814                       return  \&.25*(zeta + xi - 1\&.)/((1\&. - zeta) + eps);
815 
816                     case 1:
817                       return  \&.25*(zeta - xi - 1\&.)/((1\&. - zeta) + eps);
818 
819                     case 2:
820                       return -\&.25*(zeta - xi - 1\&.)/((1\&. - zeta) + eps);
821 
822                     case 3:
823                       return -\&.25*(zeta + xi - 1\&.)/((1\&. - zeta) + eps);
824 
825                     case 4:
826                       return 0;
827 
828                     default:
829                       libmesh_error();
830                     }
831 
832 
833                   // d/dzeta
834                 case 2:
835                   {
836                     // We computed the derivatives with general eps and
837                     // then let eps tend to zero in the numerators\&.\&.\&.
838                     Real
839                       num = zeta*(2\&. - zeta) - 1\&.,
840                       den = (1\&. - zeta + eps)*(1\&. - zeta + eps);
841 
842                     switch(i)
843                       {
844                       case 0:
845                       case 2:
846                         return \&.25*(num + xi*eta)/den;
847 
848                       case 1:
849                       case 3:
850                         return \&.25*(num - xi*eta)/den;
851 
852                       case 4:
853                         return 1\&.;
854 
855                       default:
856                         libmesh_error();
857                       }
858                   }
859 
860                 default:
861                   libmesh_error();
862                 }
863             }
864 
865 
866           default:
867             {
868               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
869                            << std::endl;
870               libmesh_error();
871             }
872           }
873       }
874 
875 
876       // quadratic Lagrange shape functions
877     case SECOND:
878       {
879         switch (type)
880           {
881 
882             // serendipity hexahedral quadratic shape functions
883           case HEX20:
884             {
885               libmesh_assert_less (i, 20);
886 
887               const Real xi   = p(0);
888               const Real eta  = p(1);
889               const Real zeta = p(2);
890 
891               // these functions are defined for (x,y,z) in [0,1]^3
892               // so transform the locations
893               const Real x = \&.5*(xi   + 1\&.);
894               const Real y = \&.5*(eta  + 1\&.);
895               const Real z = \&.5*(zeta + 1\&.);
896 
897               // and don't forget the chain rule!
898 
899               switch (j)
900                 {
901 
902                   // d/dx*dx/dxi
903                 case 0:
904                   switch (i)
905                     {
906                     case 0:
907                       return \&.5*(1\&. - y)*(1\&. - z)*((1\&. - x)*(-2\&.) +
908                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
909 
910                     case 1:
911                       return \&.5*(1\&. - y)*(1\&. - z)*(x*(2\&.) +
912                                                    (1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
913 
914                     case 2:
915                       return \&.5*y*(1\&. - z)*(x*(2\&.) +
916                                             (1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
917 
918                     case 3:
919                       return \&.5*y*(1\&. - z)*((1\&. - x)*(-2\&.) +
920                                             (-1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
921 
922                     case 4:
923                       return \&.5*(1\&. - y)*z*((1\&. - x)*(-2\&.) +
924                                             (-1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
925 
926                     case 5:
927                       return \&.5*(1\&. - y)*z*(x*(2\&.) +
928                                             (1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
929 
930                     case 6:
931                       return \&.5*y*z*(x*(2\&.) +
932                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
933 
934                     case 7:
935                       return \&.5*y*z*((1\&. - x)*(-2\&.) +
936                                      (-1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
937 
938                     case 8:
939                       return 2\&.*(1\&. - y)*(1\&. - z)*(1\&. - 2\&.*x);
940 
941                     case 9:
942                       return 2\&.*y*(1\&. - y)*(1\&. - z);
943 
944                     case 10:
945                       return 2\&.*y*(1\&. - z)*(1\&. - 2\&.*x);
946 
947                     case 11:
948                       return 2\&.*y*(1\&. - y)*(1\&. - z)*(-1\&.);
949 
950                     case 12:
951                       return 2\&.*(1\&. - y)*z*(1\&. - z)*(-1\&.);
952 
953                     case 13:
954                       return 2\&.*(1\&. - y)*z*(1\&. - z);
955 
956                     case 14:
957                       return 2\&.*y*z*(1\&. - z);
958 
959                     case 15:
960                       return 2\&.*y*z*(1\&. - z)*(-1\&.);
961 
962                     case 16:
963                       return 2\&.*(1\&. - y)*z*(1\&. - 2\&.*x);
964 
965                     case 17:
966                       return 2\&.*y*(1\&. - y)*z;
967 
968                     case 18:
969                       return 2\&.*y*z*(1\&. - 2\&.*x);
970 
971                     case 19:
972                       return 2\&.*y*(1\&. - y)*z*(-1\&.);
973 
974                     default:
975                       libmesh_error();
976                     }
977 
978 
979                   // d/dy*dy/deta
980                 case 1:
981                   switch (i)
982                     {
983                     case 0:
984                       return \&.5*(1\&. - x)*(1\&. - z)*((1\&. - y)*(-2\&.) +
985                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
986 
987                     case 1:
988                       return \&.5*x*(1\&. - z)*((1\&. - y)*(-2\&.) +
989                                             (-1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
990 
991                     case 2:
992                       return \&.5*x*(1\&. - z)*(y*(2\&.) +
993                                             (1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
994 
995                     case 3:
996                       return \&.5*(1\&. - x)*(1\&. - z)*(y*(2\&.) +
997                                                    (1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
998 
999                     case 4:
1000                       return \&.5*(1\&. - x)*z*((1\&. - y)*(-2\&.) +
1001                                             (-1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
1002 
1003                     case 5:
1004                       return \&.5*x*z*((1\&. - y)*(-2\&.) +
1005                                      (-1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
1006 
1007                     case 6:
1008                       return \&.5*x*z*(y*(2\&.) +
1009                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
1010 
1011                     case 7:
1012                       return \&.5*(1\&. - x)*z*(y*(2\&.) +
1013                                             (1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
1014 
1015                     case 8:
1016                       return 2\&.*x*(1\&. - x)*(1\&. - z)*(-1\&.);
1017 
1018                     case 9:
1019                       return 2\&.*x*(1\&. - z)*(1\&. - 2\&.*y);
1020 
1021                     case 10:
1022                       return 2\&.*x*(1\&. - x)*(1\&. - z);
1023 
1024                     case 11:
1025                       return 2\&.*(1\&. - x)*(1\&. - z)*(1\&. - 2\&.*y);
1026 
1027                     case 12:
1028                       return 2\&.*(1\&. - x)*z*(1\&. - z)*(-1\&.);
1029 
1030                     case 13:
1031                       return 2\&.*x*z*(1\&. - z)*(-1\&.);
1032 
1033                     case 14:
1034                       return 2\&.*x*z*(1\&. - z);
1035 
1036                     case 15:
1037                       return 2\&.*(1\&. - x)*z*(1\&. - z);
1038 
1039                     case 16:
1040                       return 2\&.*x*(1\&. - x)*z*(-1\&.);
1041 
1042                     case 17:
1043                       return 2\&.*x*z*(1\&. - 2\&.*y);
1044 
1045                     case 18:
1046                       return 2\&.*x*(1\&. - x)*z;
1047 
1048                     case 19:
1049                       return 2\&.*(1\&. - x)*z*(1\&. - 2\&.*y);
1050 
1051                     default:
1052                       libmesh_error();
1053                     }
1054 
1055 
1056                   // d/dz*dz/dzeta
1057                 case 2:
1058                   switch (i)
1059                     {
1060                     case 0:
1061                       return \&.5*(1\&. - x)*(1\&. - y)*((1\&. - z)*(-2\&.) +
1062                                                    (-1\&.)*(1\&. - 2\&.*x - 2\&.*y - 2\&.*z));
1063 
1064                     case 1:
1065                       return \&.5*x*(1\&. - y)*((1\&. - z)*(-2\&.) +
1066                                             (-1\&.)*(2\&.*x - 2\&.*y - 2\&.*z - 1\&.));
1067 
1068                     case 2:
1069                       return \&.5*x*y*((1\&. - z)*(-2\&.) +
1070                                      (-1\&.)*(2\&.*x + 2\&.*y - 2\&.*z - 3\&.));
1071 
1072                     case 3:
1073                       return \&.5*(1\&. - x)*y*((1\&. - z)*(-2\&.) +
1074                                             (-1\&.)*(2\&.*y - 2\&.*x - 2\&.*z - 1\&.));
1075 
1076                     case 4:
1077                       return \&.5*(1\&. - x)*(1\&. - y)*(z*(2\&.) +
1078                                                    (1\&.)*(2\&.*z - 2\&.*x - 2\&.*y - 1\&.));
1079 
1080                     case 5:
1081                       return \&.5*x*(1\&. - y)*(z*(2\&.) +
1082                                             (1\&.)*(2\&.*x - 2\&.*y + 2\&.*z - 3\&.));
1083 
1084                     case 6:
1085                       return \&.5*x*y*(z*(2\&.) +
1086                                      (1\&.)*(2\&.*x + 2\&.*y + 2\&.*z - 5\&.));
1087 
1088                     case 7:
1089                       return \&.5*(1\&. - x)*y*(z*(2\&.) +
1090                                             (1\&.)*(2\&.*y - 2\&.*x + 2\&.*z - 3\&.));
1091 
1092                     case 8:
1093                       return 2\&.*x*(1\&. - x)*(1\&. - y)*(-1\&.);
1094 
1095                     case 9:
1096                       return 2\&.*x*y*(1\&. - y)*(-1\&.);
1097 
1098                     case 10:
1099                       return 2\&.*x*(1\&. - x)*y*(-1\&.);
1100 
1101                     case 11:
1102                       return 2\&.*(1\&. - x)*y*(1\&. - y)*(-1\&.);
1103 
1104                     case 12:
1105                       return 2\&.*(1\&. - x)*(1\&. - y)*(1\&. - 2\&.*z);
1106 
1107                     case 13:
1108                       return 2\&.*x*(1\&. - y)*(1\&. - 2\&.*z);
1109 
1110                     case 14:
1111                       return 2\&.*x*y*(1\&. - 2\&.*z);
1112 
1113                     case 15:
1114                       return 2\&.*(1\&. - x)*y*(1\&. - 2\&.*z);
1115 
1116                     case 16:
1117                       return 2\&.*x*(1\&. - x)*(1\&. - y);
1118 
1119                     case 17:
1120                       return 2\&.*x*y*(1\&. - y);
1121 
1122                     case 18:
1123                       return 2\&.*x*(1\&. - x)*y;
1124 
1125                     case 19:
1126                       return 2\&.*(1\&. - x)*y*(1\&. - y);
1127 
1128                     default:
1129                       libmesh_error();
1130                     }
1131                 }
1132             }
1133 
1134             // triquadraic hexahedral shape funcions
1135           case HEX27:
1136             {
1137               libmesh_assert_less (i, 27);
1138 
1139               // Compute hex shape functions as a tensor-product
1140               const Real xi   = p(0);
1141               const Real eta  = p(1);
1142               const Real zeta = p(2);
1143 
1144               // The only way to make any sense of this
1145               // is to look at the mgflo/mg2/mgf documentation
1146               // and make the cut-out cube!
1147               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
1148               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
1149               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
1150               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
1151 
1152               switch(j)
1153                 {
1154                 case 0:
1155                   return (FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
1156                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
1157                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
1158 
1159                 case 1:
1160                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
1161                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
1162                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
1163 
1164                 case 2:
1165                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
1166                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
1167                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
1168 
1169                 default:
1170                   {
1171                     libmesh_error();
1172                   }
1173                 }
1174             }
1175 
1176             // quadratic tetrahedral shape functions
1177           case TET10:
1178             {
1179               libmesh_assert_less (i, 10);
1180 
1181               // Area coordinates, pg\&. 205, Vol\&. I, Carey, Oden, Becker FEM
1182               const Real zeta1 = p(0);
1183               const Real zeta2 = p(1);
1184               const Real zeta3 = p(2);
1185               const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
1186 
1187               const Real dzeta0dxi = -1\&.;
1188               const Real dzeta1dxi =  1\&.;
1189               const Real dzeta2dxi =  0\&.;
1190               const Real dzeta3dxi =  0\&.;
1191 
1192               const Real dzeta0deta = -1\&.;
1193               const Real dzeta1deta =  0\&.;
1194               const Real dzeta2deta =  1\&.;
1195               const Real dzeta3deta =  0\&.;
1196 
1197               const Real dzeta0dzeta = -1\&.;
1198               const Real dzeta1dzeta =  0\&.;
1199               const Real dzeta2dzeta =  0\&.;
1200               const Real dzeta3dzeta =  1\&.;
1201 
1202               switch (j)
1203                 {
1204                   // d()/dxi
1205                 case 0:
1206                   {
1207                     switch(i)
1208                       {
1209                       case 0:
1210                         return (4\&.*zeta0 - 1\&.)*dzeta0dxi;
1211 
1212                       case 1:
1213                         return (4\&.*zeta1 - 1\&.)*dzeta1dxi;
1214 
1215                       case 2:
1216                         return (4\&.*zeta2 - 1\&.)*dzeta2dxi;
1217 
1218                       case 3:
1219                         return (4\&.*zeta3 - 1\&.)*dzeta3dxi;
1220 
1221                       case 4:
1222                         return 4\&.*(zeta0*dzeta1dxi + dzeta0dxi*zeta1);
1223 
1224                       case 5:
1225                         return 4\&.*(zeta1*dzeta2dxi + dzeta1dxi*zeta2);
1226 
1227                       case 6:
1228                         return 4\&.*(zeta0*dzeta2dxi + dzeta0dxi*zeta2);
1229 
1230                       case 7:
1231                         return 4\&.*(zeta0*dzeta3dxi + dzeta0dxi*zeta3);
1232 
1233                       case 8:
1234                         return 4\&.*(zeta1*dzeta3dxi + dzeta1dxi*zeta3);
1235 
1236                       case 9:
1237                         return 4\&.*(zeta2*dzeta3dxi + dzeta2dxi*zeta3);
1238 
1239                       default:
1240                         libmesh_error();
1241                       }
1242                   }
1243 
1244                   // d()/deta
1245                 case 1:
1246                   {
1247                     switch(i)
1248                       {
1249                       case 0:
1250                         return (4\&.*zeta0 - 1\&.)*dzeta0deta;
1251 
1252                       case 1:
1253                         return (4\&.*zeta1 - 1\&.)*dzeta1deta;
1254 
1255                       case 2:
1256                         return (4\&.*zeta2 - 1\&.)*dzeta2deta;
1257 
1258                       case 3:
1259                         return (4\&.*zeta3 - 1\&.)*dzeta3deta;
1260 
1261                       case 4:
1262                         return 4\&.*(zeta0*dzeta1deta + dzeta0deta*zeta1);
1263 
1264                       case 5:
1265                         return 4\&.*(zeta1*dzeta2deta + dzeta1deta*zeta2);
1266 
1267                       case 6:
1268                         return 4\&.*(zeta0*dzeta2deta + dzeta0deta*zeta2);
1269 
1270                       case 7:
1271                         return 4\&.*(zeta0*dzeta3deta + dzeta0deta*zeta3);
1272 
1273                       case 8:
1274                         return 4\&.*(zeta1*dzeta3deta + dzeta1deta*zeta3);
1275 
1276                       case 9:
1277                         return 4\&.*(zeta2*dzeta3deta + dzeta2deta*zeta3);
1278 
1279                       default:
1280                         libmesh_error();
1281                       }
1282                   }
1283 
1284                   // d()/dzeta
1285                 case 2:
1286                   {
1287                     switch(i)
1288                       {
1289                       case 0:
1290                         return (4\&.*zeta0 - 1\&.)*dzeta0dzeta;
1291 
1292                       case 1:
1293                         return (4\&.*zeta1 - 1\&.)*dzeta1dzeta;
1294 
1295                       case 2:
1296                         return (4\&.*zeta2 - 1\&.)*dzeta2dzeta;
1297 
1298                       case 3:
1299                         return (4\&.*zeta3 - 1\&.)*dzeta3dzeta;
1300 
1301                       case 4:
1302                         return 4\&.*(zeta0*dzeta1dzeta + dzeta0dzeta*zeta1);
1303 
1304                       case 5:
1305                         return 4\&.*(zeta1*dzeta2dzeta + dzeta1dzeta*zeta2);
1306 
1307                       case 6:
1308                         return 4\&.*(zeta0*dzeta2dzeta + dzeta0dzeta*zeta2);
1309 
1310                       case 7:
1311                         return 4\&.*(zeta0*dzeta3dzeta + dzeta0dzeta*zeta3);
1312 
1313                       case 8:
1314                         return 4\&.*(zeta1*dzeta3dzeta + dzeta1dzeta*zeta3);
1315 
1316                       case 9:
1317                         return 4\&.*(zeta2*dzeta3dzeta + dzeta2dzeta*zeta3);
1318 
1319                       default:
1320                         libmesh_error();
1321                       }
1322                   }
1323 
1324                 default:
1325                   libmesh_error();
1326                 }
1327             }
1328 
1329 
1330             // "serendipity" prism
1331           case PRISM15:
1332             {
1333               libmesh_assert_less (i, 15);
1334 
1335               const Real xi   = p(0);
1336               const Real eta  = p(1);
1337               const Real zeta = p(2);
1338 
1339               switch (j)
1340                 {
1341                   // d()/dxi
1342                 case 0:
1343                   {
1344                     switch(i)
1345                       {
1346                       case 0:
1347                         return (2\&.*xi + 2\&.*eta + 0\&.5*zeta - 1\&.)*(1\&. - zeta);
1348                       case 1:
1349                         return (2\&.*xi - 1\&. - 0\&.5*zeta)*(1\&. - zeta);
1350                       case 2:
1351                         return 0\&.;
1352                       case 3:
1353                         return (2\&.*xi + 2\&.*eta - 0\&.5*zeta - 1\&.)*(1\&. + zeta);
1354                       case 4:
1355                         return (2\&.*xi - 1\&. + 0\&.5*zeta)*(1\&. + zeta);
1356                       case 5:
1357                         return 0\&.;
1358                       case 6:
1359                         return (4\&.*xi + 2\&.*eta - 2\&.)*(zeta - 1\&.);
1360                       case 7:
1361                         return -2\&.*(zeta - 1\&.)*eta;
1362                       case 8:
1363                         return 2\&.*(zeta - 1\&.)*eta;
1364                       case 9:
1365                         return (zeta - 1\&.)*(1\&. + zeta);
1366                       case 10:
1367                         return (1\&. - zeta)*(1\&. + zeta);
1368                       case 11:
1369                         return 0\&.;
1370                       case 12:
1371                         return (-4\&.*xi - 2\&.*eta + 2\&.)*(1\&. + zeta);
1372                       case 13:
1373                         return 2\&.*(1\&. + zeta)*eta;
1374                       case 14:
1375                         return -2\&.*(1\&. + zeta)*eta;
1376                       default:
1377                         libmesh_error();
1378                       }
1379                   }
1380 
1381                   // d()/deta
1382                 case 1:
1383                   {
1384                     switch(i)
1385                       {
1386                       case 0:
1387                         return (2\&.*xi + 2\&.*eta + 0\&.5*zeta - 1\&.)*(1\&. - zeta);
1388                       case 1:
1389                         return 0\&.;
1390                       case 2:
1391                         return (2\&.*eta - 1\&. - 0\&.5*zeta)*(1\&. - zeta);
1392                       case 3:
1393                         return (2\&.*xi + 2\&.*eta - 0\&.5*zeta - 1\&.)*(1\&. + zeta);
1394                       case 4:
1395                         return 0\&.;
1396                       case 5:
1397                         return (2\&.*eta - 1\&. + 0\&.5*zeta)*(1\&. + zeta);
1398                       case 6:
1399                         return 2\&.*(zeta - 1\&.)*xi;
1400                       case 7:
1401                         return 2\&.*(1\&. - zeta)*xi;
1402                       case 8:
1403                         return (2\&.*xi + 4\&.*eta - 2\&.)*(zeta - 1\&.);
1404                       case 9:
1405                         return (zeta - 1\&.)*(1\&. + zeta);
1406                       case 10:
1407                         return 0\&.;
1408                       case 11:
1409                         return (1\&. - zeta)*(1\&. + zeta);
1410                       case 12:
1411                         return -2\&.*(1\&. + zeta)*xi;
1412                       case 13:
1413                         return 2\&.*(1\&. + zeta)*xi;
1414                       case 14:
1415                         return (-2\&.*xi - 4\&.*eta + 2\&.)*(1\&. + zeta);
1416 
1417                       default:
1418                         libmesh_error();
1419                       }
1420                   }
1421 
1422                   // d()/dzeta
1423                 case 2:
1424                   {
1425                     switch(i)
1426                       {
1427                       case 0:
1428                         return (-xi - eta - zeta + 0\&.5)*(xi + eta - 1\&.);
1429                       case 1:
1430                         return -0\&.5*xi*(2\&.*xi - 1\&. - 2\&.*zeta);
1431                       case 2:
1432                         return -0\&.5*eta*(2\&.*eta - 1\&. - 2\&.*zeta);
1433                       case 3:
1434                         return (xi + eta - zeta - 0\&.5)*(xi + eta - 1\&.);
1435                       case 4:
1436                         return 0\&.5*xi*(2\&.*xi - 1\&. + 2\&.*zeta);
1437                       case 5:
1438                         return 0\&.5*eta*(2\&.*eta - 1\&. + 2\&.*zeta);
1439                       case 6:
1440                         return 2\&.*xi*(xi + eta - 1\&.);
1441                       case 7:
1442                         return -2\&.*xi*eta;
1443                       case 8:
1444                         return 2\&.*eta*(xi + eta - 1\&.);
1445                       case 9:
1446                         return 2\&.*zeta*(xi + eta - 1\&.);
1447                       case 10:
1448                         return -2\&.*xi*zeta;
1449                       case 11:
1450                         return -2\&.*eta*zeta;
1451                       case 12:
1452                         return 2\&.*xi*(1\&. - xi - eta);
1453                       case 13:
1454                         return 2\&.*xi*eta;
1455                       case 14:
1456                         return 2\&.*eta*(1\&. - xi - eta);
1457 
1458                       default:
1459                         libmesh_error();
1460                       }
1461                   }
1462 
1463                 default:
1464                   libmesh_error();
1465                 }
1466             }
1467 
1468 
1469 
1470             // quadradic prism shape functions
1471           case PRISM18:
1472             {
1473               libmesh_assert_less (i, 18);
1474 
1475               // Compute prism shape functions as a tensor-product
1476               // of a triangle and an edge
1477 
1478               Point p2d(p(0),p(1));
1479               Point p1d(p(2));
1480 
1481               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
1482               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
1483               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
1484 
1485               switch (j)
1486                 {
1487                   // d()/dxi
1488                 case 0:
1489                   return (FE<2,LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 0, p2d)*
1490                           FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1491 
1492                   // d()/deta
1493                 case 1:
1494                   return (FE<2,LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 1, p2d)*
1495                           FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1496 
1497                   // d()/dzeta
1498                 case 2:
1499                   return (FE<2,LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
1500                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
1501                 }
1502             }
1503 
1504             // G\&. Bedrosian, "Shape functions and integration formulas for
1505             // three-dimensional finite element analysis", Int\&. J\&. Numerical
1506             // Methods Engineering, vol 35, p\&. 95-108, 1992\&.
1507           case PYRAMID13:
1508             {
1509               libmesh_assert_less (i, 13);
1510 
1511               const Real xi   = p(0);
1512               const Real eta  = p(1);
1513               const Real zeta = p(2);
1514               const Real eps  = 1\&.e-35;
1515 
1516               // Denominators are perturbed by epsilon to avoid
1517               // divide-by-zero issues\&.
1518               Real
1519                 den = (-1\&. + zeta + eps),
1520                 den2 = den*den,
1521                 xi2 = xi*xi,
1522                 eta2 = eta*eta,
1523                 zeta2 = zeta*zeta,
1524                 zeta3 = zeta2*zeta;
1525 
1526               switch (j)
1527                 {
1528                   // d/dxi
1529                 case 0:
1530                   switch(i)
1531                     {
1532                     case 0:
1533                       return 0\&.25*(-zeta - eta + 2\&.*eta*zeta - 2\&.*xi + 2\&.*zeta*xi + 2\&.*eta*xi + zeta2 + eta2)/den;
1534 
1535                     case 1:
1536                       return -0\&.25*(-zeta - eta + 2\&.*eta*zeta + 2\&.*xi - 2\&.*zeta*xi - 2\&.*eta*xi + zeta2 + eta2)/den;
1537 
1538                     case 2:
1539                       return -0\&.25*(-zeta + eta - 2\&.*eta*zeta + 2\&.*xi - 2\&.*zeta*xi + 2\&.*eta*xi + zeta2 + eta2)/den;
1540 
1541                     case 3:
1542                       return 0\&.25*(-zeta + eta - 2\&.*eta*zeta - 2\&.*xi + 2\&.*zeta*xi - 2\&.*eta*xi + zeta2 + eta2)/den;
1543 
1544                     case 4:
1545                       return 0\&.;
1546 
1547                     case 5:
1548                       return -(-1\&. + eta + zeta)*xi/den;
1549 
1550                     case 6:
1551                       return 0\&.5*(-1\&. + eta + zeta)*(1\&. + eta - zeta)/den;
1552 
1553                     case 7:
1554                       return (1\&. + eta - zeta)*xi/den;
1555 
1556                     case 8:
1557                       return -0\&.5*(-1\&. + eta + zeta)*(1\&. + eta - zeta)/den;
1558 
1559                     case 9:
1560                       return -(-1\&. + eta + zeta)*zeta/den;
1561 
1562                     case 10:
1563                       return (-1\&. + eta + zeta)*zeta/den;
1564 
1565                     case 11:
1566                       return -(1\&. + eta - zeta)*zeta/den;
1567 
1568                     case 12:
1569                       return (1\&. + eta - zeta)*zeta/den;
1570 
1571                     default:
1572                       libmesh_error();
1573                     }
1574 
1575                   // d/deta
1576                 case 1:
1577                   switch(i)
1578                     {
1579                     case 0:
1580                       return 0\&.25*(-zeta - 2\&.*eta + 2\&.*eta*zeta - xi + 2\&.*zeta*xi + 2\&.*eta*xi + zeta2 + xi2)/den;
1581 
1582                     case 1:
1583                       return -0\&.25*(zeta + 2\&.*eta - 2\&.*eta*zeta - xi + 2\&.*zeta*xi + 2\&.*eta*xi - zeta2 - xi2)/den;
1584 
1585                     case 2:
1586                       return -0\&.25*(-zeta + 2\&.*eta - 2\&.*eta*zeta + xi - 2\&.*zeta*xi + 2\&.*eta*xi + zeta2 + xi2)/den;
1587 
1588                     case 3:
1589                       return 0\&.25*(zeta - 2\&.*eta + 2\&.*eta*zeta + xi - 2\&.*zeta*xi + 2\&.*eta*xi - zeta2 - xi2)/den;
1590 
1591                     case 4:
1592                       return 0\&.;
1593 
1594                     case 5:
1595                       return -0\&.5*(-1\&. + xi + zeta)*(1\&. + xi - zeta)/den;
1596 
1597                     case 6:
1598                       return (1\&. + xi - zeta)*eta/den;
1599 
1600                     case 7:
1601                       return 0\&.5*(-1\&. + xi + zeta)*(1\&. + xi - zeta)/den;
1602 
1603                     case 8:
1604                       return -(-1\&. + xi + zeta)*eta/den;
1605 
1606                     case 9:
1607                       return -(-1\&. + xi + zeta)*zeta/den;
1608 
1609                     case 10:
1610                       return (1\&. + xi - zeta)*zeta/den;
1611 
1612                     case 11:
1613                       return -(1\&. + xi - zeta)*zeta/den;
1614 
1615                     case 12:
1616                       return (-1\&. + xi + zeta)*zeta/den;
1617 
1618                     default:
1619                       libmesh_error();
1620                     }
1621 
1622                   // d/dzeta
1623                 case 2:
1624                   {
1625                     switch(i)
1626                       {
1627                       case 0:
1628                         return -0\&.25*(xi + eta + 1\&.)*(-1\&. + 2\&.*zeta - zeta2 + eta*xi)/den2;
1629 
1630                       case 1:
1631                         return 0\&.25*(eta - xi + 1\&.)*(1\&. - 2\&.*zeta + zeta2 + eta*xi)/den2;
1632 
1633                       case 2:
1634                         return 0\&.25*(xi + eta - 1\&.)*(-1\&. + 2\&.*zeta - zeta2 + eta*xi)/den2;
1635 
1636                       case 3:
1637                         return -0\&.25*(eta - xi - 1\&.)*(1\&. - 2\&.*zeta + zeta2 + eta*xi)/den2;
1638 
1639                       case 4:
1640                         return 4\&.*zeta - 1\&.;
1641 
1642                       case 5:
1643                         return 0\&.5*(-2 + eta + 6\&.*zeta + eta*xi2 + eta*zeta2 - 6\&.*zeta2 + 2\&.*zeta3 - 2\&.*eta*zeta)/den2;
1644 
1645                       case 6:
1646                         return -0\&.5*(2 - 6\&.*zeta + xi + xi*zeta2 + eta2*xi + 6\&.*zeta2 - 2\&.*zeta3 - 2\&.*zeta*xi)/den2;
1647 
1648                       case 7:
1649                         return -0\&.5*(2 + eta - 6\&.*zeta + eta*xi2 + eta*zeta2 + 6\&.*zeta2 - 2\&.*zeta3 - 2\&.*eta*zeta)/den2;
1650 
1651                       case 8:
1652                         return 0\&.5*(-2 + 6\&.*zeta + xi + xi*zeta2 + eta2*xi - 6\&.*zeta2 + 2\&.*zeta3 - 2\&.*zeta*xi)/den2;
1653 
1654                       case 9:
1655                         return (1\&. - eta - 4\&.*zeta - xi - xi*zeta2 - eta*zeta2 + eta*xi + 5\&.*zeta2 - 2\&.*zeta3 + 2\&.*eta*zeta + 2\&.*zeta*xi)/den2;
1656 
1657                       case 10:
1658                         return -(-1\&. + eta + 4\&.*zeta - xi - xi*zeta2 + eta*zeta2 + eta*xi - 5\&.*zeta2 + 2\&.*zeta3 - 2\&.*eta*zeta + 2\&.*zeta*xi)/den2;
1659 
1660                       case 11:
1661                         return (1\&. + eta - 4\&.*zeta + xi + xi*zeta2 + eta*zeta2 + eta*xi + 5\&.*zeta2 - 2\&.*zeta3 - 2\&.*eta*zeta - 2\&.*zeta*xi)/den2;
1662 
1663                       case 12:
1664                         return -(-1\&. - eta + 4\&.*zeta + xi + xi*zeta2 - eta*zeta2 + eta*xi - 5\&.*zeta2 + 2\&.*zeta3 + 2\&.*eta*zeta - 2\&.*zeta*xi)/den2;
1665 
1666                       default:
1667                         libmesh_error();
1668                       }
1669                   }
1670 
1671                 default:
1672                   libmesh_error();
1673                 }
1674             }
1675 
1676             // Quadratic shape functions, as defined in R\&. Graglia, "Higher order
1677             // bases on pyramidal elements", IEEE Trans Antennas and Propagation,
1678             // vol 47, no 5, May 1999\&.
1679           case PYRAMID14:
1680             {
1681               libmesh_assert_less (i, 14);
1682 
1683               const Real xi   = p(0);
1684               const Real eta  = p(1);
1685               const Real zeta = p(2);
1686               const Real eps  = 1\&.e-35;
1687 
1688               // The "normalized coordinates" defined by Graglia\&.  These are
1689               // the planes which define the faces of the pyramid\&.
1690               Real
1691                 p1 = 0\&.5*(1\&. - eta - zeta), // back
1692                 p2 = 0\&.5*(1\&. + xi  - zeta), // left
1693                 p3 = 0\&.5*(1\&. + eta - zeta), // front
1694                 p4 = 0\&.5*(1\&. - xi  - zeta); // right
1695 
1696               // Denominators are perturbed by epsilon to avoid
1697               // divide-by-zero issues\&.
1698               Real
1699                 den = (-1\&. + zeta + eps),
1700                 den2 = den*den,
1701                 den3 = den2*den;
1702 
1703               switch (j)
1704                 {
1705                   // d/dxi
1706                 case 0:
1707                   switch(i)
1708                     {
1709                     case 0:
1710                       return 0\&.5*p1*(-xi*eta + zeta - zeta*zeta + 2\&.*p4*eta)/den2;
1711 
1712                     case 1:
1713                       return -0\&.5*p1*(xi*eta + zeta - zeta*zeta + 2\&.*p2*eta)/den2;
1714 
1715                     case 2:
1716                       return 0\&.5*p3*(xi*eta - zeta + zeta*zeta + 2\&.*p2*eta)/den2;
1717 
1718                     case 3:
1719                       return -0\&.5*p3*(-xi*eta - zeta + zeta*zeta + 2\&.*p4*eta)/den2;
1720 
1721                     case 4:
1722                       return 0\&.;
1723 
1724                     case 5:
1725                       return 2\&.*p1*eta*xi/den2;
1726 
1727                     case 6:
1728                       return 2\&.*p1*p3*(xi + 2\&.*p2)/den2;
1729 
1730                     case 7:
1731                       return -2\&.*p3*eta*xi/den2;
1732 
1733                     case 8:
1734                       return -2\&.*p1*p3*(-xi + 2\&.*p4)/den2;
1735 
1736                     case 9:
1737                       return 2\&.*p1*zeta/den;
1738 
1739                     case 10:
1740                       return -2\&.*p1*zeta/den;
1741 
1742                     case 11:
1743                       return -2\&.*p3*zeta/den;
1744 
1745                     case 12:
1746                       return 2\&.*p3*zeta/den;
1747 
1748                     case 13:
1749                       return -8\&.*p1*p3*xi/den2;
1750 
1751                     default:
1752                       libmesh_error();
1753                     }
1754 
1755                   // d/deta
1756                 case 1:
1757                   switch(i)
1758                     {
1759                     case 0:
1760                       return -0\&.5*p4*(xi*eta - zeta + zeta*zeta - 2\&.*p1*xi)/den2;
1761 
1762                     case 1:
1763                       return 0\&.5*p2*(xi*eta + zeta - zeta*zeta - 2\&.*p1*xi)/den2;
1764 
1765                     case 2:
1766                       return 0\&.5*p2*(xi*eta - zeta + zeta*zeta + 2\&.*p3*xi)/den2;
1767 
1768                     case 3:
1769                       return -0\&.5*p4*(xi*eta + zeta - zeta*zeta + 2\&.*p3*xi)/den2;
1770 
1771                     case 4:
1772                       return 0\&.;
1773 
1774                     case 5:
1775                       return 2\&.*p2*p4*(eta - 2\&.*p1)/den2;
1776 
1777                     case 6:
1778                       return -2\&.*p2*xi*eta/den2;
1779 
1780                     case 7:
1781                       return 2\&.*p2*p4*(eta + 2\&.*p3)/den2;
1782 
1783                     case 8:
1784                       return 2\&.*p4*xi*eta/den2;
1785 
1786                     case 9:
1787                       return 2\&.*p4*zeta/den;
1788 
1789                     case 10:
1790                       return 2\&.*p2*zeta/den;
1791 
1792                     case 11:
1793                       return -2\&.*p2*zeta/den;
1794 
1795                     case 12:
1796                       return -2\&.*p4*zeta/den;
1797 
1798                     case 13:
1799                       return -8\&.*p2*p4*eta/den2;
1800 
1801                     default:
1802                       libmesh_error();
1803                     }
1804 
1805 
1806                   // d/dzeta
1807                 case 2:
1808                   {
1809                     switch(i)
1810                       {
1811                       case 0:
1812                         return -0\&.5*p1*(xi*eta - zeta + zeta*zeta)/den2
1813                           - 0\&.5*p4*(xi*eta - zeta + zeta*zeta)/den2
1814                           + p4*p1*(2\&.*zeta - 1)/den2
1815                           - 2\&.*p4*p1*(xi*eta - zeta + zeta*zeta)/den3;
1816 
1817                       case 1:
1818                         return 0\&.5*p2*(xi*eta + zeta - zeta*zeta)/den2
1819                           + 0\&.5*p1*(xi*eta + zeta - zeta*zeta)/den2
1820                           - p1*p2*(1 - 2\&.*zeta)/den2
1821                           + 2\&.*p1*p2*(xi*eta + zeta - zeta*zeta)/den3;
1822 
1823                       case 2:
1824                         return -0\&.5*p3*(xi*eta - zeta + zeta*zeta)/den2
1825                           - 0\&.5*p2*(xi*eta - zeta + zeta*zeta)/den2
1826                           + p2*p3*(2\&.*zeta - 1)/den2
1827                           - 2\&.*p2*p3*(xi*eta - zeta + zeta*zeta)/den3;
1828 
1829                       case 3:
1830                         return 0\&.5*p4*(xi*eta + zeta - zeta*zeta)/den2
1831                           + 0\&.5*p3*(xi*eta + zeta - zeta*zeta)/den2
1832                           - p3*p4*(1 - 2\&.*zeta)/den2
1833                           + 2\&.*p3*p4*(xi*eta + zeta - zeta*zeta)/den3;
1834 
1835                       case 4:
1836                         return 4\&.*zeta - 1\&.;
1837 
1838                       case 5:
1839                         return 2\&.*p4*p1*eta/den2
1840                           + 2\&.*p2*p4*eta/den2
1841                           + 2\&.*p1*p2*eta/den2
1842                           + 8\&.*p2*p1*p4*eta/den3;
1843 
1844                       case 6:
1845                         return -2\&.*p2*p3*xi/den2
1846                           - 2\&.*p1*p3*xi/den2
1847                           - 2\&.*p1*p2*xi/den2
1848                           - 8\&.*p1*p2*p3*xi/den3;
1849 
1850                       case 7:
1851                         return -2\&.*p3*p4*eta/den2
1852                           - 2\&.*p2*p4*eta/den2
1853                           - 2\&.*p2*p3*eta/den2
1854                           - 8\&.*p2*p3*p4*eta/den3;
1855 
1856                       case 8:
1857                         return 2\&.*p4*p1*xi/den2
1858                           + 2\&.*p1*p3*xi/den2
1859                           + 2\&.*p3*p4*xi/den2
1860                           + 8\&.*p3*p4*p1*xi/den3;
1861 
1862                       case 9:
1863                         return 2\&.*p4*zeta/den
1864                           + 2\&.*p1*zeta/den
1865                           - 4\&.*p1*p4/den
1866                           + 4\&.*p1*p4*zeta/den2;
1867 
1868                       case 10:
1869                         return 2\&.*p1*zeta/den
1870                           + 2\&.*p2*zeta/den
1871                           - 4\&.*p2*p1/den
1872                           + 4\&.*p2*p1*zeta/den2;
1873 
1874                       case 11:
1875                         return 2\&.*p2*zeta/den
1876                           + 2\&.*p3*zeta/den
1877                           - 4\&.*p3*p2/den
1878                           + 4\&.*p3*p2*zeta/den2;
1879 
1880                       case 12:
1881                         return 2\&.*p3*zeta/den
1882                           + 2\&.*p4*zeta/den
1883                           - 4\&.*p4*p3/den
1884                           + 4\&.*p4*p3*zeta/den2;
1885 
1886                       case 13:
1887                         return -8\&.*p2*p3*p4/den2
1888                           - 8\&.*p3*p4*p1/den2
1889                           - 8\&.*p2*p1*p4/den2
1890                           - 8\&.*p1*p2*p3/den2
1891                           - 32\&.*p1*p2*p3*p4/den3;
1892 
1893                       default:
1894                         libmesh_error();
1895                       }
1896                   }
1897 
1898                 default:
1899                   libmesh_error();
1900                 }
1901             }
1902 
1903 
1904 
1905 
1906           default:
1907             {
1908               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
1909                            << std::endl;
1910               libmesh_error();
1911             }
1912           }
1913       }
1914 
1915 
1916       // unsupported order
1917     default:
1918       {
1919         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
1920                      << std::endl;
1921         libmesh_error();
1922       }
1923     }
1924 
1925 #endif
1926 
1927   libmesh_error();
1928   return 0\&.;
1929 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 601 of file fe_nedelec_one\&.C\&.
.PP
.nf
603 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 602 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_deriv()\&.
.PP
.nf
605 {
606   Real value = FE<2,LAGRANGE>::shape_deriv( type, order, i/2, j, p );
607 
608   switch( i%2 )
609     {
610     case 0:
611       return libMesh::RealGradient( value );
612 
613     case 1:
614       return libMesh::RealGradient( Real(0), value );
615 
616     default:
617       libmesh_error();
618     }
619 
620   //dummy
621   return libMesh::RealGradient();
622 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 605 of file fe_nedelec_one\&.C\&.
.PP
.nf
607 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 624 of file fe_nedelec_one\&.C\&.
.PP
.nf
626 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 628 of file fe_nedelec_one\&.C\&.
.PP
.nf
630 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 637 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
642 {
643   libmesh_assert(elem);
644 
645   // call the orientation-independent shape function derivatives
646   return FE<3,MONOMIAL>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
647 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 670 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_deriv()\&.
.PP
.nf
673 {
674   Real value = FE<3,LAGRANGE>::shape_deriv( type, order, i/3, j, p );
675 
676   switch( i%3 )
677     {
678     case 0:
679       return libMesh::RealGradient( value );
680 
681     case 1:
682       return libMesh::RealGradient( Real(0), value );
683 
684     case 2:
685       return libMesh::RealGradient( Real(0), Real(0), value );
686 
687     default:
688       libmesh_error();
689     }
690 
691   //dummy
692   return libMesh::RealGradient();
693 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 710 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
715 {
716   libMesh::err << "Hierarchic polynomials require the element type\n"
717                << "because edge and face orientation is needed\&."
718                << std::endl;
719   libmesh_error();
720 
721   return 0\&.;
722 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 710 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
715 {
716   libMesh::err << "Hierarchic polynomials require the element type\n"
717                << "because edge and face orientation is needed\&."
718                << std::endl;
719   libmesh_error();
720 
721   return 0\&.;
722 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 725 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
730 {
731   libMesh::err << "Szabo-Babuska polynomials require the element type\n"
732                << "because edge orientation is needed\&."
733                << std::endl;
734 
735   libmesh_error();
736   return 0\&.;
737 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 727 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
732 {
733 #if LIBMESH_DIM == 3
734   libmesh_assert(elem);
735 
736   libmesh_assert_less (j, 3);
737 
738   // cheat by using finite difference approximations:
739   const Real eps = 1\&.e-6;
740   Point pp, pm;
741 
742   switch (j)
743     {
744       // d()/dxi
745     case 0:
746       {
747         pp = Point(p(0)+eps, p(1), p(2));
748         pm = Point(p(0)-eps, p(1), p(2));
749         break;
750       }
751 
752       // d()/deta
753     case 1:
754       {
755         pp = Point(p(0), p(1)+eps, p(2));
756         pm = Point(p(0), p(1)-eps, p(2));
757         break;
758       }
759 
760       // d()/dzeta
761     case 2:
762       {
763         pp = Point(p(0), p(1), p(2)+eps);
764         pm = Point(p(0), p(1), p(2)-eps);
765         break;
766       }
767 
768     default:
769       libmesh_error();
770     }
771 
772   return (FE<3,L2_HIERARCHIC>::shape(elem, order, i, pp) -
773           FE<3,L2_HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
774 #endif
775 
776   libmesh_error();
777   return 0\&.;
778 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 727 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
732 {
733 #if LIBMESH_DIM == 3
734   libmesh_assert(elem);
735 
736   libmesh_assert_less (j, 3);
737 
738   // cheat by using finite difference approximations:
739   const Real eps = 1\&.e-6;
740   Point pp, pm;
741 
742   switch (j)
743     {
744       // d()/dxi
745     case 0:
746       {
747         pp = Point(p(0)+eps, p(1), p(2));
748         pm = Point(p(0)-eps, p(1), p(2));
749         break;
750       }
751 
752       // d()/deta
753     case 1:
754       {
755         pp = Point(p(0), p(1)+eps, p(2));
756         pm = Point(p(0), p(1)-eps, p(2));
757         break;
758       }
759 
760       // d()/dzeta
761     case 2:
762       {
763         pp = Point(p(0), p(1), p(2)+eps);
764         pm = Point(p(0), p(1), p(2)-eps);
765         break;
766       }
767 
768     default:
769       libmesh_error();
770     }
771 
772   return (FE<3,HIERARCHIC>::shape(elem, order, i, pp) -
773           FE<3,HIERARCHIC>::shape(elem, order, i, pm))/2\&./eps;
774 #endif
775 
776   libmesh_error();
777   return 0\&.;
778 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 728 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
731 {
732   Real value = FE<0,LAGRANGE>::shape_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
733   return libMesh::RealGradient( value );
734 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 742 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::FIFTH, libMesh::FIRST, libMesh::FOURTH, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::SEVENTH, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::SIXTH, libMesh::THIRD, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
747 {
748   libmesh_assert(elem);
749 
750   const ElemType type = elem->type();
751 
752   const Order totalorder = static_cast<Order>(order + elem->p_level());
753 
754   switch (totalorder)
755     {
756 
757       // 1st & 2nd-order Szabo-Babuska\&.
758     case FIRST:
759     case SECOND:
760       {
761         switch (type)
762           {
763 
764             // Szabo-Babuska shape functions on the triangle\&.
765           case TRI6:
766             {
767               // Here we use finite differences to compute the derivatives!
768               const Real eps = 1\&.e-6;
769 
770               libmesh_assert_less (i, 6);
771               libmesh_assert_less (j, 2);
772 
773               switch (j)
774                 {
775                   //  d()/dxi
776                 case 0:
777                   {
778                     const Point pp(p(0)+eps, p(1));
779                     const Point pm(p(0)-eps, p(1));
780 
781                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
782                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
783                   }
784 
785                   // d()/deta
786                 case 1:
787                   {
788                     const Point pp(p(0), p(1)+eps);
789                     const Point pm(p(0), p(1)-eps);
790 
791                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
792                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
793                   }
794 
795 
796                 default:
797                   libmesh_error();
798                 }
799             }
800 
801 
802 
803             // Szabo-Babuska shape functions on the quadrilateral\&.
804           case QUAD8:
805           case QUAD9:
806             {
807               // Compute quad shape functions as a tensor-product
808               const Real xi  = p(0);
809               const Real eta = p(1);
810 
811               libmesh_assert_less (i, 9);
812 
813               //                                0  1  2  3  4  5  6  7  8
814               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
815               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
816 
817               switch (j)
818                 {
819                   // d()/dxi
820                 case 0:
821                   return (FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
822                           FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
823 
824                   // d()/deta
825                 case 1:
826                   return (FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
827                           FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
828 
829                 default:
830                   libmesh_error();
831                 }
832             }
833 
834           default:
835             libmesh_error();
836           }
837       }
838 
839 
840 
841       // 3rd-order Szabo-Babuska\&.
842     case THIRD:
843       {
844         switch (type)
845           {
846             // Szabo-Babuska shape functions on the triangle\&.
847           case TRI6:
848             {
849               // Here we use finite differences to compute the derivatives!
850               const Real eps = 1\&.e-6;
851 
852               libmesh_assert_less (i, 10);
853               libmesh_assert_less (j, 2);
854 
855               switch (j)
856                 {
857                   //  d()/dxi
858                 case 0:
859                   {
860                     const Point pp(p(0)+eps, p(1));
861                     const Point pm(p(0)-eps, p(1));
862 
863                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
864                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
865                   }
866 
867                   // d()/deta
868                 case 1:
869                   {
870                     const Point pp(p(0), p(1)+eps);
871                     const Point pm(p(0), p(1)-eps);
872 
873                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
874                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
875                   }
876 
877 
878                 default:
879                   libmesh_error();
880                 }
881             }
882 
883 
884             // Szabo-Babuska shape functions on the quadrilateral\&.
885           case QUAD8:
886           case QUAD9:
887             {
888               // Compute quad shape functions as a tensor-product
889               const Real xi  = p(0);
890               const Real eta = p(1);
891 
892               libmesh_assert_less (i, 16);
893 
894               //                                0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
895               static const unsigned int i0[] = {0,  1,  1,  0,  2,  3,  1,  1,  2,  3,  0,  0,  2,  3,  2,  3};
896               static const unsigned int i1[] = {0,  0,  1,  1,  0,  0,  2,  3,  1,  1,  2,  3,  2,  2,  3,  3};
897 
898               Real f=1\&.;
899 
900               switch(i)
901                 {
902                 case  5: // edge 0 points
903                   if (elem->point(0) > elem->point(1))f = -1\&.;
904                   break;
905                 case  7: // edge 1 points
906                   if (elem->point(1) > elem->point(2))f = -1\&.;
907                   break;
908                 case  9: // edge 2 points
909                   if (elem->point(3) > elem->point(2))f = -1\&.;
910                   break;
911                 case 11: // edge 3 points
912                   if (elem->point(0) > elem->point(3))f = -1\&.;
913                   break;
914                 }
915 
916 
917               switch (j)
918                 {
919                   // d()/dxi
920                 case 0:
921                   return f*(FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
922                             FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
923 
924                   // d()/deta
925                 case 1:
926                   return f*(FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
927                             FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
928 
929                 default:
930                   libmesh_error();
931                 }
932             }
933 
934           default:
935             libmesh_error();
936           }
937       }
938 
939 
940 
941 
942       // 4th-order Szabo-Babuska\&.
943     case FOURTH:
944       {
945         switch (type)
946           {
947 
948             // Szabo-Babuska shape functions on the triangle\&.
949           case TRI6:
950             {
951               // Here we use finite differences to compute the derivatives!
952               const Real eps = 1\&.e-6;
953 
954               libmesh_assert_less (i, 15);
955               libmesh_assert_less (j, 2);
956 
957               switch (j)
958                 {
959                   //  d()/dxi
960                 case 0:
961                   {
962                     const Point pp(p(0)+eps, p(1));
963                     const Point pm(p(0)-eps, p(1));
964 
965                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
966                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
967                   }
968 
969                   // d()/deta
970                 case 1:
971                   {
972                     const Point pp(p(0), p(1)+eps);
973                     const Point pm(p(0), p(1)-eps);
974 
975                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
976                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
977                   }
978 
979 
980                 default:
981                   libmesh_error();
982                 }
983             }
984 
985 
986 
987             // Szabo-Babuska shape functions on the quadrilateral\&.
988           case QUAD8:
989           case QUAD9:
990             {
991               // Compute quad shape functions as a tensor-product
992               const Real xi  = p(0);
993               const Real eta = p(1);
994 
995               libmesh_assert_less (i, 25);
996 
997               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
998               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4};
999               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
1000 
1001               Real f=1\&.;
1002 
1003               switch(i)
1004                 {
1005                 case  5: // edge 0 points
1006                   if (elem->point(0) > elem->point(1))f = -1\&.;
1007                   break;
1008                 case  8: // edge 1 points
1009                   if (elem->point(1) > elem->point(2))f = -1\&.;
1010                   break;
1011                 case 11: // edge 2 points
1012                   if (elem->point(3) > elem->point(2))f = -1\&.;
1013                   break;
1014                 case 14: // edge 3 points
1015                   if (elem->point(0) > elem->point(3))f = -1\&.;
1016                   break;
1017                 }
1018 
1019 
1020               switch (j)
1021                 {
1022                   // d()/dxi
1023                 case 0:
1024                   return f*(FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1025                             FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
1026 
1027                   // d()/deta
1028                 case 1:
1029                   return f*(FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
1030                             FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1031 
1032                 default:
1033                   libmesh_error();
1034                 }
1035             }
1036 
1037           default:
1038             libmesh_error();
1039           }
1040       }
1041 
1042 
1043 
1044 
1045       // 5th-order Szabo-Babuska\&.
1046     case FIFTH:
1047       {
1048         // Szabo-Babuska shape functions on the quadrilateral\&.
1049         switch (type)
1050           {
1051 
1052             // Szabo-Babuska shape functions on the triangle\&.
1053           case TRI6:
1054             {
1055               // Here we use finite differences to compute the derivatives!
1056               const Real eps = 1\&.e-6;
1057 
1058               libmesh_assert_less (i, 21);
1059               libmesh_assert_less (j, 2);
1060 
1061               switch (j)
1062                 {
1063                   //  d()/dxi
1064                 case 0:
1065                   {
1066                     const Point pp(p(0)+eps, p(1));
1067                     const Point pm(p(0)-eps, p(1));
1068 
1069                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1070                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1071                   }
1072 
1073                   // d()/deta
1074                 case 1:
1075                   {
1076                     const Point pp(p(0), p(1)+eps);
1077                     const Point pm(p(0), p(1)-eps);
1078 
1079                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1080                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1081                   }
1082 
1083 
1084                 default:
1085                   libmesh_error();
1086                 }
1087             }
1088 
1089 
1090 
1091           case QUAD8:
1092           case QUAD9:
1093             {
1094               // Compute quad shape functions as a tensor-product
1095               const Real xi  = p(0);
1096               const Real eta = p(1);
1097 
1098               libmesh_assert_less (i, 36);
1099 
1100               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
1101               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
1102               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
1103 
1104               Real f=1\&.;
1105 
1106               switch(i)
1107                 {
1108                 case  5: // edge 0 points
1109                 case  7:
1110                   if (elem->point(0) > elem->point(1))f = -1\&.;
1111                   break;
1112                 case  9: // edge 1 points
1113                 case 11:
1114                   if (elem->point(1) > elem->point(2))f = -1\&.;
1115                   break;
1116                 case 13: // edge 2 points
1117                 case 15:
1118                   if (elem->point(3) > elem->point(2))f = -1\&.;
1119                   break;
1120                 case 14: // edge 3 points
1121                 case 19:
1122                   if (elem->point(0) > elem->point(3))f = -1\&.;
1123                   break;
1124                 }
1125 
1126 
1127               switch (j)
1128                 {
1129                   // d()/dxi
1130                 case 0:
1131                   return f*(FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1132                             FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
1133 
1134                   // d()/deta
1135                 case 1:
1136                   return f*(FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
1137                             FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1138 
1139                 default:
1140                   libmesh_error();
1141                 }
1142             }
1143 
1144           default:
1145             libmesh_error();
1146           }
1147       }
1148 
1149 
1150       // 6th-order Szabo-Babuska\&.
1151     case SIXTH:
1152       {
1153         // Szabo-Babuska shape functions on the quadrilateral\&.
1154         switch (type)
1155           {
1156 
1157             // Szabo-Babuska shape functions on the triangle\&.
1158           case TRI6:
1159             {
1160               // Here we use finite differences to compute the derivatives!
1161               const Real eps = 1\&.e-6;
1162 
1163               libmesh_assert_less (i, 28);
1164               libmesh_assert_less (j, 2);
1165 
1166               switch (j)
1167                 {
1168                   //  d()/dxi
1169                 case 0:
1170                   {
1171                     const Point pp(p(0)+eps, p(1));
1172                     const Point pm(p(0)-eps, p(1));
1173 
1174                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1175                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1176                   }
1177 
1178                   // d()/deta
1179                 case 1:
1180                   {
1181                     const Point pp(p(0), p(1)+eps);
1182                     const Point pm(p(0), p(1)-eps);
1183 
1184                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1185                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1186                   }
1187 
1188 
1189                 default:
1190                   libmesh_error();
1191                 }
1192             }
1193 
1194 
1195 
1196           case QUAD8:
1197           case QUAD9:
1198             {
1199               // Compute quad shape functions as a tensor-product
1200               const Real xi  = p(0);
1201               const Real eta = p(1);
1202 
1203               libmesh_assert_less (i, 49);
1204 
1205               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
1206               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6};
1207               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6};
1208 
1209               Real f=1\&.;
1210 
1211               switch(i)
1212                 {
1213                 case  5: // edge 0 points
1214                 case  7:
1215                   if (elem->point(0) > elem->point(1))f = -1\&.;
1216                   break;
1217                 case 10: // edge 1 points
1218                 case 12:
1219                   if (elem->point(1) > elem->point(2))f = -1\&.;
1220                   break;
1221                 case 15: // edge 2 points
1222                 case 17:
1223                   if (elem->point(3) > elem->point(2))f = -1\&.;
1224                   break;
1225                 case 20: // edge 3 points
1226                 case 22:
1227                   if (elem->point(0) > elem->point(3))f = -1\&.;
1228                   break;
1229                 }
1230 
1231 
1232               switch (j)
1233                 {
1234                   // d()/dxi
1235                 case 0:
1236                   return f*(FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1237                             FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
1238 
1239                   // d()/deta
1240                 case 1:
1241                   return f*(FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
1242                             FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1243 
1244                 default:
1245                   libmesh_error();
1246                 }
1247             }
1248 
1249           default:
1250             libmesh_error();
1251           }
1252       }
1253 
1254 
1255       // 7th-order Szabo-Babuska\&.
1256     case SEVENTH:
1257       {
1258         // Szabo-Babuska shape functions on the quadrilateral\&.
1259         switch (type)
1260           {
1261 
1262             // Szabo-Babuska shape functions on the triangle\&.
1263           case TRI6:
1264             {
1265               // Here we use finite differences to compute the derivatives!
1266               const Real eps = 1\&.e-6;
1267 
1268               libmesh_assert_less (i, 36);
1269               libmesh_assert_less (j, 2);
1270 
1271               switch (j)
1272                 {
1273                   //  d()/dxi
1274                 case 0:
1275                   {
1276                     const Point pp(p(0)+eps, p(1));
1277                     const Point pm(p(0)-eps, p(1));
1278 
1279                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1280                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1281                   }
1282 
1283                   // d()/deta
1284                 case 1:
1285                   {
1286                     const Point pp(p(0), p(1)+eps);
1287                     const Point pm(p(0), p(1)-eps);
1288 
1289                     return (FE<2,SZABAB>::shape(elem, order, i, pp) -
1290                             FE<2,SZABAB>::shape(elem, order, i, pm))/2\&./eps;
1291                   }
1292 
1293 
1294                 default:
1295                   libmesh_error();
1296                 }
1297             }
1298 
1299 
1300 
1301           case QUAD8:
1302           case QUAD9:
1303             {
1304               // Compute quad shape functions as a tensor-product
1305               const Real xi  = p(0);
1306               const Real eta = p(1);
1307 
1308               libmesh_assert_less (i, 64);
1309 
1310               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
1311               static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7};
1312               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7};
1313 
1314               Real f=1\&.;
1315 
1316               switch(i)
1317                 {
1318                 case  5: // edge 0 points
1319                 case  7:
1320                 case  9:
1321                   if (elem->point(0) > elem->point(1))f = -1\&.;
1322                   break;
1323                 case 11: // edge 1 points
1324                 case 13:
1325                 case 15:
1326                   if (elem->point(1) > elem->point(2))f = -1\&.;
1327                   break;
1328                 case 17: // edge 2 points
1329                 case 19:
1330                 case 21:
1331                   if (elem->point(3) > elem->point(2))f = -1\&.;
1332                   break;
1333                 case 23: // edge 3 points
1334                 case 25:
1335                 case 27:
1336                   if (elem->point(0) > elem->point(3))f = -1\&.;
1337                   break;
1338                 }
1339 
1340 
1341               switch (j)
1342                 {
1343                   // d()/dxi
1344                 case 0:
1345                   return f*(FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1346                             FE<1,SZABAB>::shape      (EDGE3, totalorder, i1[i],    eta));
1347 
1348                   // d()/deta
1349                 case 1:
1350                   return f*(FE<1,SZABAB>::shape      (EDGE3, totalorder, i0[i],    xi)*
1351                             FE<1,SZABAB>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1352 
1353                 default:
1354                   libmesh_error();
1355                 }
1356             }
1357 
1358           default:
1359             libmesh_error();
1360           }
1361       }
1362 
1363 
1364 
1365       // by default throw an error;call the orientation-independent shape functions
1366     default:
1367       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
1368       libmesh_error();
1369     }
1370 
1371 
1372   libmesh_error();
1373   return 0\&.;
1374 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 750 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
753 {
754   Real value = FE<1,LAGRANGE>::shape_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
755   return libMesh::RealGradient( value );
756 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 763 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FOURTH, and libMesh::TRI3SUBDIVISION\&.
.PP
.nf
768 {
769   switch (order)
770     {
771     case FOURTH:
772       {
773         switch (type)
774           {
775           case TRI3SUBDIVISION:
776             libmesh_assert_less(i, 12);
777             return FESubdivision::regular_shape_deriv(i,j,p(0),p(1));
778           default:
779             std::cerr << "ERROR: Unsupported element type!" << std::endl;
780             libmesh_error();
781           }
782       }
783     default:
784       std::cerr << "ERROR: Unsupported polynomial order!" << std::endl;
785       libmesh_error();
786     }
787 
788   libmesh_error();
789   return 0\&.;
790 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 786 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
789 {
790   Real value = FE<2,LAGRANGE>::shape_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i/2, j, p );
791 
792   switch( i%2 )
793     {
794     case 0:
795       return libMesh::RealGradient( value );
796 
797     case 1:
798       return libMesh::RealGradient( Real(0), value );
799 
800     default:
801       libmesh_error();
802     }
803 
804   //dummy
805   return libMesh::RealGradient();
806 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 795 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), and libMesh::Elem::type()\&.
.PP
.nf
800 {
801   libmesh_assert(elem);
802   return FE<2,SUBDIVISION>::shape_deriv(elem->type(), order, i, j, p);
803 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 853 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
856 {
857   Real value = FE<3,LAGRANGE>::shape_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i/3, j, p );
858 
859   switch( i%3 )
860     {
861     case 0:
862       return libMesh::RealGradient( value );
863 
864     case 1:
865       return libMesh::RealGradient( Real(0), value );
866 
867     case 2:
868       return libMesh::RealGradient( Real(0), Real(0), value );
869 
870     default:
871       libmesh_error();
872     }
873 
874   //dummy
875   return libMesh::RealGradient();
876 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 953 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
958 {
959   libMesh::err << "Bernstein polynomials require the element type\n"
960                << "because edge orientation is needed\&."
961                << std::endl;
962 
963   libmesh_error();
964   return 0\&.;
965 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"
Note, since the derivatives are computed using \fBFE::shape\fP the continuity along neighboring elements (shape_flip) is already considered\&.
.PP
Definition at line 970 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::square_number_column, libMesh::square_number_row, libMesh::TRI3, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
975 {
976   libmesh_assert(elem);
977 
978   const ElemType type = elem->type();
979 
980   const Order totalorder = static_cast<Order>(order + elem->p_level());
981 
982   switch (type)
983     {
984       // Hierarchic shape functions on the quadrilateral\&.
985     case QUAD4:
986     case QUAD9:
987       {
988         // Compute quad shape functions as a tensor-product
989         const Real xi  = p(0);
990         const Real eta = p(1);
991 
992         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
993 
994         unsigned int i0, i1;
995 
996         // Vertex DoFs
997         if (i == 0)
998           { i0 = 0; i1 = 0; }
999         else if (i == 1)
1000           { i0 = 1; i1 = 0; }
1001         else if (i == 2)
1002           { i0 = 1; i1 = 1; }
1003         else if (i == 3)
1004           { i0 = 0; i1 = 1; }
1005 
1006 
1007         // Edge DoFs
1008         else if (i < totalorder + 3u)
1009           { i0 = i - 2; i1 = 0; }
1010         else if (i < 2u*totalorder + 2)
1011           { i0 = 1; i1 = i - totalorder - 1; }
1012         else if (i < 3u*totalorder + 1)
1013           { i0 = i - 2u*totalorder; i1 = 1; }
1014         else if (i < 4u*totalorder)
1015           { i0 = 0; i1 = i - 3u*totalorder + 1; }
1016         // Interior DoFs
1017         else
1018           {
1019             unsigned int basisnum = i - 4*totalorder;
1020             i0 = square_number_column[basisnum] + 2;
1021             i1 = square_number_row[basisnum] + 2;
1022           }
1023 
1024 
1025         // Flip odd degree of freedom values if necessary
1026         // to keep continuity on sides
1027         if     ((i>= 4                 && i<= 4+  totalorder-2u) && elem->point(0) > elem->point(1)) i0=totalorder+2-i0;//
1028         else if((i>= 4+  totalorder-1u && i<= 4+2*totalorder-3u) && elem->point(1) > elem->point(2)) i1=totalorder+2-i1;
1029         else if((i>= 4+2*totalorder-2u && i<= 4+3*totalorder-4u) && elem->point(3) > elem->point(2)) i0=totalorder+2-i0;
1030         else if((i>= 4+3*totalorder-3u && i<= 4+4*totalorder-5u) && elem->point(0) > elem->point(3)) i1=totalorder+2-i1;
1031 
1032         switch (j)
1033           {
1034             // d()/dxi
1035           case 0:
1036             return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
1037                     FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1,    eta));
1038 
1039             // d()/deta
1040           case 1:
1041             return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0,    xi)*
1042                     FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
1043 
1044           }
1045       }
1046 
1047       // Bernstein shape functions on the 8-noded quadrilateral
1048       // is handled separately\&.
1049     case QUAD8:
1050       {
1051         libmesh_assert_less (totalorder, 3);
1052 
1053         const Real xi  = p(0);
1054         const Real eta = p(1);
1055 
1056         libmesh_assert_less (i, 8);
1057 
1058         //                                0  1  2  3  4  5  6  7  8
1059         static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
1060         static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
1061         static const Real scal[] = {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.5, 0\&.5, 0\&.5, 0\&.5};
1062         switch (j)
1063           {
1064             // d()/dxi
1065           case 0:
1066             return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1067                     FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)
1068                     +scal[i]*
1069                     FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[8], 0, xi)*
1070                     FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[8],    eta));
1071 
1072             // d()/deta
1073           case 1:
1074             return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1075                     FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta)
1076                     +scal[i]*
1077                     FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[8],    xi)*
1078                     FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[8], 0, eta));
1079 
1080           default:
1081             libmesh_error();
1082           }
1083       }
1084 
1085     case TRI3:
1086       libmesh_assert_less (totalorder, 2);
1087     case TRI6:
1088       {
1089         // I have been lazy here and am using finite differences
1090         // to compute the derivatives!
1091         const Real eps = 1\&.e-6;
1092 
1093         switch (j)
1094           {
1095             //  d()/dxi
1096           case 0:
1097             {
1098               const Point pp(p(0)+eps, p(1));
1099               const Point pm(p(0)-eps, p(1));
1100 
1101               return (FE<2,BERNSTEIN>::shape(elem, totalorder, i, pp) -
1102                       FE<2,BERNSTEIN>::shape(elem, totalorder, i, pm))/2\&./eps;
1103             }
1104 
1105             // d()/deta
1106           case 1:
1107             {
1108               const Point pp(p(0), p(1)+eps);
1109               const Point pm(p(0), p(1)-eps);
1110 
1111               return (FE<2,BERNSTEIN>::shape(elem, totalorder, i, pp) -
1112                       FE<2,BERNSTEIN>::shape(elem, totalorder, i, pm))/2\&./eps;
1113             }
1114 
1115 
1116           default:
1117             libmesh_error();
1118           }
1119       }
1120 
1121     default:
1122       {
1123         libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1124         libmesh_error();
1125       }
1126 
1127     }
1128 
1129   // old code
1130   //   switch (totalorder)
1131   //     {
1132 
1133   //       // 1st order Bernsteins are aquivalent to Lagrange elements\&.
1134   //     case FIRST:
1135   //       {
1136   // switch (type)
1137   //   {
1138   //     // Bernstein shape functions on the triangle\&.
1139   //   case TRI6:
1140   //     {
1141   //       // I have been lazy here and am using finite differences
1142   //       // to compute the derivatives!
1143   //       const Real eps = 1\&.e-6;
1144 
1145   //       libmesh_assert_less (i, 3);
1146   //       libmesh_assert_less (j, 2);
1147 
1148   //       switch (j)
1149   // {
1150   //   //  d()/dxi
1151   // case 0:
1152   //   {
1153   //     const Point pp(p(0)+eps, p(1));
1154   //     const Point pm(p(0)-eps, p(1));
1155 
1156   //     return (FE<2,BERNSTEIN>::shape(elem, order, i, pp) -
1157   //     FE<2,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1158   //   }
1159 
1160   //   // d()/deta
1161   // case 1:
1162   //   {
1163   //     const Point pp(p(0), p(1)+eps);
1164   //     const Point pm(p(0), p(1)-eps);
1165 
1166   //     return (FE<2,BERNSTEIN>::shape(elem, order, i, pp) -
1167   //     FE<2,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1168   //   }
1169 
1170 
1171   // default:
1172   //   libmesh_error();
1173   // }
1174   //     }
1175 
1176   //     // Bernstein shape functions on the quadrilateral\&.
1177   //   case QUAD8:
1178   //   case QUAD9:
1179   //     {
1180   //       // Compute quad shape functions as a tensor-product
1181   //       const Real xi  = p(0);
1182   //       const Real eta = p(1);
1183 
1184   //       libmesh_assert_less (i, 4);
1185 
1186   //       //                                0  1  2  3
1187   //       static const unsigned int i0[] = {0, 1, 1, 0};
1188   //       static const unsigned int i1[] = {0, 0, 1, 1};
1189 
1190   //       switch (j)
1191   // {
1192   //   // d()/dxi
1193   // case 0:
1194   //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1195   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta));
1196 
1197   //   // d()/deta
1198   // case 1:
1199   //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1200   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1201 
1202   // default:
1203   //   libmesh_error();
1204   // }
1205   //     }
1206 
1207   //   default:
1208   //     libmesh_error();
1209   //   }
1210   //       }
1211 
1212   //       // second order Bernsteins\&.
1213   //     case SECOND:
1214   //       {
1215   // switch (type)
1216   //   {
1217   //     // Bernstein shape functions on the triangle\&.
1218   //   case TRI6:
1219   //     {
1220   //       // I have been lazy here and am using finite differences
1221   //       // to compute the derivatives!
1222   //       const Real eps = 1\&.e-6;
1223 
1224   //       libmesh_assert_less (i, 6);
1225   //       libmesh_assert_less (j, 2);
1226 
1227   //       switch (j)
1228   // {
1229   //   //  d()/dxi
1230   // case 0:
1231   //   {
1232   //     const Point pp(p(0)+eps, p(1));
1233   //     const Point pm(p(0)-eps, p(1));
1234 
1235   //     return (FE<2,BERNSTEIN>::shape(elem, order, i, pp) -
1236   //     FE<2,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1237   //   }
1238 
1239   //   // d()/deta
1240   // case 1:
1241   //   {
1242   //     const Point pp(p(0), p(1)+eps);
1243   //     const Point pm(p(0), p(1)-eps);
1244 
1245   //     return (FE<2,BERNSTEIN>::shape(elem, order, i, pp) -
1246   //     FE<2,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1247   //   }
1248 
1249 
1250   // default:
1251   //   libmesh_error();
1252   // }
1253   //     }
1254 
1255   //     // Bernstein shape functions on the 8-noded quadrilateral\&.
1256   //   case QUAD8:
1257   //     {
1258   //       const Real xi  = p(0);
1259   //       const Real eta = p(1);
1260 
1261   //       libmesh_assert_less (i, 8);
1262 
1263   //       //                                0  1  2  3  4  5  6  7  8
1264   //       static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
1265   //       static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
1266   //       static const Real scal[] = {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.5, 0\&.5, 0\&.5, 0\&.5};
1267   //       switch (j)
1268   // {
1269   //   // d()/dxi
1270   // case 0:
1271   //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1272   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)
1273   //   +scal[i]*
1274   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[8], 0, xi)*
1275   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[8],    eta));
1276 
1277   //   // d()/deta
1278   // case 1:
1279   //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1280   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta)
1281   //   +scal[i]*
1282   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[8],    xi)*
1283   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[8], 0, eta));
1284 
1285   // default:
1286   //   libmesh_error();
1287   // }
1288   //     }
1289 
1290 
1291   //     // Bernstein shape functions on the 9-noded quadrilateral\&.
1292   //   case QUAD9:
1293   //     {
1294   //       // Compute quad shape functions as a tensor-product
1295   //       const Real xi  = p(0);
1296   //       const Real eta = p(1);
1297 
1298   //       libmesh_assert_less (i, 9);
1299 
1300   //       //                                0  1  2  3  4  5  6  7  8
1301   //       static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
1302   //       static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
1303 
1304   //       switch (j)
1305   // {
1306   //   // d()/dxi
1307   // case 0:
1308   //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1309   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta));
1310 
1311   //   // d()/deta
1312   // case 1:
1313   //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1314   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1315 
1316   // default:
1317   //   libmesh_error();
1318   // }
1319   //     }
1320 
1321   //   default:
1322   //     libmesh_error();
1323   //   }
1324   //       }
1325 
1326 
1327   //       // 3rd-order Bernsteins\&.
1328   //     case THIRD:
1329   //       {
1330   // switch (type)
1331   //   {
1332   //     // Bernstein shape functions on the triangle\&.
1333   //   case TRI6:
1334   //     {
1335   //       // I have been lazy here and am using finite differences
1336   //       // to compute the derivatives!
1337   //       const Real eps = 1\&.e-6;
1338 
1339   //       libmesh_assert_less (i, 10);
1340   //       libmesh_assert_less (j, 2);
1341 
1342 
1343   //       unsigned int shape=i;
1344 
1345   //       /**
1346   //        * Note, since the derivatives are computed using FE::shape
1347   //        * the continuity along neighboring elements (shape_flip)
1348   //        * is already considered\&.
1349   //        */
1350 
1351 
1352   //       switch (j)
1353   // {
1354   //   //  d()/dxi
1355   // case 0:
1356   //   {
1357   //     const Point pp(p(0)+eps, p(1));
1358   //     const Point pm(p(0)-eps, p(1));
1359 
1360   //     return (FE<2,BERNSTEIN>::shape(elem, totalorder, shape, pp) -
1361   //     FE<2,BERNSTEIN>::shape(elem, totalorder, shape, pm))/2\&./eps;
1362   //   }
1363 
1364   //   // d()/deta
1365   // case 1:
1366   //   {
1367   //     const Point pp(p(0), p(1)+eps);
1368   //     const Point pm(p(0), p(1)-eps);
1369 
1370   //     return (FE<2,BERNSTEIN>::shape(elem, totalorder, shape, pp) -
1371   //     FE<2,BERNSTEIN>::shape(elem, totalorder, shape, pm))/2\&./eps;
1372   //   }
1373 
1374 
1375   // default:
1376   //   libmesh_error();
1377   // }
1378   //     }
1379 
1380 
1381 
1382   //     // Bernstein shape functions on the quadrilateral\&.
1383   //   case QUAD8:
1384   //   case QUAD9:
1385   //     {
1386   //       // Compute quad shape functions as a tensor-product
1387   //       const Real xi  = p(0);
1388   //       const Real eta = p(1);
1389 
1390   //       libmesh_assert_less (i, 16);
1391 
1392   //   //                                    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
1393   //       static const unsigned int i0_reg[] = {0,  1,  1,  0,  2,  3,  1,  1,  2,  3,  0,  0,  2,  3,  2,  3};
1394   //       static const unsigned int i1_reg[] = {0,  0,  1,  1,  0,  0,  2,  3,  1,  1,  2,  3,  2,  2,  3,  3};
1395 
1396   //       unsigned int i0=i0_reg[i];
1397   //       unsigned int i1=i1_reg[i];
1398 
1399   //       if((i== 4||i== 5) && elem->node(0) > elem->node(1)) i0=5-i0;
1400   //       if((i== 6||i== 7) && elem->node(1) > elem->node(2)) i1=5-i1;
1401   //       if((i== 8||i== 9) && elem->node(3) > elem->node(2)) i0=5-i0;
1402   //       if((i==10||i==11) && elem->node(0) > elem->node(3)) i1=5-i1;
1403 
1404   //       switch (j)
1405   // {
1406   //   // d()/dxi
1407   // case 0:
1408   //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
1409   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1,    eta));
1410 
1411   //   // d()/deta
1412   // case 1:
1413   //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0,    xi)*
1414   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
1415 
1416   // default:
1417   //   libmesh_error();
1418   // }
1419   //     }
1420 
1421   //   default:
1422   //     libmesh_error();
1423   //   }
1424   //       }
1425 
1426 
1427 
1428 
1429   //       // 4th-order Bernsteins\&.
1430   //     case FOURTH:
1431   //       {
1432   // switch (type)
1433   //   {
1434   //     // Bernstein shape functions on the triangle\&.
1435   //   case TRI6:
1436   //     {
1437   //       // I have been lazy here and am using finite differences
1438   //       // to compute the derivatives!
1439   //       const Real eps = 1\&.e-6;
1440 
1441   //       libmesh_assert_less (i, 15);
1442   //       libmesh_assert_less (j, 2);
1443 
1444   //       unsigned int shape=i;
1445 
1446   //       switch (j)
1447   // {
1448   //   //  d()/dxi
1449   // case 0:
1450   //   {
1451   //     const Point pp(p(0)+eps, p(1));
1452   //     const Point pm(p(0)-eps, p(1));
1453 
1454   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1455   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1456   //   }
1457 
1458   //   // d()/deta
1459   // case 1:
1460   //   {
1461   //     const Point pp(p(0), p(1)+eps);
1462   //     const Point pm(p(0), p(1)-eps);
1463 
1464   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1465   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1466   //   }
1467 
1468 
1469   // default:
1470   //   libmesh_error();
1471   // }
1472   //     }
1473 
1474 
1475 
1476   //     // Bernstein shape functions on the quadrilateral\&.
1477   //   case QUAD8:
1478   //   case QUAD9:
1479   //     {
1480   //       // Compute quad shape functions as a tensor-product
1481   //       const Real xi  = p(0);
1482   //       const Real eta = p(1);
1483 
1484   //       libmesh_assert_less (i, 25);
1485 
1486   //       //                                      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
1487   //       static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4};
1488   //       static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
1489 
1490   //       unsigned int i0=i0_reg[i];
1491   //       unsigned int i1=i1_reg[i];
1492 
1493   // if((i== 4||i== 6) && elem->node(0) > elem->node(1)) i0=6-i0;
1494   // if((i== 7||i== 9) && elem->node(1) > elem->node(2)) i1=6-i1;
1495   // if((i==10||i==12) && elem->node(3) > elem->node(2)) i0=6-i0;
1496   //         if((i==13||i==15) && elem->node(0) > elem->node(3)) i1=6-i1;
1497 
1498 
1499   // switch (j)
1500   //   {
1501   //     // d()/dxi
1502   //   case 0:
1503   //     return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
1504   //     FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1,    eta));
1505 
1506   //   // d()/deta
1507   //   case 1:
1508   //     return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0,    xi)*
1509   //     FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
1510 
1511   // default:
1512   //   libmesh_error();
1513   // }
1514   //     }
1515 
1516   //   default:
1517   //     libmesh_error();
1518   //   }
1519   //       }
1520 
1521 
1522 
1523 
1524   //       // 5th-order Bernsteins\&.
1525   //     case FIFTH:
1526   //       {
1527   // // Bernstein shape functions on the quadrilateral\&.
1528   // switch (type)
1529   //   {
1530   //     // Bernstein shape functions on the triangle\&.
1531   //   case TRI6:
1532   //     {
1533   //       // I have been lazy here and am using finite differences
1534   //       // to compute the derivatives!
1535   //       const Real eps = 1\&.e-6;
1536 
1537   //       libmesh_assert_less (i, 21);
1538   //       libmesh_assert_less (j, 2);
1539 
1540   //       unsigned int shape=i;
1541 
1542   //       switch (j)
1543   // {
1544   //   //  d()/dxi
1545   // case 0:
1546   //   {
1547   //     const Point pp(p(0)+eps, p(1));
1548   //     const Point pm(p(0)-eps, p(1));
1549 
1550   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1551   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1552   //   }
1553 
1554   //   // d()/deta
1555   // case 1:
1556   //   {
1557   //     const Point pp(p(0), p(1)+eps);
1558   //     const Point pm(p(0), p(1)-eps);
1559 
1560   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1561   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1562   //   }
1563 
1564 
1565   // default:
1566   //   libmesh_error();
1567   // }
1568   //     } // case TRI6
1569 
1570 
1571 
1572   //   case QUAD8:
1573   //   case QUAD9:
1574   //     {
1575   //       // Compute quad shape functions as a tensor-product
1576   //       const Real xi  = p(0);
1577   //       const Real eta = p(1);
1578 
1579   //       libmesh_assert_less (i, 36);
1580 
1581   //       //                                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
1582   //     static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5, 2, 3, 4, 5};
1583   //     static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 0, 2, 3, 4, 5, 1, 1, 1, 1, 2, 3, 4, 5, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};
1584 
1585   //     unsigned int i0=i0_reg[i];
1586   //     unsigned int i1=i1_reg[i];
1587 
1588   //     if((i>= 4&&i<= 7) && elem->node(0) > elem->node(1)) i0=7-i0;
1589   //     if((i>= 8&&i<=11) && elem->node(1) > elem->node(2)) i1=7-i1;
1590   //     if((i>=12&&i<=15) && elem->node(3) > elem->node(2)) i0=7-i0;
1591   //     if((i>=16&&i<=19) && elem->node(0) > elem->node(3)) i1=7-i1;
1592 
1593 
1594   //     switch (j)
1595   //       {
1596   // // d()/dxi
1597   //       case 0:
1598   // return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
1599   // FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1,    eta));
1600 
1601   // // d()/deta
1602   //       case 1:
1603   // return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0,    xi)*
1604   // FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
1605 
1606   //       default:
1607   // libmesh_error();
1608   //       }
1609   //     } // case QUAD8/9
1610 
1611   //   default:
1612   //     libmesh_error();
1613   //   }
1614 
1615   //       }
1616 
1617 
1618   //       // 6th-order Bernsteins\&.
1619   //     case SIXTH:
1620   //       {
1621   // // Bernstein shape functions on the quadrilateral\&.
1622   // switch (type)
1623   //   {
1624   //     // Bernstein shape functions on the triangle\&.
1625   //   case TRI6:
1626   //     {
1627   //       // I have been lazy here and am using finite differences
1628   //       // to compute the derivatives!
1629   //       const Real eps = 1\&.e-6;
1630 
1631   //       libmesh_assert_less (i, 28);
1632   //       libmesh_assert_less (j, 2);
1633 
1634   //       unsigned int shape=i;
1635 
1636   //       switch (j)
1637   // {
1638   //   //  d()/dxi
1639   // case 0:
1640   //   {
1641   //     const Point pp(p(0)+eps, p(1));
1642   //     const Point pm(p(0)-eps, p(1));
1643 
1644   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1645   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1646   //   }
1647 
1648   //   // d()/deta
1649   // case 1:
1650   //   {
1651   //     const Point pp(p(0), p(1)+eps);
1652   //     const Point pm(p(0), p(1)-eps);
1653 
1654   //     return (FE<2,BERNSTEIN>::shape(elem, order, shape, pp) -
1655   //     FE<2,BERNSTEIN>::shape(elem, order, shape, pm))/2\&./eps;
1656   //   }
1657 
1658 
1659   // default:
1660   //   libmesh_error();
1661   // }
1662   //     } // case TRI6
1663 
1664 
1665 
1666   //   case QUAD8:
1667   //   case QUAD9:
1668   //     {
1669   //       // Compute quad shape functions as a tensor-product
1670   //       const Real xi  = p(0);
1671   //       const Real eta = p(1);
1672 
1673   //       libmesh_assert_less (i, 49);
1674 
1675   //       //                                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
1676   //       static const unsigned int i0_reg[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6};
1677   //       static const unsigned int i1_reg[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6};
1678 
1679   //       unsigned int i0=i0_reg[i];
1680   //       unsigned int i1=i1_reg[i];
1681 
1682   //       if((i>= 4&&i<= 8) && elem->node(0) > elem->node(1)) i0=8-i0;
1683   //       if((i>= 9&&i<=13) && elem->node(1) > elem->node(2)) i1=8-i1;
1684   //       if((i>=14&&i<=18) && elem->node(3) > elem->node(2)) i0=8-i0;
1685   //       if((i>=19&&i<=23) && elem->node(0) > elem->node(3)) i1=8-i1;
1686 
1687 
1688   //       switch (j)
1689   // {
1690   //   // d()/dxi
1691   // case 0:
1692   //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0, 0, xi)*
1693   //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1,    eta));
1694 
1695   //   // d()/deta
1696   // case 1:
1697   //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0,    xi)*
1698   //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1, 0, eta));
1699 
1700   // default:
1701   //   libmesh_error();
1702   // }
1703   //     } // case QUAD8/9
1704 
1705   //   default:
1706   //     libmesh_error();
1707   //   }
1708 
1709   // // 7th-order Bernstein\&.
1710   //       case SEVENTH:
1711   // {
1712   //   // Szabo-Babuska shape functions on the quadrilateral\&.
1713   //   switch (type)
1714   //     {
1715 
1716 
1717   //     case QUAD9:
1718   //       {
1719   // // Compute quad shape functions as a tensor-product
1720   // const Real xi  = p(0);
1721   // const Real eta = p(1);
1722 
1723   // libmesh_assert_less (i, 64);
1724 
1725   // //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
1726   // static const unsigned int i0[] = {0, 1, 1, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7};
1727   // static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7};
1728 
1729   // Real f=1\&.;
1730 
1731   // switch(i)
1732   //   {
1733   //   case  5: // edge 0 nodes
1734   //   case  7:
1735   //   case  9:
1736   //     if (elem->node(0) > elem->node(1))f = -1\&.;
1737   //     break;
1738   //   case 11: // edge 1 nodes
1739   //   case 13:
1740   //   case 15:
1741   //     if (elem->node(1) > elem->node(2))f = -1\&.;
1742   //     break;
1743   //   case 17: // edge 2 nodes
1744   //   case 19:
1745   //   case 21:
1746   //     if (elem->node(3) > elem->node(2))f = -1\&.;
1747   //     break;
1748   //   case 23: // edge 3 nodes
1749   //   case 25:
1750   //   case 27:
1751   //     if (elem->node(0) > elem->node(3))f = -1\&.;
1752   //   break;
1753   //   }
1754 
1755 
1756   // switch (j)
1757   //   {
1758   //     // d()/dxi
1759   //   case 0:
1760   //     return f*(FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1761   //       FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta));
1762 
1763   //     // d()/deta
1764   //   case 1:
1765   //     return f*(FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1766   //       FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta));
1767 
1768   //   default:
1769   //     libmesh_error();
1770   //   }
1771   //       }
1772 
1773   //     default:
1774   //       libmesh_error();
1775   //     }
1776   // }
1777 
1778   //       }
1779   //       // by default throw an error;call the orientation-independent shape functions
1780   //     default:
1781   //       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
1782   //       libmesh_error();
1783   //     }
1784 
1785 
1786   libmesh_error();
1787   return 0\&.;
1788 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1218 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
1223 {
1224   libmesh_assert(elem);
1225 
1226   // call the orientation-independent shape function derivatives
1227   return FE<3,L2_LAGRANGE>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
1228 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1390 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1395 {
1396   libMesh::err << "Bernstein polynomials require the element type\n"
1397                << "because edge and face orientation is needed\&."
1398                << std::endl;
1399   libmesh_error();
1400 
1401   return 0\&.;
1402 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1407 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::FIRST, libMesh::FOURTH, libMesh::HEX20, libMesh::HEX27, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
1412 {
1413 
1414 #if LIBMESH_DIM == 3
1415   libmesh_assert(elem);
1416   const ElemType type = elem->type();
1417 
1418   const Order totalorder = static_cast<Order>(order + elem->p_level());
1419 
1420   libmesh_assert_less (j, 3);
1421 
1422   switch (totalorder)
1423     {
1424 
1425 
1426       // 1st order Bernstein\&.
1427     case FIRST:
1428       {
1429         switch (type)
1430           {
1431             // Bernstein shape functions on the tetrahedron\&.
1432           case TET4:
1433           case TET10:
1434             {
1435               // I have been lazy here and am using finite differences
1436               // to compute the derivatives!
1437               const Real eps = 1\&.e-6;
1438 
1439               libmesh_assert_less (i, 4);
1440               libmesh_assert_less (j, 3);
1441 
1442 
1443               switch (j)
1444                 {
1445                   //  d()/dxi
1446                 case 0:
1447                   {
1448                     const Point pp(p(0)+eps, p(1), p(2));
1449                     const Point pm(p(0)-eps, p(1), p(2));
1450 
1451                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1452                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1453                   }
1454 
1455                   // d()/deta
1456                 case 1:
1457                   {
1458                     const Point pp(p(0), p(1)+eps, p(2));
1459                     const Point pm(p(0), p(1)-eps, p(2));
1460 
1461                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1462                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1463                   }
1464                   // d()/dzeta
1465                 case 2:
1466                   {
1467                     const Point pp(p(0), p(1), p(2)+eps);
1468                     const Point pm(p(0), p(1), p(2)-eps);
1469 
1470                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1471                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1472                   }
1473                 default:
1474                   libmesh_error();
1475                 }
1476 
1477             }
1478 
1479 
1480 
1481 
1482             // Bernstein shape functions on the hexahedral\&.
1483           case HEX20:
1484           case HEX27:
1485             {
1486               libmesh_assert_less (i, 8);
1487 
1488               // Compute hex shape functions as a tensor-product
1489               const Real xi   = p(0);
1490               const Real eta  = p(1);
1491               const Real zeta = p(2);
1492 
1493               // The only way to make any sense of this
1494               // is to look at the mgflo/mg2/mgf documentation
1495               // and make the cut-out cube!
1496               //                                0  1  2  3  4  5  6  7
1497               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
1498               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
1499               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
1500 
1501               switch (j)
1502                 {
1503                   // d()/dxi
1504                 case 0:
1505                   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1506                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1507                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta));
1508 
1509                   // d()/deta
1510                 case 1:
1511                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],     xi)*
1512                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta)*
1513                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta));
1514 
1515                   // d()/dzeta
1516                 case 2:
1517                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1518                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1519                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[i], 0, zeta));
1520 
1521                 default:
1522                   libmesh_error();
1523                 }
1524             }
1525 
1526 
1527           default:
1528             libmesh_error();
1529           }
1530       }
1531 
1532 
1533 
1534 
1535     case SECOND:
1536       {
1537         switch (type)
1538           {
1539             // Bernstein shape functions on the tetrahedron\&.
1540           case TET10:
1541             {
1542               // I have been lazy here and am using finite differences
1543               // to compute the derivatives!
1544               const Real eps = 1\&.e-6;
1545 
1546               libmesh_assert_less (i, 10);
1547               libmesh_assert_less (j, 3);
1548 
1549 
1550               switch (j)
1551                 {
1552                   //  d()/dxi
1553                 case 0:
1554                   {
1555                     const Point pp(p(0)+eps, p(1), p(2));
1556                     const Point pm(p(0)-eps, p(1), p(2));
1557 
1558                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1559                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1560                   }
1561 
1562                   // d()/deta
1563                 case 1:
1564                   {
1565                     const Point pp(p(0), p(1)+eps, p(2));
1566                     const Point pm(p(0), p(1)-eps, p(2));
1567 
1568                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1569                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1570                   }
1571                   // d()/dzeta
1572                 case 2:
1573                   {
1574                     const Point pp(p(0), p(1), p(2)+eps);
1575                     const Point pm(p(0), p(1), p(2)-eps);
1576 
1577                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1578                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1579                   }
1580                 default:
1581                   libmesh_error();
1582                 }
1583 
1584             }
1585 
1586             // Bernstein shape functions on the hexahedral\&.
1587           case HEX20:
1588             {
1589               libmesh_assert_less (i, 20);
1590 
1591               // Compute hex shape functions as a tensor-product
1592               const Real xi   = p(0);
1593               const Real eta  = p(1);
1594               const Real zeta = p(2);
1595 
1596               // The only way to make any sense of this
1597               // is to look at the mgflo/mg2/mgf documentation
1598               // and make the cut-out cube!
1599               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
1600               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
1601               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
1602               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
1603               static const Real scal20[] =     {-0\&.25, -0\&.25, -0\&.25, -0\&.25, 0,     0,     0,     0,     0\&.5,   0\&.5,   0\&.5,   0\&.5,   0,     0,     0,     0,     0,     0,     0,     0};
1604               static const Real scal21[] =     {-0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0,     0};
1605               static const Real scal22[] =     {0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0};
1606               static const Real scal23[] =     {0,     0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     0\&.5,   0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0};
1607               static const Real scal24[] =     {-0\&.25, 0,     0,     -0\&.25, -0\&.25, 0,     0,     -0\&.25, 0,     0,     0,     0\&.5,   0\&.5,   0,     0,     0\&.5,   0,     0,     0,     0\&.5};
1608               static const Real scal25[] =     {0,     0,     0,     0,     -0\&.25, -0\&.25, -0\&.25, -0\&.25, 0,     0,     0,     0,     0,     0,     0,     0,     0\&.5,   0\&.5,   0\&.5,   0\&.5};
1609               static const Real scal26[] =     {-0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, -0\&.25, 0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25,  0\&.25};
1610 
1611               switch (j)
1612                 {
1613                   // d()/dxi
1614                 case 0:
1615                   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1616                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1617                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta)
1618                           +scal20[i]*
1619                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[20], 0, xi)*
1620                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[20],    eta)*
1621                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[20],    zeta)
1622                           +scal21[i]*
1623                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[21], 0, xi)*
1624                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[21],    eta)*
1625                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[21],    zeta)
1626                           +scal22[i]*
1627                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[22], 0, xi)*
1628                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[22],    eta)*
1629                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[22],    zeta)
1630                           +scal23[i]*
1631                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[23], 0, xi)*
1632                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[23],    eta)*
1633                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[23],    zeta)
1634                           +scal24[i]*
1635                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[24], 0, xi)*
1636                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[24],    eta)*
1637                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[24],    zeta)
1638                           +scal25[i]*
1639                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[25], 0, xi)*
1640                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[25],    eta)*
1641                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[25],    zeta)
1642                           +scal26[i]*
1643                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[26], 0, xi)*
1644                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[26],    eta)*
1645                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[26],    zeta));
1646 
1647                   // d()/deta
1648                 case 1:
1649                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],     xi)*
1650                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta)*
1651                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta)
1652                           +scal20[i]*
1653                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[20],     xi)*
1654                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[20], 0, eta)*
1655                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[20],    zeta)
1656                           +scal21[i]*
1657                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[21],     xi)*
1658                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[21], 0, eta)*
1659                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[21],    zeta)
1660                           +scal22[i]*
1661                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[22],     xi)*
1662                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[22], 0, eta)*
1663                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[22],    zeta)
1664                           +scal23[i]*
1665                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[23],     xi)*
1666                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[23], 0, eta)*
1667                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[23],    zeta)
1668                           +scal24[i]*
1669                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[24],     xi)*
1670                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[24], 0, eta)*
1671                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[24],    zeta)
1672                           +scal25[i]*
1673                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[25],     xi)*
1674                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[25], 0, eta)*
1675                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[25],    zeta)
1676                           +scal26[i]*
1677                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[26],     xi)*
1678                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[26], 0, eta)*
1679                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[26],    zeta));
1680 
1681                   // d()/dzeta
1682                 case 2:
1683                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1684                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1685                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[i], 0, zeta)
1686                           +scal20[i]*
1687                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[20],    xi)*
1688                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[20],    eta)*
1689                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[20], 0, zeta)
1690                           +scal21[i]*
1691                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[21],    xi)*
1692                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[21],    eta)*
1693                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[21], 0, zeta)
1694                           +scal22[i]*
1695                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[22],    xi)*
1696                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[22],    eta)*
1697                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[22], 0, zeta)
1698                           +scal23[i]*
1699                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[23],    xi)*
1700                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[23],    eta)*
1701                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[23], 0, zeta)
1702                           +scal24[i]*
1703                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[24],    xi)*
1704                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[24],    eta)*
1705                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[24], 0, zeta)
1706                           +scal25[i]*
1707                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[25],    xi)*
1708                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[25],    eta)*
1709                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[25], 0, zeta)
1710                           +scal26[i]*
1711                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[26],    xi)*
1712                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[26],    eta)*
1713                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[26], 0, zeta));
1714 
1715                 default:
1716                   libmesh_error();
1717                 }
1718             }
1719 
1720             // Bernstein shape functions on the hexahedral\&.
1721           case HEX27:
1722             {
1723               libmesh_assert_less (i, 27);
1724 
1725               // Compute hex shape functions as a tensor-product
1726               const Real xi   = p(0);
1727               const Real eta  = p(1);
1728               const Real zeta = p(2);
1729 
1730               // The only way to make any sense of this
1731               // is to look at the mgflo/mg2/mgf documentation
1732               // and make the cut-out cube!
1733               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
1734               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
1735               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
1736               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
1737 
1738               switch (j)
1739                 {
1740                   // d()/dxi
1741                 case 0:
1742                   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi)*
1743                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1744                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta));
1745 
1746                   // d()/deta
1747                 case 1:
1748                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],     xi)*
1749                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta)*
1750                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta));
1751 
1752                   // d()/dzeta
1753                 case 2:
1754                   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi)*
1755                           FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta)*
1756                           FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[i], 0, zeta));
1757 
1758                 default:
1759                   libmesh_error();
1760                 }
1761             }
1762 
1763 
1764           default:
1765             libmesh_error();
1766           }
1767       }
1768 
1769 
1770 
1771       // 3rd-order Bernstein\&.
1772     case THIRD:
1773       {
1774         switch (type)
1775           {
1776 
1777             //     // Bernstein shape functions derivatives\&.
1778             //   case TET10:
1779             //     {
1780             //       // I have been lazy here and am using finite differences
1781             //       // to compute the derivatives!
1782             //       const Real eps = 1\&.e-6;
1783 
1784             //       libmesh_assert_less (i, 20);
1785             //       libmesh_assert_less (j, 3);
1786 
1787             // switch (j)
1788             // {
1789             //   //  d()/dxi
1790             // case 0:
1791             //   {
1792             //     const Point pp(p(0)+eps, p(1), p(2));
1793             //     const Point pm(p(0)-eps, p(1), p(2));
1794 
1795             //     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1796             //     FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1797             //   }
1798 
1799             //   // d()/deta
1800             // case 1:
1801             //   {
1802             //     const Point pp(p(0), p(1)+eps, p(2));
1803             //     const Point pm(p(0), p(1)-eps, p(2));
1804 
1805             //     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1806             //     FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1807             //   }
1808             //   // d()/dzeta
1809             // case 2:
1810             //   {
1811             //     const Point pp(p(0), p(1), p(2)+eps);
1812             //     const Point pm(p(0), p(1), p(2)-eps);
1813 
1814             //     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1815             //     FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1816             //   }
1817             // default:
1818             //   libmesh_error();
1819             // }
1820 
1821 
1822             //     }
1823 
1824 
1825             // Bernstein shape functions on the hexahedral\&.
1826           case HEX27:
1827             {
1828               // I have been lazy here and am using finite differences
1829               // to compute the derivatives!
1830               const Real eps = 1\&.e-6;
1831 
1832               libmesh_assert_less (i, 64);
1833               libmesh_assert_less (j, 3);
1834 
1835               switch (j)
1836                 {
1837                   //  d()/dxi
1838                 case 0:
1839                   {
1840                     const Point pp(p(0)+eps, p(1), p(2));
1841                     const Point pm(p(0)-eps, p(1), p(2));
1842 
1843                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1844                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1845                   }
1846 
1847                   // d()/deta
1848                 case 1:
1849                   {
1850                     const Point pp(p(0), p(1)+eps, p(2));
1851                     const Point pm(p(0), p(1)-eps, p(2));
1852 
1853                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1854                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1855                   }
1856                   // d()/dzeta
1857                 case 2:
1858                   {
1859                     const Point pp(p(0), p(1), p(2)+eps);
1860                     const Point pm(p(0), p(1), p(2)-eps);
1861 
1862                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
1863                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
1864                   }
1865                 default:
1866                   libmesh_error();
1867                 }
1868 
1869             }
1870 
1871             //       // Compute hex shape functions as a tensor-product
1872             //       const Real xi    = p(0);
1873             //       const Real eta   = p(1);
1874             //       const Real zeta  = p(2);
1875             //       Real xi_mapped   = p(0);
1876             //       Real eta_mapped  = p(1);
1877             //       Real zeta_mapped = p(2);
1878 
1879             //       // The only way to make any sense of this
1880             //       // is to look at the mgflo/mg2/mgf documentation
1881             //       // and make the cut-out cube!
1882             //       //  Nodes                         0  1  2  3  4  5  6  7  8  8  9  9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 20 20 21 21 21 21 22 22 22 22 23 23 23 23 24 24 24 24 25 25 25 25 26 26 26 26 26 26 26 26
1883             //       //  DOFS                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 18 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 60 62 63
1884             //       static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 3, 1, 1, 2, 3, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 2, 3, 2, 3, 0, 0, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3};
1885             //       static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 3, 1, 1, 2, 3, 2, 2, 3, 3, 0, 0, 0, 0, 2, 3, 2, 3, 1, 1, 1, 1, 2, 3, 2, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3};
1886             //       static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3};
1887 
1888 
1889 
1890             //       // handle the edge orientation
1891             //       {
1892             // // Edge 0
1893             // if ((i1[i] == 0) && (i2[i] == 0))
1894             //   {
1895             //     if (elem->node(0) != std::min(elem->node(0), elem->node(1)))
1896             //       xi_mapped = -xi;
1897             //   }
1898             // // Edge 1
1899             // else if ((i0[i] == 1) && (i2[i] == 0))
1900             //   {
1901             //     if (elem->node(1) != std::min(elem->node(1), elem->node(2)))
1902             //       eta_mapped = -eta;
1903             //   }
1904             // // Edge 2
1905             // else if ((i1[i] == 1) && (i2[i] == 0))
1906             //   {
1907             //     if (elem->node(3) != std::min(elem->node(3), elem->node(2)))
1908             //       xi_mapped = -xi;
1909             //   }
1910             // // Edge 3
1911             // else if ((i0[i] == 0) && (i2[i] == 0))
1912             //   {
1913             //     if (elem->node(0) != std::min(elem->node(0), elem->node(3)))
1914             //       eta_mapped = -eta;
1915             //   }
1916             // // Edge 4
1917             // else if ((i0[i] == 0) && (i1[i] == 0))
1918             //   {
1919             //     if (elem->node(0) != std::min(elem->node(0), elem->node(4)))
1920             //       zeta_mapped = -zeta;
1921             //   }
1922             // // Edge 5
1923             // else if ((i0[i] == 1) && (i1[i] == 0))
1924             //   {
1925             //     if (elem->node(1) != std::min(elem->node(1), elem->node(5)))
1926             //       zeta_mapped = -zeta;
1927             //   }
1928             // // Edge 6
1929             // else if ((i0[i] == 1) && (i1[i] == 1))
1930             //   {
1931             //     if (elem->node(2) != std::min(elem->node(2), elem->node(6)))
1932             //       zeta_mapped = -zeta;
1933             //   }
1934             // // Edge 7
1935             // else if ((i0[i] == 0) && (i1[i] == 1))
1936             //   {
1937             //     if (elem->node(3) != std::min(elem->node(3), elem->node(7)))
1938             //       zeta_mapped = -zeta;
1939             //   }
1940             // // Edge 8
1941             // else if ((i1[i] == 0) && (i2[i] == 1))
1942             //   {
1943             //     if (elem->node(4) != std::min(elem->node(4), elem->node(5)))
1944             //       xi_mapped = -xi;
1945             //   }
1946             // // Edge 9
1947             // else if ((i0[i] == 1) && (i2[i] == 1))
1948             //   {
1949             //     if (elem->node(5) != std::min(elem->node(5), elem->node(6)))
1950             //       eta_mapped = -eta;
1951             //   }
1952             // // Edge 10
1953             // else if ((i1[i] == 1) && (i2[i] == 1))
1954             //   {
1955             //     if (elem->node(7) != std::min(elem->node(7), elem->node(6)))
1956             //       xi_mapped = -xi;
1957             //   }
1958             // // Edge 11
1959             // else if ((i0[i] == 0) && (i2[i] == 1))
1960             //   {
1961             //     if (elem->node(4) != std::min(elem->node(4), elem->node(7)))
1962             //       eta_mapped = -eta;
1963             //   }
1964             //       }
1965 
1966 
1967             //       // handle the face orientation
1968             //       {
1969             // // Face 0
1970             // if (     (i2[i] == 0) && (i0[i] >= 2) && (i1[i] >= 2))
1971             //   {
1972             //     const unsigned int min_node = std::min(elem->node(1),
1973             //    std::min(elem->node(2),
1974             //     std::min(elem->node(0),
1975             //      elem->node(3))));
1976             //     if (elem->node(0) == min_node)
1977             //       if (elem->node(1) == std::min(elem->node(1), elem->node(3)))
1978             // {
1979             //   // Case 1
1980             //   xi_mapped  = xi;
1981             //   eta_mapped = eta;
1982             // }
1983             //       else
1984             // {
1985             //   // Case 2
1986             //   xi_mapped  = eta;
1987             //   eta_mapped = xi;
1988             // }
1989 
1990             //     else if (elem->node(3) == min_node)
1991             //       if (elem->node(0) == std::min(elem->node(0), elem->node(2)))
1992             // {
1993             //   // Case 3
1994             //   xi_mapped  = -eta;
1995             //   eta_mapped = xi;
1996             // }
1997             //       else
1998             // {
1999             //   // Case 4
2000             //   xi_mapped  = xi;
2001             //   eta_mapped = -eta;
2002             // }
2003 
2004             //     else if (elem->node(2) == min_node)
2005             //       if (elem->node(3) == std::min(elem->node(3), elem->node(1)))
2006             // {
2007             //   // Case 5
2008             //   xi_mapped  = -xi;
2009             //   eta_mapped = -eta;
2010             // }
2011             //       else
2012             // {
2013             //   // Case 6
2014             //   xi_mapped  = -eta;
2015             //   eta_mapped = -xi;
2016             // }
2017 
2018             //     else if (elem->node(1) == min_node)
2019             //       if (elem->node(2) == std::min(elem->node(2), elem->node(0)))
2020             // {
2021             //   // Case 7
2022             //   xi_mapped  = eta;
2023             //   eta_mapped = -xi;
2024             // }
2025             //       else
2026             // {
2027             //   // Case 8
2028             //   xi_mapped  = -xi;
2029             //   eta_mapped = eta;
2030             // }
2031             //   }
2032 
2033 
2034             // // Face 1
2035             // else if ((i1[i] == 0) && (i0[i] >= 2) && (i2[i] >= 2))
2036             //   {
2037             //     const unsigned int min_node = std::min(elem->node(0),
2038             //    std::min(elem->node(1),
2039             //     std::min(elem->node(5),
2040             //      elem->node(4))));
2041             //     if (elem->node(0) == min_node)
2042             //       if (elem->node(1) == std::min(elem->node(1), elem->node(4)))
2043             // {
2044             //   // Case 1
2045             //   xi_mapped   = xi;
2046             //   zeta_mapped = zeta;
2047             // }
2048             //       else
2049             // {
2050             //   // Case 2
2051             //   xi_mapped   = zeta;
2052             //   zeta_mapped = xi;
2053             // }
2054 
2055             //     else if (elem->node(1) == min_node)
2056             //       if (elem->node(5) == std::min(elem->node(5), elem->node(0)))
2057             // {
2058             //   // Case 3
2059             //   xi_mapped   = zeta;
2060             //   zeta_mapped = -xi;
2061             // }
2062             //       else
2063             // {
2064             //   // Case 4
2065             //   xi_mapped   = -xi;
2066             //   zeta_mapped = zeta;
2067             // }
2068 
2069             //     else if (elem->node(5) == min_node)
2070             //       if (elem->node(4) == std::min(elem->node(4), elem->node(1)))
2071             // {
2072             //   // Case 5
2073             //   xi_mapped   = -xi;
2074             //   zeta_mapped = -zeta;
2075             // }
2076             //       else
2077             // {
2078             //   // Case 6
2079             //   xi_mapped   = -zeta;
2080             //   zeta_mapped = -xi;
2081             // }
2082 
2083             //     else if (elem->node(4) == min_node)
2084             //       if (elem->node(0) == std::min(elem->node(0), elem->node(5)))
2085             // {
2086             //   // Case 7
2087             //   xi_mapped   = -xi;
2088             //   zeta_mapped = zeta;
2089             // }
2090             //       else
2091             // {
2092             //   // Case 8
2093             //   xi_mapped   = xi;
2094             //   zeta_mapped = -zeta;
2095             // }
2096             //   }
2097 
2098 
2099             // // Face 2
2100             // else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] >= 2))
2101             //   {
2102             //     const unsigned int min_node = std::min(elem->node(1),
2103             //    std::min(elem->node(2),
2104             //     std::min(elem->node(6),
2105             //      elem->node(5))));
2106             //     if (elem->node(1) == min_node)
2107             //       if (elem->node(2) == std::min(elem->node(2), elem->node(5)))
2108             // {
2109             //   // Case 1
2110             //   eta_mapped  = eta;
2111             //   zeta_mapped = zeta;
2112             // }
2113             //       else
2114             // {
2115             //   // Case 2
2116             //   eta_mapped  = zeta;
2117             //   zeta_mapped = eta;
2118             // }
2119 
2120             //     else if (elem->node(2) == min_node)
2121             //       if (elem->node(6) == std::min(elem->node(6), elem->node(1)))
2122             // {
2123             //   // Case 3
2124             //   eta_mapped  = zeta;
2125             //   zeta_mapped = -eta;
2126             // }
2127             //       else
2128             // {
2129             //   // Case 4
2130             //   eta_mapped  = -eta;
2131             //   zeta_mapped = zeta;
2132             // }
2133 
2134             //     else if (elem->node(6) == min_node)
2135             //       if (elem->node(5) == std::min(elem->node(5), elem->node(2)))
2136             // {
2137             //   // Case 5
2138             //   eta_mapped  = -eta;
2139             //   zeta_mapped = -zeta;
2140             // }
2141             //       else
2142             // {
2143             //   // Case 6
2144             //   eta_mapped  = -zeta;
2145             //   zeta_mapped = -eta;
2146             // }
2147 
2148             //     else if (elem->node(5) == min_node)
2149             //       if (elem->node(1) == std::min(elem->node(1), elem->node(6)))
2150             // {
2151             //   // Case 7
2152             //   eta_mapped  = -zeta;
2153             //   zeta_mapped = eta;
2154             // }
2155             //       else
2156             // {
2157             //   // Case 8
2158             //   eta_mapped   = eta;
2159             //   zeta_mapped = -zeta;
2160             // }
2161             //   }
2162 
2163 
2164             // // Face 3
2165             // else if ((i1[i] == 1) && (i0[i] >= 2) && (i2[i] >= 2))
2166             //   {
2167             //     const unsigned int min_node = std::min(elem->node(2),
2168             //    std::min(elem->node(3),
2169             //     std::min(elem->node(7),
2170             //      elem->node(6))));
2171             //     if (elem->node(3) == min_node)
2172             //       if (elem->node(2) == std::min(elem->node(2), elem->node(7)))
2173             // {
2174             //   // Case 1
2175             //   xi_mapped   = xi;
2176             //   zeta_mapped = zeta;
2177             // }
2178             //       else
2179             // {
2180             //   // Case 2
2181             //   xi_mapped   = zeta;
2182             //   zeta_mapped = xi;
2183             // }
2184 
2185             //     else if (elem->node(7) == min_node)
2186             //       if (elem->node(3) == std::min(elem->node(3), elem->node(6)))
2187             // {
2188             //   // Case 3
2189             //   xi_mapped   = -zeta;
2190             //   zeta_mapped = xi;
2191             // }
2192             //       else
2193             // {
2194             //   // Case 4
2195             //   xi_mapped   = xi;
2196             //   zeta_mapped = -zeta;
2197             // }
2198 
2199             //     else if (elem->node(6) == min_node)
2200             //       if (elem->node(7) == std::min(elem->node(7), elem->node(2)))
2201             // {
2202             //   // Case 5
2203             //   xi_mapped   = -xi;
2204             //   zeta_mapped = -zeta;
2205             // }
2206             //       else
2207             // {
2208             //   // Case 6
2209             //   xi_mapped   = -zeta;
2210             //   zeta_mapped = -xi;
2211             // }
2212 
2213             //     else if (elem->node(2) == min_node)
2214             //       if (elem->node(6) == std::min(elem->node(3), elem->node(6)))
2215             // {
2216             //   // Case 7
2217             //   xi_mapped   = zeta;
2218             //   zeta_mapped = -xi;
2219             // }
2220             //       else
2221             // {
2222             //   // Case 8
2223             //   xi_mapped   = -xi;
2224             //   zeta_mapped = zeta;
2225             // }
2226             //   }
2227 
2228 
2229             // // Face 4
2230             // else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] >= 2))
2231             //   {
2232             //     const unsigned int min_node = std::min(elem->node(3),
2233             //    std::min(elem->node(0),
2234             //     std::min(elem->node(4),
2235             //      elem->node(7))));
2236             //     if (elem->node(0) == min_node)
2237             //       if (elem->node(3) == std::min(elem->node(3), elem->node(4)))
2238             // {
2239             //   // Case 1
2240             //   eta_mapped  = eta;
2241             //   zeta_mapped = zeta;
2242             // }
2243             //       else
2244             // {
2245             //   // Case 2
2246             //   eta_mapped  = zeta;
2247             //   zeta_mapped = eta;
2248             // }
2249 
2250             //     else if (elem->node(4) == min_node)
2251             //       if (elem->node(0) == std::min(elem->node(0), elem->node(7)))
2252             // {
2253             //   // Case 3
2254             //   eta_mapped  = -zeta;
2255             //   zeta_mapped = eta;
2256             // }
2257             //       else
2258             // {
2259             //   // Case 4
2260             //   eta_mapped  = eta;
2261             //   zeta_mapped = -zeta;
2262             // }
2263 
2264             //     else if (elem->node(7) == min_node)
2265             //       if (elem->node(4) == std::min(elem->node(4), elem->node(3)))
2266             // {
2267             //   // Case 5
2268             //   eta_mapped  = -eta;
2269             //   zeta_mapped = -zeta;
2270             // }
2271             //       else
2272             // {
2273             //   // Case 6
2274             //   eta_mapped  = -zeta;
2275             //   zeta_mapped = -eta;
2276             // }
2277 
2278             //     else if (elem->node(3) == min_node)
2279             //       if (elem->node(7) == std::min(elem->node(7), elem->node(0)))
2280             // {
2281             //   // Case 7
2282             //   eta_mapped   = zeta;
2283             //   zeta_mapped = -eta;
2284             // }
2285             //       else
2286             // {
2287             //   // Case 8
2288             //   eta_mapped  = -eta;
2289             //   zeta_mapped = zeta;
2290             // }
2291             //   }
2292 
2293 
2294             // // Face 5
2295             // else if ((i2[i] == 1) && (i0[i] >= 2) && (i1[i] >= 2))
2296             //   {
2297             //     const unsigned int min_node = std::min(elem->node(4),
2298             //    std::min(elem->node(5),
2299             //     std::min(elem->node(6),
2300             //      elem->node(7))));
2301             //     if (elem->node(4) == min_node)
2302             //       if (elem->node(5) == std::min(elem->node(5), elem->node(7)))
2303             // {
2304             //   // Case 1
2305             //   xi_mapped  = xi;
2306             //   eta_mapped = eta;
2307             // }
2308             //       else
2309             // {
2310             //   // Case 2
2311             //   xi_mapped  = eta;
2312             //   eta_mapped = xi;
2313             // }
2314 
2315             //     else if (elem->node(5) == min_node)
2316             //       if (elem->node(6) == std::min(elem->node(6), elem->node(4)))
2317             // {
2318             //   // Case 3
2319             //   xi_mapped  = eta;
2320             //   eta_mapped = -xi;
2321             // }
2322             //       else
2323             // {
2324             //   // Case 4
2325             //   xi_mapped  = -xi;
2326             //   eta_mapped = eta;
2327             // }
2328 
2329             //     else if (elem->node(6) == min_node)
2330             //       if (elem->node(7) == std::min(elem->node(7), elem->node(5)))
2331             // {
2332             //   // Case 5
2333             //   xi_mapped  = -xi;
2334             //   eta_mapped = -eta;
2335             // }
2336             //       else
2337             // {
2338             //   // Case 6
2339             //   xi_mapped  = -eta;
2340             //   eta_mapped = -xi;
2341             // }
2342 
2343             //     else if (elem->node(7) == min_node)
2344             //       if (elem->node(4) == std::min(elem->node(4), elem->node(6)))
2345             // {
2346             //   // Case 7
2347             //   xi_mapped  = -eta;
2348             //   eta_mapped = xi;
2349             // }
2350             //       else
2351             // {
2352             //   // Case 8
2353             //   xi_mapped  = xi;
2354             //   eta_mapped = eta;
2355             // }
2356             //   }
2357 
2358 
2359             //       }
2360 
2361 
2362 
2363             //       libmesh_assert_less (j, 3);
2364 
2365             //       switch (j)
2366             // {
2367             //   // d()/dxi
2368             // case 0:
2369             //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi_mapped)*
2370             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta_mapped)*
2371             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta_mapped));
2372 
2373             //   // d()/deta
2374             // case 1:
2375             //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi_mapped)*
2376             //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta_mapped)*
2377             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta_mapped));
2378 
2379             //   // d()/dzeta
2380             // case 2:
2381             //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi_mapped)*
2382             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta_mapped)*
2383             //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[i], 0, zeta_mapped));
2384 
2385             // default:
2386             //   libmesh_error();
2387             // }
2388             //     }
2389 
2390 
2391           default:
2392             libmesh_error();
2393           }
2394       }
2395 
2396       // 4th-order Bernstein\&.
2397     case FOURTH:
2398       {
2399         switch (type)
2400           {
2401 
2402             // Bernstein shape functions derivatives on the hexahedral\&.
2403           case HEX27:
2404             {
2405               const Real eps = 1\&.e-6;
2406 
2407               libmesh_assert_less (i, 125);
2408               libmesh_assert_less (j, 3);
2409 
2410               switch (j)
2411                 {
2412                   //  d()/dxi
2413                 case 0:
2414                   {
2415                     const Point pp(p(0)+eps, p(1), p(2));
2416                     const Point pm(p(0)-eps, p(1), p(2));
2417 
2418                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
2419                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
2420                   }
2421 
2422                   // d()/deta
2423                 case 1:
2424                   {
2425                     const Point pp(p(0), p(1)+eps, p(2));
2426                     const Point pm(p(0), p(1)-eps, p(2));
2427 
2428                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
2429                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
2430                   }
2431                   // d()/dzeta
2432                 case 2:
2433                   {
2434                     const Point pp(p(0), p(1), p(2)+eps);
2435                     const Point pm(p(0), p(1), p(2)-eps);
2436 
2437                     return (FE<3,BERNSTEIN>::shape(elem, order, i, pp) -
2438                             FE<3,BERNSTEIN>::shape(elem, order, i, pm))/2\&./eps;
2439                   }
2440                 default:
2441                   libmesh_error();
2442                 }
2443             }
2444 
2445             //       // Compute hex shape functions as a tensor-product
2446             //       const Real xi    = p(0);
2447             //       const Real eta   = p(1);
2448             //       const Real zeta  = p(2);
2449             //       Real xi_mapped   = p(0);
2450             //       Real eta_mapped  = p(1);
2451             //       Real zeta_mapped = p(2);
2452 
2453             //       // The only way to make any sense of this
2454             //       // is to look at the mgflo/mg2/mgf documentation
2455             //       // and make the cut-out cube!
2456             //       //  Nodes                         0  1  2  3  4  5  6  7  8  8  9  9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20 20 20 21 21 21 21 22 22 22 22 23 23 23 23 24 24 24 24 25 25 25 25 26 26 26 26 26 26 26 26
2457             //       //  DOFS                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 18 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 60 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
2458             //       static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4};
2459             //       static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 2, 3, 4, 1, 1, 1, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4};
2460             //       static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4};
2461 
2462 
2463 
2464             //       // handle the edge orientation
2465             //       {
2466             // // Edge 0
2467             // if ((i1[i] == 0) && (i2[i] == 0))
2468             //   {
2469             //     if (elem->node(0) != std::min(elem->node(0), elem->node(1)))
2470             //       xi_mapped = -xi;
2471             //   }
2472             // // Edge 1
2473             // else if ((i0[i] == 1) && (i2[i] == 0))
2474             //   {
2475             //     if (elem->node(1) != std::min(elem->node(1), elem->node(2)))
2476             //       eta_mapped = -eta;
2477             //   }
2478             // // Edge 2
2479             // else if ((i1[i] == 1) && (i2[i] == 0))
2480             //   {
2481             //     if (elem->node(3) != std::min(elem->node(3), elem->node(2)))
2482             //       xi_mapped = -xi;
2483             //   }
2484             // // Edge 3
2485             // else if ((i0[i] == 0) && (i2[i] == 0))
2486             //   {
2487             //     if (elem->node(0) != std::min(elem->node(0), elem->node(3)))
2488             //       eta_mapped = -eta;
2489             //   }
2490             // // Edge 4
2491             // else if ((i0[i] == 0) && (i1[i] == 0))
2492             //   {
2493             //     if (elem->node(0) != std::min(elem->node(0), elem->node(4)))
2494             //       zeta_mapped = -zeta;
2495             //   }
2496             // // Edge 5
2497             // else if ((i0[i] == 1) && (i1[i] == 0))
2498             //   {
2499             //     if (elem->node(1) != std::min(elem->node(1), elem->node(5)))
2500             //       zeta_mapped = -zeta;
2501             //   }
2502             // // Edge 6
2503             // else if ((i0[i] == 1) && (i1[i] == 1))
2504             //   {
2505             //     if (elem->node(2) != std::min(elem->node(2), elem->node(6)))
2506             //       zeta_mapped = -zeta;
2507             //   }
2508             // // Edge 7
2509             // else if ((i0[i] == 0) && (i1[i] == 1))
2510             //   {
2511             //     if (elem->node(3) != std::min(elem->node(3), elem->node(7)))
2512             //       zeta_mapped = -zeta;
2513             //   }
2514             // // Edge 8
2515             // else if ((i1[i] == 0) && (i2[i] == 1))
2516             //   {
2517             //     if (elem->node(4) != std::min(elem->node(4), elem->node(5)))
2518             //       xi_mapped = -xi;
2519             //   }
2520             // // Edge 9
2521             // else if ((i0[i] == 1) && (i2[i] == 1))
2522             //   {
2523             //     if (elem->node(5) != std::min(elem->node(5), elem->node(6)))
2524             //       eta_mapped = -eta;
2525             //   }
2526             // // Edge 10
2527             // else if ((i1[i] == 1) && (i2[i] == 1))
2528             //   {
2529             //     if (elem->node(7) != std::min(elem->node(7), elem->node(6)))
2530             //       xi_mapped = -xi;
2531             //   }
2532             // // Edge 11
2533             // else if ((i0[i] == 0) && (i2[i] == 1))
2534             //   {
2535             //     if (elem->node(4) != std::min(elem->node(4), elem->node(7)))
2536             //       eta_mapped = -eta;
2537             //   }
2538             //       }
2539 
2540 
2541             //       // handle the face orientation
2542             //       {
2543             // // Face 0
2544             // if (     (i2[i] == 0) && (i0[i] >= 2) && (i1[i] >= 2))
2545             //   {
2546             //     const unsigned int min_node = std::min(elem->node(1),
2547             //    std::min(elem->node(2),
2548             //     std::min(elem->node(0),
2549             //      elem->node(3))));
2550             //     if (elem->node(0) == min_node)
2551             //       if (elem->node(1) == std::min(elem->node(1), elem->node(3)))
2552             // {
2553             //   // Case 1
2554             //   xi_mapped  = xi;
2555             //   eta_mapped = eta;
2556             // }
2557             //       else
2558             // {
2559             //   // Case 2
2560             //   xi_mapped  = eta;
2561             //   eta_mapped = xi;
2562             // }
2563 
2564             //     else if (elem->node(3) == min_node)
2565             //       if (elem->node(0) == std::min(elem->node(0), elem->node(2)))
2566             // {
2567             //   // Case 3
2568             //   xi_mapped  = -eta;
2569             //   eta_mapped = xi;
2570             // }
2571             //       else
2572             // {
2573             //   // Case 4
2574             //   xi_mapped  = xi;
2575             //   eta_mapped = -eta;
2576             // }
2577 
2578             //     else if (elem->node(2) == min_node)
2579             //       if (elem->node(3) == std::min(elem->node(3), elem->node(1)))
2580             // {
2581             //   // Case 5
2582             //   xi_mapped  = -xi;
2583             //   eta_mapped = -eta;
2584             // }
2585             //       else
2586             // {
2587             //   // Case 6
2588             //   xi_mapped  = -eta;
2589             //   eta_mapped = -xi;
2590             // }
2591 
2592             //     else if (elem->node(1) == min_node)
2593             //       if (elem->node(2) == std::min(elem->node(2), elem->node(0)))
2594             // {
2595             //   // Case 7
2596             //   xi_mapped  = eta;
2597             //   eta_mapped = -xi;
2598             // }
2599             //       else
2600             // {
2601             //   // Case 8
2602             //   xi_mapped  = -xi;
2603             //   eta_mapped = eta;
2604             // }
2605             //   }
2606 
2607 
2608             // // Face 1
2609             // else if ((i1[i] == 0) && (i0[i] >= 2) && (i2[i] >= 2))
2610             //   {
2611             //     const unsigned int min_node = std::min(elem->node(0),
2612             //    std::min(elem->node(1),
2613             //     std::min(elem->node(5),
2614             //      elem->node(4))));
2615             //     if (elem->node(0) == min_node)
2616             //       if (elem->node(1) == std::min(elem->node(1), elem->node(4)))
2617             // {
2618             //   // Case 1
2619             //   xi_mapped   = xi;
2620             //   zeta_mapped = zeta;
2621             // }
2622             //       else
2623             // {
2624             //   // Case 2
2625             //   xi_mapped   = zeta;
2626             //   zeta_mapped = xi;
2627             // }
2628 
2629             //     else if (elem->node(1) == min_node)
2630             //       if (elem->node(5) == std::min(elem->node(5), elem->node(0)))
2631             // {
2632             //   // Case 3
2633             //   xi_mapped   = zeta;
2634             //   zeta_mapped = -xi;
2635             // }
2636             //       else
2637             // {
2638             //   // Case 4
2639             //   xi_mapped   = -xi;
2640             //   zeta_mapped = zeta;
2641             // }
2642 
2643             //     else if (elem->node(5) == min_node)
2644             //       if (elem->node(4) == std::min(elem->node(4), elem->node(1)))
2645             // {
2646             //   // Case 5
2647             //   xi_mapped   = -xi;
2648             //   zeta_mapped = -zeta;
2649             // }
2650             //       else
2651             // {
2652             //   // Case 6
2653             //   xi_mapped   = -zeta;
2654             //   zeta_mapped = -xi;
2655             // }
2656 
2657             //     else if (elem->node(4) == min_node)
2658             //       if (elem->node(0) == std::min(elem->node(0), elem->node(5)))
2659             // {
2660             //   // Case 7
2661             //   xi_mapped   = -xi;
2662             //   zeta_mapped = zeta;
2663             // }
2664             //       else
2665             // {
2666             //   // Case 8
2667             //   xi_mapped   = xi;
2668             //   zeta_mapped = -zeta;
2669             // }
2670             //   }
2671 
2672 
2673             // // Face 2
2674             // else if ((i0[i] == 1) && (i1[i] >= 2) && (i2[i] >= 2))
2675             //   {
2676             //     const unsigned int min_node = std::min(elem->node(1),
2677             //    std::min(elem->node(2),
2678             //     std::min(elem->node(6),
2679             //      elem->node(5))));
2680             //     if (elem->node(1) == min_node)
2681             //       if (elem->node(2) == std::min(elem->node(2), elem->node(5)))
2682             // {
2683             //   // Case 1
2684             //   eta_mapped  = eta;
2685             //   zeta_mapped = zeta;
2686             // }
2687             //       else
2688             // {
2689             //   // Case 2
2690             //   eta_mapped  = zeta;
2691             //   zeta_mapped = eta;
2692             // }
2693 
2694             //     else if (elem->node(2) == min_node)
2695             //       if (elem->node(6) == std::min(elem->node(6), elem->node(1)))
2696             // {
2697             //   // Case 3
2698             //   eta_mapped  = zeta;
2699             //   zeta_mapped = -eta;
2700             // }
2701             //       else
2702             // {
2703             //   // Case 4
2704             //   eta_mapped  = -eta;
2705             //   zeta_mapped = zeta;
2706             // }
2707 
2708             //     else if (elem->node(6) == min_node)
2709             //       if (elem->node(5) == std::min(elem->node(5), elem->node(2)))
2710             // {
2711             //   // Case 5
2712             //   eta_mapped  = -eta;
2713             //   zeta_mapped = -zeta;
2714             // }
2715             //       else
2716             // {
2717             //   // Case 6
2718             //   eta_mapped  = -zeta;
2719             //   zeta_mapped = -eta;
2720             // }
2721 
2722             //     else if (elem->node(5) == min_node)
2723             //       if (elem->node(1) == std::min(elem->node(1), elem->node(6)))
2724             // {
2725             //   // Case 7
2726             //   eta_mapped  = -zeta;
2727             //   zeta_mapped = eta;
2728             // }
2729             //       else
2730             // {
2731             //   // Case 8
2732             //   eta_mapped   = eta;
2733             //   zeta_mapped = -zeta;
2734             // }
2735             //   }
2736 
2737 
2738             // // Face 3
2739             // else if ((i1[i] == 1) && (i0[i] >= 2) && (i2[i] >= 2))
2740             //   {
2741             //     const unsigned int min_node = std::min(elem->node(2),
2742             //    std::min(elem->node(3),
2743             //     std::min(elem->node(7),
2744             //      elem->node(6))));
2745             //     if (elem->node(3) == min_node)
2746             //       if (elem->node(2) == std::min(elem->node(2), elem->node(7)))
2747             // {
2748             //   // Case 1
2749             //   xi_mapped   = xi;
2750             //   zeta_mapped = zeta;
2751             // }
2752             //       else
2753             // {
2754             //   // Case 2
2755             //   xi_mapped   = zeta;
2756             //   zeta_mapped = xi;
2757             // }
2758 
2759             //     else if (elem->node(7) == min_node)
2760             //       if (elem->node(3) == std::min(elem->node(3), elem->node(6)))
2761             // {
2762             //   // Case 3
2763             //   xi_mapped   = -zeta;
2764             //   zeta_mapped = xi;
2765             // }
2766             //       else
2767             // {
2768             //   // Case 4
2769             //   xi_mapped   = xi;
2770             //   zeta_mapped = -zeta;
2771             // }
2772 
2773             //     else if (elem->node(6) == min_node)
2774             //       if (elem->node(7) == std::min(elem->node(7), elem->node(2)))
2775             // {
2776             //   // Case 5
2777             //   xi_mapped   = -xi;
2778             //   zeta_mapped = -zeta;
2779             // }
2780             //       else
2781             // {
2782             //   // Case 6
2783             //   xi_mapped   = -zeta;
2784             //   zeta_mapped = -xi;
2785             // }
2786 
2787             //     else if (elem->node(2) == min_node)
2788             //       if (elem->node(6) == std::min(elem->node(3), elem->node(6)))
2789             // {
2790             //   // Case 7
2791             //   xi_mapped   = zeta;
2792             //   zeta_mapped = -xi;
2793             // }
2794             //       else
2795             // {
2796             //   // Case 8
2797             //   xi_mapped   = -xi;
2798             //   zeta_mapped = zeta;
2799             // }
2800             //   }
2801 
2802 
2803             // // Face 4
2804             // else if ((i0[i] == 0) && (i1[i] >= 2) && (i2[i] >= 2))
2805             //   {
2806             //     const unsigned int min_node = std::min(elem->node(3),
2807             //    std::min(elem->node(0),
2808             //     std::min(elem->node(4),
2809             //      elem->node(7))));
2810             //     if (elem->node(0) == min_node)
2811             //       if (elem->node(3) == std::min(elem->node(3), elem->node(4)))
2812             // {
2813             //   // Case 1
2814             //   eta_mapped  = eta;
2815             //   zeta_mapped = zeta;
2816             // }
2817             //       else
2818             // {
2819             //   // Case 2
2820             //   eta_mapped  = zeta;
2821             //   zeta_mapped = eta;
2822             // }
2823 
2824             //     else if (elem->node(4) == min_node)
2825             //       if (elem->node(0) == std::min(elem->node(0), elem->node(7)))
2826             // {
2827             //   // Case 3
2828             //   eta_mapped  = -zeta;
2829             //   zeta_mapped = eta;
2830             // }
2831             //       else
2832             // {
2833             //   // Case 4
2834             //   eta_mapped  = eta;
2835             //   zeta_mapped = -zeta;
2836             // }
2837 
2838             //     else if (elem->node(7) == min_node)
2839             //       if (elem->node(4) == std::min(elem->node(4), elem->node(3)))
2840             // {
2841             //   // Case 5
2842             //   eta_mapped  = -eta;
2843             //   zeta_mapped = -zeta;
2844             // }
2845             //       else
2846             // {
2847             //   // Case 6
2848             //   eta_mapped  = -zeta;
2849             //   zeta_mapped = -eta;
2850             // }
2851 
2852             //     else if (elem->node(3) == min_node)
2853             //       if (elem->node(7) == std::min(elem->node(7), elem->node(0)))
2854             // {
2855             //   // Case 7
2856             //   eta_mapped   = zeta;
2857             //   zeta_mapped = -eta;
2858             // }
2859             //       else
2860             // {
2861             //   // Case 8
2862             //   eta_mapped  = -eta;
2863             //   zeta_mapped = zeta;
2864             // }
2865             //   }
2866 
2867 
2868             // // Face 5
2869             // else if ((i2[i] == 1) && (i0[i] >= 2) && (i1[i] >= 2))
2870             //   {
2871             //     const unsigned int min_node = std::min(elem->node(4),
2872             //    std::min(elem->node(5),
2873             //     std::min(elem->node(6),
2874             //      elem->node(7))));
2875             //     if (elem->node(4) == min_node)
2876             //       if (elem->node(5) == std::min(elem->node(5), elem->node(7)))
2877             // {
2878             //   // Case 1
2879             //   xi_mapped  = xi;
2880             //   eta_mapped = eta;
2881             // }
2882             //       else
2883             // {
2884             //   // Case 2
2885             //   xi_mapped  = eta;
2886             //   eta_mapped = xi;
2887             // }
2888 
2889             //     else if (elem->node(5) == min_node)
2890             //       if (elem->node(6) == std::min(elem->node(6), elem->node(4)))
2891             // {
2892             //   // Case 3
2893             //   xi_mapped  = eta;
2894             //   eta_mapped = -xi;
2895             // }
2896             //       else
2897             // {
2898             //   // Case 4
2899             //   xi_mapped  = -xi;
2900             //   eta_mapped = eta;
2901             // }
2902 
2903             //     else if (elem->node(6) == min_node)
2904             //       if (elem->node(7) == std::min(elem->node(7), elem->node(5)))
2905             // {
2906             //   // Case 5
2907             //   xi_mapped  = -xi;
2908             //   eta_mapped = -eta;
2909             // }
2910             //       else
2911             // {
2912             //   // Case 6
2913             //   xi_mapped  = -eta;
2914             //   eta_mapped = -xi;
2915             // }
2916 
2917             //     else if (elem->node(7) == min_node)
2918             //       if (elem->node(4) == std::min(elem->node(4), elem->node(6)))
2919             // {
2920             //   // Case 7
2921             //   xi_mapped  = -eta;
2922             //   eta_mapped = xi;
2923             // }
2924             //       else
2925             // {
2926             //   // Case 8
2927             //   xi_mapped  = xi;
2928             //   eta_mapped = eta;
2929             // }
2930             //   }
2931 
2932 
2933             //       }
2934 
2935 
2936 
2937             //       libmesh_assert_less (j, 3);
2938 
2939             //       switch (j)
2940             // {
2941             //   // d()/dxi
2942             // case 0:
2943             //   return (FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i0[i], 0, xi_mapped)*
2944             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta_mapped)*
2945             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta_mapped));
2946 
2947             //   // d()/deta
2948             // case 1:
2949             //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi_mapped)*
2950             //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i1[i], 0, eta_mapped)*
2951             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i2[i],    zeta_mapped));
2952 
2953             //   // d()/dzeta
2954             // case 2:
2955             //   return (FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i0[i],    xi_mapped)*
2956             //   FE<1,BERNSTEIN>::shape      (EDGE3, totalorder, i1[i],    eta_mapped)*
2957             //   FE<1,BERNSTEIN>::shape_deriv(EDGE3, totalorder, i2[i], 0, zeta_mapped));
2958 
2959             // default:
2960             //   libmesh_error();
2961             // }
2962             //    }
2963 
2964 
2965           default:
2966             libmesh_error();
2967           }
2968       }
2969 
2970 
2971     default:
2972       libmesh_error();
2973     }
2974 
2975 #endif
2976 
2977   libmesh_error();
2978   return 0\&.;
2979 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shape_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1645 of file fe_clough_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1650 {
1651   libMesh::err << "Clough-Tocher elements require the real element\n"
1652                << "to construct gradient-based degrees of freedom\&."
1653                << std::endl;
1654 
1655   libmesh_error();
1656   return 0\&.;
1657 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1662 of file fe_clough_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::SECOND, libMesh::THIRD, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
1667 {
1668   libmesh_assert(elem);
1669 
1670   clough_compute_coefs(elem);
1671 
1672   const ElemType type = elem->type();
1673 
1674   const Order totalorder = static_cast<Order>(order + elem->p_level());
1675 
1676   switch (totalorder)
1677     {
1678       // 2nd-order restricted Clough-Tocher element
1679     case SECOND:
1680       {
1681         // There may be a bug in the 2nd order case; the 3rd order
1682         // Clough-Tocher elements are pretty uniformly better anyways
1683         // so use those instead\&.
1684         libmesh_experimental();
1685         switch (type)
1686           {
1687             // C1 functions on the Clough-Tocher triangle\&.
1688           case TRI6:
1689             {
1690               libmesh_assert_less (i, 9);
1691               // FIXME: it would be nice to calculate (and cache)
1692               // clough_raw_shape(j,p) only once per triangle, not 1-7
1693               // times
1694               switch (i)
1695                 {
1696                   // Note: these DoF numbers are "scrambled" because my
1697                   // initial numbering conventions didn't match libMesh
1698                 case 0:
1699                   return clough_raw_shape_deriv(0, j, p)
1700                     + d1d2n * clough_raw_shape_deriv(10, j, p)
1701                     + d1d3n * clough_raw_shape_deriv(11, j, p);
1702                 case 3:
1703                   return clough_raw_shape_deriv(1, j, p)
1704                     + d2d3n * clough_raw_shape_deriv(11, j, p)
1705                     + d2d1n * clough_raw_shape_deriv(9, j, p);
1706                 case 6:
1707                   return clough_raw_shape_deriv(2, j, p)
1708                     + d3d1n * clough_raw_shape_deriv(9, j, p)
1709                     + d3d2n * clough_raw_shape_deriv(10, j, p);
1710                 case 1:
1711                   return d1xd1x * clough_raw_shape_deriv(3, j, p)
1712                     + d1xd1y * clough_raw_shape_deriv(4, j, p)
1713                     + d1xd2n * clough_raw_shape_deriv(10, j, p)
1714                     + d1xd3n * clough_raw_shape_deriv(11, j, p)
1715                     + 0\&.5 * N01x * d3nd3n * clough_raw_shape_deriv(11, j, p)
1716                     + 0\&.5 * N02x * d2nd2n * clough_raw_shape_deriv(10, j, p);
1717                 case 2:
1718                   return d1yd1y * clough_raw_shape_deriv(4, j, p)
1719                     + d1yd1x * clough_raw_shape_deriv(3, j, p)
1720                     + d1yd2n * clough_raw_shape_deriv(10, j, p)
1721                     + d1yd3n * clough_raw_shape_deriv(11, j, p)
1722                     + 0\&.5 * N01y * d3nd3n * clough_raw_shape_deriv(11, j, p)
1723                     + 0\&.5 * N02y * d2nd2n * clough_raw_shape_deriv(10, j, p);
1724                 case 4:
1725                   return d2xd2x * clough_raw_shape_deriv(5, j, p)
1726                     + d2xd2y * clough_raw_shape_deriv(6, j, p)
1727                     + d2xd3n * clough_raw_shape_deriv(11, j, p)
1728                     + d2xd1n * clough_raw_shape_deriv(9, j, p)
1729                     + 0\&.5 * N10x * d3nd3n * clough_raw_shape_deriv(11, j, p)
1730                     + 0\&.5 * N12x * d1nd1n * clough_raw_shape_deriv(9, j, p);
1731                 case 5:
1732                   return d2yd2y * clough_raw_shape_deriv(6, j, p)
1733                     + d2yd2x * clough_raw_shape_deriv(5, j, p)
1734                     + d2yd3n * clough_raw_shape_deriv(11, j, p)
1735                     + d2yd1n * clough_raw_shape_deriv(9, j, p)
1736                     + 0\&.5 * N10y * d3nd3n * clough_raw_shape_deriv(11, j, p)
1737                     + 0\&.5 * N12y * d1nd1n * clough_raw_shape_deriv(9, j, p);
1738                 case 7:
1739                   return d3xd3x * clough_raw_shape_deriv(7, j, p)
1740                     + d3xd3y * clough_raw_shape_deriv(8, j, p)
1741                     + d3xd1n * clough_raw_shape_deriv(9, j, p)
1742                     + d3xd2n * clough_raw_shape_deriv(10, j, p)
1743                     + 0\&.5 * N20x * d2nd2n * clough_raw_shape_deriv(10, j, p)
1744                     + 0\&.5 * N21x * d1nd1n * clough_raw_shape_deriv(9, j, p);
1745                 case 8:
1746                   return d3yd3y * clough_raw_shape_deriv(8, j, p)
1747                     + d3yd3x * clough_raw_shape_deriv(7, j, p)
1748                     + d3yd1n * clough_raw_shape_deriv(9, j, p)
1749                     + d3yd2n * clough_raw_shape_deriv(10, j, p)
1750                     + 0\&.5 * N20y * d2nd2n * clough_raw_shape_deriv(10, j, p)
1751                     + 0\&.5 * N21y * d1nd1n * clough_raw_shape_deriv(9, j, p);
1752                 default:
1753                   libmesh_error();
1754                 }
1755             }
1756           default:
1757             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1758             libmesh_error();
1759           }
1760       }
1761       // 3rd-order Clough-Tocher element
1762     case THIRD:
1763       {
1764         switch (type)
1765           {
1766             // C1 functions on the Clough-Tocher triangle\&.
1767           case TRI6:
1768             {
1769               libmesh_assert_less (i, 12);
1770 
1771               // FIXME: it would be nice to calculate (and cache)
1772               // clough_raw_shape(j,p) only once per triangle, not 1-7
1773               // times
1774               switch (i)
1775                 {
1776                   // Note: these DoF numbers are "scrambled" because my
1777                   // initial numbering conventions didn't match libMesh
1778                 case 0:
1779                   return clough_raw_shape_deriv(0, j, p)
1780                     + d1d2n * clough_raw_shape_deriv(10, j, p)
1781                     + d1d3n * clough_raw_shape_deriv(11, j, p);
1782                 case 3:
1783                   return clough_raw_shape_deriv(1, j, p)
1784                     + d2d3n * clough_raw_shape_deriv(11, j, p)
1785                     + d2d1n * clough_raw_shape_deriv(9, j, p);
1786                 case 6:
1787                   return clough_raw_shape_deriv(2, j, p)
1788                     + d3d1n * clough_raw_shape_deriv(9, j, p)
1789                     + d3d2n * clough_raw_shape_deriv(10, j, p);
1790                 case 1:
1791                   return d1xd1x * clough_raw_shape_deriv(3, j, p)
1792                     + d1xd1y * clough_raw_shape_deriv(4, j, p)
1793                     + d1xd2n * clough_raw_shape_deriv(10, j, p)
1794                     + d1xd3n * clough_raw_shape_deriv(11, j, p);
1795                 case 2:
1796                   return d1yd1y * clough_raw_shape_deriv(4, j, p)
1797                     + d1yd1x * clough_raw_shape_deriv(3, j, p)
1798                     + d1yd2n * clough_raw_shape_deriv(10, j, p)
1799                     + d1yd3n * clough_raw_shape_deriv(11, j, p);
1800                 case 4:
1801                   return d2xd2x * clough_raw_shape_deriv(5, j, p)
1802                     + d2xd2y * clough_raw_shape_deriv(6, j, p)
1803                     + d2xd3n * clough_raw_shape_deriv(11, j, p)
1804                     + d2xd1n * clough_raw_shape_deriv(9, j, p);
1805                 case 5:
1806                   return d2yd2y * clough_raw_shape_deriv(6, j, p)
1807                     + d2yd2x * clough_raw_shape_deriv(5, j, p)
1808                     + d2yd3n * clough_raw_shape_deriv(11, j, p)
1809                     + d2yd1n * clough_raw_shape_deriv(9, j, p);
1810                 case 7:
1811                   return d3xd3x * clough_raw_shape_deriv(7, j, p)
1812                     + d3xd3y * clough_raw_shape_deriv(8, j, p)
1813                     + d3xd1n * clough_raw_shape_deriv(9, j, p)
1814                     + d3xd2n * clough_raw_shape_deriv(10, j, p);
1815                 case 8:
1816                   return d3yd3y * clough_raw_shape_deriv(8, j, p)
1817                     + d3yd3x * clough_raw_shape_deriv(7, j, p)
1818                     + d3yd1n * clough_raw_shape_deriv(9, j, p)
1819                     + d3yd2n * clough_raw_shape_deriv(10, j, p);
1820                 case 10:
1821                   return d1nd1n * clough_raw_shape_deriv(9, j, p);
1822                 case 11:
1823                   return d2nd2n * clough_raw_shape_deriv(10, j, p);
1824                 case 9:
1825                   return d3nd3n * clough_raw_shape_deriv(11, j, p);
1826 
1827                 default:
1828                   libmesh_error();
1829                 }
1830             }
1831           default:
1832             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1833             libmesh_error();
1834           }
1835       }
1836       // by default throw an error
1837     default:
1838       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
1839       libmesh_error();
1840     }
1841 
1842   libmesh_error();
1843   return 0\&.;
1844 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1934 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
1939 {
1940   libmesh_assert(elem);
1941 
1942   // call the orientation-independent shape function derivatives
1943   return FE<3,LAGRANGE>::shape_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
1944 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 67 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
72 {
73   return 0\&.;
74 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 67 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
72 {
73   return 0\&.;
74 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 67 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
72 {
73   return 0\&.;
74 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 69 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
74 {
75   return 0\&.;
76 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 77 of file fe_scalar_shape_0D\&.C\&.
.PP
.nf
82 {
83   return 0\&.;
84 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 77 of file fe_scalar_shape_3D\&.C\&.
.PP
.nf
82 {
83   return 0\&.;
84 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 77 of file fe_scalar_shape_1D\&.C\&.
.PP
.nf
82 {
83   return 0\&.;
84 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 79 of file fe_scalar_shape_2D\&.C\&.
.PP
.nf
84 {
85   return 0\&.;
86 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
90 {
91   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 85 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
90 {
91   // No spatial derivatives in 0D!
92   libmesh_error();
93   return 0\&.;
94 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 94 of file fe_clough_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
.nf
99 {
100   libmesh_assert(elem);
101   libmesh_not_implemented();
102   return 0\&.;
103 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_szabab_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
104 {
105   libMesh::err << "Szabo-Babuska polynomials are not defined in 3D\n" << std::endl;
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_clough_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_xyz_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_l2_hierarchic_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_hermite_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_monomial_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_szabab_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_l2_lagrange_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_bernstein_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_lagrange_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 99 of file fe_hierarchic_shape_0D\&.C\&.
.PP
.nf
104 {
105   // No spatial derivatives in 0D!
106   libmesh_error();
107   return 0\&.;
108 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 147 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
152 {
153   // only d()/dxi in 1D!
154 
155   libmesh_assert_equal_to (j, 0);
156 
157   const Real xi = p(0);
158 
159   libmesh_assert_less_equal (i, static_cast<unsigned int>(order));
160 
161   switch (i)
162     {
163     case 0:
164     case 1:
165       return 0\&.;
166 
167     case 2:
168       return 2\&.;
169 
170     case 3:
171       return 6\&.*xi;
172 
173     case 4:
174       return 12\&.*xi*xi;
175 
176     default:
177       Real val = 2\&.;
178       for (unsigned int index = 2; index != i; ++index)
179         val *= (index+1) * xi;
180       return val;
181     }
182 
183   libmesh_error();
184   return 0\&.;
185 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Referenced by libMesh::FEXYZ< Dim >::compute_shape_functions(), libMesh::FEMap::init_edge_shape_functions(), libMesh::FEMap::init_face_shape_functions(), libMesh::FEMap::init_reference_to_physical_map(), libMesh::FE< Dim, T >::init_shape_functions(), libMesh::FESubdivision::init_shape_functions(), and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 175 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
180 {
181   static bool warning_given = false;
182 
183   if (!warning_given)
184     libMesh::err << "Second derivatives for Szabab elements "
185                  << " are not yet implemented!"
186                  << std::endl;
187 
188   warning_given = true;
189   return 0\&.;
190 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 190 of file fe_monomial_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
195 {
196   libmesh_assert(elem);
197 
198   return FE<1,MONOMIAL>::shape_second_deriv(elem->type(),
199                                             static_cast<Order>(order + elem->p_level()), i, j, p);
200 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 195 of file fe_szabab_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
200 {
201   static bool warning_given = false;
202 
203   if (!warning_given)
204     libMesh::err << "Second derivatives for Szabab elements "
205                  << " are not yet implemented!"
206                  << std::endl;
207 
208   warning_given = true;
209   return 0\&.;
210 }
.fi
.SS "template<unsigned int Dim, FEFamily T> static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 200 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
205 {
206   // only d2()/d2xi in 1D!
207 
208   libmesh_assert_equal_to (j, 0);
209   libmesh_assert_less (i, order+1u);
210 
211   // Declare that we are using our own special power function
212   // from the Utility namespace\&.  This saves typing later\&.
213   using Utility::pow;
214 
215   const Real xi = p(0);
216 
217   Real returnval = 1\&.;
218 
219   switch (i)
220     {
221     case 0:
222     case 1:
223       returnval = 0;
224       break;
225       // All terms have the same form\&.
226       // xi^(p-2)/(p-2)!
227     case 2:
228       returnval = 1;
229       break;
230     case 3:
231       returnval = xi;
232       break;
233     case 4:
234       returnval = pow<2>(xi)/2\&.;
235       break;
236     case 5:
237       returnval = pow<3>(xi)/6\&.;
238       break;
239     case 6:
240       returnval = pow<4>(xi)/24\&.;
241       break;
242     case 7:
243       returnval = pow<5>(xi)/120\&.;
244       break;
245 
246     default:
247       Real denominator = 1\&.;
248       for (unsigned int n=1; n != i; ++n)
249         {
250           returnval *= xi;
251           denominator *= n;
252         }
253       // Odd:
254       if (i % 2)
255         returnval = (i * returnval - 1\&.)/denominator/i;
256       // Even:
257       else
258         returnval = returnval/denominator;
259       break;
260     }
261 
262   return returnval;
263 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 200 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
205 {
206   // only d2()/d2xi in 1D!
207 
208   libmesh_assert_equal_to (j, 0);
209   libmesh_assert_less (i, order+1u);
210 
211   // Declare that we are using our own special power function
212   // from the Utility namespace\&.  This saves typing later\&.
213   using Utility::pow;
214 
215   const Real xi = p(0);
216 
217   Real returnval = 1\&.;
218 
219   switch (i)
220     {
221     case 0:
222     case 1:
223       returnval = 0;
224       break;
225       // All terms have the same form\&.
226       // xi^(p-2)/(p-2)!
227     case 2:
228       returnval = 1;
229       break;
230     case 3:
231       returnval = xi;
232       break;
233     case 4:
234       returnval = pow<2>(xi)/2\&.;
235       break;
236     case 5:
237       returnval = pow<3>(xi)/6\&.;
238       break;
239     case 6:
240       returnval = pow<4>(xi)/24\&.;
241       break;
242     case 7:
243       returnval = pow<5>(xi)/120\&.;
244       break;
245 
246     default:
247       Real denominator = 1\&.;
248       for (unsigned int n=1; n != i; ++n)
249         {
250           returnval *= xi;
251           denominator *= n;
252         }
253       // Odd:
254       if (i % 2)
255         returnval = (i * returnval - 1\&.)/denominator/i;
256       // Even:
257       else
258         returnval = returnval/denominator;
259       break;
260     }
261 
262   return returnval;
263 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 213 of file fe_xyz_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
218 {
219   libMesh::err << "XYZ polynomials require the element\n"
220                << "because the centroid is needed\&."
221                << std::endl;
222 
223   libmesh_error();
224   return 0\&.;
225 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &point_in)"

.PP
Definition at line 230 of file fe_xyz_shape_1D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), std::pow(), libMesh::Real, and libMesh::x\&.
.PP
.nf
235 {
236   libmesh_assert(elem);
237   libmesh_assert_less_equal (i, order + elem->p_level());
238 
239   // only d2()/dxi2 in 1D!
240 
241   libmesh_assert_equal_to (j, 0);
242 
243   // Only recompute the centroid if the element
244   // has changed from the last one we computed\&.
245   // This avoids repeated centroid calculations
246   // when called in succession with the same element\&.
247   if (elem->id() != old_elem_id)
248     {
249       centroid = elem->centroid();
250       old_elem_id = elem->id();
251       max_distance = 0\&.;
252       for (unsigned int p = 0; p < elem->n_nodes(); p++)
253         {
254           const Real distance = std::abs(centroid(0) - elem->point(p)(0));
255           max_distance = std::max(distance, max_distance);
256         }
257     }
258 
259   // Using static globals for old_elem_id, etc\&. will fail
260   // horribly with more than one thread\&.
261   libmesh_assert_equal_to (libMesh::n_threads(), 1);
262 
263   const Real x  = point_in(0);
264   const Real xc = centroid(0);
265   const Real dx = (x - xc)/max_distance;
266   const Real dist2 = pow(max_distance,2\&.);
267 
268   // monomials\&. since they are hierarchic we only need one case block\&.
269   switch (i)
270     {
271     case 0:
272     case 1:
273       return 0\&.;
274 
275     case 2:
276       return 2\&./dist2;
277 
278     case 3:
279       return 6\&.*dx/dist2;
280 
281     case 4:
282       return 12\&.*dx*dx/dist2;
283 
284     default:
285       Real val = 2\&.;
286       for (unsigned int index = 2; index != i; ++index)
287         val *= (index+1) * dx;
288       return val/dist2;
289     }
290 
291   libmesh_error();
292   return 0\&.;
293 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 254 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
259 {
260   // Don't need to switch on j\&.  1D shape functions
261   // depend on xi only!
262 
263   const Real xi = p(0);
264   libmesh_assert_equal_to (j, 0);
265 
266   switch (order)
267     {
268       // linear Lagrange shape functions
269     case FIRST:
270       {
271         // All second derivatives of linears are zero\&.\&.\&.\&.
272         return 0\&.;
273       }
274 
275       // quadratic Lagrange shape functions
276     case SECOND:
277       {
278         switch (i)
279           {
280           case 0:
281             return 1\&.;
282 
283           case 1:
284             return 1\&.;
285 
286           case 2:
287             return -2\&.;
288 
289           default:
290             {
291               libMesh::err << "Invalid shape function index requested!"
292                            << std::endl;
293               libmesh_error();
294             }
295           }
296       } // end case SECOND
297 
298     case THIRD:
299       {
300         switch (i)
301           {
302           case 0:
303             return -9\&./16\&.*(6\&.*xi-2);
304 
305           case 1:
306             return -9\&./16\&.*(-6*xi-2\&.);
307 
308           case 2:
309             return 27\&./16\&.*(6*xi-2\&./3\&.);
310 
311           case 3:
312             return 27\&./16\&.*(-6*xi-2\&./3\&.);
313 
314           default:
315             {
316               libMesh::err << "Invalid shape function index requested!"
317                            << std::endl;
318               libmesh_error();
319             }
320           }
321       } // end case THIRD
322 
323 
324     default:
325       {
326         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
327         libmesh_error();
328       }
329     } // end switch (order)
330 
331   libmesh_error();
332   return 0\&.;
333 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fPorder, const unsigned inti, const unsigned int libmesh_dbg_varj, const \fBPoint\fP &p)"

.PP
Definition at line 254 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::Real, libMesh::SECOND, and libMesh::THIRD\&.
.PP
.nf
259 {
260   // Don't need to switch on j\&.  1D shape functions
261   // depend on xi only!
262 
263   const Real xi = p(0);
264   libmesh_assert_equal_to (j, 0);
265 
266   switch (order)
267     {
268       // linear Lagrange shape functions
269     case FIRST:
270       {
271         // All second derivatives of linears are zero\&.\&.\&.\&.
272         return 0\&.;
273       }
274 
275       // quadratic Lagrange shape functions
276     case SECOND:
277       {
278         switch (i)
279           {
280           case 0:
281             return 1\&.;
282 
283           case 1:
284             return 1\&.;
285 
286           case 2:
287             return -2\&.;
288 
289           default:
290             {
291               libMesh::err << "Invalid shape function index requested!"
292                            << std::endl;
293               libmesh_error();
294             }
295           }
296       } // end case SECOND
297 
298     case THIRD:
299       {
300         switch (i)
301           {
302           case 0:
303             return -9\&./16\&.*(6\&.*xi-2);
304 
305           case 1:
306             return -9\&./16\&.*(-6*xi-2\&.);
307 
308           case 2:
309             return 27\&./16\&.*(6*xi-2\&./3\&.);
310 
311           case 3:
312             return 27\&./16\&.*(-6*xi-2\&./3\&.);
313 
314           default:
315             {
316               libMesh::err << "Invalid shape function index requested!"
317                            << std::endl;
318               libmesh_error();
319             }
320           }
321       } // end case THIRD
322 
323 
324     default:
325       {
326         libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
327         libmesh_error();
328       }
329     } // end switch (order)
330 
331   libmesh_error();
332   return 0\&.;
333 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 268 of file fe_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
273 {
274   libmesh_assert(elem);
275 
276   return FE<1,HIERARCHIC>::shape_second_deriv(elem->type(),
277                                               static_cast<Order>(order + elem->p_level()), i, j, p);
278 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 268 of file fe_l2_hierarchic_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
273 {
274   libmesh_assert(elem);
275 
276   return FE<1,L2_HIERARCHIC>::shape_second_deriv(elem->type(),
277                                                  static_cast<Order>(order + elem->p_level()), i, j, p);
278 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 318 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
323 {
324 #if LIBMESH_DIM > 1
325 
326 
327   libmesh_assert_less_equal (j, 2);
328 
329   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
330                        (static_cast<unsigned int>(order)+2)/2);
331 
332   const Real xi  = p(0);
333   const Real eta = p(1);
334 
335   // monomials\&. since they are hierarchic we only need one case block\&.
336 
337   switch (j)
338     {
339       // d^2()/dxi^2
340     case 0:
341       {
342         switch (i)
343           {
344             // constants
345           case 0:
346             // linears
347           case 1:
348           case 2:
349             return 0\&.;
350 
351             // quadratics
352           case 3:
353             return 2\&.;
354 
355           case 4:
356           case 5:
357             return 0\&.;
358 
359             // cubics
360           case 6:
361             return 6\&.*xi;
362 
363           case 7:
364             return 2\&.*eta;
365 
366           case 8:
367           case 9:
368             return 0\&.;
369 
370             // quartics
371           case 10:
372             return 12\&.*xi*xi;
373 
374           case 11:
375             return 6\&.*xi*eta;
376 
377           case 12:
378             return 2\&.*eta*eta;
379 
380           case 13:
381           case 14:
382             return 0\&.;
383 
384           default:
385             unsigned int o = 0;
386             for (; i >= (o+1)*(o+2)/2; o++) { }
387             unsigned int ny = i - (o*(o+1)/2);
388             unsigned int nx = o - ny;
389             Real val = nx * (nx - 1);
390             for (unsigned int index=2; index < nx; index++)
391               val *= xi;
392             for (unsigned int index=0; index != ny; index++)
393               val *= eta;
394             return val;
395           }
396       }
397 
398       // d^2()/dxideta
399     case 1:
400       {
401         switch (i)
402           {
403             // constants
404           case 0:
405 
406             // linears
407           case 1:
408           case 2:
409             return 0\&.;
410 
411             // quadratics
412           case 3:
413             return 0\&.;
414 
415           case 4:
416             return 1\&.;
417 
418           case 5:
419             return 0\&.;
420 
421             // cubics
422           case 6:
423             return 0\&.;
424           case 7:
425             return 2\&.*xi;
426 
427           case 8:
428             return 2\&.*eta;
429 
430           case 9:
431             return 0\&.;
432 
433             // quartics
434           case 10:
435             return 0\&.;
436 
437           case 11:
438             return 3\&.*xi*xi;
439 
440           case 12:
441             return 4\&.*xi*eta;
442 
443           case 13:
444             return 3\&.*eta*eta;
445 
446           case 14:
447             return 0\&.;
448 
449           default:
450             unsigned int o = 0;
451             for (; i >= (o+1)*(o+2)/2; o++) { }
452             unsigned int ny = i - (o*(o+1)/2);
453             unsigned int nx = o - ny;
454             Real val = nx * ny;
455             for (unsigned int index=1; index < nx; index++)
456               val *= xi;
457             for (unsigned int index=1; index < ny; index++)
458               val *= eta;
459             return val;
460           }
461       }
462 
463       // d^2()/deta^2
464     case 2:
465       {
466         switch (i)
467           {
468             // constants
469           case 0:
470 
471             // linears
472           case 1:
473           case 2:
474             return 0\&.;
475 
476             // quadratics
477           case 3:
478           case 4:
479             return 0\&.;
480 
481           case 5:
482             return 2\&.;
483 
484             // cubics
485           case 6:
486             return 0\&.;
487 
488           case 7:
489             return 0\&.;
490 
491           case 8:
492             return 2\&.*xi;
493 
494           case 9:
495             return 6\&.*eta;
496 
497             // quartics
498           case 10:
499           case 11:
500             return 0\&.;
501 
502           case 12:
503             return 2\&.*xi*xi;
504 
505           case 13:
506             return 6\&.*xi*eta;
507 
508           case 14:
509             return 12\&.*eta*eta;
510 
511           default:
512             unsigned int o = 0;
513             for (; i >= (o+1)*(o+2)/2; o++) { }
514             unsigned int ny = i - (o*(o+1)/2);
515             unsigned int nx = o - ny;
516             Real val = ny * (ny - 1);
517             for (unsigned int index=0; index != nx; index++)
518               val *= xi;
519             for (unsigned int index=2; index < ny; index++)
520               val *= eta;
521             return val;
522           }
523       }
524     }
525 
526   libmesh_error();
527   return 0\&.;
528 
529 #endif
530 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 329 of file fe_clough_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
334 {
335   libmesh_assert(elem);
336 
337   clough_compute_coefs(elem);
338 
339   const ElemType type = elem->type();
340 
341   const Order totalorder = static_cast<Order>(order + elem->p_level());
342 
343   switch (totalorder)
344     {
345       // 3rd-order C1 cubic element
346     case THIRD:
347       {
348         switch (type)
349           {
350             // C1 functions on the C1 cubic edge
351           case EDGE2:
352           case EDGE3:
353             {
354               switch (i)
355                 {
356                 case 0:
357                   return clough_raw_shape_second_deriv(0, j, p);
358                 case 1:
359                   return clough_raw_shape_second_deriv(1, j, p);
360                 case 2:
361                   return d1xd1x * clough_raw_shape_second_deriv(2, j, p);
362                 case 3:
363                   return d2xd2x * clough_raw_shape_second_deriv(3, j, p);
364                 default:
365                   libmesh_error();
366                 }
367             }
368           default:
369             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
370             libmesh_error();
371           }
372       }
373       // by default throw an error
374     default:
375       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
376       libmesh_error();
377     }
378 
379   libmesh_error();
380   return 0\&.;
381 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 336 of file fe_hermite_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::FEHermite< Dim >::hermite_raw_shape_second_deriv(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, and libMesh::Elem::type()\&.
.PP
.nf
341 {
342   libmesh_assert(elem);
343   libmesh_assert (j == 0 || j == 1 || j == 2);
344 
345   std::vector<std::vector<Real> > dxdxi(2, std::vector<Real>(2, 0));
346 
347 #ifdef DEBUG
348   std::vector<Real> dxdeta(2), dydxi(2);
349 #endif
350 
351   hermite_compute_coefs(elem,dxdxi
352 #ifdef DEBUG
353                         ,dxdeta,dydxi
354 #endif
355                         );
356 
357   const ElemType type = elem->type();
358 
359   const Order totalorder = static_cast<Order>(order + elem->p_level());
360 
361   switch (type)
362     {
363     case QUAD4:
364       libmesh_assert_less (totalorder, 4);
365     case QUAD8:
366     case QUAD9:
367       {
368         libmesh_assert_less (i, (totalorder+1u)*(totalorder+1u));
369 
370         std::vector<unsigned int> bases1D;
371 
372         Real coef = hermite_bases_2D(bases1D, dxdxi, totalorder, i);
373 
374         switch (j)
375           {
376           case 0:
377             return coef *
378               FEHermite<1>::hermite_raw_shape_second_deriv(bases1D[0],p(0)) *
379               FEHermite<1>::hermite_raw_shape(bases1D[1],p(1));
380           case 1:
381             return coef *
382               FEHermite<1>::hermite_raw_shape_deriv(bases1D[0],p(0)) *
383               FEHermite<1>::hermite_raw_shape_deriv(bases1D[1],p(1));
384           case 2:
385             return coef *
386               FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
387               FEHermite<1>::hermite_raw_shape_second_deriv(bases1D[1],p(1));
388           default:
389             libmesh_error();
390           }
391       }
392     default:
393       libMesh::err << "ERROR: Unsupported element type!" << std::endl;
394       libmesh_error();
395     }
396 
397   libmesh_error();
398   return 0\&.;
399 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 338 of file fe_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
343 {
344   libmesh_assert(elem);
345 
346   return FE<1,LAGRANGE>::shape_second_deriv(elem->type(),
347                                             static_cast<Order>(order + elem->p_level()), i, j, p);
348 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 338 of file fe_l2_lagrange_shape_1D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
343 {
344   libmesh_assert(elem);
345 
346   return FE<1,L2_LAGRANGE>::shape_second_deriv(elem->type(),
347                                                static_cast<Order>(order + elem->p_level()), i, j, p);
348 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsignedint, const \fBPoint\fP &p)"

.PP
Definition at line 345 of file fe_hermite_shape_1D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape_second_deriv(), libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
350 {
351   libmesh_assert(elem);
352 
353   // Coefficient naming: d(1)d(2n) is the coefficient of the
354   // global shape function corresponding to value 1 in terms of the
355   // local shape function corresponding to normal derivative 2
356   Real d1xd1x, d2xd2x;
357 
358   hermite_compute_coefs(elem, d1xd1x, d2xd2x);
359 
360   const ElemType type = elem->type();
361 
362   const Order totalorder = static_cast<Order>(order + elem->p_level());
363 
364   switch (totalorder)
365     {
366       // Hermite cubic shape functions
367     case THIRD:
368       {
369         switch (type)
370           {
371             // C1 functions on the C1 cubic edge
372           case EDGE2:
373           case EDGE3:
374             {
375               switch (i)
376                 {
377                 case 0:
378                   return FEHermite<1>::hermite_raw_shape_second_deriv(0, p(0));
379                 case 1:
380                   return d1xd1x * FEHermite<1>::hermite_raw_shape_second_deriv(2, p(0));
381                 case 2:
382                   return FEHermite<1>::hermite_raw_shape_second_deriv(1, p(0));
383                 case 3:
384                   return d2xd2x * FEHermite<1>::hermite_raw_shape_second_deriv(3, p(0));
385                 default:
386                   return FEHermite<1>::hermite_raw_shape_second_deriv(i, p(0));
387                 }
388             }
389           default:
390             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
391             libmesh_error();
392           }
393       }
394       // by default throw an error
395     default:
396       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
397       libmesh_error();
398     }
399 
400   libmesh_error();
401   return 0\&.;
402 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 364 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
369 {
370 #if LIBMESH_DIM > 1
371   libMesh::err << "Nedelec elements require the element type\n"
372                << "because edge orientation is needed\&."
373                << std::endl;
374   libmesh_error();
375 #endif // LIBMESH_DIM > 1
376 
377   libmesh_error();
378   return RealGradient();
379 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &)"

.PP
Definition at line 384 of file fe_nedelec_one_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::QUAD8, libMesh::QUAD9, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
389 {
390 #if LIBMESH_DIM > 1
391   libmesh_assert(elem);
392 
393   // j = 0 ==> d^2 phi / dxi^2
394   // j = 1 ==> d^2 phi / dxi deta
395   // j = 2 ==> d^2 phi / deta^2
396   libmesh_assert_less (j, 3);
397 
398   const Order total_order = static_cast<Order>(order + elem->p_level());
399 
400   switch (total_order)
401     {
402       // linear Lagrange shape functions
403     case FIRST:
404       {
405         switch (elem->type())
406           {
407           case QUAD8:
408           case QUAD9:
409             {
410               libmesh_assert_less (i, 4);
411               // All second derivatives for linear quads are zero\&.
412               return RealGradient();
413             }
414 
415           case TRI6:
416             {
417               libmesh_assert_less (i, 3);
418               // All second derivatives for linear triangles are zero\&.
419               return RealGradient();
420             }
421 
422           default:
423             {
424               libMesh::err << "ERROR: Unsupported 2D element type!: " << elem->type()
425                            << std::endl;
426               libmesh_error();
427             }
428 
429           } // end switch (type)
430       } // end case FIRST
431 
432       // unsupported order
433     default:
434       {
435         libMesh::err << "ERROR: Unsupported 2D FE order!: " << total_order
436                      << std::endl;
437         libmesh_error();
438       }
439 
440     } // end switch (order)
441 
442 #endif // LIBMESH_DIM > 1
443 
444   libmesh_error();
445   return RealGradient();
446 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 387 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
392 {
393   libMesh::err << "Hierarchic polynomials require the element type\n"
394                << "because edge orientation is needed\&."
395                << std::endl;
396 
397   libmesh_error();
398   return 0\&.;
399 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 387 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
392 {
393   libMesh::err << "Hierarchic polynomials require the element type\n"
394                << "because edge orientation is needed\&."
395                << std::endl;
396 
397   libmesh_error();
398   return 0\&.;
399 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 399 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
404 {
405   static bool warning_given = false;
406 
407   if (!warning_given)
408     libMesh::err << "Second derivatives for Bernstein elements "
409                  << "are not yet implemented!"
410                  << std::endl;
411 
412   warning_given = true;
413   return 0\&.;
414 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 404 of file fe_xyz_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
409 {
410   libMesh::err << "XYZ polynomials require the element\n"
411                << "because the centroid is needed\&."
412                << std::endl;
413 
414   libmesh_error();
415   return 0\&.;
416 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 404 of file fe_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::invalid_uint, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
409 {
410   libmesh_assert(elem);
411 
412   // I have been lazy here and am using finite differences
413   // to compute the derivatives!
414   const Real eps = 1\&.e-6;
415   Point pp, pm;
416   unsigned int prevj = libMesh::invalid_uint;
417 
418   switch (j)
419     {
420       //  d^2()/dxi^2
421     case 0:
422       {
423         pp = Point(p(0)+eps, p(1));
424         pm = Point(p(0)-eps, p(1));
425         prevj = 0;
426         break;
427       }
428 
429       // d^2()/dxideta
430     case 1:
431       {
432         pp = Point(p(0), p(1)+eps);
433         pm = Point(p(0), p(1)-eps);
434         prevj = 0;
435         break;
436       }
437 
438       // d^2()/deta^2
439     case 2:
440       {
441         pp = Point(p(0), p(1)+eps);
442         pm = Point(p(0), p(1)-eps);
443         prevj = 1;
444         break;
445       }
446     default:
447       libmesh_error();
448     }
449   return (FE<2,HIERARCHIC>::shape_deriv(elem, order, i, prevj, pp) -
450           FE<2,HIERARCHIC>::shape_deriv(elem, order, i, prevj, pm)
451           )/2\&./eps;
452 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 404 of file fe_l2_hierarchic_shape_2D\&.C\&.
.PP
References libMesh::invalid_uint, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
409 {
410   libmesh_assert(elem);
411 
412   // I have been lazy here and am using finite differences
413   // to compute the derivatives!
414   const Real eps = 1\&.e-6;
415   Point pp, pm;
416   unsigned int prevj = libMesh::invalid_uint;
417 
418   switch (j)
419     {
420       //  d^2()/dxi^2
421     case 0:
422       {
423         pp = Point(p(0)+eps, p(1));
424         pm = Point(p(0)-eps, p(1));
425         prevj = 0;
426         break;
427       }
428 
429       // d^2()/dxideta
430     case 1:
431       {
432         pp = Point(p(0), p(1)+eps);
433         pm = Point(p(0), p(1)-eps);
434         prevj = 0;
435         break;
436       }
437 
438       // d^2()/deta^2
439     case 2:
440       {
441         pp = Point(p(0), p(1)+eps);
442         pm = Point(p(0), p(1)-eps);
443         prevj = 1;
444         break;
445       }
446     default:
447       libmesh_error();
448     }
449   return (FE<2,L2_HIERARCHIC>::shape_deriv(elem, order, i, prevj, pp) -
450           FE<2,L2_HIERARCHIC>::shape_deriv(elem, order, i, prevj, pm)
451           )/2\&./eps;
452 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 420 of file fe_bernstein_shape_1D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
425 {
426   static bool warning_given = false;
427 
428   if (!warning_given)
429     libMesh::err << "Second derivatives for Bernstein elements "
430                  << "are not yet implemented!"
431                  << std::endl;
432 
433   warning_given = true;
434   return 0\&.;
435 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &point_in)"

.PP
Definition at line 421 of file fe_xyz_shape_2D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), std::pow(), libMesh::Real, and libMesh::x\&.
.PP
.nf
426 {
427 #if LIBMESH_DIM > 1
428 
429   libmesh_assert_less_equal (j, 2);
430   libmesh_assert(elem);
431 
432   // Only recompute the centroid if the element
433   // has changed from the last one we computed\&.
434   // This avoids repeated centroid calculations
435   // when called in succession with the same element\&.
436   if (elem->id() != old_elem_id)
437     {
438       centroid = elem->centroid();
439       old_elem_id = elem->id();
440       max_distance = Point(0\&.,0\&.,0\&.);
441       for (unsigned int p = 0; p < elem->n_nodes(); p++)
442         for (unsigned int d = 0; d < 2; d++)
443           {
444             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
445             max_distance(d) = std::max(distance, max_distance(d));
446           }
447     }
448 
449   // Using static globals for old_elem_id, etc\&. will fail
450   // horribly with more than one thread\&.
451   libmesh_assert_equal_to (libMesh::n_threads(), 1);
452 
453   const Real x  = point_in(0);
454   const Real y  = point_in(1);
455   const Real xc = centroid(0);
456   const Real yc = centroid(1);
457   const Real distx = max_distance(0);
458   const Real disty = max_distance(1);
459   const Real dx = (x - xc)/distx;
460   const Real dy = (y - yc)/disty;
461   const Real dist2x = pow(distx,2\&.);
462   const Real dist2y = pow(disty,2\&.);
463   const Real distxy = distx * disty;
464 
465 #ifndef NDEBUG
466   // totalorder is only used in the assertion below, so
467   // we avoid declaring it when asserts are not active\&.
468   const unsigned int totalorder = order + elem->p_level();
469 #endif
470   libmesh_assert_less (i, (totalorder+1)*(totalorder+2)/2);
471 
472   // monomials\&. since they are hierarchic we only need one case block\&.
473 
474   switch (j)
475     {
476       // d^2()/dx^2
477     case 0:
478       {
479         switch (i)
480           {
481             // constants
482           case 0:
483             // linears
484           case 1:
485           case 2:
486             return 0\&.;
487 
488             // quadratics
489           case 3:
490             return 2\&./dist2x;
491 
492           case 4:
493           case 5:
494             return 0\&.;
495 
496             // cubics
497           case 6:
498             return 6\&.*dx/dist2x;
499 
500           case 7:
501             return 2\&.*dy/dist2x;
502 
503           case 8:
504           case 9:
505             return 0\&.;
506 
507             // quartics
508           case 10:
509             return 12\&.*dx*dx/dist2x;
510 
511           case 11:
512             return 6\&.*dx*dy/dist2x;
513 
514           case 12:
515             return 2\&.*dy*dy/dist2x;
516 
517           case 13:
518           case 14:
519             return 0\&.;
520 
521           default:
522             unsigned int o = 0;
523             for (; i >= (o+1)*(o+2)/2; o++) { }
524             unsigned int i2 = i - (o*(o+1)/2);
525             Real val = (o - i2) * (o - i2 - 1);
526             for (unsigned int index=i2+2; index < o; index++)
527               val *= dx;
528             for (unsigned int index=0; index != i2; index++)
529               val *= dy;
530             return val/dist2x;
531           }
532       }
533 
534       // d^2()/dxdy
535     case 1:
536       {
537         switch (i)
538           {
539             // constants
540           case 0:
541 
542             // linears
543           case 1:
544           case 2:
545             return 0\&.;
546 
547             // quadratics
548           case 3:
549             return 0\&.;
550 
551           case 4:
552             return 1\&./distxy;
553 
554           case 5:
555             return 0\&.;
556 
557             // cubics
558           case 6:
559             return 0\&.;
560           case 7:
561             return 2\&.*dx/distxy;
562 
563           case 8:
564             return 2\&.*dy/distxy;
565 
566           case 9:
567             return 0\&.;
568 
569             // quartics
570           case 10:
571             return 0\&.;
572 
573           case 11:
574             return 3\&.*dx*dx/distxy;
575 
576           case 12:
577             return 4\&.*dx*dy/distxy;
578 
579           case 13:
580             return 3\&.*dy*dy/distxy;
581 
582           case 14:
583             return 0\&.;
584 
585           default:
586             unsigned int o = 0;
587             for (; i >= (o+1)*(o+2)/2; o++) { }
588             unsigned int i2 = i - (o*(o+1)/2);
589             Real val = (o - i2) * i2;
590             for (unsigned int index=i2+1; index < o; index++)
591               val *= dx;
592             for (unsigned int index=1; index < i2; index++)
593               val *= dy;
594             return val/distxy;
595           }
596       }
597 
598       // d^2()/dy^2
599     case 2:
600       {
601         switch (i)
602           {
603             // constants
604           case 0:
605 
606             // linears
607           case 1:
608           case 2:
609             return 0\&.;
610 
611             // quadratics
612           case 3:
613           case 4:
614             return 0\&.;
615 
616           case 5:
617             return 2\&./dist2y;
618 
619             // cubics
620           case 6:
621             return 0\&.;
622 
623           case 7:
624             return 0\&.;
625 
626           case 8:
627             return 2\&.*dx/dist2y;
628 
629           case 9:
630             return 6\&.*dy/dist2y;
631 
632             // quartics
633           case 10:
634           case 11:
635             return 0\&.;
636 
637           case 12:
638             return 2\&.*dx*dx/dist2y;
639 
640           case 13:
641             return 6\&.*dx*dy/dist2y;
642 
643           case 14:
644             return 12\&.*dy*dy/dist2y;
645 
646           default:
647             unsigned int o = 0;
648             for (; i >= (o+1)*(o+2)/2; o++) { }
649             unsigned int i2 = i - (o*(o+1)/2);
650             Real val = i2 * (i2 - 1);
651             for (unsigned int index=i2; index != o; index++)
652               val *= dx;
653             for (unsigned int index=2; index < i2; index++)
654               val *= dy;
655             return val/dist2y;
656           }
657       }
658     }
659 
660   libmesh_error();
661   return 0\&.;
662 
663 #endif
664 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 524 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
529 {
530 #if LIBMESH_DIM == 3
531   libMesh::err << "Nedelec elements require the element type\n"
532                << "because edge orientation is needed\&."
533                << std::endl;
534   libmesh_error();
535 #endif
536 
537   libmesh_error();
538   return RealGradient();
539 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 535 of file fe_monomial_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
540 {
541   libmesh_assert(elem);
542 
543   // by default call the orientation-independent shape functions
544   return FE<2,MONOMIAL>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
545 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 544 of file fe_nedelec_one_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Real, libMesh::TET10, libMesh::TOLERANCE, and libMesh::Elem::type()\&.
.PP
.nf
549 {
550 #if LIBMESH_DIM == 3
551 
552   libmesh_assert(elem);
553 
554   // j = 0 ==> d^2 phi / dxi^2
555   // j = 1 ==> d^2 phi / dxi deta
556   // j = 2 ==> d^2 phi / deta^2
557   // j = 3 ==> d^2 phi / dxi dzeta
558   // j = 4 ==> d^2 phi / deta dzeta
559   // j = 5 ==> d^2 phi / dzeta^2
560   libmesh_assert_less (j, 6);
561 
562   const Order totalorder = static_cast<Order>(order + elem->p_level());
563 
564   switch (totalorder)
565     {
566       // linear Lagrange shape functions
567     case FIRST:
568       {
569         switch (elem->type())
570           {
571           case HEX20:
572           case HEX27:
573             {
574               libmesh_assert_less (i, 12);
575 
576 #ifndef NDEBUG
577               const Real xi   = p(0);
578               const Real eta  = p(1);
579               const Real zeta = p(2);
580 #endif
581 
582               libmesh_assert_less_equal ( std::fabs(xi),   1\&.0+TOLERANCE );
583               libmesh_assert_less_equal ( std::fabs(eta),  1\&.0+TOLERANCE );
584               libmesh_assert_less_equal ( std::fabs(zeta), 1\&.0+TOLERANCE );
585 
586               switch (j)
587                 {
588                   // d^2()/dxi^2
589                 case 0:
590                   {
591                     // All d^2()/dxi^2 derivatives for linear hexes are zero\&.
592                     return RealGradient();
593                   } // j=0
594 
595                   // d^2()/dxideta
596                 case 1:
597                   {
598                     switch(i)
599                       {
600                       case 0:
601                       case 1:
602                       case 2:
603                       case 3:
604                       case 8:
605                       case 9:
606                       case 10:
607                       case 11:
608                         return RealGradient();
609                       case 4:
610                         {
611                           if( elem->point(0) > elem->point(4) )
612                             return RealGradient( 0\&.0, 0\&.0, -0\&.125 );
613                           else
614                             return RealGradient( 0\&.0, 0\&.0,  0\&.125 );
615                         }
616                       case 5:
617                         {
618                           if( elem->point(1) > elem->point(5) )
619                             return RealGradient( 0\&.0, 0\&.0,  0\&.125 );
620                           else
621                             return RealGradient( 0\&.0, 0\&.0, -0\&.125 );
622                         }
623                       case 6:
624                         {
625                           if( elem->point(2) > elem->point(6) )
626                             return RealGradient( 0\&.0, 0\&.0, -0\&.125 );
627                           else
628                             return RealGradient( 0\&.0, 0\&.0,  0\&.125 );
629                         }
630                       case 7:
631                         {
632                           if( elem->point(3) > elem->point(7) )
633                             return RealGradient( 0\&.0, 0\&.0,  0\&.125 );
634                           else
635                             return RealGradient( 0\&.0, 0\&.0, -0\&.125 );
636                         }
637                       default:
638                         libmesh_error();
639                       } // switch(i)
640 
641                   } // j=1
642 
643                   // d^2()/deta^2
644                 case 2:
645                   {
646                     // All d^2()/deta^2 derivatives for linear hexes are zero\&.
647                     return RealGradient();
648                   } // j = 2
649 
650                   // d^2()/dxidzeta
651                 case 3:
652                   {
653                     switch(i)
654                       {
655                       case 0:
656                       case 2:
657                       case 4:
658                       case 5:
659                       case 6:
660                       case 7:
661                       case 8:
662                       case 10:
663                         return RealGradient();
664 
665                       case 1:
666                         {
667                           if( elem->point(1) > elem->point(2) )
668                             return RealGradient( 0\&.0,  0\&.125 );
669                           else
670                             return RealGradient( 0\&.0, -0\&.125 );
671                         }
672                       case 3:
673                         {
674                           if( elem->point(3) > elem->point(0) )
675                             return RealGradient( 0\&.0, -0\&.125 );
676                           else
677                             return RealGradient( 0\&.0,  0\&.125 );
678                         }
679                       case 9:
680                         {
681                           if( elem->point(5) > elem->point(6) )
682                             return RealGradient( 0\&.0, -0\&.125, 0\&.0 );
683                           else
684                             return RealGradient( 0\&.0,  0\&.125, 0\&.0 );
685                         }
686                       case 11:
687                         {
688                           if( elem->point(4) > elem->point(7) )
689                             return RealGradient( 0\&.0,  0\&.125, 0\&.0 );
690                           else
691                             return RealGradient( 0\&.0, -0\&.125, 0\&.0 );
692                         }
693                       default:
694                         libmesh_error();
695                       } // switch(i)
696 
697                   } // j = 3
698 
699                   // d^2()/detadzeta
700                 case 4:
701                   {
702                     switch(i)
703                       {
704                       case 1:
705                       case 3:
706                       case 4:
707                       case 5:
708                       case 6:
709                       case 7:
710                       case 9:
711                       case 11:
712                         return RealGradient();
713 
714                       case 0:
715                         {
716                           if( elem->point(0) > elem->point(1) )
717                             return RealGradient( -0\&.125, 0\&.0, 0\&.0 );
718                           else
719                             return RealGradient(  0\&.125, 0\&.0, 0\&.0 );
720                         }
721                       case 2:
722                         {
723                           if( elem->point(2) > elem->point(3) )
724                             return RealGradient(  0\&.125, 0\&.0, 0\&.0 );
725                           else
726                             return RealGradient( -0\&.125, 0\&.0, 0\&.0 );
727                         }
728                       case 8:
729                         {
730                           if( elem->point(4) > elem->point(5) )
731                             return RealGradient(  0\&.125, 0\&.0, 0\&.0 );
732                           else
733                             return RealGradient( -0\&.125, 0\&.0, 0\&.0 );
734                         }
735                       case 10:
736                         {
737                           if( elem->point(7) > elem->point(6) )
738                             return RealGradient( -0\&.125, 0\&.0, 0\&.0 );
739                           else
740                             return RealGradient(  0\&.125, 0\&.0, 0\&.0 );
741                         }
742                       default:
743                         libmesh_error();
744                       } // switch(i)
745 
746                   } // j = 4
747 
748                   // d^2()/dzeta^2
749                 case 5:
750                   {
751                     // All d^2()/dzeta^2 derivatives for linear hexes are zero\&.
752                     return RealGradient();
753                   } // j = 5
754 
755                 default:
756                   libmesh_error();
757                 }
758 
759               return RealGradient();
760             }
761 
762           case TET10:
763             {
764               libmesh_assert_less (i, 6);
765 
766               libmesh_not_implemented();
767               return RealGradient();
768             }
769 
770           default:
771             {
772               libMesh::err << "ERROR: Unsupported 3D element type!: " << elem->type()
773                            << std::endl;
774               libmesh_error();
775             }
776 
777           } //switch(type)
778 
779       } // case FIRST:
780       // unsupported order
781     default:
782       {
783         libMesh::err << "ERROR: Unsupported 3D FE order!: " << totalorder
784                      << std::endl;
785         libmesh_error();
786       }
787     }
788 
789 #endif
790 
791   libmesh_error();
792   return RealGradient();
793 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 550 of file fe_hermite_shape_3D\&.C\&.
.PP
References libMesh::err, libMesh::FEHermite< Dim >::hermite_raw_shape(), libMesh::FEHermite< Dim >::hermite_raw_shape_deriv(), libMesh::FEHermite< Dim >::hermite_raw_shape_second_deriv(), libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::Real, libMesh::THIRD, and libMesh::Elem::type()\&.
.PP
.nf
555 {
556   libmesh_assert(elem);
557 
558   std::vector<std::vector<Real> > dxdxi(3, std::vector<Real>(2, 0));
559 
560 #ifdef DEBUG
561   std::vector<Real> dydxi(2), dzdeta(2), dxdzeta(2);
562   std::vector<Real> dzdxi(2), dxdeta(2), dydzeta(2);
563 #endif //DEBUG
564 
565   hermite_compute_coefs(elem, dxdxi
566 #ifdef DEBUG
567                         , dydxi, dzdeta, dxdzeta, dzdxi, dxdeta, dydzeta
568 #endif
569                         );
570 
571   const ElemType type = elem->type();
572 
573   const Order totalorder = static_cast<Order>(order + elem->p_level());
574 
575   switch (totalorder)
576     {
577       // 3rd-order tricubic Hermite functions
578     case THIRD:
579       {
580         switch (type)
581           {
582           case HEX8:
583           case HEX20:
584           case HEX27:
585             {
586               libmesh_assert_less (i, 64);
587 
588               std::vector<unsigned int> bases1D;
589 
590               Real coef = hermite_bases_3D(bases1D, dxdxi, totalorder, i);
591 
592               switch (j) // Derivative type
593                 {
594                 case 0:
595                   return coef *
596                     FEHermite<1>::hermite_raw_shape_second_deriv(bases1D[0],p(0)) *
597                     FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
598                     FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
599                   break;
600                 case 1:
601                   return coef *
602                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[0],p(0)) *
603                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[1],p(1)) *
604                     FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
605                   break;
606                 case 2:
607                   return coef *
608                     FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
609                     FEHermite<1>::hermite_raw_shape_second_deriv(bases1D[1],p(1)) *
610                     FEHermite<1>::hermite_raw_shape(bases1D[2],p(2));
611                   break;
612                 case 3:
613                   return coef *
614                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[0],p(0)) *
615                     FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
616                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[2],p(2));
617                   break;
618                 case 4:
619                   return coef *
620                     FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
621                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[1],p(1)) *
622                     FEHermite<1>::hermite_raw_shape_deriv(bases1D[2],p(2));
623                   break;
624                 case 5:
625                   return coef *
626                     FEHermite<1>::hermite_raw_shape(bases1D[0],p(0)) *
627                     FEHermite<1>::hermite_raw_shape(bases1D[1],p(1)) *
628                     FEHermite<1>::hermite_raw_shape_second_deriv(bases1D[2],p(2));
629                   break;
630                 }
631 
632             }
633           default:
634             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
635             libmesh_error();
636           }
637       }
638       // by default throw an error
639     default:
640       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
641       libmesh_error();
642     }
643 
644   libmesh_error();
645   return 0\&.;
646 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 551 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.PP
.nf
554 {
555   Real value = FE<0,LAGRANGE>::shape_second_deriv( type, order, i, j, p );
556   return libMesh::RealGradient( value );
557 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 573 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.PP
.nf
576 {
577   Real value = FE<1,LAGRANGE>::shape_second_deriv( type, order, i, j, p );
578   return libMesh::RealGradient( value );
579 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 593 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
598 {
599 #if LIBMESH_DIM > 1
600 
601   // j = 0 ==> d^2 phi / dxi^2
602   // j = 1 ==> d^2 phi / dxi deta
603   // j = 2 ==> d^2 phi / deta^2
604   libmesh_assert_less (j, 3);
605 
606   switch (order)
607     {
608       // linear Lagrange shape functions
609     case FIRST:
610       {
611         switch (type)
612           {
613           case QUAD4:
614           case QUAD8:
615           case QUAD9:
616             {
617               // Compute quad shape functions as a tensor-product
618               const Real xi  = p(0);
619               const Real eta = p(1);
620 
621               libmesh_assert_less (i, 4);
622 
623               //                                0  1  2  3
624               static const unsigned int i0[] = {0, 1, 1, 0};
625               static const unsigned int i1[] = {0, 0, 1, 1};
626 
627               switch (j)
628                 {
629                   // d^2() / dxi^2
630                 case 0:
631                   return 0\&.;
632 
633                   // d^2() / dxi deta
634                 case 1:
635                   return (FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
636                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta));
637 
638                   // d^2() / deta^2
639                 case 2:
640                   return 0\&.;
641 
642                 default:
643                   {
644                     libMesh::err << "ERROR: Invalid derivative requested! "
645                                  << std::endl;
646                     libmesh_error();
647                   }
648                 }
649             }
650 
651           case TRI3:
652           case TRI6:
653             {
654               // All second derivatives for linear triangles are zero\&.
655               return 0\&.;
656             }
657 
658           default:
659             {
660               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
661                            << std::endl;
662               libmesh_error();
663             }
664 
665           } // end switch (type)
666       } // end case FIRST
667 
668 
669       // quadratic Lagrange shape functions
670     case SECOND:
671       {
672         switch (type)
673           {
674           case QUAD8:
675             {
676               const Real xi  = p(0);
677               const Real eta = p(1);
678 
679               libmesh_assert_less (j, 3);
680 
681               switch (j)
682                 {
683                   // d^2() / dxi^2
684                 case 0:
685                   {
686                     switch (i)
687                       {
688                       case 0:
689                       case 1:
690                         return 0\&.5*(1\&.-eta);
691 
692                       case 2:
693                       case 3:
694                         return 0\&.5*(1\&.+eta);
695 
696                       case 4:
697                         return eta - 1\&.;
698 
699                       case 5:
700                       case 7:
701                         return 0\&.0;
702 
703                       case 6:
704                         return -1\&. - eta;
705 
706                       default:
707                         {
708                           libMesh::err << "Invalid shape function index requested!"
709                                        << std::endl;
710                           libmesh_error();
711                         }
712                       }
713                   }
714 
715                   // d^2() / dxi deta
716                 case 1:
717                   {
718                     switch (i)
719                       {
720                       case 0:
721                         return 0\&.25*( 1\&. - 2\&.*xi - 2\&.*eta);
722 
723                       case 1:
724                         return 0\&.25*(-1\&. - 2\&.*xi + 2\&.*eta);
725 
726                       case 2:
727                         return 0\&.25*( 1\&. + 2\&.*xi + 2\&.*eta);
728 
729                       case 3:
730                         return 0\&.25*(-1\&. + 2\&.*xi - 2\&.*eta);
731 
732                       case 4:
733                         return xi;
734 
735                       case 5:
736                         return -eta;
737 
738                       case 6:
739                         return -xi;
740 
741                       case 7:
742                         return eta;
743 
744                       default:
745                         {
746                           libMesh::err << "Invalid shape function index requested!"
747                                        << std::endl;
748                           libmesh_error();
749                         }
750                       }
751                   }
752 
753                   // d^2() / deta^2
754                 case 2:
755                   {
756                     switch (i)
757                       {
758                       case 0:
759                       case 3:
760                         return 0\&.5*(1\&.-xi);
761 
762                       case 1:
763                       case 2:
764                         return 0\&.5*(1\&.+xi);
765 
766                       case 4:
767                       case 6:
768                         return 0\&.0;
769 
770                       case 5:
771                         return -1\&.0 - xi;
772 
773                       case 7:
774                         return xi - 1\&.0;
775 
776                       default:
777                         {
778                           libMesh::err << "Invalid shape function index requested!"
779                                        << std::endl;
780                           libmesh_error();
781                         }
782                       }
783                   }
784 
785 
786                 default:
787                   {
788                     libMesh::err << "ERROR: Invalid derivative requested! "
789                                  << std::endl;
790                     libmesh_error();
791                   }
792                 } // end switch (j)
793             } // end case QUAD8
794 
795           case QUAD9:
796             {
797               // Compute QUAD9 second derivatives as tensor product
798               const Real xi  = p(0);
799               const Real eta = p(1);
800 
801               libmesh_assert_less (i, 9);
802 
803               //                                0  1  2  3  4  5  6  7  8
804               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
805               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
806 
807               switch (j)
808                 {
809                   // d^2() / dxi^2
810                 case 0:
811                   return (FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, xi)*
812                           FE<1,LAGRANGE>::shape             (EDGE3, SECOND, i1[i], eta));
813 
814                   // d^2() / dxi deta
815                 case 1:
816                   return (FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
817                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta));
818 
819                   // d^2() / deta^2
820                 case 2:
821                   return (FE<1,LAGRANGE>::shape             (EDGE3, SECOND, i0[i], xi)*
822                           FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i1[i], 0, eta));
823 
824                 default:
825                   {
826                     libMesh::err << "ERROR: Invalid derivative requested! "
827                                  << std::endl;
828                     libmesh_error();
829                   }
830                 }  // end switch (j)
831             } // end case QUAD9
832 
833           case TRI6:
834             {
835               const Real dzeta0dxi  = -1\&.;
836               const Real dzeta1dxi  = 1\&.;
837               const Real dzeta2dxi  = 0\&.;
838 
839               const Real dzeta0deta = -1\&.;
840               const Real dzeta1deta = 0\&.;
841               const Real dzeta2deta = 1\&.;
842 
843               libmesh_assert_less (j, 3);
844 
845               switch (j)
846                 {
847                   // d^2() / dxi^2
848                 case 0:
849                   {
850                     switch (i)
851                       {
852                       case 0:
853                         return 4\&.*dzeta0dxi*dzeta0dxi;
854 
855                       case 1:
856                         return 4\&.*dzeta1dxi*dzeta1dxi;
857 
858                       case 2:
859                         return 4\&.*dzeta2dxi*dzeta2dxi;
860 
861                       case 3:
862                         return 8\&.*dzeta0dxi*dzeta1dxi;
863 
864                       case 4:
865                         return 8\&.*dzeta1dxi*dzeta2dxi;
866 
867                       case 5:
868                         return 8\&.*dzeta0dxi*dzeta2dxi;
869 
870                       default:
871                         {
872                           libMesh::err << "Invalid shape function index requested!"
873                                        << std::endl;
874                           libmesh_error();
875                         }
876                       }
877                   }
878 
879                   // d^2() / dxi deta
880                 case 1:
881                   {
882                     switch (i)
883                       {
884                       case 0:
885                         return 4\&.*dzeta0dxi*dzeta0deta;
886 
887                       case 1:
888                         return 4\&.*dzeta1dxi*dzeta1deta;
889 
890                       case 2:
891                         return 4\&.*dzeta2dxi*dzeta2deta;
892 
893                       case 3:
894                         return 4\&.*dzeta1deta*dzeta0dxi + 4\&.*dzeta0deta*dzeta1dxi;
895 
896                       case 4:
897                         return 4\&.*dzeta2deta*dzeta1dxi + 4\&.*dzeta1deta*dzeta2dxi;
898 
899                       case 5:
900                         return 4\&.*dzeta2deta*dzeta0dxi + 4\&.*dzeta0deta*dzeta2dxi;
901 
902                       default:
903                         {
904                           libMesh::err << "Invalid shape function index requested!"
905                                        << std::endl;
906                           libmesh_error();
907                         }
908                       }
909                   }
910 
911                   // d^2() / deta^2
912                 case 2:
913                   {
914                     switch (i)
915                       {
916                       case 0:
917                         return 4\&.*dzeta0deta*dzeta0deta;
918 
919                       case 1:
920                         return 4\&.*dzeta1deta*dzeta1deta;
921 
922                       case 2:
923                         return 4\&.*dzeta2deta*dzeta2deta;
924 
925                       case 3:
926                         return 8\&.*dzeta0deta*dzeta1deta;
927 
928                       case 4:
929                         return 8\&.*dzeta1deta*dzeta2deta;
930 
931                       case 5:
932                         return 8\&.*dzeta0deta*dzeta2deta;
933 
934                       default:
935                         {
936                           libMesh::err << "Invalid shape function index requested!"
937                                        << std::endl;
938                           libmesh_error();
939                         }
940                       }
941                   }
942 
943                 default:
944                   {
945                     libMesh::err << "ERROR: Invalid derivative requested! "
946                                  << std::endl;
947                     libmesh_error();
948                   }
949                 } // end switch (j)
950             }  // end case TRI6
951 
952           default:
953             {
954               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
955                            << std::endl;
956               libmesh_error();
957             }
958           }
959       } // end case SECOND
960 
961 
962 
963       // unsupported order
964     default:
965       {
966         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
967                      << std::endl;
968         libmesh_error();
969       }
970 
971     } // end switch (order)
972 
973 
974   libmesh_error();
975 #endif // LIBMESH_DIM > 1
976   return 0\&.;
977 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 595 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::SECOND, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
600 {
601 #if LIBMESH_DIM > 1
602 
603   // j = 0 ==> d^2 phi / dxi^2
604   // j = 1 ==> d^2 phi / dxi deta
605   // j = 2 ==> d^2 phi / deta^2
606   libmesh_assert_less (j, 3);
607 
608   switch (order)
609     {
610       // linear Lagrange shape functions
611     case FIRST:
612       {
613         switch (type)
614           {
615           case QUAD4:
616           case QUAD8:
617           case QUAD9:
618             {
619               // Compute quad shape functions as a tensor-product
620               const Real xi  = p(0);
621               const Real eta = p(1);
622 
623               libmesh_assert_less (i, 4);
624 
625               //                                0  1  2  3
626               static const unsigned int i0[] = {0, 1, 1, 0};
627               static const unsigned int i1[] = {0, 0, 1, 1};
628 
629               switch (j)
630                 {
631                   // d^2() / dxi^2
632                 case 0:
633                   return 0\&.;
634 
635                   // d^2() / dxi deta
636                 case 1:
637                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
638                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta));
639 
640                   // d^2() / deta^2
641                 case 2:
642                   return 0\&.;
643 
644                 default:
645                   {
646                     libMesh::err << "ERROR: Invalid derivative requested! "
647                                  << std::endl;
648                     libmesh_error();
649                   }
650                 }
651             }
652 
653           case TRI3:
654           case TRI6:
655             {
656               // All second derivatives for linear triangles are zero\&.
657               return 0\&.;
658             }
659 
660           default:
661             {
662               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
663                            << std::endl;
664               libmesh_error();
665             }
666 
667           } // end switch (type)
668       } // end case FIRST
669 
670 
671       // quadratic Lagrange shape functions
672     case SECOND:
673       {
674         switch (type)
675           {
676           case QUAD8:
677             {
678               const Real xi  = p(0);
679               const Real eta = p(1);
680 
681               libmesh_assert_less (j, 3);
682 
683               switch (j)
684                 {
685                   // d^2() / dxi^2
686                 case 0:
687                   {
688                     switch (i)
689                       {
690                       case 0:
691                       case 1:
692                         return 0\&.5*(1\&.-eta);
693 
694                       case 2:
695                       case 3:
696                         return 0\&.5*(1\&.+eta);
697 
698                       case 4:
699                         return eta - 1\&.;
700 
701                       case 5:
702                       case 7:
703                         return 0\&.0;
704 
705                       case 6:
706                         return -1\&. - eta;
707 
708                       default:
709                         {
710                           libMesh::err << "Invalid shape function index requested!"
711                                        << std::endl;
712                           libmesh_error();
713                         }
714                       }
715                   }
716 
717                   // d^2() / dxi deta
718                 case 1:
719                   {
720                     switch (i)
721                       {
722                       case 0:
723                         return 0\&.25*( 1\&. - 2\&.*xi - 2\&.*eta);
724 
725                       case 1:
726                         return 0\&.25*(-1\&. - 2\&.*xi + 2\&.*eta);
727 
728                       case 2:
729                         return 0\&.25*( 1\&. + 2\&.*xi + 2\&.*eta);
730 
731                       case 3:
732                         return 0\&.25*(-1\&. + 2\&.*xi - 2\&.*eta);
733 
734                       case 4:
735                         return xi;
736 
737                       case 5:
738                         return -eta;
739 
740                       case 6:
741                         return -xi;
742 
743                       case 7:
744                         return eta;
745 
746                       default:
747                         {
748                           libMesh::err << "Invalid shape function index requested!"
749                                        << std::endl;
750                           libmesh_error();
751                         }
752                       }
753                   }
754 
755                   // d^2() / deta^2
756                 case 2:
757                   {
758                     switch (i)
759                       {
760                       case 0:
761                       case 3:
762                         return 0\&.5*(1\&.-xi);
763 
764                       case 1:
765                       case 2:
766                         return 0\&.5*(1\&.+xi);
767 
768                       case 4:
769                       case 6:
770                         return 0\&.0;
771 
772                       case 5:
773                         return -1\&.0 - xi;
774 
775                       case 7:
776                         return xi - 1\&.0;
777 
778                       default:
779                         {
780                           libMesh::err << "Invalid shape function index requested!"
781                                        << std::endl;
782                           libmesh_error();
783                         }
784                       }
785                   }
786 
787 
788                 default:
789                   {
790                     libMesh::err << "ERROR: Invalid derivative requested! "
791                                  << std::endl;
792                     libmesh_error();
793                   }
794                 } // end switch (j)
795             } // end case QUAD8
796 
797           case QUAD9:
798             {
799               // Compute QUAD9 second derivatives as tensor product
800               const Real xi  = p(0);
801               const Real eta = p(1);
802 
803               libmesh_assert_less (i, 9);
804 
805               //                                0  1  2  3  4  5  6  7  8
806               static const unsigned int i0[] = {0, 1, 1, 0, 2, 1, 2, 0, 2};
807               static const unsigned int i1[] = {0, 0, 1, 1, 0, 2, 1, 2, 2};
808 
809               switch (j)
810                 {
811                   // d^2() / dxi^2
812                 case 0:
813                   return (FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, xi)*
814                           FE<1,L2_LAGRANGE>::shape             (EDGE3, SECOND, i1[i], eta));
815 
816                   // d^2() / dxi deta
817                 case 1:
818                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
819                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta));
820 
821                   // d^2() / deta^2
822                 case 2:
823                   return (FE<1,L2_LAGRANGE>::shape             (EDGE3, SECOND, i0[i], xi)*
824                           FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i1[i], 0, eta));
825 
826                 default:
827                   {
828                     libMesh::err << "ERROR: Invalid derivative requested! "
829                                  << std::endl;
830                     libmesh_error();
831                   }
832                 }  // end switch (j)
833             } // end case QUAD9
834 
835           case TRI6:
836             {
837               const Real dzeta0dxi  = -1\&.;
838               const Real dzeta1dxi  = 1\&.;
839               const Real dzeta2dxi  = 0\&.;
840 
841               const Real dzeta0deta = -1\&.;
842               const Real dzeta1deta = 0\&.;
843               const Real dzeta2deta = 1\&.;
844 
845               libmesh_assert_less (j, 3);
846 
847               switch (j)
848                 {
849                   // d^2() / dxi^2
850                 case 0:
851                   {
852                     switch (i)
853                       {
854                       case 0:
855                         return 4\&.*dzeta0dxi*dzeta0dxi;
856 
857                       case 1:
858                         return 4\&.*dzeta1dxi*dzeta1dxi;
859 
860                       case 2:
861                         return 4\&.*dzeta2dxi*dzeta2dxi;
862 
863                       case 3:
864                         return 8\&.*dzeta0dxi*dzeta1dxi;
865 
866                       case 4:
867                         return 8\&.*dzeta1dxi*dzeta2dxi;
868 
869                       case 5:
870                         return 8\&.*dzeta0dxi*dzeta2dxi;
871 
872                       default:
873                         {
874                           libMesh::err << "Invalid shape function index requested!"
875                                        << std::endl;
876                           libmesh_error();
877                         }
878                       }
879                   }
880 
881                   // d^2() / dxi deta
882                 case 1:
883                   {
884                     switch (i)
885                       {
886                       case 0:
887                         return 4\&.*dzeta0dxi*dzeta0deta;
888 
889                       case 1:
890                         return 4\&.*dzeta1dxi*dzeta1deta;
891 
892                       case 2:
893                         return 4\&.*dzeta2dxi*dzeta2deta;
894 
895                       case 3:
896                         return 4\&.*dzeta1deta*dzeta0dxi + 4\&.*dzeta0deta*dzeta1dxi;
897 
898                       case 4:
899                         return 4\&.*dzeta2deta*dzeta1dxi + 4\&.*dzeta1deta*dzeta2dxi;
900 
901                       case 5:
902                         return 4\&.*dzeta2deta*dzeta0dxi + 4\&.*dzeta0deta*dzeta2dxi;
903 
904                       default:
905                         {
906                           libMesh::err << "Invalid shape function index requested!"
907                                        << std::endl;
908                           libmesh_error();
909                         }
910                       }
911                   }
912 
913                   // d^2() / deta^2
914                 case 2:
915                   {
916                     switch (i)
917                       {
918                       case 0:
919                         return 4\&.*dzeta0deta*dzeta0deta;
920 
921                       case 1:
922                         return 4\&.*dzeta1deta*dzeta1deta;
923 
924                       case 2:
925                         return 4\&.*dzeta2deta*dzeta2deta;
926 
927                       case 3:
928                         return 8\&.*dzeta0deta*dzeta1deta;
929 
930                       case 4:
931                         return 8\&.*dzeta1deta*dzeta2deta;
932 
933                       case 5:
934                         return 8\&.*dzeta0deta*dzeta2deta;
935 
936                       default:
937                         {
938                           libMesh::err << "Invalid shape function index requested!"
939                                        << std::endl;
940                           libmesh_error();
941                         }
942                       }
943                   }
944 
945                 default:
946                   {
947                     libMesh::err << "ERROR: Invalid derivative requested! "
948                                  << std::endl;
949                     libmesh_error();
950                   }
951                 } // end switch (j)
952             }  // end case TRI6
953 
954           default:
955             {
956               libMesh::err << "ERROR: Unsupported 2D element type!: " << type
957                            << std::endl;
958               libmesh_error();
959             }
960           }
961       } // end case SECOND
962 
963 
964 
965       // unsupported order
966     default:
967       {
968         libMesh::err << "ERROR: Unsupported 2D FE order!: " << order
969                      << std::endl;
970         libmesh_error();
971       }
972 
973     } // end switch (order)
974 
975 
976   libmesh_error();
977   return 0\&.;
978 #endif // LIBMESH_DIM > 1
979 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 609 of file fe_nedelec_one\&.C\&.
.PP
.nf
611 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 613 of file fe_nedelec_one\&.C\&.
.PP
.nf
615 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 623 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.PP
.nf
626 {
627   Real value = FE<2,LAGRANGE>::shape_second_deriv( type, order, i/2, j, p );
628 
629   switch( i%2 )
630     {
631     case 0:
632       return libMesh::RealGradient( value );
633 
634     case 1:
635       return libMesh::RealGradient( Real(0), value );
636 
637     default:
638       libmesh_error();
639     }
640 
641   //dummy
642   return libMesh::RealGradient();
643 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 632 of file fe_nedelec_one\&.C\&.
.PP
.nf
634 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 636 of file fe_nedelec_one\&.C\&.
.PP
.nf
638 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 652 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
657 {
658 #if LIBMESH_DIM == 3
659 
660   libmesh_assert_less (j, 6);
661 
662   libmesh_assert_less (i, (static_cast<unsigned int>(order)+1)*
663                        (static_cast<unsigned int>(order)+2)*
664                        (static_cast<unsigned int>(order)+3)/6);
665 
666   const Real xi   = p(0);
667   const Real eta  = p(1);
668   const Real zeta = p(2);
669 
670   // monomials\&. since they are hierarchic we only need one case block\&.
671   switch (j)
672     {
673       // d^2()/dxi^2
674     case 0:
675       {
676         switch (i)
677           {
678             // constant
679           case 0:
680 
681             // linear
682           case 1:
683           case 2:
684           case 3:
685             return 0\&.;
686 
687             // quadratic
688           case 4:
689             return 2\&.;
690 
691           case 5:
692           case 6:
693           case 7:
694           case 8:
695           case 9:
696             return 0\&.;
697 
698             // cubic
699           case 10:
700             return 6\&.*xi;
701 
702           case 11:
703             return 2\&.*eta;
704 
705           case 12:
706           case 13:
707             return 0\&.;
708 
709           case 14:
710             return 2\&.*zeta;
711 
712           case 15:
713           case 16:
714           case 17:
715           case 18:
716           case 19:
717             return 0\&.;
718 
719             // quartics
720           case 20:
721             return 12\&.*xi*xi;
722 
723           case 21:
724             return 6\&.*xi*eta;
725 
726           case 22:
727             return 2\&.*eta*eta;
728 
729           case 23:
730           case 24:
731             return 0\&.;
732 
733           case 25:
734             return 6\&.*xi*zeta;
735 
736           case 26:
737             return 2\&.*eta*zeta;
738 
739           case 27:
740           case 28:
741             return 0\&.;
742 
743           case 29:
744             return 2\&.*zeta*zeta;
745 
746           case 30:
747           case 31:
748           case 32:
749           case 33:
750           case 34:
751             return 0\&.;
752 
753           default:
754             unsigned int o = 0;
755             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
756             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
757             unsigned int block=o, nz = 0;
758             for (; block < i2; block += (o-nz+1)) { nz++; }
759             const unsigned int nx = block - i2;
760             const unsigned int ny = o - nx - nz;
761             Real val = nx * (nx - 1);
762             for (unsigned int index=2; index < nx; index++)
763               val *= xi;
764             for (unsigned int index=0; index != ny; index++)
765               val *= eta;
766             for (unsigned int index=0; index != nz; index++)
767               val *= zeta;
768             return val;
769           }
770       }
771 
772 
773       // d^2()/dxideta
774     case 1:
775       {
776         switch (i)
777           {
778             // constant
779           case 0:
780 
781             // linear
782           case 1:
783           case 2:
784           case 3:
785             return 0\&.;
786 
787             // quadratic
788           case 4:
789             return 0\&.;
790 
791           case 5:
792             return 1\&.;
793 
794           case 6:
795           case 7:
796           case 8:
797           case 9:
798             return 0\&.;
799 
800             // cubic
801           case 10:
802             return 0\&.;
803 
804           case 11:
805             return 2\&.*xi;
806 
807           case 12:
808             return 2\&.*eta;
809 
810           case 13:
811           case 14:
812             return 0\&.;
813 
814           case 15:
815             return zeta;
816 
817           case 16:
818           case 17:
819           case 18:
820           case 19:
821             return 0\&.;
822 
823             // quartics
824           case 20:
825             return 0\&.;
826 
827           case 21:
828             return 3\&.*xi*xi;
829 
830           case 22:
831             return 4\&.*xi*eta;
832 
833           case 23:
834             return 3\&.*eta*eta;
835 
836           case 24:
837           case 25:
838             return 0\&.;
839 
840           case 26:
841             return 2\&.*xi*zeta;
842 
843           case 27:
844             return 2\&.*eta*zeta;
845 
846           case 28:
847           case 29:
848             return 0\&.;
849 
850           case 30:
851             return zeta*zeta;
852 
853           case 31:
854           case 32:
855           case 33:
856           case 34:
857             return 0\&.;
858 
859           default:
860             unsigned int o = 0;
861             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
862             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
863             unsigned int block=o, nz = 0;
864             for (; block < i2; block += (o-nz+1)) { nz++; }
865             const unsigned int nx = block - i2;
866             const unsigned int ny = o - nx - nz;
867             Real val = nx * ny;
868             for (unsigned int index=1; index < nx; index++)
869               val *= xi;
870             for (unsigned int index=1; index < ny; index++)
871               val *= eta;
872             for (unsigned int index=0; index != nz; index++)
873               val *= zeta;
874             return val;
875           }
876       }
877 
878 
879       // d^2()/deta^2
880     case 2:
881       {
882         switch (i)
883           {
884             // constant
885           case 0:
886 
887             // linear
888           case 1:
889           case 2:
890           case 3:
891             return 0\&.;
892 
893             // quadratic
894           case 4:
895           case 5:
896             return 0\&.;
897 
898           case 6:
899             return 2\&.;
900 
901           case 7:
902           case 8:
903           case 9:
904             return 0\&.;
905 
906             // cubic
907           case 10:
908           case 11:
909             return 0\&.;
910 
911           case 12:
912             return 2\&.*xi;
913           case 13:
914             return 6\&.*eta;
915 
916           case 14:
917           case 15:
918             return 0\&.;
919 
920           case 16:
921             return 2\&.*zeta;
922 
923           case 17:
924           case 18:
925           case 19:
926             return 0\&.;
927 
928             // quartics
929           case 20:
930           case 21:
931             return 0\&.;
932 
933           case 22:
934             return 2\&.*xi*xi;
935 
936           case 23:
937             return 6\&.*xi*eta;
938 
939           case 24:
940             return 12\&.*eta*eta;
941 
942           case 25:
943           case 26:
944             return 0\&.;
945 
946           case 27:
947             return 2\&.*xi*zeta;
948 
949           case 28:
950             return 6\&.*eta*zeta;
951 
952           case 29:
953           case 30:
954             return 0\&.;
955 
956           case 31:
957             return 2\&.*zeta*zeta;
958 
959           case 32:
960           case 33:
961           case 34:
962             return 0\&.;
963 
964           default:
965             unsigned int o = 0;
966             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
967             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
968             unsigned int block=o, nz = 0;
969             for (; block < i2; block += (o-nz+1)) { nz++; }
970             const unsigned int nx = block - i2;
971             const unsigned int ny = o - nx - nz;
972             Real val = ny * (ny - 1);
973             for (unsigned int index=0; index != nx; index++)
974               val *= xi;
975             for (unsigned int index=2; index < ny; index++)
976               val *= eta;
977             for (unsigned int index=0; index != nz; index++)
978               val *= zeta;
979             return val;
980           }
981       }
982 
983 
984       // d^2()/dxidzeta
985     case 3:
986       {
987         switch (i)
988           {
989             // constant
990           case 0:
991 
992             // linear
993           case 1:
994           case 2:
995           case 3:
996             return 0\&.;
997 
998             // quadratic
999           case 4:
1000           case 5:
1001           case 6:
1002             return 0\&.;
1003 
1004           case 7:
1005             return 1\&.;
1006 
1007           case 8:
1008           case 9:
1009             return 0\&.;
1010 
1011             // cubic
1012           case 10:
1013           case 11:
1014           case 12:
1015           case 13:
1016             return 0\&.;
1017 
1018           case 14:
1019             return 2\&.*xi;
1020 
1021           case 15:
1022             return eta;
1023 
1024           case 16:
1025             return 0\&.;
1026 
1027           case 17:
1028             return 2\&.*zeta;
1029 
1030           case 18:
1031           case 19:
1032             return 0\&.;
1033 
1034             // quartics
1035           case 20:
1036           case 21:
1037           case 22:
1038           case 23:
1039           case 24:
1040             return 0\&.;
1041 
1042           case 25:
1043             return 3\&.*xi*xi;
1044 
1045           case 26:
1046             return 2\&.*xi*eta;
1047 
1048           case 27:
1049             return eta*eta;
1050 
1051           case 28:
1052             return 0\&.;
1053 
1054           case 29:
1055             return 4\&.*xi*zeta;
1056 
1057           case 30:
1058             return 2\&.*eta*zeta;
1059 
1060           case 31:
1061             return 0\&.;
1062 
1063           case 32:
1064             return 3\&.*zeta*zeta;
1065 
1066           case 33:
1067           case 34:
1068             return 0\&.;
1069 
1070           default:
1071             unsigned int o = 0;
1072             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1073             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1074             unsigned int block=o, nz = 0;
1075             for (; block < i2; block += (o-nz+1)) { nz++; }
1076             const unsigned int nx = block - i2;
1077             const unsigned int ny = o - nx - nz;
1078             Real val = nx * nz;
1079             for (unsigned int index=1; index < nx; index++)
1080               val *= xi;
1081             for (unsigned int index=0; index != ny; index++)
1082               val *= eta;
1083             for (unsigned int index=1; index < nz; index++)
1084               val *= zeta;
1085             return val;
1086           }
1087       }
1088 
1089       // d^2()/detadzeta
1090     case 4:
1091       {
1092         switch (i)
1093           {
1094             // constant
1095           case 0:
1096 
1097             // linear
1098           case 1:
1099           case 2:
1100           case 3:
1101             return 0\&.;
1102 
1103             // quadratic
1104           case 4:
1105           case 5:
1106           case 6:
1107           case 7:
1108             return 0\&.;
1109 
1110           case 8:
1111             return 1\&.;
1112 
1113           case 9:
1114             return 0\&.;
1115 
1116             // cubic
1117           case 10:
1118           case 11:
1119           case 12:
1120           case 13:
1121           case 14:
1122             return 0\&.;
1123 
1124           case 15:
1125             return xi;
1126 
1127           case 16:
1128             return 2\&.*eta;
1129 
1130           case 17:
1131             return 0\&.;
1132 
1133           case 18:
1134             return 2\&.*zeta;
1135 
1136           case 19:
1137             return 0\&.;
1138 
1139             // quartics
1140           case 20:
1141           case 21:
1142           case 22:
1143           case 23:
1144           case 24:
1145           case 25:
1146             return 0\&.;
1147 
1148           case 26:
1149             return xi*xi;
1150 
1151           case 27:
1152             return 2\&.*xi*eta;
1153 
1154           case 28:
1155             return 3\&.*eta*eta;
1156 
1157           case 29:
1158             return 0\&.;
1159 
1160           case 30:
1161             return 2\&.*xi*zeta;
1162 
1163           case 31:
1164             return 4\&.*eta*zeta;
1165 
1166           case 32:
1167             return 0\&.;
1168 
1169           case 33:
1170             return 3\&.*zeta*zeta;
1171 
1172           case 34:
1173             return 0\&.;
1174 
1175           default:
1176             unsigned int o = 0;
1177             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1178             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1179             unsigned int block=o, nz = 0;
1180             for (; block < i2; block += (o-nz+1)) { nz++; }
1181             const unsigned int nx = block - i2;
1182             const unsigned int ny = o - nx - nz;
1183             Real val = ny * nz;
1184             for (unsigned int index=0; index != nx; index++)
1185               val *= xi;
1186             for (unsigned int index=1; index < ny; index++)
1187               val *= eta;
1188             for (unsigned int index=1; index < nz; index++)
1189               val *= zeta;
1190             return val;
1191           }
1192       }
1193 
1194 
1195       // d^2()/dzeta^2
1196     case 5:
1197       {
1198         switch (i)
1199           {
1200             // constant
1201           case 0:
1202 
1203             // linear
1204           case 1:
1205           case 2:
1206           case 3:
1207             return 0\&.;
1208 
1209             // quadratic
1210           case 4:
1211           case 5:
1212           case 6:
1213           case 7:
1214           case 8:
1215             return 0\&.;
1216 
1217           case 9:
1218             return 2\&.;
1219 
1220             // cubic
1221           case 10:
1222           case 11:
1223           case 12:
1224           case 13:
1225           case 14:
1226           case 15:
1227           case 16:
1228             return 0\&.;
1229 
1230           case 17:
1231             return 2\&.*xi;
1232 
1233           case 18:
1234             return 2\&.*eta;
1235 
1236           case 19:
1237             return 6\&.*zeta;
1238 
1239             // quartics
1240           case 20:
1241           case 21:
1242           case 22:
1243           case 23:
1244           case 24:
1245           case 25:
1246           case 26:
1247           case 27:
1248           case 28:
1249             return 0\&.;
1250 
1251           case 29:
1252             return 2\&.*xi*xi;
1253 
1254           case 30:
1255             return 2\&.*xi*eta;
1256 
1257           case 31:
1258             return 2\&.*eta*eta;
1259 
1260           case 32:
1261             return 6\&.*xi*zeta;
1262 
1263           case 33:
1264             return 6\&.*eta*zeta;
1265 
1266           case 34:
1267             return 12\&.*zeta*zeta;
1268 
1269           default:
1270             unsigned int o = 0;
1271             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1272             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1273             unsigned int block=o, nz = 0;
1274             for (; block < i2; block += (o-nz+1)) { nz++; }
1275             const unsigned int nx = block - i2;
1276             const unsigned int ny = o - nx - nz;
1277             Real val = nz * (nz - 1);
1278             for (unsigned int index=0; index != nx; index++)
1279               val *= xi;
1280             for (unsigned int index=0; index != ny; index++)
1281               val *= eta;
1282             for (unsigned int index=2; index < nz; index++)
1283               val *= zeta;
1284             return val;
1285           }
1286       }
1287 
1288 
1289     default:
1290       libmesh_error();
1291     }
1292 
1293 #endif
1294 
1295   libmesh_error();
1296   return 0\&.;
1297 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 694 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Real, and libMesh::FE< Dim, T >::shape_second_deriv()\&.
.PP
.nf
697 {
698   Real value = FE<3,LAGRANGE>::shape_second_deriv( type, order, i/3, j, p );
699 
700   switch( i%3 )
701     {
702     case 0:
703       return libMesh::RealGradient( value );
704 
705     case 1:
706       return libMesh::RealGradient( Real(0), value );
707 
708     case 2:
709       return libMesh::RealGradient( Real(0), Real(0), value );
710 
711     default:
712       libmesh_error();
713     }
714 
715   //dummy
716   return libMesh::RealGradient();
717 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 735 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
738 {
739   Real value = FE<0,LAGRANGE>::shape_second_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
740   return libMesh::RealGradient( value );
741 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 744 of file fe_xyz_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
749 {
750   libMesh::err << "XYZ polynomials require the element\n"
751                << "because the centroid is needed\&."
752                << std::endl;
753 
754   libmesh_error();
755   return 0\&.;
756 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 757 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
760 {
761   Real value = FE<1,LAGRANGE>::shape_second_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
762   return libMesh::RealGradient( value );
763 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fP libmesh_dbg_varorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &point_in)"

.PP
Definition at line 761 of file fe_xyz_shape_3D\&.C\&.
.PP
References std::abs(), libMesh::Elem::centroid(), libMesh::DofObject::id(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::n_nodes(), libMesh::n_threads, libMesh::Elem::p_level(), libMesh::Elem::point(), std::pow(), libMesh::Real, and libMesh::x\&.
.PP
.nf
766 {
767 #if LIBMESH_DIM == 3
768 
769   libmesh_assert(elem);
770   libmesh_assert_less (j, 6);
771 
772   // Only recompute the centroid if the element
773   // has changed from the last one we computed\&.
774   // This avoids repeated centroid calculations
775   // when called in succession with the same element\&.
776   if (elem->id() != old_elem_id)
777     {
778       centroid = elem->centroid();
779       old_elem_id = elem->id();
780       max_distance = Point(0\&.,0\&.,0\&.);
781       for (unsigned int p = 0; p < elem->n_nodes(); p++)
782         for (unsigned int d = 0; d < 3; d++)
783           {
784             const Real distance = std::abs(centroid(d) - elem->point(p)(d));
785             max_distance(d) = std::max(distance, max_distance(d));
786           }
787     }
788 
789   // Using static globals for old_elem_id, etc\&. will fail
790   // horribly with more than one thread\&.
791   libmesh_assert_equal_to (libMesh::n_threads(), 1);
792 
793   const Real x  = point_in(0);
794   const Real y  = point_in(1);
795   const Real z  = point_in(2);
796   const Real xc = centroid(0);
797   const Real yc = centroid(1);
798   const Real zc = centroid(2);
799   const Real distx = max_distance(0);
800   const Real disty = max_distance(1);
801   const Real distz = max_distance(2);
802   const Real dx = (x - xc)/distx;
803   const Real dy = (y - yc)/disty;
804   const Real dz = (z - zc)/distz;
805   const Real dist2x = pow(distx,2\&.);
806   const Real dist2y = pow(disty,2\&.);
807   const Real dist2z = pow(distz,2\&.);
808   const Real distxy = distx * disty;
809   const Real distxz = distx * distz;
810   const Real distyz = disty * distz;
811 
812 #ifndef NDEBUG
813   // totalorder is only used in the assertion below, so
814   // we avoid declaring it when asserts are not active\&.
815   const unsigned int totalorder = static_cast<Order>(order + elem->p_level());
816 #endif
817   libmesh_assert_less (i, (static_cast<unsigned int>(totalorder)+1)*
818                        (static_cast<unsigned int>(totalorder)+2)*
819                        (static_cast<unsigned int>(totalorder)+3)/6);
820 
821   // monomials\&. since they are hierarchic we only need one case block\&.
822   switch (j)
823     {
824       // d^2()/dx^2
825     case 0:
826       {
827         switch (i)
828           {
829             // constant
830           case 0:
831 
832             // linear
833           case 1:
834           case 2:
835           case 3:
836             return 0\&.;
837 
838             // quadratic
839           case 4:
840             return 2\&./dist2x;
841 
842           case 5:
843           case 6:
844           case 7:
845           case 8:
846           case 9:
847             return 0\&.;
848 
849             // cubic
850           case 10:
851             return 6\&.*dx/dist2x;
852 
853           case 11:
854             return 2\&.*dy/dist2x;
855 
856           case 12:
857           case 13:
858             return 0\&.;
859 
860           case 14:
861             return 2\&.*dz/dist2x;
862 
863           case 15:
864           case 16:
865           case 17:
866           case 18:
867           case 19:
868             return 0\&.;
869 
870             // quartics
871           case 20:
872             return 12\&.*dx*dx/dist2x;
873 
874           case 21:
875             return 6\&.*dx*dy/dist2x;
876 
877           case 22:
878             return 2\&.*dy*dy/dist2x;
879 
880           case 23:
881           case 24:
882             return 0\&.;
883 
884           case 25:
885             return 6\&.*dx*dz/dist2x;
886 
887           case 26:
888             return 2\&.*dy*dz/dist2x;
889 
890           case 27:
891           case 28:
892             return 0\&.;
893 
894           case 29:
895             return 2\&.*dz*dz/dist2x;
896 
897           case 30:
898           case 31:
899           case 32:
900           case 33:
901           case 34:
902             return 0\&.;
903 
904           default:
905             unsigned int o = 0;
906             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
907             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
908             unsigned int block=o, nz = 0;
909             for (; block < i2; block += (o-nz+1)) { nz++; }
910             const unsigned int nx = block - i2;
911             const unsigned int ny = o - nx - nz;
912             Real val = nx * (nx - 1);
913             for (unsigned int index=2; index < nx; index++)
914               val *= dx;
915             for (unsigned int index=0; index != ny; index++)
916               val *= dy;
917             for (unsigned int index=0; index != nz; index++)
918               val *= dz;
919             return val/dist2x;
920           }
921       }
922 
923 
924       // d^2()/dxdy
925     case 1:
926       {
927         switch (i)
928           {
929             // constant
930           case 0:
931 
932             // linear
933           case 1:
934           case 2:
935           case 3:
936             return 0\&.;
937 
938             // quadratic
939           case 4:
940             return 0\&.;
941 
942           case 5:
943             return 1\&./distxy;
944 
945           case 6:
946           case 7:
947           case 8:
948           case 9:
949             return 0\&.;
950 
951             // cubic
952           case 10:
953             return 0\&.;
954 
955           case 11:
956             return 2\&.*dx/distxy;
957 
958           case 12:
959             return 2\&.*dy/distxy;
960 
961           case 13:
962           case 14:
963             return 0\&.;
964 
965           case 15:
966             return dz/distxy;
967 
968           case 16:
969           case 17:
970           case 18:
971           case 19:
972             return 0\&.;
973 
974             // quartics
975           case 20:
976             return 0\&.;
977 
978           case 21:
979             return 3\&.*dx*dx/distxy;
980 
981           case 22:
982             return 4\&.*dx*dy/distxy;
983 
984           case 23:
985             return 3\&.*dy*dy/distxy;
986 
987           case 24:
988           case 25:
989             return 0\&.;
990 
991           case 26:
992             return 2\&.*dx*dz/distxy;
993 
994           case 27:
995             return 2\&.*dy*dz/distxy;
996 
997           case 28:
998           case 29:
999             return 0\&.;
1000 
1001           case 30:
1002             return dz*dz/distxy;
1003 
1004           case 31:
1005           case 32:
1006           case 33:
1007           case 34:
1008             return 0\&.;
1009 
1010           default:
1011             unsigned int o = 0;
1012             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1013             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1014             unsigned int block=o, nz = 0;
1015             for (; block < i2; block += (o-nz+1)) { nz++; }
1016             const unsigned int nx = block - i2;
1017             const unsigned int ny = o - nx - nz;
1018             Real val = nx * ny;
1019             for (unsigned int index=1; index < nx; index++)
1020               val *= dx;
1021             for (unsigned int index=1; index < ny; index++)
1022               val *= dy;
1023             for (unsigned int index=0; index != nz; index++)
1024               val *= dz;
1025             return val/distxy;
1026           }
1027       }
1028 
1029 
1030       // d^2()/dy^2
1031     case 2:
1032       {
1033         switch (i)
1034           {
1035             // constant
1036           case 0:
1037 
1038             // linear
1039           case 1:
1040           case 2:
1041           case 3:
1042             return 0\&.;
1043 
1044             // quadratic
1045           case 4:
1046           case 5:
1047             return 0\&.;
1048 
1049           case 6:
1050             return 2\&./dist2y;
1051 
1052           case 7:
1053           case 8:
1054           case 9:
1055             return 0\&.;
1056 
1057             // cubic
1058           case 10:
1059           case 11:
1060             return 0\&.;
1061 
1062           case 12:
1063             return 2\&.*dx/dist2y;
1064           case 13:
1065             return 6\&.*dy/dist2y;
1066 
1067           case 14:
1068           case 15:
1069             return 0\&.;
1070 
1071           case 16:
1072             return 2\&.*dz/dist2y;
1073 
1074           case 17:
1075           case 18:
1076           case 19:
1077             return 0\&.;
1078 
1079             // quartics
1080           case 20:
1081           case 21:
1082             return 0\&.;
1083 
1084           case 22:
1085             return 2\&.*dx*dx/dist2y;
1086 
1087           case 23:
1088             return 6\&.*dx*dy/dist2y;
1089 
1090           case 24:
1091             return 12\&.*dy*dy/dist2y;
1092 
1093           case 25:
1094           case 26:
1095             return 0\&.;
1096 
1097           case 27:
1098             return 2\&.*dx*dz/dist2y;
1099 
1100           case 28:
1101             return 6\&.*dy*dz/dist2y;
1102 
1103           case 29:
1104           case 30:
1105             return 0\&.;
1106 
1107           case 31:
1108             return 2\&.*dz*dz/dist2y;
1109 
1110           case 32:
1111           case 33:
1112           case 34:
1113             return 0\&.;
1114 
1115           default:
1116             unsigned int o = 0;
1117             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1118             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1119             unsigned int block=o, nz = 0;
1120             for (; block < i2; block += (o-nz+1)) { nz++; }
1121             const unsigned int nx = block - i2;
1122             const unsigned int ny = o - nx - nz;
1123             Real val = ny * (ny - 1);
1124             for (unsigned int index=0; index != nx; index++)
1125               val *= dx;
1126             for (unsigned int index=2; index < ny; index++)
1127               val *= dy;
1128             for (unsigned int index=0; index != nz; index++)
1129               val *= dz;
1130             return val/dist2y;
1131           }
1132       }
1133 
1134 
1135       // d^2()/dxdz
1136     case 3:
1137       {
1138         switch (i)
1139           {
1140             // constant
1141           case 0:
1142 
1143             // linear
1144           case 1:
1145           case 2:
1146           case 3:
1147             return 0\&.;
1148 
1149             // quadratic
1150           case 4:
1151           case 5:
1152           case 6:
1153             return 0\&.;
1154 
1155           case 7:
1156             return 1\&./distxz;
1157 
1158           case 8:
1159           case 9:
1160             return 0\&.;
1161 
1162             // cubic
1163           case 10:
1164           case 11:
1165           case 12:
1166           case 13:
1167             return 0\&.;
1168 
1169           case 14:
1170             return 2\&.*dx/distxz;
1171 
1172           case 15:
1173             return dy/distxz;
1174 
1175           case 16:
1176             return 0\&.;
1177 
1178           case 17:
1179             return 2\&.*dz/distxz;
1180 
1181           case 18:
1182           case 19:
1183             return 0\&.;
1184 
1185             // quartics
1186           case 20:
1187           case 21:
1188           case 22:
1189           case 23:
1190           case 24:
1191             return 0\&.;
1192 
1193           case 25:
1194             return 3\&.*dx*dx/distxz;
1195 
1196           case 26:
1197             return 2\&.*dx*dy/distxz;
1198 
1199           case 27:
1200             return dy*dy/distxz;
1201 
1202           case 28:
1203             return 0\&.;
1204 
1205           case 29:
1206             return 4\&.*dx*dz/distxz;
1207 
1208           case 30:
1209             return 2\&.*dy*dz/distxz;
1210 
1211           case 31:
1212             return 0\&.;
1213 
1214           case 32:
1215             return 3\&.*dz*dz/distxz;
1216 
1217           case 33:
1218           case 34:
1219             return 0\&.;
1220 
1221           default:
1222             unsigned int o = 0;
1223             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1224             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1225             unsigned int block=o, nz = 0;
1226             for (; block < i2; block += (o-nz+1)) { nz++; }
1227             const unsigned int nx = block - i2;
1228             const unsigned int ny = o - nx - nz;
1229             Real val = nx * nz;
1230             for (unsigned int index=1; index < nx; index++)
1231               val *= dx;
1232             for (unsigned int index=0; index != ny; index++)
1233               val *= dy;
1234             for (unsigned int index=1; index < nz; index++)
1235               val *= dz;
1236             return val/distxz;
1237           }
1238       }
1239 
1240       // d^2()/dydz
1241     case 4:
1242       {
1243         switch (i)
1244           {
1245             // constant
1246           case 0:
1247 
1248             // linear
1249           case 1:
1250           case 2:
1251           case 3:
1252             return 0\&.;
1253 
1254             // quadratic
1255           case 4:
1256           case 5:
1257           case 6:
1258           case 7:
1259             return 0\&.;
1260 
1261           case 8:
1262             return 1\&./distyz;
1263 
1264           case 9:
1265             return 0\&.;
1266 
1267             // cubic
1268           case 10:
1269           case 11:
1270           case 12:
1271           case 13:
1272           case 14:
1273             return 0\&.;
1274 
1275           case 15:
1276             return dx/distyz;
1277 
1278           case 16:
1279             return 2\&.*dy/distyz;
1280 
1281           case 17:
1282             return 0\&.;
1283 
1284           case 18:
1285             return 2\&.*dz/distyz;
1286 
1287           case 19:
1288             return 0\&.;
1289 
1290             // quartics
1291           case 20:
1292           case 21:
1293           case 22:
1294           case 23:
1295           case 24:
1296           case 25:
1297             return 0\&.;
1298 
1299           case 26:
1300             return dx*dx/distyz;
1301 
1302           case 27:
1303             return 2\&.*dx*dy/distyz;
1304 
1305           case 28:
1306             return 3\&.*dy*dy/distyz;
1307 
1308           case 29:
1309             return 0\&.;
1310 
1311           case 30:
1312             return 2\&.*dx*dz/distyz;
1313 
1314           case 31:
1315             return 4\&.*dy*dz/distyz;
1316 
1317           case 32:
1318             return 0\&.;
1319 
1320           case 33:
1321             return 3\&.*dz*dz/distyz;
1322 
1323           case 34:
1324             return 0\&.;
1325 
1326           default:
1327             unsigned int o = 0;
1328             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1329             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1330             unsigned int block=o, nz = 0;
1331             for (; block < i2; block += (o-nz+1)) { nz++; }
1332             const unsigned int nx = block - i2;
1333             const unsigned int ny = o - nx - nz;
1334             Real val = ny * nz;
1335             for (unsigned int index=0; index != nx; index++)
1336               val *= dx;
1337             for (unsigned int index=1; index < ny; index++)
1338               val *= dy;
1339             for (unsigned int index=1; index < nz; index++)
1340               val *= dz;
1341             return val/distyz;
1342           }
1343       }
1344 
1345 
1346       // d^2()/dz^2
1347     case 5:
1348       {
1349         switch (i)
1350           {
1351             // constant
1352           case 0:
1353 
1354             // linear
1355           case 1:
1356           case 2:
1357           case 3:
1358             return 0\&.;
1359 
1360             // quadratic
1361           case 4:
1362           case 5:
1363           case 6:
1364           case 7:
1365           case 8:
1366             return 0\&.;
1367 
1368           case 9:
1369             return 2\&./dist2z;
1370 
1371             // cubic
1372           case 10:
1373           case 11:
1374           case 12:
1375           case 13:
1376           case 14:
1377           case 15:
1378           case 16:
1379             return 0\&.;
1380 
1381           case 17:
1382             return 2\&.*dx/dist2z;
1383 
1384           case 18:
1385             return 2\&.*dy/dist2z;
1386 
1387           case 19:
1388             return 6\&.*dz/dist2z;
1389 
1390             // quartics
1391           case 20:
1392           case 21:
1393           case 22:
1394           case 23:
1395           case 24:
1396           case 25:
1397           case 26:
1398           case 27:
1399           case 28:
1400             return 0\&.;
1401 
1402           case 29:
1403             return 2\&.*dx*dx/dist2z;
1404 
1405           case 30:
1406             return 2\&.*dx*dy/dist2z;
1407 
1408           case 31:
1409             return 2\&.*dy*dy/dist2z;
1410 
1411           case 32:
1412             return 6\&.*dx*dz/dist2z;
1413 
1414           case 33:
1415             return 6\&.*dy*dz/dist2z;
1416 
1417           case 34:
1418             return 12\&.*dz*dz/dist2z;
1419 
1420           default:
1421             unsigned int o = 0;
1422             for (; i >= (o+1)*(o+2)*(o+3)/6; o++) { }
1423             unsigned int i2 = i - (o*(o+1)*(o+2)/6);
1424             unsigned int block=o, nz = 0;
1425             for (; block < i2; block += (o-nz+1)) { nz++; }
1426             const unsigned int nx = block - i2;
1427             const unsigned int ny = o - nx - nz;
1428             Real val = nz * (nz - 1);
1429             for (unsigned int index=0; index != nx; index++)
1430               val *= dx;
1431             for (unsigned int index=0; index != ny; index++)
1432               val *= dy;
1433             for (unsigned int index=2; index < nz; index++)
1434               val *= dz;
1435             return val/dist2z;
1436           }
1437       }
1438 
1439 
1440     default:
1441       libmesh_error();
1442     }
1443 
1444 #endif
1445 
1446   libmesh_error();
1447   return 0\&.;
1448 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 783 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
788 {
789   libMesh::err << "Hierarchic polynomials require the element type\n"
790                << "because edge and face orientation is needed\&."
791                << std::endl;
792   libmesh_error();
793 
794   return 0\&.;
795 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 783 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
788 {
789   libMesh::err << "Hierarchic polynomials require the element type\n"
790                << "because edge and face orientation is needed\&."
791                << std::endl;
792   libmesh_error();
793 
794   return 0\&.;
795 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 800 of file fe_l2_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::invalid_uint, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
805 {
806   libmesh_assert(elem);
807 
808   const Real eps = 1\&.e-6;
809   Point pp, pm;
810   unsigned int prevj = libMesh::invalid_uint;
811 
812   switch (j)
813     {
814       //  d^2()/dxi^2
815     case 0:
816       {
817         pp = Point(p(0)+eps, p(1), p(2));
818         pm = Point(p(0)-eps, p(1), p(2));
819         prevj = 0;
820         break;
821       }
822 
823       //  d^2()/dxideta
824     case 1:
825       {
826         pp = Point(p(0), p(1)+eps, p(2));
827         pm = Point(p(0), p(1)-eps, p(2));
828         prevj = 0;
829         break;
830       }
831 
832       //  d^2()/deta^2
833     case 2:
834       {
835         pp = Point(p(0), p(1)+eps, p(2));
836         pm = Point(p(0), p(1)-eps, p(2));
837         prevj = 1;
838         break;
839       }
840 
841       //  d^2()/dxidzeta
842     case 3:
843       {
844         pp = Point(p(0), p(1), p(2)+eps);
845         pm = Point(p(0), p(1), p(2)-eps);
846         prevj = 0;
847         break;
848       }
849 
850       //  d^2()/detadzeta
851     case 4:
852       {
853         pp = Point(p(0), p(1), p(2)+eps);
854         pm = Point(p(0), p(1), p(2)-eps);
855         prevj = 1;
856         break;
857       }
858 
859       //  d^2()/dzeta^2
860     case 5:
861       {
862         pp = Point(p(0), p(1), p(2)+eps);
863         pm = Point(p(0), p(1), p(2)-eps);
864         prevj = 2;
865         break;
866       }
867     default:
868       libmesh_error();
869     }
870   return (FE<3,L2_HIERARCHIC>::shape_deriv(elem, order, i, prevj, pp) -
871           FE<3,L2_HIERARCHIC>::shape_deriv(elem, order, i, prevj, pm))
872     / 2\&. / eps;
873 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 800 of file fe_hierarchic_shape_3D\&.C\&.
.PP
References libMesh::invalid_uint, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
805 {
806   libmesh_assert(elem);
807 
808   const Real eps = 1\&.e-6;
809   Point pp, pm;
810   unsigned int prevj = libMesh::invalid_uint;
811 
812   switch (j)
813     {
814       //  d^2()/dxi^2
815     case 0:
816       {
817         pp = Point(p(0)+eps, p(1), p(2));
818         pm = Point(p(0)-eps, p(1), p(2));
819         prevj = 0;
820         break;
821       }
822 
823       //  d^2()/dxideta
824     case 1:
825       {
826         pp = Point(p(0), p(1)+eps, p(2));
827         pm = Point(p(0), p(1)-eps, p(2));
828         prevj = 0;
829         break;
830       }
831 
832       //  d^2()/deta^2
833     case 2:
834       {
835         pp = Point(p(0), p(1)+eps, p(2));
836         pm = Point(p(0), p(1)-eps, p(2));
837         prevj = 1;
838         break;
839       }
840 
841       //  d^2()/dxidzeta
842     case 3:
843       {
844         pp = Point(p(0), p(1), p(2)+eps);
845         pm = Point(p(0), p(1), p(2)-eps);
846         prevj = 0;
847         break;
848       }
849 
850       //  d^2()/detadzeta
851     case 4:
852       {
853         pp = Point(p(0), p(1), p(2)+eps);
854         pm = Point(p(0), p(1), p(2)-eps);
855         prevj = 1;
856         break;
857       }
858 
859       //  d^2()/dzeta^2
860     case 5:
861       {
862         pp = Point(p(0), p(1), p(2)+eps);
863         pm = Point(p(0), p(1), p(2)-eps);
864         prevj = 2;
865         break;
866       }
867     default:
868       libmesh_error();
869     }
870   return (FE<3,HIERARCHIC>::shape_deriv(elem, order, i, prevj, pp) -
871           FE<3,HIERARCHIC>::shape_deriv(elem, order, i, prevj, pm))
872     / 2\&. / eps;
873 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 807 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
810 {
811   Real value = FE<2,LAGRANGE>::shape_second_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i/2, j, p );
812 
813   switch( i%2 )
814     {
815     case 0:
816       return libMesh::RealGradient( value );
817 
818     case 1:
819       return libMesh::RealGradient( Real(0), value );
820 
821     default:
822       libmesh_error();
823     }
824 
825   //dummy
826   return libMesh::RealGradient();
827 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 808 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FOURTH, and libMesh::TRI3SUBDIVISION\&.
.PP
.nf
813 {
814   switch (order)
815     {
816     case FOURTH:
817       {
818         switch (type)
819           {
820           case TRI3SUBDIVISION:
821             libmesh_assert_less(i, 12);
822             return FESubdivision::regular_shape_second_deriv(i,j,p(0),p(1));
823           default:
824             std::cerr << "ERROR: Unsupported element type!" << std::endl;
825             libmesh_error();
826           }
827       }
828     default:
829       std::cerr << "ERROR: Unsupported polynomial order!" << std::endl;
830       libmesh_error();
831     }
832 
833   libmesh_error();
834   return 0\&.;
835 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 840 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), and libMesh::Elem::type()\&.
.PP
.nf
845 {
846   libmesh_assert(elem);
847   return FE<2,SUBDIVISION>::shape_second_deriv(elem->type(), order, i, j, p);
848 }
.fi
.SS "template<> \fBRealGradient\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 877 of file fe_lagrange_vec\&.C\&.
.PP
References libMesh::Elem::p_level(), libMesh::Real, libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
880 {
881   Real value = FE<3,LAGRANGE>::shape_second_deriv( elem->type(), static_cast<Order>(order + elem->p_level()), i/3, j, p );
882 
883   switch( i%3 )
884     {
885     case 0:
886       return libMesh::RealGradient( value );
887 
888     case 1:
889       return libMesh::RealGradient( Real(0), value );
890 
891     case 2:
892       return libMesh::RealGradient( Real(0), Real(0), value );
893 
894     default:
895       libmesh_error();
896     }
897 
898   //dummy
899   return libMesh::RealGradient();
900 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 982 of file fe_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
987 {
988   libmesh_assert(elem);
989 
990   // call the orientation-independent shape functions
991   return FE<2,LAGRANGE>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
992 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 984 of file fe_l2_lagrange_shape_2D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
989 {
990   libmesh_assert(elem);
991 
992   // call the orientation-independent shape functions
993   return FE<2,L2_LAGRANGE>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
994 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1233 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::PRISM18, libMesh::Real, libMesh::SECOND, libMesh::TET10, and libMesh::TRI6\&.
.PP
.nf
1238 {
1239 #if LIBMESH_DIM == 3
1240 
1241   libmesh_assert_less (j, 6);
1242 
1243   switch (order)
1244     {
1245       // linear Lagrange shape functions
1246     case FIRST:
1247       {
1248         return 0\&.;
1249       }
1250 
1251       // quadratic Lagrange shape functions
1252     case SECOND:
1253       {
1254         switch (type)
1255           {
1256 
1257             // serendipity hexahedral quadratic shape functions
1258           case HEX20:
1259             {
1260               static bool warning_given_HEX20 = false;
1261 
1262               if (!warning_given_HEX20)
1263                 libMesh::err << "Second derivatives for 3D Lagrangian HEX20"
1264                              << " elements are not yet implemented!"
1265                              << std::endl;
1266               warning_given_HEX20 = true;
1267             }
1268 
1269             // triquadraic hexahedral shape funcions
1270           case HEX27:
1271             {
1272               libmesh_assert_less (i, 27);
1273 
1274               // Compute hex shape functions as a tensor-product
1275               const Real xi   = p(0);
1276               const Real eta  = p(1);
1277               const Real zeta = p(2);
1278 
1279               // The only way to make any sense of this
1280               // is to look at the mgflo/mg2/mgf documentation
1281               // and make the cut-out cube!
1282               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
1283               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
1284               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
1285               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
1286 
1287               switch(j)
1288                 {
1289                   // d^2()/dxi^2
1290                 case 0:
1291                   return (FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, xi)*
1292                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
1293                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
1294 
1295                   // d^2()/dxideta
1296                 case 1:
1297                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
1298                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
1299                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
1300 
1301                   // d^2()/deta^2
1302                 case 2:
1303                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
1304                           FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i1[i], 0, eta)*
1305                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
1306 
1307                   // d^2()/dxidzeta
1308                 case 3:
1309                   return (FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
1310                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
1311                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
1312 
1313                   // d^2()/detadzeta
1314                 case 4:
1315                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
1316                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
1317                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
1318 
1319                   // d^2()/dzeta^2
1320                 case 5:
1321                   return (FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
1322                           FE<1,L2_LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
1323                           FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i2[i], 0, zeta));
1324 
1325                 default:
1326                   {
1327                     libmesh_error();
1328                   }
1329                 }
1330             }
1331 
1332             // quadratic tetrahedral shape functions
1333           case TET10:
1334             {
1335               // The area coordinates are the same as used for the
1336               // shape() and shape_deriv() functions\&.
1337               // const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
1338               // const Real zeta1 = p(0);
1339               // const Real zeta2 = p(1);
1340               // const Real zeta3 = p(2);
1341               static const Real dzetadxi[4][3] =
1342                 {
1343                   {-1\&., -1\&., -1\&.},
1344                   {1\&.,   0\&.,  0\&.},
1345                   {0\&.,   1\&.,  0\&.},
1346                   {0\&.,   0\&.,  1\&.}
1347                 };
1348 
1349               // Convert from j -> (j,k) indices for independent variable
1350               // (0=xi, 1=eta, 2=zeta)
1351               static const unsigned short int independent_var_indices[6][2] =
1352                 {
1353                   {0, 0}, // d^2 phi / dxi^2
1354                   {0, 1}, // d^2 phi / dxi deta
1355                   {1, 1}, // d^2 phi / deta^2
1356                   {0, 2}, // d^2 phi / dxi dzeta
1357                   {1, 2}, // d^2 phi / deta dzeta
1358                   {2, 2}  // d^2 phi / dzeta^2
1359                 };
1360 
1361               // Convert from i -> zeta indices\&.  Each quadratic shape
1362               // function for the Tet10 depends on up to two of the zeta
1363               // area coordinate functions (see the shape() function above)\&.
1364               // This table just tells which two area coords it uses\&.
1365               static const unsigned short int zeta_indices[10][2] =
1366                 {
1367                   {0, 0},
1368                   {1, 1},
1369                   {2, 2},
1370                   {3, 3},
1371                   {0, 1},
1372                   {1, 2},
1373                   {2, 0},
1374                   {0, 3},
1375                   {1, 3},
1376                   {2, 3},
1377                 };
1378 
1379               // Look up the independent variable indices for this value of j\&.
1380               const unsigned int my_j = independent_var_indices[j][0];
1381               const unsigned int my_k = independent_var_indices[j][1];
1382 
1383               if (i<4)
1384                 {
1385                   return 4\&.*dzetadxi[i][my_j]*dzetadxi[i][my_k];
1386                 }
1387 
1388               else if (i<10)
1389                 {
1390                   const unsigned short int my_m = zeta_indices[i][0];
1391                   const unsigned short int my_n = zeta_indices[i][1];
1392 
1393                   return 4\&.*(dzetadxi[my_n][my_j]*dzetadxi[my_m][my_k] +
1394                              dzetadxi[my_m][my_j]*dzetadxi[my_n][my_k] );
1395                 }
1396               else
1397                 {
1398                   libMesh::err << "Invalid shape function index " << i << std::endl;
1399                   libmesh_error();
1400                 }
1401             }
1402 
1403 
1404             // quadradic prism shape functions
1405           case PRISM18:
1406             {
1407               libmesh_assert_less (i, 18);
1408 
1409               // Compute prism shape functions as a tensor-product
1410               // of a triangle and an edge
1411 
1412               Point p2d(p(0),p(1));
1413               Point p1d(p(2));
1414 
1415               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
1416               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
1417               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
1418 
1419               switch (j)
1420                 {
1421                   // d^2()/dxi^2
1422                 case 0:
1423                   return (FE<2,L2_LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 0, p2d)*
1424                           FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1425 
1426                   // d^2()/dxideta
1427                 case 1:
1428                   return (FE<2,L2_LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 1, p2d)*
1429                           FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1430 
1431                   // d^2()/deta^2
1432                 case 2:
1433                   return (FE<2,L2_LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 2, p2d)*
1434                           FE<1,L2_LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
1435 
1436                   // d^2()/dxidzeta
1437                 case 3:
1438                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 0, p2d)*
1439                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
1440 
1441                   // d^2()/detadzeta
1442                 case 4:
1443                   return (FE<2,L2_LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 1, p2d)*
1444                           FE<1,L2_LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
1445 
1446                   // d^2()/dzeta^2
1447                 case 5:
1448                   return (FE<2,L2_LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
1449                           FE<1,L2_LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, p1d));
1450                 }
1451             }
1452 
1453 
1454 
1455           default:
1456             {
1457               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
1458                            << std::endl;
1459               libmesh_error();
1460             }
1461           }
1462       }
1463 
1464 
1465       // unsupported order
1466     default:
1467       {
1468         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
1469                      << std::endl;
1470         libmesh_error();
1471       }
1472     }
1473 
1474 #endif
1475 
1476   libmesh_error();
1477   return 0\&.;
1478 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1302 of file fe_monomial_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
1307 {
1308   libmesh_assert(elem);
1309 
1310   // call the orientation-independent shape function derivatives
1311   return FE<3,MONOMIAL>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
1312 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1379 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1384 {
1385   static bool warning_given = false;
1386 
1387   if (!warning_given)
1388     libMesh::err << "Second derivatives for Szabab elements "
1389                  << " are not yet implemented!"
1390                  << std::endl;
1391 
1392   warning_given = true;
1393   return 0\&.;
1394 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1399 of file fe_szabab_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1404 {
1405   static bool warning_given = false;
1406 
1407   if (!warning_given)
1408     libMesh::err << "Second derivatives for Szabab elements "
1409                  << " are not yet implemented!"
1410                  << std::endl;
1411 
1412   warning_given = true;
1413   return 0\&.;
1414 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1483 of file fe_l2_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
1488 {
1489   libmesh_assert(elem);
1490 
1491   // call the orientation-independent shape function derivatives
1492   return FE<3,L2_LAGRANGE>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
1493 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1793 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1798 {
1799   static bool warning_given = false;
1800 
1801   if (!warning_given)
1802     libMesh::err << "Second derivatives for Bernstein elements "
1803                  << "are not yet implemented!"
1804                  << std::endl;
1805 
1806   warning_given = true;
1807   return 0\&.;
1808 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 1813 of file fe_bernstein_shape_2D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
1818 {
1819   static bool warning_given = false;
1820 
1821   if (!warning_given)
1822     libMesh::err << "Second derivatives for Bernstein elements "
1823                  << "are not yet implemented!"
1824                  << std::endl;
1825 
1826   warning_given = true;
1827   return 0\&.;
1828 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1849 of file fe_clough_shape_2D\&.C\&.
.PP
References libMesh::err, libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::SECOND, libMesh::THIRD, libMesh::TRI6, and libMesh::Elem::type()\&.
.PP
.nf
1854 {
1855   libmesh_assert(elem);
1856 
1857   clough_compute_coefs(elem);
1858 
1859   const ElemType type = elem->type();
1860 
1861   const Order totalorder = static_cast<Order>(order + elem->p_level());
1862 
1863   switch (totalorder)
1864     {
1865       // 2nd-order restricted Clough-Tocher element
1866     case SECOND:
1867       {
1868         switch (type)
1869           {
1870             // C1 functions on the Clough-Tocher triangle\&.
1871           case TRI6:
1872             {
1873               libmesh_assert_less (i, 9);
1874               // FIXME: it would be nice to calculate (and cache)
1875               // clough_raw_shape(j,p) only once per triangle, not 1-7
1876               // times
1877               switch (i)
1878                 {
1879                   // Note: these DoF numbers are "scrambled" because my
1880                   // initial numbering conventions didn't match libMesh
1881                 case 0:
1882                   return clough_raw_shape_second_deriv(0, j, p)
1883                     + d1d2n * clough_raw_shape_second_deriv(10, j, p)
1884                     + d1d3n * clough_raw_shape_second_deriv(11, j, p);
1885                 case 3:
1886                   return clough_raw_shape_second_deriv(1, j, p)
1887                     + d2d3n * clough_raw_shape_second_deriv(11, j, p)
1888                     + d2d1n * clough_raw_shape_second_deriv(9, j, p);
1889                 case 6:
1890                   return clough_raw_shape_second_deriv(2, j, p)
1891                     + d3d1n * clough_raw_shape_second_deriv(9, j, p)
1892                     + d3d2n * clough_raw_shape_second_deriv(10, j, p);
1893                 case 1:
1894                   return d1xd1x * clough_raw_shape_second_deriv(3, j, p)
1895                     + d1xd1y * clough_raw_shape_second_deriv(4, j, p)
1896                     + d1xd2n * clough_raw_shape_second_deriv(10, j, p)
1897                     + d1xd3n * clough_raw_shape_second_deriv(11, j, p)
1898                     + 0\&.5 * N01x * d3nd3n * clough_raw_shape_second_deriv(11, j, p)
1899                     + 0\&.5 * N02x * d2nd2n * clough_raw_shape_second_deriv(10, j, p);
1900                 case 2:
1901                   return d1yd1y * clough_raw_shape_second_deriv(4, j, p)
1902                     + d1yd1x * clough_raw_shape_second_deriv(3, j, p)
1903                     + d1yd2n * clough_raw_shape_second_deriv(10, j, p)
1904                     + d1yd3n * clough_raw_shape_second_deriv(11, j, p)
1905                     + 0\&.5 * N01y * d3nd3n * clough_raw_shape_second_deriv(11, j, p)
1906                     + 0\&.5 * N02y * d2nd2n * clough_raw_shape_second_deriv(10, j, p);
1907                 case 4:
1908                   return d2xd2x * clough_raw_shape_second_deriv(5, j, p)
1909                     + d2xd2y * clough_raw_shape_second_deriv(6, j, p)
1910                     + d2xd3n * clough_raw_shape_second_deriv(11, j, p)
1911                     + d2xd1n * clough_raw_shape_second_deriv(9, j, p)
1912                     + 0\&.5 * N10x * d3nd3n * clough_raw_shape_second_deriv(11, j, p)
1913                     + 0\&.5 * N12x * d1nd1n * clough_raw_shape_second_deriv(9, j, p);
1914                 case 5:
1915                   return d2yd2y * clough_raw_shape_second_deriv(6, j, p)
1916                     + d2yd2x * clough_raw_shape_second_deriv(5, j, p)
1917                     + d2yd3n * clough_raw_shape_second_deriv(11, j, p)
1918                     + d2yd1n * clough_raw_shape_second_deriv(9, j, p)
1919                     + 0\&.5 * N10y * d3nd3n * clough_raw_shape_second_deriv(11, j, p)
1920                     + 0\&.5 * N12y * d1nd1n * clough_raw_shape_second_deriv(9, j, p);
1921                 case 7:
1922                   return d3xd3x * clough_raw_shape_second_deriv(7, j, p)
1923                     + d3xd3y * clough_raw_shape_second_deriv(8, j, p)
1924                     + d3xd1n * clough_raw_shape_second_deriv(9, j, p)
1925                     + d3xd2n * clough_raw_shape_second_deriv(10, j, p)
1926                     + 0\&.5 * N20x * d2nd2n * clough_raw_shape_second_deriv(10, j, p)
1927                     + 0\&.5 * N21x * d1nd1n * clough_raw_shape_second_deriv(9, j, p);
1928                 case 8:
1929                   return d3yd3y * clough_raw_shape_second_deriv(8, j, p)
1930                     + d3yd3x * clough_raw_shape_second_deriv(7, j, p)
1931                     + d3yd1n * clough_raw_shape_second_deriv(9, j, p)
1932                     + d3yd2n * clough_raw_shape_second_deriv(10, j, p)
1933                     + 0\&.5 * N20y * d2nd2n * clough_raw_shape_second_deriv(10, j, p)
1934                     + 0\&.5 * N21y * d1nd1n * clough_raw_shape_second_deriv(9, j, p);
1935                 default:
1936                   libmesh_error();
1937                 }
1938             }
1939           default:
1940             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
1941             libmesh_error();
1942           }
1943       }
1944       // 3rd-order Clough-Tocher element
1945     case THIRD:
1946       {
1947         switch (type)
1948           {
1949             // C1 functions on the Clough-Tocher triangle\&.
1950           case TRI6:
1951             {
1952               libmesh_assert_less (i, 12);
1953 
1954               // FIXME: it would be nice to calculate (and cache)
1955               // clough_raw_shape(j,p) only once per triangle, not 1-7
1956               // times
1957               switch (i)
1958                 {
1959                   // Note: these DoF numbers are "scrambled" because my
1960                   // initial numbering conventions didn't match libMesh
1961                 case 0:
1962                   return clough_raw_shape_second_deriv(0, j, p)
1963                     + d1d2n * clough_raw_shape_second_deriv(10, j, p)
1964                     + d1d3n * clough_raw_shape_second_deriv(11, j, p);
1965                 case 3:
1966                   return clough_raw_shape_second_deriv(1, j, p)
1967                     + d2d3n * clough_raw_shape_second_deriv(11, j, p)
1968                     + d2d1n * clough_raw_shape_second_deriv(9, j, p);
1969                 case 6:
1970                   return clough_raw_shape_second_deriv(2, j, p)
1971                     + d3d1n * clough_raw_shape_second_deriv(9, j, p)
1972                     + d3d2n * clough_raw_shape_second_deriv(10, j, p);
1973                 case 1:
1974                   return d1xd1x * clough_raw_shape_second_deriv(3, j, p)
1975                     + d1xd1y * clough_raw_shape_second_deriv(4, j, p)
1976                     + d1xd2n * clough_raw_shape_second_deriv(10, j, p)
1977                     + d1xd3n * clough_raw_shape_second_deriv(11, j, p);
1978                 case 2:
1979                   return d1yd1y * clough_raw_shape_second_deriv(4, j, p)
1980                     + d1yd1x * clough_raw_shape_second_deriv(3, j, p)
1981                     + d1yd2n * clough_raw_shape_second_deriv(10, j, p)
1982                     + d1yd3n * clough_raw_shape_second_deriv(11, j, p);
1983                 case 4:
1984                   return d2xd2x * clough_raw_shape_second_deriv(5, j, p)
1985                     + d2xd2y * clough_raw_shape_second_deriv(6, j, p)
1986                     + d2xd3n * clough_raw_shape_second_deriv(11, j, p)
1987                     + d2xd1n * clough_raw_shape_second_deriv(9, j, p);
1988                 case 5:
1989                   return d2yd2y * clough_raw_shape_second_deriv(6, j, p)
1990                     + d2yd2x * clough_raw_shape_second_deriv(5, j, p)
1991                     + d2yd3n * clough_raw_shape_second_deriv(11, j, p)
1992                     + d2yd1n * clough_raw_shape_second_deriv(9, j, p);
1993                 case 7:
1994                   return d3xd3x * clough_raw_shape_second_deriv(7, j, p)
1995                     + d3xd3y * clough_raw_shape_second_deriv(8, j, p)
1996                     + d3xd1n * clough_raw_shape_second_deriv(9, j, p)
1997                     + d3xd2n * clough_raw_shape_second_deriv(10, j, p);
1998                 case 8:
1999                   return d3yd3y * clough_raw_shape_second_deriv(8, j, p)
2000                     + d3yd3x * clough_raw_shape_second_deriv(7, j, p)
2001                     + d3yd1n * clough_raw_shape_second_deriv(9, j, p)
2002                     + d3yd2n * clough_raw_shape_second_deriv(10, j, p);
2003                 case 10:
2004                   return d1nd1n * clough_raw_shape_second_deriv(9, j, p);
2005                 case 11:
2006                   return d2nd2n * clough_raw_shape_second_deriv(10, j, p);
2007                 case 9:
2008                   return d3nd3n * clough_raw_shape_second_deriv(11, j, p);
2009 
2010                 default:
2011                   libmesh_error();
2012                 }
2013             }
2014           default:
2015             libMesh::err << "ERROR: Unsupported element type!" << std::endl;
2016             libmesh_error();
2017           }
2018       }
2019       // by default throw an error
2020     default:
2021       libMesh::err << "ERROR: Unsupported polynomial order!" << std::endl;
2022       libmesh_error();
2023     }
2024 
2025   libmesh_error();
2026   return 0\&.;
2027 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElemType\fPtype, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 1949 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::FIRST, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::Real, libMesh::SECOND, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI6, and libMesh::x\&.
.PP
.nf
1954 {
1955 #if LIBMESH_DIM == 3
1956 
1957   libmesh_assert_less (j, 6);
1958 
1959   switch (order)
1960     {
1961       // linear Lagrange shape functions
1962     case FIRST:
1963       {
1964         switch (type)
1965           {
1966             // Linear tets have all second derivatives = 0
1967           case TET4:
1968           case TET10:
1969             {
1970               return 0\&.;
1971             }
1972 
1973             // The following elements use either tensor product or
1974             // rational basis functions, and therefore probably have
1975             // second derivatives, but we have not implemented them
1976             // yet\&.\&.\&.
1977           case PRISM6:
1978           case PRISM15:
1979           case PRISM18:
1980             {
1981               libmesh_assert_less (i, 6);
1982 
1983               // Compute prism shape functions as a tensor-product
1984               // of a triangle and an edge
1985 
1986               Point p2d(p(0),p(1));
1987               Point p1d(p(2));
1988 
1989               //                                0  1  2  3  4  5
1990               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1};
1991               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2};
1992 
1993               switch (j)
1994                 {
1995                   // All repeated second derivatives and the xi-eta derivative are zero on PRISMs
1996                 case 0: // d^2()/dxi^2
1997                 case 1: // d^2()/dxideta
1998                 case 2: // d^2()/deta^2
1999                 case 5: // d^2()/dzeta^2
2000                   {
2001                     return 0\&.;
2002                   }
2003 
2004                 case 3: // d^2()/dxidzeta
2005                   return (FE<2,LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 0, p2d)*
2006                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, p1d));
2007 
2008                 case 4: // d^2()/detadzeta
2009                   return (FE<2,LAGRANGE>::shape_deriv(TRI3,  FIRST, i1[i], 1, p2d)*
2010                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, p1d));
2011 
2012                 default:
2013                   {
2014                     // Unrecognized index
2015                     libmesh_error();
2016                   }
2017                 }
2018               return 0\&.;
2019             }
2020 
2021           case PYRAMID5:
2022           case PYRAMID13:
2023           case PYRAMID14:
2024             {
2025               libmesh_assert_less (i, 5);
2026 
2027               const Real xi   = p(0);
2028               const Real eta  = p(1);
2029               const Real zeta = p(2);
2030               const Real eps  = 1\&.e-35;
2031 
2032               switch (j)
2033                 {
2034                   // xi-xi and eta-eta derivatives are all zero for PYRAMID5\&.
2035                 case 0: // d^2()/dxi^2
2036                 case 2: // d^2()/deta^2
2037                   return 0\&.;
2038 
2039                 case 1: // d^2()/dxideta
2040                   {
2041                     switch (i)
2042                       {
2043                       case 0:
2044                       case 2:
2045                         return 0\&.25/(1\&. - zeta + eps);
2046                       case 1:
2047                       case 3:
2048                         return -0\&.25/(1\&. - zeta + eps);
2049                       case 4:
2050                         return 0\&.;
2051                       default:
2052                         libmesh_error();
2053                       }
2054                   }
2055 
2056                 case 3: // d^2()/dxidzeta
2057                   {
2058                     Real den = (1\&. - zeta + eps)*(1\&. - zeta + eps);
2059 
2060                     switch (i)
2061                       {
2062                       case 0:
2063                       case 2:
2064                         return 0\&.25*eta/den;
2065                       case 1:
2066                       case 3:
2067                         return -0\&.25*eta/den;
2068                       case 4:
2069                         return 0\&.;
2070                       default:
2071                         libmesh_error();
2072                       }
2073                   }
2074 
2075                 case 4: // d^2()/detadzeta
2076                   {
2077                     Real den = (1\&. - zeta + eps)*(1\&. - zeta + eps);
2078 
2079                     switch (i)
2080                       {
2081                       case 0:
2082                       case 2:
2083                         return 0\&.25*xi/den;
2084                       case 1:
2085                       case 3:
2086                         return -0\&.25*xi/den;
2087                       case 4:
2088                         return 0\&.;
2089                       default:
2090                         libmesh_error();
2091                       }
2092                   }
2093 
2094                 case 5: // d^2()/dzeta^2
2095                   {
2096                     Real den = (1\&. - zeta + eps)*(1\&. - zeta + eps)*(1\&. - zeta + eps);
2097 
2098                     switch (i)
2099                       {
2100                       case 0:
2101                       case 2:
2102                         return 0\&.5*xi*eta/den;
2103                       case 1:
2104                       case 3:
2105                         return -0\&.5*xi*eta/den;
2106                       case 4:
2107                         return 0\&.;
2108                       default:
2109                         libmesh_error();
2110                       }
2111                   }
2112 
2113                 default:
2114                   {
2115                     // Unrecognized index
2116                     libmesh_error();
2117                   }
2118                 }
2119             }
2120 
2121             // Trilinear shape functions on HEX8s have nonzero mixed second derivatives
2122           case HEX8:
2123           case HEX20:
2124           case HEX27:
2125             {
2126               libmesh_assert_less (i, 8);
2127 
2128               // Compute hex shape functions as a tensor-product
2129               const Real xi   = p(0);
2130               const Real eta  = p(1);
2131               const Real zeta = p(2);
2132 
2133               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0};
2134               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1};
2135               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1};
2136 
2137               switch (j)
2138                 {
2139                   // All repeated second derivatives are zero on HEX8
2140                 case 0: // d^2()/dxi^2
2141                 case 2: // d^2()/deta^2
2142                 case 5: // d^2()/dzeta^2
2143                   {
2144                     return 0\&.;
2145                   }
2146 
2147                 case 1: // d^2()/dxideta
2148                   return (FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
2149                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta)*
2150                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i2[i], zeta));
2151 
2152                 case 3: // d^2()/dxidzeta
2153                   return (FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i0[i], 0, xi)*
2154                           FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i1[i], eta)*
2155                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i2[i], 0, zeta));
2156 
2157                 case 4: // d^2()/detadzeta
2158                   return (FE<1,LAGRANGE>::shape      (EDGE2, FIRST, i0[i], xi)*
2159                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i1[i], 0, eta)*
2160                           FE<1,LAGRANGE>::shape_deriv(EDGE2, FIRST, i2[i], 0, zeta));
2161 
2162                 default:
2163                   {
2164                     // Unrecognized index
2165                     libmesh_error();
2166                   }
2167                 }
2168               return 0\&.;
2169             }
2170 
2171           default:
2172             {
2173               libMesh::err << "ERROR: Unsupported 3D element type!: " << type << std::endl;
2174               libmesh_error();
2175             }
2176           }
2177 
2178       }
2179 
2180       // quadratic Lagrange shape functions
2181     case SECOND:
2182       {
2183         switch (type)
2184           {
2185 
2186             // serendipity hexahedral quadratic shape functions
2187           case HEX20:
2188             {
2189               libmesh_assert_less (i, 20);
2190 
2191               const Real xi   = p(0);
2192               const Real eta  = p(1);
2193               const Real zeta = p(2);
2194 
2195               // these functions are defined for (x,y,z) in [0,1]^3
2196               // so transform the locations
2197               const Real x = \&.5*(xi   + 1\&.);
2198               const Real y = \&.5*(eta  + 1\&.);
2199               const Real z = \&.5*(zeta + 1\&.);
2200 
2201               switch(j)
2202                 {
2203                 case 0: // d^2()/dxi^2
2204                   {
2205                     switch(i)
2206                       {
2207                       case 0:
2208                       case 1:
2209                         return (1\&. - y) * (1\&. - z);
2210                       case 2:
2211                       case 3:
2212                         return y * (1\&. - z);
2213                       case 4:
2214                       case 5:
2215                         return (1\&. - y) * z;
2216                       case 6:
2217                       case 7:
2218                         return y * z;
2219                       case 8:
2220                         return -2\&. * (1\&. - y) * (1\&. - z);
2221                       case 10:
2222                         return -2\&. * y * (1\&. - z);
2223                       case 16:
2224                         return -2\&. * (1\&. - y) * z;
2225                       case 18:
2226                         return -2\&. * y * z;
2227                       case 9:
2228                       case 11:
2229                       case 12:
2230                       case 13:
2231                       case 14:
2232                       case 15:
2233                       case 17:
2234                       case 19:
2235                         return 0;
2236                       default:
2237                         libmesh_error();
2238                       }
2239                   }
2240                 case 1: // d^2()/dxideta
2241                   {
2242                     switch(i)
2243                       {
2244                       case 0:
2245                         return (1\&.25 - x - y - \&.5*z) * (1\&. - z);
2246                       case 1:
2247                         return (-x + y + \&.5*z - \&.25) * (1\&. - z);
2248                       case 2:
2249                         return (x + y - \&.5*z - \&.75) * (1\&. - z);
2250                       case 3:
2251                         return (-y + x + \&.5*z - \&.25) * (1\&. - z);
2252                       case 4:
2253                         return -\&.25*z * (4\&.*x + 4\&.*y - 2\&.*z - 3);
2254                       case 5:
2255                         return -\&.25*z * (-4\&.*y + 4\&.*x + 2\&.*z - 1\&.);
2256                       case 6:
2257                         return \&.25*z * (-5 + 4\&.*x + 4\&.*y + 2\&.*z);
2258                       case 7:
2259                         return \&.25*z * (4\&.*x - 4\&.*y - 2\&.*z + 1\&.);
2260                       case 8:
2261                         return (-1\&. + 2\&.*x) * (1\&. - z);
2262                       case 9:
2263                         return (1\&. - 2\&.*y) * (1\&. - z);
2264                       case 10:
2265                         return (1\&. - 2\&.*x) * (1\&. - z);
2266                       case 11:
2267                         return (-1\&. + 2\&.*y) * (1\&. - z);
2268                       case 12:
2269                         return z * (1\&. - z);
2270                       case 13:
2271                         return -z * (1\&. - z);
2272                       case 14:
2273                         return z * (1\&. - z);
2274                       case 15:
2275                         return -z * (1\&. - z);
2276                       case 16:
2277                         return (-1\&. + 2\&.*x) * z;
2278                       case 17:
2279                         return (1\&. - 2\&.*y) * z;
2280                       case 18:
2281                         return (1\&. - 2\&.*x) * z;
2282                       case 19:
2283                         return (-1\&. + 2\&.*y) * z;
2284                       default:
2285                         libmesh_error();
2286                       }
2287                   }
2288                 case 2: // d^2()/deta^2
2289                   switch(i)
2290                     {
2291                     case 0:
2292                     case 3:
2293                       return (1\&. - x) * (1\&. - z);
2294                     case 1:
2295                     case 2:
2296                       return x * (1\&. - z);
2297                     case 4:
2298                     case 7:
2299                       return (1\&. - x) * z;
2300                     case 5:
2301                     case 6:
2302                       return x * z;
2303                     case 9:
2304                       return -2\&. * x * (1\&. - z);
2305                     case 11:
2306                       return -2\&. * (1\&. - x) * (1\&. - z);
2307                     case 17:
2308                       return -2\&. * x * z;
2309                     case 19:
2310                       return -2\&. * (1\&. - x) * z;
2311                     case 8:
2312                     case 10:
2313                     case 12:
2314                     case 13:
2315                     case 14:
2316                     case 15:
2317                     case 16:
2318                     case 18:
2319                       return 0\&.;
2320                     default:
2321                       libmesh_error();
2322                     }
2323                 case 3: // d^2()/dxidzeta
2324                   switch(i)
2325                     {
2326                     case 0:
2327                       return (1\&.25 - x - \&.5*y - z) * (1\&. - y);
2328                     case 1:
2329                       return (-x + \&.5*y + z - \&.25) * (1\&. - y);
2330                     case 2:
2331                       return -\&.25*y * (2\&.*y + 4\&.*x - 4\&.*z - 1\&.);
2332                     case 3:
2333                       return -\&.25*y * (-2\&.*y + 4\&.*x + 4\&.*z - 3);
2334                     case 4:
2335                       return (-z + x + \&.5*y - \&.25) * (1\&. - y);
2336                     case 5:
2337                       return (x - \&.5*y + z - \&.75) * (1\&. - y);
2338                     case 6:
2339                       return \&.25*y * (2\&.*y + 4\&.*x + 4\&.*z - 5);
2340                     case 7:
2341                       return \&.25*y * (-2\&.*y + 4\&.*x - 4\&.*z + 1\&.);
2342                     case 8:
2343                       return (-1\&. + 2\&.*x) * (1\&. - y);
2344                     case 9:
2345                       return -y * (1\&. - y);
2346                     case 10:
2347                       return (-1\&. + 2\&.*x) * y;
2348                     case 11:
2349                       return y * (1\&. - y);
2350                     case 12:
2351                       return (-1\&. + 2\&.*z) * (1\&. - y);
2352                     case 13:
2353                       return (1\&. - 2\&.*z) * (1\&. - y);
2354                     case 14:
2355                       return (1\&. - 2\&.*z) * y;
2356                     case 15:
2357                       return (-1\&. + 2\&.*z) * y;
2358                     case 16:
2359                       return (1\&. - 2\&.*x) * (1\&. - y);
2360                     case 17:
2361                       return y * (1\&. - y);
2362                     case 18:
2363                       return (1\&. - 2\&.*x) * y;
2364                     case 19:
2365                       return -y * (1\&. - y);
2366                     default:
2367                       libmesh_error();
2368                     }
2369                 case 4: // d^2()/detadzeta
2370                   switch(i)
2371                     {
2372                     case 0:
2373                       return (1\&.25 - \&.5*x - y - z) * (1\&. - x);
2374                     case 1:
2375                       return \&.25*x * (2\&.*x - 4\&.*y - 4\&.*z + 3\&.);
2376                     case 2:
2377                       return -\&.25*x * (2\&.*x + 4\&.*y - 4\&.*z - 1\&.);
2378                     case 3:
2379                       return (-y + \&.5*x + z - \&.25) * (1\&. - x);
2380                     case 4:
2381                       return (-z + \&.5*x + y - \&.25) * (1\&. - x);
2382                     case 5:
2383                       return -\&.25*x * (2\&.*x - 4\&.*y + 4\&.*z - 1\&.);
2384                     case 6:
2385                       return \&.25*x * (2\&.*x + 4\&.*y + 4\&.*z - 5);
2386                     case 7:
2387                       return (y - \&.5*x + z - \&.75) * (1\&. - x);
2388                     case 8:
2389                       return x * (1\&. - x);
2390                     case 9:
2391                       return (-1\&. + 2\&.*y) * x;
2392                     case 10:
2393                       return -x * (1\&. - x);
2394                     case 11:
2395                       return (-1\&. + 2\&.*y) * (1\&. - x);
2396                     case 12:
2397                       return (-1\&. + 2\&.*z) * (1\&. - x);
2398                     case 13:
2399                       return (-1\&. + 2\&.*z) * x;
2400                     case 14:
2401                       return (1\&. - 2\&.*z) * x;
2402                     case 15:
2403                       return (1\&. - 2\&.*z) * (1\&. - x);
2404                     case 16:
2405                       return -x * (1\&. - x);
2406                     case 17:
2407                       return (1\&. - 2\&.*y) * x;
2408                     case 18:
2409                       return x * (1\&. - x);
2410                     case 19:
2411                       return (1\&. - 2\&.*y) * (1\&. - x);
2412                     default:
2413                       libmesh_error();
2414                     }
2415                 case 5: // d^2()/dzeta^2
2416                   switch(i)
2417                     {
2418                     case 0:
2419                     case 4:
2420                       return (1\&. - x) * (1\&. - y);
2421                     case 1:
2422                     case 5:
2423                       return x * (1\&. - y);
2424                     case 2:
2425                     case 6:
2426                       return x * y;
2427                     case 3:
2428                     case 7:
2429                       return (1\&. - x) * y;
2430                     case 12:
2431                       return -2\&. * (1\&. - x) * (1\&. - y);
2432                     case 13:
2433                       return -2\&. * x * (1\&. - y);
2434                     case 14:
2435                       return -2\&. * x * y;
2436                     case 15:
2437                       return -2\&. * (1\&. - x) * y;
2438                     case 8:
2439                     case 9:
2440                     case 10:
2441                     case 11:
2442                     case 16:
2443                     case 17:
2444                     case 18:
2445                     case 19:
2446                       return 0\&.;
2447                     default:
2448                       libmesh_error();
2449                     }
2450                 default:
2451                   libmesh_error();
2452                 }
2453             }
2454 
2455             // triquadraic hexahedral shape funcions
2456           case HEX27:
2457             {
2458               libmesh_assert_less (i, 27);
2459 
2460               // Compute hex shape functions as a tensor-product
2461               const Real xi   = p(0);
2462               const Real eta  = p(1);
2463               const Real zeta = p(2);
2464 
2465               // The only way to make any sense of this
2466               // is to look at the mgflo/mg2/mgf documentation
2467               // and make the cut-out cube!
2468               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
2469               static const unsigned int i0[] = {0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 2, 2};
2470               static const unsigned int i1[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 2, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2, 2, 0, 2, 1, 2, 2, 2};
2471               static const unsigned int i2[] = {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 0, 2, 2, 2, 2, 1, 2};
2472 
2473               switch(j)
2474                 {
2475                   // d^2()/dxi^2
2476                 case 0:
2477                   return (FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, xi)*
2478                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
2479                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
2480 
2481                   // d^2()/dxideta
2482                 case 1:
2483                   return (FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
2484                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
2485                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
2486 
2487                   // d^2()/deta^2
2488                 case 2:
2489                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
2490                           FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i1[i], 0, eta)*
2491                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i2[i], zeta));
2492 
2493                   // d^2()/dxidzeta
2494                 case 3:
2495                   return (FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, xi)*
2496                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
2497                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
2498 
2499                   // d^2()/detadzeta
2500                 case 4:
2501                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
2502                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i1[i], 0, eta)*
2503                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i2[i], 0, zeta));
2504 
2505                   // d^2()/dzeta^2
2506                 case 5:
2507                   return (FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i0[i], xi)*
2508                           FE<1,LAGRANGE>::shape      (EDGE3, SECOND, i1[i], eta)*
2509                           FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i2[i], 0, zeta));
2510 
2511                 default:
2512                   {
2513                     libmesh_error();
2514                   }
2515                 }
2516             }
2517 
2518             // quadratic tetrahedral shape functions
2519           case TET10:
2520             {
2521               // The area coordinates are the same as used for the
2522               // shape() and shape_deriv() functions\&.
2523               // const Real zeta0 = 1\&. - zeta1 - zeta2 - zeta3;
2524               // const Real zeta1 = p(0);
2525               // const Real zeta2 = p(1);
2526               // const Real zeta3 = p(2);
2527               static const Real dzetadxi[4][3] =
2528                 {
2529                   {-1\&., -1\&., -1\&.},
2530                   {1\&.,   0\&.,  0\&.},
2531                   {0\&.,   1\&.,  0\&.},
2532                   {0\&.,   0\&.,  1\&.}
2533                 };
2534 
2535               // Convert from j -> (j,k) indices for independent variable
2536               // (0=xi, 1=eta, 2=zeta)
2537               static const unsigned short int independent_var_indices[6][2] =
2538                 {
2539                   {0, 0}, // d^2 phi / dxi^2
2540                   {0, 1}, // d^2 phi / dxi deta
2541                   {1, 1}, // d^2 phi / deta^2
2542                   {0, 2}, // d^2 phi / dxi dzeta
2543                   {1, 2}, // d^2 phi / deta dzeta
2544                   {2, 2}  // d^2 phi / dzeta^2
2545                 };
2546 
2547               // Convert from i -> zeta indices\&.  Each quadratic shape
2548               // function for the Tet10 depends on up to two of the zeta
2549               // area coordinate functions (see the shape() function above)\&.
2550               // This table just tells which two area coords it uses\&.
2551               static const unsigned short int zeta_indices[10][2] =
2552                 {
2553                   {0, 0},
2554                   {1, 1},
2555                   {2, 2},
2556                   {3, 3},
2557                   {0, 1},
2558                   {1, 2},
2559                   {2, 0},
2560                   {0, 3},
2561                   {1, 3},
2562                   {2, 3},
2563                 };
2564 
2565               // Look up the independent variable indices for this value of j\&.
2566               const unsigned int my_j = independent_var_indices[j][0];
2567               const unsigned int my_k = independent_var_indices[j][1];
2568 
2569               if (i<4)
2570                 {
2571                   return 4\&.*dzetadxi[i][my_j]*dzetadxi[i][my_k];
2572                 }
2573 
2574               else if (i<10)
2575                 {
2576                   const unsigned short int my_m = zeta_indices[i][0];
2577                   const unsigned short int my_n = zeta_indices[i][1];
2578 
2579                   return 4\&.*(dzetadxi[my_n][my_j]*dzetadxi[my_m][my_k] +
2580                              dzetadxi[my_m][my_j]*dzetadxi[my_n][my_k] );
2581                 }
2582               else
2583                 {
2584                   libMesh::err << "Invalid shape function index " << i << std::endl;
2585                   libmesh_error();
2586                 }
2587             }
2588 
2589 
2590 
2591             // "serendipity" prism
2592           case PRISM15:
2593             {
2594               libmesh_assert_less (i, 15);
2595 
2596               const Real xi   = p(0);
2597               const Real eta  = p(1);
2598               const Real zeta = p(2);
2599 
2600               switch (j)
2601                 {
2602                   // d^2()/dxi^2
2603                 case 0:
2604                   {
2605                     switch(i)
2606                       {
2607                       case 0:
2608                       case 1:
2609                         return 2\&.*(1\&. - zeta);
2610                       case 2:
2611                       case 5:
2612                       case 7:
2613                       case 8:
2614                       case 9:
2615                       case 10:
2616                       case 11:
2617                       case 13:
2618                       case 14:
2619                         return 0\&.;
2620                       case 3:
2621                       case 4:
2622                         return 2\&.*(1\&. + zeta);
2623                       case 6:
2624                         return 4\&.*(zeta - 1);
2625                       case 12:
2626                         return -4\&.*(1\&. + zeta);
2627                       default:
2628                         libmesh_error();
2629                       }
2630                   }
2631 
2632                   // d^2()/dxideta
2633                 case 1:
2634                   {
2635                     switch(i)
2636                       {
2637                       case 0:
2638                       case 7:
2639                         return 2\&.*(1\&. - zeta);
2640                       case 1:
2641                       case 2:
2642                       case 4:
2643                       case 5:
2644                       case 9:
2645                       case 10:
2646                       case 11:
2647                         return 0\&.;
2648                       case 3:
2649                       case 13:
2650                         return 2\&.*(1\&. + zeta);
2651                       case 6:
2652                       case 8:
2653                         return 2\&.*(zeta - 1\&.);
2654                       case 12:
2655                       case 14:
2656                         return -2\&.*(1\&. + zeta);
2657                       default:
2658                         libmesh_error();
2659                       }
2660                   }
2661 
2662                   // d^2()/deta^2
2663                 case 2:
2664                   {
2665                     switch(i)
2666                       {
2667                       case 0:
2668                       case 2:
2669                         return 2\&.*(1\&. - zeta);
2670                       case 1:
2671                       case 4:
2672                       case 6:
2673                       case 7:
2674                       case 9:
2675                       case 10:
2676                       case 11:
2677                       case 12:
2678                       case 13:
2679                         return 0\&.;
2680                       case 3:
2681                       case 5:
2682                         return 2\&.*(1\&. + zeta);
2683                       case 8:
2684                         return 4\&.*(zeta - 1\&.);
2685                       case 14:
2686                         return -4\&.*(1\&. + zeta);
2687                       default:
2688                         libmesh_error();
2689                       }
2690                   }
2691 
2692                   // d^2()/dxidzeta
2693                 case 3:
2694                   {
2695                     switch(i)
2696                       {
2697                       case 0:
2698                         return 1\&.5 - zeta - 2\&.*xi - 2\&.*eta;
2699                       case 1:
2700                         return 0\&.5 + zeta - 2\&.*xi;
2701                       case 2:
2702                       case 5:
2703                       case 11:
2704                         return 0\&.;
2705                       case 3:
2706                         return -1\&.5 - zeta + 2\&.*xi + 2\&.*eta;
2707                       case 4:
2708                         return -0\&.5 + zeta + 2\&.*xi;
2709                       case 6:
2710                         return 4\&.*xi + 2\&.*eta - 2\&.;
2711                       case 7:
2712                         return -2\&.*eta;
2713                       case 8:
2714                         return 2\&.*eta;
2715                       case 9:
2716                         return 2\&.*zeta;
2717                       case 10:
2718                         return -2\&.*zeta;
2719                       case 12:
2720                         return -4\&.*xi - 2\&.*eta + 2\&.;
2721                       case 13:
2722                         return 2\&.*eta;
2723                       case 14:
2724                         return -2\&.*eta;
2725                       default:
2726                         libmesh_error();
2727                       }
2728                   }
2729 
2730                   // d^2()/detadzeta
2731                 case 4:
2732                   {
2733                     switch(i)
2734                       {
2735                       case 0:
2736                         return 1\&.5 - zeta - 2\&.*xi - 2\&.*eta;
2737                       case 1:
2738                       case 4:
2739                       case 10:
2740                         return 0\&.;
2741                       case 2:
2742                         return \&.5 + zeta - 2\&.*eta;
2743                       case 3:
2744                         return -1\&.5 - zeta + 2\&.*xi + 2\&.*eta;
2745                       case 5:
2746                         return -\&.5 + zeta + 2\&.*eta;
2747                       case 6:
2748                         return 2\&.*xi;
2749                       case 7:
2750                         return -2\&.*xi;
2751                       case 8:
2752                         return 2\&.*xi + 4\&.*eta - 2\&.;
2753                       case 9:
2754                         return 2\&.*zeta;
2755                       case 11:
2756                         return -2\&.*zeta;
2757                       case 12:
2758                         return -2\&.*xi;
2759                       case 13:
2760                         return 2\&.*xi;
2761                       case 14:
2762                         return -2\&.*xi - 4\&.*eta + 2\&.;
2763                       default:
2764                         libmesh_error();
2765                       }
2766                   }
2767 
2768                   // d^2()/dzeta^2
2769                 case 5:
2770                   {
2771                     switch(i)
2772                       {
2773                       case 0:
2774                       case 3:
2775                         return 1\&. - xi - eta;
2776                       case 1:
2777                       case 4:
2778                         return xi;
2779                       case 2:
2780                       case 5:
2781                         return eta;
2782                       case 6:
2783                       case 7:
2784                       case 8:
2785                       case 12:
2786                       case 13:
2787                       case 14:
2788                         return 0\&.;
2789                       case 9:
2790                         return 2\&.*xi + 2\&.*eta - 2\&.;
2791                       case 10:
2792                         return -2\&.*xi;
2793                       case 11:
2794                         return -2\&.*eta;
2795                       default:
2796                         libmesh_error();
2797                       }
2798                   }
2799 
2800                 default:
2801                   libmesh_error();
2802                 }
2803             }
2804 
2805 
2806 
2807             // quadradic prism shape functions
2808           case PRISM18:
2809             {
2810               libmesh_assert_less (i, 18);
2811 
2812               // Compute prism shape functions as a tensor-product
2813               // of a triangle and an edge
2814 
2815               Point p2d(p(0),p(1));
2816               Point p1d(p(2));
2817 
2818               //                                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
2819               static const unsigned int i0[] = {0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 1, 1, 1, 2, 2, 2};
2820               static const unsigned int i1[] = {0, 1, 2, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 3, 4, 5};
2821 
2822               switch (j)
2823                 {
2824                   // d^2()/dxi^2
2825                 case 0:
2826                   return (FE<2,LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 0, p2d)*
2827                           FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
2828 
2829                   // d^2()/dxideta
2830                 case 1:
2831                   return (FE<2,LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 1, p2d)*
2832                           FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
2833 
2834                   // d^2()/deta^2
2835                 case 2:
2836                   return (FE<2,LAGRANGE>::shape_second_deriv(TRI6, SECOND, i1[i], 2, p2d)*
2837                           FE<1,LAGRANGE>::shape(EDGE3, SECOND, i0[i], p1d));
2838 
2839                   // d^2()/dxidzeta
2840                 case 3:
2841                   return (FE<2,LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 0, p2d)*
2842                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
2843 
2844                   // d^2()/detadzeta
2845                 case 4:
2846                   return (FE<2,LAGRANGE>::shape_deriv(TRI6,  SECOND, i1[i], 1, p2d)*
2847                           FE<1,LAGRANGE>::shape_deriv(EDGE3, SECOND, i0[i], 0, p1d));
2848 
2849                   // d^2()/dzeta^2
2850                 case 5:
2851                   return (FE<2,LAGRANGE>::shape(TRI6,  SECOND, i1[i], p2d)*
2852                           FE<1,LAGRANGE>::shape_second_deriv(EDGE3, SECOND, i0[i], 0, p1d));
2853                 }
2854             }
2855 
2856 
2857             // Quadratic shape functions, as defined in R\&. Graglia, "Higher order
2858             // bases on pyramidal elements", IEEE Trans Antennas and Propagation,
2859             // vol 47, no 5, May 1999\&.
2860           case PYRAMID14:
2861             {
2862               libmesh_assert_less (i, 14);
2863 
2864               const Real xi   = p(0);
2865               const Real eta  = p(1);
2866               const Real zeta = p(2);
2867               const Real eps  = 1\&.e-35;
2868 
2869               // The "normalized coordinates" defined by Graglia\&.  These are
2870               // the planes which define the faces of the pyramid\&.
2871               Real
2872                 p1 = 0\&.5*(1\&. - eta - zeta), // back
2873                 p2 = 0\&.5*(1\&. + xi  - zeta), // left
2874                 p3 = 0\&.5*(1\&. + eta - zeta), // front
2875                 p4 = 0\&.5*(1\&. - xi  - zeta); // right
2876 
2877               // Denominators are perturbed by epsilon to avoid
2878               // divide-by-zero issues\&.
2879               Real
2880                 den = (-1\&. + zeta + eps),
2881                 den2 = den*den,
2882                 den3 = den2*den,
2883                 den4 = den2*den2;
2884 
2885               // These terms are used in several of the derivatives
2886               Real
2887                 numer_mp = xi*eta - zeta + zeta*zeta,
2888                 numer_pm = xi*eta + zeta - zeta*zeta;
2889 
2890               switch (j)
2891                 {
2892                 case 0: // d^2()/dxi^2
2893                   {
2894                     switch(i)
2895                       {
2896                       case 0:
2897                       case 1:
2898                         return -p1*eta/den2;
2899                       case 2:
2900                       case 3:
2901                         return p3*eta/den2;
2902                       case 4:
2903                       case 9:
2904                       case 10:
2905                       case 11:
2906                       case 12:
2907                         return 0\&.;
2908                       case 5:
2909                         return 2\&.*p1*eta/den2;
2910                       case 6:
2911                       case 8:
2912                         return 4\&.*p1*p3/den2;
2913                       case 7:
2914                         return -2\&.*p3*eta/den2;
2915                       case 13:
2916                         return -8\&.*p1*p3/den2;
2917                       default:
2918                         libmesh_error();
2919                       }
2920                   }
2921 
2922                 case 1: // d^2()/dxideta
2923                   {
2924                     switch(i)
2925                       {
2926                       case 0:
2927                         return 0\&.25*numer_mp/den2
2928                           - 0\&.5*p1*xi/den2
2929                           - 0\&.5*p4*eta/den2
2930                           + p4*p1/den2;
2931 
2932                       case 1:
2933                         return 0\&.25*numer_pm/den2
2934                           - 0\&.5*p1*xi/den2
2935                           + 0\&.5*p2*eta/den2
2936                           - p1*p2/den2;
2937 
2938                       case 2:
2939                         return 0\&.25*numer_mp/den2
2940                           + 0\&.5*p3*xi/den2
2941                           + 0\&.5*p2*eta/den2
2942                           + p2*p3/den2;
2943 
2944                       case 3:
2945                         return 0\&.25*numer_pm/den2
2946                           + 0\&.5*p3*xi/den2
2947                           - 0\&.5*p4*eta/den2
2948                           - p3*p4/den2;
2949 
2950                       case 4:
2951                         return 0\&.;
2952 
2953                       case 5:
2954                         return p4*eta/den2
2955                           - 2\&.*p4*p1/den2
2956                           - p2*eta/den2
2957                           + 2\&.*p1*p2/den2;
2958 
2959                       case 6:
2960                         return -p3*xi/den2
2961                           + p1*xi/den2
2962                           - 2\&.*p2*p3/den2
2963                           + 2\&.*p1*p2/den2;
2964 
2965                       case 7:
2966                         return p4*eta/den2
2967                           + 2\&.*p3*p4/den2
2968                           - p2*eta/den2
2969                           - 2\&.*p2*p3/den2;
2970 
2971                       case 8:
2972                         return -p3*xi/den2
2973                           + p1*xi/den2
2974                           - 2\&.*p4*p1/den2
2975                           + 2\&.*p3*p4/den2;
2976 
2977                       case 9:
2978                       case 11:
2979                         return -zeta/den;
2980 
2981                       case 10:
2982                       case 12:
2983                         return zeta/den;
2984 
2985                       case 13:
2986                         return 4\&.*p4*p1/den2
2987                           - 4\&.*p3*p4/den2
2988                           + 4\&.*p2*p3/den2
2989                           - 4\&.*p1*p2/den2;
2990 
2991                       default:
2992                         libmesh_error();
2993                       }
2994                   }
2995 
2996 
2997                 case 2: // d^2()/deta^2
2998                   {
2999                     switch(i)
3000                       {
3001                       case 0:
3002                       case 3:
3003                         return -p4*xi/den2;
3004                       case 1:
3005                       case 2:
3006                         return p2*xi/den2;
3007                       case 4:
3008                       case 9:
3009                       case 10:
3010                       case 11:
3011                       case 12:
3012                         return 0\&.;
3013                       case 5:
3014                       case 7:
3015                         return 4\&.*p2*p4/den2;
3016                       case 6:
3017                         return -2\&.*p2*xi/den2;
3018                       case 8:
3019                         return 2\&.*p4*xi/den2;
3020                       case 13:
3021                         return -8\&.*p2*p4/den2;
3022                       default:
3023                         libmesh_error();
3024                       }
3025                   }
3026 
3027 
3028                 case 3: // d^2()/dxidzeta
3029                   {
3030                     switch(i)
3031                       {
3032                       case 0:
3033                         return 0\&.25*numer_mp/den2
3034                           - 0\&.5*p1*(2\&.*zeta - 1\&.)/den2
3035                           + p1*numer_mp/den3
3036                           - 0\&.5*p1*eta/den2
3037                           - 0\&.5*p4*eta/den2
3038                           - 2\&.*p4*p1*eta/den3;
3039 
3040                       case 1:
3041                         return 0\&.25*numer_pm/den2
3042                           - 0\&.5*p1*(1 - 2\&.*zeta)/den2
3043                           + p1*numer_pm/den3
3044                           + 0\&.5*p2*eta/den2
3045                           + 0\&.5*p1*eta/den2
3046                           + 2\&.*p1*p2*eta/den3;
3047 
3048                       case 2:
3049                         return -0\&.25*numer_mp/den2
3050                           + 0\&.5*p3*(2\&.*zeta - 1\&.)/den2
3051                           - p3*numer_mp/den3
3052                           - 0\&.5*p3*eta/den2
3053                           - 0\&.5*p2*eta/den2
3054                           - 2\&.*p2*p3*eta/den3;
3055 
3056                       case 3:
3057                         return -0\&.25*numer_pm/den2
3058                           + 0\&.5*p3*(1 - 2\&.*zeta)/den2
3059                           - p3*numer_pm/den3
3060                           + 0\&.5*p4*eta/den2
3061                           + 0\&.5*p3*eta/den2
3062                           + 2\&.*p3*p4*eta/den3;
3063 
3064                       case 4:
3065                         return 0\&.;
3066 
3067                       case 5:
3068                         return p4*eta/den2
3069                           + 4\&.*p4*p1*eta/den3
3070                           - p2*eta/den2
3071                           - 4\&.*p1*p2*eta/den3;
3072 
3073                       case 6:
3074                         return -p3*xi/den2
3075                           - p1*xi/den2
3076                           - 4\&.*p1*p3*xi/den3
3077                           - 2\&.*p2*p3/den2
3078                           - 2\&.*p1*p3/den2
3079                           - 2\&.*p1*p2/den2
3080                           - 8\&.*p1*p2*p3/den3;
3081 
3082                       case 7:
3083                         return -p4*eta/den2
3084                           - 4\&.*p3*p4*eta/den3
3085                           + p2*eta/den2
3086                           + 4\&.*p2*p3*eta/den3;
3087 
3088                       case 8:
3089                         return -p3*xi/den2
3090                           - p1*xi/den2
3091                           - 4\&.*p1*p3*xi/den3
3092                           + 2\&.*p4*p1/den2
3093                           + 2\&.*p1*p3/den2
3094                           + 2\&.*p3*p4/den2
3095                           + 8\&.*p3*p4*p1/den3;
3096 
3097                       case 9:
3098                         return -zeta/den
3099                           + 2\&.*p1/den
3100                           - 2\&.*p1*zeta/den2;
3101 
3102                       case 10:
3103                         return zeta/den
3104                           - 2\&.*p1/den
3105                           + 2\&.*p1*zeta/den2;
3106 
3107                       case 11:
3108                         return zeta/den
3109                           - 2\&.*p3/den
3110                           + 2\&.*p3*zeta/den2;
3111 
3112                       case 12:
3113                         return -zeta/den
3114                           + 2\&.*p3/den
3115                           - 2\&.*p3*zeta/den2;
3116 
3117                       case 13:
3118                         return -4\&.*p4*p1/den2
3119                           - 4\&.*p3*p4/den2
3120                           - 16\&.*p3*p4*p1/den3
3121                           + 4\&.*p2*p3/den2
3122                           + 4\&.*p1*p2/den2
3123                           + 16\&.*p1*p2*p3/den3;
3124 
3125                       default:
3126                         libmesh_error();
3127                       }
3128                   }
3129 
3130                 case 4: // d^2()/detadzeta
3131                   {
3132                     switch(i)
3133                       {
3134                       case 0:
3135                         return 0\&.25*numer_mp/den2
3136                           - 0\&.5*p4*(2\&.*zeta - 1\&.)/den2
3137                           + p4*numer_mp/den3
3138                           - 0\&.5*p1*xi/den2
3139                           - 0\&.5*p4*xi/den2
3140                           - 2\&.*p4*p1*xi/den3;
3141 
3142                       case 1:
3143                         return -0\&.25*numer_pm/den2
3144                           + 0\&.5*p2*(1\&. - 2\&.*zeta)/den2
3145                           - p2*numer_pm/den3
3146                           + 0\&.5*p2*xi/den2
3147                           + 0\&.5*p1*xi/den2
3148                           + 2\&.*p1*p2*xi/den3;
3149 
3150                       case 2:
3151                         return -0\&.25*numer_mp/den2
3152                           + 0\&.5*p2*(2\&.*zeta - 1\&.)/den2
3153                           - p2*numer_mp/den3
3154                           - 0\&.5*p3*xi/den2
3155                           - 0\&.5*p2*xi/den2
3156                           - 2\&.*p2*p3*xi/den3;
3157 
3158                       case 3:
3159                         return 0\&.25*numer_pm/den2
3160                           - 0\&.5*p4*(1\&. - 2\&.*zeta)/den2
3161                           + p4*numer_pm/den3
3162                           + 0\&.5*p4*xi/den2
3163                           + 0\&.5*p3*xi/den2
3164                           + 2\&.*p3*p4*xi/den3;
3165 
3166                       case 4:
3167                         return 0\&.;
3168 
3169                       case 5:
3170                         return -p4*eta/den2
3171                           - p2*eta/den2
3172                           - 4\&.*p2*p4*eta/den3
3173                           + 2\&.*p4*p1/den2
3174                           + 2\&.*p2*p4/den2
3175                           + 2\&.*p1*p2/den2
3176                           + 8\&.*p2*p1*p4/den3;
3177 
3178                       case 6:
3179                         return p3*xi/den2
3180                           + 4\&.*p2*p3*xi/den3
3181                           - p1*xi/den2
3182                           - 4\&.*p1*p2*xi/den3;
3183 
3184                       case 7:
3185                         return -p4*eta/den2
3186                           - p2*eta/den2
3187                           - 4\&.*p2*p4*eta/den3
3188                           - 2\&.*p3*p4/den2
3189                           - 2\&.*p2*p4/den2
3190                           - 2\&.*p2*p3/den2
3191                           - 8\&.*p2*p3*p4/den3;
3192 
3193                       case 8:
3194                         return p1*xi/den2
3195                           + 4\&.*p4*p1*xi/den3
3196                           - p3*xi/den2
3197                           - 4\&.*p3*p4*xi/den3;
3198 
3199                       case 9:
3200                         return -zeta/den
3201                           + 2\&.*p4/den
3202                           - 2\&.*p4*zeta/den2;
3203 
3204                       case 10:
3205                         return -zeta/den
3206                           + 2\&.*p2/den
3207                           - 2\&.*p2*zeta/den2;
3208 
3209                       case 11:
3210                         return zeta/den
3211                           - 2\&.*p2/den
3212                           + 2\&.*p2*zeta/den2;
3213 
3214                       case 12:
3215                         return zeta/den
3216                           - 2\&.*p4/den
3217                           + 2\&.*p4*zeta/den2;
3218 
3219                       case 13:
3220                         return 4\&.*p3*p4/den2
3221                           + 4\&.*p2*p3/den2
3222                           + 16\&.*p2*p3*p4/den3
3223                           - 4\&.*p4*p1/den2
3224                           - 4\&.*p1*p2/den2
3225                           - 16\&.*p2*p1*p4/den3;
3226 
3227                       default:
3228                         libmesh_error();
3229                       }
3230                   }
3231 
3232                 case 5: // d^2()/dzeta^2
3233                   {
3234                     switch(i)
3235                       {
3236                       case 0:
3237                         return 0\&.5*numer_mp/den2
3238                           - p1*(2\&.*zeta - 1\&.)/den2
3239                           + 2\&.*p1*numer_mp/den3
3240                           - p4*(2\&.*zeta - 1\&.)/den2
3241                           + 2\&.*p4*numer_mp/den3
3242                           + 2\&.*p4*p1/den2
3243                           - 4\&.*p4*p1*(2\&.*zeta - 1\&.)/den3
3244                           + 6\&.*p4*p1*numer_mp/den4;
3245 
3246                       case 1:
3247                         return -0\&.5*numer_pm/den2
3248                           + p2*(1 - 2\&.*zeta)/den2
3249                           - 2\&.*p2*numer_pm/den3
3250                           + p1*(1 - 2\&.*zeta)/den2
3251                           - 2\&.*p1*numer_pm/den3
3252                           + 2\&.*p1*p2/den2
3253                           + 4\&.*p1*p2*(1 - 2\&.*zeta)/den3
3254                           - 6\&.*p1*p2*numer_pm/den4;
3255 
3256                       case 2:
3257                         return 0\&.5*numer_mp/den2
3258                           - p3*(2\&.*zeta - 1\&.)/den2
3259                           + 2\&.*p3*numer_mp/den3
3260                           - p2*(2\&.*zeta - 1\&.)/den2
3261                           + 2\&.*p2*numer_mp/den3
3262                           + 2\&.*p2*p3/den2
3263                           - 4\&.*p2*p3*(2\&.*zeta - 1\&.)/den3
3264                           + 6\&.*p2*p3*numer_mp/den4;
3265 
3266                       case 3:
3267                         return -0\&.5*numer_pm/den2
3268                           + p4*(1 - 2\&.*zeta)/den2
3269                           - 2\&.*p4*numer_pm/den3
3270                           + p3*(1 - 2\&.*zeta)/den2
3271                           - 2\&.*p3*numer_pm/den3
3272                           + 2\&.*p3*p4/den2
3273                           + 4\&.*p3*p4*(1 - 2\&.*zeta)/den3
3274                           - 6\&.*p3*p4*numer_pm/den4;
3275 
3276                       case 4:
3277                         return 4\&.;
3278 
3279                       case 5:
3280                         return -2\&.*p1*eta/den2
3281                           - 2\&.*p4*eta/den2
3282                           - 8\&.*p4*p1*eta/den3
3283                           - 2\&.*p2*eta/den2
3284                           - 8\&.*p2*p4*eta/den3
3285                           - 8\&.*p1*p2*eta/den3
3286                           - 24\&.*p2*p1*p4*eta/den4;
3287 
3288                       case 6:
3289                         return 2\&.*p3*xi/den2
3290                           + 2\&.*p2*xi/den2
3291                           + 8\&.*p2*p3*xi/den3
3292                           + 2\&.*p1*xi/den2
3293                           + 8\&.*p1*p3*xi/den3
3294                           + 8\&.*p1*p2*xi/den3
3295                           + 24\&.*p1*p2*p3*xi/den4;
3296 
3297                       case 7:
3298                         return 2\&.*p4*eta/den2
3299                           + 2\&.*p3*eta/den2
3300                           + 8\&.*p3*p4*eta/den3
3301                           + 2\&.*p2*eta/den2
3302                           + 8\&.*p2*p4*eta/den3
3303                           + 8\&.*p2*p3*eta/den3
3304                           + 24\&.*p2*p3*p4*eta/den4;
3305 
3306                       case 8:
3307                         return -2\&.*p1*xi/den2
3308                           - 2\&.*p4*xi/den2
3309                           - 8\&.*p4*p1*xi/den3
3310                           - 2\&.*p3*xi/den2
3311                           - 8\&.*p1*p3*xi/den3
3312                           - 8\&.*p3*p4*xi/den3
3313                           - 24\&.*p3*p4*p1*xi/den4;
3314 
3315                       case 9:
3316                         return -2\&.*zeta/den
3317                           + 4\&.*p4/den
3318                           - 4\&.*p4*zeta/den2
3319                           + 4\&.*p1/den
3320                           - 4\&.*p1*zeta/den2
3321                           + 8\&.*p4*p1/den2
3322                           - 8\&.*p1*p4*zeta/den3;
3323 
3324                       case 10:
3325                         return -2\&.*zeta/den
3326                           + 4\&.*p1/den
3327                           - 4\&.*p1*zeta/den2
3328                           + 4\&.*p2/den
3329                           - 4\&.*p2*zeta/den2
3330                           + 8\&.*p1*p2/den2
3331                           - 8\&.*p2*p1*zeta/den3;
3332 
3333                       case 11:
3334                         return -2\&.*zeta/den
3335                           + 4\&.*p2/den
3336                           - 4\&.*p2*zeta/den2
3337                           + 4\&.*p3/den
3338                           - 4\&.*p3*zeta/den2
3339                           + 8\&.*p2*p3/den2
3340                           - 8\&.*p3*p2*zeta/den3;
3341 
3342                       case 12:
3343                         return -2\&.*zeta/den
3344                           + 4\&.*p3/den
3345                           - 4\&.*p3*zeta/den2
3346                           + 4\&.*p4/den
3347                           - 4\&.*p4*zeta/den2
3348                           + 8\&.*p3*p4/den2
3349                           - 8\&.*p4*p3*zeta/den3;
3350 
3351                       case 13:
3352                         return 8\&.*p3*p4/den2
3353                           + 8\&.*p2*p4/den2
3354                           + 8\&.*p2*p3/den2
3355                           + 32\&.*p2*p3*p4/den3
3356                           + 8\&.*p4*p1/den2
3357                           + 8\&.*p1*p3/den2
3358                           + 32\&.*p3*p4*p1/den3
3359                           + 8\&.*p1*p2/den2
3360                           + 32\&.*p2*p1*p4/den3
3361                           + 32\&.*p1*p2*p3/den3
3362                           + 96\&.*p1*p2*p3*p4/den4;
3363 
3364                       default:
3365                         libmesh_error();
3366                       }
3367                   }
3368 
3369                 default:
3370                   {
3371                     // Unrecognized index
3372                     libmesh_error();
3373                   }
3374                 }
3375             }
3376 
3377             // G\&. Bedrosian, "Shape functions and integration formulas for
3378             // three-dimensional finite element analysis", Int\&. J\&. Numerical
3379             // Methods Engineering, vol 35, p\&. 95-108, 1992\&.
3380           case PYRAMID13:
3381             {
3382               libmesh_assert_less (i, 13);
3383 
3384               const Real xi   = p(0);
3385               const Real eta  = p(1);
3386               const Real zeta = p(2);
3387               const Real eps  = 1\&.e-35;
3388 
3389               // Denominators are perturbed by epsilon to avoid
3390               // divide-by-zero issues\&.
3391               Real
3392                 den = (-1\&. + zeta + eps),
3393                 den2 = den*den,
3394                 den3 = den2*den,
3395                 xi2 = xi*xi,
3396                 eta2 = eta*eta,
3397                 zeta2 = zeta*zeta,
3398                 zeta3 = zeta2*zeta;
3399 
3400               switch (j)
3401                 {
3402                 case 0: // d^2()/dxi^2
3403                   {
3404                     switch(i)
3405                       {
3406                       case 0:
3407                       case 1:
3408                         return 0\&.5*(-1\&. + zeta + eta)/den;
3409 
3410                       case 2:
3411                       case 3:
3412                         return 0\&.5*(-1\&. + zeta - eta)/den;
3413 
3414                       case 4:
3415                       case 6:
3416                       case 8:
3417                       case 9:
3418                       case 10:
3419                       case 11:
3420                       case 12:
3421                         return 0\&.;
3422 
3423                       case 5:
3424                         return (1\&. - eta - zeta)/den;
3425 
3426                       case 7:
3427                         return (1\&. + eta - zeta)/den;
3428 
3429                       default:
3430                         libmesh_error();
3431                       }
3432                   }
3433 
3434                 case 1: // d^2()/dxideta
3435                   {
3436                     switch(i)
3437                       {
3438                       case 0:
3439                         return  0\&.25*(-1\&. + 2\&.*zeta + 2\&.*xi + 2\&.*eta)/den;
3440 
3441                       case 1:
3442                         return -0\&.25*(-1\&. + 2\&.*zeta - 2\&.*xi + 2\&.*eta)/den;
3443 
3444                       case 2:
3445                         return -0\&.25*(1\&. - 2\&.*zeta + 2\&.*xi + 2\&.*eta)/den;
3446 
3447                       case 3:
3448                         return  0\&.25*(1\&. - 2\&.*zeta - 2\&.*xi + 2\&.*eta)/den;
3449 
3450                       case 4:
3451                         return 0\&.;
3452 
3453                       case 5:
3454                         return -xi/den;
3455 
3456                       case 6:
3457                         return eta/den;
3458 
3459                       case 7:
3460                         return xi/den;
3461 
3462                       case 8:
3463                         return -eta/den;
3464 
3465                       case 9:
3466                         return -zeta/den;
3467 
3468                       case 10:
3469                         return zeta/den;
3470 
3471                       case 11:
3472                         return -zeta/den;
3473 
3474                       case 12:
3475                         return zeta/den;
3476 
3477                       default:
3478                         libmesh_error();
3479                       }
3480                   }
3481 
3482 
3483                 case 2: // d^2()/deta^2
3484                   {
3485                     switch(i)
3486                       {
3487                       case 0:
3488                       case 3:
3489                         return 0\&.5*(-1\&. + zeta + xi)/den;
3490 
3491                       case 1:
3492                       case 2:
3493                         return 0\&.5*(-1\&. + zeta - xi)/den;
3494 
3495                       case 4:
3496                       case 5:
3497                       case 7:
3498                       case 9:
3499                       case 10:
3500                       case 11:
3501                       case 12:
3502                         return 0\&.;
3503 
3504                       case 6:
3505                         return (1\&. + xi - zeta)/den;
3506 
3507                       case 8:
3508                         return (1\&. - xi - zeta)/den;
3509 
3510                       default:
3511                         libmesh_error();
3512                       }
3513                   }
3514 
3515 
3516                 case 3: // d^2()/dxidzeta
3517                   {
3518                     switch(i)
3519                       {
3520                       case 0:
3521                         return -0\&.25*(-1\&. + 2\&.*zeta - zeta2 + eta + 2\&.*eta*xi + eta2)/den2;
3522 
3523                       case 1:
3524                         return 0\&.25*(-1\&. + 2\&.*zeta - zeta2 + eta - 2\&.*eta*xi + eta2)/den2;
3525 
3526                       case 2:
3527                         return 0\&.25*(-1\&. + 2\&.*zeta - zeta2 - eta + 2\&.*eta*xi + eta2)/den2;
3528 
3529                       case 3:
3530                         return -0\&.25*(-1\&. + 2\&.*zeta - zeta2 - eta - 2\&.*eta*xi + eta2)/den2;
3531 
3532                       case 4:
3533                         return 0\&.;
3534 
3535                       case 5:
3536                         return eta*xi/den2;
3537 
3538                       case 6:
3539                         return -0\&.5*(1\&. + zeta2 + eta2 - 2\&.*zeta)/den2;
3540 
3541                       case 7:
3542                         return -eta*xi/den2;
3543 
3544                       case 8:
3545                         return 0\&.5*(1\&. + zeta2 + eta2 - 2\&.*zeta)/den2;
3546 
3547                       case 9:
3548                         return (-1\&. - zeta2 + eta + 2\&.*zeta)/den2;
3549 
3550                       case 10:
3551                         return -(-1\&. - zeta2 + eta + 2\&.*zeta)/den2;
3552 
3553                       case 11:
3554                         return (1\&. + zeta2 + eta - 2\&.*zeta)/den2;
3555 
3556                       case 12:
3557                         return -(1\&. + zeta2 + eta - 2\&.*zeta)/den2;
3558 
3559                       default:
3560                         libmesh_error();
3561                       }
3562                   }
3563 
3564                 case 4: // d^2()/detadzeta
3565                   {
3566                     switch(i)
3567                       {
3568                       case 0:
3569                         return -0\&.25*(-1\&. + 2\&.*zeta - zeta2 + xi + 2\&.*eta*xi + xi2)/den2;
3570 
3571                       case 1:
3572                         return 0\&.25*(1\&. - 2\&.*zeta + zeta2 + xi + 2\&.*eta*xi - xi2)/den2;
3573 
3574                       case 2:
3575                         return 0\&.25*(-1\&. + 2\&.*zeta - zeta2 - xi + 2\&.*eta*xi + xi2)/den2;
3576 
3577                       case 3:
3578                         return -0\&.25*(1\&. - 2\&.*zeta + zeta2 - xi + 2\&.*eta*xi - xi2)/den2;
3579 
3580                       case 4:
3581                         return 0\&.;
3582 
3583                       case 5:
3584                         return 0\&.5*(1\&. + xi2 + zeta2 - 2\&.*zeta)/den2;
3585 
3586                       case 6:
3587                         return -eta*xi/den2;
3588 
3589                       case 7:
3590                         return -0\&.5*(1\&. + xi2 + zeta2 - 2\&.*zeta)/den2;
3591 
3592                       case 8:
3593                         return eta*xi/den2;
3594 
3595                       case 9:
3596                         return (-1\&. - zeta2 + xi + 2\&.*zeta)/den2;
3597 
3598                       case 10:
3599                         return -(1\&. + zeta2 + xi - 2\&.*zeta)/den2;
3600 
3601                       case 11:
3602                         return (1\&. + zeta2 + xi - 2\&.*zeta)/den2;
3603 
3604                       case 12:
3605                         return -(-1\&. - zeta2 + xi + 2\&.*zeta)/den2;
3606 
3607                       default:
3608                         libmesh_error();
3609                       }
3610                   }
3611 
3612                 case 5: // d^2()/dzeta^2
3613                   {
3614                     switch(i)
3615                       {
3616                       case 0:
3617                         return 0\&.5*(xi + eta + 1\&.)*eta*xi/den3;
3618 
3619                       case 1:
3620                         return -0\&.5*(eta - xi + 1\&.)*eta*xi/den3;
3621 
3622                       case 2:
3623                         return -0\&.5*(xi + eta - 1\&.)*eta*xi/den3;
3624 
3625                       case 3:
3626                         return 0\&.5*(eta - xi - 1\&.)*eta*xi/den3;
3627 
3628                       case 4:
3629                         return 4\&.;
3630 
3631                       case 5:
3632                         return -(1\&. - 3\&.*zeta + 3\&.*zeta2 - zeta3 + eta*xi2)/den3;
3633 
3634                       case 6:
3635                         return (-1\&. + 3\&.*zeta - 3\&.*zeta2 + zeta3 + eta2*xi)/den3;
3636 
3637                       case 7:
3638                         return (-1\&. + 3\&.*zeta - 3\&.*zeta2 + zeta3 + eta*xi2)/den3;
3639 
3640                       case 8:
3641                         return -(1\&. - 3\&.*zeta + 3\&.*zeta2 - zeta3 + eta2*xi)/den3;
3642 
3643                       case 9:
3644                         return -2\&.*(-1\&. + 3\&.*zeta - 3\&.*zeta2 + zeta3 + eta*xi)/den3;
3645 
3646                       case 10:
3647                         return 2\&.*(1\&. - 3\&.*zeta + 3\&.*zeta2 - zeta3 + eta*xi)/den3;
3648 
3649                       case 11:
3650                         return -2\&.*(-1\&. + 3\&.*zeta - 3\&.*zeta2 + zeta3 + eta*xi)/den3;
3651 
3652                       case 12:
3653                         return 2\&.*(1\&. - 3\&.*zeta + 3\&.*zeta2 - zeta3 + eta*xi)/den3;
3654 
3655                       default:
3656                         libmesh_error();
3657                       }
3658                   }
3659 
3660                 default:
3661                   {
3662                     // Unrecognized index
3663                     libmesh_error();
3664                   }
3665                 }
3666             }
3667 
3668           default:
3669             {
3670               libMesh::err << "ERROR: Unsupported 3D element type!: " << type
3671                            << std::endl;
3672               libmesh_error();
3673             }
3674           }
3675       }
3676 
3677 
3678       // unsupported order
3679     default:
3680       {
3681         libMesh::err << "ERROR: Unsupported 3D FE order!: " << order
3682                      << std::endl;
3683         libmesh_error();
3684       }
3685     }
3686 
3687 #endif
3688 
3689   libmesh_error();
3690   return 0\&.;
3691 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElemType\fP, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 2984 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
2989 {
2990   static bool warning_given = false;
2991 
2992   if (!warning_given)
2993     libMesh::err << "Second derivatives for Bernstein elements "
2994                  << "are not yet implemented!"
2995                  << std::endl;
2996 
2997   warning_given = true;
2998   return 0\&.;
2999 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shape_second_deriv (const \fBElem\fP *, const \fBOrder\fP, const unsignedint, const unsignedint, const \fBPoint\fP &)"

.PP
Definition at line 3004 of file fe_bernstein_shape_3D\&.C\&.
.PP
References libMesh::err\&.
.PP
.nf
3009 {
3010   static bool warning_given = false;
3011 
3012   if (!warning_given)
3013     libMesh::err << "Second derivatives for Bernstein elements "
3014                  << "are not yet implemented!"
3015                  << std::endl;
3016 
3017   warning_given = true;
3018   return 0\&.;
3019 }
.fi
.SS "template<> \fBReal\fP \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPorder, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)"

.PP
Definition at line 3696 of file fe_lagrange_shape_3D\&.C\&.
.PP
References libMesh::libmesh_assert(), libMesh::Elem::p_level(), libMesh::FE< Dim, T >::shape_second_deriv(), and libMesh::Elem::type()\&.
.PP
.nf
3701 {
3702   libmesh_assert(elem);
3703 
3704   // call the orientation-independent shape function derivatives
3705   return FE<3,LAGRANGE>::shape_second_deriv(elem->type(), static_cast<Order>(order + elem->p_level()), i, j, p);
3706 }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBSCALAR\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 137 of file fe_scalar\&.C\&.
.PP
.nf
137 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBSCALAR\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 138 of file fe_scalar\&.C\&.
.PP
.nf
138 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSCALAR\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 139 of file fe_scalar\&.C\&.
.PP
.nf
139 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBSCALAR\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 140 of file fe_scalar\&.C\&.
.PP
.nf
140 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBL2_HIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 218 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
218 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBL2_HIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 219 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
219 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBL2_HIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 220 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
220 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBL2_HIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 221 of file fe_l2_hierarchic\&.C\&.
.PP
.nf
221 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBCLOUGH\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 325 of file fe_clough\&.C\&.
.PP
.nf
325 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBCLOUGH\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 326 of file fe_clough\&.C\&.
.PP
.nf
326 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBCLOUGH\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 327 of file fe_clough\&.C\&.
.PP
.nf
327 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBCLOUGH\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 328 of file fe_clough\&.C\&.
.PP
.nf
328 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBHERMITE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 354 of file fe_hermite\&.C\&.
.PP
.nf
354 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBHERMITE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 355 of file fe_hermite\&.C\&.
.PP
.nf
355 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBHERMITE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 356 of file fe_hermite\&.C\&.
.PP
.nf
356 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBHERMITE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 357 of file fe_hermite\&.C\&.
.PP
.nf
357 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBHIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 380 of file fe_hierarchic\&.C\&.
.PP
.nf
380 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBHIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 381 of file fe_hierarchic\&.C\&.
.PP
.nf
381 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBHIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 382 of file fe_hierarchic\&.C\&.
.PP
.nf
382 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBHIERARCHIC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 383 of file fe_hierarchic\&.C\&.
.PP
.nf
383 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBMONOMIAL\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 399 of file fe_monomial\&.C\&.
.PP
.nf
399 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBMONOMIAL\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 400 of file fe_monomial\&.C\&.
.PP
.nf
400 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBMONOMIAL\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 401 of file fe_monomial\&.C\&.
.PP
.nf
401 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBMONOMIAL\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 402 of file fe_monomial\&.C\&.
.PP
.nf
402 { return false; }
.fi
.SS "template<unsigned int Dim, FEFamily T> virtual bool \fBlibMesh::FE\fP< Dim, T >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBBERNSTEIN\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 450 of file fe_bernstein\&.C\&.
.PP
.nf
450 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBBERNSTEIN\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 451 of file fe_bernstein\&.C\&.
.PP
.nf
451 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBBERNSTEIN\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 452 of file fe_bernstein\&.C\&.
.PP
.nf
452 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBBERNSTEIN\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 453 of file fe_bernstein\&.C\&.
.PP
.nf
453 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBL2_LAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 476 of file fe_l2_lagrange\&.C\&.
.PP
.nf
476 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBL2_LAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 477 of file fe_l2_lagrange\&.C\&.
.PP
.nf
477 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBL2_LAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 478 of file fe_l2_lagrange\&.C\&.
.PP
.nf
478 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBL2_LAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 479 of file fe_l2_lagrange\&.C\&.
.PP
.nf
479 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBNEDELEC_ONE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 558 of file fe_nedelec_one\&.C\&.
.PP
.nf
558 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBNEDELEC_ONE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 559 of file fe_nedelec_one\&.C\&.
.PP
.nf
559 { NEDELEC_LOW_D_ERROR_MESSAGE }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBNEDELEC_ONE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 560 of file fe_nedelec_one\&.C\&.
.PP
.nf
560 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBNEDELEC_ONE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 561 of file fe_nedelec_one\&.C\&.
.PP
.nf
561 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBLAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 866 of file fe_lagrange\&.C\&.
.PP
.nf
866 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBLAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 867 of file fe_lagrange\&.C\&.
.PP
.nf
867 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBLAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 868 of file fe_lagrange\&.C\&.
.PP
.nf
868 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBLAGRANGE\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 869 of file fe_lagrange\&.C\&.
.PP
.nf
869 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBXYZ\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 895 of file fe_xyz\&.C\&.
.PP
.nf
895 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBXYZ\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 896 of file fe_xyz\&.C\&.
.PP
.nf
896 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBXYZ\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 897 of file fe_xyz\&.C\&.
.PP
.nf
897 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBXYZ\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 898 of file fe_xyz\&.C\&.
.PP
.nf
898 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBLAGRANGE_VEC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 939 of file fe_lagrange_vec\&.C\&.
.PP
.nf
939 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBLAGRANGE_VEC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 940 of file fe_lagrange_vec\&.C\&.
.PP
.nf
940 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBLAGRANGE_VEC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 941 of file fe_lagrange_vec\&.C\&.
.PP
.nf
941 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBLAGRANGE_VEC\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 942 of file fe_lagrange_vec\&.C\&.
.PP
.nf
942 { return false; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 951 of file fe_subdivision_2D\&.C\&.
.PP
.nf
951 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 0, \fBSZABAB\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1258 of file fe_szabab\&.C\&.
.PP
.nf
1258 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 1, \fBSZABAB\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1259 of file fe_szabab\&.C\&.
.PP
.nf
1259 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 2, \fBSZABAB\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1260 of file fe_szabab\&.C\&.
.PP
.nf
1260 { return true; }
.fi
.SS "template<> bool \fBlibMesh::FE\fP< 3, \fBSZABAB\fP >::shapes_need_reinit () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 1261 of file fe_szabab\&.C\&.
.PP
.nf
1261 { return true; }
.fi
.SS "template<unsigned int Dim, FEFamily T> void \fBlibMesh::FE\fP< Dim, T >::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigned ints, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [virtual]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 335 of file fe_boundary\&.C\&.
.PP
References std::max(), libMesh::Elem::n_nodes(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::Elem::p_level(), side, libMesh::Elem::type(), and libMesh::zero\&.
.PP
.nf
340 {
341   unsigned int side_p_level = elem->p_level();
342   if (elem->neighbor(s) != NULL)
343     side_p_level = std::max(side_p_level, elem->neighbor(s)->p_level());
344 
345   if (side->type() != last_side ||
346       side_p_level != this->_p_level ||
347       !this->shapes_on_quadrature)
348     {
349       // Set the element type
350       this->elem_type = elem->type();
351       this->_p_level = side_p_level;
352 
353       // Set the last_side
354       last_side = side->type();
355 
356       // Initialize the face shape functions
357       this->_fe_map->template init_face_shape_functions<Dim>(reference_side_points, side);
358     }
359 
360   const unsigned int n_points =
361     libmesh_cast_int<unsigned int>(reference_side_points\&.size());
362   reference_points\&.resize(n_points);
363   for (unsigned int i = 0; i < n_points; i++)
364     reference_points[i]\&.zero();
365 
366   std::vector<unsigned int> elem_nodes_map;
367   elem_nodes_map\&.resize(side->n_nodes());
368   for (unsigned int j = 0; j < side->n_nodes(); j++)
369     for (unsigned int i = 0; i < elem->n_nodes(); i++)
370       if (side->node(j) == elem->node(i))
371         elem_nodes_map[j] = i;
372   std::vector<Point> refspace_nodes;
373   this->get_refspace_nodes(elem->type(), refspace_nodes);
374 
375   const std::vector<std::vector<Real> >& psi_map = this->_fe_map->get_psi();
376 
377   for (unsigned int i=0; i<psi_map\&.size(); i++) // sum over the nodes
378     {
379       const Point& side_node = refspace_nodes[elem_nodes_map[i]];
380       for (unsigned int p=0; p<n_points; p++)
381         reference_points[p]\&.add_scaled (side_node, psi_map[i][p]);
382     }
383 }
.fi
.SS "template<> void \fBlibMesh::FE\fP< 2, \fBSUBDIVISION\fP >::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigneds, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [virtual]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Definition at line 891 of file fe_subdivision_2D\&.C\&.
.PP
.nf
896 {
897   libmesh_error();
898 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<unsigned int Dim, FEFamily T> template<unsigned int friend_Dim, FEFamily friend_T_radial, InfMapType friend_T_map> friend class \fBInfFE\fP\fC [friend]\fP"
make \fBInfFE\fP classes friends, so that these may access the private \fCmap\fP, map_xyz methods 
.PP
Definition at line 443 of file fe\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_curvatures(), libMesh::FEAbstract::get_d2xyzdeta2(), libMesh::FEAbstract::get_d2xyzdetadzeta(), libMesh::FEAbstract::get_d2xyzdxi2(), libMesh::FEAbstract::get_d2xyzdxideta(), libMesh::FEAbstract::get_d2xyzdxidzeta(), libMesh::FEAbstract::get_d2xyzdzeta2(), libMesh::FEAbstract::get_detadx(), libMesh::FEAbstract::get_detady(), libMesh::FEAbstract::get_detadz(), libMesh::FEAbstract::get_dxidx(), libMesh::FEAbstract::get_dxidy(), libMesh::FEAbstract::get_dxidz(), libMesh::FEAbstract::get_dxyzdeta(), libMesh::FEAbstract::get_dxyzdxi(), libMesh::FEAbstract::get_dxyzdzeta(), libMesh::FEAbstract::get_dzetadx(), libMesh::FEAbstract::get_dzetady(), libMesh::FEAbstract::get_dzetadz(), libMesh::FEAbstract::get_fe_map(), libMesh::FEAbstract::get_JxW(), libMesh::FEAbstract::get_normals(), libMesh::FEAbstract::get_tangents(), libMesh::FEAbstract::get_xyz(), libMesh::FESubdivision::init_shape_functions(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_xyz(), and libMesh::FESubdivision::reinit()\&.
.SS "\fBAutoPtr\fP<\fBFETransformationBase\fP<OutputType> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::_fe_trans\fC [protected]\fP, \fC [inherited]\fP"
Object that handles computing shape function values, gradients, etc in the physical domain\&. 
.PP
Definition at line 489 of file fe_base\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP, \fC [inherited]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_order(), and libMesh::FEAbstract::get_p_level()\&.
.SS "template<unsigned int Dim, FEFamily T> std::vector<\fBPoint\fP> \fBlibMesh::FE\fP< Dim, T >::cached_nodes\fC [protected]\fP"
An array of the node locations on the last element we computed on 
.PP
Definition at line 473 of file fe\&.h\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::curl_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function curl values\&. Only defined for vector types\&. 
.PP
Definition at line 504 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputTensor\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivative values\&. 
.PP
Definition at line 547 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phideta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta direction\&. 
.PP
Definition at line 567 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidetadzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta-zeta direction\&. 
.PP
Definition at line 572 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidx2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x direction\&. 
.PP
Definition at line 582 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdy\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-y direction\&. 
.PP
Definition at line 587 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-z direction\&. 
.PP
Definition at line 592 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxi2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi direction\&. 
.PP
Definition at line 552 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-eta direction\&. 
.PP
Definition at line 557 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-zeta direction\&. 
.PP
Definition at line 562 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidy2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y direction\&. 
.PP
Definition at line 597 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidydz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y-z direction\&. 
.PP
Definition at line 602 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidz2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the z direction\&. 
.PP
Definition at line 607 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidzeta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the zeta direction\&. 
.PP
Definition at line 577 of file fe_base\&.h\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP, \fC [inherited]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "std::vector<std::vector<\fBOutputDivergence\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::div_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function divergence values\&. Only defined for vector types\&. 
.PP
Definition at line 509 of file fe_base\&.h\&.
.SS "std::vector<\fBOutputGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphase\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the first derivatives of the phase term in global coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 625 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputGradient\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivative values\&. 
.PP
Definition at line 499 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the eta direction\&. 
.PP
Definition at line 519 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidx\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the x direction\&. 
.PP
Definition at line 529 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidxi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the xi direction\&. 
.PP
Definition at line 514 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidy\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the y direction\&. 
.PP
Definition at line 534 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidz\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the z direction\&. 
.PP
Definition at line 539 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the zeta direction\&. 
.PP
Definition at line 524 of file fe_base\&.h\&.
.SS "std::vector<\fBRealGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dweight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the global derivative of the additional radial weight $ 1/{r^2} $, over \fIall\fP quadrature points\&. 
.PP
Definition at line 632 of file fe_base\&.h\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP, \fC [inherited]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FEAbstract::get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP, \fC [inherited]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::compute_node_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEAbstract::get_family(), libMesh::FEAbstract::get_fe_type(), libMesh::FEAbstract::get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "template<unsigned int Dim, FEFamily T> unsigned int \fBlibMesh::FE\fP< Dim, T >::last_edge\fC [protected]\fP"

.PP
Definition at line 480 of file fe\&.h\&.
.SS "template<unsigned int Dim, FEFamily T> \fBElemType\fP \fBlibMesh::FE\fP< Dim, T >::last_side\fC [protected]\fP"
The last side and last edge we did a reinit on 
.PP
Definition at line 478 of file fe\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function values\&. 
.PP
Definition at line 494 of file fe_base\&.h\&.
.PP
Referenced by libMesh::FESubdivision::init_shape_functions()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP, \fC [inherited]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FESubdivision::reinit()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP, \fC [inherited]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "std::vector<\fBReal\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::weight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the additional radial weight $ 1/{r^2} $ in local coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 639 of file fe_base\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
