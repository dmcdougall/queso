.TH "libMesh::FESubdivision" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FESubdivision \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe\&.h>\fP
.PP
Inherits \fBlibMesh::FE< 2, SUBDIVISION >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBFEGenericBase\fP
.br
< typename \fBFEOutputType\fP< T >
.br
::type >::\fBOutputShape\fP \fBOutputShape\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputGradient\fP >::type \fBOutputTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputShape\fP >::type \fBOutputDivergence\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::MakeNumber\fP
.br
< \fBOutputShape\fP >::type \fBOutputNumber\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberGradient\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::IncrementRank\fP
.br
< \fBOutputNumberGradient\fP >::type \fBOutputNumberTensor\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBTensorTools::DecrementRank\fP
.br
< \fBOutputNumber\fP >::type \fBOutputNumberDivergence\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFESubdivision\fP (const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *, const unsigned int, const \fBReal\fP=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const =NULL, const std::vector< \fBReal\fP > *const =NULL)"
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)"
.br
.ti -1c
.RI "virtual void \fBinit_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const"
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const"
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *elem, const \fBElem\fP *\fBside\fP, const unsigned int s, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)"
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const"
.br
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputGradient\fP > > & \fBget_dphi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_curl_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputDivergence\fP > > & \fBget_div_phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidx\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidxi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_dphidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputTensor\fP > > & \fBget_d2phi\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidx2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdy\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxdz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidy2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidydz\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidz2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxi2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxideta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidxidzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phideta2\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidetadzeta\fP () const"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBOutputShape\fP > > & \fBget_d2phidzeta2\fP () const"
.br
.ti -1c
.RI "const std::vector
.br
< \fBOutputGradient\fP > & \fBget_dphase\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_Sobolev_weight\fP () const"
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_Sobolev_dweight\fP () const"
.br
.ti -1c
.RI "void \fBprint_phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_dphi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "void \fBprint_d2phi\fP (std::ostream &os) const"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBReal\fP \fBregular_shape\fP (const unsigned int i, const \fBReal\fP v, const \fBReal\fP w)"
.br
.ti -1c
.RI "static \fBReal\fP \fBregular_shape_deriv\fP (const unsigned int i, const unsigned int j, const \fBReal\fP v, const \fBReal\fP w)"
.br
.ti -1c
.RI "static \fBReal\fP \fBregular_shape_second_deriv\fP (const unsigned int i, const unsigned int j, const \fBReal\fP v, const \fBReal\fP w)"
.br
.ti -1c
.RI "static void \fBloop_subdivision_mask\fP (std::vector< \fBReal\fP > &weights, const unsigned int valence)"
.br
.ti -1c
.RI "static void \fBinit_subdivision_matrix\fP (\fBDenseMatrix\fP< \fBReal\fP > &\fBA\fP, unsigned int valence)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static \fBOutputShape\fP \fBshape_second_deriv\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const unsigned int i, const unsigned int j, const \fBPoint\fP &p)"
.br
.ti -1c
.RI "static void \fBnodal_soln\fP (const \fBElem\fP *elem, const \fBOrder\fP o, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)"
.br
.ti -1c
.RI "static unsigned int \fBn_shape_functions\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_at_node\fP (const \fBElemType\fP t, const \fBOrder\fP o, const unsigned int n)"
.br
.ti -1c
.RI "static unsigned int \fBn_dofs_per_elem\fP (const \fBElemType\fP t, const \fBOrder\fP o)"
.br
.ti -1c
.RI "static void \fBdofs_on_side\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int s, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static void \fBdofs_on_edge\fP (const \fBElem\fP *const elem, const \fBOrder\fP o, unsigned int e, std::vector< unsigned int > &di)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBinverse_map\fP (const \fBElem\fP *elem, const \fBPoint\fP &p, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBinverse_map\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const bool secure=true)"
.br
.ti -1c
.RI "static void \fBcompute_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_xi\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_eta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBPoint\fP \fBmap_zeta\fP (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEGenericBase\fP > \fBbuild_InfFE\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static void \fBcompute_proj_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcoarsened_dof_values\fP (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &\fBdof_map\fP, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned int var, const bool use_old_dof_indices=false)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_constraints\fP (\fBDofConstraints\fP &constraints, \fBDofMap\fP &\fBdof_map\fP, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const unsigned int variable_number, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBinit_base_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBPoint\fP > \fBcached_nodes\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBlast_side\fP"
.br
.ti -1c
.RI "unsigned int \fBlast_edge\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFETransformationBase\fP
.br
< OutputType > > \fB_fe_trans\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputGradient\fP > > \fBdphi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBcurl_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputDivergence\fP > > \fBdiv_phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidxi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidx\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBdphidz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputTensor\fP > > \fBd2phi\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxi2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxideta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxidzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phideta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidetadzeta\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidzeta2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidx2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdy\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidxdz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidy2\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidydz\fP"
.br
.ti -1c
.RI "std::vector< std::vector
.br
< \fBOutputShape\fP > > \fBd2phidz2\fP"
.br
.ti -1c
.RI "std::vector< \fBOutputGradient\fP > \fBdphase\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdweight\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBweight\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 575 of file fe\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 138 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputGradient\fP\fC [inherited]\fP"

.PP
Definition at line 136 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::MakeNumber\fP<\fBOutputShape\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumber\fP\fC [inherited]\fP"

.PP
Definition at line 139 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::DecrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberDivergence\fP\fC [inherited]\fP"

.PP
Definition at line 142 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumber\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberGradient\fP\fC [inherited]\fP"

.PP
Definition at line 140 of file fe_base\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputNumberGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputNumberTensor\fP\fC [inherited]\fP"

.PP
Definition at line 141 of file fe_base\&.h\&.
.SS "typedef \fBFEGenericBase\fP<typename \fBFEOutputType\fP<T>::type>::\fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::\fBOutputShape\fP\fC [inherited]\fP"

.PP
Definition at line 103 of file fe\&.h\&.
.SS "typedef \fBTensorTools::IncrementRank\fP<\fBOutputGradient\fP>::type \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::\fBOutputTensor\fP\fC [inherited]\fP"

.PP
Definition at line 137 of file fe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::FESubdivision::FESubdivision (const \fBFEType\fP &fet)"
Constructor\&. Creates a subdivision surface finite element\&. Currently only supported for two-dimensional meshes in three-dimensional space\&. 
.PP
Definition at line 33 of file fe_subdivision_2D\&.C\&.
.PP
.nf
33                                               :
34   FE<2,SUBDIVISION>(fet)
35 {
36   // Only 2D meshes in 3D space are supported
37   libmesh_assert_equal_to(LIBMESH_DIM, 3);
38 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::FESubdivision::attach_quadrature_rule (\fBQBase\fP *q)\fC [virtual]\fP"
Provides the class with the quadrature rule, which provides the locations (on a reference element) where the shape functions are to be calculated\&. 
.PP
Reimplemented from \fBlibMesh::FE< 2, SUBDIVISION >\fP\&.
.PP
Definition at line 671 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FEAbstract::elem_type, libMesh::INVALID_ELEM, libMesh::libmesh_assert(), and libMesh::FEAbstract::qrule\&.
.PP
.nf
672 {
673   libmesh_assert(q);
674 
675   qrule = q;
676   // make sure we don't cache results from a previous quadrature rule
677   elem_type = INVALID_ELEM;
678   return;
679 }
.fi
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputType of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static \fBAutoPtr\fP<\fBFEGenericBase\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::build_InfFE (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP, \fC [inherited]\fP"
Builds a specific infinite element type\&. A \fCAutoPtr<FEGenericBase>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&.
.PP
The build call will fail if the OutputShape of this class is not compatible with the output required for the requested \fCtype\fP 
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::coarsened_dof_values (const \fBNumericVector\fP< \fBNumber\fP > &global_vector, const \fBDofMap\fP &dof_map, const \fBElem\fP *coarse_elem, \fBDenseVector\fP< \fBNumber\fP > &coarse_dofs, const unsigned intvar, const booluse_old_dof_indices = \fCfalse\fP)\fC [static]\fP, \fC [inherited]\fP"
Creates a local projection on \fCcoarse_elem\fP, based on the DoF values in \fCglobal_vector\fP for it's children\&. 
.SS "static void \fBlibMesh::FE\fP< Dim, T >::compute_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using element-specific optimizations if possible\&. 
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_periodic_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for meshes with periodic boundary conditions) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), libMesh::FEAbstract::fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "static void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_proj_constraints (\fBDofConstraints\fP &constraints, \fBDofMap\fP &dof_map, const unsigned intvariable_number, const \fBElem\fP *elem)\fC [static]\fP, \fC [inherited]\fP"
Computes the constraint matrix contributions (for non-conforming adapted meshes) corresponding to variable number \fCvar_number\fP, using generic projections\&. 
.SS "virtual void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::compute_shape_functions (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &qp)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
After having updated the jacobian and the transformation from local to global coordinates in \fCFEAbstract::compute_map()\fP, the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx\fP, \fCdphidy\fP, and \fCdphidz\fP\&. This method should rarely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.PP
Reimplemented in \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "static void \fBlibMesh::FE\fP< Dim, T >::dofs_on_edge (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned inte, std::vector< unsigned int > &di)\fC [static]\fP, \fC [inherited]\fP"
Fills the vector di with the local degree of freedom indices associated with edge \fCe\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static void \fBlibMesh::FE\fP< Dim, T >::dofs_on_side (const \fBElem\fP *constelem, const \fBOrder\fPo, unsigned ints, std::vector< unsigned int > &di)\fC [static]\fP, \fC [inherited]\fP"
Fills the vector di with the local degree of freedom indices associated with side \fCs\fP of element \fCelem\fP 
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const Realtolerance = \fCTOLERANCE\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< Real > *constweights = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fC\fBinverse_map()\fP\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference \fIside\fP element specified in the optional argument \fCpts\fP\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual \fBFEContinuity\fP \fBlibMesh::FE\fP< Dim, T >::get_continuity () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_curl_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curl of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 225 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_curl_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::curl_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
226   { libmesh_assert(!calculations_started || calculate_curl_phi);
227     calculate_curl_phi = calculate_dphiref = true; return curl_phi; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "const std::vector<std::vector<\fBOutputTensor\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phi, and libMesh::libmesh_assert()\&.
.PP
.nf
292   { libmesh_assert(!calculations_started || calculate_d2phi);
293     calculate_d2phi = calculate_dphiref = true; return d2phi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phideta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 371 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phideta2, and libMesh::libmesh_assert()\&.
.PP
.nf
372   { libmesh_assert(!calculations_started || calculate_d2phi);
373     calculate_d2phi = calculate_dphiref = true; return d2phideta2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 379 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidetadzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
380   { libmesh_assert(!calculations_started || calculate_d2phi);
381     calculate_d2phi = calculate_dphiref = true; return d2phidetadzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidx2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidx2, and libMesh::libmesh_assert()\&.
.PP
.nf
300   { libmesh_assert(!calculations_started || calculate_d2phi);
301     calculate_d2phi = calculate_dphiref = true; return d2phidx2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 307 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdy, and libMesh::libmesh_assert()\&.
.PP
.nf
308   { libmesh_assert(!calculations_started || calculate_d2phi);
309     calculate_d2phi = calculate_dphiref = true; return d2phidxdy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxdz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 315 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxdz, and libMesh::libmesh_assert()\&.
.PP
.nf
316   { libmesh_assert(!calculations_started || calculate_d2phi);
317     calculate_d2phi = calculate_dphiref = true; return d2phidxdz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 347 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxi2, and libMesh::libmesh_assert()\&.
.PP
.nf
348   { libmesh_assert(!calculations_started || calculate_d2phi);
349     calculate_d2phi = calculate_dphiref = true; return d2phidxi2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 355 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxideta, and libMesh::libmesh_assert()\&.
.PP
.nf
356   { libmesh_assert(!calculations_started || calculate_d2phi);
357     calculate_d2phi = calculate_dphiref = true; return d2phidxideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 363 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidxidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
364   { libmesh_assert(!calculations_started || calculate_d2phi);
365     calculate_d2phi = calculate_dphiref = true; return d2phidxidzeta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidy2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 323 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidy2, and libMesh::libmesh_assert()\&.
.PP
.nf
324   { libmesh_assert(!calculations_started || calculate_d2phi);
325     calculate_d2phi =  calculate_dphiref = true; return d2phidy2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidydz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 331 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidydz, and libMesh::libmesh_assert()\&.
.PP
.nf
332   { libmesh_assert(!calculations_started || calculate_d2phi);
333     calculate_d2phi = calculate_dphiref = true; return d2phidydz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidz2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 339 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidz2, and libMesh::libmesh_assert()\&.
.PP
.nf
340   { libmesh_assert(!calculations_started || calculate_d2phi);
341     calculate_d2phi = calculate_dphiref = true; return d2phidz2; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_d2phidzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function second derivatives at the quadrature points, in reference coordinates 
.RE
.PP

.PP
Definition at line 387 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::d2phidzeta2, and libMesh::libmesh_assert()\&.
.PP
.nf
388   { libmesh_assert(!calculations_started || calculate_d2phi);
389     calculate_d2phi = calculate_dphiref = true; return d2phidzeta2; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "const std::vector<std::vector<\fBOutputDivergence\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_div_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the divergence of the shape function at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 233 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_div_phi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::div_phi, and libMesh::libmesh_assert()\&.
.PP
.nf
234   { libmesh_assert(!calculations_started || calculate_div_phi);
235     calculate_div_phi = calculate_dphiref = true; return div_phi; }
.fi
.SS "const std::vector<\fBOutputGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphase () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global first derivative of the phase term which is used in infinite elements, evaluated at the quadrature points\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all zero, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 405 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dphase\&.
.PP
.nf
406   { return dphase; }
.fi
.SS "const std::vector<std::vector<\fBOutputGradient\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function derivatives at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 217 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphi, and libMesh::libmesh_assert()\&.
.PP
.nf
218   { libmesh_assert(!calculations_started || calculate_dphi);
219     calculate_dphi = calculate_dphiref = true; return dphi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function eta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 273 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphideta, and libMesh::libmesh_assert()\&.
.PP
.nf
274   { libmesh_assert(!calculations_started || calculate_dphiref);
275     calculate_dphiref = true; return dphideta; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function x-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidx, and libMesh::libmesh_assert()\&.
.PP
.nf
242   { libmesh_assert(!calculations_started || calculate_dphi);
243     calculate_dphi = calculate_dphiref = true; return dphidx; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function xi-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 265 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidxi, and libMesh::libmesh_assert()\&.
.PP
.nf
266   { libmesh_assert(!calculations_started || calculate_dphiref);
267     calculate_dphiref = true; return dphidxi; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function y-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 249 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidy, and libMesh::libmesh_assert()\&.
.PP
.nf
250   { libmesh_assert(!calculations_started || calculate_dphi);
251     calculate_dphi = calculate_dphiref = true; return dphidy; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function z-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidz, and libMesh::libmesh_assert()\&.
.PP
.nf
258   { libmesh_assert(!calculations_started || calculate_dphi);
259     calculate_dphi = calculate_dphiref = true; return dphidz; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_dphidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function zeta-derivative at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 281 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_dphiref, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< T >::dphidzeta, and libMesh::libmesh_assert()\&.
.PP
.nf
282   { libmesh_assert(!calculations_started || calculate_dphiref);
283     calculate_dphiref = true; return dphidzeta; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level, libMesh::FEAbstract::fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "const std::vector<std::vector<\fBOutputShape\fP> >& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_phi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the shape function values at the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 209 of file fe_base\&.h\&.
.PP
References libMesh::FEAbstract::calculate_phi, libMesh::FEAbstract::calculations_started, libMesh::libmesh_assert(), and libMesh::FEGenericBase< T >::phi\&.
.PP
.nf
210   { libmesh_assert(!calculations_started || calculate_phi);
211     calculate_phi = true; return phi; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP, \fC [inherited]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "const std::vector<\fBRealGradient\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_dweight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the first global derivative of the multiplicative weight at each quadrature point\&. See \fC\fBget_Sobolev_weight()\fP\fP for details\&. In case of \fCFE\fP initialized to all zero\&. 
.RE
.PP

.PP
Definition at line 429 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::dweight\&.
.PP
.nf
430   { return dweight; }
.fi
.SS "const std::vector<\fBReal\fP>& \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::get_Sobolev_weight () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the multiplicative weight at each quadrature point\&. This weight is used for certain infinite element weak formulations, so that \fIweighted\fP Sobolev spaces are used for the trial function space\&. This renders the variational form easily computable\&.
.RE
.PP
In case of the general finite element class \fCFE\fP this field is initialized to all ones, so that the variational formulation for an \fIinfinite\fP element returns correct element matrices for a mesh using both finite and infinite elements\&. 
.PP
Definition at line 421 of file fe_base\&.h\&.
.PP
References libMesh::FEGenericBase< T >::weight\&.
.PP
.nf
422   { return weight; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::init_base_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *e)\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Initialize the data fields for the base of an an infinite element\&. 
.PP
Implements \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.SS "void libMesh::FESubdivision::init_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *elem)\fC [virtual]\fP"
Update the various member data fields \fCphi\fP, \fCdphidxi\fP, \fCdphideta\fP, \fCdphidzeta\fP, etc\&. for the current element\&. These data will be computed at the points \fCqp\fP, which are generally (but need not be) the quadrature points\&. 
.PP
Reimplemented from \fBlibMesh::FE< 2, SUBDIVISION >\fP\&.
.PP
Definition at line 413 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map, A, libMesh::FEAbstract::calculate_d2phi, libMesh::FEAbstract::calculate_dphi, libMesh::FEAbstract::calculate_phi, libMesh::FEAbstract::calculations_started, libMesh::FEGenericBase< FEOutputType< T >::type >::d2phi, libMesh::FEGenericBase< FEOutputType< T >::type >::d2phideta2, libMesh::FEGenericBase< FEOutputType< T >::type >::d2phidxi2, libMesh::FEGenericBase< FEOutputType< T >::type >::d2phidxideta, libMesh::FEGenericBase< FEOutputType< T >::type >::dphi, libMesh::FEGenericBase< FEOutputType< T >::type >::dphideta, libMesh::FEGenericBase< FEOutputType< T >::type >::dphidxi, libMesh::FEAbstract::fe_type, init_subdivision_matrix(), libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), std::max(), std::min(), libMesh::FEType::order, libMesh::FEGenericBase< FEOutputType< T >::type >::phi, std::pow(), libMesh::Real, libMesh::DenseMatrix< T >::right_multiply(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TRI3SUBDIVISION, and libMesh::Elem::type()\&.
.PP
Referenced by reinit()\&.
.PP
.nf
415 {
416   libmesh_assert(elem);
417   libmesh_assert_equal_to(elem->type(), TRI3SUBDIVISION);
418   const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
419 
420   START_LOG("init_shape_functions()", "FESubdivision");
421 
422   calculations_started = true;
423 
424   // If the user forgot to request anything, we'll be safe and calculate everything:
425 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
426   if (!calculate_phi && !calculate_dphi && !calculate_d2phi)
427     calculate_phi = calculate_dphi = calculate_d2phi = true;
428 #else
429   if (!calculate_phi && !calculate_dphi)
430     calculate_phi = calculate_dphi = true;
431 #endif
432 
433   const unsigned int valence = sd_elem->get_ordered_valence(0);
434   const unsigned int n_qp = qp\&.size();
435   const unsigned int n_approx_shape_functions = valence + 6;
436 
437   // resize the vectors to hold current data
438   phi\&.resize         (n_approx_shape_functions);
439   dphi\&.resize        (n_approx_shape_functions);
440   dphidxi\&.resize     (n_approx_shape_functions);
441   dphideta\&.resize    (n_approx_shape_functions);
442 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
443   d2phi\&.resize       (n_approx_shape_functions);
444   d2phidxi2\&.resize   (n_approx_shape_functions);
445   d2phidxideta\&.resize(n_approx_shape_functions);
446   d2phideta2\&.resize  (n_approx_shape_functions);
447 #endif
448 
449   for (unsigned int i = 0; i < n_approx_shape_functions; ++i)
450     {
451       phi[i]\&.resize         (n_qp);
452       dphi[i]\&.resize        (n_qp);
453       dphidxi[i]\&.resize     (n_qp);
454       dphideta[i]\&.resize    (n_qp);
455 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
456       d2phi[i]\&.resize       (n_qp);
457       d2phidxi2[i]\&.resize   (n_qp);
458       d2phidxideta[i]\&.resize(n_qp);
459       d2phideta2[i]\&.resize  (n_qp);
460 #endif
461     }
462 
463   // Renumbering of the shape functions
464   static const unsigned int cvi[12] = {3,6,2,0,1,4,7,10,9,5,11,8};
465 
466   if (valence == 6) // This means that all vertices are regular, i\&.e\&. we have 12 shape functions
467     {
468       for (unsigned int i = 0; i < n_approx_shape_functions; ++i)
469         {
470           for (unsigned int p = 0; p < n_qp; ++p)
471             {
472               phi[i][p]          = FE<2,SUBDIVISION>::shape             (elem, fe_type\&.order, cvi[i],    qp[p]);
473               dphidxi[i][p]      = FE<2,SUBDIVISION>::shape_deriv       (elem, fe_type\&.order, cvi[i], 0, qp[p]);
474               dphideta[i][p]     = FE<2,SUBDIVISION>::shape_deriv       (elem, fe_type\&.order, cvi[i], 1, qp[p]);
475               dphi[i][p](0)      = dphidxi[i][p];
476               dphi[i][p](1)      = dphideta[i][p];
477 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
478               d2phidxi2[i][p]    = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, cvi[i], 0, qp[p]);
479               d2phidxideta[i][p] = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, cvi[i], 1, qp[p]);
480               d2phideta2[i][p]   = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, cvi[i], 2, qp[p]);
481               d2phi[i][p](0,0)   = d2phidxi2[i][p];
482               d2phi[i][p](0,1)   = d2phi[i][p](1,0) = d2phidxideta[i][p];
483               d2phi[i][p](1,1)   = d2phideta2[i][p];
484 #endif
485             }
486         }
487     }
488   else // vertex 0 is irregular by construction of the mesh
489     {
490       static const Real eps = 1e-10;
491 
492       // temporary values
493       std::vector<Real> tphi(12);
494       std::vector<Real> tdphidxi(12);
495       std::vector<Real> tdphideta(12);
496 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
497       std::vector<Real> td2phidxi2(12);
498       std::vector<Real> td2phidxideta(12);
499       std::vector<Real> td2phideta2(12);
500 #endif
501 
502       for (unsigned int p = 0; p < n_qp; ++p)
503         {
504           // evaluate the number of the required subdivisions
505           Real v = qp[p](0);
506           Real w = qp[p](1);
507           Real u = 1 - v - w;
508           Real min = 0, max = 0\&.5;
509           int n = 0;
510           while (!(u > min-eps && u < max+eps))
511             {
512               ++n;
513               min = max;
514               max += std::pow((Real)(2), -n-1);
515             }
516 
517           // transform u, v and w according to the number of subdivisions required\&.
518           const Real pow2 = std::pow((Real)(2), n);
519           v *= pow2;
520           w *= pow2;
521           u = 1 - v - w;
522           libmesh_assert_less(u, 0\&.5 + eps);
523           libmesh_assert_greater(u, -eps);
524 
525           // find out in which subdivided patch we are and setup the "selection matrix" P and the transformation Jacobian
526           // (see Int\&. J\&. Numer\&. Meth\&. Engng\&. 2000; 47:2039-2072, Appendix A\&.2\&.)
527           const int k = n+1;
528           Real jfac; // the additional factor per derivative order
529           DenseMatrix<Real> P(12, valence+12);
530           if (v > 0\&.5 - eps)
531             {
532               v = 2*v - 1;
533               w = 2*w;
534               jfac = std::pow((Real)(2), k);
535               P( 0,2        ) = 1;
536               P( 1,0        ) = 1;
537               P( 2,valence+3) = 1;
538               P( 3,1        ) = 1;
539               P( 4,valence  ) = 1;
540               P( 5,valence+8) = 1;
541               P( 6,valence+2) = 1;
542               P( 7,valence+1) = 1;
543               P( 8,valence+4) = 1;
544               P( 9,valence+7) = 1;
545               P(10,valence+6) = 1;
546               P(11,valence+9) = 1;
547             }
548           else if (w > 0\&.5 - eps)
549             {
550               v = 2*v;
551               w = 2*w - 1;
552               jfac = std::pow((Real)(2), k);
553               P( 0,0         ) = 1;
554               P( 1,valence- 1) = 1;
555               P( 2,1         ) = 1;
556               P( 3,valence   ) = 1;
557               P( 4,valence+ 5) = 1;
558               P( 5,valence+ 2) = 1;
559               P( 6,valence+ 1) = 1;
560               P( 7,valence+ 4) = 1;
561               P( 8,valence+11) = 1;
562               P( 9,valence+ 6) = 1;
563               P(10,valence+ 9) = 1;
564               P(11,valence+10) = 1;
565             }
566           else
567             {
568               v = 1 - 2*v;
569               w = 1 - 2*w;
570               jfac = std::pow((Real)(-2), k);
571               P( 0,valence+9) = 1;
572               P( 1,valence+6) = 1;
573               P( 2,valence+4) = 1;
574               P( 3,valence+1) = 1;
575               P( 4,valence+2) = 1;
576               P( 5,valence+5) = 1;
577               P( 6,valence  ) = 1;
578               P( 7,1        ) = 1;
579               P( 8,valence+3) = 1;
580               P( 9,valence-1) = 1;
581               P(10,0        ) = 1;
582               P(11,2        ) = 1;
583             }
584 
585           u = 1 - v - w;
586           if ((u > 1 + eps) || (u < -eps))
587             {
588               std::cout << "SUBDIVISION irregular patch: u is outside valid range!\n";
589               libmesh_error();
590             }
591 
592           DenseMatrix<Real> A;
593           init_subdivision_matrix(A, valence);
594 
595           // compute P*A^k
596           if (k > 1)
597             {
598               DenseMatrix<Real> Acopy(A);
599               for (int e = 1; e < k; ++e)
600                 A\&.right_multiply(Acopy);
601             }
602           P\&.right_multiply(A);
603 
604           const Point transformed_p(v,w);
605 
606           for (unsigned int i = 0; i < 12; ++i)
607             {
608               tphi[i]          = FE<2,SUBDIVISION>::shape             (elem, fe_type\&.order, i,    transformed_p);
609               tdphidxi[i]      = FE<2,SUBDIVISION>::shape_deriv       (elem, fe_type\&.order, i, 0, transformed_p);
610               tdphideta[i]     = FE<2,SUBDIVISION>::shape_deriv       (elem, fe_type\&.order, i, 1, transformed_p);
611 
612 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
613               td2phidxi2[i]    = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, i, 0, transformed_p);
614               td2phidxideta[i] = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, i, 1, transformed_p);
615               td2phideta2[i]   = FE<2,SUBDIVISION>::shape_second_deriv(elem, fe_type\&.order, i, 2, transformed_p);
616 #endif
617             }
618 
619           // Finally, we can compute the irregular shape functions as the product of P
620           // and the regular shape functions:
621           Real sum1, sum2, sum3, sum4, sum5, sum6;
622           for (unsigned int j = 0; j < n_approx_shape_functions; ++j)
623             {
624               sum1 = sum2 = sum3 = sum4 = sum5 = sum6 = 0;
625               for (unsigned int i = 0; i < 12; ++i)
626                 {
627                   sum1 += P(i,j) * tphi[i];
628                   sum2 += P(i,j) * tdphidxi[i];
629                   sum3 += P(i,j) * tdphideta[i];
630 
631 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
632                   sum4 += P(i,j) * td2phidxi2[i];
633                   sum5 += P(i,j) * td2phidxideta[i];
634                   sum6 += P(i,j) * td2phideta2[i];
635 #endif
636                 }
637               phi[j][p]          = sum1;
638               dphidxi[j][p]      = sum2 * jfac;
639               dphideta[j][p]     = sum3 * jfac;
640               dphi[j][p](0)      = dphidxi[j][p];
641               dphi[j][p](1)      = dphideta[j][p];
642 
643 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
644               d2phidxi2[j][p]    = sum4 * jfac * jfac;
645               d2phidxideta[j][p] = sum5 * jfac * jfac;
646               d2phideta2[j][p]   = sum6 * jfac * jfac;
647               d2phi[j][p](0,0)   = d2phidxi2[j][p];
648               d2phi[j][p](0,1)   = d2phi[j][p](1,0) = d2phidxideta[j][p];
649               d2phi[j][p](1,1)   = d2phideta2[j][p];
650 #endif
651             }
652         } // end quadrature loop
653     } // end irregular vertex
654 
655   // Let the FEMap use the same initialized shape functions
656   this->_fe_map->get_phi_map()          = phi;
657   this->_fe_map->get_dphidxi_map()      = dphidxi;
658   this->_fe_map->get_dphideta_map()     = dphideta;
659 
660 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
661   this->_fe_map->get_d2phidxi2_map()    = d2phidxi2;
662   this->_fe_map->get_d2phideta2_map()   = d2phideta2;
663   this->_fe_map->get_d2phidxideta_map() = d2phidxideta;
664 #endif
665 
666   STOP_LOG("init_shape_functions()", "FESubdivision");
667 }
.fi
.SS "void libMesh::FESubdivision::init_subdivision_matrix (\fBDenseMatrix\fP< \fBReal\fP > &A, unsigned intvalence)\fC [static]\fP"
Builds the subdivision matrix \fCA\fP for the Loop scheme\&. The size depends on the element's \fCvalence\fP\&. 
.PP
Definition at line 42 of file fe_subdivision_2D\&.C\&.
.PP
References A, loop_subdivision_mask(), and libMesh::DenseMatrix< T >::resize()\&.
.PP
Referenced by init_shape_functions()\&.
.PP
.nf
44 {
45   A\&.resize(valence + 12, valence + 12);
46 
47   // A = (S11 0; S21 S22), see Cirak et al\&.,
48   // Int\&. J\&. Numer\&. Meth\&. Engng\&. 2000; 47:2039-2072, Appendix A\&.2\&.
49 
50   // First, set the static S21 part
51   A(valence+ 1,0        ) = 0\&.125;
52   A(valence+ 1,1        ) = 0\&.375;
53   A(valence+ 1,valence  ) = 0\&.375;
54   A(valence+ 2,0        ) = 0\&.0625;
55   A(valence+ 2,1        ) = 0\&.625;
56   A(valence+ 2,2        ) = 0\&.0625;
57   A(valence+ 2,valence  ) = 0\&.0625;
58   A(valence+ 3,0        ) = 0\&.125;
59   A(valence+ 3,1        ) = 0\&.375;
60   A(valence+ 3,2        ) = 0\&.375;
61   A(valence+ 4,0        ) = 0\&.0625;
62   A(valence+ 4,1        ) = 0\&.0625;
63   A(valence+ 4,valence-1) = 0\&.0625;
64   A(valence+ 4,valence  ) = 0\&.625;
65   A(valence+ 5,0        ) = 0\&.125;
66   A(valence+ 5,valence-1) = 0\&.375;
67   A(valence+ 5,valence  ) = 0\&.375;
68   A(valence+ 6,1        ) = 0\&.375;
69   A(valence+ 6,valence  ) = 0\&.125;
70   A(valence+ 7,1        ) = 0\&.375;
71   A(valence+ 8,1        ) = 0\&.375;
72   A(valence+ 8,2        ) = 0\&.125;
73   A(valence+ 9,1        ) = 0\&.125;
74   A(valence+ 9,valence  ) = 0\&.375;
75   A(valence+10,valence  ) = 0\&.375;
76   A(valence+11,valence-1) = 0\&.125;
77   A(valence+11,valence  ) = 0\&.375;
78 
79   // Next, set the static S22 part
80   A(valence+ 1,valence+1) = 0\&.125;
81   A(valence+ 2,valence+1) = 0\&.0625;
82   A(valence+ 2,valence+2) = 0\&.0625;
83   A(valence+ 2,valence+3) = 0\&.0625;
84   A(valence+ 3,valence+3) = 0\&.125;
85   A(valence+ 4,valence+1) = 0\&.0625;
86   A(valence+ 4,valence+4) = 0\&.0625;
87   A(valence+ 4,valence+5) = 0\&.0625;
88   A(valence+ 5,valence+5) = 0\&.125;
89   A(valence+ 6,valence+1) = 0\&.375;
90   A(valence+ 6,valence+2) = 0\&.125;
91   A(valence+ 7,valence+1) = 0\&.125;
92   A(valence+ 7,valence+2) = 0\&.375;
93   A(valence+ 7,valence+3) = 0\&.125;
94   A(valence+ 8,valence+2) = 0\&.125;
95   A(valence+ 8,valence+3) = 0\&.375;
96   A(valence+ 9,valence+1) = 0\&.375;
97   A(valence+ 9,valence+4) = 0\&.125;
98   A(valence+10,valence+1) = 0\&.125;
99   A(valence+10,valence+4) = 0\&.375;
100   A(valence+10,valence+5) = 0\&.125;
101   A(valence+11,valence+4) = 0\&.125;
102   A(valence+11,valence+5) = 0\&.375;
103 
104   // Last, set the S11 part: first row
105   std::vector<Real> weights;
106   loop_subdivision_mask(weights, valence);
107   for (unsigned int i = 0; i <= valence; ++i)
108     A(0,i) = weights[i];
109 
110   // second row
111   A(1,0) = 0\&.375;
112   A(1,1) = 0\&.375;
113   A(1,2) = 0\&.125;
114   A(1,valence) = 0\&.125;
115 
116   // third to second-to-last rows
117   for (unsigned int i = 2; i < valence; ++i)
118     {
119       A(i,0  ) = 0\&.375;
120       A(i,i-1) = 0\&.125;
121       A(i,i  ) = 0\&.375;
122       A(i,i+1) = 0\&.125;
123     }
124 
125   // last row
126   A(valence,0) = 0\&.375;
127   A(valence,1) = 0\&.125;
128   A(valence,valence-1) = 0\&.125;
129   A(valence,valence  ) = 0\&.375;
130 }
.fi
.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const \fBPoint\fP &p, const Realtolerance = \fCTOLERANCE\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (on the reference element) of the point \fCp\fP located in physical space\&. This function requires inverting the (possibly nonlinear) transformation map, so it is not trivial\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.RE
.PP

.SS "static void \fBlibMesh::FE\fP< Dim, T >::inverse_map (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > &physical_points, std::vector< \fBPoint\fP > &reference_points, const Realtolerance = \fCTOLERANCE\fP, const boolsecure = \fCtrue\fP)\fC [static]\fP, \fC [inherited]\fP"
Takes a number points in physical space (in the \fCphysical_points\fP vector) and finds their location on the reference element for the input element \fCelem\fP\&. The values on the reference element are returned in the vector \fCreference_points\fP\&. The optional parameter \fCtolerance\fP defines how close is 'good enough\&.' The map inversion iteration computes the sequence $ \{ p_n \} $, and the iteration is terminated when $ \|p - p_n\| < \mbox{\texttt{tolerance}} $ 
.SS "virtual bool \fBlibMesh::FE\fP< Dim, T >::is_hierarchic () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::FESubdivision::loop_subdivision_mask (std::vector< \fBReal\fP > &weights, const unsigned intvalence)\fC [static]\fP"
Fills the vector \fCweights\fP with the weight coefficients of the Loop subdivision mask for evaluating the limit surface at a node explicitly\&. The size of \fCweights\fP will be 1 + \fCvalence\fP, where \fCvalence\fP is the number of neighbor nodes of the node where the limit surface is to be evaluated\&. The weight for the node itself is the first element of \fCweights\fP\&. 
.PP
Definition at line 401 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::libmesh_assert_greater(), libMesh::pi, and libMesh::Real\&.
.PP
Referenced by init_subdivision_matrix()\&.
.PP
.nf
403 {
404   libmesh_assert_greater(valence, 0);
405   const Real cs = std::cos(2 * libMesh::pi / valence);
406   const Real nb_weight = (0\&.625 - Utility::pow<2>(0\&.375 + 0\&.25 * cs)) / valence;
407   weights\&.resize(1 + valence, nb_weight);
408   weights[0] = 1\&.0 - valence * nb_weight;
409 }
.fi
.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the location (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_eta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/deta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_xi (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dxi (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static \fBPoint\fP \fBlibMesh::FE\fP< Dim, T >::map_zeta (const \fBElem\fP *elem, const \fBPoint\fP &reference_point)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
d(xyz)/dzeta (in physical space) of the point \fCp\fP located on the reference element\&. 
.RE
.PP

.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_at_node (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned intn)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs at node \fCn\fP for a finite element of type \fCt\fP and order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_dofs_per_elem (const \fBElemType\fPt, const \fBOrder\fPo)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of dofs interior to the element, not associated with any interior nodes\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "virtual unsigned int \fBlibMesh::FE\fP< Dim, T >::n_quadrature_points () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Call this to get an upper bound for the \fCfor\fP loop in your simulation for matrix assembly of the current element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "virtual unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with this finite element\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "static unsigned int \fBlibMesh::FE\fP< Dim, T >::n_shape_functions (const \fBElemType\fPt, const \fBOrder\fPo)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of shape functions associated with a finite element of type \fCt\fP and approximation order \fCo\fP\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.PP
Definition at line 226 of file fe\&.h\&.
.PP
.nf
228   { return FE<Dim,T>::n_dofs (t,o); }
.fi
.SS "static void \fBlibMesh::FE\fP< Dim, T >::nodal_soln (const \fBElem\fP *elem, const \fBOrder\fPo, const std::vector< \fBNumber\fP > &elem_soln, std::vector< \fBNumber\fP > &nodal_soln)\fC [static]\fP, \fC [inherited]\fP"
Build the nodal soln from the element soln\&. This is the solution that will be plotted\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_d2phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_dphi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const\fC [inherited]\fP"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::print_dphi(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_phi(), and libMesh::FEAbstract::print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "void \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::print_phi (std::ostream &os) const\fC [virtual]\fP, \fC [inherited]\fP"
Prints the value of each shape function at each quadrature point\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map\&.
.PP
Referenced by libMesh::FEAbstract::print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "\fBReal\fP libMesh::FESubdivision::regular_shape (const unsigned inti, const \fBReal\fPv, const \fBReal\fPw)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ of the 12 quartic box splines interpolating a regular Loop subdivision element, evaluated at the barycentric coordinates \fCv\fP, \fCw\fP\&. 
.RE
.PP

.PP
Definition at line 134 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::Utility::pow(), and libMesh::Real\&.
.PP
.nf
137 {
138   // These are the 12 quartic box splines, see Cirak et al\&.,
139   // Int\&. J\&. Numer\&. Meth\&. Engng\&. 2000; 47:2039-2072, Appendix A\&.1\&.
140 
141   const Real u = 1 - v - w;
142   libmesh_assert_less_equal(0, v);
143   libmesh_assert_less_equal(0, w);
144   libmesh_assert_less_equal(0, u);
145 
146   using Utility::pow;
147   const Real factor = 1\&. / 12;
148 
149   switch (i)
150     {
151     case 0:
152       return factor*(pow<4>(u) + 2*u*u*u*v);
153     case 1:
154       return factor*(pow<4>(u) + 2*u*u*u*w);
155     case 2:
156       return factor*(pow<4>(u) + 2*u*u*u*w + 6*u*u*u*v + 6*u*u*v*w + 12*u*u*v*v + 6*u*v*v*w + 6*u*v*v*v +
157                      2*v*v*v*w + pow<4>(v));
158     case 3:
159       return factor*(6*pow<4>(u) + 24*u*u*u*w + 24*u*u*w*w + 8*u*w*w*w + pow<4>(w) + 24*u*u*u*v +
160                      60*u*u*v*w + 36*u*v*w*w + 6*v*w*w*w + 24*u*u*v*v + 36*u*v*v*w + 12*v*v*w*w + 8*u*v*v*v +
161                      6*v*v*v*w + pow<4>(v));
162     case 4:
163       return factor*(pow<4>(u) + 6*u*u*u*w + 12*u*u*w*w + 6*u*w*w*w + pow<4>(w) + 2*u*u*u*v + 6*u*u*v*w +
164                      6*u*v*w*w + 2*v*w*w*w);
165     case 5:
166       return factor*(2*u*v*v*v + pow<4>(v));
167     case 6:
168       return factor*(pow<4>(u) + 6*u*u*u*w + 12*u*u*w*w + 6*u*w*w*w + pow<4>(w) + 8*u*u*u*v + 36*u*u*v*w +
169                      36*u*v*w*w + 8*v*w*w*w + 24*u*u*v*v + 60*u*v*v*w + 24*v*v*w*w + 24*u*v*v*v + 24*v*v*v*w + 6*pow<4>(v));
170     case 7:
171       return factor*(pow<4>(u) + 8*u*u*u*w + 24*u*u*w*w + 24*u*w*w*w + 6*pow<4>(w) + 6*u*u*u*v + 36*u*u*v*w +
172                      60*u*v*w*w + 24*v*w*w*w + 12*u*u*v*v + 36*u*v*v*w + 24*v*v*w*w + 6*u*v*v*v + 8*v*v*v*w + pow<4>(v));
173     case 8:
174       return factor*(2*u*w*w*w + pow<4>(w));
175     case 9:
176       return factor*(2*v*v*v*w + pow<4>(v));
177     case 10:
178       return factor*(2*u*w*w*w + pow<4>(w) + 6*u*v*w*w + 6*v*w*w*w + 6*u*v*v*w + 12*v*v*w*w + 2*u*v*v*v +
179                      6*v*v*v*w + pow<4>(v));
180     case 11:
181       return factor*(pow<4>(w) + 2*v*w*w*w);
182 
183     default:
184       libmesh_error();
185     }
186 
187   libmesh_error();
188   return 0\&.;
189 }
.fi
.SS "\fBReal\fP libMesh::FESubdivision::regular_shape_deriv (const unsigned inti, const unsigned intj, const \fBReal\fPv, const \fBReal\fPw)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ of the 12 quartic box splines interpolating a regular Loop subdivision element, evaluated at the barycentric coordinates \fCv\fP, \fCw\fP\&. 
.RE
.PP

.PP
Definition at line 193 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
197 {
198   const Real u = 1 - v - w;
199   const Real factor = 1\&. / 12;
200 
201   switch (j) // j=0: xi-directional derivative, j=1: eta-directional derivative
202     {
203     case 0: // xi derivatives
204       {
205         switch (i) // shape function number
206           {
207           case 0:
208             return factor*(-6*v*u*u - 2*u*u*u);
209           case 1:
210             return factor*(-4*u*u*u - 6*u*u*w);
211           case 2:
212             return factor*(-2*v*v*v - 6*v*v*u + 6*v*u*u + 2*u*u*u);
213           case 3:
214             return factor*(-4*v*v*v - 24*v*v*u - 24*v*u*u - 18*v*v*w - 48*v*u*w - 12*u*u*w -
215                            12*v*w*w - 12*u*w*w - 2*w*w*w);
216           case 4:
217             return factor*(-6*v*u*u - 2*u*u*u - 12*v*u*w-12*u*u*w - 6*v*w*w - 18*u*w*w - 4*w*w*w);
218           case 5:
219             return factor*(2*v*v*v + 6*v*v*u);
220           case 6:
221             return factor*(24*v*v*u + 24*v*u*u + 4*u*u*u + 12*v*v*w + 48*v*u*w + 18*u*u*w +
222                            12*v*w*w + 12*u*w*w + 2*w*w*w);
223           case 7:
224             return factor*(-2*v*v*v - 6*v*v*u + 6*v*u*u + 2*u*u*u - 12*v*v*w + 12*u*u*w -
225                            12*v*w*w + 12*u*w*w);
226           case 8:
227             return -w*w*w/6;
228           case 9:
229             return factor*(4*v*v*v + 6*v*v*w);
230           case 10:
231             return factor*(2*v*v*v + 6*v*v*u + 12*v*v*w + 12*v*u*w + 18*v*w*w + 6*u*w*w + 4*w*w*w);
232           case 11:
233             return w*w*w/6;
234           default:
235             libmesh_error();
236           }
237       }
238     case 1: // eta derivatives
239       {
240         switch (i) // shape function number
241           {
242           case 0:
243             return factor*(-6*v*u*u - 4*u*u*u);
244           case 1:
245             return factor*(-2*u*u*u - 6*u*u*w);
246           case 2:
247             return factor*(-4*v*v*v - 18*v*v*u - 12*v*u*u - 2*u*u*u - 6*v*v*w - 12*v*u*w -
248                            6*u*u*w);
249           case 3:
250             return factor*(-2*v*v*v-12*v*v*u - 12*v*u*u - 12*v*v*w - 48*v*u*w - 24*u*u*w -
251                            18*v*w*w - 24*u*w*w - 4*w*w*w);
252           case 4:
253             return factor*(2*u*u*u + 6*u*u*w - 6*u*w*w - 2*w*w*w);
254           case 5:
255             return -v*v*v/6;
256           case 6:
257             return factor*(12*v*v*u + 12*v*u*u + 2*u*u*u - 12*v*v*w + 6*u*u*w - 12*v*w*w -
258                            6*u*w*w - 2*w*w*w);
259           case 7:
260             return factor*(2*v*v*v + 12*v*v*u + 18*v*u*u + 4*u*u*u + 12*v*v*w + 48*v*u*w +
261                            24*u*u*w + 12*v*w*w + 24*u*w*w);
262           case 8:
263             return factor*(6*u*w*w + 2*w*w*w);
264           case 9:
265             return v*v*v/6;
266           case 10:
267             return factor*(4*v*v*v + 6*v*v*u + 18*v*v*w + 12*v*u*w + 12*v*w*w + 6*u*w*w +
268                            2*w*w*w);
269           case 11:
270             return factor*(6*v*w*w + 4*w*w*w);
271           default:
272             libmesh_error();
273           }
274       }
275     default:
276       libmesh_error();
277     }
278 
279   libmesh_error();
280   return 0\&.;
281 }
.fi
.SS "\fBReal\fP libMesh::FESubdivision::regular_shape_second_deriv (const unsigned inti, const unsigned intj, const \fBReal\fPv, const \fBReal\fPw)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ of the 12 quartic box splines interpolating a regular Loop subdivision element, evaluated at the barycentric coordinates \fCv\fP, \fCw\fP\&. 
.RE
.PP

.PP
Definition at line 285 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::Real\&.
.PP
.nf
289 {
290   const Real u = 1 - v - w;
291   const Real factor = 1\&. / 12;
292 
293   switch (j)
294     {
295     case 0: // xi-xi derivative
296       {
297         switch (i) // shape function number
298           {
299           case 0:
300             return v*u;
301           case 1:
302             return u*u + u*w;
303           case 2:
304             return -2*v*u;
305           case 3:
306             return v*v - 2*u*u + v*w - 2*u*w;
307           case 4:
308             return v*u + v*w + u*w + w*w;
309           case 5:
310             return v*u;
311           case 6:
312             return factor*(-24*v*v + 12*u*u - 24*v*w + 12*u*w);
313           case 7:
314             return -2*v*u - 2*v*w - 2*u*w - 2*w*w;
315           case 8:
316             return 0\&.;
317           case 9:
318             return v*v + v*w;
319           case 10:
320             return v*u + v*w + u*w + w*w;
321           case 11:
322             return 0\&.;
323           default:
324             libmesh_error();
325           }
326       }
327     case 1: //eta-xi derivative
328       {
329         switch (i)
330           {
331           case 0:
332             return factor*(12*v*u + 6*u*u);
333           case 1:
334             return factor*(6*u*u + 12*u*w);
335           case 2:
336             return factor*(6*v*v - 12*v*u - 6*u*u);
337           case 3:
338             return factor*(6*v*v - 12*u*u + 24*v*w + 6*w*w);
339           case 4:
340             return factor*(-6*u*u - 12*u*w + 6*w*w);
341           case 5:
342             return -v*v/2\&.;
343           case 6:
344             return factor*(-12*v*v + 6*u*u - 24*v*w - 12*u*w - 6*w*w);
345           case 7:
346             return factor*(-6*v*v - 12*v*u + 6*u*u - 24*v*w - 12*w*w);
347           case 8:
348             return -w*w/2\&.;
349           case 9:
350             return v*v/2\&.;
351           case 10:
352             return factor*(6*v*v + 12*v*u + 24*v*w + 12*u*w + 6*w*w);
353           case 11:
354             return w*w/2\&.;
355           default:
356             libmesh_error();
357           }
358       }
359     case 2: // eta-eta derivative
360       {
361         switch (i)
362           {
363           case 0:
364             return v*u + u*u;
365           case 1:
366             return u*w;
367           case 2:
368             return v*v + v*u + v*w + u*w;
369           case 3:
370             return -2*v*u - 2*u*u + v*w + w*w;
371           case 4:
372             return -2*u*w;
373           case 5:
374             return 0\&.;
375           case 6:
376             return -2*v*v - 2*v*u - 2*v*w - 2*u*w;
377           case 7:
378             return v*u + u*u - 2*v*w - 2*w*w;
379           case 8:
380             return u*w;
381           case 9:
382             return 0\&.;
383           case 10:
384             return v*v + v*u + v*w + u*w;
385           case 11:
386             return v*w + w*w;
387           default:
388             libmesh_error();
389           }
390       }
391     default:
392       libmesh_error();
393     }
394 
395   libmesh_error();
396   return 0\&.;
397 }
.fi
.SS "void libMesh::FESubdivision::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [virtual]\fP"
This is at the core of this class\&. Use this for each new non-ghosted element in the mesh\&. Reinitializes all the physical element-dependent data based on the current element \fCelem\fP\&. By default the shape functions and associated data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but may be any points specified on the reference element specified in the optional argument \fCpts\fP\&. 
.PP
Reimplemented from \fBlibMesh::FE< 2, SUBDIVISION >\fP\&.
.PP
Definition at line 683 of file fe_subdivision_2D\&.C\&.
.PP
References libMesh::FEAbstract::_fe_map, libMesh::FEAbstract::dim, libMesh::QBase::get_points(), libMesh::QBase::get_weights(), libMesh::QBase::init(), init_shape_functions(), libMesh::libmesh_assert(), libMesh::FEAbstract::qrule, libMesh::FEAbstract::shapes_on_quadrature, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TRI3SUBDIVISION, and libMesh::Elem::type()\&.
.PP
.nf
686 {
687   libmesh_assert(elem);
688   libmesh_assert_equal_to(elem->type(), TRI3SUBDIVISION);
689   const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
690 
691   START_LOG("reinit()", "FESubdivision");
692 
693   libmesh_assert(!sd_elem->is_ghost());
694   libmesh_assert(sd_elem->is_subdivision_updated());
695 
696   // check if vertices 1 and 2 are regular
697   libmesh_assert_equal_to(sd_elem->get_ordered_valence(1), 6);
698   libmesh_assert_equal_to(sd_elem->get_ordered_valence(2), 6);
699 
700   // no custom quadrature support
701   libmesh_assert(pts == NULL);
702   libmesh_assert(qrule);
703   qrule->init(elem->type());
704 
705   // Initialize the shape functions
706   this->init_shape_functions(this->qrule->get_points(), elem);
707 
708   // The shape functions correspond to the qrule
709   shapes_on_quadrature = true;
710 
711   // Compute the map for this element\&.
712   this->_fe_map->compute_map (this->dim, this->qrule->get_weights(), elem);
713 
714   STOP_LOG("reinit()", "FESubdivision");
715 }
.fi
.SS "virtual void libMesh::FESubdivision::reinit (const \fBElem\fP *, const unsigned int, const \fBReal\fP = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *const = \fCNULL\fP, const std::vector< \fBReal\fP > *const = \fCNULL\fP)\fC [inline]\fP, \fC [virtual]\fP"
This prevents some compilers being confused by partially overriding this virtual function\&. 
.PP
Reimplemented from \fBlibMesh::FE< 2, SUBDIVISION >\fP\&.
.PP
Definition at line 604 of file fe\&.h\&.
.PP
.nf
609   { libmesh_error(); }
.fi
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the value of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the imension, element type, and order directly\&. This allows the method to be static\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function at point \fCp\fP\&. This method allows you to specify the dimension, element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $ j^{th} $ derivative of the $ i^{th} $ shape function\&. You must specify element type, and order directly\&.
.RE
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElemType\fPt, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the total order of the element\&. 
.SS "static \fBOutputShape\fP \fBlibMesh::FE\fP< Dim, T >::shape_second_deriv (const \fBElem\fP *elem, const \fBOrder\fPo, const unsigned inti, const unsigned intj, const \fBPoint\fP &p)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second $ j^{th} $ derivative of the $ i^{th} $ shape function at the point \fCp\fP\&. Note that cross-derivatives are also possible, i\&.e\&. j = 0 ==> d^2 phi / dxi^2 j = 1 ==> d^2 phi / dxi deta j = 2 ==> d^2 phi / deta^2 j = 3 ==> d^2 phi / dxi dzeta j = 4 ==> d^2 phi / deta dzeta j = 5 ==> d^2 phi / dzeta^2
.RE
.PP
Note: Computing second derivatives is not currently supported for all element types: C1 (Clough, Hermite and Subdivision), Lagrange, Hierarchic, L2_Hierarchic, and Monomial are supported\&. All other element types return an error when asked for second derivatives\&.
.PP
On a p-refined element, \fCo\fP should be the base order of the element\&. 
.SS "virtual bool \fBlibMesh::FE\fP< Dim, T >::shapes_need_reinit () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SS "virtual void \fBlibMesh::FE\fP< Dim, T >::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigned ints, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [virtual]\fP, \fC [inherited]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implements \fBlibMesh::FEAbstract\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_curvatures(), libMesh::FEAbstract::get_d2xyzdeta2(), libMesh::FEAbstract::get_d2xyzdetadzeta(), libMesh::FEAbstract::get_d2xyzdxi2(), libMesh::FEAbstract::get_d2xyzdxideta(), libMesh::FEAbstract::get_d2xyzdxidzeta(), libMesh::FEAbstract::get_d2xyzdzeta2(), libMesh::FEAbstract::get_detadx(), libMesh::FEAbstract::get_detady(), libMesh::FEAbstract::get_detadz(), libMesh::FEAbstract::get_dxidx(), libMesh::FEAbstract::get_dxidy(), libMesh::FEAbstract::get_dxidz(), libMesh::FEAbstract::get_dxyzdeta(), libMesh::FEAbstract::get_dxyzdxi(), libMesh::FEAbstract::get_dxyzdzeta(), libMesh::FEAbstract::get_dzetadx(), libMesh::FEAbstract::get_dzetady(), libMesh::FEAbstract::get_dzetadz(), libMesh::FEAbstract::get_fe_map(), libMesh::FEAbstract::get_JxW(), libMesh::FEAbstract::get_normals(), libMesh::FEAbstract::get_tangents(), libMesh::FEAbstract::get_xyz(), init_shape_functions(), libMesh::FEAbstract::print_JxW(), libMesh::FEAbstract::print_xyz(), and reinit()\&.
.SS "\fBAutoPtr\fP<\fBFETransformationBase\fP<OutputType> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::_fe_trans\fC [protected]\fP, \fC [inherited]\fP"
Object that handles computing shape function values, gradients, etc in the physical domain\&. 
.PP
Definition at line 489 of file fe_base\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP, \fC [inherited]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::get_order(), and libMesh::FEAbstract::get_p_level()\&.
.SS "std::vector<\fBPoint\fP> \fBlibMesh::FE\fP< Dim, T >::cached_nodes\fC [protected]\fP, \fC [inherited]\fP"
An array of the node locations on the last element we computed on 
.PP
Definition at line 473 of file fe\&.h\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::curl_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function curl values\&. Only defined for vector types\&. 
.PP
Definition at line 504 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputTensor\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivative values\&. 
.PP
Definition at line 547 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phideta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta direction\&. 
.PP
Definition at line 567 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidetadzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the eta-zeta direction\&. 
.PP
Definition at line 572 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidx2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x direction\&. 
.PP
Definition at line 582 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdy\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-y direction\&. 
.PP
Definition at line 587 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxdz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the x-z direction\&. 
.PP
Definition at line 592 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxi2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi direction\&. 
.PP
Definition at line 552 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-eta direction\&. 
.PP
Definition at line 557 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidxidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the xi-zeta direction\&. 
.PP
Definition at line 562 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidy2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y direction\&. 
.PP
Definition at line 597 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidydz\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the y-z direction\&. 
.PP
Definition at line 602 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidz2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the z direction\&. 
.PP
Definition at line 607 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::d2phidzeta2\fC [protected]\fP, \fC [inherited]\fP"
Shape function second derivatives in the zeta direction\&. 
.PP
Definition at line 577 of file fe_base\&.h\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP, \fC [inherited]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by reinit()\&.
.SS "std::vector<std::vector<\fBOutputDivergence\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::div_phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function divergence values\&. Only defined for vector types\&. 
.PP
Definition at line 509 of file fe_base\&.h\&.
.SS "std::vector<\fBOutputGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphase\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the first derivatives of the phase term in global coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 625 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputGradient\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivative values\&. 
.PP
Definition at line 499 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphideta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the eta direction\&. 
.PP
Definition at line 519 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidx\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the x direction\&. 
.PP
Definition at line 529 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidxi\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the xi direction\&. 
.PP
Definition at line 514 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidy\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the y direction\&. 
.PP
Definition at line 534 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidz\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the z direction\&. 
.PP
Definition at line 539 of file fe_base\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dphidzeta\fC [protected]\fP, \fC [inherited]\fP"
Shape function derivatives in the zeta direction\&. 
.PP
Definition at line 524 of file fe_base\&.h\&.
.SS "std::vector<\fBRealGradient\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::dweight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the global derivative of the additional radial weight $ 1/{r^2} $, over \fIall\fP quadrature points\&. 
.PP
Definition at line 632 of file fe_base\&.h\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP, \fC [inherited]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by attach_quadrature_rule(), and libMesh::FEAbstract::get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP, \fC [inherited]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEAbstract::compute_node_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEAbstract::get_family(), libMesh::FEAbstract::get_fe_type(), libMesh::FEAbstract::get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and init_shape_functions()\&.
.SS "unsigned int \fBlibMesh::FE\fP< Dim, T >::last_edge\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 480 of file fe\&.h\&.
.SS "\fBElemType\fP \fBlibMesh::FE\fP< Dim, T >::last_side\fC [protected]\fP, \fC [inherited]\fP"
The last side and last edge we did a reinit on 
.PP
Definition at line 478 of file fe\&.h\&.
.SS "std::vector<std::vector<\fBOutputShape\fP> > \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::phi\fC [protected]\fP, \fC [inherited]\fP"
Shape function values\&. 
.PP
Definition at line 494 of file fe_base\&.h\&.
.PP
Referenced by init_shape_functions()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP, \fC [inherited]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by attach_quadrature_rule(), and reinit()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP, \fC [inherited]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by reinit()\&.
.SS "std::vector<\fBReal\fP> \fBlibMesh::FEGenericBase\fP< \fBFEOutputType\fP< T >::type  >::weight\fC [protected]\fP, \fC [inherited]\fP"
Used for certain \fIinfinite\fP element families: the additional radial weight $ 1/{r^2} $ in local coordinates, over \fIall\fP quadrature points\&. 
.PP
Definition at line 639 of file fe_base\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
