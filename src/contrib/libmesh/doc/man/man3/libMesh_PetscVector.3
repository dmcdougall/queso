.TH "libMesh::PetscVector< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::PetscVector< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <petsc_vector\&.h>\fP
.PP
Inherits \fBlibMesh::NumericVector< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPetscVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBPetscVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP n, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBPetscVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP n, const \fBnumeric_index_type\fP \fBn_local\fP, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBPetscVector\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBnumeric_index_type\fP N, const \fBnumeric_index_type\fP \fBn_local\fP, const std::vector< \fBnumeric_index_type\fP > &ghost, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "\fBPetscVector\fP (Vec v, const \fBParallel::Communicator\fP &\fBcomm\fP LIBMESH_CAN_DEFAULT_TO_COMMWORLD)"
.br
.ti -1c
.RI "\fB~PetscVector\fP ()"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBzero_clone\fP () const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBclone\fP () const "
.br
.ti -1c
.RI "void \fBinit\fP (const \fBnumeric_index_type\fP N, const \fBnumeric_index_type\fP \fBn_local\fP, const bool fast=false, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "void \fBinit\fP (const \fBnumeric_index_type\fP N, const bool fast=false, const \fBParallelType\fP \fBtype\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "virtual void \fBinit\fP (const \fBnumeric_index_type\fP, const \fBnumeric_index_type\fP, const std::vector< \fBnumeric_index_type\fP > &, const bool=false, const \fBParallelType\fP=\fBAUTOMATIC\fP)"
.br
.ti -1c
.RI "virtual void \fBinit\fP (const \fBNumericVector\fP< T > &other, const bool fast=false)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const T s)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBPetscVector\fP< T > & \fBoperator=\fP (const \fBPetscVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator=\fP (const std::vector< T > &v)"
.br
.ti -1c
.RI "\fBReal\fP \fBmin\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBmax\fP () const "
.br
.ti -1c
.RI "T \fBsum\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBl1_norm\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBl2_norm\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBlinfty_norm\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBsize\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBlocal_size\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBfirst_local_index\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBlast_local_index\fP () const "
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fBmap_global_to_local_index\fP (const \fBnumeric_index_type\fP i) const "
.br
.ti -1c
.RI "T \fBoperator()\fP (const \fBnumeric_index_type\fP i) const "
.br
.ti -1c
.RI "virtual void \fBget\fP (const std::vector< \fBnumeric_index_type\fP > &index, std::vector< T > &values) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator+=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator-=\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "virtual void \fBreciprocal\fP ()"
.br
.ti -1c
.RI "virtual void \fBconjugate\fP ()"
.br
.ti -1c
.RI "void \fBset\fP (const \fBnumeric_index_type\fP i, const T value)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBnumeric_index_type\fP i, const T value)"
.br
.ti -1c
.RI "void \fBadd\fP (const T s)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBNumericVector\fP< T > &V)"
.br
.ti -1c
.RI "void \fBadd\fP (const T a, const \fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &\fBA\fP)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBadd_vector_transpose\fP (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)"
.br
.ti -1c
.RI "void \fBadd_vector_conjugate_transpose\fP (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "virtual void \fBinsert\fP (const \fBDenseSubVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)"
.br
.ti -1c
.RI "void \fBscale\fP (const T factor)"
.br
.ti -1c
.RI "virtual \fBNumericVector\fP< T > & \fBoperator/=\fP (\fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "virtual void \fBabs\fP ()"
.br
.ti -1c
.RI "virtual T \fBdot\fP (const \fBNumericVector\fP< T > &) const "
.br
.ti -1c
.RI "virtual T \fBindefinite_dot\fP (const \fBNumericVector\fP< T > &) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (std::vector< T > &v_local) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (\fBNumericVector\fP< T > &v_local) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (\fBNumericVector\fP< T > &v_local, const std::vector< \fBnumeric_index_type\fP > &send_list) const "
.br
.ti -1c
.RI "void \fBlocalize\fP (const \fBnumeric_index_type\fP first_local_idx, const \fBnumeric_index_type\fP last_local_idx, const std::vector< \fBnumeric_index_type\fP > &send_list)"
.br
.ti -1c
.RI "void \fBlocalize_to_one\fP (std::vector< T > &v_local, const \fBprocessor_id_type\fP proc_id=0) const "
.br
.ti -1c
.RI "virtual void \fBpointwise_mult\fP (const \fBNumericVector\fP< T > &vec1, const \fBNumericVector\fP< T > &vec2)"
.br
.ti -1c
.RI "virtual void \fBprint_matlab\fP (const std::string &name='') const "
.br
.ti -1c
.RI "virtual void \fBcreate_subvector\fP (\fBNumericVector\fP< T > &subvector, const std::vector< \fBnumeric_index_type\fP > &rows) const "
.br
.ti -1c
.RI "virtual void \fBswap\fP (\fBNumericVector\fP< T > &v)"
.br
.ti -1c
.RI "Vec \fBvec\fP ()"
.br
.ti -1c
.RI "template<> void \fBlocalize_to_one\fP (std::vector< \fBReal\fP > &v_local, const \fBprocessor_id_type\fP pid) const"
.br
.ti -1c
.RI "template<> void \fBlocalize_to_one\fP (std::vector< \fBComplex\fP > &v_local, const \fBprocessor_id_type\fP pid) const"
.br
.ti -1c
.RI "virtual bool \fBinitialized\fP () const "
.br
.ti -1c
.RI "\fBParallelType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "\fBParallelType\fP & \fBtype\fP ()"
.br
.ti -1c
.RI "virtual bool \fBclosed\fP () const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_l1_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_l2_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBsubset_linfty_norm\fP (const std::set< \fBnumeric_index_type\fP > &indices) const "
.br
.ti -1c
.RI "virtual T \fBel\fP (const \fBnumeric_index_type\fP i) const "
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator*=\fP (const T a)"
.br
.ti -1c
.RI "\fBNumericVector\fP< T > & \fBoperator/=\fP (const T a)"
.br
.ti -1c
.RI "void \fBadd_vector\fP (const \fBNumericVector\fP< T > &v, const \fBShellMatrix\fP< T > &a)"
.br
.ti -1c
.RI "virtual int \fBcompare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual int \fBlocal_relative_compare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual int \fBglobal_relative_compare\fP (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fP threshold=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "template<> void \fBprint\fP (std::ostream &os) const"
.br
.ti -1c
.RI "virtual void \fBprint_global\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "template<> void \fBprint_global\fP (std::ostream &os) const"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBbuild\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBNumericVector\fP
.br
< T > > \fBbuild\fP (const \fBSolverPackage\fP solver_package=\fBlibMesh::default_solver_package\fP())"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fB_is_closed\fP"
.br
.ti -1c
.RI "bool \fB_is_initialized\fP"
.br
.ti -1c
.RI "\fBParallelType\fP \fB_type\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef 
.br
LIBMESH_BEST_UNORDERED_MAP
.br
< \fBnumeric_index_type\fP, 
.br
\fBnumeric_index_type\fP > \fBGlobalToLocalMap\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fB_get_array\fP (void) const "
.br
.ti -1c
.RI "void \fB_restore_array\fP (void) const "
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Vec \fB_vec\fP"
.br
.ti -1c
.RI "bool \fB_array_is_present\fP"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fB_first\fP"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fB_last\fP"
.br
.ti -1c
.RI "\fBnumeric_index_type\fP \fB_local_size\fP"
.br
.ti -1c
.RI "Vec \fB_local_form\fP"
.br
.ti -1c
.RI "PetscScalar * \fB_values\fP"
.br
.ti -1c
.RI "\fBGlobalToLocalMap\fP \fB_global_to_local_map\fP"
.br
.ti -1c
.RI "bool \fB_destroy_vec_on_exit\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::PetscVector< T >"
Petsc vector\&. Provides a nice interface to the Petsc C-based data structures for parallel vectors\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2002 
.RE
.PP

.PP
Definition at line 63 of file petsc_vector\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "template<typename T> typedef LIBMESH_BEST_UNORDERED_MAP<\fBnumeric_index_type\fP,\fBnumeric_index_type\fP> \fBlibMesh::PetscVector\fP< T >::\fBGlobalToLocalMap\fP\fC [private]\fP"
Type for map that maps global to local ghost cells\&. 
.PP
Definition at line 612 of file petsc_vector\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBlibMesh::PetscVector\fP< T >::\fBPetscVector\fP (const \fBParallel::Communicator\fP &comm, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [explicit]\fP"
Dummy-Constructor\&. Dimension=0 
.PP
Definition at line 634 of file petsc_vector\&.h\&.
.PP
References libMesh::NumericVector< T >::_type\&.
.PP
.nf
635   : NumericVector<T>(comm, ptype),
636     _array_is_present(false),
637     _first(0),
638     _last(0),
639     _local_form(NULL),
640     _values(NULL),
641     _global_to_local_map(),
642     _destroy_vec_on_exit(true)
643 {
644   this->_type = ptype;
645 }
.fi
.SS "template<typename T > \fBlibMesh::PetscVector\fP< T >::\fBPetscVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPn, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. Set dimension to \fCn\fP and initialize all elements with zero\&. 
.PP
Definition at line 651 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::init()\&.
.PP
.nf
654   : NumericVector<T>(comm, ptype),
655     _array_is_present(false),
656     _local_form(NULL),
657     _values(NULL),
658     _global_to_local_map(),
659     _destroy_vec_on_exit(true)
660 {
661   this->init(n, n, false, ptype);
662 }
.fi
.SS "template<typename T > \fBlibMesh::PetscVector\fP< T >::\fBPetscVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPn, const \fBnumeric_index_type\fPn_local, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP"
Constructor\&. Set local dimension to \fCn_local\fP, the global dimension to \fCn\fP, and initialize all elements with zero\&. 
.PP
Definition at line 668 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::init()\&.
.PP
.nf
672   : NumericVector<T>(comm, ptype),
673     _array_is_present(false),
674     _local_form(NULL),
675     _values(NULL),
676     _global_to_local_map(),
677     _destroy_vec_on_exit(true)
678 {
679   this->init(n, n_local, false, ptype);
680 }
.fi
.SS "template<typename T > \fBlibMesh::PetscVector\fP< T >::\fBPetscVector\fP (const \fBParallel::Communicator\fP &comm, const \fBnumeric_index_type\fPN, const \fBnumeric_index_type\fPn_local, const std::vector< \fBnumeric_index_type\fP > &ghost, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP"
Constructor\&. Set local dimension to \fCn_local\fP, the global dimension to \fCn\fP, but additionally reserve memory for the indices specified by the \fCghost\fP argument\&. 
.PP
Definition at line 686 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::init()\&.
.PP
.nf
691   : NumericVector<T>(comm, ptype),
692     _array_is_present(false),
693     _local_form(NULL),
694     _values(NULL),
695     _global_to_local_map(),
696     _destroy_vec_on_exit(true)
697 {
698   this->init(n, n_local, ghost, false, ptype);
699 }
.fi
.SS "template<typename T> \fBlibMesh::PetscVector\fP< T >::\fBPetscVector\fP (Vecv, const \fBParallel::Communicator\fP &\fBcomm\fPLIBMESH_CAN_DEFAULT_TO_COMMWORLD)"
Constructor\&. Creates a \fBPetscVector\fP assuming you already have a valid PETSc Vec object\&. In this case, \fCv\fP is NOT destroyed by the \fBPetscVector\fP constructor when this object goes out of scope\&. This allows ownership of \fCv\fP to remain with the original creator, and to simply provide additional functionality with the \fBPetscVector\fP\&. 
.SS "template<typename T > \fBlibMesh::PetscVector\fP< T >::~\fBPetscVector\fP ()\fC [inline]\fP"
Destructor, deallocates memory\&. Made virtual to allow for derived classes to behave properly\&. 
.PP
Definition at line 791 of file petsc_vector\&.h\&.
.PP
.nf
792 {
793   this->clear ();
794 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::_get_array (void) const\fC [inline]\fP, \fC [private]\fP"
Queries the array (and the local form if the vector is ghosted) from Petsc\&. 
.PP
Definition at line 1352 of file petsc_vector\&.h\&.
.PP
References libMesh::GHOSTED, libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1353 {
1354   libmesh_assert (this->initialized());
1355   if(!_array_is_present)
1356     {
1357       PetscErrorCode ierr=0;
1358       if(this->type() != GHOSTED)
1359         {
1360           ierr = VecGetArray(_vec, &_values);
1361           LIBMESH_CHKERRABORT(ierr);
1362         }
1363       else
1364         {
1365           ierr = VecGhostGetLocalForm (_vec,&_local_form);
1366           LIBMESH_CHKERRABORT(ierr);
1367           ierr = VecGetArray(_local_form, &_values);
1368           LIBMESH_CHKERRABORT(ierr);
1369 #ifndef NDEBUG
1370           PetscInt my_local_size = 0;
1371           ierr = VecGetLocalSize(_local_form, &my_local_size);
1372           LIBMESH_CHKERRABORT(ierr);
1373           _local_size = static_cast<numeric_index_type>(my_local_size);
1374 #endif
1375         }
1376 
1377       { // cache ownership range
1378         PetscErrorCode ierr=0;
1379         PetscInt petsc_first=0, petsc_last=0;
1380         ierr = VecGetOwnershipRange (_vec, &petsc_first, &petsc_last);
1381         LIBMESH_CHKERRABORT(ierr);
1382         _first = static_cast<numeric_index_type>(petsc_first);
1383         _last = static_cast<numeric_index_type>(petsc_last);
1384       }
1385 
1386       _array_is_present = true;
1387     }
1388 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::_restore_array (void) const\fC [inline]\fP, \fC [private]\fP"
Restores the array (and the local form if the vector is ghosted) to Petsc\&. 
.PP
Definition at line 1394 of file petsc_vector\&.h\&.
.PP
References libMesh::GHOSTED, libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::PetscVector< T >::add(), libMesh::PetscVector< T >::create_subvector(), libMesh::PetscVector< T >::init(), and libMesh::PetscVector< T >::operator=()\&.
.PP
.nf
1395 {
1396   libmesh_assert (this->initialized());
1397   if(_array_is_present)
1398     {
1399       PetscErrorCode ierr=0;
1400       if(this->type() != GHOSTED)
1401         {
1402           ierr = VecRestoreArray (_vec, &_values);
1403           LIBMESH_CHKERRABORT(ierr);
1404           _values = NULL;
1405         }
1406       else
1407         {
1408           ierr = VecRestoreArray (_local_form, &_values);
1409           LIBMESH_CHKERRABORT(ierr);
1410           _values = NULL;
1411           ierr = VecGhostRestoreLocalForm (_vec,&_local_form);
1412           LIBMESH_CHKERRABORT(ierr);
1413           _local_form = NULL;
1414 #ifndef NDEBUG
1415           _local_size = 0;
1416 #endif
1417         }
1418       _array_is_present = false;
1419     }
1420 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::abs ()\fC [virtual]\fP"
v = abs(v)\&.\&.\&. that is, each entry in v is replaced by its absolute value\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 565 of file petsc_vector\&.C\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
566 {
567   this->_restore_array();
568 
569   PetscErrorCode ierr = 0;
570 
571   if(this->type() != GHOSTED)
572     {
573       ierr = VecAbs(_vec);
574       LIBMESH_CHKERRABORT(ierr);
575     }
576   else
577     {
578       Vec loc_vec;
579       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
580       LIBMESH_CHKERRABORT(ierr);
581 
582       ierr = VecAbs(loc_vec);
583       LIBMESH_CHKERRABORT(ierr);
584 
585       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
586       LIBMESH_CHKERRABORT(ierr);
587     }
588 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add (const \fBnumeric_index_type\fPi, const Tvalue)\fC [virtual]\fP"
v(i) += value 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 191 of file petsc_vector\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
192 {
193   this->_restore_array();
194   libmesh_assert_less (i, size());
195 
196   PetscErrorCode ierr=0;
197   PetscInt i_val = static_cast<PetscInt>(i);
198   PetscScalar petsc_value = static_cast<PetscScalar>(value);
199 
200   ierr = VecSetValues (_vec, 1, &i_val, &petsc_value, ADD_VALUES);
201   LIBMESH_CHKERRABORT(ierr);
202 
203   this->_is_closed = false;
204 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add (const Ts)\fC [virtual]\fP"
$U(0-LIBMESH_DIM)+=s$\&. Addition of \fCs\fP to all components\&. Note that \fCs\fP is a scalar and not a vector\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 336 of file petsc_vector\&.C\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
337 {
338   this->_restore_array();
339 
340   PetscErrorCode ierr=0;
341   PetscScalar* values;
342   const PetscScalar v = static_cast<PetscScalar>(v_in);
343 
344   if(this->type() != GHOSTED)
345     {
346       const PetscInt n   = static_cast<PetscInt>(this->local_size());
347       const PetscInt fli = static_cast<PetscInt>(this->first_local_index());
348 
349       for (PetscInt i=0; i<n; i++)
350         {
351           ierr = VecGetArray (_vec, &values);
352           LIBMESH_CHKERRABORT(ierr);
353 
354           PetscInt ig = fli + i;
355 
356           PetscScalar value = (values[i] + v);
357 
358           ierr = VecRestoreArray (_vec, &values);
359           LIBMESH_CHKERRABORT(ierr);
360 
361           ierr = VecSetValues (_vec, 1, &ig, &value, INSERT_VALUES);
362           LIBMESH_CHKERRABORT(ierr);
363         }
364     }
365   else
366     {
367       /* Vectors that include ghost values require a special
368          handling\&.  */
369       Vec loc_vec;
370       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
371       LIBMESH_CHKERRABORT(ierr);
372 
373       PetscInt n=0;
374       ierr = VecGetSize(loc_vec, &n);
375       LIBMESH_CHKERRABORT(ierr);
376 
377       for (PetscInt i=0; i<n; i++)
378         {
379           ierr = VecGetArray (loc_vec, &values);
380           LIBMESH_CHKERRABORT(ierr);
381 
382           PetscScalar value = (values[i] + v);
383 
384           ierr = VecRestoreArray (loc_vec, &values);
385           LIBMESH_CHKERRABORT(ierr);
386 
387           ierr = VecSetValues (loc_vec, 1, &i, &value, INSERT_VALUES);
388           LIBMESH_CHKERRABORT(ierr);
389         }
390 
391       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
392       LIBMESH_CHKERRABORT(ierr);
393     }
394 
395   this->_is_closed = false;
396 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
$ U+=V $ \&. Simple vector addition, equal to the \fCoperator\fP +=\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 401 of file petsc_vector\&.C\&.
.PP
.nf
402 {
403   this->add (1\&., v);
404 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add (const Ta, const \fBNumericVector\fP< T > &v)\fC [virtual]\fP"
$ U+=a*V $ \&. Simple vector addition, equal to the \fCoperator\fP +=\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 409 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_restore_array(), libMesh::PetscVector< T >::_vec, libMesh::GHOSTED, and libMesh::PetscVector< T >::size()\&.
.PP
.nf
410 {
411   this->_restore_array();
412 
413   PetscErrorCode ierr = 0;
414   PetscScalar a = static_cast<PetscScalar>(a_in);
415 
416   // Make sure the NumericVector passed in is really a PetscVector
417   const PetscVector<T>* v = libmesh_cast_ptr<const PetscVector<T>*>(&v_in);
418   v->_restore_array();
419 
420   libmesh_assert_equal_to (this->size(), v->size());
421 
422   if(this->type() != GHOSTED)
423     {
424 #if PETSC_VERSION_LESS_THAN(2,3,0)
425       // 2\&.2\&.x & earlier style
426       ierr = VecAXPY(&a, v->_vec, _vec);
427       LIBMESH_CHKERRABORT(ierr);
428 #else
429       // 2\&.3\&.x & later style
430       ierr = VecAXPY(_vec, a, v->_vec);
431       LIBMESH_CHKERRABORT(ierr);
432 #endif
433     }
434   else
435     {
436       Vec loc_vec;
437       Vec v_loc_vec;
438       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
439       LIBMESH_CHKERRABORT(ierr);
440       ierr = VecGhostGetLocalForm (v->_vec,&v_loc_vec);
441       LIBMESH_CHKERRABORT(ierr);
442 
443 #if PETSC_VERSION_LESS_THAN(2,3,0)
444       // 2\&.2\&.x & earlier style
445       ierr = VecAXPY(&a, v_loc_vec, loc_vec);
446       LIBMESH_CHKERRABORT(ierr);
447 #else
448       // 2\&.3\&.x & later style
449       ierr = VecAXPY(loc_vec, a, v_loc_vec);
450       LIBMESH_CHKERRABORT(ierr);
451 #endif
452 
453       ierr = VecGhostRestoreLocalForm (v->_vec,&v_loc_vec);
454       LIBMESH_CHKERRABORT(ierr);
455       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
456       LIBMESH_CHKERRABORT(ierr);
457     }
458 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U+=v $ where \fCv\fP is a std::vector<T> and you want to specify WHERE to add it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 209 of file petsc_vector\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
211 {
212   // If we aren't adding anything just return
213   if(v\&.empty() || dof_indices\&.empty())
214     return;
215 
216   this->_restore_array();
217   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
218 
219   PetscErrorCode ierr=0;
220   const PetscInt * i_val = reinterpret_cast<const PetscInt*>(&dof_indices[0]);
221   const PetscScalar * petsc_value = static_cast<const PetscScalar*>(&v[0]);
222 
223   ierr = VecSetValues (_vec, v\&.size(), i_val, petsc_value, ADD_VALUES);
224   LIBMESH_CHKERRABORT(ierr);
225 
226   this->_is_closed = false;
227 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U+=V $ where U and V are type \fCNumericVector<T>\fP and you want to specify WHERE to add the \fCNumericVector<T>\fP V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 232 of file petsc_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::size()\&.
.PP
.nf
234 {
235   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
236 
237   for (unsigned int i=0; i<V\&.size(); i++)
238     this->add (dof_indices[i], V(i));
239 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A)\fC [virtual]\fP"
$U+=A*V$, add the product of a \fC\fBSparseMatrix\fP\fP \fCA\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 244 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec, A, and libMesh::ierr\&.
.PP
.nf
246 {
247   this->_restore_array();
248   // Make sure the data passed in are really of Petsc types
249   const PetscVector<T>* V = libmesh_cast_ptr<const PetscVector<T>*>(&V_in);
250   const PetscMatrix<T>* A = libmesh_cast_ptr<const PetscMatrix<T>*>(&A_in);
251 
252   PetscErrorCode ierr=0;
253 
254   A->close();
255 
256   // The const_cast<> is not elegant, but it is required since PETSc
257   // is not const-correct\&.
258   ierr = MatMultAdd(const_cast<PetscMatrix<T>*>(A)->mat(), V->_vec, _vec, _vec);
259   LIBMESH_CHKERRABORT(ierr);
260 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$U+=V $ where U and V are type DenseVector<T> and you want to specify WHERE to add the DenseVector<T> V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 265 of file petsc_vector\&.C\&.
.PP
References libMesh::DenseVector< T >::size()\&.
.PP
.nf
267 {
268   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
269 
270   for (unsigned int i=0; i<V\&.size(); i++)
271     this->add (dof_indices[i], V(i));
272 }
.fi
.SS "template<typename T> void \fBlibMesh::NumericVector\fP< T >::add_vector (const \fBNumericVector\fP< T > &v, const \fBShellMatrix\fP< T > &a)\fC [inherited]\fP"
$U+=A*V$, add the product of a \fC\fBShellMatrix\fP\fP \fCA\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Definition at line 380 of file numeric_vector\&.C\&.
.PP
References libMesh::ShellMatrix< T >::vector_mult_add()\&.
.PP
.nf
382 {
383   a\&.vector_mult_add(*this,v);
384 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector_conjugate_transpose (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)"
$U+=A^H*V$, add the product of the conjugate-transpose of \fC\fBSparseMatrix\fP\fP \fCA_trans\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Definition at line 297 of file petsc_vector\&.C\&.
.PP
References libMesh::out\&.
.PP
.nf
299 {
300 
301   libMesh::out << "MatMultHermitianTranspose was introduced in PETSc 3\&.1\&.0,"
302                << "No one has made it backwards compatible with older "
303                << "versions of PETSc so far\&." << std::endl;
304   libmesh_error();
305 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::add_vector_transpose (const \fBNumericVector\fP< T > &V, const \fBSparseMatrix\fP< T > &A_trans)\fC [virtual]\fP"
$U+=A^T*V$, add the product of the transpose of \fC\fBSparseMatrix\fP\fP \fCA_trans\fP and a \fC\fBNumericVector\fP\fP \fCV\fP to \fCthis\fP, where \fCthis=U\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 276 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec, A, and libMesh::ierr\&.
.PP
.nf
278 {
279   this->_restore_array();
280   // Make sure the data passed in are really of Petsc types
281   const PetscVector<T>* V = libmesh_cast_ptr<const PetscVector<T>*>(&V_in);
282   const PetscMatrix<T>* A = libmesh_cast_ptr<const PetscMatrix<T>*>(&A_in);
283 
284   PetscErrorCode ierr=0;
285 
286   A->close();
287 
288   // The const_cast<> is not elegant, but it is required since PETSc
289   // is not const-correct\&.
290   ierr = MatMultTransposeAdd(const_cast<PetscMatrix<T>*>(A)->mat(), V->_vec, _vec, _vec);
291   LIBMESH_CHKERRABORT(ierr);
292 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::NumericVector\fP< T >::build (const \fBParallel::Communicator\fP &comm, const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBNumericVector\fP\fP on the processors in communicator \fCcomm\fP using the linear solver package specified by \fCsolver_package\fP 
.PP
Definition at line 46 of file numeric_vector\&.C\&.
.PP
References libMesh::AUTOMATIC, libMesh::EIGEN_SOLVERS, libMesh::LASPACK_SOLVERS, libMesh::PETSC_SOLVERS, and libMesh::TRILINOS_SOLVERS\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::add_vector(), libMesh::NumericVector< T >::build(), libMesh::EquationSystems::build_solution_vector(), libMesh::System::calculate_norm(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::EquationSystems::get_solution(), and libMesh::System::project_vector()\&.
.PP
.nf
47 {
48   // Build the appropriate vector
49   switch (solver_package)
50     {
51 
52 
53 #ifdef LIBMESH_HAVE_LASPACK
54     case LASPACK_SOLVERS:
55       {
56         AutoPtr<NumericVector<T> > ap(new LaspackVector<T>(comm, AUTOMATIC));
57         return ap;
58       }
59 #endif
60 
61 
62 #ifdef LIBMESH_HAVE_PETSC
63     case PETSC_SOLVERS:
64       {
65         AutoPtr<NumericVector<T> > ap(new PetscVector<T>(comm, AUTOMATIC));
66         return ap;
67       }
68 #endif
69 
70 
71 #ifdef LIBMESH_HAVE_TRILINOS
72     case TRILINOS_SOLVERS:
73       {
74         AutoPtr<NumericVector<T> > ap(new EpetraVector<T>(comm, AUTOMATIC));
75         return ap;
76       }
77 #endif
78 
79 
80 #ifdef LIBMESH_HAVE_EIGEN
81     case EIGEN_SOLVERS:
82       {
83         AutoPtr<NumericVector<T> > ap(new EigenSparseVector<T>(comm, AUTOMATIC));
84         return ap;
85       }
86 #endif
87 
88 
89     default:
90       AutoPtr<NumericVector<T> > ap(new DistributedVector<T>(comm, AUTOMATIC));
91       return ap;
92 
93     }
94 
95   AutoPtr<NumericVector<T> > ap(NULL);
96   return ap;
97 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::NumericVector\fP< T >::build (const \fBSolverPackage\fPsolver_package = \fC\fBlibMesh::default_solver_package\fP()\fP)\fC [static]\fP, \fC [inherited]\fP"
Builds a \fC\fBNumericVector\fP\fP on the processors in communicator CommWorld using the linear solver package specified by \fCsolver_package\fP\&. Deprecated\&. 
.PP
Definition at line 103 of file numeric_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::build(), and libMesh::CommWorld\&.
.PP
.nf
104 {
105   libmesh_deprecated();
106   return NumericVector<T>::build(CommWorld, solver_package);
107 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::clear ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCPetscVector<T>\fP to a pristine state\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1006 of file petsc_vector\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, and libMesh::initialized()\&.
.PP
.nf
1007 {
1008   if (this->initialized())
1009     this->_restore_array();
1010 
1011   if ((this->initialized()) && (this->_destroy_vec_on_exit))
1012     {
1013       PetscErrorCode ierr=0;
1014 
1015       ierr = LibMeshVecDestroy(&_vec);
1016       LIBMESH_CHKERRABORT(ierr);
1017     }
1018 
1019   this->_is_closed = this->_is_initialized = false;
1020 
1021   _global_to_local_map\&.clear();
1022 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::PetscVector\fP< T >::clone () const\fC [inline]\fP, \fC [virtual]\fP"
Creates a copy of this vector and returns it in an \fC\fBAutoPtr\fP\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1089 of file petsc_vector\&.h\&.
.PP
References libMesh::comm\&.
.PP
.nf
1090 {
1091   AutoPtr<NumericVector<T> > cloned_vector
1092     (new PetscVector<T>(this->comm(), this->type()));
1093 
1094   cloned_vector->init(*this, true);
1095 
1096   *cloned_vector = *this;
1097 
1098   return cloned_vector;
1099 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::close ()\fC [inline]\fP, \fC [virtual]\fP"
Call the assemble functions 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 980 of file petsc_vector\&.h\&.
.PP
References libMesh::GHOSTED\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::SlepcEigenSolver< T >::get_eigenpair(), libMesh::PetscVector< T >::localize(), and libMesh::PetscLinearSolver< T >::solve()\&.
.PP
.nf
981 {
982   this->_restore_array();
983 
984   PetscErrorCode ierr=0;
985 
986   ierr = VecAssemblyBegin(_vec);
987   LIBMESH_CHKERRABORT(ierr);
988   ierr = VecAssemblyEnd(_vec);
989   LIBMESH_CHKERRABORT(ierr);
990 
991   if(this->type() == GHOSTED)
992     {
993       ierr = VecGhostUpdateBegin(_vec,INSERT_VALUES,SCATTER_FORWARD);
994       LIBMESH_CHKERRABORT(ierr);
995       ierr = VecGhostUpdateEnd(_vec,INSERT_VALUES,SCATTER_FORWARD);
996       LIBMESH_CHKERRABORT(ierr);
997     }
998 
999   this->_is_closed = true;
1000 }
.fi
.SS "template<typename T> virtual bool \fBlibMesh::NumericVector\fP< T >::closed () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the vector is closed and ready for computation, false otherwise\&. 
.RE
.PP

.PP
Definition at line 145 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::DofMap::max_constraint_error(), libMesh::LaspackVector< T >::operator=(), libMesh::EigenSparseVector< T >::operator=(), and libMesh::PetscVector< T >::operator=()\&.
.PP
.nf
145 { return _is_closed; }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given \fCthreshold\fP\&. When differences occur, the return value contains the first index \fCi\fP where the difference \fC\fP(a[i]-b[i]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 112 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), and std::max()\&.
.PP
.nf
114 {
115   libmesh_assert (this->initialized());
116   libmesh_assert (other_vector\&.initialized());
117   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
118   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
119 
120   int first_different_i = std::numeric_limits<int>::max();
121   numeric_index_type i = first_local_index();
122 
123   do
124     {
125       if ( std::abs( (*this)(i) - other_vector(i) ) > threshold )
126         first_different_i = i;
127       else
128         i++;
129     }
130   while (first_different_i==std::numeric_limits<int>::max()
131          && i<last_local_index());
132 
133   // Find the correct first differing index in parallel
134   this->comm()\&.min(first_different_i);
135 
136   if (first_different_i == std::numeric_limits<int>::max())
137     return -1;
138 
139   return first_different_i;
140 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::conjugate ()\fC [virtual]\fP"
Replace each entry v_i = real(v_i) + imag(v_i) of this vector by its complex conjugate, real(v_i) - imag(v_i) 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 179 of file petsc_vector\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
180 {
181   PetscErrorCode ierr = 0;
182 
183   // We just call the PETSc VecConjugate
184   ierr = VecConjugate(_vec);
185   LIBMESH_CHKERRABORT(ierr);
186 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::create_subvector (\fBNumericVector\fP< T > &subvector, const std::vector< \fBnumeric_index_type\fP > &rows) const\fC [virtual]\fP"
Creates a 'subvector' from this vector using the rows indices of the 'rows' array\&. 
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1390 of file petsc_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::_is_initialized, libMesh::PetscVector< T >::_restore_array(), libMesh::PetscVector< T >::_vec, libMesh::comm, libMesh::MeshTools::Generation::Private::idx(), libMesh::NumericVector< T >::initialized(), libMesh::Utility::iota(), and PETSC_USE_POINTER\&.
.PP
.nf
1392 {
1393   this->_restore_array();
1394 
1395   // PETSc data structures
1396   IS parent_is, subvector_is;
1397   VecScatter scatter;
1398   PetscErrorCode ierr = 0;
1399 
1400   // Make sure the passed in subvector is really a PetscVector
1401   PetscVector<T>* petsc_subvector = libmesh_cast_ptr<PetscVector<T>*>(&subvector);
1402 
1403   // If the petsc_subvector is already initialized, we assume that the
1404   // user has already allocated the *correct* amount of space for it\&.
1405   // If not, we use the appropriate PETSc routines to initialize it\&.
1406   if (!petsc_subvector->initialized())
1407     {
1408       // Initialize the petsc_subvector to have enough space to hold
1409       // the entries which will be scattered into it\&.  Note: such an
1410       // init() function (where we let PETSc decide the number of local
1411       // entries) is not currently offered by the PetscVector
1412       // class\&.  Should we differentiate here between sequential and
1413       // parallel vector creation based on this->n_processors() ?
1414       ierr = VecCreateMPI(this->comm()\&.get(),
1415                           PETSC_DECIDE,          // n_local
1416                           rows\&.size(),           // n_global
1417                           &(petsc_subvector->_vec)); LIBMESH_CHKERRABORT(ierr);
1418 
1419       ierr = VecSetFromOptions (petsc_subvector->_vec); LIBMESH_CHKERRABORT(ierr);
1420 
1421       // Mark the subvector as initialized
1422       petsc_subvector->_is_initialized = true;
1423     }
1424   else
1425     {
1426       petsc_subvector->_restore_array();
1427     }
1428 
1429   // Use iota to fill an array with entries [0,1,2,3,4,\&.\&.\&.rows\&.size()]
1430   std::vector<PetscInt> idx(rows\&.size());
1431   Utility::iota (idx\&.begin(), idx\&.end(), 0);
1432 
1433   // Construct index sets
1434   ierr = ISCreateLibMesh(this->comm()\&.get(),
1435                          rows\&.size(),
1436                          (PetscInt*) &rows[0],
1437                          PETSC_USE_POINTER,
1438                          &parent_is); LIBMESH_CHKERRABORT(ierr);
1439 
1440   ierr = ISCreateLibMesh(this->comm()\&.get(),
1441                          rows\&.size(),
1442                          (PetscInt*) &idx[0],
1443                          PETSC_USE_POINTER,
1444                          &subvector_is); LIBMESH_CHKERRABORT(ierr);
1445 
1446   // Construct the scatter object
1447   ierr = VecScatterCreate(this->_vec,
1448                           parent_is,
1449                           petsc_subvector->_vec,
1450                           subvector_is,
1451                           &scatter); LIBMESH_CHKERRABORT(ierr);
1452 
1453   // Actually perform the scatter
1454 #if PETSC_VERSION_LESS_THAN(2,3,3)
1455   ierr = VecScatterBegin(this->_vec,
1456                          petsc_subvector->_vec,
1457                          INSERT_VALUES,
1458                          SCATTER_FORWARD,
1459                          scatter); LIBMESH_CHKERRABORT(ierr);
1460 
1461   ierr = VecScatterEnd(this->_vec,
1462                        petsc_subvector->_vec,
1463                        INSERT_VALUES,
1464                        SCATTER_FORWARD,
1465                        scatter); LIBMESH_CHKERRABORT(ierr);
1466 #else
1467   // API argument order change in PETSc 2\&.3\&.3
1468   ierr = VecScatterBegin(scatter,
1469                          this->_vec,
1470                          petsc_subvector->_vec,
1471                          INSERT_VALUES,
1472                          SCATTER_FORWARD); LIBMESH_CHKERRABORT(ierr);
1473 
1474   ierr = VecScatterEnd(scatter,
1475                        this->_vec,
1476                        petsc_subvector->_vec,
1477                        INSERT_VALUES,
1478                        SCATTER_FORWARD); LIBMESH_CHKERRABORT(ierr);
1479 #endif
1480 
1481   // Clean up
1482   ierr = LibMeshISDestroy(&parent_is);       LIBMESH_CHKERRABORT(ierr);
1483   ierr = LibMeshISDestroy(&subvector_is);    LIBMESH_CHKERRABORT(ierr);
1484   ierr = LibMeshVecScatterDestroy(&scatter); LIBMESH_CHKERRABORT(ierr);
1485 
1486 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "template<typename T > T \fBlibMesh::PetscVector\fP< T >::dot (const \fBNumericVector\fP< T > &V) const\fC [virtual]\fP"
Computes the dot product, p = U\&.V\&. Use complex-conjugate of V in the complex-valued case\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 591 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec\&.
.PP
.nf
592 {
593   this->_restore_array();
594 
595   // Error flag
596   PetscErrorCode ierr = 0;
597 
598   // Return value
599   PetscScalar value=0\&.;
600 
601   // Make sure the NumericVector passed in is really a PetscVector
602   const PetscVector<T>* v = libmesh_cast_ptr<const PetscVector<T>*>(&V);
603 
604   // 2\&.3\&.x (at least) style\&.  Untested for previous versions\&.
605   ierr = VecDot(this->_vec, v->_vec, &value);
606   LIBMESH_CHKERRABORT(ierr);
607 
608   return static_cast<T>(value);
609 }
.fi
.SS "template<typename T> virtual T \fBlibMesh::NumericVector\fP< T >::el (const \fBnumeric_index_type\fPi) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element \fCU(i)\fP 
.RE
.PP

.PP
Definition at line 342 of file numeric_vector\&.h\&.
.PP
.nf
342 { return (*this)(i); }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::first_local_index () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the first vector element actually stored on this processor 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1142 of file petsc_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1143 {
1144   libmesh_assert (this->initialized());
1145 
1146   numeric_index_type first = 0;
1147 
1148   if(_array_is_present) // Can we use cached values?
1149     first = _first;
1150   else
1151     {
1152       PetscErrorCode ierr=0;
1153       PetscInt petsc_first=0, petsc_last=0;
1154       ierr = VecGetOwnershipRange (_vec, &petsc_first, &petsc_last);
1155       LIBMESH_CHKERRABORT(ierr);
1156       first = static_cast<numeric_index_type>(petsc_first);
1157     }
1158 
1159   return first;
1160 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::get (const std::vector< \fBnumeric_index_type\fP > &index, std::vector< T > &values) const\fC [inline]\fP, \fC [virtual]\fP"
Access multiple components at once\&. Overloaded method that should be faster (probably much faster) than calling \fCoperator()\fP individually for each index\&. 
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1272 of file petsc_vector\&.h\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
1273 {
1274   this->_get_array();
1275 
1276   const std::size_t num = index\&.size();
1277   values\&.resize(num);
1278 
1279   for(std::size_t i=0; i<num; i++)
1280     {
1281       const numeric_index_type local_index = this->map_global_to_local_index(index[i]);
1282 #ifndef NDEBUG
1283       if(this->type() == GHOSTED)
1284         {
1285           libmesh_assert_less (local_index, _local_size);
1286         }
1287 #endif
1288       values[i] = static_cast<T>(_values[local_index]);
1289     }
1290 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::global_relative_compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given local relative \fCthreshold\fP\&. When differences occur, the return value contains the first index where the difference \fC\fP(a[i]-b[i])/max_j(a[j],b[j]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 177 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), libMesh::NumericVector< T >::linfty_norm(), std::max(), and libMesh::Real\&.
.PP
.nf
179 {
180   libmesh_assert (this->initialized());
181   libmesh_assert (other_vector\&.initialized());
182   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
183   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
184 
185   int first_different_i = std::numeric_limits<int>::max();
186   numeric_index_type i = first_local_index();
187 
188   const Real my_norm = this->linfty_norm();
189   const Real other_norm = other_vector\&.linfty_norm();
190   const Real abs_threshold = std::max(my_norm, other_norm) * threshold;
191 
192   do
193     {
194       if ( std::abs( (*this)(i) - other_vector(i) ) > abs_threshold )
195         first_different_i = i;
196       else
197         i++;
198     }
199   while (first_different_i==std::numeric_limits<int>::max()
200          && i<last_local_index());
201 
202   // Find the correct first differing index in parallel
203   this->comm()\&.min(first_different_i);
204 
205   if (first_different_i == std::numeric_limits<int>::max())
206     return -1;
207 
208   return first_different_i;
209 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "template<typename T > T \fBlibMesh::PetscVector\fP< T >::indefinite_dot (const \fBNumericVector\fP< T > &V) const\fC [virtual]\fP"
Computes the dot product, p = U\&.V\&. Do not use complex-conjugate of V in the complex-valued case\&. 
.PP
Definition at line 612 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec\&.
.PP
.nf
613 {
614   this->_restore_array();
615 
616   // Error flag
617   PetscErrorCode ierr = 0;
618 
619   // Return value
620   PetscScalar value=0\&.;
621 
622   // Make sure the NumericVector passed in is really a PetscVector
623   const PetscVector<T>* v = libmesh_cast_ptr<const PetscVector<T>*>(&V);
624 
625   // 2\&.3\&.x (at least) style\&.  Untested for previous versions\&.
626   ierr = VecTDot(this->_vec, v->_vec, &value);
627   LIBMESH_CHKERRABORT(ierr);
628 
629   return static_cast<T>(value);
630 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::init (const \fBnumeric_index_type\fPN, const \fBnumeric_index_type\fPn_local, const boolfast = \fCfalse\fP, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [virtual]\fP"
Change the dimension of the vector to \fCN\fP\&. The reserved memory for this vector remains unchanged if possible, to make things faster, but this may waste some memory, so take this in the back of your head\&. However, if \fCN==0\fP all memory is freed, i\&.e\&. if you want to resize the vector and release the memory not needed, you have to first call \fCinit(0)\fP and then \fCinit(N)\fP\&. This cited behaviour is analogous to that of the STL containers\&.
.PP
On \fCfast==false\fP, the vector is filled by zeros\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 800 of file petsc_vector\&.h\&.
.PP
References libMesh::libMeshPrivateData::_is_initialized, libMesh::AUTOMATIC, libMesh::CHKERRABORT(), libMesh::comm, libMesh::initialized(), libMesh::libmesh_assert(), libMesh::n_local, libMesh::PARALLEL, libMesh::SERIAL, and libMesh::zero\&.
.PP
Referenced by libMesh::PetscVector< T >::localize(), and libMesh::PetscVector< T >::PetscVector()\&.
.PP
.nf
804 {
805   PetscErrorCode ierr=0;
806   PetscInt petsc_n=static_cast<PetscInt>(n);
807   PetscInt petsc_n_local=static_cast<PetscInt>(n_local);
808 
809 
810   // Clear initialized vectors
811   if (this->initialized())
812     this->clear();
813 
814   if (ptype == AUTOMATIC)
815     {
816       if (n == n_local)
817         this->_type = SERIAL;
818       else
819         this->_type = PARALLEL;
820     }
821   else
822     this->_type = ptype;
823 
824   libmesh_assert ((this->_type==SERIAL && n==n_local) ||
825                   this->_type==PARALLEL);
826 
827   // create a sequential vector if on only 1 processor
828   if (this->_type == SERIAL)
829     {
830       ierr = VecCreateSeq (PETSC_COMM_SELF, petsc_n, &_vec);
831       CHKERRABORT(PETSC_COMM_SELF,ierr);
832 
833       ierr = VecSetFromOptions (_vec);
834       CHKERRABORT(PETSC_COMM_SELF,ierr);
835     }
836   // otherwise create an MPI-enabled vector
837   else if (this->_type == PARALLEL)
838     {
839 #ifdef LIBMESH_HAVE_MPI
840       libmesh_assert_less_equal (n_local, n);
841       ierr = VecCreateMPI (this->comm()\&.get(), petsc_n_local, petsc_n,
842                            &_vec);
843       LIBMESH_CHKERRABORT(ierr);
844 #else
845       libmesh_assert_equal_to (n_local, n);
846       ierr = VecCreateSeq (PETSC_COMM_SELF, petsc_n, &_vec);
847       CHKERRABORT(PETSC_COMM_SELF,ierr);
848 #endif
849 
850       ierr = VecSetFromOptions (_vec);
851       LIBMESH_CHKERRABORT(ierr);
852     }
853   else
854     libmesh_error();
855 
856   this->_is_initialized = true;
857   this->_is_closed = true;
858 
859 
860   if (fast == false)
861     this->zero ();
862 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::init (const \fBnumeric_index_type\fPN, const boolfast = \fCfalse\fP, const \fBParallelType\fPtype = \fC\fBAUTOMATIC\fP\fP)\fC [inline]\fP, \fC [virtual]\fP"
call init with n_local = N, 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 868 of file petsc_vector\&.h\&.
.PP
References libMesh::TriangleWrapper::init()\&.
.PP
.nf
871 {
872   this->init(n,n,fast,ptype);
873 }
.fi
.SS "template<typename T> virtual void \fBlibMesh::PetscVector\fP< T >::init (const \fBnumeric_index_type\fP, const \fBnumeric_index_type\fP, const std::vector< \fBnumeric_index_type\fP > &, const bool = \fCfalse\fP, const \fBParallelType\fP = \fC\fBAUTOMATIC\fP\fP)\fC [virtual]\fP"
Create a vector that holds tha local indices plus those specified in the \fCghost\fP argument\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::init (const \fBNumericVector\fP< T > &other, const boolfast = \fCfalse\fP)\fC [inline]\fP, \fC [virtual]\fP"
Creates a vector that has the same dimension and storage type as \fCother\fP, including ghost dofs\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 939 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::_global_to_local_map, libMesh::libMeshPrivateData::_is_initialized, libMesh::PetscVector< T >::_restore_array(), libMesh::NumericVector< T >::_type, libMesh::PetscVector< T >::_vec, libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::PetscVector< T >::size(), and libMesh::zero\&.
.PP
.nf
941 {
942   // Clear initialized vectors
943   if (this->initialized())
944     this->clear();
945 
946   const PetscVector<T>& v = libmesh_cast_ref<const PetscVector<T>&>(other);
947 
948   // Other vector should restore array\&.
949   if(v\&.initialized())
950     {
951       v\&._restore_array();
952     }
953 
954   this->_global_to_local_map = v\&._global_to_local_map;
955 
956   // Even if we're initializeing sizes based on an uninitialized or
957   // unclosed vector, *this* vector is being initialized now and is
958   // initially closed\&.
959   this->_is_closed      = true; // v\&._is_closed;
960   this->_is_initialized = true; // v\&._is_initialized;
961 
962   this->_type = v\&._type;
963 
964   if (v\&.size() != 0)
965     {
966       PetscErrorCode ierr = 0;
967 
968       ierr = VecDuplicate (v\&._vec, &this->_vec);
969       LIBMESH_CHKERRABORT(ierr);
970     }
971 
972   if (fast == false)
973     this->zero ();
974 }
.fi
.SS "template<typename T> virtual bool \fBlibMesh::NumericVector\fP< T >::initialized () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the vector has been initialized, false otherwise\&. 
.RE
.PP

.PP
Definition at line 129 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::ImplicitSystem::assemble(), libMesh::NumericVector< T >::compare(), libMesh::PetscVector< T >::create_subvector(), libMesh::NumericVector< T >::global_relative_compare(), libMesh::PetscVector< T >::init(), and libMesh::NumericVector< T >::local_relative_compare()\&.
.PP
.nf
129 { return _is_initialized; }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::insert (const std::vector< T > &v, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=v $ where v is a std::vector<T> and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 463 of file petsc_vector\&.C\&.
.PP
.nf
465 {
466   libmesh_assert_equal_to (v\&.size(), dof_indices\&.size());
467 
468   for (unsigned int i=0; i<v\&.size(); i++)
469     this->set (dof_indices[i], v[i]);
470 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::insert (const \fBNumericVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$U=V$, where U and V are type NumericVector<T> and you want to specify WHERE to insert the NumericVector<T> V 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 475 of file petsc_vector\&.C\&.
.PP
References libMesh::NumericVector< T >::size()\&.
.PP
.nf
477 {
478   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
479 
480   for (unsigned int i=0; i<V\&.size(); i++)
481     this->set (dof_indices[i], V(i));
482 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::insert (const \fBDenseVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=V $ where V is type DenseVector<T> and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 487 of file petsc_vector\&.C\&.
.PP
References libMesh::DenseVector< T >::size()\&.
.PP
.nf
489 {
490   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
491 
492   for (unsigned int i=0; i<V\&.size(); i++)
493     this->set (dof_indices[i], V(i));
494 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::insert (const \fBDenseSubVector\fP< T > &V, const std::vector< \fBnumeric_index_type\fP > &dof_indices)\fC [virtual]\fP"
$ U=V $ where V is type DenseSubVector<T> and you want to specify WHERE to insert it 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 499 of file petsc_vector\&.C\&.
.PP
References libMesh::DenseVectorBase< T >::size()\&.
.PP
.nf
501 {
502   libmesh_assert_equal_to (V\&.size(), dof_indices\&.size());
503 
504   for (unsigned int i=0; i<V\&.size(); i++)
505     this->set (dof_indices[i], V(i));
506 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::PetscVector\fP< T >::l1_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_1$-norm of the vector, i\&.e\&. the sum of the absolute values\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 68 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::ierr, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
69 {
70   this->_restore_array();
71   libmesh_assert(this->closed());
72 
73   PetscErrorCode ierr=0;
74   PetscReal value=0\&.;
75 
76   ierr = VecNorm (_vec, NORM_1, &value);
77   LIBMESH_CHKERRABORT(ierr);
78 
79   return static_cast<Real>(value);
80 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::PetscVector\fP< T >::l2_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_2$-norm of the vector, i\&.e\&. the square root of the sum of the squares of the elements\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 85 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::ierr, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
86 {
87   this->_restore_array();
88   libmesh_assert(this->closed());
89 
90   PetscErrorCode ierr=0;
91   PetscReal value=0\&.;
92 
93   ierr = VecNorm (_vec, NORM_2, &value);
94   LIBMESH_CHKERRABORT(ierr);
95 
96   return static_cast<Real>(value);
97 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::last_local_index () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the index of the last vector element actually stored on this processor 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1166 of file petsc_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1167 {
1168   libmesh_assert (this->initialized());
1169 
1170   numeric_index_type last = 0;
1171 
1172   if(_array_is_present) // Can we use cached values?
1173     last = _last;
1174   else
1175     {
1176       PetscErrorCode ierr=0;
1177       PetscInt petsc_first=0, petsc_last=0;
1178       ierr = VecGetOwnershipRange (_vec, &petsc_first, &petsc_last);
1179       LIBMESH_CHKERRABORT(ierr);
1180       last = static_cast<numeric_index_type>(petsc_last);
1181     }
1182 
1183   return last;
1184 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::PetscVector\fP< T >::linfty_norm () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum absolute value of the elements of this vector, which is the $l_\infty$-norm of a vector\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 103 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::ierr, libMesh::libmesh_assert(), and libMesh::Real\&.
.PP
.nf
104 {
105   this->_restore_array();
106   libmesh_assert(this->closed());
107 
108   PetscErrorCode ierr=0;
109   PetscReal value=0\&.;
110 
111   ierr = VecNorm (_vec, NORM_INFINITY, &value);
112   LIBMESH_CHKERRABORT(ierr);
113 
114   return static_cast<Real>(value);
115 }
.fi
.SS "template<typename T> int \fBlibMesh::NumericVector\fP< T >::local_relative_compare (const \fBNumericVector\fP< T > &other_vector, const \fBReal\fPthreshold = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fC-1\fP when \fCthis\fP is equivalent to \fCother_vector\fP, up to the given local relative \fCthreshold\fP\&. When differences occur, the return value contains the first index where the difference \fC\fP(a[i]-b[i])/max(a[i],b[i]) exceeded the threshold\&. When no threshold is given, the \fC\fBlibMesh\fP\fP \fCTOLERANCE\fP is used\&. 
.RE
.PP

.PP
Definition at line 144 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, libMesh::NumericVector< T >::first_local_index(), libMesh::NumericVector< T >::initialized(), libMesh::initialized(), libMesh::NumericVector< T >::last_local_index(), libMesh::libmesh_assert(), and std::max()\&.
.PP
.nf
146 {
147   libmesh_assert (this->initialized());
148   libmesh_assert (other_vector\&.initialized());
149   libmesh_assert_equal_to (this->first_local_index(), other_vector\&.first_local_index());
150   libmesh_assert_equal_to (this->last_local_index(), other_vector\&.last_local_index());
151 
152   int first_different_i = std::numeric_limits<int>::max();
153   numeric_index_type i = first_local_index();
154 
155   do
156     {
157       if ( std::abs( (*this)(i) - other_vector(i) ) > threshold *
158            std::max(std::abs((*this)(i)), std::abs(other_vector(i))))
159         first_different_i = i;
160       else
161         i++;
162     }
163   while (first_different_i==std::numeric_limits<int>::max()
164          && i<last_local_index());
165 
166   // Find the correct first differing index in parallel
167   this->comm()\&.min(first_different_i);
168 
169   if (first_different_i == std::numeric_limits<int>::max())
170     return -1;
171 
172   return first_different_i;
173 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::local_size () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the local size of the vector (index_stop-index_start) 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1125 of file petsc_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::PetscVector< T >::operator=()\&.
.PP
.nf
1126 {
1127   libmesh_assert (this->initialized());
1128 
1129   PetscErrorCode ierr=0;
1130   PetscInt petsc_size=0;
1131 
1132   ierr = VecGetLocalSize(_vec, &petsc_size);
1133   LIBMESH_CHKERRABORT(ierr);
1134 
1135   return static_cast<numeric_index_type>(petsc_size);
1136 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::localize (std::vector< T > &v_local) const\fC [virtual]\fP"
Creates a copy of the global vector in the local vector \fCv_local\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1059 of file petsc_vector\&.C\&.
.PP
References libMesh::comm\&.
.PP
Referenced by libMesh::PetscVector< T >::localize()\&.
.PP
.nf
1060 {
1061   this->_restore_array();
1062 
1063   // This function must be run on all processors at once
1064   parallel_object_only();
1065 
1066   PetscErrorCode ierr=0;
1067   const PetscInt n = this->size();
1068   const PetscInt nl = this->local_size();
1069   PetscScalar *values;
1070 
1071   v_local\&.clear();
1072   v_local\&.resize(n, 0\&.);
1073 
1074   ierr = VecGetArray (_vec, &values);
1075   LIBMESH_CHKERRABORT(ierr);
1076 
1077   numeric_index_type ioff = first_local_index();
1078 
1079   for (PetscInt i=0; i<nl; i++)
1080     v_local[i+ioff] = static_cast<T>(values[i]);
1081 
1082   ierr = VecRestoreArray (_vec, &values);
1083   LIBMESH_CHKERRABORT(ierr);
1084 
1085   this->comm()\&.sum(v_local);
1086 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::localize (\fBNumericVector\fP< T > &v_local) const\fC [virtual]\fP"
Same, but fills a \fCNumericVector<T>\fP instead of a \fCstd::vector\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 816 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec, libMesh::PetscVector< T >::close(), libMesh::comm, libMesh::GHOSTED, libMesh::MeshTools::Generation::Private::idx(), libMesh::Utility::iota(), libMesh::libmesh_assert(), PETSC_USE_POINTER, libMesh::PetscVector< T >::size(), and libMesh::NumericVector< T >::type()\&.
.PP
.nf
817 {
818   this->_restore_array();
819 
820   // Make sure the NumericVector passed in is really a PetscVector
821   PetscVector<T>* v_local = libmesh_cast_ptr<PetscVector<T>*>(&v_local_in);
822 
823   libmesh_assert(v_local);
824   libmesh_assert_equal_to (v_local->size(), this->size());
825 
826   PetscErrorCode ierr = 0;
827   const PetscInt n = this->size();
828 
829   IS is;
830   VecScatter scatter;
831 
832   // Create idx, idx[i] = i;
833   std::vector<PetscInt> idx(n); Utility::iota (idx\&.begin(), idx\&.end(), 0);
834 
835   // Create the index set & scatter object
836   ierr = ISCreateLibMesh(this->comm()\&.get(), n, &idx[0], PETSC_USE_POINTER, &is);
837   LIBMESH_CHKERRABORT(ierr);
838 
839   ierr = VecScatterCreate(_vec,          is,
840                           v_local->_vec, is,
841                           &scatter);
842   LIBMESH_CHKERRABORT(ierr);
843 
844   // Perform the scatter
845 #if PETSC_VERSION_LESS_THAN(2,3,3)
846 
847   ierr = VecScatterBegin(_vec, v_local->_vec, INSERT_VALUES,
848                          SCATTER_FORWARD, scatter);
849   LIBMESH_CHKERRABORT(ierr);
850 
851   ierr = VecScatterEnd  (_vec, v_local->_vec, INSERT_VALUES,
852                          SCATTER_FORWARD, scatter);
853   LIBMESH_CHKERRABORT(ierr);
854 #else
855   // API argument order change in PETSc 2\&.3\&.3
856   ierr = VecScatterBegin(scatter, _vec, v_local->_vec,
857                          INSERT_VALUES, SCATTER_FORWARD);
858   LIBMESH_CHKERRABORT(ierr);
859 
860   ierr = VecScatterEnd  (scatter, _vec, v_local->_vec,
861                          INSERT_VALUES, SCATTER_FORWARD);
862   LIBMESH_CHKERRABORT(ierr);
863 #endif
864 
865   // Clean up
866   ierr = LibMeshISDestroy (&is);
867   LIBMESH_CHKERRABORT(ierr);
868 
869   ierr = LibMeshVecScatterDestroy(&scatter);
870   LIBMESH_CHKERRABORT(ierr);
871 
872   // Make sure ghost dofs are up to date
873   if (v_local->type() == GHOSTED)
874     v_local->close();
875 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::localize (\fBNumericVector\fP< T > &v_local, const std::vector< \fBnumeric_index_type\fP > &send_list) const\fC [virtual]\fP"
Creates a local vector \fCv_local\fP containing only information relevant to this processor, as defined by the \fCsend_list\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 880 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec, libMesh::PetscVector< T >::close(), libMesh::comm, libMesh::GHOSTED, libMesh::MeshTools::Generation::Private::idx(), libMesh::libmesh_assert(), libMesh::PARALLEL, PETSC_USE_POINTER, libMesh::PetscVector< T >::size(), and libMesh::NumericVector< T >::type()\&.
.PP
.nf
882 {
883   // FIXME: Workaround for a strange bug at large-scale\&.
884   // If we have ghosting, PETSc lets us just copy the solution, and
885   // doing so avoids a segfault?
886   if (v_local_in\&.type() == GHOSTED &&
887       this->type() == PARALLEL)
888     {
889       v_local_in = *this;
890       return;
891     }
892 
893   // Normal code path begins here
894 
895   this->_restore_array();
896 
897   // Make sure the NumericVector passed in is really a PetscVector
898   PetscVector<T>* v_local = libmesh_cast_ptr<PetscVector<T>*>(&v_local_in);
899 
900   libmesh_assert(v_local);
901   libmesh_assert_equal_to (v_local->size(), this->size());
902   libmesh_assert_less_equal (send_list\&.size(), v_local->size());
903 
904   PetscErrorCode ierr=0;
905   const numeric_index_type n_sl = send_list\&.size();
906 
907   IS is;
908   VecScatter scatter;
909 
910   std::vector<PetscInt> idx(n_sl + this->local_size());
911 
912   for (numeric_index_type i=0; i<n_sl; i++)
913     idx[i] = static_cast<PetscInt>(send_list[i]);
914   for (numeric_index_type i = 0; i != this->local_size(); ++i)
915     idx[n_sl+i] = i + this->first_local_index();
916 
917   // Create the index set & scatter object
918   if (idx\&.empty())
919     ierr = ISCreateLibMesh(this->comm()\&.get(),
920                            n_sl+this->local_size(), PETSC_NULL, PETSC_USE_POINTER, &is);
921   else
922     ierr = ISCreateLibMesh(this->comm()\&.get(),
923                            n_sl+this->local_size(), &idx[0], PETSC_USE_POINTER, &is);
924   LIBMESH_CHKERRABORT(ierr);
925 
926   ierr = VecScatterCreate(_vec,          is,
927                           v_local->_vec, is,
928                           &scatter);
929   LIBMESH_CHKERRABORT(ierr);
930 
931 
932   // Perform the scatter
933 #if PETSC_VERSION_LESS_THAN(2,3,3)
934 
935   ierr = VecScatterBegin(_vec, v_local->_vec, INSERT_VALUES,
936                          SCATTER_FORWARD, scatter);
937   LIBMESH_CHKERRABORT(ierr);
938 
939   ierr = VecScatterEnd  (_vec, v_local->_vec, INSERT_VALUES,
940                          SCATTER_FORWARD, scatter);
941   LIBMESH_CHKERRABORT(ierr);
942 
943 #else
944 
945   // API argument order change in PETSc 2\&.3\&.3
946   ierr = VecScatterBegin(scatter, _vec, v_local->_vec,
947                          INSERT_VALUES, SCATTER_FORWARD);
948   LIBMESH_CHKERRABORT(ierr);
949 
950   ierr = VecScatterEnd  (scatter, _vec, v_local->_vec,
951                          INSERT_VALUES, SCATTER_FORWARD);
952   LIBMESH_CHKERRABORT(ierr);
953 
954 #endif
955 
956 
957   // Clean up
958   ierr = LibMeshISDestroy (&is);
959   LIBMESH_CHKERRABORT(ierr);
960 
961   ierr = LibMeshVecScatterDestroy(&scatter);
962   LIBMESH_CHKERRABORT(ierr);
963 
964   // Make sure ghost dofs are up to date
965   if (v_local->type() == GHOSTED)
966     v_local->close();
967 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::localize (const \fBnumeric_index_type\fPfirst_local_idx, const \fBnumeric_index_type\fPlast_local_idx, const std::vector< \fBnumeric_index_type\fP > &send_list)\fC [virtual]\fP"
Updates a local vector with selected values from neighboring processors, as defined by \fCsend_list\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 971 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec, libMesh::PetscVector< T >::close(), libMesh::comm, libMesh::MeshTools::Generation::Private::idx(), libMesh::PetscVector< T >::init(), libMesh::Utility::iota(), libMesh::PetscVector< T >::localize(), libMesh::n_processors(), libMesh::PARALLEL, and PETSC_USE_POINTER\&.
.PP
.nf
974 {
975   this->_restore_array();
976 
977   libmesh_assert_less_equal (send_list\&.size(), this->size());
978   libmesh_assert_less_equal (last_local_idx+1, this->size());
979 
980   const numeric_index_type my_size       = this->size();
981   const numeric_index_type my_local_size = (last_local_idx - first_local_idx + 1);
982   PetscErrorCode ierr=0;
983 
984   // Don't bother for serial cases
985   //  if ((first_local_idx == 0) &&
986   //      (my_local_size == my_size))
987   // But we do need to stay in sync for degenerate cases
988   if (this->n_processors() == 1)
989     return;
990 
991 
992   // Build a parallel vector, initialize it with the local
993   // parts of (*this)
994   PetscVector<T> parallel_vec(this->comm(), PARALLEL);
995 
996   parallel_vec\&.init (my_size, my_local_size, true, PARALLEL);
997 
998 
999   // Copy part of *this into the parallel_vec
1000   {
1001     IS is;
1002     VecScatter scatter;
1003 
1004     // Create idx, idx[i] = i+first_local_idx;
1005     std::vector<PetscInt> idx(my_local_size);
1006     Utility::iota (idx\&.begin(), idx\&.end(), first_local_idx);
1007 
1008     // Create the index set & scatter object
1009     ierr = ISCreateLibMesh(this->comm()\&.get(), my_local_size,
1010                            my_local_size ? &idx[0] : NULL, PETSC_USE_POINTER, &is);
1011     LIBMESH_CHKERRABORT(ierr);
1012 
1013     ierr = VecScatterCreate(_vec,              is,
1014                             parallel_vec\&._vec, is,
1015                             &scatter);
1016     LIBMESH_CHKERRABORT(ierr);
1017 
1018     // Perform the scatter
1019 #if PETSC_VERSION_LESS_THAN(2,3,3)
1020 
1021     ierr = VecScatterBegin(_vec, parallel_vec\&._vec, INSERT_VALUES,
1022                            SCATTER_FORWARD, scatter);
1023     LIBMESH_CHKERRABORT(ierr);
1024 
1025     ierr = VecScatterEnd  (_vec, parallel_vec\&._vec, INSERT_VALUES,
1026                            SCATTER_FORWARD, scatter);
1027     LIBMESH_CHKERRABORT(ierr);
1028 
1029 #else
1030 
1031     // API argument order change in PETSc 2\&.3\&.3
1032     ierr = VecScatterBegin(scatter, _vec, parallel_vec\&._vec,
1033                            INSERT_VALUES, SCATTER_FORWARD);
1034     LIBMESH_CHKERRABORT(ierr);
1035 
1036     ierr = VecScatterEnd  (scatter, _vec, parallel_vec\&._vec,
1037                            INSERT_VALUES, SCATTER_FORWARD);
1038     LIBMESH_CHKERRABORT(ierr);
1039 
1040 #endif
1041 
1042     // Clean up
1043     ierr = LibMeshISDestroy (&is);
1044     LIBMESH_CHKERRABORT(ierr);
1045 
1046     ierr = LibMeshVecScatterDestroy(&scatter);
1047     LIBMESH_CHKERRABORT(ierr);
1048   }
1049 
1050   // localize like normal
1051   parallel_vec\&.close();
1052   parallel_vec\&.localize (*this, send_list);
1053   this->close();
1054 }
.fi
.SS "template<typename T> void \fBlibMesh::PetscVector\fP< T >::localize_to_one (std::vector< T > &v_local, const \fBprocessor_id_type\fPproc_id = \fC0\fP) const\fC [virtual]\fP"
Creates a local copy of the global vector in \fCv_local\fP only on processor \fCproc_id\fP\&. By default the data is sent to processor 0\&. This method is useful for outputting data from one processor\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.SS "template<> void \fBlibMesh::PetscVector\fP< \fBReal\fP >::localize_to_one (std::vector< \fBReal\fP > &v_local, const \fBprocessor_id_type\fPpid) const"

.PP
Definition at line 1094 of file petsc_vector\&.C\&.
.PP
References libMesh::comm, libMesh::n_processors(), and libMesh::processor_id()\&.
.PP
.nf
1096 {
1097   this->_restore_array();
1098 
1099   PetscErrorCode ierr=0;
1100   const PetscInt n  = size();
1101   const PetscInt nl = local_size();
1102   PetscScalar *values;
1103 
1104 
1105   // only one processor
1106   if (n_processors() == 1)
1107     {
1108       v_local\&.resize(n);
1109 
1110       ierr = VecGetArray (_vec, &values);
1111       LIBMESH_CHKERRABORT(ierr);
1112 
1113       for (PetscInt i=0; i<n; i++)
1114         v_local[i] = static_cast<Real>(values[i]);
1115 
1116       ierr = VecRestoreArray (_vec, &values);
1117       LIBMESH_CHKERRABORT(ierr);
1118     }
1119 
1120   // otherwise multiple processors
1121   else
1122     {
1123       if(pid == 0) // optimized version for localizing to 0
1124         {
1125           Vec vout;
1126           VecScatter ctx;
1127 
1128           ierr = VecScatterCreateToZero(_vec, &ctx, &vout);
1129           LIBMESH_CHKERRABORT(ierr);
1130 
1131           ierr = VecScatterBegin(ctx, _vec, vout, INSERT_VALUES, SCATTER_FORWARD);
1132           LIBMESH_CHKERRABORT(ierr);
1133           ierr = VecScatterEnd(ctx, _vec, vout, INSERT_VALUES, SCATTER_FORWARD);
1134           LIBMESH_CHKERRABORT(ierr);
1135 
1136           if(processor_id() == 0)
1137             {
1138               v_local\&.resize(n);
1139 
1140               ierr = VecGetArray (vout, &values);
1141               LIBMESH_CHKERRABORT(ierr);
1142 
1143               for (PetscInt i=0; i<n; i++)
1144                 v_local[i] = static_cast<Real>(values[i]);
1145 
1146               ierr = VecRestoreArray (vout, &values);
1147               LIBMESH_CHKERRABORT(ierr);
1148             }
1149 
1150           ierr = LibMeshVecScatterDestroy(&ctx);
1151           LIBMESH_CHKERRABORT(ierr);
1152           ierr = LibMeshVecDestroy(&vout);
1153           LIBMESH_CHKERRABORT(ierr);
1154 
1155         }
1156       else
1157         {
1158           v_local\&.resize(n);
1159 
1160           numeric_index_type ioff = this->first_local_index();
1161           std::vector<Real> local_values (n, 0\&.);
1162 
1163           {
1164             ierr = VecGetArray (_vec, &values);
1165             LIBMESH_CHKERRABORT(ierr);
1166 
1167             for (PetscInt i=0; i<nl; i++)
1168               local_values[i+ioff] = static_cast<Real>(values[i]);
1169 
1170             ierr = VecRestoreArray (_vec, &values);
1171             LIBMESH_CHKERRABORT(ierr);
1172           }
1173 
1174 
1175           MPI_Reduce (&local_values[0], &v_local[0], n, MPI_REAL, MPI_SUM,
1176                       pid, this->comm()\&.get());
1177         }
1178     }
1179 }
.fi
.SS "template<> void \fBlibMesh::PetscVector\fP< \fBComplex\fP >::localize_to_one (std::vector< \fBComplex\fP > &v_local, const \fBprocessor_id_type\fPpid) const"

.PP
Definition at line 1188 of file petsc_vector\&.C\&.
.PP
References libMesh::comm\&.
.PP
.nf
1190 {
1191   this->_restore_array();
1192 
1193   PetscErrorCode ierr=0;
1194   const PetscInt n  = size();
1195   const PetscInt nl = local_size();
1196   PetscScalar *values;
1197 
1198 
1199   v_local\&.resize(n);
1200 
1201 
1202   for (PetscInt i=0; i<n; i++)
1203     v_local[i] = 0\&.;
1204 
1205   // only one processor
1206   if (n == nl)
1207     {
1208       ierr = VecGetArray (_vec, &values);
1209       LIBMESH_CHKERRABORT(ierr);
1210 
1211       for (PetscInt i=0; i<n; i++)
1212         v_local[i] = static_cast<Complex>(values[i]);
1213 
1214       ierr = VecRestoreArray (_vec, &values);
1215       LIBMESH_CHKERRABORT(ierr);
1216     }
1217 
1218   // otherwise multiple processors
1219   else
1220     {
1221       numeric_index_type ioff = this->first_local_index();
1222 
1223       /* in here the local values are stored, acting as send buffer for MPI
1224        * initialize to zero, since we collect using MPI_SUM
1225        */
1226       std::vector<Real> real_local_values(n, 0\&.);
1227       std::vector<Real> imag_local_values(n, 0\&.);
1228 
1229       {
1230         ierr = VecGetArray (_vec, &values);
1231         LIBMESH_CHKERRABORT(ierr);
1232 
1233         // provide my local share to the real and imag buffers
1234         for (PetscInt i=0; i<nl; i++)
1235           {
1236             real_local_values[i+ioff] = static_cast<Complex>(values[i])\&.real();
1237             imag_local_values[i+ioff] = static_cast<Complex>(values[i])\&.imag();
1238           }
1239 
1240         ierr = VecRestoreArray (_vec, &values);
1241         LIBMESH_CHKERRABORT(ierr);
1242       }
1243 
1244       /* have buffers of the real and imaginary part of v_local\&.
1245        * Once MPI_Reduce() collected all the real and imaginary
1246        * parts in these std::vector<Real>, the values can be
1247        * copied to v_local
1248        */
1249       std::vector<Real> real_v_local(n);
1250       std::vector<Real> imag_v_local(n);
1251 
1252       // collect entries from other proc's in real_v_local, imag_v_local
1253       MPI_Reduce (&real_local_values[0], &real_v_local[0], n,
1254                   MPI_REAL, MPI_SUM,
1255                   pid, this->comm()\&.get());
1256 
1257       MPI_Reduce (&imag_local_values[0], &imag_v_local[0], n,
1258                   MPI_REAL, MPI_SUM,
1259                   pid, this->comm()\&.get());
1260 
1261       // copy real_v_local and imag_v_local to v_local
1262       for (PetscInt i=0; i<n; i++)
1263         v_local[i] = Complex(real_v_local[i], imag_v_local[i]);
1264     }
1265 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::map_global_to_local_index (const \fBnumeric_index_type\fPi) const\fC [inline]\fP"
Maps the global index \fCi\fP to the corresponding global index\&. If the index is not a ghost cell, this is done by subtraction the number of the first local index\&. If it is a ghost cell, it has to be looked up in the map\&. 
.PP
Definition at line 1190 of file petsc_vector\&.h\&.
.PP
References end, libMesh::err, libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
1191 {
1192   libmesh_assert (this->initialized());
1193 
1194   numeric_index_type first=0;
1195   numeric_index_type last=0;
1196 
1197   if(_array_is_present) // Can we use cached values?
1198     {
1199       first = _first;
1200       last = _last;
1201     }
1202   else
1203     {
1204       PetscErrorCode ierr=0;
1205       PetscInt petsc_first=0, petsc_last=0;
1206       ierr = VecGetOwnershipRange (_vec, &petsc_first, &petsc_last);
1207       LIBMESH_CHKERRABORT(ierr);
1208       first = static_cast<numeric_index_type>(petsc_first);
1209       last = static_cast<numeric_index_type>(petsc_last);
1210     }
1211 
1212 
1213   if((i>=first) && (i<last))
1214     {
1215       return i-first;
1216     }
1217 
1218   GlobalToLocalMap::const_iterator it = _global_to_local_map\&.find(i);
1219 #ifndef NDEBUG
1220   const GlobalToLocalMap::const_iterator end = _global_to_local_map\&.end();
1221   if (it == end)
1222     {
1223       std::ostringstream error_message;
1224       error_message << "No index " << i << " in ghosted vector\&.\n"
1225                     << "Vector contains [" << first << ',' << last << ")\n";
1226       GlobalToLocalMap::const_iterator b = _global_to_local_map\&.begin();
1227       if (b == end)
1228         {
1229           error_message << "And empty ghost array\&.\n";
1230         }
1231       else
1232         {
1233           error_message << "And ghost array {" << b->first;
1234           for (++b; b != end; ++b)
1235             error_message << ',' << b->first;
1236           error_message << "}\n";
1237         }
1238 
1239       libMesh::err << error_message\&.str();
1240 
1241       libmesh_error();
1242     }
1243   libmesh_assert (it != _global_to_local_map\&.end());
1244 #endif
1245   return it->second+last-first;
1246 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::PetscVector\fP< T >::max () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum element in the vector\&. In case of complex numbers, this returns the maximum Real part\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1315 of file petsc_vector\&.h\&.
.PP
References libMesh::Real\&.
.PP
.nf
1316 {
1317   this->_restore_array();
1318 
1319   PetscErrorCode ierr=0;
1320   PetscInt index=0;
1321   PetscReal returnval=0\&.;
1322 
1323   ierr = VecMax (_vec, &index, &returnval);
1324   LIBMESH_CHKERRABORT(ierr);
1325 
1326   // this return value is correct: VecMax returns a PetscReal
1327   return static_cast<Real>(returnval);
1328 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::PetscVector\fP< T >::min () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the minimum element in the vector\&. In case of complex numbers, this returns the minimum Real part\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1296 of file petsc_vector\&.h\&.
.PP
References libMesh::Real\&.
.PP
.nf
1297 {
1298   this->_restore_array();
1299 
1300   PetscErrorCode ierr=0;
1301   PetscInt index=0;
1302   PetscReal returnval=0\&.;
1303 
1304   ierr = VecMin (_vec, &index, &returnval);
1305   LIBMESH_CHKERRABORT(ierr);
1306 
1307   // this return value is correct: VecMin returns a PetscReal
1308   return static_cast<Real>(returnval);
1309 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "template<typename T > T \fBlibMesh::PetscVector\fP< T >::operator() (const \fBnumeric_index_type\fPi) const\fC [inline]\fP, \fC [virtual]\fP"
Access components, returns \fCU(i)\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1252 of file petsc_vector\&.h\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
1253 {
1254   this->_get_array();
1255 
1256   const numeric_index_type local_index = this->map_global_to_local_index(i);
1257 
1258 #ifndef NDEBUG
1259   if(this->type() == GHOSTED)
1260     {
1261       libmesh_assert_less (local_index, _local_size);
1262     }
1263 #endif
1264 
1265   return static_cast<T>(_values[local_index]);
1266 }
.fi
.SS "template<typename T> \fBNumericVector\fP<T>& \fBlibMesh::NumericVector\fP< T >::operator*= (const Ta)\fC [inline]\fP, \fC [inherited]\fP"
Multiplication operator\&. Equivalent to \fCU\&.scale(a)\fP 
.PP
Definition at line 368 of file numeric_vector\&.h\&.
.PP
.nf
368 { this->scale(a); return *this; }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator+= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
Addition operator\&. Fast equivalent to \fCU\&.add(1, V)\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 122 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), and libMesh::libmesh_assert()\&.
.PP
.nf
123 {
124   this->_restore_array();
125   libmesh_assert(this->closed());
126 
127   this->add(1\&., v);
128 
129   return *this;
130 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator-= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
Subtraction operator\&. Fast equivalent to \fCU\&.add\fP(-1, V)\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 136 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), and libMesh::libmesh_assert()\&.
.PP
.nf
137 {
138   this->_restore_array();
139   libmesh_assert(this->closed());
140 
141   this->add(-1\&., v);
142 
143   return *this;
144 }
.fi
.SS "template<typename T> \fBNumericVector\fP<T>& \fBlibMesh::NumericVector\fP< T >::operator/= (const Ta)\fC [inline]\fP, \fC [inherited]\fP"
Division operator\&. Equivalent to \fCU\&.scale\fP(1\&./a) 
.PP
Definition at line 374 of file numeric_vector\&.h\&.
.PP
.nf
374 { this->scale(1\&./a); return *this; }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator/= (\fBNumericVector\fP< T > &v)\fC [virtual]\fP"
Pointwise Division operator\&. ie divide every entry in this vector by the entry in v 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 552 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_vec\&.
.PP
.nf
553 {
554   PetscErrorCode ierr = 0;
555 
556   const PetscVector<T>* v_vec = libmesh_cast_ptr<const PetscVector<T>*>(&v);
557 
558   ierr = VecPointwiseDivide(_vec, _vec, v_vec->_vec);
559   LIBMESH_CHKERRABORT(ierr);
560 
561   return *this;
562 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator= (const Ts)\fC [virtual]\fP"
Change the dimension to that of the vector \fCV\fP\&. The same applies as for the other \fCinit\fP function\&.
.PP
The elements of \fCV\fP are not copied, i\&.e\&. this function is the same as calling \fCinit\fP(V\&.size(),fast)\&. $U(0-N) = s$: fill all components\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 635 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::GHOSTED, and libMesh::libmesh_assert()\&.
.PP
.nf
636 {
637   this->_restore_array();
638   libmesh_assert(this->closed());
639 
640   PetscErrorCode ierr = 0;
641   PetscScalar s = static_cast<PetscScalar>(s_in);
642 
643   if (this->size() != 0)
644     {
645       if(this->type() != GHOSTED)
646         {
647 #if PETSC_VERSION_LESS_THAN(2,3,0)
648           // 2\&.2\&.x & earlier style
649           ierr = VecSet(&s, _vec);
650           LIBMESH_CHKERRABORT(ierr);
651 #else
652           // 2\&.3\&.x & later style
653           ierr = VecSet(_vec, s);
654           LIBMESH_CHKERRABORT(ierr);
655 #endif
656         }
657       else
658         {
659           Vec loc_vec;
660           ierr = VecGhostGetLocalForm (_vec,&loc_vec);
661           LIBMESH_CHKERRABORT(ierr);
662 
663 #if PETSC_VERSION_LESS_THAN(2,3,0)
664           // 2\&.2\&.x & earlier style
665           ierr = VecSet(&s, loc_vec);
666           LIBMESH_CHKERRABORT(ierr);
667 #else
668           // 2\&.3\&.x & later style
669           ierr = VecSet(loc_vec, s);
670           LIBMESH_CHKERRABORT(ierr);
671 #endif
672 
673           ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
674           LIBMESH_CHKERRABORT(ierr);
675         }
676     }
677 
678   return *this;
679 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator= (const \fBNumericVector\fP< T > &V)\fC [virtual]\fP"
$U = V$: copy all components\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 685 of file petsc_vector\&.C\&.
.PP
.nf
686 {
687   // Make sure the NumericVector passed in is really a PetscVector
688   const PetscVector<T>* v = libmesh_cast_ptr<const PetscVector<T>*>(&v_in);
689 
690   *this = *v;
691 
692   return *this;
693 }
.fi
.SS "template<typename T > \fBPetscVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator= (const \fBPetscVector\fP< T > &V)"
$U = V$: copy all components\&. 
.PP
Definition at line 699 of file petsc_vector\&.C\&.
.PP
References libMesh::PetscVector< T >::_restore_array(), libMesh::NumericVector< T >::_type, libMesh::PetscVector< T >::_vec, libMesh::NumericVector< T >::closed(), libMesh::GHOSTED, libMesh::libmesh_assert(), libMesh::PetscVector< T >::local_size(), libMesh::PARALLEL, libMesh::SERIAL, libMesh::PetscVector< T >::size(), and libMesh::NumericVector< T >::type()\&.
.PP
.nf
700 {
701   this->_restore_array();
702   v\&._restore_array();
703 
704   libmesh_assert_equal_to (this->size(), v\&.size());
705   libmesh_assert_equal_to (this->local_size(), v\&.local_size());
706   libmesh_assert (v\&.closed());
707 
708   PetscErrorCode ierr = 0;
709 
710   if (((this->type()==PARALLEL) && (v\&.type()==GHOSTED)) ||
711       ((this->type()==GHOSTED) && (v\&.type()==PARALLEL)) ||
712       ((this->type()==GHOSTED) && (v\&.type()==SERIAL))   ||
713       ((this->type()==SERIAL) && (v\&.type()==GHOSTED)))
714     {
715       /* Allow assignment of a ghosted to a parallel vector since this
716          causes no difficulty\&.  See discussion in libmesh-devel of
717          June 24, 2010\&.  */
718       ierr = VecCopy (v\&._vec, this->_vec);
719       LIBMESH_CHKERRABORT(ierr);
720     }
721   else
722     {
723       /* In all other cases, we assert that both vectors are of equal
724          type\&.  */
725       libmesh_assert_equal_to (this->_type, v\&._type);
726 
727       if (v\&.size() != 0)
728         {
729           if(this->type() != GHOSTED)
730             {
731               ierr = VecCopy (v\&._vec, this->_vec);
732               LIBMESH_CHKERRABORT(ierr);
733             }
734           else
735             {
736               Vec loc_vec;
737               Vec v_loc_vec;
738               ierr = VecGhostGetLocalForm (_vec,&loc_vec);
739               LIBMESH_CHKERRABORT(ierr);
740               ierr = VecGhostGetLocalForm (v\&._vec,&v_loc_vec);
741               LIBMESH_CHKERRABORT(ierr);
742 
743               ierr = VecCopy (v_loc_vec, loc_vec);
744               LIBMESH_CHKERRABORT(ierr);
745 
746               ierr = VecGhostRestoreLocalForm (v\&._vec,&v_loc_vec);
747               LIBMESH_CHKERRABORT(ierr);
748               ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
749               LIBMESH_CHKERRABORT(ierr);
750             }
751         }
752     }
753 
754   close();
755 
756   return *this;
757 }
.fi
.SS "template<typename T > \fBNumericVector\fP< T > & \fBlibMesh::PetscVector\fP< T >::operator= (const std::vector< T > &v)\fC [virtual]\fP"
$U = V$: copy all components\&. Case 1: The vector is the same size of The global vector\&. Only add the local components\&.
.PP
Case 2: The vector is the same size as our local piece\&. Insert directly to the local piece\&.
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 763 of file petsc_vector\&.C\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
764 {
765   this->_restore_array();
766 
767   const numeric_index_type nl   = this->local_size();
768   const numeric_index_type ioff = this->first_local_index();
769   PetscErrorCode ierr=0;
770   PetscScalar* values;
771 
776   if (this->size() == v\&.size())
777     {
778       ierr = VecGetArray (_vec, &values);
779       LIBMESH_CHKERRABORT(ierr);
780 
781       for (numeric_index_type i=0; i<nl; i++)
782         values[i] =  static_cast<PetscScalar>(v[i+ioff]);
783 
784       ierr = VecRestoreArray (_vec, &values);
785       LIBMESH_CHKERRABORT(ierr);
786     }
787 
792   else
793     {
794       libmesh_assert_equal_to (this->local_size(), v\&.size());
795 
796       ierr = VecGetArray (_vec, &values);
797       LIBMESH_CHKERRABORT(ierr);
798 
799       for (numeric_index_type i=0; i<nl; i++)
800         values[i] = static_cast<PetscScalar>(v[i]);
801 
802       ierr = VecRestoreArray (_vec, &values);
803       LIBMESH_CHKERRABORT(ierr);
804     }
805 
806   // Make sure ghost dofs are up to date
807   if (this->type() == GHOSTED)
808     this->close();
809 
810   return *this;
811 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::pointwise_mult (const \fBNumericVector\fP< T > &vec1, const \fBNumericVector\fP< T > &vec2)\fC [virtual]\fP"
Computes the pointwise (i\&.e\&. component-wise) product of \fCvec1\fP and \fCvec2\fP and stores the result in \fC*this\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1272 of file petsc_vector\&.C\&.
.PP
References libMesh::GHOSTED, and libMesh::out\&.
.PP
.nf
1274 {
1275   this->_restore_array();
1276 
1277   PetscErrorCode ierr = 0;
1278 
1279   // Convert arguments to PetscVector*\&.
1280   const PetscVector<T>* vec1_petsc = libmesh_cast_ptr<const PetscVector<T>*>(&vec1);
1281   const PetscVector<T>* vec2_petsc = libmesh_cast_ptr<const PetscVector<T>*>(&vec2);
1282 
1283   // Call PETSc function\&.
1284 
1285 #if PETSC_VERSION_LESS_THAN(2,3,1)
1286 
1287   libMesh::out << "This method has been developed with PETSc 2\&.3\&.1\&.  "
1288                << "No one has made it backwards compatible with older "
1289                << "versions of PETSc so far; however, it might work "
1290                << "without any change with some older version\&." << std::endl;
1291   libmesh_error();
1292 
1293 #else
1294 
1295   if(this->type() != GHOSTED)
1296     {
1297       ierr = VecPointwiseMult(this->vec(),
1298                               const_cast<PetscVector<T>*>(vec1_petsc)->vec(),
1299                               const_cast<PetscVector<T>*>(vec2_petsc)->vec());
1300       LIBMESH_CHKERRABORT(ierr);
1301     }
1302   else
1303     {
1304       Vec loc_vec;
1305       Vec v1_loc_vec;
1306       Vec v2_loc_vec;
1307       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
1308       LIBMESH_CHKERRABORT(ierr);
1309       ierr = VecGhostGetLocalForm (const_cast<PetscVector<T>*>(vec1_petsc)->vec(),&v1_loc_vec);
1310       LIBMESH_CHKERRABORT(ierr);
1311       ierr = VecGhostGetLocalForm (const_cast<PetscVector<T>*>(vec2_petsc)->vec(),&v2_loc_vec);
1312       LIBMESH_CHKERRABORT(ierr);
1313 
1314       ierr = VecPointwiseMult(loc_vec,v1_loc_vec,v2_loc_vec);
1315       LIBMESH_CHKERRABORT(ierr);
1316 
1317       ierr = VecGhostRestoreLocalForm (const_cast<PetscVector<T>*>(vec1_petsc)->vec(),&v1_loc_vec);
1318       LIBMESH_CHKERRABORT(ierr);
1319       ierr = VecGhostRestoreLocalForm (const_cast<PetscVector<T>*>(vec2_petsc)->vec(),&v2_loc_vec);
1320       LIBMESH_CHKERRABORT(ierr);
1321       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
1322       LIBMESH_CHKERRABORT(ierr);
1323     }
1324 
1325 #endif
1326 
1327 }
.fi
.SS "template<typename T > void \fBlibMesh::NumericVector\fP< T >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Prints the local contents of the vector, by default to \fBlibMesh::out\fP 
.PP
Definition at line 830 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
831 {
832   libmesh_assert (this->initialized());
833   os << "Size\tglobal =  " << this->size()
834      << "\t\tlocal =  " << this->local_size() << std::endl;
835 
836   os << "#\tValue" << std::endl;
837   for (numeric_index_type i=this->first_local_index(); i<this->last_local_index(); i++)
838     os << i << "\t" << (*this)(i) << std::endl;
839 }
.fi
.SS "template<> void \fBlibMesh::NumericVector\fP< \fBComplex\fP >::print (std::ostream &os) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 812 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
.nf
813 {
814   libmesh_assert (this->initialized());
815   os << "Size\tglobal =  " << this->size()
816      << "\t\tlocal =  " << this->local_size() << std::endl;
817 
818   // std::complex<>::operator<<() is defined, but use this form
819   os << "#\tReal part\t\tImaginary part" << std::endl;
820   for (numeric_index_type i=this->first_local_index(); i<this->last_local_index(); i++)
821     os << i << "\t"
822        << (*this)(i)\&.real() << "\t\t"
823        << (*this)(i)\&.imag() << std::endl;
824 }
.fi
.SS "template<typename T > void \fBlibMesh::NumericVector\fP< T >::print_global (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Prints the global contents of the vector, by default to \fBlibMesh::out\fP 
.PP
Definition at line 867 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), libMesh::libmesh_assert(), and libMesh::processor_id()\&.
.PP
.nf
868 {
869   libmesh_assert (this->initialized());
870 
871   std::vector<T> v(this->size());
872   this->localize(v);
873 
874   // Right now we only want one copy of the output
875   if (this->processor_id())
876     return;
877 
878   os << "Size\tglobal =  " << this->size() << std::endl;
879   os << "#\tValue" << std::endl;
880   for (numeric_index_type i=0; i!=v\&.size(); i++)
881     os << i << "\t" << v[i] << std::endl;
882 }
.fi
.SS "template<> void \fBlibMesh::NumericVector\fP< \fBComplex\fP >::print_global (std::ostream &os) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 845 of file numeric_vector\&.h\&.
.PP
References libMesh::initialized(), libMesh::libmesh_assert(), and libMesh::processor_id()\&.
.PP
.nf
846 {
847   libmesh_assert (this->initialized());
848 
849   std::vector<Complex> v(this->size());
850   this->localize(v);
851 
852   // Right now we only want one copy of the output
853   if (this->processor_id())
854     return;
855 
856   os << "Size\tglobal =  " << this->size() << std::endl;
857   os << "#\tReal part\t\tImaginary part" << std::endl;
858   for (numeric_index_type i=0; i!=v\&.size(); i++)
859     os << i << "\t"
860        << v[i]\&.real() << "\t\t"
861        << v[i]\&.imag() << std::endl;
862 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::print_matlab (const std::string &name = \fC''\fP) const\fC [virtual]\fP"
Print the contents of the vector in Matlab format\&. Optionally prints the matrix to the file named \fCname\fP\&. If \fCname\fP is not specified it is dumped to the screen\&. Create an ASCII file containing the matrix if a filename was provided\&.
.PP
Otherwise the matrix will be dumped to the screen\&.
.PP
Destroy the viewer\&.
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1332 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::comm, and libMesh::libmesh_assert()\&.
.PP
.nf
1333 {
1334   this->_restore_array();
1335   libmesh_assert (this->closed());
1336 
1337   PetscErrorCode ierr=0;
1338   PetscViewer petsc_viewer;
1339 
1340 
1341   ierr = PetscViewerCreate (this->comm()\&.get(),
1342                             &petsc_viewer);
1343   LIBMESH_CHKERRABORT(ierr);
1344 
1349   if (name != "")
1350     {
1351       ierr = PetscViewerASCIIOpen( this->comm()\&.get(),
1352                                    name\&.c_str(),
1353                                    &petsc_viewer);
1354       LIBMESH_CHKERRABORT(ierr);
1355 
1356       ierr = PetscViewerSetFormat (petsc_viewer,
1357                                    PETSC_VIEWER_ASCII_MATLAB);
1358       LIBMESH_CHKERRABORT(ierr);
1359 
1360       ierr = VecView (_vec, petsc_viewer);
1361       LIBMESH_CHKERRABORT(ierr);
1362     }
1363 
1367   else
1368     {
1369       ierr = PetscViewerSetFormat (PETSC_VIEWER_STDOUT_WORLD,
1370                                    PETSC_VIEWER_ASCII_MATLAB);
1371       LIBMESH_CHKERRABORT(ierr);
1372 
1373       ierr = VecView (_vec, PETSC_VIEWER_STDOUT_WORLD);
1374       LIBMESH_CHKERRABORT(ierr);
1375     }
1376 
1377 
1381   ierr = LibMeshPetscViewerDestroy (&petsc_viewer);
1382   LIBMESH_CHKERRABORT(ierr);
1383 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::reciprocal ()\fC [virtual]\fP"
Replace each entry v_i of this vector by its reciprocal, 1/v_i\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 167 of file petsc_vector\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
168 {
169   PetscErrorCode ierr = 0;
170 
171   // VecReciprocal has been in PETSc since at least 2\&.3\&.3 days
172   ierr = VecReciprocal(_vec);
173   LIBMESH_CHKERRABORT(ierr);
174 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::scale (const Tfactor)\fC [virtual]\fP"
Scale each element of the vector by the given factor\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 511 of file petsc_vector\&.C\&.
.PP
References libMesh::GHOSTED\&.
.PP
.nf
512 {
513   this->_restore_array();
514 
515   PetscErrorCode ierr = 0;
516   PetscScalar factor = static_cast<PetscScalar>(factor_in);
517 
518   if(this->type() != GHOSTED)
519     {
520 #if PETSC_VERSION_LESS_THAN(2,3,0)
521       // 2\&.2\&.x & earlier style
522       ierr = VecScale(&factor, _vec);
523       LIBMESH_CHKERRABORT(ierr);
524 #else
525       // 2\&.3\&.x & later style
526       ierr = VecScale(_vec, factor);
527       LIBMESH_CHKERRABORT(ierr);
528 #endif
529     }
530   else
531     {
532       Vec loc_vec;
533       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
534       LIBMESH_CHKERRABORT(ierr);
535 
536 #if PETSC_VERSION_LESS_THAN(2,3,0)
537       // 2\&.2\&.x & earlier style
538       ierr = VecScale(&factor, loc_vec);
539       LIBMESH_CHKERRABORT(ierr);
540 #else
541       // 2\&.3\&.x & later style
542       ierr = VecScale(loc_vec, factor);
543       LIBMESH_CHKERRABORT(ierr);
544 #endif
545 
546       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
547       LIBMESH_CHKERRABORT(ierr);
548     }
549 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::set (const \fBnumeric_index_type\fPi, const Tvalue)\fC [virtual]\fP"
v(i) = value 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 149 of file petsc_vector\&.C\&.
.PP
References libMesh::ierr\&.
.PP
.nf
150 {
151   this->_restore_array();
152   libmesh_assert_less (i, size());
153 
154   PetscErrorCode ierr=0;
155   PetscInt i_val = static_cast<PetscInt>(i);
156   PetscScalar petsc_value = static_cast<PetscScalar>(value);
157 
158   ierr = VecSetValues (_vec, 1, &i_val, &petsc_value, INSERT_VALUES);
159   LIBMESH_CHKERRABORT(ierr);
160 
161   this->_is_closed = false;
162 }
.fi
.SS "template<typename T > \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::size () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
dimension of the vector\&. This function was formerly called \fCn()\fP, but was renamed to get the \fCPetscVector<T>\fP class closer to the C++ standard library's \fCstd::vector\fP container\&. 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1105 of file petsc_vector\&.h\&.
.PP
References libMesh::initialized(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::PetscVector< T >::add(), libMesh::PetscVector< T >::init(), libMesh::PetscVector< T >::localize(), and libMesh::PetscVector< T >::operator=()\&.
.PP
.nf
1106 {
1107   libmesh_assert (this->initialized());
1108 
1109   PetscErrorCode ierr=0;
1110   PetscInt petsc_size=0;
1111 
1112   if (!this->initialized())
1113     return 0;
1114 
1115   ierr = VecGetSize(_vec, &petsc_size);
1116   LIBMESH_CHKERRABORT(ierr);
1117 
1118   return static_cast<numeric_index_type>(petsc_size);
1119 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_l1_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_1$-norm of the vector, i\&.e\&. the sum of the absolute values for the specified entries in the vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 320 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
321 {
322   const NumericVector<T> & v = *this;
323 
324   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
325   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
326 
327   Real norm = 0;
328 
329   for(; it!=it_end; ++it)
330     norm += std::abs(v(*it));
331 
332   this->comm()\&.sum(norm);
333 
334   return norm;
335 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_l2_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the $l_2$-norm of the vector, i\&.e\&. the square root of the sum of the squares of the elements for the specified entries in the vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 338 of file numeric_vector\&.C\&.
.PP
References libMesh::comm, libMesh::TensorTools::norm_sq(), and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
339 {
340   const NumericVector<T> & v = *this;
341 
342   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
343   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
344 
345   Real norm = 0;
346 
347   for(; it!=it_end; ++it)
348     norm += TensorTools::norm_sq(v(*it));
349 
350   this->comm()\&.sum(norm);
351 
352   return std::sqrt(norm);
353 }
.fi
.SS "template<class T > \fBReal\fP \fBlibMesh::NumericVector\fP< T >::subset_linfty_norm (const std::set< \fBnumeric_index_type\fP > &indices) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum absolute value of the specified entries of this vector, which is the $l_\infty$-norm of a vector\&.
.RE
.PP
Note that the indices must necessary live on this processor\&. 
.PP
Definition at line 356 of file numeric_vector\&.C\&.
.PP
References std::abs(), libMesh::comm, and libMesh::Real\&.
.PP
Referenced by libMesh::System::discrete_var_norm()\&.
.PP
.nf
357 {
358   const NumericVector<T> & v = *this;
359 
360   std::set<numeric_index_type>::const_iterator it = indices\&.begin();
361   const std::set<numeric_index_type>::const_iterator it_end = indices\&.end();
362 
363   Real norm = 0;
364 
365   for(; it!=it_end; ++it)
366     {
367       Real value = std::abs(v(*it));
368       if(value > norm)
369         norm = value;
370     }
371 
372   this->comm()\&.max(norm);
373 
374   return norm;
375 }
.fi
.SS "template<typename T > T \fBlibMesh::PetscVector\fP< T >::sum () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the sum of values in a vector 
.RE
.PP

.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 52 of file petsc_vector\&.C\&.
.PP
References libMesh::closed(), libMesh::ierr, and libMesh::libmesh_assert()\&.
.PP
.nf
53 {
54   this->_restore_array();
55   libmesh_assert(this->closed());
56 
57   PetscErrorCode ierr=0;
58   PetscScalar value=0\&.;
59 
60   ierr = VecSum (_vec, &value);
61   LIBMESH_CHKERRABORT(ierr);
62 
63   return static_cast<T>(value);
64 }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::swap (\fBNumericVector\fP< T > &v)\fC [inline]\fP, \fC [virtual]\fP"
Swaps the raw PETSc vector context pointers\&. 
.PP
Reimplemented from \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1334 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::_array_is_present, libMesh::PetscVector< T >::_destroy_vec_on_exit, libMesh::PetscVector< T >::_global_to_local_map, libMesh::PetscVector< T >::_local_form, libMesh::PetscVector< T >::_values, libMesh::PetscVector< T >::_vec, libMesh::swap(), and libMesh::NumericVector< T >::swap()\&.
.PP
.nf
1335 {
1336   NumericVector<T>::swap(other);
1337 
1338   PetscVector<T>& v = libmesh_cast_ref<PetscVector<T>&>(other);
1339 
1340   std::swap(_vec, v\&._vec);
1341   std::swap(_destroy_vec_on_exit, v\&._destroy_vec_on_exit);
1342   std::swap(_global_to_local_map, v\&._global_to_local_map);
1343   std::swap(_array_is_present, v\&._array_is_present);
1344   std::swap(_local_form, v\&._local_form);
1345   std::swap(_values, v\&._values);
1346 }
.fi
.SS "template<typename T> \fBParallelType\fP \fBlibMesh::NumericVector\fP< T >::type () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the type (SERIAL, PARALLEL, GHOSTED) of the vector\&. 
.RE
.PP

.PP
Definition at line 134 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DofMap::enforce_adjoint_constraints_exactly(), libMesh::DofMap::enforce_constraints_exactly(), libMesh::EpetraVector< T >::EpetraVector(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::DistributedVector< T >::init(), libMesh::LaspackVector< T >::init(), libMesh::EigenSparseVector< T >::init(), libMesh::EpetraVector< T >::init(), libMesh::PetscVector< T >::localize(), libMesh::MeshFunction::operator()(), libMesh::PetscVector< T >::operator=(), libMesh::System::project_vector(), and libMesh::System::read_serialized_vector()\&.
.PP
.nf
134 { return _type; }
.fi
.SS "template<typename T> \fBParallelType\fP& \fBlibMesh::NumericVector\fP< T >::type ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the type (SERIAL, PARALLEL, GHOSTED) of the vector\&. 
.RE
.PP

.PP
Definition at line 139 of file numeric_vector\&.h\&.
.PP
.nf
139 { return _type; }
.fi
.SS "template<typename T> Vec \fBlibMesh::PetscVector\fP< T >::vec ()\fC [inline]\fP"
Returns the raw PETSc vector context pointer\&. Note this is generally not required in user-level code\&. Just don't do anything crazy like calling LibMeshVecDestroy()! 
.PP
Definition at line 542 of file petsc_vector\&.h\&.
.PP
References libMesh::PetscVector< T >::_vec, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::PetscPreconditioner< T >::apply(), libMesh::PetscNonlinearSolver< T >::build_mat_null_space(), DMCreateGlobalVector_libMesh(), libMesh::PetscMatrix< T >::get_diagonal(), libMesh::SlepcEigenSolver< T >::get_eigenpair(), libMesh::PetscDiffSolver::solve(), and libMesh::PetscLinearSolver< T >::solve()\&.
.PP
.nf
542 { libmesh_assert (_vec); return _vec; }
.fi
.SS "template<typename T > void \fBlibMesh::PetscVector\fP< T >::zero ()\fC [inline]\fP, \fC [virtual]\fP"
Set all entries to zero\&. Equivalent to \fCv\fP = 0, but more obvious and faster\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1028 of file petsc_vector\&.h\&.
.PP
References libMesh::closed(), libMesh::GHOSTED, and libMesh::libmesh_assert()\&.
.PP
.nf
1029 {
1030   libmesh_assert(this->closed());
1031 
1032   this->_restore_array();
1033 
1034   PetscErrorCode ierr=0;
1035 
1036   PetscScalar z=0\&.;
1037 
1038   if(this->type() != GHOSTED)
1039     {
1040 #if PETSC_VERSION_LESS_THAN(2,3,0)
1041       // 2\&.2\&.x & earlier style
1042       ierr = VecSet (&z, _vec);
1043       LIBMESH_CHKERRABORT(ierr);
1044 #else
1045       // 2\&.3\&.x & newer
1046       ierr = VecSet (_vec, z);
1047       LIBMESH_CHKERRABORT(ierr);
1048 #endif
1049     }
1050   else
1051     {
1052       /* Vectors that include ghost values require a special
1053          handling\&.  */
1054       Vec loc_vec;
1055       ierr = VecGhostGetLocalForm (_vec,&loc_vec);
1056       LIBMESH_CHKERRABORT(ierr);
1057 #if PETSC_VERSION_LESS_THAN(2,3,0)
1058       // 2\&.2\&.x & earlier style
1059       ierr = VecSet (&z, loc_vec);
1060       LIBMESH_CHKERRABORT(ierr);
1061 #else
1062       // 2\&.3\&.x & newer
1063       ierr = VecSet (loc_vec, z);
1064       LIBMESH_CHKERRABORT(ierr);
1065 #endif
1066       ierr = VecGhostRestoreLocalForm (_vec,&loc_vec);
1067       LIBMESH_CHKERRABORT(ierr);
1068     }
1069 }
.fi
.SS "template<typename T > \fBAutoPtr\fP< \fBNumericVector\fP< T > > \fBlibMesh::PetscVector\fP< T >::zero_clone () const\fC [inline]\fP, \fC [virtual]\fP"
Creates a vector which has the same type, size and partitioning as this vector, but whose data is all zero\&. Returns it in an \fC\fBAutoPtr\fP\fP\&. 
.PP
Implements \fBlibMesh::NumericVector< T >\fP\&.
.PP
Definition at line 1075 of file petsc_vector\&.h\&.
.PP
References libMesh::comm\&.
.PP
.nf
1076 {
1077   AutoPtr<NumericVector<T> > cloned_vector
1078     (new PetscVector<T>(this->comm(), this->type()));
1079 
1080   cloned_vector->init(*this);
1081 
1082   return cloned_vector;
1083 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<typename T> bool \fBlibMesh::PetscVector\fP< T >::_array_is_present\fC [mutable]\fP, \fC [private]\fP"
If \fCtrue\fP, the actual Petsc array of the values of the vector is currently accessible\&. That means that the members \fC_local_form\fP and \fC_values\fP are valid\&. 
.PP
Definition at line 559 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::swap()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "template<typename T> bool \fBlibMesh::PetscVector\fP< T >::_destroy_vec_on_exit\fC [private]\fP"
This boolean value should only be set to false for the constructor which takes a PETSc Vec object\&. 
.PP
Definition at line 624 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::swap()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "template<typename T> \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::_first\fC [mutable]\fP, \fC [private]\fP"
First local index\&.
.PP
Only valid when _array_is_present 
.PP
Definition at line 566 of file petsc_vector\&.h\&.
.SS "template<typename T> \fBGlobalToLocalMap\fP \fBlibMesh::PetscVector\fP< T >::_global_to_local_map\fC [private]\fP"
Map that maps global to local ghost cells (will be empty if not in ghost cell mode)\&. 
.PP
Definition at line 618 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::init(), and libMesh::PetscVector< T >::swap()\&.
.SS "template<typename T> bool \fBlibMesh::NumericVector\fP< T >::_is_closed\fC [protected]\fP, \fC [inherited]\fP"
Flag to see if the Numeric assemble routines have been called yet 
.PP
Definition at line 655 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::NumericVector< Number >::closed(), libMesh::DistributedVector< T >::localize(), and libMesh::DistributedVector< T >::operator=()\&.
.SS "template<typename T> bool \fBlibMesh::NumericVector\fP< T >::_is_initialized\fC [protected]\fP, \fC [inherited]\fP"
Flag to tell if init has been called yet 
.PP
Definition at line 661 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::create_subvector(), libMesh::NumericVector< Number >::initialized(), libMesh::DistributedVector< T >::localize(), and libMesh::DistributedVector< T >::operator=()\&.
.SS "template<typename T> \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::_last\fC [mutable]\fP, \fC [private]\fP"
Last local index\&.
.PP
Only valid when _array_is_present 
.PP
Definition at line 573 of file petsc_vector\&.h\&.
.SS "template<typename T> Vec \fBlibMesh::PetscVector\fP< T >::_local_form\fC [mutable]\fP, \fC [private]\fP"
Petsc vector datatype to hold the local form of a ghosted vector\&. The contents of this field are only valid if the vector is ghosted and \fC_array_is_present\fP is \fCtrue\fP\&. 
.PP
Definition at line 589 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::swap()\&.
.SS "template<typename T> \fBnumeric_index_type\fP \fBlibMesh::PetscVector\fP< T >::_local_size\fC [mutable]\fP, \fC [private]\fP"
Size of the local form, for being used in assertations\&. The contents of this field are only valid if the vector is ghosted and \fC_array_is_present\fP is \fCtrue\fP\&. 
.PP
Definition at line 581 of file petsc_vector\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "template<typename T> \fBParallelType\fP \fBlibMesh::NumericVector\fP< T >::_type\fC [protected]\fP, \fC [inherited]\fP"
Type of vector 
.PP
Definition at line 666 of file numeric_vector\&.h\&.
.PP
Referenced by libMesh::DistributedVector< T >::DistributedVector(), libMesh::EigenSparseVector< T >::EigenSparseVector(), libMesh::EpetraVector< T >::EpetraVector(), libMesh::PetscVector< T >::init(), libMesh::LaspackVector< T >::LaspackVector(), libMesh::PetscVector< T >::operator=(), libMesh::PetscVector< T >::PetscVector(), and libMesh::NumericVector< Number >::type()\&.
.SS "template<typename T> PetscScalar* \fBlibMesh::PetscVector\fP< T >::_values\fC [mutable]\fP, \fC [private]\fP"
Pointer to the actual Petsc array of the values of the vector\&. This pointer is only valid if \fC_array_is_present\fP is \fCtrue\fP\&. 
.PP
Definition at line 595 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::swap()\&.
.SS "template<typename T> Vec \fBlibMesh::PetscVector\fP< T >::_vec\fC [private]\fP"
Actual Petsc vector datatype to hold vector entries 
.PP
Definition at line 552 of file petsc_vector\&.h\&.
.PP
Referenced by libMesh::PetscVector< T >::add(), libMesh::PetscVector< T >::add_vector(), libMesh::PetscVector< T >::add_vector_transpose(), libMesh::PetscVector< T >::create_subvector(), libMesh::PetscVector< T >::dot(), libMesh::PetscVector< T >::indefinite_dot(), libMesh::PetscVector< T >::init(), libMesh::PetscVector< T >::localize(), libMesh::PetscVector< T >::operator/=(), libMesh::PetscVector< T >::operator=(), libMesh::PetscVector< T >::swap(), and libMesh::PetscVector< T >::vec()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
