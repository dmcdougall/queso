.TH "libMesh::SerialMesh" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::SerialMesh \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <serial_mesh\&.h>\fP
.PP
Inherits \fBlibMesh::UnstructuredMesh\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBPredicates::multi_predicate\fP \fBPredicate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSerialMesh\fP (const \fBParallel::Communicator\fP &\fBcomm\fP, unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "\fBSerialMesh\fP (unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "\fBSerialMesh\fP (const \fBUnstructuredMesh\fP &other_mesh)"
.br
.ti -1c
.RI "\fBSerialMesh\fP (const \fBSerialMesh\fP &other_mesh)"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBMeshBase\fP > \fBclone\fP () const "
.br
.ti -1c
.RI "virtual \fB~SerialMesh\fP ()"
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBrenumber_nodes_and_elements\fP ()"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_nodes\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBparallel_n_nodes\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_node_id\fP () const "
.br
.ti -1c
.RI "virtual void \fBreserve_nodes\fP (const \fBdof_id_type\fP nn)"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_elem\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBparallel_n_elem\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_active_elem\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_elem_id\fP () const "
.br
.ti -1c
.RI "virtual void \fBreserve_elem\fP (const \fBdof_id_type\fP ne)"
.br
.ti -1c
.RI "virtual void \fBupdate_parallel_id_counts\fP ()"
.br
.ti -1c
.RI "virtual const \fBPoint\fP & \fBpoint\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual const \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_point\fP (const \fBPoint\fP &p, const \fBdof_id_type\fP id=\fBDofObject::invalid_id\fP, const \fBprocessor_id_type\fP proc_id=\fBDofObject::invalid_processor_id\fP)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBinsert_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual void \fBdelete_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual void \fBrenumber_node\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBadd_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBinsert_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBdelete_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBrenumber_elem\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)"
.br
.ti -1c
.RI "virtual void \fBfix_broken_node_and_element_numbering\fP ()"
.br
.ti -1c
.RI "void \fBstitch_meshes\fP (\fBSerialMesh\fP &other_mesh, \fBboundary_id_type\fP this_mesh_boundary, \fBboundary_id_type\fP other_mesh_boundary, \fBReal\fP tol=\fBTOLERANCE\fP, bool clear_stitched_boundary_ids=false, bool verbose=true, bool use_binary_search=true, bool enforce_all_nodes_match_on_boundaries=false)"
.br
.ti -1c
.RI "void \fBstitch_surfaces\fP (\fBboundary_id_type\fP boundary_id_1, \fBboundary_id_type\fP boundary_id_2, \fBReal\fP tol=\fBTOLERANCE\fP, bool clear_stitched_boundary_ids=false, bool verbose=true, bool use_binary_search=true, bool enforce_all_nodes_match_on_boundaries=false)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBelements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBelements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBancestor_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBancestor_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBsubactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBsubactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_active_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_active_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_ancestor_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_ancestor_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_subactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_subactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_not_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_not_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlevel_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBunpartitioned_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBunpartitioned_elements_end\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBelements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBelements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBancestor_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBancestor_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBsubactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBsubactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_active_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_active_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_ancestor_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_ancestor_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_subactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_subactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_not_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_not_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlevel_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBunpartitioned_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBunpartitioned_elements_end\fP () const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBnodes_begin\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBnodes_end\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBactive_nodes_begin\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBactive_nodes_end\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBlocal_nodes_begin\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBlocal_nodes_end\fP ()"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBnodes_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBnodes_end\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBactive_nodes_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBactive_nodes_end\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBlocal_nodes_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBlocal_nodes_end\fP () const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "void \fBread\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL, bool skip_renumber_nodes_and_elements=false)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)"
.br
.ti -1c
.RI "virtual void \fBall_first_order\fP ()"
.br
.ti -1c
.RI "virtual void \fBall_second_order\fP (const bool full_ordered=true)"
.br
.ti -1c
.RI "void \fBcreate_pid_mesh\fP (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fP pid) const "
.br
.ti -1c
.RI "void \fBcreate_submesh\fP (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const "
.br
.ti -1c
.RI "virtual void \fBcopy_nodes_and_elements\fP (const \fBUnstructuredMesh\fP &other_mesh, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBfind_neighbors\fP (const bool reset_remote_elements=false, const bool reset_current_list=true)"
.br
.ti -1c
.RI "virtual bool \fBcontract\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBPartitioner\fP > & \fBpartitioner\fP ()"
.br
.ti -1c
.RI "bool \fBis_prepared\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_serial\fP () const "
.br
.ti -1c
.RI "virtual void \fBallgather\fP ()"
.br
.ti -1c
.RI "virtual void \fBdelete_remote_elements\fP ()"
.br
.ti -1c
.RI "unsigned int \fBmesh_dimension\fP () const "
.br
.ti -1c
.RI "void \fBset_mesh_dimension\fP (unsigned int d)"
.br
.ti -1c
.RI "unsigned int \fBspatial_dimension\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_nodes_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_nodes\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_nodes\fP () const "
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBnext_unique_id\fP ()"
.br
.ti -1c
.RI "void \fBset_next_unique_id\fP (\fBunique_id_type\fP id)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_sub_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_sub_elem\fP () const "
.br
.ti -1c
.RI "void \fBprepare_for_use\fP (const bool skip_renumber_nodes_and_elements=false, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBpartition\fP (const unsigned int n_parts)"
.br
.ti -1c
.RI "void \fBpartition\fP ()"
.br
.ti -1c
.RI "virtual void \fBredistribute\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_post_partitioning\fP ()"
.br
.ti -1c
.RI "void \fBallow_renumbering\fP (bool allow)"
.br
.ti -1c
.RI "bool \fBallow_renumbering\fP () const "
.br
.ti -1c
.RI "void \fBskip_partitioning\fP (bool skip)"
.br
.ti -1c
.RI "bool \fBskip_partitioning\fP () const "
.br
.ti -1c
.RI "void \fBsubdomain_ids\fP (std::set< \fBsubdomain_id_type\fP > &ids) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBn_subdomains\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_partitions\fP () const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "unsigned int \fBrecalculate_n_partitions\fP ()"
.br
.ti -1c
.RI "const \fBPointLocatorBase\fP & \fBpoint_locator\fP () const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fBsub_point_locator\fP () const "
.br
.ti -1c
.RI "void \fBclear_point_locator\fP ()"
.br
.ti -1c
.RI "virtual void \fBlibmesh_assert_valid_parallel_ids\fP () const "
.br
.ti -1c
.RI "std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id)"
.br
.ti -1c
.RI "const std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBget_id_by_name\fP (const std::string &name) const "
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBset_subdomain_name_map\fP ()"
.br
.ti -1c
.RI "const std::map
.br
< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBget_subdomain_name_map\fP () const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBBoundaryInfo\fP > \fBboundary_info\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBassign_unique_ids\fP ()"
.br
.ti -1c
.RI "unsigned int & \fBset_n_partitions\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBNode\fP * > \fB_nodes\fP"
.br
.ti -1c
.RI "std::vector< \fBElem\fP * > \fB_elements\fP"
.br
.ti -1c
.RI "unsigned int \fB_n_parts\fP"
.br
.ti -1c
.RI "unsigned int \fB_dim\fP"
.br
.ti -1c
.RI "bool \fB_is_prepared\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fB_point_locator\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPartitioner\fP > \fB_partitioner\fP"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fB_next_unique_id\fP"
.br
.ti -1c
.RI "bool \fB_skip_partitioning\fP"
.br
.ti -1c
.RI "bool \fB_skip_renumber_nodes_and_elements\fP"
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > \fB_block_id_to_name\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef std::vector< \fBElem\fP * >
.br
::iterator \fBelem_iterator_imp\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBElem\fP * >
.br
::const_iterator \fBconst_elem_iterator_imp\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBNode\fP * >
.br
::iterator \fBnode_iterator_imp\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBNode\fP * >
.br
::const_iterator \fBconst_node_iterator_imp\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBstitching_helper\fP (\fBSerialMesh\fP *other_mesh, \fBboundary_id_type\fP boundary_id_1, \fBboundary_id_type\fP boundary_id_2, \fBReal\fP tol, bool clear_stitched_boundary_ids, bool verbose, bool use_binary_search, bool enforce_all_nodes_match_on_boundaries, bool skip_find_neighbors)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBSerialMesh\fP\fP class is derived from the \fC\fBMeshBase\fP\fP class, and currently represents the default \fBMesh\fP implementation\&. Most methods for this class are found in \fBMeshBase\fP, and most implementation details are found in \fBUnstructuredMesh\fP\&. 
.PP
Definition at line 47 of file serial_mesh\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::vector<\fBElem\fP*>::const_iterator \fBlibMesh::SerialMesh::const_elem_iterator_imp\fP\fC [private]\fP"

.PP
Definition at line 435 of file serial_mesh\&.h\&.
.SS "typedef std::vector<\fBNode\fP*>::const_iterator \fBlibMesh::SerialMesh::const_node_iterator_imp\fP\fC [private]\fP"

.PP
Definition at line 442 of file serial_mesh\&.h\&.
.SS "typedef std::vector<\fBElem\fP*>::iterator \fBlibMesh::SerialMesh::elem_iterator_imp\fP\fC [private]\fP"
Typedefs for the container implementation\&. In this case, it's just a std::vector<Elem*>\&. 
.PP
Definition at line 434 of file serial_mesh\&.h\&.
.SS "typedef std::vector<\fBNode\fP*>::iterator \fBlibMesh::SerialMesh::node_iterator_imp\fP\fC [private]\fP"
Typedefs for the container implementation\&. In this case, it's just a std::vector<Node*>\&. 
.PP
Definition at line 441 of file serial_mesh\&.h\&.
.SS "typedef \fBPredicates::multi_predicate\fP \fBlibMesh::MeshBase::Predicate\fP\fC [inherited]\fP"
We need an empty, generic class to act as a predicate for this and derived mesh classes\&. 
.PP
Definition at line 632 of file mesh_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::SerialMesh::SerialMesh (const \fBParallel::Communicator\fP &comm, unsigned intdim = \fC1\fP)\fC [explicit]\fP"
Constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 117 of file serial_mesh\&.C\&.
.PP
References libMesh::MeshBase::_next_unique_id, and libMesh::MeshBase::_partitioner\&.
.PP
Referenced by clone()\&.
.PP
.nf
118                                         :
119   UnstructuredMesh (comm,d)
120 {
121 #ifdef LIBMESH_ENABLE_UNIQUE_ID
122   // In serial we just need to reset the next unique id to zero
123   // here in the constructor\&.
124   _next_unique_id = 0;
125 #endif
126   _partitioner = AutoPtr<Partitioner>(new MetisPartitioner());
127 }
.fi
.SS "libMesh::SerialMesh::SerialMesh (unsigned intdim = \fC1\fP)\fC [explicit]\fP"
Deprecated constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 132 of file serial_mesh\&.C\&.
.PP
References libMesh::MeshBase::_next_unique_id, and libMesh::MeshBase::_partitioner\&.
.PP
.nf
132                                       :
133   UnstructuredMesh (d)
134 {
135 #ifdef LIBMESH_ENABLE_UNIQUE_ID
136   // In serial we just need to reset the next unique id to zero
137   // here in the constructor\&.
138   _next_unique_id = 0;
139 #endif
140   _partitioner = AutoPtr<Partitioner>(new MetisPartitioner());
141 }
.fi
.SS "libMesh::SerialMesh::SerialMesh (const \fBUnstructuredMesh\fP &other_mesh)"
Copy-constructor\&. This should be able to take a serial or parallel mesh\&. 
.PP
Definition at line 162 of file serial_mesh\&.C\&.
.PP
References libMesh::MeshBase::boundary_info, and libMesh::UnstructuredMesh::copy_nodes_and_elements()\&.
.PP
.nf
162                                                           :
163   UnstructuredMesh (other_mesh)
164 {
165   this->copy_nodes_and_elements(other_mesh);
166   *this->boundary_info = *other_mesh\&.boundary_info;
167 }
.fi
.SS "libMesh::SerialMesh::SerialMesh (const \fBSerialMesh\fP &other_mesh)"
Copy-constructor, possibly specialized for a serial mesh\&. 
.PP
Definition at line 154 of file serial_mesh\&.C\&.
.PP
References libMesh::MeshBase::boundary_info, and libMesh::UnstructuredMesh::copy_nodes_and_elements()\&.
.PP
.nf
154                                                     :
155   UnstructuredMesh (other_mesh)
156 {
157   this->copy_nodes_and_elements(other_mesh);
158   *this->boundary_info = *other_mesh\&.boundary_info;
159 }
.fi
.SS "libMesh::SerialMesh::~SerialMesh ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 145 of file serial_mesh\&.C\&.
.PP
References clear()\&.
.PP
.nf
146 {
147   this->clear();  // Free nodes and elements
148 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 47 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by n_active_elem()\&.
.PP
.nf
48 {
49   Predicates::Active<elem_iterator_imp> p;
50   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
51 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 270 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
271 {
272   Predicates::Active<const_elem_iterator_imp> p;
273   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
274 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 493 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by n_active_elem()\&.
.PP
.nf
494 {
495   Predicates::Active<elem_iterator_imp> p;
496   return element_iterator(_elements\&.end(), _elements\&.end(), p);
497 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 720 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
721 {
722   Predicates::Active<const_elem_iterator_imp> p;
723   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
724 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_local_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 127 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
128 {
129   Predicates::ActiveLocal<elem_iterator_imp> p(this->processor_id());
130   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
131 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_local_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 350 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
351 {
352   Predicates::ActiveLocal<const_elem_iterator_imp> p(this->processor_id());
353   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
354 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_local_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 573 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
574 {
575   Predicates::ActiveLocal<elem_iterator_imp> p(this->processor_id());
576   return element_iterator(_elements\&.end(), _elements\&.end(), p);
577 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_local_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 800 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
801 {
802   Predicates::ActiveLocal<const_elem_iterator_imp> p(this->processor_id());
803   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
804 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 236 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
237 {
238   Predicates::ActiveLocalSubdomain<elem_iterator_imp> p(this->processor_id(),subdomain_id);
239   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
240 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 459 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
460 {
461   Predicates::ActiveLocalSubdomain<const_elem_iterator_imp> p(this->processor_id(),subdomain_id);
462   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
463 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 682 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
683 {
684   Predicates::ActiveLocalSubdomain<elem_iterator_imp> p(this->processor_id(),subdomain_id);
685   return element_iterator(_elements\&.end(), _elements\&.end(), p);
686 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 909 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
910 {
911   Predicates::ActiveLocalSubdomain<const_elem_iterator_imp> p(this->processor_id(),subdomain_id);
912   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
913 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::active_nodes_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 942 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
943 {
944   Predicates::Active<node_iterator_imp> p;
945   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
946 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::active_nodes_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 982 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
983 {
984   Predicates::Active<const_node_iterator_imp> p;
985   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
986 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::active_nodes_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1022 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1023 {
1024   Predicates::Active<node_iterator_imp> p;
1025   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1026 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::active_nodes_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1062 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1063 {
1064   Predicates::Active<const_node_iterator_imp> p;
1065   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1066 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_not_local_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 137 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
138 {
139   Predicates::ActiveNotLocal<elem_iterator_imp> p(this->processor_id());
140   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
141 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_not_local_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 360 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
361 {
362   Predicates::ActiveNotLocal<const_elem_iterator_imp> p(this->processor_id());
363   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
364 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_not_local_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 583 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
584 {
585   Predicates::ActiveNotLocal<elem_iterator_imp> p(this->processor_id());
586   return element_iterator(_elements\&.end(), _elements\&.end(), p);
587 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_not_local_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 810 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
811 {
812   Predicates::ActiveNotLocal<const_elem_iterator_imp> p(this->processor_id());
813   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
814 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 217 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
218 {
219   Predicates::ActivePID<elem_iterator_imp> p(proc_id);
220   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
221 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 440 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
441 {
442   Predicates::ActivePID<const_elem_iterator_imp> p(proc_id);
443   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
444 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 663 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
664 {
665   Predicates::ActivePID<elem_iterator_imp> p(proc_id);
666   return element_iterator(_elements\&.end(), _elements\&.end(), p);
667 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 890 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
891 {
892   Predicates::ActivePID<const_elem_iterator_imp> p(proc_id);
893   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
894 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 246 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
247 {
248   Predicates::ActiveSubdomain<elem_iterator_imp> p(subdomain_id);
249   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
250 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 469 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
470 {
471   Predicates::ActiveSubdomain<const_elem_iterator_imp> p(subdomain_id);
472   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
473 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 692 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
693 {
694   Predicates::ActiveSubdomain<elem_iterator_imp> p(subdomain_id);
695   return element_iterator(_elements\&.end(), _elements\&.end(), p);
696 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 919 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
920 {
921   Predicates::ActiveSubdomain<const_elem_iterator_imp> p(subdomain_id);
922   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
923 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_type_elements_begin (const \fBElemType\fPtype)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 207 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
208 {
209   Predicates::ActiveType<elem_iterator_imp> p(type);
210   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
211 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_type_elements_begin (const \fBElemType\fPtype) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 430 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
431 {
432   Predicates::ActiveType<const_elem_iterator_imp> p(type);
433   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
434 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::active_type_elements_end (const \fBElemType\fPtype)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 653 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
654 {
655   Predicates::ActiveType<elem_iterator_imp> p(type);
656   return element_iterator(_elements\&.end(), _elements\&.end(), p);
657 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::active_type_elements_end (const \fBElemType\fPtype) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 880 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
881 {
882   Predicates::ActiveType<const_elem_iterator_imp> p(type);
883   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
884 }
.fi
.SS "\fBElem\fP * libMesh::SerialMesh::add_elem (\fBElem\fP *e)\fC [virtual]\fP"
Add elem \fCe\fP to the end of the element array\&. To add an element locally, set e->\fBprocessor_id()\fP before adding it\&. To ensure a specific element id, call e->set_id() before adding it; only do this in parallel if you are manually keeping ids consistent\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 315 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::MeshBase::_next_unique_id, libMesh::DofObject::id(), libMesh::libmesh_assert(), libMesh::DofObject::set_id(), libMesh::DofObject::set_unique_id(), libMesh::DofObject::valid_id(), and libMesh::DofObject::valid_unique_id()\&.
.PP
.nf
316 {
317   libmesh_assert(e);
318 
319   // We no longer merely append elements with SerialMesh
320 
321   // If the user requests a valid id that doesn't correspond to an
322   // existing element, let's give them that id, resizing the elements
323   // container if necessary\&.
324   if (!e->valid_id())
325     e->set_id (_elements\&.size());
326 
327 #ifdef LIBMESH_ENABLE_UNIQUE_ID
328   if (!e->valid_unique_id())
329     e->set_unique_id() = _next_unique_id++;
330 #endif
331 
332   const dof_id_type id = e->id();
333 
334   if (id < _elements\&.size())
335     {
336       // Overwriting existing elements is still probably a mistake\&.
337       libmesh_assert(!_elements[id]);
338     }
339   else
340     {
341       _elements\&.resize(id+1, NULL);
342     }
343 
344   _elements[id] = e;
345 
346   return e;
347 }
.fi
.SS "\fBNode\fP * libMesh::SerialMesh::add_node (\fBNode\fP *n)\fC [virtual]\fP"
Add \fC\fBNode\fP\fP \fCn\fP to the end of the vertex array\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 474 of file serial_mesh\&.C\&.
.PP
References libMesh::MeshBase::_next_unique_id, _nodes, libMesh::DofObject::id(), libMesh::libmesh_assert(), libMesh::DofObject::set_id(), libMesh::DofObject::set_unique_id(), libMesh::DofObject::valid_id(), and libMesh::DofObject::valid_unique_id()\&.
.PP
.nf
475 {
476   libmesh_assert(n);
477   // We only append points with SerialMesh
478   libmesh_assert(!n->valid_id() || n->id() == _nodes\&.size());
479 
480   n->set_id (_nodes\&.size());
481 
482 #ifdef LIBMESH_ENABLE_UNIQUE_ID
483   if (!n->valid_unique_id())
484     n->set_unique_id() = _next_unique_id++;
485 #endif
486 
487   _nodes\&.push_back(n);
488 
489   return n;
490 }
.fi
.SS "\fBNode\fP * libMesh::SerialMesh::add_point (const \fBPoint\fP &p, const \fBdof_id_type\fPid = \fC\fBDofObject::invalid_id\fP\fP, const \fBprocessor_id_type\fPproc_id = \fC\fBDofObject::invalid_processor_id\fP\fP)\fC [virtual]\fP"
functions for adding /deleting nodes elements\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 427 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::Node::build(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
430 {
431   //   // We only append points with SerialMesh
432   //   libmesh_assert(id == DofObject::invalid_id || id == _nodes\&.size());
433   //   Node *n = Node::build(p, _nodes\&.size())\&.release();
434   //   n->processor_id() = proc_id;
435   //   _nodes\&.push_back (n);
436 
437   Node *n = NULL;
438 
439   // If the user requests a valid id, either
440   // provide the existing node or resize the container
441   // to fit the new node\&.
442   if (id != DofObject::invalid_id)
443     if (id < _nodes\&.size())
444       n = _nodes[id];
445     else
446       _nodes\&.resize(id+1);
447   else
448     _nodes\&.push_back (static_cast<Node*>(NULL));
449 
450   // if the node already exists, then assign new (x,y,z) values
451   if (n)
452     *n = p;
453   // otherwise build a new node, put it in the right spot, and return
454   // a valid pointer\&.
455   else
456     {
457       n = Node::build(p, (id == DofObject::invalid_id) ? _nodes\&.size()-1 : id)\&.release();
458       n->processor_id() = proc_id;
459 
460       if (id == DofObject::invalid_id)
461         _nodes\&.back() = n;
462       else
463         _nodes[id] = n;
464     }
465 
466   // better not pass back a NULL pointer\&.
467   libmesh_assert (n);
468 
469   return n;
470 }
.fi
.SS "void libMesh::UnstructuredMesh::all_first_order ()\fC [virtual]\fP, \fC [inherited]\fP"
Converts a mesh with higher-order elements into a mesh with linear elements\&. For example, a mesh consisting of \fC\fBTet10\fP\fP will be converted to a mesh with \fC\fBTet4\fP\fP etc\&. Prepare to identify (and then delete) a bunch of no-longer-used nodes\&.
.PP
Loop over the high-ordered elements\&. First make sure they \fIare\fP indeed high-order, and then replace them with an equivalent first-order element\&.
.PP
If the second order element had any boundary conditions they should be transfered to the first-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 292 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::Elem::add_child(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::delete_node(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::Elem::first_order_equivalent_type(), libMesh::Elem::get_node(), libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::libmesh_assert(), libMesh::MeshBase::max_node_id(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::Elem::replace_child(), libMesh::DofObject::set_id(), libMesh::Elem::set_neighbor(), libMesh::Elem::set_node(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Elem::set_p_level(), libMesh::Elem::set_p_refinement_flag(), libMesh::Elem::set_parent(), libMesh::Elem::set_refinement_flag(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
293 {
294   /*
295    * when the mesh is not prepared,
296    * at least renumber the nodes and
297    * elements, so that the node ids
298    * are correct
299    */
300   if (!this->_is_prepared)
301     this->renumber_nodes_and_elements ();
302 
303   START_LOG("all_first_order()", "Mesh");
304 
308   std::vector<bool> node_touched_by_me(this->max_node_id(), false);
309 
315   element_iterator endit = elements_end();
316   for (element_iterator it = elements_begin();
317        it != endit; ++it)
318     {
319       Elem* so_elem = *it;
320 
321       libmesh_assert(so_elem);
322 
323       /*
324        * build the first-order equivalent, add to
325        * the new_elements list\&.
326        */
327       Elem* lo_elem = Elem::build
328         (Elem::first_order_equivalent_type
329          (so_elem->type()), so_elem->parent())\&.release();
330 
331       for (unsigned int s=0; s != so_elem->n_sides(); ++s)
332         if (so_elem->neighbor(s) == remote_elem)
333           lo_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
334 
335 #ifdef LIBMESH_ENABLE_AMR
336       /*
337        * Reset the parent links of any child elements
338        */
339       if (so_elem->has_children())
340         for (unsigned int c=0; c != so_elem->n_children(); ++c)
341           {
342             so_elem->child(c)->set_parent(lo_elem);
343             lo_elem->add_child(so_elem->child(c), c);
344           }
345 
346       /*
347        * Reset the child link of any parent element
348        */
349       if (so_elem->parent())
350         {
351           unsigned int c =
352             so_elem->parent()->which_child_am_i(so_elem);
353           lo_elem->parent()->replace_child(lo_elem, c);
354         }
355 
356       /*
357        * Copy as much data to the new element as makes sense
358        */
359       lo_elem->set_p_level(so_elem->p_level());
360       lo_elem->set_refinement_flag(so_elem->refinement_flag());
361       lo_elem->set_p_refinement_flag(so_elem->p_refinement_flag());
362 #endif
363 
364       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
365 
366       /*
367        * By definition the vertices of the linear and
368        * second order element are identically numbered\&.
369        * transfer these\&.
370        */
371       for (unsigned int v=0; v < so_elem->n_vertices(); v++)
372         {
373           lo_elem->set_node(v) = so_elem->get_node(v);
374           node_touched_by_me[lo_elem->node(v)] = true;
375         }
376 
383       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
384 
385       for (unsigned int s=0; s<so_elem->n_sides(); s++)
386         {
387           const std::vector<boundary_id_type> boundary_ids =
388             this->boundary_info->raw_boundary_ids (so_elem, s);
389 
390           this->boundary_info->add_side (lo_elem, s, boundary_ids);
391         }
392 
393       /*
394        * The new first-order element is ready\&.
395        * Inserting it into the mesh will replace and delete
396        * the second-order element\&.
397        */
398       lo_elem->set_id(so_elem->id());
399       lo_elem->processor_id() = so_elem->processor_id();
400       lo_elem->subdomain_id() = so_elem->subdomain_id();
401       this->insert_elem(lo_elem);
402     }
403 
404   const MeshBase::node_iterator nd_end = this->nodes_end();
405   MeshBase::node_iterator nd = this->nodes_begin();
406   while (nd != nd_end)
407     {
408       Node *the_node = *nd;
409       ++nd;
410       if (!node_touched_by_me[the_node->id()])
411         this->delete_node(the_node);
412     }
413 
414   STOP_LOG("all_first_order()", "Mesh");
415 
416   // On hanging nodes that used to also be second order nodes, we
417   // might now have an invalid nodal processor_id()
418   Partitioner::set_node_processor_ids(*this);
419 
420   // delete or renumber nodes, etc
421   this->prepare_for_use(/*skip_renumber =*/ false);
422 }
.fi
.SS "void libMesh::UnstructuredMesh::all_second_order (const boolfull_ordered = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Converts a (conforming, non-refined) mesh with linear elements into a mesh with second-order elements\&. For example, a mesh consisting of \fC\fBTet4\fP\fP will be converted to a mesh with \fC\fBTet10\fP\fP etc\&. Note that for some elements like \fC\fBHex8\fP\fP there exist \fItwo\fP higher order equivalents, \fC\fBHex20\fP\fP and \fC\fBHex27\fP\fP\&. When \fCfull_ordered\fP is \fCtrue\fP (default), then \fC\fBHex27\fP\fP is built\&. Otherwise, \fC\fBHex20\fP\fP is built\&. The same holds obviously for \fC\fBQuad4\fP\fP, \fC\fBPrism6\fP\fP \&.\&.\&. Loop over the low-ordered elements in the \fIelements vector\&. First make sure they _are\fP indeed low-order, and then replace them with an equivalent second-order element\&. Don't forget to delete the low-order element, or else it will leak!
.PP
If the linear element had any boundary conditions they should be transfered to the second-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Also, \fBprepare_for_use()\fP will reconstruct most of our neighbor links, but if we have any remote_elem links in a distributed mesh, they need to be preserved\&. We do that in the same loop here\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 426 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::add_point(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::ParallelObject::comm(), libMesh::Elem::default_order(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::err, libMesh::FIRST, libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::DofObject::invalid_id, libMesh::MeshBase::is_serial(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::MeshBase::node(), libMesh::MeshBase::point(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Real, libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::reserve_nodes(), libMesh::Elem::second_order_equivalent_type(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube()\&.
.PP
.nf
427 {
428   // This function must be run on all processors at once
429   parallel_object_only();
430 
431   /*
432    * when the mesh is not prepared,
433    * at least renumber the nodes and
434    * elements, so that the node ids
435    * are correct
436    */
437   if (!this->_is_prepared)
438     this->renumber_nodes_and_elements ();
439 
440   /*
441    * If the mesh is empty
442    * then we have nothing to do
443    */
444   if (!this->n_elem())
445     return;
446 
447   /*
448    * If the mesh is already second order
449    * then we have nothing to do\&.
450    * We have to test for this in a round-about way to avoid
451    * a bug on distributed parallel meshes with more processors
452    * than elements\&.
453    */
454   bool already_second_order = false;
455   if (this->elements_begin() != this->elements_end() &&
456       (*(this->elements_begin()))->default_order() != FIRST)
457     already_second_order = true;
458   this->comm()\&.max(already_second_order);
459   if (already_second_order)
460     return;
461 
462   START_LOG("all_second_order()", "Mesh");
463 
464   /*
465    * this map helps in identifying second order
466    * nodes\&.  Namely, a second-order node:
467    * - edge node
468    * - face node
469    * - bubble node
470    * is uniquely defined through a set of adjacent
471    * vertices\&.  This set of adjacent vertices is
472    * used to identify already added higher-order
473    * nodes\&.  We are safe to use node id's since we
474    * make sure that these are correctly numbered\&.
475    */
476   std::map<std::vector<dof_id_type>, Node*> adj_vertices_to_so_nodes;
477 
478   /*
479    * for speed-up of the \p add_point() method, we
480    * can reserve memory\&.  Guess the number of additional
481    * nodes for different dimensions
482    */
483   switch (this->mesh_dimension())
484     {
485     case 1:
486       /*
487        * in 1D, there can only be order-increase from Edge2
488        * to Edge3\&.  Something like 1/2 of n_nodes() have
489        * to be added
490        */
491       this->reserve_nodes(static_cast<unsigned int>
492                           (1\&.5*static_cast<double>(this->n_nodes())));
493       break;
494 
495     case 2:
496       /*
497        * in 2D, either refine from Tri3 to Tri6 (double the nodes)
498        * or from Quad4 to Quad8 (again, double) or Quad9 (2\&.25 that much)
499        */
500       this->reserve_nodes(static_cast<unsigned int>
501                           (2*static_cast<double>(this->n_nodes())));
502       break;
503 
504 
505     case 3:
506       /*
507        * in 3D, either refine from Tet4 to Tet10 (factor = 2\&.5) up to
508        * Hex8 to Hex27 (something  > 3)\&.  Since in 3D there _are_ already
509        * quite some nodes, and since we do not want to overburden the memory by
510        * a too conservative guess, use the lower bound
511        */
512       this->reserve_nodes(static_cast<unsigned int>
513                           (2\&.5*static_cast<double>(this->n_nodes())));
514       break;
515 
516     default:
517       // Hm?
518       libmesh_error();
519     }
520 
521 
522 
523   /*
524    * form a vector that will hold the node id's of
525    * the vertices that are adjacent to the son-th
526    * second-order node\&.  Pull this outside of the
527    * loop so that silly compilers don't repeatedly
528    * create and destroy the vector\&.
529    */
530   std::vector<dof_id_type> adjacent_vertices_ids;
531 
538   const_element_iterator endit = elements_end();
539   for (const_element_iterator it = elements_begin();
540        it != endit; ++it)
541     {
542       // the linear-order element
543       const Elem* lo_elem = *it;
544 
545       libmesh_assert(lo_elem);
546 
547       // make sure it is linear order
548       if (lo_elem->default_order() != FIRST)
549         {
550           libMesh::err << "ERROR: This is not a linear element: type="
551                        << lo_elem->type() << std::endl;
552           libmesh_error();
553         }
554 
555       // this does _not_ work for refined elements
556       libmesh_assert_equal_to (lo_elem->level (), 0);
557 
558       /*
559        * build the second-order equivalent, add to
560        * the new_elements list\&.  Note that this here
561        * is the only point where \p full_ordered
562        * is necessary\&.  The remaining code works well
563        * for either type of seconrd-order equivalent, e\&.g\&.
564        * Hex20 or Hex27, as equivalents for Hex8
565        */
566       Elem* so_elem =
567         Elem::build (Elem::second_order_equivalent_type(lo_elem->type(),
568                                                         full_ordered) )\&.release();
569 
570       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
571 
572 
573       /*
574        * By definition the vertices of the linear and
575        * second order element are identically numbered\&.
576        * transfer these\&.
577        */
578       for (unsigned int v=0; v < lo_elem->n_vertices(); v++)
579         so_elem->set_node(v) = lo_elem->get_node(v);
580 
581       /*
582        * Now handle the additional mid-side nodes\&.  This
583        * is simply handled through a map that remembers
584        * the already-added nodes\&.  This map maps the global
585        * ids of the vertices (that uniquely define this
586        * higher-order node) to the new node\&.
587        * Notation: son = second-order node
588        */
589       const unsigned int son_begin = so_elem->n_vertices();
590       const unsigned int son_end   = so_elem->n_nodes();
591 
592 
593       for (unsigned int son=son_begin; son<son_end; son++)
594         {
595           const unsigned int n_adjacent_vertices =
596             so_elem->n_second_order_adjacent_vertices(son);
597 
598           adjacent_vertices_ids\&.resize(n_adjacent_vertices);
599 
600           for (unsigned int v=0; v<n_adjacent_vertices; v++)
601             adjacent_vertices_ids[v] =
602               so_elem->node( so_elem->second_order_adjacent_vertex(son,v) );
603 
604           /*
605            * \p adjacent_vertices_ids is now in order of the current
606            * side\&.  sort it, so that comparisons  with the
607            * \p adjacent_vertices_ids created through other elements'
608            * sides can match
609            */
610           std::sort(adjacent_vertices_ids\&.begin(),
611                     adjacent_vertices_ids\&.end());
612 
613 
614           // does this set of vertices already has a mid-node added?
615           std::pair<std::map<std::vector<dof_id_type>, Node*>::iterator,
616             std::map<std::vector<dof_id_type>, Node*>::iterator>
617             pos = adj_vertices_to_so_nodes\&.equal_range (adjacent_vertices_ids);
618 
619           // no, not added yet
620           if (pos\&.first == pos\&.second)
621             {
622               /*
623                * for this set of vertices, there is no
624                * second_order node yet\&.  Add it\&.
625                *
626                * compute the location of the new node as
627                * the average over the adjacent vertices\&.
628                */
629               Point new_location = this->point(adjacent_vertices_ids[0]);
630               for (unsigned int v=1; v<n_adjacent_vertices; v++)
631                 new_location += this->point(adjacent_vertices_ids[v]);
632 
633               new_location /= static_cast<Real>(n_adjacent_vertices);
634 
635               /* Add the new point to the mesh, giving it a globally
636                * well-defined processor id\&.
637                */
638               Node* so_node = this->add_point
639                 (new_location, DofObject::invalid_id,
640                  this->node(adjacent_vertices_ids[0])\&.processor_id());
641 
642               /*
643                * insert the new node with its defining vertex
644                * set into the map, and relocate pos to this
645                * new entry, so that the so_elem can use
646                * \p pos for inserting the node
647                */
648               adj_vertices_to_so_nodes\&.insert(pos\&.first,
649                                               std::make_pair(adjacent_vertices_ids,
650                                                              so_node));
651 
652               so_elem->set_node(son) = so_node;
653             }
654           // yes, already added\&.
655           else
656             {
657               libmesh_assert(pos\&.first->second);
658 
659               so_elem->set_node(son) = pos\&.first->second;
660             }
661         }
662 
663 
675       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
676 
677       for (unsigned int s=0; s<lo_elem->n_sides(); s++)
678         {
679           const std::vector<boundary_id_type> boundary_ids =
680             this->boundary_info->raw_boundary_ids (lo_elem, s);
681 
682           this->boundary_info->add_side (so_elem, s, boundary_ids);
683 
684           if (lo_elem->neighbor(s) == remote_elem)
685             so_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
686         }
687 
688       /*
689        * The new second-order element is ready\&.
690        * Inserting it into the mesh will replace and delete
691        * the first-order element\&.
692        */
693       so_elem->set_id(lo_elem->id());
694       so_elem->processor_id() = lo_elem->processor_id();
695       so_elem->subdomain_id() = lo_elem->subdomain_id();
696       this->insert_elem(so_elem);
697     }
698 
699   // we can clear the map
700   adj_vertices_to_so_nodes\&.clear();
701 
702 
703   STOP_LOG("all_second_order()", "Mesh");
704 
705   // In a ParallelMesh our ghost node processor ids may be bad and
706   // the ids of nodes touching remote elements may be inconsistent\&.
707   // Fix them\&.
708   if (!this->is_serial())
709     {
710       LocationMap<Node> loc_map;
711       MeshCommunication()\&.make_nodes_parallel_consistent
712         (*this, loc_map);
713     }
714 
715   // renumber nodes, elements etc
716   this->prepare_for_use(/*skip_renumber =*/ false);
717 }
.fi
.SS "virtual void libMesh::MeshBase::allgather ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Gathers all elements and nodes of the mesh onto every processor 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 140 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::EquationSystems::allgather(), and libMesh::MeshSerializer::MeshSerializer()\&.
.PP
.nf
140 {}
.fi
.SS "void libMesh::MeshBase::allow_renumbering (boolallow)\fC [inline]\fP, \fC [inherited]\fP"
If false is passed in then this mesh will no longer be renumbered when being prepared for use\&. This may slightly adversely affect performance during subsequent element access, particulary when using a distributed mesh\&. 
.PP
Definition at line 536 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::ErrorVector::plot_error()\&.
.PP
.nf
536 { _skip_renumber_nodes_and_elements = !allow; }
.fi
.SS "bool libMesh::MeshBase::allow_renumbering () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 537 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use(), and libMesh::UnstructuredMesh::read()\&.
.PP
.nf
537 { return !_skip_renumber_nodes_and_elements; }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::ancestor_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 67 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
68 {
69   Predicates::Ancestor<elem_iterator_imp> p;
70   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
71 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::ancestor_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 290 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
291 {
292   Predicates::Ancestor<const_elem_iterator_imp> p;
293   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
294 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::ancestor_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 513 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
514 {
515   Predicates::Ancestor<elem_iterator_imp> p;
516   return element_iterator(_elements\&.end(), _elements\&.end(), p);
517 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::ancestor_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 740 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
741 {
742   Predicates::Ancestor<const_elem_iterator_imp> p;
743   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
744 }
.fi
.SS "void libMesh::SerialMesh::assign_unique_ids ()\fC [protected]\fP, \fC [virtual]\fP"
Assign globally unique IDs to all DOF objects (Elements and Nodes) if the library has been configured with unique_id support\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1348 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::MeshBase::_next_unique_id, and _nodes\&.
.PP
.nf
1349 {
1350   for (dof_id_type i=0; i<_elements\&.size(); ++i)
1351     if (_elements[i] && ! _elements[i]->valid_unique_id())
1352       _elements[i]->set_unique_id() = _next_unique_id++;
1353 
1354   for (dof_id_type i=0; i<_nodes\&.size(); ++i)
1355     if (_nodes[i] && ! _nodes[i]->valid_unique_id())
1356       _nodes[i]->set_unique_id() = _next_unique_id++;
1357 }
.fi
.SS "void libMesh::SerialMesh::clear ()\fC [virtual]\fP"
Clear all internal data\&. 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 591 of file serial_mesh\&.C\&.
.PP
References _elements, _nodes, libMesh::MeshBase::clear(), and end\&.
.PP
Referenced by ~SerialMesh()\&.
.PP
.nf
592 {
593   // Call parent clear function
594   MeshBase::clear();
595 
596 
597   // Clear our elements and nodes
598   {
599     std::vector<Elem*>::iterator       it  = _elements\&.begin();
600     const std::vector<Elem*>::iterator end = _elements\&.end();
601 
602     // There is no need to remove the elements from
603     // the BoundaryInfo data structure since we
604     // already cleared it\&.
605     for (; it != end; ++it)
606       delete *it;
607 
608     _elements\&.clear();
609   }
610 
611   // clear the nodes data structure
612   {
613     std::vector<Node*>::iterator       it  = _nodes\&.begin();
614     const std::vector<Node*>::iterator end = _nodes\&.end();
615 
616     // There is no need to remove the nodes from
617     // the BoundaryInfo data structure since we
618     // already cleared it\&.
619     for (; it != end; ++it)
620       delete *it;
621 
622     _nodes\&.clear();
623   }
624 }
.fi
.SS "void libMesh::MeshBase::clear_point_locator ()\fC [inherited]\fP"
Releases the current \fCPointLocator\fP object\&. 
.PP
Definition at line 415 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator\&.
.PP
Referenced by libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::contract(), and libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
416 {
417   _point_locator\&.reset(NULL);
418 }
.fi
.SS "virtual \fBAutoPtr\fP<\fBMeshBase\fP> libMesh::SerialMesh::clone () const\fC [inline]\fP, \fC [virtual]\fP"
Virtual copy-constructor, creates a copy of this mesh 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 86 of file serial_mesh\&.h\&.
.PP
References SerialMesh()\&.
.PP
.nf
87   { return AutoPtr<MeshBase>(new SerialMesh(*this)); }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "bool libMesh::UnstructuredMesh::contract ()\fC [virtual]\fP, \fC [inherited]\fP"
Delete subactive (i\&.e\&. children of coarsened) elements\&. This removes all elements descended from currently active elements in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1131 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::MeshBase::clear_point_locator(), libMesh::Elem::contract(), libMesh::MeshBase::delete_elem(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::libmesh_assert(), libMesh::Elem::parent(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::subactive()\&.
.PP
.nf
1132 {
1133   START_LOG ("contract()", "Mesh");
1134 
1135   // Flag indicating if this call actually changes the mesh
1136   bool mesh_changed = false;
1137 
1138   element_iterator in        = elements_begin();
1139   const element_iterator end = elements_end();
1140 
1141 #ifdef DEBUG
1142   for ( ; in != end; ++in)
1143     if (*in != NULL)
1144       {
1145         Elem* el = *in;
1146         libmesh_assert(el->active() || el->subactive() || el->ancestor());
1147       }
1148   in = elements_begin();
1149 #endif
1150 
1151   // Loop over the elements\&.
1152   for ( ; in != end; ++in)
1153     if (*in != NULL)
1154       {
1155         Elem* el = *in;
1156 
1157         // Delete all the subactive ones
1158         if (el->subactive())
1159           {
1160             // No level-0 element should be subactive\&.
1161             // Note that we CAN'T test elem->level(), as that
1162             // touches elem->parent()->dim(), and elem->parent()
1163             // might have already been deleted!
1164             libmesh_assert(el->parent());
1165 
1166             // Delete the element
1167             // This just sets a pointer to NULL, and doesn't
1168             // invalidate any iterators
1169             this->delete_elem(el);
1170 
1171             // the mesh has certainly changed
1172             mesh_changed = true;
1173           }
1174         else
1175           {
1176             // Compress all the active ones
1177             if (el->active())
1178               el->contract();
1179             else
1180               libmesh_assert (el->ancestor());
1181           }
1182       }
1183 
1184   // Strip any newly-created NULL voids out of the element array
1185   this->renumber_nodes_and_elements();
1186 
1187   // FIXME: Need to understand why deleting subactive children
1188   // invalidates the point locator\&.  For now we will clear it explicitly
1189   this->clear_point_locator();
1190 
1191   STOP_LOG ("contract()", "Mesh");
1192 
1193   return mesh_changed;
1194 }
.fi
.SS "void libMesh::UnstructuredMesh::copy_nodes_and_elements (const \fBUnstructuredMesh\fP &other_mesh, const boolskip_find_neighbors = \fCfalse\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Deep copy of another unstructured mesh class (used by subclass copy constructors) 
.PP
Definition at line 104 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_n_parts, libMesh::Elem::add_child(), libMesh::MeshBase::allow_renumbering(), libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::Elem::n_children(), libMesh::MeshBase::n_elem(), libMesh::Elem::n_neighbors(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::MeshBase::skip_partitioning(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
Referenced by libMesh::ParallelMesh::ParallelMesh(), SerialMesh(), and stitching_helper()\&.
.PP
.nf
105 {
106   // We're assuming our subclass data needs no copy
107   libmesh_assert_equal_to (_n_parts, other_mesh\&._n_parts);
108   libmesh_assert_equal_to (_dim, other_mesh\&._dim);
109   libmesh_assert_equal_to (_is_prepared, other_mesh\&._is_prepared);
110 
111   // We're assuming the other mesh has proper element number ordering,
112   // so that we add parents before their children\&.
113 #ifdef DEBUG
114   MeshTools::libmesh_assert_valid_amr_elem_ids(other_mesh);
115 #endif
116 
117   //Copy in Nodes
118   {
119     //Preallocate Memory if necessary
120     this->reserve_nodes(other_mesh\&.n_nodes());
121 
122     const_node_iterator it = other_mesh\&.nodes_begin();
123     const_node_iterator end = other_mesh\&.nodes_end();
124 
125     for (; it != end; ++it)
126       {
127         const Node *oldn = *it;
128 
129         // Add new nodes in old node Point locations
130         /*Node *newn =*/ this->add_point(*oldn, oldn->id(), oldn->processor_id());
131 
132         // And start them off in the same subdomain
133         //        newn->processor_id() = oldn->processor_id();
134       }
135   }
136 
137   //Copy in Elements
138   {
139     //Preallocate Memory if necessary
140     this->reserve_elem(other_mesh\&.n_elem());
141 
142     // Declare a map linking old and new elements, needed to copy the neighbor lists
143     std::map<const Elem*, Elem*> old_elems_to_new_elems;
144 
145     // Loop over the elements
146     MeshBase::const_element_iterator it = other_mesh\&.elements_begin();
147     const MeshBase::const_element_iterator end = other_mesh\&.elements_end();
148 
149     // FIXME: Where do we set element IDs??
150     for (; it != end; ++it)
151       {
152         //Look at the old element
153         const Elem *old = *it;
154         //Build a new element
155         Elem *newparent = old->parent() ?
156           this->elem(old->parent()->id()) : NULL;
157         AutoPtr<Elem> ap = Elem::build(old->type(), newparent);
158         Elem * el = ap\&.release();
159 
160         el->subdomain_id() = old->subdomain_id();
161 
162         for (unsigned int s=0; s != old->n_sides(); ++s)
163           if (old->neighbor(s) == remote_elem)
164             el->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
165 
166 #ifdef LIBMESH_ENABLE_AMR
167         if (old->has_children())
168           for (unsigned int c=0; c != old->n_children(); ++c)
169             if (old->child(c) == remote_elem)
170               el->add_child(const_cast<RemoteElem*>(remote_elem), c);
171 
172         //Create the parent's child pointers if necessary
173         if (newparent)
174           {
175             unsigned int oldc = old->parent()->which_child_am_i(old);
176             newparent->add_child(el, oldc);
177           }
178 
179         // Copy the refinement flags
180         el->set_refinement_flag(old->refinement_flag());
181         el->set_p_refinement_flag(old->p_refinement_flag());
182 #endif // #ifdef LIBMESH_ENABLE_AMR
183 
184         //Assign all the nodes
185         for(unsigned int i=0;i<el->n_nodes();i++)
186           el->set_node(i) = &this->node(old->node(i));
187 
188         // And start it off in the same subdomain
189         el->processor_id() = old->processor_id();
190 
191         // Give it the same id
192         el->set_id(old->id());
193 
194         //Hold onto it
195         if(!skip_find_neighbors)
196           {
197             this->add_elem(el);
198           }
199         else
200           {
201             Elem* new_el = this->add_elem(el);
202             old_elems_to_new_elems[old] = new_el;
203           }
204 
205         // Add the link between the original element and this copy to the map
206         if(skip_find_neighbors)
207           old_elems_to_new_elems[old] = el;
208       }
209 
210     // Loop (again) over the elements to fill in the neighbors
211     if(skip_find_neighbors)
212       {
213         it = other_mesh\&.elements_begin();
214         for (; it != end; ++it)
215           {
216             Elem* old_elem = *it;
217             Elem* new_elem = old_elems_to_new_elems[old_elem];
218             for (unsigned int s=0; s != old_elem->n_neighbors(); ++s)
219               {
220                 const Elem* old_neighbor = old_elem->neighbor(s);
221                 Elem* new_neighbor = old_elems_to_new_elems[old_neighbor];
222                 new_elem->set_neighbor(s, new_neighbor);
223               }
224           }
225       }
226   }
227 
228   //Finally prepare the new Mesh for use\&.  Keep the same numbering and
229   //partitioning but also the same renumbering and partitioning
230   //policies as our source mesh\&.
231   this->allow_renumbering(false);
232   this->skip_partitioning(true);
233   this->prepare_for_use(false, skip_find_neighbors);
234   this->allow_renumbering(other_mesh\&.allow_renumbering());
235   this->skip_partitioning(other_mesh\&.skip_partitioning());
236 }
.fi
.SS "void libMesh::UnstructuredMesh::create_pid_mesh (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fPpid) const\fC [inherited]\fP"
Generates a new mesh containing all the elements which are assigned to processor \fCpid\fP\&. This mesh is written to the pid_mesh reference which you must create and pass to the function\&. 
.PP
Definition at line 997 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), libMesh::UnstructuredMesh::create_submesh(), libMesh::ParallelObject::n_processors(), and libMesh::out\&.
.PP
.nf
999 {
1000 
1001   // Issue a warning if the number the number of processors
1002   // currently available is less that that requested for
1003   // partitioning\&.  This is not necessarily an error since
1004   // you may run on one processor and still partition the
1005   // mesh into several partitions\&.
1006 #ifdef DEBUG
1007   if (this->n_processors() < pid)
1008     {
1009       libMesh::out << "WARNING:  You are creating a "
1010                    << "mesh for a processor id (="
1011                    << pid
1012                    << ") greater than "
1013                    << "the number of processors available for "
1014                    << "the calculation\&. (="
1015                    << this->n_processors()
1016                    << ")\&."
1017                    << std::endl;
1018     }
1019 #endif
1020 
1021   // Create iterators to loop over the list of elements
1022   //   const_active_pid_elem_iterator       it(this->elements_begin(),   pid);
1023   //   const const_active_pid_elem_iterator it_end(this->elements_end(), pid);
1024 
1025   const_element_iterator       it     = this->active_pid_elements_begin(pid);
1026   const const_element_iterator it_end = this->active_pid_elements_end(pid);
1027 
1028   this->create_submesh (pid_mesh, it, it_end);
1029 }
.fi
.SS "void libMesh::UnstructuredMesh::create_submesh (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const\fC [inherited]\fP"
Constructs a mesh called 'new_mesh' from the current mesh by iterating over the elements between it and it_end and adding them to the new mesh\&. 
.PP
Definition at line 1037 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::add_elem(), libMesh::MeshBase::add_point(), bc_id, libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::MeshBase::clear(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::node(), libMesh::MeshBase::node_ptr(), libMesh::Elem::point(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::set_node(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::UnstructuredMesh::create_pid_mesh()\&.
.PP
.nf
1040 {
1041   // Just in case the subdomain_mesh already has some information
1042   // in it, get rid of it\&.
1043   new_mesh\&.clear();
1044 
1045   // Fail if (*this == new_mesh), we cannot create a submesh inside ourself!
1046   // This may happen if the user accidently passes the original mesh into
1047   // this function!  We will check this by making sure we did not just
1048   // clear ourself\&.
1049   libmesh_assert_not_equal_to (this->n_nodes(), 0);
1050   libmesh_assert_not_equal_to (this->n_elem(), 0);
1051 
1052   // How the nodes on this mesh will be renumbered to nodes
1053   // on the new_mesh\&.
1054   std::vector<dof_id_type> new_node_numbers (this->n_nodes());
1055 
1056   std::fill (new_node_numbers\&.begin(),
1057              new_node_numbers\&.end(),
1058              DofObject::invalid_id);
1059 
1060 
1061 
1062   // the number of nodes on the new mesh, will be incremented
1063   dof_id_type n_new_nodes = 0;
1064   dof_id_type n_new_elem  = 0;
1065 
1066   for (; it != it_end; ++it)
1067     {
1068       // increment the new element counter
1069       n_new_elem++;
1070 
1071       const Elem* old_elem = *it;
1072 
1073       // Add an equivalent element type to the new_mesh
1074       Elem* new_elem =
1075         new_mesh\&.add_elem (Elem::build(old_elem->type())\&.release());
1076 
1077       libmesh_assert(new_elem);
1078 
1079       // Loop over the nodes on this element\&.
1080       for (unsigned int n=0; n<old_elem->n_nodes(); n++)
1081         {
1082           libmesh_assert_less (old_elem->node(n), new_node_numbers\&.size());
1083 
1084           if (new_node_numbers[old_elem->node(n)] == DofObject::invalid_id)
1085             {
1086               new_node_numbers[old_elem->node(n)] = n_new_nodes;
1087 
1088               // Add this node to the new mesh
1089               new_mesh\&.add_point (old_elem->point(n));
1090 
1091               // Increment the new node counter
1092               n_new_nodes++;
1093             }
1094 
1095           // Define this element's connectivity on the new mesh
1096           libmesh_assert_less (new_node_numbers[old_elem->node(n)], new_mesh\&.n_nodes());
1097 
1098           new_elem->set_node(n) = new_mesh\&.node_ptr (new_node_numbers[old_elem->node(n)]);
1099         }
1100 
1101       // Copy ids for this element
1102       new_elem->subdomain_id() = old_elem->subdomain_id();
1103       new_elem->processor_id() = old_elem->processor_id();
1104 
1105       // Maybe add boundary conditions for this element
1106       for (unsigned int s=0; s<old_elem->n_sides(); s++)
1107         // We're supporting boundary ids on internal sides now
1108         //if (old_elem->neighbor(s) == NULL)
1109         {
1110           const std::vector<boundary_id_type>& bc_ids = this->boundary_info->boundary_ids(old_elem, s);
1111           for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1112             {
1113               const boundary_id_type bc_id = *id_it;
1114               if (bc_id != this->boundary_info->invalid_id)
1115                 new_mesh\&.boundary_info->add_side (new_elem,
1116                                                   s,
1117                                                   bc_id);
1118             }
1119         }
1120     } // end loop over elements
1121 
1122 
1123   // Prepare the new_mesh for use
1124   new_mesh\&.prepare_for_use(/*skip_renumber =*/false);
1125 
1126 }
.fi
.SS "void libMesh::SerialMesh::delete_elem (\fBElem\fP *e)\fC [virtual]\fP"
Removes element \fCe\fP from the mesh\&. Note that calling this method may produce isolated nodes, i\&.e\&. nodes not connected to any element\&. This method must be implemented in derived classes in such a way that it does not invalidate element iterators\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 370 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::MeshBase::boundary_info, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
Referenced by insert_elem()\&.
.PP
.nf
371 {
372   libmesh_assert(e);
373 
374   // Initialize an iterator to eventually point to the element we want to delete
375   std::vector<Elem*>::iterator pos = _elements\&.end();
376 
377   // In many cases, e->id() gives us a clue as to where e
378   // is located in the _elements vector\&.  Try that first
379   // before trying the O(n_elem) search\&.
380   libmesh_assert_less (e->id(), _elements\&.size());
381 
382   if (_elements[e->id()] == e)
383     {
384       // We found it!
385       pos = _elements\&.begin();
386       std::advance(pos, e->id());
387     }
388 
389   else
390     {
391       // This search is O(n_elem)
392       pos = std::find (_elements\&.begin(),
393                        _elements\&.end(),
394                        e);
395     }
396 
397   // Huh? Element not in the vector?
398   libmesh_assert (pos != _elements\&.end());
399 
400   // Remove the element from the BoundaryInfo object
401   this->boundary_info->remove(e);
402 
403   // delete the element
404   delete e;
405 
406   // explicitly NULL the pointer
407   *pos = NULL;
408 }
.fi
.SS "void libMesh::SerialMesh::delete_node (\fBNode\fP *n)\fC [virtual]\fP"
Removes the \fBNode\fP n from the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 537 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::MeshBase::boundary_info, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
538 {
539   libmesh_assert(n);
540   libmesh_assert_less (n->id(), _nodes\&.size());
541 
542   // Initialize an iterator to eventually point to the element we want
543   // to delete
544   std::vector<Node*>::iterator pos;
545 
546   // In many cases, e->id() gives us a clue as to where e
547   // is located in the _elements vector\&.  Try that first
548   // before trying the O(n_elem) search\&.
549   if (_nodes[n->id()] == n)
550     {
551       pos = _nodes\&.begin();
552       std::advance(pos, n->id());
553     }
554   else
555     {
556       pos = std::find (_nodes\&.begin(),
557                        _nodes\&.end(),
558                        n);
559     }
560 
561   // Huh? Node not in the vector?
562   libmesh_assert (pos != _nodes\&.end());
563 
564   // Delete the node from the BoundaryInfo object
565   this->boundary_info->remove(n);
566 
567   // delete the node
568   delete n;
569 
570   // explicitly NULL the pointer
571   *pos = NULL;
572 }
.fi
.SS "virtual void libMesh::MeshBase::delete_remote_elements ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
When supported, deletes all nonlocal elements of the mesh except for 'ghosts' which touch a local element, and deletes all nodes which are not part of a local or ghost element 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 147 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_extrusion(), libMesh::EquationSystems::init(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::BoundaryInfo::sync(), and libMesh::MeshSerializer::~MeshSerializer()\&.
.PP
.nf
147 {}
.fi
.SS "const \fBElem\fP * libMesh::SerialMesh::elem (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 265 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::libmesh_assert(), and n_elem()\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
266 {
267   libmesh_assert_less (i, this->n_elem());
268   libmesh_assert(_elements[i]);
269   libmesh_assert_equal_to (_elements[i]->id(), i); // This will change soon
270 
271   return _elements[i];
272 }
.fi
.SS "\fBElem\fP * libMesh::SerialMesh::elem (const \fBdof_id_type\fPi)\fC [virtual]\fP"
Return a writeable pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 277 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::libmesh_assert(), and n_elem()\&.
.PP
.nf
278 {
279   libmesh_assert_less (i, this->n_elem());
280   libmesh_assert(_elements[i]);
281   libmesh_assert_equal_to (_elements[i]->id(), i); // This will change soon
282 
283   return _elements[i];
284 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::elements_begin ()\fC [virtual]\fP"
\fBElem\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 37 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
38 {
39   Predicates::NotNull<elem_iterator_imp> p;
40   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
41 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::elements_begin () const\fC [virtual]\fP"
const \fBElem\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 260 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
261 {
262   Predicates::NotNull<const_elem_iterator_imp> p;
263   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
264 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 483 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
484 {
485   Predicates::NotNull<elem_iterator_imp> p;
486   return element_iterator(_elements\&.end(), _elements\&.end(), p);
487 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 710 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
711 {
712   Predicates::NotNull<const_elem_iterator_imp> p;
713   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
714 }
.fi
.SS "void libMesh::UnstructuredMesh::find_neighbors (const boolreset_remote_elements = \fCfalse\fP, const boolreset_current_list = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Other functions from \fBMeshBase\fP requiring re-definition\&. Here we look at all of the child elements which don't already have valid neighbors\&.
.PP
If a child element has a NULL neighbor it is either because it is on the boundary or because its neighbor is at a different level\&. In the latter case we must get the neighbor from the parent\&.
.PP
If a child element has a remote_elem neighbor on a boundary it shares with its parent, that info may have become out-dated through coarsening of the neighbor's parent\&. In this case, if the parent's neighbor is active then the child should share it\&.
.PP
Furthermore, that neighbor better be active, otherwise we missed a child somewhere\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 251 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::Elem::centroid(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::err, libMesh::Elem::has_children(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::Elem::is_child_on_side(), libMesh::Elem::key(), libMesh::Elem::level(), libMesh::MeshBase::level_elements_begin(), libMesh::MeshBase::level_elements_end(), libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::Elem::n_children(), libMesh::MeshTools::n_levels(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::Elem::side(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subactive(), libMesh::Elem::which_child_am_i(), and libMesh::GMVIO::write()\&.
.PP
Referenced by libMesh::TriangleWrapper::copy_tri_to_mesh()\&.
.PP
.nf
253 {
254   // We might actually want to run this on an empty mesh
255   // (e\&.g\&. the boundary mesh for a nonexistant bcid!)
256   // libmesh_assert_not_equal_to (this->n_nodes(), 0);
257   // libmesh_assert_not_equal_to (this->n_elem(), 0);
258 
259   // This function must be run on all processors at once
260   parallel_object_only();
261 
262   START_LOG("find_neighbors()", "Mesh");
263 
264   const element_iterator el_end = this->elements_end();
265 
266   //TODO:[BSK] This should be removed later?!
267   if (reset_current_list)
268     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
269       {
270         Elem* e = *el;
271         for (unsigned int s=0; s<e->n_neighbors(); s++)
272           if (e->neighbor(s) != remote_elem ||
273               reset_remote_elements)
274             e->set_neighbor(s,NULL);
275       }
276 
277   // Find neighboring elements by first finding elements
278   // with identical side keys and then check to see if they
279   // are neighbors
280   {
281     // data structures -- Use the hash_multimap if available
282     typedef unsigned int                    key_type;
283     typedef std::pair<Elem*, unsigned char> val_type;
284     typedef std::pair<key_type, val_type>   key_val_pair;
285 
286     typedef LIBMESH_BEST_UNORDERED_MULTIMAP<key_type, val_type> map_type;
287 
288     // A map from side keys to corresponding elements & side numbers
289     map_type side_to_elem_map;
290 
291 
292 
293     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
294       {
295         Elem* element = *el;
296 
297         for (unsigned int ms=0; ms<element->n_neighbors(); ms++)
298           {
299           next_side:
300             // If we haven't yet found a neighbor on this side, try\&.
301             // Even if we think our neighbor is remote, that
302             // information may be out of date\&.
303             if (element->neighbor(ms) == NULL ||
304                 element->neighbor(ms) == remote_elem)
305               {
306                 // Get the key for the side of this element
307                 const unsigned int key = element->key(ms);
308 
309                 // Look for elements that have an identical side key
310                 std::pair <map_type::iterator, map_type::iterator>
311                   bounds = side_to_elem_map\&.equal_range(key);
312 
313                 // May be multiple keys, check all the possible
314                 // elements which _might_ be neighbors\&.
315                 if (bounds\&.first != bounds\&.second)
316                   {
317                     // Get the side for this element
318                     const AutoPtr<Elem> my_side(element->side(ms));
319 
320                     // Look at all the entries with an equivalent key
321                     while (bounds\&.first != bounds\&.second)
322                       {
323                         // Get the potential element
324                         Elem* neighbor = bounds\&.first->second\&.first;
325 
326                         // Get the side for the neighboring element
327                         const unsigned int ns = bounds\&.first->second\&.second;
328                         const AutoPtr<Elem> their_side(neighbor->side(ns));
329                         //libmesh_assert(my_side\&.get());
330                         //libmesh_assert(their_side\&.get());
331 
332                         // If found a match with my side
333                         //
334                         // We need special tests here for 1D:
335                         // since parents and children have an equal
336                         // side (i\&.e\&. a node), we need to check
337                         // ns != ms, and we also check level() to
338                         // avoid setting our neighbor pointer to
339                         // any of our neighbor's descendants
340                         if( (*my_side == *their_side) &&
341                             (element->level() == neighbor->level()) &&
342                             ((_dim != 1) || (ns != ms)) )
343                           {
344                             // So share a side\&.  Is this a mixed pair
345                             // of subactive and active/ancestor
346                             // elements?
347                             // If not, then we're neighbors\&.
348                             // If so, then the subactive's neighbor is
349 
350                             if (element->subactive() ==
351                                 neighbor->subactive())
352                               {
353                                 // an element is only subactive if it has
354                                 // been coarsened but not deleted
355                                 element->set_neighbor (ms,neighbor);
356                                 neighbor->set_neighbor(ns,element);
357                               }
358                             else if (element->subactive())
359                               {
360                                 element->set_neighbor(ms,neighbor);
361                               }
362                             else if (neighbor->subactive())
363                               {
364                                 neighbor->set_neighbor(ns,element);
365                               }
366                             side_to_elem_map\&.erase (bounds\&.first);
367 
368                             // get out of this nested crap
369                             goto next_side;
370                           }
371 
372                         ++bounds\&.first;
373                       }
374                   }
375 
376                 // didn't find a match\&.\&.\&.
377                 // Build the map entry for this element
378                 key_val_pair kvp;
379 
380                 kvp\&.first         = key;
381                 kvp\&.second\&.first  = element;
382                 kvp\&.second\&.second = ms;
383 
384                 // use the lower bound as a hint for
385                 // where to put it\&.
386 #if defined(LIBMESH_HAVE_UNORDERED_MAP) || defined(LIBMESH_HAVE_TR1_UNORDERED_MAP) || defined(LIBMESH_HAVE_HASH_MAP) || defined(LIBMESH_HAVE_EXT_HASH_MAP)
387                 side_to_elem_map\&.insert (kvp);
388 #else
389                 side_to_elem_map\&.insert (bounds\&.first,kvp);
390 #endif
391               }
392           }
393       }
394   }
395 
396 #ifdef LIBMESH_ENABLE_AMR
397 
418   const unsigned int n_levels = MeshTools::n_levels(*this);
419   for (unsigned int level = 1; level < n_levels; ++level)
420     {
421       element_iterator end = this->level_elements_end(level);
422       for (element_iterator el = this->level_elements_begin(level);
423            el != end; ++el)
424         {
425           Elem* current_elem = *el;
426           libmesh_assert(current_elem);
427           Elem* parent = current_elem->parent();
428           libmesh_assert(parent);
429           const unsigned int my_child_num = parent->which_child_am_i(current_elem);
430 
431           for (unsigned int s=0; s < current_elem->n_neighbors(); s++)
432             {
433               if (current_elem->neighbor(s) == NULL ||
434                   (current_elem->neighbor(s) == remote_elem &&
435                    parent->is_child_on_side(my_child_num, s)))
436                 {
437                   Elem *neigh = parent->neighbor(s);
438 
439                   // If neigh was refined and had non-subactive children
440                   // made remote earlier, then a non-subactive elem should
441                   // actually have one of those remote children as a
442                   // neighbor
443                   if (neigh && (neigh->ancestor()) && (!current_elem->subactive()))
444                     {
445 #ifdef DEBUG
446                       // Let's make sure that "had children made remote"
447                       // situation is actually the case
448                       libmesh_assert(neigh->has_children());
449                       bool neigh_has_remote_children = false;
450                       for (unsigned int c = 0; c != neigh->n_children(); ++c)
451                         {
452                           if (neigh->child(c) == remote_elem)
453                             neigh_has_remote_children = true;
454                         }
455                       libmesh_assert(neigh_has_remote_children);
456 
457                       // And let's double-check that we don't have
458                       // a remote_elem neighboring a local element
459                       libmesh_assert_not_equal_to (current_elem->processor_id(),
460                                                    this->processor_id());
461 #endif // DEBUG
462                       neigh = const_cast<RemoteElem*>(remote_elem);
463                     }
464 
465                   current_elem->set_neighbor(s, neigh);
466 #ifdef DEBUG
467                   if (neigh != NULL && neigh != remote_elem)
468                     // We ignore subactive elements here because
469                     // we don't care about neighbors of subactive element\&.
470                     if ((!neigh->active()) && (!current_elem->subactive()))
471                       {
472                         libMesh::err << "On processor " << this->processor_id()
473                                      << std::endl;
474                         libMesh::err << "Bad element ID = " << current_elem->id()
475                                      << ", Side " << s << ", Bad neighbor ID = " << neigh->id() << std::endl;
476                         libMesh::err << "Bad element proc_ID = " << current_elem->processor_id()
477                                      << ", Bad neighbor proc_ID = " << neigh->processor_id() << std::endl;
478                         libMesh::err << "Bad element size = " << current_elem->hmin()
479                                      << ", Bad neighbor size = " << neigh->hmin() << std::endl;
480                         libMesh::err << "Bad element center = " << current_elem->centroid()
481                                      << ", Bad neighbor center = " << neigh->centroid() << std::endl;
482                         libMesh::err << "ERROR: "
483                                      << (current_elem->active()?"Active":"Ancestor")
484                                      << " Element at level "
485                                      << current_elem->level() << std::endl;
486                         libMesh::err << "with "
487                                      << (parent->active()?"active":
488                                          (parent->subactive()?"subactive":"ancestor"))
489                                      << " parent share "
490                                      << (neigh->subactive()?"subactive":"ancestor")
491                                      << " neighbor at level " << neigh->level()
492                                      << std::endl;
493                         GMVIO(*this)\&.write ("bad_mesh\&.gmv");
494                         libmesh_error();
495                       }
496 #endif // DEBUG
497                 }
498             }
499         }
500     }
501 
502 #endif // AMR
503 
504 
505 #ifdef DEBUG
506   MeshTools::libmesh_assert_valid_neighbors(*this);
507 #endif
508 
509   STOP_LOG("find_neighbors()", "Mesh");
510 }
.fi
.SS "void libMesh::SerialMesh::fix_broken_node_and_element_numbering ()\fC [virtual]\fP"
There is no reason for a user to ever call this function\&.
.PP
This function restores a previously broken element/node numbering such that \fCmesh\&.node(n)->id()\fP == n\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 787 of file serial_mesh\&.C\&.
.PP
References _elements, and _nodes\&.
.PP
.nf
788 {
789   // Nodes first
790   for (dof_id_type n=0; n<this->_nodes\&.size(); n++)
791     if (this->_nodes[n] != NULL)
792       this->_nodes[n]->set_id() = n;
793 
794   // Elements next
795   for (dof_id_type e=0; e<this->_elements\&.size(); e++)
796     if (this->_elements[e] != NULL)
797       this->_elements[e]->set_id() = e;
798 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::get_id_by_name (const std::string &name) const\fC [inherited]\fP"
Returns a the id of the requested block by name\&. Throws an error if a block by name is not found 
.PP
Definition at line 442 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name, and libMesh::err\&.
.PP
.nf
443 {
444   // This function is searching the *values* of the map (linear search)
445   // We might want to make this more efficient\&.\&.\&.
446   std::map<subdomain_id_type, std::string>::const_iterator
447     iter = _block_id_to_name\&.begin(),
448     end_iter = _block_id_to_name\&.end();
449 
450   for ( ; iter != end_iter; ++iter)
451     {
452       if (iter->second == name)
453         return iter->first;
454     }
455 
456   libMesh::err << "Block '" << name << "' does not exist in mesh" << std::endl;
457   libmesh_error();
458 }
.fi
.SS "std::string libMesh::MeshBase::get_info () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a string containing relevant information about the mesh\&. 
.RE
.PP

.PP
Definition at line 306 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_active_elem(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::MeshBase::n_nodes(), libMesh::MeshBase::n_partitions(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::n_subdomains(), libMesh::n_threads, libMesh::ParallelObject::processor_id(), and libMesh::MeshBase::spatial_dimension()\&.
.PP
Referenced by libMesh::MeshBase::print_info()\&.
.PP
.nf
307 {
308   std::ostringstream oss;
309 
310   oss << " Mesh Information:"                                  << '\n'
311       << "  mesh_dimension()="    << this->mesh_dimension()    << '\n'
312       << "  spatial_dimension()=" << this->spatial_dimension() << '\n'
313       << "  n_nodes()="           << this->n_nodes()           << '\n'
314       << "    n_local_nodes()="   << this->n_local_nodes()     << '\n'
315       << "  n_elem()="            << this->n_elem()            << '\n'
316       << "    n_local_elem()="    << this->n_local_elem()      << '\n'
317 #ifdef LIBMESH_ENABLE_AMR
318       << "    n_active_elem()="   << this->n_active_elem()     << '\n'
319 #endif
320       << "  n_subdomains()="      << static_cast<std::size_t>(this->n_subdomains()) << '\n'
321       << "  n_partitions()="      << static_cast<std::size_t>(this->n_partitions()) << '\n'
322       << "  n_processors()="      << static_cast<std::size_t>(this->n_processors()) << '\n'
323       << "  n_threads()="         << static_cast<std::size_t>(libMesh::n_threads()) << '\n'
324       << "  processor_id()="      << static_cast<std::size_t>(this->processor_id()) << '\n';
325 
326   return oss\&.str();
327 }
.fi
.SS "const std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::get_subdomain_name_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 843 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::write_serialized_subdomain_names(), and libMesh::CheckpointIO::write_subdomain_names()\&.
.PP
.nf
844   { return _block_id_to_name; }
.fi
.SS "\fBElem\fP * libMesh::SerialMesh::insert_elem (\fBElem\fP *e)\fC [virtual]\fP"
Insert elem \fCe\fP to the element array, preserving its id and replacing/deleting any existing element with the same id\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 351 of file serial_mesh\&.C\&.
.PP
References _elements, delete_elem(), and libMesh::DofObject::id()\&.
.PP
.nf
352 {
353   dof_id_type eid = e->id();
354   libmesh_assert_less (eid, _elements\&.size());
355   Elem *oldelem = _elements[eid];
356 
357   if (oldelem)
358     {
359       libmesh_assert_equal_to (oldelem->id(), eid);
360       this->delete_elem(oldelem);
361     }
362 
363   _elements[e->id()] = e;
364 
365   return e;
366 }
.fi
.SS "\fBNode\fP * libMesh::SerialMesh::insert_node (\fBNode\fP *n)\fC [virtual]\fP"
Insert \fC\fBNode\fP\fP \fCn\fP into the \fBMesh\fP at a location consistent with n->id(), allocating extra storage if necessary\&. Throws an error if: \&.) n==NULL \&.) n->id() == \fBDofObject::invalid_id\fP \&.) A node already exists in position n->id()\&.
.PP
This function differs from the \fBSerialMesh::add_node()\fP function, which is only capable of appending nodes at the end of the nodes storage\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 494 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::err, libMesh::DofObject::id(), and libMesh::DofObject::invalid_id\&.
.PP
.nf
495 {
496   if (!n)
497     {
498       libMesh::err << "Error, attempting to insert NULL node\&." << std::endl;
499       libmesh_error();
500     }
501 
502   if (n->id() == DofObject::invalid_id)
503     {
504       libMesh::err << "Error, cannot insert node with invalid id\&." << std::endl;
505       libmesh_error();
506     }
507 
508   if (n->id() < _nodes\&.size())
509     {
510       // Don't allow inserting on top of an existing Node\&.
511       if (_nodes[ n->id() ] != NULL)
512         {
513           libMesh::err << "Error, cannot insert node on top of existing node\&." << std::endl;
514           libmesh_error();
515         }
516     }
517   else
518     {
519       // Allocate just enough space to store the new node\&.  This will
520       // cause highly non-ideal memory allocation behavior if called
521       // repeatedly\&.\&.\&.
522       _nodes\&.resize(n->id() + 1);
523     }
524 
525 
526   // We have enough space and this spot isn't already occupied by
527   // another node, so go ahead and add it\&.
528   _nodes[ n->id() ] = n;
529 
530   // If we made it this far, we just inserted the node the user handed
531   // us, so we can give it right back\&.
532   return n;
533 }
.fi
.SS "bool libMesh::MeshBase::is_prepared () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the mesh has been prepared via a call to \fCprepare_for_use\fP, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 126 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_is_prepared\&.
.PP
Referenced by libMesh::DofMap::build_sparsity(), libMesh::DofMap::create_dof_constraints(), libMesh::DofMap::distribute_dofs(), and libMesh::DofMap::reinit()\&.
.PP
.nf
127   { return _is_prepared; }
.fi
.SS "virtual bool libMesh::MeshBase::is_serial () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if all elements and nodes of the mesh exist on the current processor, \fCfalse\fP otherwise 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 133 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MetisPartitioner::_do_partition(), libMesh::MeshRefinement::_refine_elements(), libMesh::UnstructuredMesh::all_second_order(), libMesh::EquationSystems::allgather(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshRefinement::coarsen_elements(), libMesh::DofMap::create_dof_constraints(), libMesh::LocationMap< T >::init(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshSerializer::MeshSerializer(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshBase::partition(), libMesh::MeshBase::prepare_for_use(), libMesh::DofMap::process_constraints(), libMesh::Nemesis_IO::read(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::EquationSystems::write(), libMesh::LegacyXdrIO::write_mesh(), and libMesh::XdrIO::write_parallel()\&.
.PP
.nf
134   { return true; }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::level_elements_begin (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 147 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
148 {
149   Predicates::Level<elem_iterator_imp> p(level);
150   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
151 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 370 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
371 {
372   Predicates::Level<const_elem_iterator_imp> p(level);
373   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
374 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::level_elements_end (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 593 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
594 {
595   Predicates::Level<elem_iterator_imp> p(level);
596   return element_iterator(_elements\&.end(), _elements\&.end(), p);
597 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::level_elements_end (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 820 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
821 {
822   Predicates::Level<const_elem_iterator_imp> p(level);
823   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
824 }
.fi
.SS "virtual void libMesh::MeshBase::libmesh_assert_valid_parallel_ids () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Verify id and processor_id consistency of our elements and nodes containers\&. Calls \fBlibmesh_assert()\fP on each possible failure\&. Currently only implemented on \fBParallelMesh\fP; a serial data structure is much harder to get out of sync\&. 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 692 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_refine_elements(), libMesh::InfElemBuilder::build_inf_elem(), and libMesh::MeshRefinement::refine_and_coarsen_elements()\&.
.PP
.nf
692 {}
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 107 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
108 {
109   Predicates::Local<elem_iterator_imp> p(this->processor_id());
110   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
111 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 330 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
331 {
332   Predicates::Local<const_elem_iterator_imp> p(this->processor_id());
333   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
334 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 553 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
554 {
555   Predicates::Local<elem_iterator_imp> p(this->processor_id());
556   return element_iterator(_elements\&.end(), _elements\&.end(), p);
557 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 780 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
781 {
782   Predicates::Local<const_elem_iterator_imp> p(this->processor_id());
783   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
784 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 167 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
168 {
169   Predicates::LocalLevel<elem_iterator_imp> p(this->processor_id(),level);
170   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
171 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 390 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
391 {
392   Predicates::LocalLevel<const_elem_iterator_imp> p(this->processor_id(),level);
393   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
394 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_level_elements_end (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 613 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
614 {
615   Predicates::LocalLevel<elem_iterator_imp> p(this->processor_id(),level);
616   return element_iterator(_elements\&.end(), _elements\&.end(), p);
617 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 840 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
841 {
842   Predicates::LocalLevel<const_elem_iterator_imp> p(this->processor_id(),level);
843   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
844 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::local_nodes_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 952 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
953 {
954   Predicates::Local<node_iterator_imp> p(this->processor_id());
955   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
956 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::local_nodes_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 992 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
993 {
994   Predicates::Local<const_node_iterator_imp> p(this->processor_id());
995   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
996 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::local_nodes_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1032 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
1033 {
1034   Predicates::Local<node_iterator_imp> p(this->processor_id());
1035   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1036 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::local_nodes_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1072 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
1073 {
1074   Predicates::Local<const_node_iterator_imp> p(this->processor_id());
1075   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1076 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_not_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 177 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
178 {
179   Predicates::LocalNotLevel<elem_iterator_imp> p(this->processor_id(),level);
180   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
181 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_not_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 400 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
401 {
402   Predicates::LocalNotLevel<const_elem_iterator_imp> p(this->processor_id(),level);
403   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
404 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::local_not_level_elements_end (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 623 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
624 {
625   Predicates::LocalNotLevel<elem_iterator_imp> p(this->processor_id(),level);
626   return element_iterator(_elements\&.end(), _elements\&.end(), p);
627 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::local_not_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 850 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
851 {
852   Predicates::LocalNotLevel<const_elem_iterator_imp> p(this->processor_id(),level);
853   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
854 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::max_elem_id () const\fC [inline]\fP, \fC [virtual]\fP"
Returns a number greater than or equal to the maximum element id in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 124 of file serial_mesh\&.h\&.
.PP
References _elements\&.
.PP
.nf
125   { return libmesh_cast_int<dof_id_type>(_elements\&.size()); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::max_node_id () const\fC [inline]\fP, \fC [virtual]\fP"
Returns a number greater than or equal to the maximum node id in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 110 of file serial_mesh\&.h\&.
.PP
References _nodes\&.
.PP
.nf
111   { return libmesh_cast_int<dof_id_type>(_nodes\&.size()); }
.fi
.SS "unsigned int libMesh::MeshBase::mesh_dimension () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the logical dimension of the mesh; i\&.e\&. the manifold dimension of the elements in the mesh\&. If we ever support multi-dimensional meshes (e\&.g\&. hexes and quads in the same mesh) then this will return the largest such dimension\&. 
.RE
.PP

.PP
Definition at line 155 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::EquationSystems::build_variable_names(), libMesh::System::calculate_norm(), libMesh::DofMap::create_dof_constraints(), libMesh::MeshTools::Modification::distort(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshBase::get_info(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::LaplaceMeshSmoother::init(), libMesh::PointLocatorTree::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::FEInterface::n_vec_dim(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::MeshFunction::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::System::read_header(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshTools::Modification::rotate(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshTools::Modification::smooth(), libMesh::BoundaryInfo::sync(), libMesh::DofMap::use_coupled_neighbor_dofs(), libMesh::PostscriptIO::write(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::UCDIO::write_nodal_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
156   { return static_cast<unsigned int>(_dim); }
.fi
.SS "\fBdof_id_type\fP libMesh::SerialMesh::n_active_elem () const\fC [virtual]\fP"
Returns the number of active elements in the mesh\&. Implemented in terms of active_element_iterators\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1340 of file serial_mesh\&.C\&.
.PP
References active_elements_begin(), and active_elements_end()\&.
.PP
.nf
1341 {
1342   return static_cast<dof_id_type>(std::distance (this->active_elements_begin(),
1343                                                  this->active_elements_end()));
1344 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of active elements on processor \fCproc\fP\&. 
.PP
Definition at line 267 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), and libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::n_active_local_elem()\&.
.PP
.nf
268 {
269   libmesh_assert_less (proc_id, this->n_processors());
270   return static_cast<dof_id_type>(std::distance (this->active_pid_elements_begin(proc_id),
271                                                  this->active_pid_elements_end  (proc_id)));
272 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of active elements on the local processor\&. 
.PP
Definition at line 300 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_active_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParmetisPartitioner::build_graph(), libMesh::VTKIO::cells_to_vtk(), and libMesh::ParmetisPartitioner::initialize()\&.
.PP
.nf
301   { return this->n_active_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_sub_elem () const\fC [inherited]\fP"
Same, but only counts active elements\&. 
.PP
Definition at line 291 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), and end\&.
.PP
Referenced by libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_old_impl(), and libMesh::TecplotIO::write_binary()\&.
.PP
.nf
292 {
293   dof_id_type ne=0;
294 
295   const_element_iterator       el  = this->active_elements_begin();
296   const const_element_iterator end = this->active_elements_end();
297 
298   for (; el!=end; ++el)
299     ne += (*el)->n_sub_elem();
300 
301   return ne;
302 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::n_elem () const\fC [inline]\fP, \fC [virtual]\fP"
Returns the number of elements in the mesh\&. The standard \fBn_elem()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 116 of file serial_mesh\&.h\&.
.PP
References _elements\&.
.PP
Referenced by elem(), query_elem(), and stitching_helper()\&.
.PP
.nf
117   { return libmesh_cast_int<dof_id_type>(_elements\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of elements on processor \fCproc\fP\&. 
.PP
Definition at line 254 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_elements_begin(), and libMesh::MeshBase::pid_elements_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_elem(), and libMesh::MeshBase::n_unpartitioned_elem()\&.
.PP
.nf
255 {
256   // We're either counting a processor's elements or unpartitioned
257   // elements
258   libmesh_assert (proc_id < this->n_processors() ||
259                   proc_id == DofObject::invalid_processor_id);
260 
261   return static_cast<dof_id_type>(std::distance (this->pid_elements_begin(proc_id),
262                                                  this->pid_elements_end  (proc_id)));
263 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements on the local processor\&. 
.PP
Definition at line 283 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), and libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
284   { return this->n_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes on the local processor\&. 
.PP
Definition at line 197 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_nodes_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::VTKIO::nodes_to_vtk(), and libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
198   { return this->n_nodes_on_proc (this->processor_id()); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::n_nodes () const\fC [inline]\fP, \fC [virtual]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The standard \fBn_nodes()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 104 of file serial_mesh\&.h\&.
.PP
References _nodes\&.
.PP
Referenced by node(), node_ptr(), point(), query_node_ptr(), and stitching_helper()\&.
.PP
.nf
105   { return libmesh_cast_int<dof_id_type>(_nodes\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_nodes_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of nodes on processor \fCproc\fP\&. 
.PP
Definition at line 241 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_nodes_begin(), and libMesh::MeshBase::pid_nodes_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_nodes(), and libMesh::MeshBase::n_unpartitioned_nodes()\&.
.PP
.nf
242 {
243   // We're either counting a processor's nodes or unpartitioned
244   // nodes
245   libmesh_assert (proc_id < this->n_processors() ||
246                   proc_id == DofObject::invalid_processor_id);
247 
248   return static_cast<dof_id_type>(std::distance (this->pid_nodes_begin(proc_id),
249                                                  this->pid_nodes_end  (proc_id)));
250 }
.fi
.SS "unsigned int libMesh::MeshBase::n_partitions () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of partitions which have been defined via a call to either mesh\&.partition() or by building a \fBPartitioner\fP object and calling partition\&. Note that the partitioner objects are responsible for setting this value\&. 
.PP
Definition at line 578 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::Partitioner::set_node_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::UnstructuredMesh::write(), libMesh::GMVIO::write_ascii_new_impl(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.PP
.nf
579   { return _n_parts; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_sub_elem () const\fC [inherited]\fP"
This function returns the number of elements that will be written out in the Tecplot format\&. For example, a 9-noded quadrilateral will be broken into 4 linear sub-elements for plotting purposes\&. Thus, for a mesh of 2 \fCQUAD9\fP elements \fCn_tecplot_elem()\fP will return 8\&. Implemented in terms of element_iterators\&. 
.PP
Definition at line 276 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), and end\&.
.PP
.nf
277 {
278   dof_id_type ne=0;
279 
280   const_element_iterator       el  = this->elements_begin();
281   const const_element_iterator end = this->elements_end();
282 
283   for (; el!=end; ++el)
284     ne += (*el)->n_sub_elem();
285 
286   return ne;
287 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::n_subdomains () const\fC [inherited]\fP"
Returns the number of subdomains in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 226 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::subdomain_ids()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::XdrIO::write(), and libMesh::UnstructuredMesh::write()\&.
.PP
.nf
227 {
228   // This requires an inspection on every processor
229   parallel_object_only();
230 
231   std::set<subdomain_id_type> ids;
232 
233   this->subdomain_ids (ids);
234 
235   return ids\&.size();
236 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements owned by no processor\&. 
.PP
Definition at line 289 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_elem_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
290   { return this->n_elem_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes owned by no processor\&. 
.PP
Definition at line 203 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_nodes_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
204   { return this->n_nodes_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBunique_id_type\fP libMesh::MeshBase::next_unique_id ()\fC [inline]\fP, \fC [inherited]\fP"
Returns the next unique id to be used\&. 
.PP
Definition at line 216 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
216 { return _next_unique_id; }
.fi
.SS "const \fBNode\fP & libMesh::SerialMesh::node (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 183 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
184 {
185   libmesh_assert_less (i, this->n_nodes());
186   libmesh_assert(_nodes[i]);
187   libmesh_assert_equal_to (_nodes[i]->id(), i); // This will change soon
188 
189   return (*_nodes[i]);
190 }
.fi
.SS "\fBNode\fP & libMesh::SerialMesh::node (const \fBdof_id_type\fPi)\fC [virtual]\fP"
Return a reference to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 196 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), n_nodes(), and libMesh::out\&.
.PP
.nf
197 {
198   if (i >= this->n_nodes())
199     {
200       libMesh::out << " i=" << i
201                    << ", n_nodes()=" << this->n_nodes()
202                    << std::endl;
203       libmesh_error();
204     }
205 
206   libmesh_assert_less (i, this->n_nodes());
207   libmesh_assert(_nodes[i]);
208   libmesh_assert_equal_to (_nodes[i]->id(), i); // This will change soon
209 
210   return (*_nodes[i]);
211 }
.fi
.SS "const \fBNode\fP * libMesh::SerialMesh::node_ptr (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 215 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
216 {
217   libmesh_assert_less (i, this->n_nodes());
218   libmesh_assert(_nodes[i]);
219   libmesh_assert_equal_to (_nodes[i]->id(), i); // This will change soon
220 
221   return _nodes[i];
222 }
.fi
.SS "\fBNode\fP * libMesh::SerialMesh::node_ptr (const \fBdof_id_type\fPi)\fC [virtual]\fP"
Return a writeable pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 227 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
.nf
228 {
229   libmesh_assert_less (i, this->n_nodes());
230   libmesh_assert(_nodes[i]);
231   libmesh_assert_equal_to (_nodes[i]->id(), i); // This will change soon
232 
233   return _nodes[i];
234 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::nodes_begin ()\fC [virtual]\fP"
non-const \fBNode\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 932 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
933 {
934   Predicates::NotNull<node_iterator_imp> p;
935   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
936 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::nodes_begin () const\fC [virtual]\fP"
const \fBNode\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 972 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
973 {
974   Predicates::NotNull<const_node_iterator_imp> p;
975   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
976 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::nodes_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1012 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
1013 {
1014   Predicates::NotNull<node_iterator_imp> p;
1015   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1016 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::nodes_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1052 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1053 {
1054   Predicates::NotNull<const_node_iterator_imp> p;
1055   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1056 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_active_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 57 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
58 {
59   Predicates::NotActive<elem_iterator_imp> p;
60   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
61 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_active_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 280 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
281 {
282   Predicates::NotActive<const_elem_iterator_imp> p;
283   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
284 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_active_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 503 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
504 {
505   Predicates::NotActive<elem_iterator_imp> p;
506   return element_iterator(_elements\&.end(), _elements\&.end(), p);
507 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_active_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 730 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
731 {
732   Predicates::NotActive<const_elem_iterator_imp> p;
733   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
734 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_ancestor_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 77 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
78 {
79   Predicates::Ancestor<elem_iterator_imp> p;
80   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
81 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_ancestor_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 300 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
301 {
302   Predicates::Ancestor<const_elem_iterator_imp> p;
303   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
304 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_ancestor_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 523 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
524 {
525   Predicates::Ancestor<elem_iterator_imp> p;
526   return element_iterator(_elements\&.end(), _elements\&.end(), p);
527 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_ancestor_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 750 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
751 {
752   Predicates::Ancestor<const_elem_iterator_imp> p;
753   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
754 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 157 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
158 {
159   Predicates::NotLevel<elem_iterator_imp> p(level);
160   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
161 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 380 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
381 {
382   Predicates::NotLevel<const_elem_iterator_imp> p(level);
383   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
384 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_level_elements_end (const unsigned intlevel)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 603 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
604 {
605   Predicates::NotLevel<elem_iterator_imp> p(level);
606   return element_iterator(_elements\&.end(), _elements\&.end(), p);
607 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 830 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
831 {
832   Predicates::NotLevel<const_elem_iterator_imp> p(level);
833   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
834 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_local_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 117 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
118 {
119   Predicates::NotLocal<elem_iterator_imp> p(this->processor_id());
120   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
121 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_local_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 340 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
341 {
342   Predicates::NotLocal<const_elem_iterator_imp> p(this->processor_id());
343   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
344 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_local_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 563 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
564 {
565   Predicates::NotLocal<elem_iterator_imp> p(this->processor_id());
566   return element_iterator(_elements\&.end(), _elements\&.end(), p);
567 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_local_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 790 of file serial_mesh_iterators\&.C\&.
.PP
References _elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
791 {
792   Predicates::NotLocal<const_elem_iterator_imp> p(this->processor_id());
793   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
794 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_subactive_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 97 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
98 {
99   Predicates::NotSubActive<elem_iterator_imp> p;
100   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
101 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_subactive_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 320 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
321 {
322   Predicates::NotSubActive<const_elem_iterator_imp> p;
323   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
324 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::not_subactive_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 543 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
544 {
545   Predicates::NotSubActive<elem_iterator_imp> p;
546   return element_iterator(_elements\&.end(), _elements\&.end(), p);
547 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::not_subactive_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 770 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
771 {
772   Predicates::NotSubActive<const_elem_iterator_imp> p;
773   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
774 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::parallel_n_elem () const\fC [inline]\fP, \fC [virtual]\fP"
Returns the number of elements in the mesh\&. The \fBparallel_n_elem()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 119 of file serial_mesh\&.h\&.
.PP
References _elements\&.
.PP
.nf
120   { return libmesh_cast_int<dof_id_type>(_elements\&.size()); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::SerialMesh::parallel_n_nodes () const\fC [inline]\fP, \fC [virtual]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The \fBparallel_n_nodes()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 107 of file serial_mesh\&.h\&.
.PP
References _nodes\&.
.PP
.nf
108   { return libmesh_cast_int<dof_id_type>(_nodes\&.size()); }
.fi
.SS "void libMesh::MeshBase::partition (const unsigned intn_parts)\fC [virtual]\fP, \fC [inherited]\fP"
Call the default partitioner (currently \fCmetis_partition()\fP)\&. 
.PP
Definition at line 344 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::is_serial(), libMesh::MeshBase::partitioner(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshBase::skip_partitioning(), and libMesh::MeshBase::update_post_partitioning()\&.
.PP
.nf
345 {
346   // NULL partitioner means don't partition
347   // Non-serial meshes aren't ready for partitioning yet\&.
348   if(!skip_partitioning() &&
349      partitioner()\&.get() &&
350      this->is_serial())
351     {
352       partitioner()->partition (*this, n_parts);
353     }
354   else
355     {
356       // Make sure locally cached partition count
357       this->recalculate_n_partitions();
358 
359       // Make sure any other locally cached data is correct
360       this->update_post_partitioning();
361     }
362 }
.fi
.SS "void libMesh::MeshBase::partition ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 514 of file mesh_base\&.h\&.
.PP
References libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
515   { this->partition(this->n_processors()); }
.fi
.SS "virtual \fBAutoPtr\fP<\fBPartitioner\fP>& libMesh::MeshBase::partitioner ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP 
.PP
Definition at line 115 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_partitioner\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshBase::partition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
115 { return _partitioner; }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 187 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by unpartitioned_elements_begin()\&.
.PP
.nf
188 {
189   Predicates::PID<elem_iterator_imp> p(proc_id);
190   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
191 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 410 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
411 {
412   Predicates::PID<const_elem_iterator_imp> p(proc_id);
413   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
414 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 633 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
Referenced by unpartitioned_elements_end()\&.
.PP
.nf
634 {
635   Predicates::PID<elem_iterator_imp> p(proc_id);
636   return element_iterator(_elements\&.end(), _elements\&.end(), p);
637 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 860 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
861 {
862   Predicates::PID<const_elem_iterator_imp> p(proc_id);
863   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
864 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 962 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
963 {
964   Predicates::PID<node_iterator_imp> p(proc_id);
965   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
966 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1002 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1003 {
1004   Predicates::PID<const_node_iterator_imp> p(proc_id);
1005   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
1006 }
.fi
.SS "\fBSerialMesh::node_iterator\fP libMesh::SerialMesh::pid_nodes_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1042 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1043 {
1044   Predicates::PID<node_iterator_imp> p(proc_id);
1045   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1046 }
.fi
.SS "\fBSerialMesh::const_node_iterator\fP libMesh::SerialMesh::pid_nodes_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1082 of file serial_mesh_iterators\&.C\&.
.PP
References _nodes\&.
.PP
.nf
1083 {
1084   Predicates::PID<const_node_iterator_imp> p(proc_id);
1085   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1086 }
.fi
.SS "const \fBPoint\fP & libMesh::SerialMesh::point (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ point, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 170 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
Referenced by stitching_helper()\&.
.PP
.nf
171 {
172   libmesh_assert_less (i, this->n_nodes());
173   libmesh_assert(_nodes[i]);
174   libmesh_assert_equal_to (_nodes[i]->id(), i); // This will change soon
175 
176   return (*_nodes[i]);
177 }
.fi
.SS "const \fBPointLocatorBase\fP & libMesh::MeshBase::point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should never be used in threaded or non-parallel_only code, and so is deprecated\&. 
.PP
Definition at line 384 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
.nf
385 {
386   libmesh_deprecated();
387 
388   if (_point_locator\&.get() == NULL)
389     {
390       // PointLocator construction may not be safe within threads
391       libmesh_assert(!Threads::in_threads);
392 
393       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
394     }
395 
396   return *_point_locator;
397 }
.fi
.SS "void libMesh::MeshBase::prepare_for_use (const boolskip_renumber_nodes_and_elements = \fCfalse\fP, const boolskip_find_neighbors = \fCfalse\fP)\fC [inherited]\fP"
Prepare a newly created (or read) mesh for use\&. This involves 3 steps: 1\&.) call \fC\fBfind_neighbors()\fP\fP 2\&.) call \fC\fBpartition()\fP\fP 3\&.) call \fC\fBrenumber_nodes_and_elements()\fP\fP 
.PP
The argument to skip renumbering is now deprecated - to prevent a mesh from being renumbered, set allow_renumbering(false)\&. 
.PP
Definition at line 120 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_skip_renumber_nodes_and_elements, libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::assign_unique_ids(), libMesh::MeshBase::clear_point_locator(), libMesh::ParallelObject::comm(), libMesh::MeshBase::delete_remote_elements(), libMesh::dim, libMesh::MeshBase::find_neighbors(), libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::partition(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::set_mesh_dimension(), libMesh::MeshBase::update_parallel_id_counts(), and libMesh::Parallel::verify()\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshRefinement::coarsen_elements(), libMesh::UnstructuredMesh::create_submesh(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::GMVIO::read(), libMesh::UnstructuredMesh::read(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::MeshRefinement::uniformly_coarsen(), and libMesh::MeshRefinement::uniformly_refine()\&.
.PP
.nf
121 {
122   parallel_object_only();
123 
124   // A distributed mesh may have processors with no elements (or
125   // processors with no elements of higher dimension, if we ever
126   // support mixed-dimension meshes), but we want consistent
127   // mesh_dimension anyways\&.
128   libmesh_assert(this->comm()\&.verify(this->is_serial()));
129 
130   if (!this->is_serial())
131     {
132       unsigned int dim = this->mesh_dimension();
133       this->comm()\&.max(dim);
134       this->set_mesh_dimension(dim);
135     }
136 
137   // Renumber the nodes and elements so that they in contiguous
138   // blocks\&.  By default, _skip_renumber_nodes_and_elements is false\&.
139   //
140   // We may currently change that by passing
141   // skip_renumber_nodes_and_elements==true to this function, but we
142   // should use the allow_renumbering() accessor instead\&.
143   //
144   // Instances where you if prepare_for_use() should not renumber the nodes
145   // and elements include reading in e\&.g\&. an xda/r or gmv file\&. In
146   // this case, the ordering of the nodes may depend on an accompanying
147   // solution, and the node ordering cannot be changed\&.
148 
149   if (skip_renumber_nodes_and_elements)
150     {
151       libmesh_deprecated();
152       this->allow_renumbering(false);
153     }
154 
155   // Mesh modification operations might not leave us with consistent
156   // id counts, but our partitioner might need that consistency\&.
157   if(!_skip_renumber_nodes_and_elements)
158     this->renumber_nodes_and_elements();
159   else
160     this->update_parallel_id_counts();
161 
162   // Let all the elements find their neighbors
163   if(!skip_find_neighbors)
164     this->find_neighbors();
165 
166   // Partition the mesh\&.
167   this->partition();
168 
169   // If we're using ParallelMesh, we'll want it parallelized\&.
170   this->delete_remote_elements();
171 
172 #ifdef LIBMESH_ENABLE_UNIQUE_ID
173   // Assign DOF object unique ids
174   this->assign_unique_ids();
175 #endif
176 
177   if(!_skip_renumber_nodes_and_elements)
178     this->renumber_nodes_and_elements();
179 
180   // Reset our PointLocator\&.  This needs to happen any time the elements
181   // in the underlying elements in the mesh have changed, so we do it here\&.
182   this->clear_point_locator();
183 
184   // The mesh is now prepared for use\&.
185   _is_prepared = true;
186 }
.fi
.SS "void libMesh::MeshBase::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Prints relevant information about the mesh\&. 
.PP
Definition at line 330 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::get_info()\&.
.PP
Referenced by libMesh::InfElemBuilder::build_inf_elem(), and libMesh::operator<<()\&.
.PP
.nf
331 {
332   os << this->get_info()
333      << std::endl;
334 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), local_elements_end(), libMesh::ParallelMesh::local_elements_end(), local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "const \fBElem\fP * libMesh::SerialMesh::query_elem (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 289 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::libmesh_assert(), and n_elem()\&.
.PP
.nf
290 {
291   if (i >= this->n_elem())
292     return NULL;
293   libmesh_assert (_elements[i] == NULL ||
294                   _elements[i]->id() == i); // This will change soon
295 
296   return _elements[i];
297 }
.fi
.SS "\fBElem\fP * libMesh::SerialMesh::query_elem (const \fBdof_id_type\fPi)\fC [virtual]\fP"
Return a writeable pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 302 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::libmesh_assert(), and n_elem()\&.
.PP
.nf
303 {
304   if (i >= this->n_elem())
305     return NULL;
306   libmesh_assert (_elements[i] == NULL ||
307                   _elements[i]->id() == i); // This will change soon
308 
309   return _elements[i];
310 }
.fi
.SS "const \fBNode\fP * libMesh::SerialMesh::query_node_ptr (const \fBdof_id_type\fPi) const\fC [virtual]\fP"
Return a pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 239 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
.nf
240 {
241   if (i >= this->n_nodes())
242     return NULL;
243   libmesh_assert (_nodes[i] == NULL ||
244                   _nodes[i]->id() == i); // This will change soon
245 
246   return _nodes[i];
247 }
.fi
.SS "\fBNode\fP * libMesh::SerialMesh::query_node_ptr (const \fBdof_id_type\fPi)\fC [virtual]\fP"
Return a writeable pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 252 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and n_nodes()\&.
.PP
.nf
253 {
254   if (i >= this->n_nodes())
255     return NULL;
256   libmesh_assert (_nodes[i] == NULL ||
257                   _nodes[i]->id() == i); // This will change soon
258 
259   return _nodes[i];
260 }
.fi
.SS "void libMesh::UnstructuredMesh::read (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP, boolskip_renumber_nodes_and_elements = \fCfalse\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Reads the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. This is now the only way to read a mesh\&. The \fC\fBUnstructuredMesh\fP\fP then initializes its data structures and is ready for use\&.
.PP
In order to read the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you will use with this mesh, since these read methods expect it\&.
.PP
The skip_renumber_nodes_and_elements argument is now deprecated - to disallow renumbering, set \fCMeshBase::allow_renumbering(false)\fP 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 514 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::allow_renumbering(), libMesh::XdrIO::binary(), libMesh::MeshCommunication::broadcast(), libMesh::err, libMesh::XdrIO::legacy(), libMesh::ParallelObject::n_processors(), libMesh::Quality::name(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::AbaqusIO::read(), libMesh::OFFIO::read(), libMesh::UCDIO::read(), libMesh::TetGenIO::read(), libMesh::UNVIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GmshIO::read(), libMesh::GMVIO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::VTKIO::read(), libMesh::MatlabIO::read(), libMesh::LegacyXdrIO::read_mgf(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
517 {
518   // See if the file exists\&.  Perform this check on all processors
519   // so that the code is terminated properly in the case that the
520   // file does not exist\&.
521 
522   // For Nemesis files, the name we try to read will have suffixes
523   // identifying processor rank
524   if (name\&.rfind("\&.nem") + 4 == name\&.size() ||
525       name\&.rfind("\&.n") + 2 == name\&.size())
526     {
527       std::ostringstream full_name;
528 
529       // Find the length of a string which represents the highest processor ID
530       full_name << (this->n_processors());
531       unsigned field_width = full_name\&.str()\&.size();
532 
533       // reset the string stream
534       full_name\&.str("");
535 
536       // And build up the full filename
537       full_name << name
538                 << '\&.' << this->n_processors()
539                 << '\&.' << std::setfill('0') << std::setw(field_width) << this->processor_id();
540 
541       std::ifstream in (full_name\&.str()\&.c_str());
542 
543       if (!in\&.good())
544         {
545           libMesh::err << "ERROR: cannot locate specified file:\n\t"
546                        << full_name\&.str()
547                        << std::endl;
548           libmesh_error();
549         }
550     }
551   else if(name\&.rfind("\&.cp")) {} // Do error checking in the reader
552   else
553     {
554       std::ifstream in (name\&.c_str());
555 
556       if (!in\&.good())
557         {
558           libMesh::err << "ERROR: cannot locate specified file:\n\t"
559                        << name
560                        << std::endl;
561           libmesh_error();
562         }
563     }
564 
565   // Set the skip_renumber_nodes_and_elements flag on all processors\&.
566   // This ensures that renumber_nodes_and_elements is *not* called
567   // during prepare_for_use() for certain types of mesh files\&.
568   // This is required in cases where there is an associated solution
569   // file which expects a certain ordering of the nodes\&.
570   if(name\&.rfind("\&.gmv")+4==name\&.size())
571     {
572       skip_renumber_nodes_and_elements =  true;
573     }
574 
575   // Look for parallel formats first
576   if (is_parallel_file_format(name))
577     {
578       // no need to handle bz2 files here -- the Xdr class does that\&.
579       if ((name\&.rfind("\&.xda") < name\&.size()) ||
580           (name\&.rfind("\&.xdr") < name\&.size()))
581         {
582           XdrIO xdr_io(*this);
583 
584           // \&.xda* ==> bzip2/gzip/ASCII flavors
585           if (name\&.rfind("\&.xda") < name\&.size())
586             {
587               xdr_io\&.binary() = false;
588               xdr_io\&.read (name);
589             }
590           else // \&.xdr* ==> true binary XDR file
591             {
592               xdr_io\&.binary() = true;
593               xdr_io\&.read (name);
594             }
595 
596           // The xdr_io object gets constructed with legacy() == false\&.
597           // if legacy() == true then it means that a legacy file was detected and
598           // thus processor 0 performed the read\&. We therefore need to broadcast the
599           // mesh\&.  Further, for this flavor of mesh solution data ordering is tied
600           // to the node ordering, so we better not reorder the nodes!
601           if (xdr_io\&.legacy())
602             {
603               this->allow_renumbering(false);
604               MeshCommunication()\&.broadcast(*this);
605             }
606 
607           // libHilbert-enabled libMesh builds should construct files
608           // with a canonical node ordering, which libHilbert-enabled
609           // builds will be able to read in again regardless of any
610           // renumbering\&.  So in that case we're free to renumber\&.
611           // However, if either the writer or the reader of this file
612           // don't have libHilbert, then we'll have to skip
613           // renumbering because we need the numbering to remain
614           // consistent with any solution file we read in next\&.
615 #ifdef LIBMESH_HAVE_LIBHILBERT
616           // if (!xdr_io\&.libhilbert_ordering())
617           //   skip_renumber_nodes_and_elements = true;
618 #else
619           this->allow_renumbering(false);
620 #endif
621         }
622       else if (name\&.rfind("\&.nem") < name\&.size() ||
623                name\&.rfind("\&.n")   < name\&.size())
624         Nemesis_IO(*this)\&.read (name);
625       else if (name\&.rfind("\&.cp") < name\&.size())
626         {
627           if(name\&.rfind("\&.cpa") < name\&.size())
628             CheckpointIO(*this, false)\&.read(name);
629           else
630             CheckpointIO(*this, true)\&.read(name);
631         }
632     }
633 
634   // Serial mesh formats
635   else
636     {
637       START_LOG("read()", "Mesh");
638 
639       // Read the file based on extension\&.  Only processor 0
640       // needs to read the mesh\&.  It will then broadcast it and
641       // the other processors will pick it up
642       if (this->processor_id() == 0)
643         {
644           std::ostringstream pid_suffix;
645           pid_suffix << '_' << getpid();
646           // Nasty hack for reading/writing zipped files
647           std::string new_name = name;
648           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
649             {
650 #ifdef LIBMESH_HAVE_BZIP
651               new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
652               new_name += pid_suffix\&.str();
653               std::string system_string = "bunzip2 -f -k -c ";
654               system_string += name + " > " + new_name;
655               START_LOG("system(bunzip2)", "Mesh");
656               if (std::system(system_string\&.c_str()))
657                 libmesh_file_error(system_string);
658               STOP_LOG("system(bunzip2)", "Mesh");
659 #else
660               libMesh::err << "ERROR: need bzip2/bunzip2 to open \&.bz2 file "
661                            << name << std::endl;
662               libmesh_error();
663 #endif
664             }
665           else if (name\&.size() - name\&.rfind("\&.xz") == 3)
666             {
667 #ifdef LIBMESH_HAVE_XZ
668               new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
669               new_name += pid_suffix\&.str();
670               std::string system_string = "xz -f -d -k -c ";
671               system_string += name + " > " + new_name;
672               START_LOG("system(xz -d)", "XdrIO");
673               if (std::system(system_string\&.c_str()))
674                 libmesh_file_error(system_string);
675               STOP_LOG("system(xz -d)", "XdrIO");
676 #else
677               libMesh::err << "ERROR: need xz to open \&.xz file "
678                            << name << std::endl;
679               libmesh_error();
680 #endif
681             }
682 
683           if (new_name\&.rfind("\&.mat") < new_name\&.size())
684             MatlabIO(*this)\&.read(new_name);
685 
686           else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
687             UCDIO(*this)\&.read (new_name);
688 
689           else if ((new_name\&.rfind("\&.off")  < new_name\&.size()) ||
690                    (new_name\&.rfind("\&.ogl")  < new_name\&.size()) ||
691                    (new_name\&.rfind("\&.oogl") < new_name\&.size()))
692             OFFIO(*this)\&.read (new_name);
693 
694           else if (new_name\&.rfind("\&.mgf") < new_name\&.size())
695             LegacyXdrIO(*this,true)\&.read_mgf (new_name);
696 
697           else if (new_name\&.rfind("\&.unv") < new_name\&.size())
698             {
699               if (mesh_data == NULL)
700                 {
701                   libMesh::err << "Error! You must pass a "
702                                << "valid MeshData pointer to "
703                                << "read UNV files!" << std::endl;
704                   libmesh_error();
705                 }
706               UNVIO(*this, *mesh_data)\&.read (new_name);
707             }
708 
709           else if ((new_name\&.rfind("\&.node")  < new_name\&.size()) ||
710                    (new_name\&.rfind("\&.ele")   < new_name\&.size()))
711             TetGenIO(*this,mesh_data)\&.read (new_name);
712 
713           else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
714                    new_name\&.rfind("\&.e") < new_name\&.size())
715             ExodusII_IO(*this)\&.read (new_name);
716 
717           else if (new_name\&.rfind("\&.msh") < new_name\&.size())
718             GmshIO(*this)\&.read (new_name);
719 
720           else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
721             GMVIO(*this)\&.read (new_name);
722 
723           else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
724             VTKIO(*this)\&.read(new_name);
725 
726           else if (new_name\&.rfind("\&.inp") < new_name\&.size())
727             AbaqusIO(*this)\&.read(new_name);
728 
729           else
730             {
731               libMesh::err << " ERROR: Unrecognized file extension: " << name
732                            << "\n   I understand the following:\n\n"
733                            << "     *\&.e    -- Sandia's ExodusII format\n"
734                            << "     *\&.exd  -- Sandia's ExodusII format\n"
735                            << "     *\&.gmv  -- LANL's General Mesh Viewer format\n"
736                            << "     *\&.mat  -- Matlab triangular ASCII file\n"
737                            << "     *\&.n    -- Sandia's Nemesis format\n"
738                            << "     *\&.nem  -- Sandia's Nemesis format\n"
739                            << "     *\&.off  -- OOGL OFF surface format\n"
740                            << "     *\&.ucd  -- AVS's ASCII UCD format\n"
741                            << "     *\&.unv  -- I-deas Universal format\n"
742                            << "     *\&.vtu  -- Paraview VTK format\n"
743                            << "     *\&.inp  -- Abaqus \&.inp format\n"
744                            << "     *\&.xda  -- libMesh ASCII format\n"
745                            << "     *\&.xdr  -- libMesh binary format\n"
746                            << "     *\&.gz   -- any above format gzipped\n"
747                            << "     *\&.bz2  -- any above format bzip2'ed\n"
748                            << "     *\&.xz   -- any above format xzipped\n"
749                            << "     *\&.cpa  -- libMesh Checkpoint ASCII format\n"
750                            << "     *\&.cpr  -- libMesh Checkpoint binary format\n"
751 
752                            << std::endl;
753               libmesh_error();
754             }
755 
756           // If we temporarily decompressed a file, remove the
757           // uncompressed version
758           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
759             std::remove(new_name\&.c_str());
760           if (name\&.size() - name\&.rfind("\&.xz") == 3)
761             std::remove(new_name\&.c_str());
762         }
763 
764 
765       STOP_LOG("read()", "Mesh");
766 
767       // Send the mesh & bcs (which are now only on processor 0) to the other
768       // processors
769       MeshCommunication()\&.broadcast (*this);
770     }
771 
772   if (skip_renumber_nodes_and_elements)
773     {
774       // Use MeshBase::allow_renumbering() yourself instead\&.
775       libmesh_deprecated();
776       this->allow_renumbering(false);
777     }
778 
779   // Done reading the mesh\&.  Now prepare it for use\&.
780   this->prepare_for_use();
781 }
.fi
.SS "unsigned int libMesh::MeshBase::recalculate_n_partitions ()\fC [inherited]\fP"
In a few (very rare) cases, the user may have manually tagged the elements with specific processor IDs by hand, without using a partitioner\&. In this case, the \fBMesh\fP will not know that the total number of partitions, _n_parts, has changed, unless you call this function\&. This is an O(N active elements) calculation\&. The return value is the number of partitions, and _n_parts is also set by this function\&. 
.PP
Definition at line 364 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_n_parts, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, std::max(), and libMesh::Parallel::Communicator::max()\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
365 {
366   const_element_iterator       el  = this->active_elements_begin();
367   const const_element_iterator end = this->active_elements_end();
368 
369   unsigned int max_proc_id=0;
370 
371   for (; el!=end; ++el)
372     max_proc_id = std::max(max_proc_id, static_cast<unsigned int>((*el)->processor_id()));
373 
374   // The number of partitions is one more than the max processor ID\&.
375   _n_parts = max_proc_id+1;
376 
377   this->comm()\&.max(_n_parts);
378 
379   return _n_parts;
380 }
.fi
.SS "virtual void libMesh::MeshBase::redistribute ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Redistribute elements between processors\&. This gets called automatically by the \fBPartitioner\fP, and is a no-op in the case of a \fBSerialMesh\fP or serialized \fBParallelMesh\fP 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 522 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::Partitioner::partition()\&.
.PP
.nf
522 {}
.fi
.SS "void libMesh::SerialMesh::renumber_elem (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [virtual]\fP"
Changes the id of element \fCold_id\fP, both by changing elem(old_id)->id() and by moving elem(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 412 of file serial_mesh\&.C\&.
.PP
References _elements, libMesh::libmesh_assert(), and libMesh::DofObject::set_id()\&.
.PP
.nf
414 {
415   // This doesn't get used in serial yet
416   Elem *el = _elements[old_id];
417   libmesh_assert (el);
418 
419   el->set_id(new_id);
420   libmesh_assert (!_elements[new_id]);
421   _elements[new_id] = el;
422   _elements[old_id] = NULL;
423 }
.fi
.SS "void libMesh::SerialMesh::renumber_node (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [virtual]\fP"
Changes the id of node \fCold_id\fP, both by changing node(old_id)->id() and by moving node(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 576 of file serial_mesh\&.C\&.
.PP
References _nodes, libMesh::libmesh_assert(), and libMesh::DofObject::set_id()\&.
.PP
.nf
578 {
579   // This doesn't get used in serial yet
580   Node *nd = _nodes[old_id];
581   libmesh_assert (nd);
582 
583   nd->set_id(new_id);
584   libmesh_assert (!_nodes[new_id]);
585   _nodes[new_id] = nd;
586   _nodes[old_id] = NULL;
587 }
.fi
.SS "void libMesh::SerialMesh::renumber_nodes_and_elements ()\fC [virtual]\fP"
Remove NULL elements from arrays 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 628 of file serial_mesh\&.C\&.
.PP
References _elements, _nodes, libMesh::MeshBase::_skip_renumber_nodes_and_elements, libMesh::MeshBase::boundary_info, end, libMesh::Elem::get_node(), libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::Elem::node(), libMesh::DofObject::set_id(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::swap()\&.
.PP
.nf
629 {
630 
631   START_LOG("renumber_nodes_and_elem()", "Mesh");
632 
633   // node and element id counters
634   dof_id_type next_free_elem = 0;
635   dof_id_type next_free_node = 0;
636 
637   // Will hold the set of nodes that are currently connected to elements
638   LIBMESH_BEST_UNORDERED_SET<Node*> connected_nodes;
639 
640   // Loop over the elements\&.  Note that there may
641   // be NULLs in the _elements vector from the coarsening
642   // process\&.  Pack the elements in to a contiguous array
643   // and then trim any excess\&.
644   {
645     std::vector<Elem*>::iterator in        = _elements\&.begin();
646     std::vector<Elem*>::iterator out_iter  = _elements\&.begin();
647     const std::vector<Elem*>::iterator end = _elements\&.end();
648 
649     for (; in != end; ++in)
650       if (*in != NULL)
651         {
652           Elem* el = *in;
653 
654           *out_iter = *in;
655           ++out_iter;
656 
657           // Increment the element counter
658           el->set_id (next_free_elem++);
659 
660           if(_skip_renumber_nodes_and_elements)
661             {
662               // Add this elements nodes to the connected list
663               for (unsigned int n=0; n<el->n_nodes(); n++)
664                 connected_nodes\&.insert(el->get_node(n));
665             }
666           else  // We DO want node renumbering
667             {
668               // Loop over this element's nodes\&.  Number them,
669               // if they have not been numbered already\&.  Also,
670               // position them in the _nodes vector so that they
671               // are packed contiguously from the beginning\&.
672               for (unsigned int n=0; n<el->n_nodes(); n++)
673                 if (el->node(n) == next_free_node)     // don't need to process
674                   next_free_node++;                      // [(src == dst) below]
675 
676                 else if (el->node(n) > next_free_node) // need to process
677                   {
678                     // The source and destination indices
679                     // for this node
680                     const dof_id_type src_idx = el->node(n);
681                     const dof_id_type dst_idx = next_free_node++;
682 
683                     // ensure we want to swap a valid nodes
684                     libmesh_assert(_nodes[src_idx]);
685 
686                     // Swap the source and destination nodes
687                     std::swap(_nodes[src_idx],
688                               _nodes[dst_idx] );
689 
690                     // Set proper indices where that makes sense
691                     if (_nodes[src_idx] != NULL)
692                       _nodes[src_idx]->set_id (src_idx);
693                     _nodes[dst_idx]->set_id (dst_idx);
694                   }
695             }
696         }
697 
698     // Erase any additional storage\&. These elements have been
699     // copied into NULL voids by the procedure above, and are
700     // thus repeated and unnecessary\&.
701     _elements\&.erase (out_iter, end);
702   }
703 
704 
705   if(_skip_renumber_nodes_and_elements)
706     {
707       // Loop over the nodes\&.  Note that there may
708       // be NULLs in the _nodes vector from the coarsening
709       // process\&.  Pack the nodes in to a contiguous array
710       // and then trim any excess\&.
711 
712       std::vector<Node*>::iterator in        = _nodes\&.begin();
713       std::vector<Node*>::iterator out_iter  = _nodes\&.begin();
714       const std::vector<Node*>::iterator end = _nodes\&.end();
715 
716       for (; in != end; ++in)
717         if (*in != NULL)
718           {
719             // This is a reference so that if we change the pointer it will change in the vector
720             Node* & nd = *in;
721 
722             // If this node is still connected to an elem, put it in the list
723             if(connected_nodes\&.find(nd) != connected_nodes\&.end())
724               {
725                 *out_iter = nd;
726                 ++out_iter;
727 
728                 // Increment the node counter
729                 nd->set_id (next_free_node++);
730               }
731             else // This node is orphaned, delete it!
732               {
733                 this->boundary_info->remove (nd);
734 
735                 // delete the node
736                 delete nd;
737                 nd = NULL;
738               }
739           }
740 
741       // Erase any additional storage\&.  Whatever was
742       _nodes\&.erase (out_iter, end);
743     }
744   else // We really DO want node renumbering
745     {
746       // Any nodes in the vector >= _nodes[next_free_node]
747       // are not connected to any elements and may be deleted
748       // if desired\&.
749 
750       // (This code block will erase the unused nodes)
751       // Now, delete the unused nodes
752       {
753         std::vector<Node*>::iterator nd        = _nodes\&.begin();
754         const std::vector<Node*>::iterator end = _nodes\&.end();
755 
756         std::advance (nd, next_free_node);
757 
758         for (std::vector<Node*>::iterator it=nd;
759              it != end; ++it)
760           {
761             // Mesh modification code might have already deleted some
762             // nodes
763             if (*it == NULL)
764               continue;
765 
766             // remove any boundary information associated with
767             // this node
768             this->boundary_info->remove (*it);
769 
770             // delete the node
771             delete *it;
772             *it = NULL;
773           }
774 
775         _nodes\&.erase (nd, end);
776       }
777     }
778 
779   libmesh_assert_equal_to (next_free_elem, _elements\&.size());
780   libmesh_assert_equal_to (next_free_node, _nodes\&.size());
781 
782   STOP_LOG("renumber_nodes_and_elem()", "Mesh");
783 }
.fi
.SS "virtual void libMesh::SerialMesh::reserve_elem (const \fBdof_id_type\fPne)\fC [inline]\fP, \fC [virtual]\fP"
Reserves space for a known number of elements\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of elements you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 127 of file serial_mesh\&.h\&.
.PP
References _elements\&.
.PP
.nf
127 { _elements\&.reserve (ne); }
.fi
.SS "virtual void libMesh::SerialMesh::reserve_nodes (const \fBdof_id_type\fPnn)\fC [inline]\fP, \fC [virtual]\fP"
Reserves space for a known number of nodes\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of nodes you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 113 of file serial_mesh\&.h\&.
.PP
References _nodes\&.
.PP
.nf
114   { _nodes\&.reserve (nn); }
.fi
.SS "void libMesh::MeshBase::set_mesh_dimension (unsigned intd)\fC [inline]\fP, \fC [inherited]\fP"
Resets the logical dimension of the mesh\&. 
.PP
Definition at line 161 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::TriangleWrapper::copy_tri_to_mesh(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), and libMesh::TriangleInterface::triangulate()\&.
.PP
.nf
162   { _dim = d; }
.fi
.SS "unsigned int& libMesh::MeshBase::set_n_partitions ()\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Returns a writeable reference to the number of partitions\&. 
.PP
Definition at line 859 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::Partitioner::partition(), libMesh::Partitioner::repartition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
860   { return _n_parts; }
.fi
.SS "void libMesh::MeshBase::set_next_unique_id (\fBunique_id_type\fPid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the next unique id to be used\&. 
.PP
Definition at line 221 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
221 { _next_unique_id = id; }
.fi
.SS "std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::set_subdomain_name_map ()\fC [inline]\fP, \fC [inherited]\fP"
Return a writeable reference to the whole subdomain name map 
.PP
Definition at line 841 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::read_serialized_subdomain_names(), and libMesh::CheckpointIO::read_subdomain_names()\&.
.PP
.nf
842   { return _block_id_to_name; }
.fi
.SS "void libMesh::MeshBase::skip_partitioning (boolskip)\fC [inline]\fP, \fC [inherited]\fP"
If true is passed in then this mesh will no longer be (re)partitioned\&. It would probably be a bad idea to call this on a Serial \fBMesh\fP \fIbefore\fP the first partitioning has happened\&.\&.\&. because no elements would get assigned to your processor pool\&.
.PP
Note that turning on \fBskip_partitioning()\fP can have adverse effects on your performance when using AMR\&.\&.\&. ie you could get large load imbalances\&.
.PP
However you might still want to use this if the communication and computation of the rebalance and repartition is too high for your application\&. 
.PP
Definition at line 551 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements()\&.
.PP
.nf
551 { _skip_partitioning = skip; }
.fi
.SS "bool libMesh::MeshBase::skip_partitioning () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 552 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
552 { return _skip_partitioning; }
.fi
.SS "unsigned int libMesh::MeshBase::spatial_dimension () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the spatial dimension of the mesh\&. Note that this is defined at compile time in the header \fC\fBlibmesh_common\&.h\fP\fP\&. 
.PP
Definition at line 168 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::MeshBase::get_info(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::UNVIO::node_out(), libMesh::MeshTools::Modification::scale(), libMesh::MeshTools::subdomain_bounding_box(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.PP
.nf
169   { return static_cast<unsigned int>(LIBMESH_DIM); }
.fi
.SS "void libMesh::SerialMesh::stitch_meshes (\fBSerialMesh\fP &other_mesh, \fBboundary_id_type\fPthis_mesh_boundary, \fBboundary_id_type\fPother_mesh_boundary, \fBReal\fPtol = \fC\fBTOLERANCE\fP\fP, boolclear_stitched_boundary_ids = \fCfalse\fP, boolverbose = \fCtrue\fP, booluse_binary_search = \fCtrue\fP, boolenforce_all_nodes_match_on_boundaries = \fCfalse\fP)"
Stitch \fCother_mesh\fP to this mesh so that this mesh is the union of the two meshes\&. \fCthis_mesh_boundary\fP and \fCother_mesh_boundary\fP are used to specify a dim-1 dimensional surface on which we seek to merge any 'overlapping' nodes, where we use the parameter \fCtol\fP as a relative tolerance (relative to the smallest edge length on the surfaces being stitched) to determine whether or not nodes are overlapping\&. If \fCclear_stitched_boundary_ids==true\fP, this function clears boundary_info IDs in this mesh associated \fCthis_mesh_boundary\fP and \fCother_mesh_boundary\fP\&. If \fCuse_binary_search\fP is true, we use an optimized 'sort then binary search' algorithm for finding matching nodes\&. Otherwise we use a N^2 algorithm (which can be more reliable at dealing with slightly misaligned meshes)\&. If \fCenforce_all_nodes_match_on_boundaries\fP is true, we throw an error if the number of nodes on the specified boundaries don't match the number of nodes that were merged\&. This is a helpful error check in some cases\&. If \fCskip_find_neighbors\fP is true, a faster stitching method is used, where the lists of neighbors for each elements are copied as well and patched, without calling the time-consuming \fBfind_neighbors()\fP function\&. 
.PP
Definition at line 801 of file serial_mesh\&.C\&.
.PP
References libMesh::START_LOG(), stitching_helper(), and libMesh::STOP_LOG()\&.
.PP
.nf
809 {
810   START_LOG("stitch_meshes()", "SerialMesh");
811   stitching_helper(&other_mesh,
812                    this_mesh_boundary_id,
813                    other_mesh_boundary_id,
814                    tol,
815                    clear_stitched_boundary_ids,
816                    verbose,
817                    use_binary_search,
818                    enforce_all_nodes_match_on_boundaries,
819                    true);
820   STOP_LOG("stitch_meshes()", "SerialMesh");
821 }
.fi
.SS "void libMesh::SerialMesh::stitch_surfaces (\fBboundary_id_type\fPboundary_id_1, \fBboundary_id_type\fPboundary_id_2, \fBReal\fPtol = \fC\fBTOLERANCE\fP\fP, boolclear_stitched_boundary_ids = \fCfalse\fP, boolverbose = \fCtrue\fP, booluse_binary_search = \fCtrue\fP, boolenforce_all_nodes_match_on_boundaries = \fCfalse\fP)"
Similar to stitch_meshes, except that we stitch two adjacent surfaces within this mesh\&. 
.PP
Definition at line 823 of file serial_mesh\&.C\&.
.PP
References stitching_helper()\&.
.PP
.nf
830 {
831   stitching_helper(NULL,
832                    boundary_id_1,
833                    boundary_id_2,
834                    tol,
835                    clear_stitched_boundary_ids,
836                    verbose,
837                    use_binary_search,
838                    enforce_all_nodes_match_on_boundaries,
839                    true);
840 }
.fi
.SS "void libMesh::SerialMesh::stitching_helper (\fBSerialMesh\fP *other_mesh, \fBboundary_id_type\fPboundary_id_1, \fBboundary_id_type\fPboundary_id_2, \fBReal\fPtol, boolclear_stitched_boundary_ids, boolverbose, booluse_binary_search, boolenforce_all_nodes_match_on_boundaries, boolskip_find_neighbors)\fC [private]\fP"
Helper function for stitch_meshes and stitch_surfaces that does the mesh stitching\&. 
.PP
Definition at line 842 of file serial_mesh\&.C\&.
.PP
References libMesh::TypeVector< T >::absolute_fuzzy_equals(), libMesh::Utility::binary_find(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), delete_node(), elem(), elements_begin(), elements_end(), end, libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::BoundaryInfo::invalid_id, libMesh::Elem::key(), libMesh::Elem::local_node(), std::max(), std::min(), libMesh::Elem::n_edges(), n_elem(), libMesh::Elem::n_neighbors(), n_nodes(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::node(), node(), node_ptr(), nodes_begin(), nodes_end(), libMesh::out, point(), libMesh::MeshBase::prepare_for_use(), libMesh::Real, libMesh::DofObject::set_id(), libMesh::Elem::set_neighbor(), libMesh::Elem::set_node(), side, and libMesh::TOLERANCE\&.
.PP
Referenced by stitch_meshes(), and stitch_surfaces()\&.
.PP
.nf
851 {
852   std::map<dof_id_type, dof_id_type> node_to_node_map, other_to_this_node_map; // The second is the inverse map of the first
853   std::map<dof_id_type, std::vector<dof_id_type> > node_to_elems_map;
854 
855   typedef dof_id_type                     key_type;
856   typedef std::pair<Elem*, unsigned char> val_type;
857   // Mapping between all side keys in this mesh and elements+side numbers relevant to the boundary in this mesh as well\&.
858   std::map<key_type, val_type>            side_to_elem_map;
859 
860   // If there is only one mesh (i\&.e\&. other_mesh==NULL), then loop over this mesh twice
861   if(!other_mesh)
862     {
863       other_mesh = this;
864     }
865 
866   if( (this_mesh_boundary_id  != BoundaryInfo::invalid_id) &&
867       (other_mesh_boundary_id != BoundaryInfo::invalid_id) )
868     {
869       // While finding nodes on the boundary, also find the minimum edge length
870       // of all faces on both boundaries\&.  This will later be used in relative
871       // distance checks when stitching nodes\&.
872       Real h_min = std::numeric_limits<Real>::max();
873       bool h_min_updated = false;
874 
875       // Loop below fills in these sets for the two meshes\&.
876       std::set<dof_id_type> this_boundary_node_ids, other_boundary_node_ids;
877       {
878         // Make temporary fixed-size arrays for loop
879         boundary_id_type id_array[2]        = {this_mesh_boundary_id, other_mesh_boundary_id};
880         std::set<dof_id_type>* set_array[2] = {&this_boundary_node_ids, &other_boundary_node_ids};
881         SerialMesh* mesh_array[2]           = {this, other_mesh};
882 
883         for (unsigned i=0; i<2; ++i)
884           {
885             MeshBase::element_iterator elem_it  = mesh_array[i]->elements_begin();
886             MeshBase::element_iterator elem_end = mesh_array[i]->elements_end();
887             for ( ; elem_it != elem_end; ++elem_it)
888               {
889                 Elem *el = *elem_it;
890 
891                 // Now check whether elem has a face on the specified boundary
892                 for (unsigned int side_id=0; side_id<el->n_sides(); ++side_id)
893                   if (el->neighbor(side_id) == NULL)
894                     {
895                       // Get *all* boundary IDs, not just the first one!
896                       std::vector<boundary_id_type> bc_ids = mesh_array[i]->boundary_info->boundary_ids (el, side_id);
897 
898                       if (std::count(bc_ids\&.begin(), bc_ids\&.end(), id_array[i]))
899                         {
900                           AutoPtr<Elem> side (el->build_side(side_id));
901                           for (unsigned int node_id=0; node_id<side->n_nodes(); ++node_id)
902                             set_array[i]->insert( side->node(node_id) );
903 
904                           h_min = std::min(h_min, side->hmin());
905                           h_min_updated = true;
906 
907                           // This side is on the boundary, add its information to side_to_elem
908                           if(skip_find_neighbors && (i==0))
909                             {
910                               key_type key = el->key(side_id);
911                               val_type val;
912                               val\&.first = el;
913                               val\&.second = side_id;
914                               side_to_elem_map[key] = val;
915                             }
916                         }
917                     }
918               }
919           }
920       }
921 
922       if (verbose)
923         {
924           libMesh::out << "In SerialMesh::stitch_meshes:\n"
925                        << "This mesh has "  << this_boundary_node_ids\&.size()
926                        << " nodes on boundary " << this_mesh_boundary_id  << "\&.\n"
927                        << "Other mesh has " << other_boundary_node_ids\&.size()
928                        << " nodes on boundary " << other_mesh_boundary_id << "\&.\n";
929 
930           if(h_min_updated)
931             {
932               libMesh::out << "Minimum edge length on both surfaces is " << h_min << "\&.\n";
933             }
934           else
935             {
936               libMesh::out << "No elements on specified surfaces\&." << std::endl;
937             }
938         }
939 
940 
941       if(use_binary_search)
942         {
943           // Store points from both stitched faces in sorted vectors for faster
944           // searching later\&.
945           typedef std::vector< std::pair<Point, dof_id_type> > PointVector;
946           PointVector
947             this_sorted_bndry_nodes(this_boundary_node_ids\&.size()),
948             other_sorted_bndry_nodes(other_boundary_node_ids\&.size());
949 
950           // Comparison object that will be used later\&. So far, I've had reasonable success
951           // with TOLERANCE\&.\&.\&.
952           FuzzyPointCompare mein_comp(TOLERANCE);
953 
954           // Create and sort the vectors we will use to do the geometric searching
955           {
956             std::set<dof_id_type>* set_array[2] = {&this_boundary_node_ids, &other_boundary_node_ids};
957             SerialMesh* mesh_array[2]           = {this, other_mesh};
958             PointVector* vec_array[2]           = {&this_sorted_bndry_nodes, &other_sorted_bndry_nodes};
959 
960             for (unsigned i=0; i<2; ++i)
961               {
962                 std::set<dof_id_type>::iterator
963                   set_it     = set_array[i]->begin(),
964                   set_it_end = set_array[i]->end();
965 
966                 // Fill up the vector with the contents of the set\&.\&.\&.
967                 for (unsigned ctr=0; set_it != set_it_end; ++set_it, ++ctr)
968                   {
969                     (*vec_array[i])[ctr] = std::make_pair( mesh_array[i]->point(*set_it), // The geometric point
970                                                            *set_it );                     // Its ID
971                   }
972 
973                 // Sort the vectors based on the FuzzyPointCompare struct op()
974                 std::sort(vec_array[i]->begin(), vec_array[i]->end(), mein_comp);
975               }
976           }
977 
978           // Build up the node_to_node_map and node_to_elems_map using the sorted vectors of Points\&.
979           for (unsigned i=0; i<this_sorted_bndry_nodes\&.size(); ++i)
980             {
981               // Current point we're working on
982               Point this_point = this_sorted_bndry_nodes[i]\&.first;
983 
984               // FuzzyPointCompare does a fuzzy equality comparison internally to handle
985               // slight differences between the list of nodes on each mesh\&.
986               PointVector::iterator other_iter = Utility::binary_find(other_sorted_bndry_nodes\&.begin(),
987                                                                       other_sorted_bndry_nodes\&.end(),
988                                                                       this_point,
989                                                                       mein_comp);
990 
991               // Not every node on this_sorted_bndry_nodes will necessarily be stitched, so
992               // if its pair is not found on other_mesh, just continue\&.
993               if (other_iter != other_sorted_bndry_nodes\&.end())
994                 {
995                   // Check that the points do indeed match - should not be necessary unless something
996                   // is wrong with binary_find\&.  To be on the safe side, we'll check\&.
997                   {
998                     // Grab the other point from the iterator
999                     Point other_point = other_iter->first;
1000 
1001                     if (!this_point\&.absolute_fuzzy_equals(other_point, tol*h_min))
1002                       {
1003                         libMesh::out << "Error: mismatched points: " << this_point << " and " << other_point << std::endl;
1004                         libmesh_error();
1005                       }
1006                   }
1007 
1008 
1009                   // Associate these two nodes in both the node_to_node_map and the other_to_this_node_map
1010                   dof_id_type
1011                     this_node_id = this_sorted_bndry_nodes[i]\&.second,
1012                     other_node_id = other_iter->second;
1013                   node_to_node_map[this_node_id] = other_node_id;
1014                   other_to_this_node_map[other_node_id] = this_node_id;
1015                 }
1016 
1017             }
1018         }
1019       else
1020         {
1021           // Otherwise, use a simple N^2 search to find the closest matching points\&. This can be helpful
1022           // in the case that we have tolerance issues which cause mismatch between the two surfaces
1023           // that are being stitched\&.
1024 
1025           std::set<dof_id_type>::iterator set_it     = this_boundary_node_ids\&.begin();
1026           std::set<dof_id_type>::iterator set_it_end = this_boundary_node_ids\&.end();
1027           for( ; set_it != set_it_end; ++set_it)
1028             {
1029               dof_id_type this_node_id = *set_it;
1030               Node& this_node = this->node(this_node_id);
1031 
1032               bool found_matching_nodes = false;
1033 
1034               std::set<dof_id_type>::iterator other_set_it     = other_boundary_node_ids\&.begin();
1035               std::set<dof_id_type>::iterator other_set_it_end = other_boundary_node_ids\&.end();
1036               for( ; other_set_it != other_set_it_end; ++other_set_it)
1037                 {
1038                   dof_id_type other_node_id = *other_set_it;
1039                   Node& other_node = other_mesh->node(other_node_id);
1040 
1041                   Real node_distance = (this_node - other_node)\&.size();
1042 
1043                   if(node_distance < tol*h_min)
1044                     {
1045                       // Make sure we didn't already find a matching node!
1046                       if(found_matching_nodes)
1047                         {
1048                           libMesh::out << "Error: Found multiple matching nodes in stitch_meshes" << std::endl;
1049                           libmesh_error();
1050                         }
1051 
1052                       node_to_node_map[this_node_id] = other_node_id;
1053                       other_to_this_node_map[other_node_id] = this_node_id;
1054 
1055                       found_matching_nodes = true;
1056                     }
1057                 }
1058             }
1059         }
1060 
1061       // Build up the node_to_elems_map, using only one loop over other_mesh
1062       {
1063         MeshBase::element_iterator other_elem_it  = other_mesh->elements_begin();
1064         MeshBase::element_iterator other_elem_end = other_mesh->elements_end();
1065         for (; other_elem_it != other_elem_end; ++other_elem_it)
1066           {
1067             Elem *el = *other_elem_it;
1068 
1069             // For each node on the element, find the corresponding node
1070             // on "this" Mesh, 'this_node_id', if it exists, and push
1071             // the current element ID back onto node_to_elems_map[this_node_id]\&.
1072             // For that we will use the reverse mapping we created at
1073             // the same time as the forward mapping\&.
1074             for (unsigned n=0; n<el->n_nodes(); ++n)
1075               {
1076                 dof_id_type other_node_id = el->node(n);
1077                 std::map<dof_id_type, dof_id_type>::iterator it =
1078                   other_to_this_node_map\&.find(other_node_id);
1079 
1080                 if (it != other_to_this_node_map\&.end())
1081                   {
1082                     dof_id_type this_node_id = it->second;
1083                     node_to_elems_map[this_node_id]\&.push_back( el->id() );
1084                   }
1085               }
1086           }
1087       }
1088 
1089       if(verbose)
1090         {
1091           libMesh::out << "In SerialMesh::stitch_meshes:\n"
1092                        << "Found " << node_to_node_map\&.size()
1093                        << " matching nodes\&.\n"
1094                        << std::endl;
1095         }
1096 
1097       if(enforce_all_nodes_match_on_boundaries)
1098         {
1099           unsigned int n_matching_nodes = node_to_node_map\&.size();
1100           unsigned int this_mesh_n_nodes = this_boundary_node_ids\&.size();
1101           unsigned int other_mesh_n_nodes = other_boundary_node_ids\&.size();
1102           if( (n_matching_nodes != this_mesh_n_nodes) ||
1103               (n_matching_nodes != other_mesh_n_nodes) )
1104             {
1105               libMesh::out << "Error: We expected the number of nodes to match\&."
1106                            << std::endl;
1107               libmesh_error();
1108             }
1109         }
1110     }
1111   else
1112     {
1113       if(verbose)
1114         {
1115           libMesh::out << "Skip node merging in SerialMesh::stitch_meshes:" << std::endl;
1116         }
1117     }
1118 
1119 
1120 
1121   dof_id_type node_delta = this->n_nodes();
1122   dof_id_type elem_delta = this->n_elem();
1123 
1124   // If other_mesh!=NULL, then we have to do a bunch of work
1125   // in order to copy it to this mesh
1126   if(this!=other_mesh)
1127     {
1128       // need to increment node and element IDs of other_mesh before copying to this mesh
1129       MeshBase::node_iterator node_it  = other_mesh->nodes_begin();
1130       MeshBase::node_iterator node_end = other_mesh->nodes_end();
1131       for (; node_it != node_end; ++node_it)
1132         {
1133           Node *nd = *node_it;
1134           dof_id_type new_id = nd->id() + node_delta;
1135           nd->set_id(new_id);
1136         }
1137 
1138       MeshBase::element_iterator elem_it  = other_mesh->elements_begin();
1139       MeshBase::element_iterator elem_end = other_mesh->elements_end();
1140       for (; elem_it != elem_end; ++elem_it)
1141         {
1142           Elem *el = *elem_it;
1143           dof_id_type new_id = el->id() + elem_delta;
1144           el->set_id(new_id);
1145         }
1146 
1147       // Also, increment the node_to_node_map and node_to_elems_map
1148       std::map<dof_id_type, dof_id_type>::iterator node_map_it     = node_to_node_map\&.begin();
1149       std::map<dof_id_type, dof_id_type>::iterator node_map_it_end = node_to_node_map\&.end();
1150       for( ; node_map_it != node_map_it_end; ++node_map_it)
1151         {
1152           node_map_it->second += node_delta;
1153         }
1154       std::map<dof_id_type, std::vector<dof_id_type> >::iterator elem_map_it     = node_to_elems_map\&.begin();
1155       std::map<dof_id_type, std::vector<dof_id_type> >::iterator elem_map_it_end = node_to_elems_map\&.end();
1156       for( ; elem_map_it != elem_map_it_end; ++elem_map_it)
1157         {
1158           dof_id_type n_elems = elem_map_it->second\&.size();
1159           for(dof_id_type i=0; i<n_elems; i++)
1160             {
1161               (elem_map_it->second)[i] += elem_delta;
1162             }
1163         }
1164 
1165       // Copy mesh data\&. If we skip the call to find_neighbors(), the lists
1166       // of neighbors will be copied verbatim from the other mesh
1167       this->copy_nodes_and_elements(*other_mesh, skip_find_neighbors);
1168 
1169       // Decrement node IDs of mesh to return to original state
1170       node_it  = other_mesh->nodes_begin();
1171       node_end = other_mesh->nodes_end();
1172       for (; node_it != node_end; ++node_it)
1173         {
1174           Node *nd = *node_it;
1175           dof_id_type new_id = nd->id() - node_delta;
1176           nd->set_id(new_id);
1177         }
1178 
1179       elem_it  = other_mesh->elements_begin();
1180       elem_end = other_mesh->elements_end();
1181       for (; elem_it != elem_end; ++elem_it)
1182         {
1183           Elem *other_elem = *elem_it;
1184 
1185           // Find the corresponding element on this mesh
1186           Elem* this_elem = this->elem(other_elem->id());
1187 
1188           // Decrement elem IDs of other_mesh to return it to original state
1189           dof_id_type new_id = other_elem->id() - elem_delta;
1190           other_elem->set_id(new_id);
1191 
1192           unsigned int n_nodes = other_elem->n_nodes();
1193           for (unsigned int n=0; n != n_nodes; ++n)
1194             {
1195               const std::vector<boundary_id_type>& ids =
1196                 other_mesh->boundary_info->boundary_ids(other_elem->get_node(n));
1197               if (!ids\&.empty())
1198                 {
1199                   this->boundary_info->add_node(this_elem->get_node(n), ids);
1200                 }
1201             }
1202 
1203           // Copy edge boundary info
1204           unsigned int n_edges = other_elem->n_edges();
1205           for (unsigned int edge=0; edge != n_edges; ++edge)
1206             {
1207               const std::vector<boundary_id_type>& ids =
1208                 other_mesh->boundary_info->edge_boundary_ids(other_elem, edge);
1209               if (!ids\&.empty())
1210                 {
1211                   this->boundary_info->add_edge( this_elem, edge, ids);
1212                 }
1213             }
1214 
1215           unsigned int n_sides = other_elem->n_sides();
1216           for (unsigned int s=0; s != n_sides; ++s)
1217             {
1218               const std::vector<boundary_id_type>& ids =
1219                 other_mesh->boundary_info->boundary_ids(other_elem, s);
1220               if (!ids\&.empty())
1221                 {
1222                   this->boundary_info->add_side( this_elem, s, ids);
1223                 }
1224             }
1225 
1226         }
1227 
1228     } // end if(other_mesh)
1229 
1230   // Finally, we need to "merge" the overlapping nodes
1231   // We do this by iterating over node_to_elems_map and updating
1232   // the elements so that they "point" to the nodes that came
1233   // from this mesh, rather than from other_mesh\&.
1234   // Then we iterate over node_to_node_map and delete the
1235   // duplicate nodes that came from other_mesh\&.
1236   std::map<dof_id_type, std::vector<dof_id_type> >::iterator elem_map_it     = node_to_elems_map\&.begin();
1237   std::map<dof_id_type, std::vector<dof_id_type> >::iterator elem_map_it_end = node_to_elems_map\&.end();
1238   for( ; elem_map_it != elem_map_it_end; ++elem_map_it)
1239     {
1240       dof_id_type target_node_id = elem_map_it->first;
1241       dof_id_type other_node_id = node_to_node_map[target_node_id];
1242       Node& target_node = this->node(target_node_id);
1243 
1244       dof_id_type n_elems = elem_map_it->second\&.size();
1245       for(unsigned int i=0; i<n_elems; i++)
1246         {
1247           dof_id_type elem_id = elem_map_it->second[i];
1248           Elem* el = this->elem(elem_id);
1249 
1250           // find the local node index that we want to update
1251           unsigned int local_node_index = el->local_node(other_node_id);
1252 
1253           el->set_node(local_node_index) = &target_node;
1254         }
1255     }
1256 
1257   std::map<dof_id_type, dof_id_type>::iterator node_map_it     = node_to_node_map\&.begin();
1258   std::map<dof_id_type, dof_id_type>::iterator node_map_it_end = node_to_node_map\&.end();
1259   for( ; node_map_it != node_map_it_end; ++node_map_it)
1260     {
1261       dof_id_type node_id = node_map_it->second;
1262       this->delete_node( this->node_ptr(node_id) );
1263     }
1264 
1265   // If find_neighbors() wasn't called in prepare_for_use(), we need to
1266   // manually loop once more over all elements adjacent to the stitched boundary
1267   // and fix their lists of neighbors\&.
1268   // This is done according to the following steps:
1269   //   1\&. Loop over all copied elements adjacent to the boundary using node_to_elems_map (trying to avoid duplicates)
1270   //   2\&. Look at all their sides with a NULL neighbor and update them using side_to_elem_map if necessary
1271   //   3\&. Update the corresponding side in side_to_elem_map as well
1272   if(skip_find_neighbors)
1273     {
1274       elem_map_it     = node_to_elems_map\&.begin();
1275       elem_map_it_end = node_to_elems_map\&.end();
1276       std::set<dof_id_type> fixed_elems;
1277       for( ; elem_map_it != elem_map_it_end; ++elem_map_it)
1278         {
1279           dof_id_type n_elems = elem_map_it->second\&.size();
1280           for(dof_id_type i=0; i<n_elems; i++)
1281             {
1282               dof_id_type elem_id = elem_map_it->second[i];
1283               if(fixed_elems\&.find(elem_id) == fixed_elems\&.end())
1284                 {
1285                   Elem* el = this->elem(elem_id);
1286                   fixed_elems\&.insert(elem_id);
1287                   for(dof_id_type s(0); s < el->n_neighbors(); ++s)
1288                     {
1289                       if(el->neighbor(s) == NULL)
1290                         {
1291                           key_type key = el->key(s);
1292                           std::map<key_type, val_type>::const_iterator key_val_it;
1293                           key_val_it = side_to_elem_map\&.find(key);
1294 
1295                           if(key_val_it != side_to_elem_map\&.end())
1296                             {
1297                               Elem* neighbor = key_val_it->second\&.first;
1298                               dof_id_type neighbor_side = key_val_it->second\&.second;
1299                               el->set_neighbor(s, key_val_it->second\&.first);
1300                               neighbor->set_neighbor(neighbor_side, el);
1301                             }
1302                         }
1303                     }
1304                 }
1305             }
1306         }
1307     }
1308 
1309   this->prepare_for_use( /*skip_renumber_nodes_and_elements= */ false, skip_find_neighbors);
1310 
1311   // After the stitching, we may want to clear boundary IDs from element
1312   // faces that are now internal to the mesh
1313   if(clear_stitched_boundary_ids)
1314     {
1315       MeshBase::element_iterator elem_it  = this->elements_begin();
1316       MeshBase::element_iterator elem_end = this->elements_end();
1317       for (; elem_it != elem_end; ++elem_it)
1318         {
1319           Elem *el = *elem_it;
1320 
1321           for (unsigned int side_id=0; side_id<el->n_sides(); side_id++)
1322             {
1323               if (el->neighbor(side_id) != NULL)
1324                 {
1325                   // Completely remove the side from the boundary_info object if it has either
1326                   // this_mesh_boundary_id or other_mesh_boundary_id\&.
1327                   std::vector<boundary_id_type> bc_ids = this->boundary_info->boundary_ids (el, side_id);
1328 
1329                   if (std::count(bc_ids\&.begin(), bc_ids\&.end(), this_mesh_boundary_id) ||
1330                       std::count(bc_ids\&.begin(), bc_ids\&.end(), other_mesh_boundary_id))
1331                     this->boundary_info->remove_side(el, side_id);
1332                 }
1333             }
1334         }
1335     }
1336 
1337 }
.fi
.SS "\fBAutoPtr\fP< \fBPointLocatorBase\fP > libMesh::MeshBase::sub_point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a subordinate \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should not be used in threaded or non-parallel_only code unless the master has already been constructed\&. 
.PP
Definition at line 400 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
Referenced by libMesh::DofMap::create_dof_constraints(), libMesh::MeshFunction::init(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), and libMesh::MeshRefinement::test_level_one()\&.
.PP
.nf
401 {
402   if (_point_locator\&.get() == NULL)
403     {
404       // PointLocator construction may not be safe within threads
405       libmesh_assert(!Threads::in_threads);
406 
407       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
408     }
409 
410   return PointLocatorBase::build(TREE, *this, _point_locator\&.get());
411 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::subactive_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 87 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
88 {
89   Predicates::SubActive<elem_iterator_imp> p;
90   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
91 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::subactive_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 310 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
311 {
312   Predicates::SubActive<const_elem_iterator_imp> p;
313   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
314 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::subactive_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 533 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
534 {
535   Predicates::SubActive<elem_iterator_imp> p;
536   return element_iterator(_elements\&.end(), _elements\&.end(), p);
537 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::subactive_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 760 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
761 {
762   Predicates::SubActive<const_elem_iterator_imp> p;
763   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
764 }
.fi
.SS "void libMesh::MeshBase::subdomain_ids (std::set< \fBsubdomain_id_type\fP > &ids) const\fC [inherited]\fP"
Constructs a list of all subdomain identifiers in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 207 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, and libMesh::Parallel::Communicator::set_union()\&.
.PP
Referenced by libMesh::MeshBase::n_subdomains(), and libMesh::TecplotIO::TecplotIO()\&.
.PP
.nf
208 {
209   // This requires an inspection on every processor
210   parallel_object_only();
211 
212   ids\&.clear();
213 
214   const_element_iterator       el  = this->active_elements_begin();
215   const const_element_iterator end = this->active_elements_end();
216 
217   for (; el!=end; ++el)
218     ids\&.insert((*el)->subdomain_id());
219 
220   // Some subdomains may only live on other processors
221   this->comm()\&.set_union(ids);
222 }
.fi
.SS "std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid)\fC [inherited]\fP"
Returns a writable reference for getting/setting an optional name for a subdomain\&. 
.PP
Definition at line 422 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by DMLibMeshSetSystem(), libMesh::ExodusII_IO::read(), libMesh::TecplotIO::write_binary(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.PP
.nf
423 {
424   return _block_id_to_name[id];
425 }
.fi
.SS "const std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid) const\fC [inherited]\fP"

.PP
Definition at line 427 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
.nf
428 {
429   // An empty string to return when no matching subdomain name is found
430   static const std::string empty;
431 
432   std::map<subdomain_id_type, std::string>::const_iterator iter = _block_id_to_name\&.find(id);
433   if (iter == _block_id_to_name\&.end())
434     return empty;
435   else
436     return iter->second;
437 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::type_elements_begin (const \fBElemType\fPtype)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 197 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
198 {
199   Predicates::Type<elem_iterator_imp> p(type);
200   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
201 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::type_elements_begin (const \fBElemType\fPtype) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 420 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
421 {
422   Predicates::Type<const_elem_iterator_imp> p(type);
423   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
424 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::type_elements_end (const \fBElemType\fPtype)\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 643 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
644 {
645   Predicates::Type<elem_iterator_imp> p(type);
646   return element_iterator(_elements\&.end(), _elements\&.end(), p);
647 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::type_elements_end (const \fBElemType\fPtype) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 870 of file serial_mesh_iterators\&.C\&.
.PP
References _elements\&.
.PP
.nf
871 {
872   Predicates::Type<const_elem_iterator_imp> p(type);
873   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
874 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::unpartitioned_elements_begin ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 227 of file serial_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and pid_elements_begin()\&.
.PP
.nf
228 {
229   return this->pid_elements_begin(DofObject::invalid_processor_id);
230 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::unpartitioned_elements_begin () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 450 of file serial_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and pid_elements_begin()\&.
.PP
.nf
451 {
452   return this->pid_elements_begin(DofObject::invalid_processor_id);
453 }
.fi
.SS "\fBSerialMesh::element_iterator\fP libMesh::SerialMesh::unpartitioned_elements_end ()\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 673 of file serial_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and pid_elements_end()\&.
.PP
.nf
674 {
675   return this->pid_elements_end(DofObject::invalid_processor_id);
676 }
.fi
.SS "\fBSerialMesh::const_element_iterator\fP libMesh::SerialMesh::unpartitioned_elements_end () const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 900 of file serial_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and pid_elements_end()\&.
.PP
.nf
901 {
902   return this->pid_elements_end(DofObject::invalid_processor_id);
903 }
.fi
.SS "virtual void libMesh::SerialMesh::update_parallel_id_counts ()\fC [inline]\fP, \fC [virtual]\fP"
Updates parallel caches so that methods like \fBn_elem()\fP accurately reflect changes on other processors 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 130 of file serial_mesh\&.h\&.
.PP
.nf
130 {}
.fi
.SS "virtual void libMesh::MeshBase::update_post_partitioning ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Recalculate any cached data after elements and nodes have been repartitioned\&. 
.PP
Reimplemented in \fBlibMesh::ParallelMesh\fP\&.
.PP
Definition at line 528 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), and libMesh::Nemesis_IO::read()\&.
.PP
.nf
528 {}
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Write the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&.
.PP
In order to write the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you have been using with this mesh, since these write methods expect it\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 785 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Parallel::Communicator::barrier(), libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::err, libMesh::MeshBase::n_partitions(), libMesh::Quality::name(), libMesh::GMVIO::partitioning(), libMesh::ParallelObject::processor_id(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::FroIO::write(), libMesh::DivaIO::write(), libMesh::TecplotIO::write(), libMesh::MEDITIO::write(), libMesh::GMVIO::write(), libMesh::UCDIO::write(), libMesh::TetGenIO::write(), libMesh::UNVIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::GmshIO::write(), libMesh::XdrIO::write(), libMesh::VTKIO::write(), and libMesh::LegacyXdrIO::write_mgf()\&.
.PP
.nf
787 {
788   // parallel formats are special -- they may choose to write
789   // separate files, let's not try to handle the zipping here\&.
790   if (is_parallel_file_format(name))
791     {
792       // no need to handle bz2 files here -- the Xdr class does that\&.
793       if (name\&.rfind("\&.xda") < name\&.size())
794         XdrIO(*this)\&.write(name);
795 
796       else if (name\&.rfind("\&.xdr") < name\&.size())
797         XdrIO(*this,true)\&.write(name);
798 
799       else if (name\&.rfind("\&.nem") < name\&.size() ||
800                name\&.rfind("\&.n")   < name\&.size())
801         Nemesis_IO(*this)\&.write(name);
802     }
803 
804   // serial file formats
805   else
806     {
807       START_LOG("write()", "Mesh");
808 
809       // Nasty hack for reading/writing zipped files
810       std::string new_name = name;
811       processor_id_type pid_0 = 0;
812       if (this->processor_id() == 0)
813         pid_0 = getpid();
814       this->comm()\&.broadcast(pid_0);
815       std::ostringstream pid_suffix;
816       pid_suffix << '_' << pid_0;
817 
818       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
819         {
820           new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
821           new_name += pid_suffix\&.str();
822         }
823       else if (name\&.size() - name\&.rfind("\&.xz") == 3)
824         {
825           new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
826           new_name += pid_suffix\&.str();
827         }
828 
829       // New scope so that io will close before we try to zip the file
830       {
831         // Write the file based on extension
832         if (new_name\&.rfind("\&.dat") < new_name\&.size())
833           TecplotIO(*this)\&.write (new_name);
834 
835         else if (new_name\&.rfind("\&.plt") < new_name\&.size())
836           TecplotIO(*this,true)\&.write (new_name);
837 
838         else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
839           UCDIO (*this)\&.write (new_name);
840 
841         else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
842           if (this->n_partitions() > 1)
843             GMVIO(*this)\&.write (new_name);
844           else
845             {
846               GMVIO io(*this);
847               io\&.partitioning() = false;
848               io\&.write (new_name);
849             }
850 
851         else if (new_name\&.rfind("\&.ugrid") < new_name\&.size())
852           DivaIO(*this)\&.write(new_name);
853         else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
854                  new_name\&.rfind("\&.e") < new_name\&.size())
855           ExodusII_IO(*this)\&.write(new_name);
856         else if (new_name\&.rfind("\&.mgf")  < new_name\&.size())
857           LegacyXdrIO(*this,true)\&.write_mgf(new_name);
858 
859         else if (new_name\&.rfind("\&.unv") < new_name\&.size())
860           {
861             if (mesh_data == NULL)
862               {
863                 libMesh::err << "Error! You must pass a "
864                              << "valid MeshData pointer to "
865                              << "write UNV files!" << std::endl;
866                 libmesh_error();
867               }
868             UNVIO(*this, *mesh_data)\&.write (new_name);
869           }
870 
871         else if (new_name\&.rfind("\&.mesh") < new_name\&.size())
872           MEDITIO(*this)\&.write (new_name);
873 
874         else if (new_name\&.rfind("\&.poly") < new_name\&.size())
875           TetGenIO(*this)\&.write (new_name);
876 
877         else if (new_name\&.rfind("\&.msh") < new_name\&.size())
878           GmshIO(*this)\&.write (new_name);
879 
880         else if (new_name\&.rfind("\&.fro") < new_name\&.size())
881           FroIO(*this)\&.write (new_name);
882 
883         else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
884           VTKIO(*this)\&.write (new_name);
885 
886         else
887           {
888             libMesh::err
889               << " ERROR: Unrecognized file extension: " << name
890               << "\n   I understand the following:\n\n"
891               << "     *\&.dat   -- Tecplot ASCII file\n"
892               << "     *\&.e     -- Sandia's ExodusII format\n"
893               << "     *\&.exd   -- Sandia's ExodusII format\n"
894               << "     *\&.fro   -- ACDL's surface triangulation file\n"
895               << "     *\&.gmv   -- LANL's GMV (General Mesh Viewer) format\n"
896               << "     *\&.mesh  -- MEdit mesh format\n"
897               << "     *\&.mgf   -- MGF binary mesh format\n"
898               << "     *\&.msh   -- GMSH ASCII file\n"
899               << "     *\&.n     -- Sandia's Nemesis format\n"
900               << "     *\&.nem   -- Sandia's Nemesis format\n"
901               << "     *\&.plt   -- Tecplot binary file\n"
902               << "     *\&.poly  -- TetGen ASCII file\n"
903               << "     *\&.ucd   -- AVS's ASCII UCD format\n"
904               << "     *\&.ugrid -- Kelly's DIVA ASCII format\n"
905               << "     *\&.unv   -- I-deas Universal format\n"
906               << "     *\&.vtu   -- VTK (paraview-readable) format\n"
907               << "     *\&.xda   -- libMesh ASCII format\n"
908               << "     *\&.xdr   -- libMesh binary format,\n"
909               << std::endl
910               << "\n Exiting without writing output\n";
911           }
912       }
913 
914       // Nasty hack for reading/writing zipped files
915       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
916         {
917           START_LOG("system(bzip2)", "Mesh");
918           if (this->processor_id() == 0)
919             {
920               std::string system_string = "bzip2 -f -c ";
921               system_string += new_name + " > " + name;
922               if (std::system(system_string\&.c_str()))
923                 libmesh_file_error(system_string);
924               std::remove(new_name\&.c_str());
925             }
926           this->comm()\&.barrier();
927           STOP_LOG("system(bzip2)", "Mesh");
928         }
929       if (name\&.size() - name\&.rfind("\&.xz") == 3)
930         {
931           START_LOG("system(xz)", "Mesh");
932           if (this->processor_id() == 0)
933             {
934               std::string system_string = "xz -f -c ";
935               system_string += new_name + " > " + name;
936               if (std::system(system_string\&.c_str()))
937                 libmesh_file_error(system_string);
938               std::remove(new_name\&.c_str());
939             }
940           this->comm()\&.barrier();
941           STOP_LOG("system(xz)", "Mesh");
942         }
943 
944       STOP_LOG("write()", "Mesh");
945     }
946 }
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)\fC [inherited]\fP"
Write to the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. Also writes data\&. 
.PP
Definition at line 950 of file unstructured_mesh\&.C\&.
.PP
References libMesh::err, libMesh::MeshBase::n_subdomains(), libMesh::GMVIO::partitioning(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TecplotIO::write_nodal_data(), libMesh::VTKIO::write_nodal_data(), and libMesh::GMVIO::write_nodal_data()\&.
.PP
.nf
953 {
954   START_LOG("write()", "Mesh");
955 
956   // Write the file based on extension
957   if (name\&.rfind("\&.dat") < name\&.size())
958     TecplotIO(*this)\&.write_nodal_data (name, v, vn);
959 
960   else if (name\&.rfind("\&.plt") < name\&.size())
961     TecplotIO(*this,true)\&.write_nodal_data (name, v, vn);
962 
963   else if (name\&.rfind("\&.gmv") < name\&.size())
964     {
965       if (n_subdomains() > 1)
966         GMVIO(*this)\&.write_nodal_data (name, v, vn);
967       else
968         {
969           GMVIO io(*this);
970           io\&.partitioning() = false;
971           io\&.write_nodal_data (name, v, vn);
972         }
973     }
974   else if (name\&.rfind("\&.pvtu") < name\&.size())
975     {
976       VTKIO(*this)\&.write_nodal_data (name, v, vn);
977     }
978   else
979     {
980       libMesh::err
981         << " ERROR: Unrecognized file extension: " << name
982         << "\n   I understand the following:\n\n"
983         << "     *\&.dat  -- Tecplot ASCII file\n"
984         << "     *\&.gmv  -- LANL's GMV (General Mesh Viewer) format\n"
985         << "     *\&.plt  -- Tecplot binary file\n"
986         << "     *\&.pvtu -- Paraview VTK file\n"
987         << "\n Exiting without writing output\n";
988     }
989 
990   STOP_LOG("write()", "Mesh");
991 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::map<\fBsubdomain_id_type\fP, std::string> libMesh::MeshBase::_block_id_to_name\fC [protected]\fP, \fC [inherited]\fP"
This structure maintains the mapping of named blocks for file formats that support named blocks\&. Currently this is only implemented for ExodusII 
.PP
Definition at line 924 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::get_id_by_name(), libMesh::MeshBase::get_subdomain_name_map(), libMesh::MeshBase::set_subdomain_name_map(), and libMesh::MeshBase::subdomain_name()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "unsigned int libMesh::MeshBase::_dim\fC [protected]\fP, \fC [inherited]\fP"
The logical dimension of the mesh\&. 
.PP
Definition at line 876 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::MeshBase(), and libMesh::MeshBase::set_mesh_dimension()\&.
.SS "std::vector<\fBElem\fP*> libMesh::SerialMesh::_elements\fC [protected]\fP"
The elements in the mesh\&. 
.PP
Definition at line 412 of file serial_mesh\&.h\&.
.PP
Referenced by active_elements_begin(), active_elements_end(), active_local_elements_begin(), active_local_elements_end(), active_local_subdomain_elements_begin(), active_local_subdomain_elements_end(), active_not_local_elements_begin(), active_not_local_elements_end(), active_pid_elements_begin(), active_pid_elements_end(), active_subdomain_elements_begin(), active_subdomain_elements_end(), active_type_elements_begin(), active_type_elements_end(), add_elem(), ancestor_elements_begin(), ancestor_elements_end(), assign_unique_ids(), clear(), delete_elem(), elem(), elements_begin(), elements_end(), fix_broken_node_and_element_numbering(), insert_elem(), level_elements_begin(), level_elements_end(), local_elements_begin(), local_elements_end(), local_level_elements_begin(), local_level_elements_end(), local_not_level_elements_begin(), local_not_level_elements_end(), max_elem_id(), n_elem(), not_active_elements_begin(), not_active_elements_end(), not_ancestor_elements_begin(), not_ancestor_elements_end(), not_level_elements_begin(), not_level_elements_end(), not_local_elements_begin(), not_local_elements_end(), not_subactive_elements_begin(), not_subactive_elements_end(), parallel_n_elem(), pid_elements_begin(), pid_elements_end(), query_elem(), renumber_elem(), renumber_nodes_and_elements(), reserve_elem(), subactive_elements_begin(), subactive_elements_end(), type_elements_begin(), and type_elements_end()\&.
.SS "bool libMesh::MeshBase::_is_prepared\fC [protected]\fP, \fC [inherited]\fP"
Flag indicating if the mesh has been prepared for use\&. 
.PP
Definition at line 881 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshBase::is_prepared(), and libMesh::MeshBase::prepare_for_use()\&.
.SS "unsigned int libMesh::MeshBase::_n_parts\fC [protected]\fP, \fC [inherited]\fP"
The number of partitions the mesh has\&. This is set by the partitioners, and may not be changed directly by the user\&. \fBNOTE\fP The number of partitions \fIneed not\fP equal this->\fBn_processors()\fP, consider for example the case where you simply want to partition a mesh on one processor and view the result in GMV\&. 
.PP
Definition at line 871 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshBase::n_partitions(), libMesh::MeshBase::recalculate_n_partitions(), and libMesh::MeshBase::set_n_partitions()\&.
.SS "\fBunique_id_type\fP libMesh::MeshBase::_next_unique_id\fC [protected]\fP, \fC [inherited]\fP"
The next available unique id for assigning ids to DOF objects 
.PP
Definition at line 904 of file mesh_base\&.h\&.
.PP
Referenced by add_elem(), libMesh::ParallelMesh::add_elem(), add_node(), libMesh::ParallelMesh::add_node(), assign_unique_ids(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::MeshBase::next_unique_id(), libMesh::ParallelMesh::ParallelMesh(), SerialMesh(), and libMesh::MeshBase::set_next_unique_id()\&.
.SS "std::vector<\fBNode\fP*> libMesh::SerialMesh::_nodes\fC [protected]\fP"
The verices (spatial coordinates) of the mesh\&. 
.PP
Definition at line 407 of file serial_mesh\&.h\&.
.PP
Referenced by active_nodes_begin(), active_nodes_end(), add_node(), add_point(), assign_unique_ids(), clear(), delete_node(), fix_broken_node_and_element_numbering(), insert_node(), local_nodes_begin(), local_nodes_end(), max_node_id(), n_nodes(), node(), node_ptr(), nodes_begin(), nodes_end(), parallel_n_nodes(), pid_nodes_begin(), pid_nodes_end(), point(), query_node_ptr(), renumber_node(), renumber_nodes_and_elements(), and reserve_nodes()\&.
.SS "\fBAutoPtr\fP<\fBPartitioner\fP> libMesh::MeshBase::_partitioner\fC [protected]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP\&.
.PP
This will be built in the constructor of each derived class, but can be replaced by the user through the \fBpartitioner()\fP accessor\&. 
.PP
Definition at line 898 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::MeshBase(), libMesh::ParallelMesh::ParallelMesh(), libMesh::MeshBase::partitioner(), and SerialMesh()\&.
.SS "\fBAutoPtr\fP<\fBPointLocatorBase\fP> libMesh::MeshBase::_point_locator\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
A \fCPointLocator\fP class for this mesh\&. This will not actually be built unless needed\&. Further, since we want our \fC\fBpoint_locator()\fP\fP method to be \fCconst\fP (yet do the dynamic allocating) this needs to be mutable\&. Since the \fBPointLocatorBase::build()\fP member is used, and it operates on a constant reference to the mesh, this is OK\&. 
.PP
Definition at line 890 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear_point_locator(), libMesh::MeshBase::point_locator(), and libMesh::MeshBase::sub_point_locator()\&.
.SS "bool libMesh::MeshBase::_skip_partitioning\fC [protected]\fP, \fC [inherited]\fP"
If this is true then no partitioning should be done\&. 
.PP
Definition at line 910 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::skip_partitioning()\&.
.SS "bool libMesh::MeshBase::_skip_renumber_nodes_and_elements\fC [protected]\fP, \fC [inherited]\fP"
If this is true then renumbering will be kept to a miniumum\&.
.PP
This is set when \fBprepare_for_use()\fP is called\&. 
.PP
Definition at line 917 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::prepare_for_use(), renumber_nodes_and_elements(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.SS "\fBAutoPtr\fP<\fBBoundaryInfo\fP> libMesh::MeshBase::boundary_info\fC [inherited]\fP"
This class holds the boundary information\&. It can store nodes, edges, and faces with a corresponding id that facilitates setting boundary conditions\&. 
.PP
Definition at line 110 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::AbaqusIO::assign_boundary_node_ids(), libMesh::AbaqusIO::assign_sideset_ids(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::Modification::change_boundary_id(), libMesh::MeshBase::clear(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::UnstructuredMesh::create_submesh(), delete_elem(), libMesh::ParallelMesh::delete_elem(), delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshTools::Modification::flatten(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::BoundaryProjectSolution::operator()(), libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), libMesh::ParallelMesh::ParallelMesh(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_bcs(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::CheckpointIO::read_nodesets(), renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), SerialMesh(), stitching_helper(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::FroIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::XdrIO::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::LegacyXdrIO::write_soln(), and libMesh::DivaIO::write_stream()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
