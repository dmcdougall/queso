.TH "libMesh::VectorValue< T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::VectorValue< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <exact_error_estimator\&.h>\fP
.PP
Inherits \fBlibMesh::TypeVector< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVectorValue\fP ()"
.br
.ti -1c
.RI "\fBVectorValue\fP (const T \fBx\fP, const T y=0, const T z=0)"
.br
.ti -1c
.RI "template<typename Scalar > \fBVectorValue\fP (const Scalar \fBx\fP, const Scalar y=0, typename \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, const Scalar >::type z=0)"
.br
.ti -1c
.RI "template<typename T2 > \fBVectorValue\fP (const \fBVectorValue\fP< T2 > &p)"
.br
.ti -1c
.RI "template<typename T2 > \fBVectorValue\fP (const \fBTypeVector\fP< T2 > &p)"
.br
.ti -1c
.RI "\fBVectorValue\fP (const \fBTypeVector\fP< \fBReal\fP > &p_re, const \fBTypeVector\fP< \fBReal\fP > &p_im)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBVectorValue\fP & >::type \fBoperator=\fP (const Scalar &p)"
.br
.ti -1c
.RI "template<typename T2 > void \fBassign\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "const T & \fBoperator()\fP (const unsigned int i) const "
.br
.ti -1c
.RI "T & \fBoperator()\fP (const unsigned int i)"
.br
.ti -1c
.RI "const T & \fBslice\fP (const unsigned int i) const "
.br
.ti -1c
.RI "T & \fBslice\fP (const unsigned int i)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator+\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeVector\fP< T > & \fBoperator+=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBadd\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBadd_scaled\fP (const \fBTypeVector\fP< T2 > &, const T)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator-\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "\fBTypeVector\fP< T > \fBoperator-\fP () const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeVector\fP< T > & \fBoperator-=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBsubtract\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > void \fBsubtract_scaled\fP (const \fBTypeVector\fP< T2 > &, const T)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar) const "
.br
.ti -1c
.RI "template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBoperator*\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "const \fBTypeVector\fP< T > & \fBoperator*=\fP (const T)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, Scalar >
.br
::supertype > >::type \fBoperator/\fP (const Scalar) const "
.br
.ti -1c
.RI "const \fBTypeVector\fP< T > & \fBoperator/=\fP (const T)"
.br
.ti -1c
.RI "template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBcontract\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBcross\fP (const \fBTypeVector\fP< T2 > &) const "
.br
.ti -1c
.RI "\fBTypeVector\fP< T > \fBunit\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBsize\fP () const "
.br
.ti -1c
.RI "\fBReal\fP \fBsize_sq\fP () const "
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "bool \fBrelative_fuzzy_equals\fP (const \fBTypeVector\fP< T > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "bool \fBabsolute_fuzzy_equals\fP (const \fBTypeVector\fP< T > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "template<> bool \fBoperator!=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "template<> bool \fBoperator<\fP (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "template<> bool \fBoperator<=\fP (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "template<> bool \fBoperator>\fP (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBTypeVector\fP< T > &rhs) const "
.br
.ti -1c
.RI "template<> bool \fBoperator>=\fP (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const"
.br
.ti -1c
.RI "void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "void \fBwrite_unformatted\fP (std::ostream &\fBout\fP, const bool newline=true) const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "T \fB_coords\fP [LIBMESH_DIM]"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T>class libMesh::VectorValue< T >"
This class defines a vector in LIBMESH_DIM dimensional Real or Complex space\&. The typedef RealVectorValue always defines a real-valued vector, and NumberVectorValue defines a real or complex-valued vector depending on how the library was configured\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2003\&. 
.RE
.PP

.PP
Definition at line 48 of file exact_error_estimator\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP ()\fC [inline]\fP"
Empty constructor\&. Gives the vector 0 in \fCLIBMESH_DIM\fP dimensional T space\&. 
.PP
Definition at line 125 of file vector_value\&.h\&.
.PP
.nf
125                              :
126   TypeVector<T> ()
127 {
128 }
.fi
.SS "template<typename T> \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP (const Tx, const Ty = \fC0\fP, const Tz = \fC0\fP)\fC [inline]\fP"
Constructor-from-T\&. By default sets higher dimensional entries to 0\&. 
.PP
Definition at line 133 of file vector_value\&.h\&.
.PP
.nf
135                                         :
136   TypeVector<T> (x,y,z)
137 {
138 }
.fi
.SS "template<typename T > template<typename Scalar > \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP (const Scalarx, const Scalary = \fC0\fP, typename \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, const Scalar >::typez = \fC0\fP)\fC [inline]\fP"
Constructor-from-scalars\&. By default sets higher dimensional entries to 0\&. 
.PP
Definition at line 145 of file vector_value\&.h\&.
.PP
.nf
149                                                   :
150   TypeVector<T> (x,y,z)
151 {
152 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP (const \fBVectorValue\fP< T2 > &p)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 159 of file vector_value\&.h\&.
.PP
.nf
159                                                      :
160   TypeVector<T> (p)
161 {
162 }
.fi
.SS "template<typename T > template<typename T2 > \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 169 of file vector_value\&.h\&.
.PP
.nf
169                                                     :
170   TypeVector<T> (p)
171 {
172 }
.fi
.SS "template<typename T> \fBlibMesh::VectorValue\fP< T >::\fBVectorValue\fP (const \fBTypeVector\fP< \fBReal\fP > &p_re, const \fBTypeVector\fP< \fBReal\fP > &p_im)\fC [inline]\fP"
Constructor that takes two \fC\fBTypeVector<Real>\fP\fP representing the real and imaginary part as arguments\&. 
.PP
Definition at line 177 of file vector_value\&.h\&.
.PP
.nf
178                                                            :
179   TypeVector<T> (Complex (p_re(0), p_im(0)),
180                  Complex (p_re(1), p_im(1)),
181                  Complex (p_re(2), p_im(2)))
182 {
183 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::absolute_fuzzy_equals (const \fBTypeVector\fP< T > &rhs, \fBReal\fPtol = \fC\fBTOLERANCE\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCtol\fP\&. 
.RE
.PP

.PP
Definition at line 854 of file type_vector\&.h\&.
.PP
References std::abs()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::LocationMap< T >::find(), and libMesh::SerialMesh::stitching_helper()\&.
.PP
.nf
855 {
856 #if LIBMESH_DIM == 1
857   return (std::abs(_coords[0] - rhs\&._coords[0])
858           <= tol);
859 #endif
860 
861 #if LIBMESH_DIM == 2
862   return (std::abs(_coords[0] - rhs\&._coords[0]) +
863           std::abs(_coords[1] - rhs\&._coords[1])
864           <= tol);
865 #endif
866 
867 #if LIBMESH_DIM == 3
868   return (std::abs(_coords[0] - rhs\&._coords[0]) +
869           std::abs(_coords[1] - rhs\&._coords[1]) +
870           std::abs(_coords[2] - rhs\&._coords[2])
871           <= tol);
872 #endif
873 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeVector\fP< T >::add (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP, \fC [inherited]\fP"
Add to this vector without creating a temporary\&. 
.PP
Definition at line 516 of file type_vector\&.h\&.
.PP
Referenced by libMesh::Elem::centroid(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::LaplaceMeshSmoother::smooth(), and libMesh::MeshTools::Modification::smooth()\&.
.PP
.nf
517 {
518 #if LIBMESH_DIM == 1
519   _coords[0] += p\&._coords[0];
520 #endif
521 
522 #if LIBMESH_DIM == 2
523   _coords[0] += p\&._coords[0];
524   _coords[1] += p\&._coords[1];
525 #endif
526 
527 #if LIBMESH_DIM == 3
528   _coords[0] += p\&._coords[0];
529   _coords[1] += p\&._coords[1];
530   _coords[2] += p\&._coords[2];
531 #endif
532 
533 }
.fi
.SS "template<typename T> template<typename T2 > void \fBlibMesh::TypeVector\fP< T >::add_scaled (const \fBTypeVector\fP< T2 > &p, const Tfactor)\fC [inline]\fP, \fC [inherited]\fP"
Add a scaled value to this vector without creating a temporary\&. 
.PP
Definition at line 540 of file type_vector\&.h\&.
.PP
Referenced by libMesh::HPCoarsenTest::add_projection(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::System::calculate_norm(), libMesh::Elem::coarsen(), libMesh::MeshFunction::gradient(), libMesh::KellyErrorEstimator::internal_side_integration(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::FE< Dim, T >::map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::System::point_gradient(), libMesh::HPCoarsenTest::select_refinement(), and libMesh::MeshTools::Modification::smooth()\&.
.PP
.nf
541 {
542 #if LIBMESH_DIM == 1
543   _coords[0] += factor*p(0);
544 #endif
545 
546 #if LIBMESH_DIM == 2
547   _coords[0] += factor*p(0);
548   _coords[1] += factor*p(1);
549 #endif
550 
551 #if LIBMESH_DIM == 3
552   _coords[0] += factor*p(0);
553   _coords[1] += factor*p(1);
554   _coords[2] += factor*p(2);
555 #endif
556 
557 }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeVector\fP< T >::assign (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP, \fC [inherited]\fP"
Assign to a vector without creating a temporary\&. 
.PP
Definition at line 445 of file type_vector\&.h\&.
.PP
.nf
446 {
447   for (unsigned int i=0; i<LIBMESH_DIM; i++)
448     _coords[i] = p\&._coords[i];
449 }
.fi
.SS "template<typename T > template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBlibMesh::TypeVector\fP< T >::contract (const \fBTypeVector\fP< T2 > &p) const\fC [inline]\fP, \fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.PP
Definition at line 785 of file type_vector\&.h\&.
.PP
.nf
786 {
787   return (*this)*(p);
788 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeVector\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeVector\fP< T >::cross (const \fBTypeVector\fP< T2 > &p) const\fC [inherited]\fP"
Cross 2 vectors together, i\&.e\&. cross-product\&. 
.PP
Definition at line 795 of file type_vector\&.h\&.
.PP
Referenced by libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::Plane::create_from_three_points(), libMesh::Quad4::volume(), libMesh::Tri3::volume(), libMesh::Pyramid5::volume(), libMesh::Prism6::volume(), libMesh::Hex8::volume(), and libMesh::Tet4::volume()\&.
.PP
.nf
796 {
797   typedef typename CompareTypes<T, T2>::supertype TS;
798   libmesh_assert_equal_to (LIBMESH_DIM, 3);
799 
800   // |     i          j          k    |
801   // |(*this)(0) (*this)(1) (*this)(2)|
802   // |   p(0)       p(1)       p(2)   |
803 
804   return TypeVector<TS>( _coords[1]*p\&._coords[2] - _coords[2]*p\&._coords[1],
805                          -_coords[0]*p\&._coords[2] + _coords[2]*p\&._coords[0],
806                          _coords[0]*p\&._coords[1] - _coords[1]*p\&._coords[0]);
807 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator!= (const \fBTypeVector\fP< T > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors do not occupy approximately the same physical location in space\&. 
.RE
.PP

.SS "template<> bool \fBlibMesh::TypeVector\fP< \fBReal\fP >::operator!= (const \fBTypeVector\fP< \fBReal\fP > &rhs) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 926 of file type_vector\&.h\&.
.PP
.nf
927 {
928   return (!(*this == rhs));
929 }
.fi
.SS "template<typename T > const T & \fBlibMesh::TypeVector\fP< T >::operator() (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"
Return the $ i^{th} $ element of the vector\&. 
.PP
Definition at line 455 of file type_vector\&.h\&.
.PP
.nf
456 {
457   libmesh_assert_less (i, LIBMESH_DIM);
458 
459   return _coords[i];
460 }
.fi
.SS "template<typename T > T & \fBlibMesh::TypeVector\fP< T >::operator() (const unsigned inti)\fC [inline]\fP, \fC [inherited]\fP"
Return a writeable reference to the $ i^{th} $ element of the vector\&. 
.PP
Definition at line 466 of file type_vector\&.h\&.
.PP
.nf
467 {
468   libmesh_assert_less (i, LIBMESH_DIM);
469 
470   return _coords[i];
471 }
.fi
.SS "template<typename T > template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, \fBTypeVector\fP< typename \fBCompareTypes\fP< T, Scalar >::supertype > >::type \fBlibMesh::TypeVector\fP< T >::operator* (const Scalarfactor) const\fC [inline]\fP, \fC [inherited]\fP"
Multiply a vector by a number, i\&.e\&. scale\&. 
.PP
Definition at line 652 of file type_vector\&.h\&.
.PP
.nf
653 {
654   typedef typename CompareTypes<T, Scalar>::supertype SuperType;
655 
656 #if LIBMESH_DIM == 1
657   return TypeVector<SuperType>(_coords[0]*factor);
658 #endif
659 
660 #if LIBMESH_DIM == 2
661   return TypeVector<SuperType>(_coords[0]*factor,
662                                _coords[1]*factor);
663 #endif
664 
665 #if LIBMESH_DIM == 3
666   return TypeVector<SuperType>(_coords[0]*factor,
667                                _coords[1]*factor,
668                                _coords[2]*factor);
669 #endif
670 }
.fi
.SS "template<typename T > template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBlibMesh::TypeVector\fP< T >::operator* (const \fBTypeVector\fP< T2 > &p) const\fC [inline]\fP, \fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.PP
Definition at line 763 of file type_vector\&.h\&.
.PP
.nf
764 {
765 #if LIBMESH_DIM == 1
766   return _coords[0]*p\&._coords[0];
767 #endif
768 
769 #if LIBMESH_DIM == 2
770   return (_coords[0]*p\&._coords[0] +
771           _coords[1]*p\&._coords[1]);
772 #endif
773 
774 #if LIBMESH_DIM == 3
775   return (_coords[0]*p(0) +
776           _coords[1]*p(1) +
777           _coords[2]*p(2));
778 #endif
779 }
.fi
.SS "template<typename T> const \fBTypeVector\fP< T > & \fBlibMesh::TypeVector\fP< T >::operator*= (const Tfactor)\fC [inline]\fP, \fC [inherited]\fP"
Multiply this vector by a number, i\&.e\&. scale\&. 
.PP
Definition at line 689 of file type_vector\&.h\&.
.PP
.nf
690 {
691 #if LIBMESH_DIM == 1
692   _coords[0] *= factor;
693 #endif
694 
695 #if LIBMESH_DIM == 2
696   _coords[0] *= factor;
697   _coords[1] *= factor;
698 #endif
699 
700 #if LIBMESH_DIM == 3
701   _coords[0] *= factor;
702   _coords[1] *= factor;
703   _coords[2] *= factor;
704 #endif
705 
706   return *this;
707 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeVector\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeVector\fP< T >::operator+ (const \fBTypeVector\fP< T2 > &p) const\fC [inline]\fP, \fC [inherited]\fP"
Add two vectors\&. 
.PP
Definition at line 479 of file type_vector\&.h\&.
.PP
.nf
480 {
481   typedef typename CompareTypes<T, T2>::supertype TS;
482 #if LIBMESH_DIM == 1
483   return TypeVector<TS> (_coords[0] + p\&._coords[0]);
484 #endif
485 
486 #if LIBMESH_DIM == 2
487   return TypeVector<TS> (_coords[0] + p\&._coords[0],
488                          _coords[1] + p\&._coords[1]);
489 #endif
490 
491 #if LIBMESH_DIM == 3
492   return TypeVector<TS> (_coords[0] + p\&._coords[0],
493                          _coords[1] + p\&._coords[1],
494                          _coords[2] + p\&._coords[2]);
495 #endif
496 
497 }
.fi
.SS "template<typename T > template<typename T2 > const \fBTypeVector\fP< T > & \fBlibMesh::TypeVector\fP< T >::operator+= (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP, \fC [inherited]\fP"
Add to this vector\&. 
.PP
Definition at line 504 of file type_vector\&.h\&.
.PP
.nf
505 {
506   this->add (p);
507 
508   return *this;
509 }
.fi
.SS "template<typename T > template<typename T2 > \fBTypeVector\fP< typename \fBCompareTypes\fP< T, T2 >::supertype > \fBlibMesh::TypeVector\fP< T >::operator- (const \fBTypeVector\fP< T2 > &p) const\fC [inline]\fP, \fC [inherited]\fP"
Subtract two vectors\&. 
.PP
Definition at line 565 of file type_vector\&.h\&.
.PP
.nf
566 {
567   typedef typename CompareTypes<T, T2>::supertype TS;
568 
569 #if LIBMESH_DIM == 1
570   return TypeVector<TS>(_coords[0] - p\&._coords[0]);
571 #endif
572 
573 #if LIBMESH_DIM == 2
574   return TypeVector<TS>(_coords[0] - p\&._coords[0],
575                         _coords[1] - p\&._coords[1]);
576 #endif
577 
578 #if LIBMESH_DIM == 3
579   return TypeVector<TS>(_coords[0] - p\&._coords[0],
580                         _coords[1] - p\&._coords[1],
581                         _coords[2] - p\&._coords[2]);
582 #endif
583 
584 }
.fi
.SS "template<typename T > \fBTypeVector\fP< T > \fBlibMesh::TypeVector\fP< T >::operator- () const\fC [inline]\fP, \fC [inherited]\fP"
Return the opposite of a vector 
.PP
Definition at line 624 of file type_vector\&.h\&.
.PP
.nf
625 {
626 
627 #if LIBMESH_DIM == 1
628   return TypeVector(-_coords[0]);
629 #endif
630 
631 #if LIBMESH_DIM == 2
632   return TypeVector(-_coords[0],
633                     -_coords[1]);
634 #endif
635 
636 #if LIBMESH_DIM == 3
637   return TypeVector(-_coords[0],
638                     -_coords[1],
639                     -_coords[2]);
640 #endif
641 
642 }
.fi
.SS "template<typename T > template<typename T2 > const \fBTypeVector\fP< T > & \fBlibMesh::TypeVector\fP< T >::operator-= (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP, \fC [inherited]\fP"
Subtract from this vector\&. 
.PP
Definition at line 591 of file type_vector\&.h\&.
.PP
.nf
592 {
593   this->subtract (p);
594 
595   return *this;
596 }
.fi
.SS "template<typename T > template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP< Scalar >::value, \fBTypeVector\fP< typename \fBCompareTypes\fP< T, Scalar >::supertype > >::type \fBlibMesh::TypeVector\fP< T >::operator/ (const Scalarfactor) const\fC [inline]\fP, \fC [inherited]\fP"
Divide a vector by a number, i\&.e\&. scale\&. 
.PP
Definition at line 717 of file type_vector\&.h\&.
.PP
.nf
718 {
719   libmesh_assert_not_equal_to (factor, static_cast<T>(0\&.));
720 
721   typedef typename CompareTypes<T, Scalar>::supertype TS;
722 
723 #if LIBMESH_DIM == 1
724   return TypeVector<TS>(_coords[0]/factor);
725 #endif
726 
727 #if LIBMESH_DIM == 2
728   return TypeVector<TS>(_coords[0]/factor,
729                         _coords[1]/factor);
730 #endif
731 
732 #if LIBMESH_DIM == 3
733   return TypeVector<TS>(_coords[0]/factor,
734                         _coords[1]/factor,
735                         _coords[2]/factor);
736 #endif
737 
738 }
.fi
.SS "template<typename T> const \fBTypeVector\fP< T > & \fBlibMesh::TypeVector\fP< T >::operator/= (const Tfactor)\fC [inline]\fP, \fC [inherited]\fP"
Divide this vector by a number, i\&.e\&. scale\&. 
.PP
Definition at line 746 of file type_vector\&.h\&.
.PP
.nf
747 {
748   libmesh_assert_not_equal_to (factor, static_cast<T>(0\&.));
749 
750   for (unsigned int i=0; i<LIBMESH_DIM; i++)
751     _coords[i] /= factor;
752 
753   return *this;
754 }
.fi
.SS "template<> bool \fBlibMesh::TypeVector\fP< \fBComplex\fP >::operator< (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const\fC [inherited]\fP"

.PP
Definition at line 167 of file type_vector\&.C\&.
.PP
.nf
168 {
169   for (unsigned int i=0; i<LIBMESH_DIM; i++)
170     {
171       if ((*this)(i)\&.real() < rhs(i)\&.real())
172         return true;
173       if ((*this)(i)\&.real() > rhs(i)\&.real())
174         return false;
175       if ((*this)(i)\&.imag() < rhs(i)\&.imag())
176         return true;
177       if ((*this)(i)\&.imag() > rhs(i)\&.imag())
178         return false;
179     }
180   return false;
181 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator< (const \fBTypeVector\fP< T > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.PP
Definition at line 109 of file type_vector\&.C\&.
.PP
.nf
110 {
111   for (unsigned int i=0; i<LIBMESH_DIM; i++)
112     {
113       if ((*this)(i) < rhs(i))
114         return true;
115       if ((*this)(i) > rhs(i))
116         return false;
117     }
118   return false;
119 }
.fi
.SS "template<> bool \fBlibMesh::TypeVector\fP< \fBComplex\fP >::operator<= (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const\fC [inherited]\fP"

.PP
Definition at line 186 of file type_vector\&.C\&.
.PP
.nf
187 {
188   for (unsigned int i=0; i<LIBMESH_DIM; i++)
189     {
190       if ((*this)(i)\&.real() < rhs(i)\&.real())
191         return true;
192       if ((*this)(i)\&.real() > rhs(i)\&.real())
193         return false;
194       if ((*this)(i)\&.imag() < rhs(i)\&.imag())
195         return true;
196       if ((*this)(i)\&.imag() > rhs(i)\&.imag())
197         return false;
198     }
199   return true;
200 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator<= (const \fBTypeVector\fP< T > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.PP
Definition at line 123 of file type_vector\&.C\&.
.PP
.nf
124 {
125   for (unsigned int i=0; i<LIBMESH_DIM; i++)
126     {
127       if ((*this)(i) < rhs(i))
128         return true;
129       if ((*this)(i) > rhs(i))
130         return false;
131     }
132   return true;
133 }
.fi
.SS "template<typename T> template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBVectorValue\fP&>::type \fBlibMesh::VectorValue\fP< T >::operator= (const Scalar &p)\fC [inline]\fP"
Assignment-from-scalar operator\&. Used only to zero out vectors\&. 
.PP
Definition at line 98 of file vector_value\&.h\&.
.PP
.nf
99   { libmesh_assert_equal_to (p, Scalar(0)); this->zero(); return *this; }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator== (const \fBTypeVector\fP< T > &rhs) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCTOLERANCE\fP\&. 
.RE
.PP

.PP
Definition at line 904 of file type_vector\&.h\&.
.PP
.nf
905 {
906 #if LIBMESH_DIM == 1
907   return (_coords[0] == rhs\&._coords[0]);
908 #endif
909 
910 #if LIBMESH_DIM == 2
911   return (_coords[0] == rhs\&._coords[0] &&
912           _coords[1] == rhs\&._coords[1]);
913 #endif
914 
915 #if LIBMESH_DIM == 3
916   return (_coords[0] == rhs\&._coords[0] &&
917           _coords[1] == rhs\&._coords[1] &&
918           _coords[2] == rhs\&._coords[2]);
919 #endif
920 }
.fi
.SS "template<> bool \fBlibMesh::TypeVector\fP< \fBComplex\fP >::operator> (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const\fC [inherited]\fP"

.PP
Definition at line 205 of file type_vector\&.C\&.
.PP
.nf
206 {
207   for (unsigned int i=0; i<LIBMESH_DIM; i++)
208     {
209       if ((*this)(i)\&.real() > rhs(i)\&.real())
210         return true;
211       if ((*this)(i)\&.real() < rhs(i)\&.real())
212         return false;
213       if ((*this)(i)\&.imag() > rhs(i)\&.imag())
214         return true;
215       if ((*this)(i)\&.imag() < rhs(i)\&.imag())
216         return false;
217     }
218   return false;
219 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator> (const \fBTypeVector\fP< T > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.PP
Definition at line 138 of file type_vector\&.C\&.
.PP
.nf
139 {
140   for (unsigned int i=0; i<LIBMESH_DIM; i++)
141     {
142       if ((*this)(i) > rhs(i))
143         return true;
144       if ((*this)(i) < rhs(i))
145         return false;
146     }
147   return false;
148 }
.fi
.SS "template<> bool \fBlibMesh::TypeVector\fP< \fBComplex\fP >::operator>= (const \fBTypeVector\fP< \fBComplex\fP > &rhs) const\fC [inherited]\fP"

.PP
Definition at line 224 of file type_vector\&.C\&.
.PP
.nf
225 {
226   for (unsigned int i=0; i<LIBMESH_DIM; i++)
227     {
228       if ((*this)(i)\&.real() > rhs(i)\&.real())
229         return true;
230       if ((*this)(i)\&.real() < rhs(i)\&.real())
231         return false;
232       if ((*this)(i)\&.imag() > rhs(i)\&.imag())
233         return true;
234       if ((*this)(i)\&.imag() < rhs(i)\&.imag())
235         return false;
236     }
237   return true;
238 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::operator>= (const \fBTypeVector\fP< T > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.PP
Definition at line 152 of file type_vector\&.C\&.
.PP
.nf
153 {
154   for (unsigned int i=0; i<LIBMESH_DIM; i++)
155     {
156       if ((*this)(i) > rhs(i))
157         return true;
158       if ((*this)(i) < rhs(i))
159         return false;
160     }
161   return true;
162 }
.fi
.SS "template<typename T > void \fBlibMesh::TypeVector\fP< T >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Formatted print, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 64 of file type_vector\&.C\&.
.PP
.nf
65 {
66 #if LIBMESH_DIM == 1
67 
68   os << "x=" << (*this)(0);
69 
70 #endif
71 #if LIBMESH_DIM == 2
72 
73   os << "(x,y)=("
74      << std::setw(8) << (*this)(0) << ", "
75      << std::setw(8) << (*this)(1) << ")";
76 
77 #endif
78 #if LIBMESH_DIM == 3
79 
80   os <<  "(x,y,z)=("
81      << std::setw(8) << (*this)(0) << ", "
82      << std::setw(8) << (*this)(1) << ", "
83      << std::setw(8) << (*this)(2) << ")";
84 #endif
85 }
.fi
.SS "template<typename T> bool \fBlibMesh::TypeVector\fP< T >::relative_fuzzy_equals (const \fBTypeVector\fP< T > &rhs, \fBReal\fPtol = \fC\fBTOLERANCE\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within a relative tolerance of \fCtol\fP\&. 
.RE
.PP

.PP
Definition at line 879 of file type_vector\&.h\&.
.PP
References std::abs()\&.
.PP
Referenced by libMesh::Prism6::has_affine_map(), libMesh::Quad4::has_affine_map(), libMesh::Hex8::has_affine_map(), libMesh::Quad9::has_affine_map(), libMesh::Quad8::has_affine_map(), libMesh::Hex27::has_affine_map(), libMesh::Hex20::has_affine_map(), libMesh::Prism15::has_affine_map(), and libMesh::Prism18::has_affine_map()\&.
.PP
.nf
880 {
881 #if LIBMESH_DIM == 1
882   return this->absolute_fuzzy_equals(rhs, tol *
883                                      (std::abs(_coords[0]) + std::abs(rhs\&._coords[0])));
884 #endif
885 
886 #if LIBMESH_DIM == 2
887   return this->absolute_fuzzy_equals(rhs, tol *
888                                      (std::abs(_coords[0]) + std::abs(rhs\&._coords[0]) +
889                                       std::abs(_coords[1]) + std::abs(rhs\&._coords[1])));
890 #endif
891 
892 #if LIBMESH_DIM == 3
893   return this->absolute_fuzzy_equals(rhs, tol *
894                                      (std::abs(_coords[0]) + std::abs(rhs\&._coords[0]) +
895                                       std::abs(_coords[1]) + std::abs(rhs\&._coords[1]) +
896                                       std::abs(_coords[2]) + std::abs(rhs\&._coords[2])));
897 #endif
898 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::TypeVector\fP< T >::size () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the magnitude of the vector, i\&.e\&. the square-root of the sum of the elements squared\&. 
.PP
Definition at line 813 of file type_vector\&.h\&.
.PP
Referenced by libMesh::Sphere::above_surface(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::System::calculate_norm(), libMesh::DofMap::get_info(), libMesh::FEInterface::inverse_map(), libMesh::FE< Dim, T >::inverse_map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::Tri3::min_and_max_angle(), libMesh::Tet4::min_and_max_angle(), libMesh::Sphere::on_surface(), libMesh::Tri::quality(), libMesh::DofMap::scatter_constraints(), libMesh::MeshTools::Modification::smooth(), and libMesh::Sphere::surface_coords()\&.
.PP
.nf
814 {
815   return std::sqrt(this->size_sq());
816 }
.fi
.SS "template<typename T > \fBReal\fP \fBlibMesh::TypeVector\fP< T >::size_sq () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the magnitude of the vector squared, i\&.e\&. the sum of the element magnitudes squared\&. 
.PP
Definition at line 832 of file type_vector\&.h\&.
.PP
References libMesh::TensorTools::norm_sq()\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::System::calculate_norm(), libMesh::InfQuad4::contains_point(), libMesh::InfPrism6::contains_point(), libMesh::InfHex8::contains_point(), libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::Elem::hmax(), libMesh::Elem::hmin(), libMesh::TensorTools::norm_sq(), libMesh::PointLocatorList::operator()(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Sphere::Sphere(), and libMesh::Edge3::volume()\&.
.PP
.nf
833 {
834 #if LIBMESH_DIM == 1
835   return (TensorTools::norm_sq(_coords[0]));
836 #endif
837 
838 #if LIBMESH_DIM == 2
839   return (TensorTools::norm_sq(_coords[0]) +
840           TensorTools::norm_sq(_coords[1]));
841 #endif
842 
843 #if LIBMESH_DIM == 3
844   return (TensorTools::norm_sq(_coords[0]) +
845           TensorTools::norm_sq(_coords[1]) +
846           TensorTools::norm_sq(_coords[2]));
847 #endif
848 }
.fi
.SS "template<typename T> const T& \fBlibMesh::TypeVector\fP< T >::slice (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 123 of file type_vector\&.h\&.
.PP
.nf
123 { return (*this)(i); }
.fi
.SS "template<typename T> T& \fBlibMesh::TypeVector\fP< T >::slice (const unsigned inti)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 130 of file type_vector\&.h\&.
.PP
.nf
130 { return (*this)(i); }
.fi
.SS "template<typename T > template<typename T2 > void \fBlibMesh::TypeVector\fP< T >::subtract (const \fBTypeVector\fP< T2 > &p)\fC [inline]\fP, \fC [inherited]\fP"
Subtract from this vector without creating a temporary\&. 
.PP
Definition at line 603 of file type_vector\&.h\&.
.PP
.nf
604 {
605   for (unsigned int i=0; i<LIBMESH_DIM; i++)
606     _coords[i] -= p\&._coords[i];
607 }
.fi
.SS "template<typename T> template<typename T2 > void \fBlibMesh::TypeVector\fP< T >::subtract_scaled (const \fBTypeVector\fP< T2 > &p, const Tfactor)\fC [inline]\fP, \fC [inherited]\fP"
Subtract a scaled value from this vector without creating a temporary\&. 
.PP
Definition at line 614 of file type_vector\&.h\&.
.PP
Referenced by libMesh::HPCoarsenTest::select_refinement()\&.
.PP
.nf
615 {
616   for (unsigned int i=0; i<LIBMESH_DIM; i++)
617     _coords[i] -= factor*p(i);
618 }
.fi
.SS "template<typename T > \fBTypeVector\fP< T > \fBlibMesh::TypeVector\fP< T >::unit () const\fC [inherited]\fP"
Think of a vector as a \fCdim\fP dimensional vector\&. This will return a unit vector aligned in that direction\&. 
.PP
Definition at line 37 of file type_vector\&.C\&.
.PP
References libMesh::Real\&.
.PP
Referenced by libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::Plane::create_from_point_normal(), libMesh::Plane::create_from_three_points(), libMesh::MeshTools::Modification::distort(), and libMesh::Sphere::unit_normal()\&.
.PP
.nf
38 {
39 
40   const Real length = size();
41 
42   libmesh_assert_not_equal_to (length, static_cast<Real>(0\&.));
43 
44 #if LIBMESH_DIM == 1
45   return TypeVector<T>(_coords[0]/length);
46 #endif
47 
48 #if LIBMESH_DIM == 2
49   return TypeVector<T>(_coords[0]/length,
50                        _coords[1]/length);
51 #endif
52 
53 #if LIBMESH_DIM == 3
54   return TypeVector<T>(_coords[0]/length,
55                        _coords[1]/length,
56                        _coords[2]/length);
57 #endif
58 
59 }
.fi
.SS "template<typename T > void \fBlibMesh::TypeVector\fP< T >::write_unformatted (std::ostream &out, const boolnewline = \fCtrue\fP) const\fC [inherited]\fP"
Unformatted print to the stream \fCout\fP\&. Simply prints the elements of the vector separated by spaces\&. Optionally prints a newline, which it does by default\&. 
.PP
Definition at line 92 of file type_vector\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::InfElemBuilder::build_inf_elem(), libMesh::TecplotIO::write_ascii(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
94 {
95   libmesh_assert (os);
96 
97   os << std::setiosflags(std::ios::showpoint)
98      << (*this)(0) << " "
99      << (*this)(1) << " "
100      << (*this)(2) << " ";
101 
102   if (newline)
103     os << '\n';
104 }
.fi
.SS "template<typename T > void \fBlibMesh::TypeVector\fP< T >::zero ()\fC [inline]\fP, \fC [inherited]\fP"
Zero the vector in any dimension\&. 
.PP
Definition at line 822 of file type_vector\&.h\&.
.PP
Referenced by libMesh::VectorValue< Real >::operator=(), and libMesh::TypeVector< Real >::operator=()\&.
.PP
.nf
823 {
824   for (unsigned int i=0; i<LIBMESH_DIM; i++)
825     _coords[i] = 0\&.;
826 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<typename T> T \fBlibMesh::TypeVector\fP< T >::_coords[LIBMESH_DIM]\fC [protected]\fP, \fC [inherited]\fP"
The coordinates of the \fC\fBTypeVector\fP\fP 
.PP
Definition at line 347 of file type_vector\&.h\&.
.PP
Referenced by libMesh::TypeTensor< T >::row()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
