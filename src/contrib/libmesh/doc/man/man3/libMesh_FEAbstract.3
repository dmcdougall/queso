.TH "libMesh::FEAbstract" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FEAbstract \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe_abstract\&.h>\fP
.PP
Inherits \fBlibMesh::ReferenceCountedObject< FEAbstract >\fP\&.
.PP
Inherited by \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP, and \fBlibMesh::FEGenericBase< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~FEAbstract\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBreinit\fP (const \fBElem\fP *elem, const unsigned int \fBside\fP, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *const pts=NULL, const std::vector< \fBReal\fP > *const weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBedge_reinit\fP (const \fBElem\fP *elem, const unsigned int edge, const \fBReal\fP tolerance=\fBTOLERANCE\fP, const std::vector< \fBPoint\fP > *pts=NULL, const std::vector< \fBReal\fP > *weights=NULL)=0"
.br
.ti -1c
.RI "virtual void \fBside_map\fP (const \fBElem\fP *elem, const \fBElem\fP *\fBside\fP, const unsigned int s, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)=0"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "virtual void \fBattach_quadrature_rule\fP (\fBQBase\fP *q)=0"
.br
.ti -1c
.RI "virtual unsigned int \fBn_shape_functions\fP () const =0"
.br
.ti -1c
.RI "virtual unsigned int \fBn_quadrature_points\fP () const =0"
.br
.ti -1c
.RI "\fBElemType\fP \fBget_type\fP () const "
.br
.ti -1c
.RI "unsigned int \fBget_p_level\fP () const "
.br
.ti -1c
.RI "\fBFEType\fP \fBget_fe_type\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBget_order\fP () const "
.br
.ti -1c
.RI "virtual \fBFEContinuity\fP \fBget_continuity\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBis_hierarchic\fP () const =0"
.br
.ti -1c
.RI "\fBFEFamily\fP \fBget_family\fP () const "
.br
.ti -1c
.RI "const \fBFEMap\fP & \fBget_fe_map\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "virtual void \fBprint_phi\fP (std::ostream &os) const =0"
.br
.ti -1c
.RI "virtual void \fBprint_dphi\fP (std::ostream &os) const =0"
.br
.ti -1c
.RI "virtual void \fBprint_d2phi\fP (std::ostream &os) const =0"
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEAbstract\fP > \fBbuild\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &type)"
.br
.ti -1c
.RI "static bool \fBon_reference_element\fP (const \fBPoint\fP &p, const \fBElemType\fP t, const \fBReal\fP eps=\fBTOLERANCE\fP)"
.br
.ti -1c
.RI "static void \fBget_refspace_nodes\fP (const \fBElemType\fP t, std::vector< \fBPoint\fP > &nodes)"
.br
.ti -1c
.RI "static void \fBcompute_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static void \fBcompute_periodic_node_constraints\fP (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBFEAbstract\fP (const unsigned int \fBdim\fP, const \fBFEType\fP &fet)"
.br
.ti -1c
.RI "virtual void \fBcompute_shape_functions\fP (const \fBElem\fP *, const std::vector< \fBPoint\fP > &)=0"
.br
.ti -1c
.RI "virtual bool \fBshapes_need_reinit\fP () const =0"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBFEMap\fP > \fB_fe_map\fP"
.br
.ti -1c
.RI "const unsigned int \fBdim\fP"
.br
.ti -1c
.RI "bool \fBcalculations_started\fP"
.br
.ti -1c
.RI "bool \fBcalculate_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_d2phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_curl_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_div_phi\fP"
.br
.ti -1c
.RI "bool \fBcalculate_dphiref\fP"
.br
.ti -1c
.RI "const \fBFEType\fP \fBfe_type\fP"
.br
.ti -1c
.RI "\fBElemType\fP \fBelem_type\fP"
.br
.ti -1c
.RI "unsigned int \fB_p_level\fP"
.br
.ti -1c
.RI "\fBQBase\fP * \fBqrule\fP"
.br
.ti -1c
.RI "bool \fBshapes_on_quadrature\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBFEAbstract\fP &fe)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class forms the foundation from which generic finite elements may be derived\&. In the current implementation the templated derived class \fC\fBFE\fP\fP offers a wide variety of commonly used finite element concepts\&. Check there for details\&. Use the \fC\fBFEAbstract::build()\fP\fP method to create an object of any of the derived classes\&. Note that the amount of virtual members is kept to a minimum, and the sophisticated template scheme of \fC\fBFE\fP\fP is quite likely to offer acceptably fast code\&.
.PP
All calls to static members of the \fC\fBFE\fP\fP classes should be requested through the \fC\fBFEInterface\fP\fP\&. This interface class offers sort-of runtime polymorphism for the templated finite element classes\&. Even internal library classes, like \fC\fBDofMap\fP\fP, request the number of dof's through this interface class\&. Note that this also enables the co-existence of various element-based schemes\&. This class is well 'at the heart' of the library, so things in here should better remain unchanged\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2002 
.RE
.PP

.PP
Definition at line 97 of file fe_abstract\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::FEAbstract::FEAbstract (const unsigned intdim, const \fBFEType\fP &fet)\fC [inline]\fP, \fC [protected]\fP"
Constructor\&. Optionally initializes required data structures\&. Protected so that this base class cannot be explicitly instantiated\&. 
.PP
Definition at line 599 of file fe_abstract\&.h\&.
.PP
.nf
600                                           :
601   _fe_map( FEMap::build(fet) ),
602   dim(d),
603   calculations_started(false),
604   calculate_phi(false),
605   calculate_dphi(false),
606   calculate_d2phi(false),
607   calculate_curl_phi(false),
608   calculate_div_phi(false),
609   calculate_dphiref(false),
610   fe_type(fet),
611   elem_type(INVALID_ELEM),
612   _p_level(0),
613   qrule(NULL),
614   shapes_on_quadrature(false)
615 {
616 }
.fi
.SS "libMesh::FEAbstract::~FEAbstract ()\fC [inline]\fP, \fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 620 of file fe_abstract\&.h\&.
.PP
.nf
621 {
622 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "virtual void libMesh::FEAbstract::attach_quadrature_rule (\fBQBase\fP *q)\fC [pure virtual]\fP"
Provides the class with the quadrature rule\&. Implement this in derived classes\&. 
.PP
Implemented in \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "\fBAutoPtr\fP< \fBFEAbstract\fP > libMesh::FEAbstract::build (const unsigned intdim, const \fBFEType\fP &type)\fC [static]\fP"
Builds a specific finite element type\&. A \fCAutoPtr<FEAbstract>\fP is returned to prevent a memory leak\&. This way the user need not remember to delete the object\&. 
.PP
Definition at line 44 of file fe_abstract\&.C\&.
.PP
References libMesh::BERNSTEIN, libMesh::CLOUGH, libMesh::FEType::family, libMesh::HERMITE, libMesh::HIERARCHIC, libMesh::L2_HIERARCHIC, libMesh::L2_LAGRANGE, libMesh::LAGRANGE, libMesh::LAGRANGE_VEC, libMesh::MONOMIAL, libMesh::NEDELEC_ONE, libMesh::out, libMesh::SCALAR, libMesh::SUBDIVISION, libMesh::SZABAB, and libMesh::XYZ\&.
.PP
Referenced by libMesh::DGFEMContext::DGFEMContext(), libMesh::FEMContext::FEMContext(), and libMesh::DofMap::use_coupled_neighbor_dofs()\&.
.PP
.nf
46 {
47   // The stupid AutoPtr<FEAbstract> ap(); return ap;
48   // construct is required to satisfy IBM's xlC
49 
50   switch (dim)
51     {
52       // 0D
53     case 0:
54       {
55         switch (fet\&.family)
56           {
57           case CLOUGH:
58             {
59               AutoPtr<FEAbstract> ap(new FE<0,CLOUGH>(fet));
60               return ap;
61             }
62 
63           case HERMITE:
64             {
65               AutoPtr<FEAbstract> ap(new FE<0,HERMITE>(fet));
66               return ap;
67             }
68 
69           case LAGRANGE:
70             {
71               AutoPtr<FEAbstract> ap(new FE<0,LAGRANGE>(fet));
72               return ap;
73             }
74 
75           case LAGRANGE_VEC:
76             {
77               AutoPtr<FEAbstract> ap(new FE<0,LAGRANGE_VEC>(fet));
78               return ap;
79             }
80 
81           case L2_LAGRANGE:
82             {
83               AutoPtr<FEAbstract> ap(new FE<0,L2_LAGRANGE>(fet));
84               return ap;
85             }
86 
87           case HIERARCHIC:
88             {
89               AutoPtr<FEAbstract> ap(new FE<0,HIERARCHIC>(fet));
90               return ap;
91             }
92 
93           case L2_HIERARCHIC:
94             {
95               AutoPtr<FEAbstract> ap(new FE<0,L2_HIERARCHIC>(fet));
96               return ap;
97             }
98 
99           case MONOMIAL:
100             {
101               AutoPtr<FEAbstract> ap(new FE<0,MONOMIAL>(fet));
102               return ap;
103             }
104 
105 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
106           case SZABAB:
107             {
108               AutoPtr<FEAbstract> ap(new FE<0,SZABAB>(fet));
109               return ap;
110             }
111 
112           case BERNSTEIN:
113             {
114               AutoPtr<FEAbstract> ap(new FE<0,BERNSTEIN>(fet));
115               return ap;
116             }
117 #endif
118 
119           case XYZ:
120             {
121               AutoPtr<FEAbstract> ap(new FEXYZ<0>(fet));
122               return ap;
123             }
124 
125           case SCALAR:
126             {
127               AutoPtr<FEAbstract> ap(new FEScalar<0>(fet));
128               return ap;
129             }
130 
131           default:
132             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
133             libmesh_error();
134           }
135       }
136       // 1D
137     case 1:
138       {
139         switch (fet\&.family)
140           {
141           case CLOUGH:
142             {
143               AutoPtr<FEAbstract> ap(new FE<1,CLOUGH>(fet));
144               return ap;
145             }
146 
147           case HERMITE:
148             {
149               AutoPtr<FEAbstract> ap(new FE<1,HERMITE>(fet));
150               return ap;
151             }
152 
153           case LAGRANGE:
154             {
155               AutoPtr<FEAbstract> ap(new FE<1,LAGRANGE>(fet));
156               return ap;
157             }
158 
159           case LAGRANGE_VEC:
160             {
161               AutoPtr<FEAbstract> ap(new FE<1,LAGRANGE_VEC>(fet));
162               return ap;
163             }
164 
165           case L2_LAGRANGE:
166             {
167               AutoPtr<FEAbstract> ap(new FE<1,L2_LAGRANGE>(fet));
168               return ap;
169             }
170 
171           case HIERARCHIC:
172             {
173               AutoPtr<FEAbstract> ap(new FE<1,HIERARCHIC>(fet));
174               return ap;
175             }
176 
177           case L2_HIERARCHIC:
178             {
179               AutoPtr<FEAbstract> ap(new FE<1,L2_HIERARCHIC>(fet));
180               return ap;
181             }
182 
183           case MONOMIAL:
184             {
185               AutoPtr<FEAbstract> ap(new FE<1,MONOMIAL>(fet));
186               return ap;
187             }
188 
189 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
190           case SZABAB:
191             {
192               AutoPtr<FEAbstract> ap(new FE<1,SZABAB>(fet));
193               return ap;
194             }
195 
196           case BERNSTEIN:
197             {
198               AutoPtr<FEAbstract> ap(new FE<1,BERNSTEIN>(fet));
199               return ap;
200             }
201 #endif
202 
203           case XYZ:
204             {
205               AutoPtr<FEAbstract> ap(new FEXYZ<1>(fet));
206               return ap;
207             }
208 
209           case SCALAR:
210             {
211               AutoPtr<FEAbstract> ap(new FEScalar<1>(fet));
212               return ap;
213             }
214 
215           default:
216             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
217             libmesh_error();
218           }
219       }
220 
221 
222       // 2D
223     case 2:
224       {
225         switch (fet\&.family)
226           {
227           case CLOUGH:
228             {
229               AutoPtr<FEAbstract> ap(new FE<2,CLOUGH>(fet));
230               return ap;
231             }
232 
233           case HERMITE:
234             {
235               AutoPtr<FEAbstract> ap(new FE<2,HERMITE>(fet));
236               return ap;
237             }
238 
239           case LAGRANGE:
240             {
241               AutoPtr<FEAbstract> ap(new FE<2,LAGRANGE>(fet));
242               return ap;
243             }
244 
245           case LAGRANGE_VEC:
246             {
247               AutoPtr<FEAbstract> ap(new FE<2,LAGRANGE_VEC>(fet));
248               return ap;
249             }
250 
251           case L2_LAGRANGE:
252             {
253               AutoPtr<FEAbstract> ap(new FE<2,L2_LAGRANGE>(fet));
254               return ap;
255             }
256 
257           case HIERARCHIC:
258             {
259               AutoPtr<FEAbstract> ap(new FE<2,HIERARCHIC>(fet));
260               return ap;
261             }
262 
263           case L2_HIERARCHIC:
264             {
265               AutoPtr<FEAbstract> ap(new FE<2,L2_HIERARCHIC>(fet));
266               return ap;
267             }
268 
269           case MONOMIAL:
270             {
271               AutoPtr<FEAbstract> ap(new FE<2,MONOMIAL>(fet));
272               return ap;
273             }
274 
275 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
276           case SZABAB:
277             {
278               AutoPtr<FEAbstract> ap(new FE<2,SZABAB>(fet));
279               return ap;
280             }
281 
282           case BERNSTEIN:
283             {
284               AutoPtr<FEAbstract> ap(new FE<2,BERNSTEIN>(fet));
285               return ap;
286             }
287 #endif
288 
289           case XYZ:
290             {
291               AutoPtr<FEAbstract> ap(new FEXYZ<2>(fet));
292               return ap;
293             }
294 
295           case SCALAR:
296             {
297               AutoPtr<FEAbstract> ap(new FEScalar<2>(fet));
298               return ap;
299             }
300 
301           case NEDELEC_ONE:
302             {
303               AutoPtr<FEAbstract> ap(new FENedelecOne<2>(fet));
304               return ap;
305             }
306 
307           case SUBDIVISION:
308             {
309               AutoPtr<FEAbstract> ap(new FESubdivision(fet));
310               return ap;
311             }
312 
313           default:
314             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
315             libmesh_error();
316           }
317       }
318 
319 
320       // 3D
321     case 3:
322       {
323         switch (fet\&.family)
324           {
325           case CLOUGH:
326             {
327               libMesh::out << "ERROR: Clough-Tocher elements currently only support 1D and 2D"
328                            << std::endl;
329               libmesh_error();
330             }
331 
332           case HERMITE:
333             {
334               AutoPtr<FEAbstract> ap(new FE<3,HERMITE>(fet));
335               return ap;
336             }
337 
338           case LAGRANGE:
339             {
340               AutoPtr<FEAbstract> ap(new FE<3,LAGRANGE>(fet));
341               return ap;
342             }
343 
344           case LAGRANGE_VEC:
345             {
346               AutoPtr<FEAbstract> ap(new FE<3,LAGRANGE_VEC>(fet));
347               return ap;
348             }
349 
350           case L2_LAGRANGE:
351             {
352               AutoPtr<FEAbstract> ap(new FE<3,L2_LAGRANGE>(fet));
353               return ap;
354             }
355 
356           case HIERARCHIC:
357             {
358               AutoPtr<FEAbstract> ap(new FE<3,HIERARCHIC>(fet));
359               return ap;
360             }
361 
362           case L2_HIERARCHIC:
363             {
364               AutoPtr<FEAbstract> ap(new FE<3,L2_HIERARCHIC>(fet));
365               return ap;
366             }
367 
368           case MONOMIAL:
369             {
370               AutoPtr<FEAbstract> ap(new FE<3,MONOMIAL>(fet));
371               return ap;
372             }
373 
374 #ifdef LIBMESH_ENABLE_HIGHER_ORDER_SHAPES
375           case SZABAB:
376             {
377               AutoPtr<FEAbstract> ap(new FE<3,SZABAB>(fet));
378               return ap;
379             }
380 
381           case BERNSTEIN:
382             {
383               AutoPtr<FEAbstract> ap(new FE<3,BERNSTEIN>(fet));
384               return ap;
385             }
386 #endif
387 
388           case XYZ:
389             {
390               AutoPtr<FEAbstract> ap(new FEXYZ<3>(fet));
391               return ap;
392             }
393 
394           case SCALAR:
395             {
396               AutoPtr<FEAbstract> ap(new FEScalar<3>(fet));
397               return ap;
398             }
399 
400           case NEDELEC_ONE:
401             {
402               AutoPtr<FEAbstract> ap(new FENedelecOne<3>(fet));
403               return ap;
404             }
405 
406           default:
407             libMesh::out << "ERROR: Bad FEType\&.family= " << fet\&.family << std::endl;
408             libmesh_error();
409           }
410       }
411 
412     default:
413       libmesh_error();
414     }
415 
416   libmesh_error();
417   AutoPtr<FEAbstract> ap(NULL);
418   return ap;
419 }
.fi
.SS "void libMesh::FEAbstract::compute_node_constraints (\fBNodeConstraints\fP &constraints, const \fBElem\fP *elem)\fC [static]\fP"
Computes the nodal constraint contributions (for non-conforming adapted meshes), using Lagrange geometry 
.PP
Definition at line 954 of file fe_abstract\&.C\&.
.PP
References std::abs(), libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), fe_type, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Real, libMesh::remote_elem, libMesh::FEInterface::shape(), libMesh::Threads::spin_mtx, and libMesh::Elem::subactive()\&.
.PP
.nf
956 {
957   libmesh_assert(elem);
958 
959   const unsigned int Dim = elem->dim();
960 
961   // Only constrain elements in 2,3D\&.
962   if (Dim == 1)
963     return;
964 
965   // Only constrain active and ancestor elements
966   if (elem->subactive())
967     return;
968 
969   // We currently always use LAGRANGE mappings for geometry
970   const FEType fe_type(elem->default_order(), LAGRANGE);
971 
972   std::vector<const Node*> my_nodes, parent_nodes;
973 
974   // Look at the element faces\&.  Check to see if we need to
975   // build constraints\&.
976   for (unsigned int s=0; s<elem->n_sides(); s++)
977     if (elem->neighbor(s) != NULL &&
978         elem->neighbor(s) != remote_elem)
979       if (elem->neighbor(s)->level() < elem->level()) // constrain dofs shared between
980         {                                                     // this element and ones coarser
981           // than this element\&.
982           // Get pointers to the elements of interest and its parent\&.
983           const Elem* parent = elem->parent();
984 
985           // This can't happen\&.\&.\&.  Only level-0 elements have NULL
986           // parents, and no level-0 elements can be at a higher
987           // level than their neighbors!
988           libmesh_assert(parent);
989 
990           const AutoPtr<Elem> my_side     (elem->build_side(s));
991           const AutoPtr<Elem> parent_side (parent->build_side(s));
992 
993           const unsigned int n_side_nodes = my_side->n_nodes();
994 
995           my_nodes\&.clear();
996           my_nodes\&.reserve (n_side_nodes);
997           parent_nodes\&.clear();
998           parent_nodes\&.reserve (n_side_nodes);
999 
1000           for (unsigned int n=0; n != n_side_nodes; ++n)
1001             my_nodes\&.push_back(my_side->get_node(n));
1002 
1003           for (unsigned int n=0; n != n_side_nodes; ++n)
1004             parent_nodes\&.push_back(parent_side->get_node(n));
1005 
1006           for (unsigned int my_side_n=0;
1007                my_side_n < n_side_nodes;
1008                my_side_n++)
1009             {
1010               libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1011 
1012               const Node* my_node = my_nodes[my_side_n];
1013 
1014               // The support point of the DOF
1015               const Point& support_point = *my_node;
1016 
1017               // Figure out where my node lies on their reference element\&.
1018               const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1019                                                                   parent_side\&.get(),
1020                                                                   support_point);
1021 
1022               // Compute the parent's side shape function values\&.
1023               for (unsigned int their_side_n=0;
1024                    their_side_n < n_side_nodes;
1025                    their_side_n++)
1026                 {
1027                   libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, parent_side->type()));
1028 
1029                   const Node* their_node = parent_nodes[their_side_n];
1030                   libmesh_assert(their_node);
1031 
1032                   const Real their_value = FEInterface::shape(Dim-1,
1033                                                               fe_type,
1034                                                               parent_side->type(),
1035                                                               their_side_n,
1036                                                               mapped_point);
1037 
1038                   const Real their_mag = std::abs(their_value);
1039 #ifdef DEBUG
1040                   // Protect for the case u_i ~= u_j,
1041                   // in which case i better equal j\&.
1042                   if (their_mag > 0\&.999)
1043                     {
1044                       libmesh_assert_equal_to (my_node, their_node);
1045                       libmesh_assert_less (std::abs(their_value - 1\&.), 0\&.001);
1046                     }
1047                   else
1048 #endif
1049                     // To make nodal constraints useful for constructing
1050                     // sparsity patterns faster, we need to get EVERY
1051                     // POSSIBLE constraint coupling identified, even if
1052                     // there is no coupling in the isoparametric
1053                     // Lagrange case\&.
1054                     if (their_mag < 1\&.e-5)
1055                       {
1056                         // since we may be running this method concurrently
1057                         // on multiple threads we need to acquire a lock
1058                         // before modifying the shared constraint_row object\&.
1059                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1060 
1061                         // A reference to the constraint row\&.
1062                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1063 
1064                         constraint_row\&.insert(std::make_pair (their_node,
1065                                                               0\&.));
1066                       }
1067                   // To get nodal coordinate constraints right, only
1068                   // add non-zero and non-identity values for Lagrange
1069                   // basis functions\&.
1070                     else // (1\&.e-5 <= their_mag <= \&.999)
1071                       {
1072                         // since we may be running this method concurrently
1073                         // on multiple threads we need to acquire a lock
1074                         // before modifying the shared constraint_row object\&.
1075                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1076 
1077                         // A reference to the constraint row\&.
1078                         NodeConstraintRow& constraint_row = constraints[my_node]\&.first;
1079 
1080                         constraint_row\&.insert(std::make_pair (their_node,
1081                                                               their_value));
1082                       }
1083                 }
1084             }
1085         }
1086 }
.fi
.SS "void libMesh::FEAbstract::compute_periodic_node_constraints (\fBNodeConstraints\fP &constraints, const \fBPeriodicBoundaries\fP &boundaries, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP *point_locator, const \fBElem\fP *elem)\fC [static]\fP"
Computes the node position constraint equation contributions (for meshes with periodic boundary conditions) 
.PP
Definition at line 1097 of file fe_abstract\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::Elem::build_side(), libMesh::Elem::default_order(), libMesh::Elem::dim(), fe_type, libMesh::PeriodicBoundaryBase::get_corresponding_pos(), libMesh::invalid_uint, libMesh::FEInterface::inverse_map(), libMesh::LAGRANGE, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::FEInterface::n_dofs(), libMesh::Elem::n_sides(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), libMesh::PeriodicBoundaryBase::pairedboundary, libMesh::Real, libMesh::FEInterface::shape(), and libMesh::Threads::spin_mtx\&.
.PP
.nf
1102 {
1103   // Only bother if we truly have periodic boundaries
1104   if (boundaries\&.empty())
1105     return;
1106 
1107   libmesh_assert(elem);
1108 
1109   // Only constrain active elements with this method
1110   if (!elem->active())
1111     return;
1112 
1113   const unsigned int Dim = elem->dim();
1114 
1115   // We currently always use LAGRANGE mappings for geometry
1116   const FEType fe_type(elem->default_order(), LAGRANGE);
1117 
1118   std::vector<const Node*> my_nodes, neigh_nodes;
1119 
1120   // Look at the element faces\&.  Check to see if we need to
1121   // build constraints\&.
1122   for (unsigned int s=0; s<elem->n_sides(); s++)
1123     {
1124       if (elem->neighbor(s))
1125         continue;
1126 
1127       const std::vector<boundary_id_type>& bc_ids = mesh\&.boundary_info->boundary_ids (elem, s);
1128       for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1129         {
1130           const boundary_id_type boundary_id = *id_it;
1131           const PeriodicBoundaryBase *periodic = boundaries\&.boundary(boundary_id);
1132           if (periodic)
1133             {
1134               libmesh_assert(point_locator);
1135 
1136               // Get pointers to the element's neighbor\&.
1137               const Elem* neigh = boundaries\&.neighbor(boundary_id, *point_locator, elem, s);
1138 
1139               // h refinement constraints:
1140               // constrain dofs shared between
1141               // this element and ones as coarse
1142               // as or coarser than this element\&.
1143               if (neigh->level() <= elem->level())
1144                 {
1145                   unsigned int s_neigh =
1146                     mesh\&.boundary_info->side_with_boundary_id (neigh, periodic->pairedboundary);
1147                   libmesh_assert_not_equal_to (s_neigh, libMesh::invalid_uint);
1148 
1149 #ifdef LIBMESH_ENABLE_AMR
1150                   libmesh_assert(neigh->active());
1151 #endif // #ifdef LIBMESH_ENABLE_AMR
1152 
1153                   const AutoPtr<Elem> my_side    (elem->build_side(s));
1154                   const AutoPtr<Elem> neigh_side (neigh->build_side(s_neigh));
1155 
1156                   const unsigned int n_side_nodes = my_side->n_nodes();
1157 
1158                   my_nodes\&.clear();
1159                   my_nodes\&.reserve (n_side_nodes);
1160                   neigh_nodes\&.clear();
1161                   neigh_nodes\&.reserve (n_side_nodes);
1162 
1163                   for (unsigned int n=0; n != n_side_nodes; ++n)
1164                     my_nodes\&.push_back(my_side->get_node(n));
1165 
1166                   for (unsigned int n=0; n != n_side_nodes; ++n)
1167                     neigh_nodes\&.push_back(neigh_side->get_node(n));
1168 
1169                   // Make sure we're not adding recursive constraints
1170                   // due to the redundancy in the way we add periodic
1171                   // boundary constraints, or adding constraints to
1172                   // nodes that already have AMR constraints
1173                   std::vector<bool> skip_constraint(n_side_nodes, false);
1174 
1175                   for (unsigned int my_side_n=0;
1176                        my_side_n < n_side_nodes;
1177                        my_side_n++)
1178                     {
1179                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1180 
1181                       const Node* my_node = my_nodes[my_side_n];
1182 
1183                       // Figure out where my node lies on their reference element\&.
1184                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1185 
1186                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1187                                                                           neigh_side\&.get(),
1188                                                                           neigh_point);
1189 
1190                       // If we've already got a constraint on this
1191                       // node, then the periodic constraint is
1192                       // redundant
1193                       {
1194                         Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1195 
1196                         if (constraints\&.count(my_node))
1197                           {
1198                             skip_constraint[my_side_n] = true;
1199                             continue;
1200                           }
1201                       }
1202 
1203                       // Compute the neighbors's side shape function values\&.
1204                       for (unsigned int their_side_n=0;
1205                            their_side_n < n_side_nodes;
1206                            their_side_n++)
1207                         {
1208                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1209 
1210                           const Node* their_node = neigh_nodes[their_side_n];
1211 
1212                           // If there's a constraint on an opposing node,
1213                           // we need to see if it's constrained by
1214                           // *our side* making any periodic constraint
1215                           // on us recursive
1216                           {
1217                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1218 
1219                             if (!constraints\&.count(their_node))
1220                               continue;
1221 
1222                             const NodeConstraintRow& their_constraint_row =
1223                               constraints[their_node]\&.first;
1224 
1225                             for (unsigned int orig_side_n=0;
1226                                  orig_side_n < n_side_nodes;
1227                                  orig_side_n++)
1228                               {
1229                                 libmesh_assert_less (orig_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1230 
1231                                 const Node* orig_node = my_nodes[orig_side_n];
1232 
1233                                 if (their_constraint_row\&.count(orig_node))
1234                                   skip_constraint[orig_side_n] = true;
1235                               }
1236                           }
1237                         }
1238                     }
1239                   for (unsigned int my_side_n=0;
1240                        my_side_n < n_side_nodes;
1241                        my_side_n++)
1242                     {
1243                       libmesh_assert_less (my_side_n, FEInterface::n_dofs(Dim-1, fe_type, my_side->type()));
1244 
1245                       if (skip_constraint[my_side_n])
1246                         continue;
1247 
1248                       const Node* my_node = my_nodes[my_side_n];
1249 
1250                       // Figure out where my node lies on their reference element\&.
1251                       const Point neigh_point = periodic->get_corresponding_pos(*my_node);
1252 
1253                       // Figure out where my node lies on their reference element\&.
1254                       const Point mapped_point = FEInterface::inverse_map(Dim-1, fe_type,
1255                                                                           neigh_side\&.get(),
1256                                                                           neigh_point);
1257 
1258                       for (unsigned int their_side_n=0;
1259                            their_side_n < n_side_nodes;
1260                            their_side_n++)
1261                         {
1262                           libmesh_assert_less (their_side_n, FEInterface::n_dofs(Dim-1, fe_type, neigh_side->type()));
1263 
1264                           const Node* their_node = neigh_nodes[their_side_n];
1265                           libmesh_assert(their_node);
1266 
1267                           const Real their_value = FEInterface::shape(Dim-1,
1268                                                                       fe_type,
1269                                                                       neigh_side->type(),
1270                                                                       their_side_n,
1271                                                                       mapped_point);
1272 
1273                           // since we may be running this method concurrently
1274                           // on multiple threads we need to acquire a lock
1275                           // before modifying the shared constraint_row object\&.
1276                           {
1277                             Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
1278 
1279                             NodeConstraintRow& constraint_row =
1280                               constraints[my_node]\&.first;
1281 
1282                             constraint_row\&.insert(std::make_pair(their_node,
1283                                                                  their_value));
1284                           }
1285                         }
1286                     }
1287                 }
1288             }
1289         }
1290     }
1291 }
.fi
.SS "virtual void libMesh::FEAbstract::compute_shape_functions (const \fBElem\fP *, const std::vector< \fBPoint\fP > &)\fC [protected]\fP, \fC [pure virtual]\fP"
After having updated the jacobian and the transformation from local to global coordinates in \fC\fBFEMap::compute_map()\fP\fP, the first derivatives of the shape functions are transformed to global coordinates, giving \fCdphi\fP, \fCdphidx\fP, \fCdphidy\fP, and \fCdphidz\fP\&. This method should rarely be re-defined in derived classes, but still should be usable for children\&. Therefore, keep it protected\&. This needs to be implemented in the derived class since this function depends on whether the shape functions are vector-valued or not\&. 
.PP
Implemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FEGenericBase< T >\fP, and \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "virtual void libMesh::FEAbstract::edge_reinit (const \fBElem\fP *elem, const unsigned intedge, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *pts = \fCNULL\fP, const std::vector< \fBReal\fP > *weights = \fCNULL\fP)\fC [pure virtual]\fP"
Reinitializes all the physical element-dependent data based on the \fCedge\fP of the element \fCelem\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fCinverse_map()\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference \fIedge\fP element may be specified in the optional argument \fCpts\fP\&. 
.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "virtual \fBFEContinuity\fP libMesh::FEAbstract::get_continuity () const\fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the continuity level of the finite element\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.PP
Referenced by libMesh::ProjectFEMSolution::operator()()\&.
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_curvatures () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 380 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
381   { return this->_fe_map->get_curvatures();}
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdeta2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 267 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
268   { return this->_fe_map->get_d2xyzdeta2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdetadzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 297 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
298   { return this->_fe_map->get_d2xyzdetadzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxi2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 261 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
262   { return this->_fe_map->get_d2xyzdxi2(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxideta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 283 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
284   { return this->_fe_map->get_d2xyzdxideta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdxidzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 291 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
292   { return this->_fe_map->get_d2xyzdxidzeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_d2xyzdzeta2 () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 275 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
276   { return this->_fe_map->get_d2xyzdzeta2(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadx () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 327 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
328   { return this->_fe_map->get_detadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detady () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
335   { return this->_fe_map->get_detady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_detadz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 341 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
342   { return this->_fe_map->get_detadz(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidx () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 306 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
307   { return this->_fe_map->get_dxidx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidy () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 313 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
314   { return this->_fe_map->get_dxidy(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dxidz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 320 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
321   { return this->_fe_map->get_dxidz(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 248 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
249   { return this->_fe_map->get_dxyzdeta(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdxi () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 241 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
242   { return this->_fe_map->get_dxyzdxi(); }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEAbstract::get_dxyzdzeta () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 255 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
256   { return _fe_map->get_dxyzdzeta(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadx () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 348 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
349   { return this->_fe_map->get_dzetadx(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetady () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 355 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
356   { return this->_fe_map->get_dzetady(); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_dzetadz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 362 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
363   { return this->_fe_map->get_dzetadz(); }
.fi
.SS "\fBFEFamily\fP libMesh::FEAbstract::get_family () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the finite element family of this element\&. 
.RE
.PP

.PP
Definition at line 439 of file fe_abstract\&.h\&.
.PP
References libMesh::FEType::family, and fe_type\&.
.PP
Referenced by libMesh::FE< Dim, T >::FE()\&.
.PP
.nf
439 { return fe_type\&.family; }
.fi
.SS "const \fBFEMap\fP& libMesh::FEAbstract::get_fe_map () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the mapping object 
.RE
.PP

.PP
Definition at line 444 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
444 { return *_fe_map\&.get(); }
.fi
.SS "\fBFEType\fP libMesh::FEAbstract::get_fe_type () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fBFE\fP Type (approximation order and family) of the finite element\&. 
.RE
.PP

.PP
Definition at line 418 of file fe_abstract\&.h\&.
.PP
References fe_type\&.
.PP
Referenced by libMesh::FEMContext::build_new_fe(), libMesh::H1FETransformation< T >::map_phi(), libMesh::HCurlFETransformation< T >::map_phi(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
418 { return fe_type; }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEAbstract::get_JxW () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 234 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::FEMSystem::init_context(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
235   { return this->_fe_map->get_JxW(); }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_normals () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 374 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
375   { return this->_fe_map->get_normals(); }
.fi
.SS "\fBOrder\fP libMesh::FEAbstract::get_order () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the approximation order of the finite element\&. 
.RE
.PP

.PP
Definition at line 423 of file fe_abstract\&.h\&.
.PP
References _p_level, fe_type, and libMesh::FEType::order\&.
.PP
.nf
423 { return static_cast<Order>(fe_type\&.order + _p_level); }
.fi
.SS "unsigned int libMesh::FEAbstract::get_p_level () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the p refinement level that the current shape functions have been calculated for\&. 
.RE
.PP

.PP
Definition at line 413 of file fe_abstract\&.h\&.
.PP
References _p_level\&.
.PP
.nf
413 { return _p_level; }
.fi
.SS "void libMesh::FEAbstract::get_refspace_nodes (const \fBElemType\fPt, std::vector< \fBPoint\fP > &nodes)\fC [static]\fP"
returns the reference space nodes coordinates given the element type 
.PP
Definition at line 421 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
.nf
422 {
423   switch(itemType)
424     {
425     case EDGE2:
426       {
427         nodes\&.resize(2);
428         nodes[0] = Point (-1\&.,0\&.,0\&.);
429         nodes[1] = Point (1\&.,0\&.,0\&.);
430         return;
431       }
432     case EDGE3:
433       {
434         nodes\&.resize(3);
435         nodes[0] = Point (-1\&.,0\&.,0\&.);
436         nodes[1] = Point (1\&.,0\&.,0\&.);
437         nodes[2] = Point (0\&.,0\&.,0\&.);
438         return;
439       }
440     case TRI3:
441       {
442         nodes\&.resize(3);
443         nodes[0] = Point (0\&.,0\&.,0\&.);
444         nodes[1] = Point (1\&.,0\&.,0\&.);
445         nodes[2] = Point (0\&.,1\&.,0\&.);
446         return;
447       }
448     case TRI6:
449       {
450         nodes\&.resize(6);
451         nodes[0] = Point (0\&.,0\&.,0\&.);
452         nodes[1] = Point (1\&.,0\&.,0\&.);
453         nodes[2] = Point (0\&.,1\&.,0\&.);
454         nodes[3] = Point (\&.5,0\&.,0\&.);
455         nodes[4] = Point (\&.5,\&.5,0\&.);
456         nodes[5] = Point (0\&.,\&.5,0\&.);
457         return;
458       }
459     case QUAD4:
460       {
461         nodes\&.resize(4);
462         nodes[0] = Point (-1\&.,-1\&.,0\&.);
463         nodes[1] = Point (1\&.,-1\&.,0\&.);
464         nodes[2] = Point (1\&.,1\&.,0\&.);
465         nodes[3] = Point (-1\&.,1\&.,0\&.);
466         return;
467       }
468     case QUAD8:
469       {
470         nodes\&.resize(8);
471         nodes[0] = Point (-1\&.,-1\&.,0\&.);
472         nodes[1] = Point (1\&.,-1\&.,0\&.);
473         nodes[2] = Point (1\&.,1\&.,0\&.);
474         nodes[3] = Point (-1\&.,1\&.,0\&.);
475         nodes[4] = Point (0\&.,-1\&.,0\&.);
476         nodes[5] = Point (1\&.,0\&.,0\&.);
477         nodes[6] = Point (0\&.,1\&.,0\&.);
478         nodes[7] = Point (-1\&.,0\&.,0\&.);
479         return;
480       }
481     case QUAD9:
482       {
483         nodes\&.resize(9);
484         nodes[0] = Point (-1\&.,-1\&.,0\&.);
485         nodes[1] = Point (1\&.,-1\&.,0\&.);
486         nodes[2] = Point (1\&.,1\&.,0\&.);
487         nodes[3] = Point (-1\&.,1\&.,0\&.);
488         nodes[4] = Point (0\&.,-1\&.,0\&.);
489         nodes[5] = Point (1\&.,0\&.,0\&.);
490         nodes[6] = Point (0\&.,1\&.,0\&.);
491         nodes[7] = Point (-1\&.,0\&.,0\&.);
492         nodes[8] = Point (0\&.,0\&.,0\&.);
493         return;
494       }
495     case TET4:
496       {
497         nodes\&.resize(4);
498         nodes[0] = Point (0\&.,0\&.,0\&.);
499         nodes[1] = Point (1\&.,0\&.,0\&.);
500         nodes[2] = Point (0\&.,1\&.,0\&.);
501         nodes[3] = Point (0\&.,0\&.,1\&.);
502         return;
503       }
504     case TET10:
505       {
506         nodes\&.resize(10);
507         nodes[0] = Point (0\&.,0\&.,0\&.);
508         nodes[1] = Point (1\&.,0\&.,0\&.);
509         nodes[2] = Point (0\&.,1\&.,0\&.);
510         nodes[3] = Point (0\&.,0\&.,1\&.);
511         nodes[4] = Point (\&.5,0\&.,0\&.);
512         nodes[5] = Point (\&.5,\&.5,0\&.);
513         nodes[6] = Point (0\&.,\&.5,0\&.);
514         nodes[7] = Point (0\&.,0\&.,\&.5);
515         nodes[8] = Point (\&.5,0\&.,\&.5);
516         nodes[9] = Point (0\&.,\&.5,\&.5);
517         return;
518       }
519     case HEX8:
520       {
521         nodes\&.resize(8);
522         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
523         nodes[1] = Point (1\&.,-1\&.,-1\&.);
524         nodes[2] = Point (1\&.,1\&.,-1\&.);
525         nodes[3] = Point (-1\&.,1\&.,-1\&.);
526         nodes[4] = Point (-1\&.,-1\&.,1\&.);
527         nodes[5] = Point (1\&.,-1\&.,1\&.);
528         nodes[6] = Point (1\&.,1\&.,1\&.);
529         nodes[7] = Point (-1\&.,1\&.,1\&.);
530         return;
531       }
532     case HEX20:
533       {
534         nodes\&.resize(20);
535         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
536         nodes[1] = Point (1\&.,-1\&.,-1\&.);
537         nodes[2] = Point (1\&.,1\&.,-1\&.);
538         nodes[3] = Point (-1\&.,1\&.,-1\&.);
539         nodes[4] = Point (-1\&.,-1\&.,1\&.);
540         nodes[5] = Point (1\&.,-1\&.,1\&.);
541         nodes[6] = Point (1\&.,1\&.,1\&.);
542         nodes[7] = Point (-1\&.,1\&.,1\&.);
543         nodes[8] = Point (0\&.,-1\&.,-1\&.);
544         nodes[9] = Point (1\&.,0\&.,-1\&.);
545         nodes[10] = Point (0\&.,1\&.,-1\&.);
546         nodes[11] = Point (-1\&.,0\&.,-1\&.);
547         nodes[12] = Point (-1\&.,-1\&.,0\&.);
548         nodes[13] = Point (1\&.,-1\&.,0\&.);
549         nodes[14] = Point (1\&.,1\&.,0\&.);
550         nodes[15] = Point (-1\&.,1\&.,0\&.);
551         nodes[16] = Point (0\&.,-1\&.,1\&.);
552         nodes[17] = Point (1\&.,0\&.,1\&.);
553         nodes[18] = Point (0\&.,1\&.,1\&.);
554         nodes[19] = Point (-1\&.,0\&.,1\&.);
555         return;
556       }
557     case HEX27:
558       {
559         nodes\&.resize(27);
560         nodes[0] = Point (-1\&.,-1\&.,-1\&.);
561         nodes[1] = Point (1\&.,-1\&.,-1\&.);
562         nodes[2] = Point (1\&.,1\&.,-1\&.);
563         nodes[3] = Point (-1\&.,1\&.,-1\&.);
564         nodes[4] = Point (-1\&.,-1\&.,1\&.);
565         nodes[5] = Point (1\&.,-1\&.,1\&.);
566         nodes[6] = Point (1\&.,1\&.,1\&.);
567         nodes[7] = Point (-1\&.,1\&.,1\&.);
568         nodes[8] = Point (0\&.,-1\&.,-1\&.);
569         nodes[9] = Point (1\&.,0\&.,-1\&.);
570         nodes[10] = Point (0\&.,1\&.,-1\&.);
571         nodes[11] = Point (-1\&.,0\&.,-1\&.);
572         nodes[12] = Point (-1\&.,-1\&.,0\&.);
573         nodes[13] = Point (1\&.,-1\&.,0\&.);
574         nodes[14] = Point (1\&.,1\&.,0\&.);
575         nodes[15] = Point (-1\&.,1\&.,0\&.);
576         nodes[16] = Point (0\&.,-1\&.,1\&.);
577         nodes[17] = Point (1\&.,0\&.,1\&.);
578         nodes[18] = Point (0\&.,1\&.,1\&.);
579         nodes[19] = Point (-1\&.,0\&.,1\&.);
580         nodes[20] = Point (0\&.,0\&.,-1\&.);
581         nodes[21] = Point (0\&.,-1\&.,0\&.);
582         nodes[22] = Point (1\&.,0\&.,0\&.);
583         nodes[23] = Point (0\&.,1\&.,0\&.);
584         nodes[24] = Point (-1\&.,0\&.,0\&.);
585         nodes[25] = Point (0\&.,0\&.,1\&.);
586         nodes[26] = Point (0\&.,0\&.,0\&.);
587         return;
588       }
589     case PRISM6:
590       {
591         nodes\&.resize(6);
592         nodes[0] = Point (0\&.,0\&.,-1\&.);
593         nodes[1] = Point (1\&.,0\&.,-1\&.);
594         nodes[2] = Point (0\&.,1\&.,-1\&.);
595         nodes[3] = Point (0\&.,0\&.,1\&.);
596         nodes[4] = Point (1\&.,0\&.,1\&.);
597         nodes[5] = Point (0\&.,1\&.,1\&.);
598         return;
599       }
600     case PRISM15:
601       {
602         nodes\&.resize(15);
603         nodes[0] = Point (0\&.,0\&.,-1\&.);
604         nodes[1] = Point (1\&.,0\&.,-1\&.);
605         nodes[2] = Point (0\&.,1\&.,-1\&.);
606         nodes[3] = Point (0\&.,0\&.,1\&.);
607         nodes[4] = Point (1\&.,0\&.,1\&.);
608         nodes[5] = Point (0\&.,1\&.,1\&.);
609         nodes[6] = Point (\&.5,0\&.,-1\&.);
610         nodes[7] = Point (\&.5,\&.5,-1\&.);
611         nodes[8] = Point (0\&.,\&.5,-1\&.);
612         nodes[9] = Point (0\&.,0\&.,0\&.);
613         nodes[10] = Point (1\&.,0\&.,0\&.);
614         nodes[11] = Point (0\&.,1\&.,0\&.);
615         nodes[12] = Point (\&.5,0\&.,1\&.);
616         nodes[13] = Point (\&.5,\&.5,1\&.);
617         nodes[14] = Point (0\&.,\&.5,1\&.);
618         return;
619       }
620     case PRISM18:
621       {
622         nodes\&.resize(18);
623         nodes[0] = Point (0\&.,0\&.,-1\&.);
624         nodes[1] = Point (1\&.,0\&.,-1\&.);
625         nodes[2] = Point (0\&.,1\&.,-1\&.);
626         nodes[3] = Point (0\&.,0\&.,1\&.);
627         nodes[4] = Point (1\&.,0\&.,1\&.);
628         nodes[5] = Point (0\&.,1\&.,1\&.);
629         nodes[6] = Point (\&.5,0\&.,-1\&.);
630         nodes[7] = Point (\&.5,\&.5,-1\&.);
631         nodes[8] = Point (0\&.,\&.5,-1\&.);
632         nodes[9] = Point (0\&.,0\&.,0\&.);
633         nodes[10] = Point (1\&.,0\&.,0\&.);
634         nodes[11] = Point (0\&.,1\&.,0\&.);
635         nodes[12] = Point (\&.5,0\&.,1\&.);
636         nodes[13] = Point (\&.5,\&.5,1\&.);
637         nodes[14] = Point (0\&.,\&.5,1\&.);
638         nodes[15] = Point (\&.5,0\&.,0\&.);
639         nodes[16] = Point (\&.5,\&.5,0\&.);
640         nodes[17] = Point (0\&.,\&.5,0\&.);
641         return;
642       }
643     case PYRAMID5:
644       {
645         nodes\&.resize(5);
646         nodes[0] = Point (-1\&.,-1\&.,0\&.);
647         nodes[1] = Point (1\&.,-1\&.,0\&.);
648         nodes[2] = Point (1\&.,1\&.,0\&.);
649         nodes[3] = Point (-1\&.,1\&.,0\&.);
650         nodes[4] = Point (0\&.,0\&.,1\&.);
651         return;
652       }
653     case PYRAMID13:
654       {
655         nodes\&.resize(13);
656 
657         // base corners
658         nodes[0] = Point (-1\&.,-1\&.,0\&.);
659         nodes[1] = Point (1\&.,-1\&.,0\&.);
660         nodes[2] = Point (1\&.,1\&.,0\&.);
661         nodes[3] = Point (-1\&.,1\&.,0\&.);
662 
663         // apex
664         nodes[4] = Point (0\&.,0\&.,1\&.);
665 
666         // base midedge
667         nodes[5] = Point (0\&.,-1\&.,0\&.);
668         nodes[6] = Point (1\&.,0\&.,0\&.);
669         nodes[7] = Point (0\&.,1\&.,0\&.);
670         nodes[8] = Point (-1,0\&.,0\&.);
671 
672         // lateral midedge
673         nodes[9] = Point (-\&.5,-\&.5,\&.5);
674         nodes[10] = Point (\&.5,-\&.5,\&.5);
675         nodes[11] = Point (\&.5,\&.5,\&.5);
676         nodes[12] = Point (-\&.5,\&.5,\&.5);
677 
678         return;
679       }
680     case PYRAMID14:
681       {
682         nodes\&.resize(14);
683 
684         // base corners
685         nodes[0] = Point (-1\&.,-1\&.,0\&.);
686         nodes[1] = Point (1\&.,-1\&.,0\&.);
687         nodes[2] = Point (1\&.,1\&.,0\&.);
688         nodes[3] = Point (-1\&.,1\&.,0\&.);
689 
690         // apex
691         nodes[4] = Point (0\&.,0\&.,1\&.);
692 
693         // base midedge
694         nodes[5] = Point (0\&.,-1\&.,0\&.);
695         nodes[6] = Point (1\&.,0\&.,0\&.);
696         nodes[7] = Point (0\&.,1\&.,0\&.);
697         nodes[8] = Point (-1,0\&.,0\&.);
698 
699         // lateral midedge
700         nodes[9] = Point (-\&.5,-\&.5,\&.5);
701         nodes[10] = Point (\&.5,-\&.5,\&.5);
702         nodes[11] = Point (\&.5,\&.5,\&.5);
703         nodes[12] = Point (-\&.5,\&.5,\&.5);
704 
705         // base center
706         nodes[13] = Point (0\&.,0\&.,0\&.);
707 
708         return;
709       }
710     default:
711       {
712         libMesh::err << "ERROR: Unknown element type " << itemType << std::endl;
713         libmesh_error();
714       }
715     }
716   return;
717 }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEAbstract::get_tangents () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 368 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
.nf
369   { return this->_fe_map->get_tangents(); }
.fi
.SS "\fBElemType\fP libMesh::FEAbstract::get_type () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type that the current shape functions have been calculated for\&. Useful in determining when shape functions must be recomputed\&. 
.RE
.PP

.PP
Definition at line 407 of file fe_abstract\&.h\&.
.PP
References elem_type\&.
.PP
.nf
407 { return elem_type; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEAbstract::get_xyz () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 227 of file fe_abstract\&.h\&.
.PP
References _fe_map\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error(), libMesh::DGFEMContext::neighbor_side_fe_reinit(), and libMesh::ProjectFEMSolution::operator()()\&.
.PP
.nf
228   { return this->_fe_map->get_xyz(); }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "virtual bool libMesh::FEAbstract::is_hierarchic () const\fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the finite element's higher order shape functions are hierarchic 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "virtual unsigned int libMesh::FEAbstract::n_quadrature_points () const\fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of quadrature points\&. Useful during matrix assembly\&. Implement this in derived classes\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "virtual unsigned int libMesh::FEAbstract::n_shape_functions () const\fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the total number of approximation shape functions for the current element\&. Useful during matrix assembly\&. Implement this in derived classes\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SS "bool libMesh::FEAbstract::on_reference_element (const \fBPoint\fP &p, const \fBElemType\fPt, const \fBReal\fPeps = \fC\fBTOLERANCE\fP\fP)\fC [static]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is located on the reference element for element type t, false otherwise\&. Since we are doing floating point comparisons here the parameter \fCeps\fP can be specified to indicate a tolerance\&. For example, $ x \le 1 $ becomes $ x \le 1 + \epsilon $\&. 
.RE
.PP

.PP
Definition at line 719 of file fe_abstract\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX8, libMesh::INFPRISM6, libMesh::NODEELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::Real, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::FEInterface::ifem_on_reference_element(), libMesh::FE< Dim, T >::inverse_map(), and libMesh::FEInterface::on_reference_element()\&.
.PP
.nf
720 {
721   libmesh_assert_greater_equal (eps, 0\&.);
722 
723   const Real xi   = p(0);
724 #if LIBMESH_DIM > 1
725   const Real eta  = p(1);
726 #else
727   const Real eta  = 0\&.;
728 #endif
729 #if LIBMESH_DIM > 2
730   const Real zeta = p(2);
731 #else
732   const Real zeta  = 0\&.;
733 #endif
734 
735   switch (t)
736     {
737     case NODEELEM:
738       {
739         return (!xi && !eta && !zeta);
740       }
741     case EDGE2:
742     case EDGE3:
743     case EDGE4:
744       {
745         // The reference 1D element is [-1,1]\&.
746         if ((xi >= -1\&.-eps) &&
747             (xi <=  1\&.+eps))
748           return true;
749 
750         return false;
751       }
752 
753 
754     case TRI3:
755     case TRI6:
756       {
757         // The reference triangle is isocoles
758         // and is bound by xi=0, eta=0, and xi+eta=1\&.
759         if ((xi  >= 0\&.-eps) &&
760             (eta >= 0\&.-eps) &&
761             ((xi + eta) <= 1\&.+eps))
762           return true;
763 
764         return false;
765       }
766 
767 
768     case QUAD4:
769     case QUAD8:
770     case QUAD9:
771       {
772         // The reference quadrilateral element is [-1,1]^2\&.
773         if ((xi  >= -1\&.-eps) &&
774             (xi  <=  1\&.+eps) &&
775             (eta >= -1\&.-eps) &&
776             (eta <=  1\&.+eps))
777           return true;
778 
779         return false;
780       }
781 
782 
783     case TET4:
784     case TET10:
785       {
786         // The reference tetrahedral is isocoles
787         // and is bound by xi=0, eta=0, zeta=0,
788         // and xi+eta+zeta=1\&.
789         if ((xi   >= 0\&.-eps) &&
790             (eta  >= 0\&.-eps) &&
791             (zeta >= 0\&.-eps) &&
792             ((xi + eta + zeta) <= 1\&.+eps))
793           return true;
794 
795         return false;
796       }
797 
798 
799     case HEX8:
800     case HEX20:
801     case HEX27:
802       {
803         /*
804           if ((xi   >= -1\&.) &&
805           (xi   <=  1\&.) &&
806           (eta  >= -1\&.) &&
807           (eta  <=  1\&.) &&
808           (zeta >= -1\&.) &&
809           (zeta <=  1\&.))
810           return true;
811         */
812 
813         // The reference hexahedral element is [-1,1]^3\&.
814         if ((xi   >= -1\&.-eps) &&
815             (xi   <=  1\&.+eps) &&
816             (eta  >= -1\&.-eps) &&
817             (eta  <=  1\&.+eps) &&
818             (zeta >= -1\&.-eps) &&
819             (zeta <=  1\&.+eps))
820           {
821             //    libMesh::out << "Strange Point:\n";
822             //    p\&.print();
823             return true;
824           }
825 
826         return false;
827       }
828 
829     case PRISM6:
830     case PRISM15:
831     case PRISM18:
832       {
833         // Figure this one out\&.\&.\&.
834         // inside the reference triange with zeta in [-1,1]
835         if ((xi   >=  0\&.-eps) &&
836             (eta  >=  0\&.-eps) &&
837             (zeta >= -1\&.-eps) &&
838             (zeta <=  1\&.+eps) &&
839             ((xi + eta) <= 1\&.+eps))
840           return true;
841 
842         return false;
843       }
844 
845 
846     case PYRAMID5:
847     case PYRAMID13:
848     case PYRAMID14:
849       {
850         // Check that the point is on the same side of all the faces
851         // by testing whether:
852         //
853         // n_i\&.(x - x_i) <= 0
854         //
855         // for each i, where:
856         //   n_i is the outward normal of face i,
857         //   x_i is a point on face i\&.
858         if ((-eta - 1\&. + zeta <= 0\&.+eps) &&
859             (  xi - 1\&. + zeta <= 0\&.+eps) &&
860             ( eta - 1\&. + zeta <= 0\&.+eps) &&
861             ( -xi - 1\&. + zeta <= 0\&.+eps) &&
862             (            zeta >= 0\&.-eps))
863           return true;
864 
865         return false;
866       }
867 
868 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
869     case INFHEX8:
870       {
871         // The reference infhex8 is a [-1,1]^3\&.
872         if ((xi   >= -1\&.-eps) &&
873             (xi   <=  1\&.+eps) &&
874             (eta  >= -1\&.-eps) &&
875             (eta  <=  1\&.+eps) &&
876             (zeta >= -1\&.-eps) &&
877             (zeta <=  1\&.+eps))
878           {
879             return true;
880           }
881         return false;
882       }
883 
884     case INFPRISM6:
885       {
886         // inside the reference triange with zeta in [-1,1]
887         if ((xi   >=  0\&.-eps) &&
888             (eta  >=  0\&.-eps) &&
889             (zeta >= -1\&.-eps) &&
890             (zeta <=  1\&.+eps) &&
891             ((xi + eta) <= 1\&.+eps))
892           {
893             return true;
894           }
895 
896         return false;
897       }
898 #endif
899 
900     default:
901       libMesh::err << "ERROR: Unknown element type " << t << std::endl;
902       libmesh_error();
903     }
904 
905   // If we get here then the point is _not_ in the
906   // reference element\&.   Better return false\&.
907 
908   return false;
909 }
.fi
.SS "virtual void libMesh::FEAbstract::print_d2phi (std::ostream &os) const\fC [pure virtual]\fP"
Prints the value of each shape function's second derivatives at each quadrature point\&. Implement in derived class since this depends on whether the element is vector-valued or not\&. 
.PP
Implemented in \fBlibMesh::FEGenericBase< T >\fP, and \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.SS "virtual void libMesh::FEAbstract::print_dphi (std::ostream &os) const\fC [pure virtual]\fP"
Prints the value of each shape function's derivative at each quadrature point\&. Implement in derived class since this depends on whether the element is vector-valued or not\&. 
.PP
Implemented in \fBlibMesh::FEGenericBase< T >\fP, and \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.PP
Referenced by print_info()\&.
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::FEAbstract::print_info (std::ostream &os) const"
Prints all the relevant information about the current element\&. 
.PP
Definition at line 927 of file fe_abstract\&.C\&.
.PP
References print_dphi(), print_JxW(), print_phi(), and print_xyz()\&.
.PP
Referenced by libMesh::operator<<()\&.
.PP
.nf
928 {
929   os << "phi[i][j]: Shape function i at quadrature pt\&. j" << std::endl;
930   this->print_phi(os);
931 
932   os << "dphi[i][j]: Shape function i's gradient at quadrature pt\&. j" << std::endl;
933   this->print_dphi(os);
934 
935   os << "XYZ locations of the quadrature pts\&." << std::endl;
936   this->print_xyz(os);
937 
938   os << "Values of JxW at the quadrature pts\&." << std::endl;
939   this->print_JxW(os);
940 }
.fi
.SS "void libMesh::FEAbstract::print_JxW (std::ostream &os) const"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 914 of file fe_abstract\&.C\&.
.PP
References _fe_map\&.
.PP
Referenced by print_info()\&.
.PP
.nf
915 {
916   this->_fe_map->print_JxW(os);
917 }
.fi
.SS "virtual void libMesh::FEAbstract::print_phi (std::ostream &os) const\fC [pure virtual]\fP"
Prints the value of each shape function at each quadrature point\&. Implement in derived class since this depends on whether the element is vector-valued or not\&. 
.PP
Implemented in \fBlibMesh::FEGenericBase< T >\fP, and \fBlibMesh::FEGenericBase< FEOutputType< T >::type >\fP\&.
.PP
Referenced by print_info()\&.
.SS "void libMesh::FEAbstract::print_xyz (std::ostream &os) const"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 921 of file fe_abstract\&.C\&.
.PP
References _fe_map\&.
.PP
Referenced by print_info()\&.
.PP
.nf
922 {
923   this->_fe_map->print_xyz(os);
924 }
.fi
.SS "virtual void libMesh::FEAbstract::reinit (const \fBElem\fP *elem, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [pure virtual]\fP"
This is at the core of this class\&. Use this for each new element in the mesh\&. Reinitializes the requested physical element-dependent data based on the current element \fCelem\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference element may be specified in the optional argument \fCpts\fP\&.
.PP
Note that the \fBFE\fP classes decide which data to initialize based on which accessor functions such as \fCget_phi()\fP or \fCget_d2phi()\fP have been called, so all such accessors should be called before the first \fC\fBreinit()\fP\fP\&. 
.PP
Implemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.PP
Referenced by libMesh::ExactErrorEstimator::find_squared_element_error()\&.
.SS "virtual void libMesh::FEAbstract::reinit (const \fBElem\fP *elem, const unsigned intside, const \fBReal\fPtolerance = \fC\fBTOLERANCE\fP\fP, const std::vector< \fBPoint\fP > *constpts = \fCNULL\fP, const std::vector< \fBReal\fP > *constweights = \fCNULL\fP)\fC [pure virtual]\fP"
Reinitializes all the physical element-dependent data based on the \fCside\fP of the element \fCelem\fP\&. The \fCtolerance\fP paremeter is passed to the involved call to \fCinverse_map()\fP\&. By default the element data are computed at the quadrature points specified by the quadrature rule \fCqrule\fP, but any set of points on the reference \fIside\fP element may be specified in the optional argument \fCpts\fP\&. 
.PP
Implemented in \fBlibMesh::FEXYZ< Dim >\fP, \fBlibMesh::FESubdivision\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FEXYZ< Dim >\fP, and \fBlibMesh::FEXYZ< Dim >\fP\&.
.SS "virtual bool libMesh::FEAbstract::shapes_need_reinit () const\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP when the shape functions (for this \fCFEFamily\fP) depend on the particular element, and therefore needs to be re-initialized for each new element\&. \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< Dim, T >\fP, and \fBlibMesh::FE< Dim, T >\fP\&.
.SS "virtual void libMesh::FEAbstract::side_map (const \fBElem\fP *elem, const \fBElem\fP *side, const unsigned ints, const std::vector< \fBPoint\fP > &reference_side_points, std::vector< \fBPoint\fP > &reference_points)\fC [pure virtual]\fP"
Computes the reference space quadrature points on the side of an element based on the side quadrature points\&. 
.PP
Implemented in \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >\fP, \fBlibMesh::FE< Dim, T >\fP, \fBlibMesh::FE< 2, SUBDIVISION >\fP, \fBlibMesh::FE< Dim, HIERARCHIC >\fP, \fBlibMesh::FE< Dim, SCALAR >\fP, \fBlibMesh::FE< Dim, L2_LAGRANGE >\fP, \fBlibMesh::FE< Dim, NEDELEC_ONE >\fP, \fBlibMesh::FE< Dim, HERMITE >\fP, \fBlibMesh::FE< Dim, CLOUGH >\fP, \fBlibMesh::FE< Dim, MONOMIAL >\fP, \fBlibMesh::FE< Dim, XYZ >\fP, \fBlibMesh::FE< Dim, LAGRANGE >\fP, \fBlibMesh::FE< Dim, L2_HIERARCHIC >\fP, and \fBlibMesh::FE< Dim, LAGRANGE_VEC >\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "std::ostream& operator<< (std::ostream &os, const \fBFEAbstract\fP &fe)\fC [friend]\fP"
Same as above, but allows you to print to a stream\&. 
.PP
Definition at line 943 of file fe_abstract\&.C\&.
.PP
.nf
944 {
945   fe\&.print_info(os);
946   return os;
947 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBFEMap\fP> libMesh::FEAbstract::_fe_map\fC [protected]\fP"

.PP
Definition at line 509 of file fe_abstract\&.h\&.
.PP
Referenced by get_curvatures(), get_d2xyzdeta2(), get_d2xyzdetadzeta(), get_d2xyzdxi2(), get_d2xyzdxideta(), get_d2xyzdxidzeta(), get_d2xyzdzeta2(), get_detadx(), get_detady(), get_detadz(), get_dxidx(), get_dxidy(), get_dxidz(), get_dxyzdeta(), get_dxyzdxi(), get_dxyzdzeta(), get_dzetadx(), get_dzetady(), get_dzetadz(), get_fe_map(), get_JxW(), get_normals(), get_tangents(), get_xyz(), libMesh::FESubdivision::init_shape_functions(), print_JxW(), print_xyz(), and libMesh::FESubdivision::reinit()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "unsigned int libMesh::FEAbstract::_p_level\fC [protected]\fP"
The p refinement level the current data structures are set up for\&. 
.PP
Definition at line 570 of file fe_abstract\&.h\&.
.PP
Referenced by get_order(), and get_p_level()\&.
.SS "bool libMesh::FEAbstract::calculate_curl_phi\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate shape function curls? 
.PP
Definition at line 541 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_d2phi\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate shape function hessians? 
.PP
Definition at line 536 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_div_phi\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate shape function divergences? 
.PP
Definition at line 546 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi()\&.
.SS "bool libMesh::FEAbstract::calculate_dphi\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate shape function gradients? 
.PP
Definition at line 531 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculate_dphiref\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate reference shape function gradients? 
.PP
Definition at line 551 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), and libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta()\&.
.SS "bool libMesh::FEAbstract::calculate_phi\fC [mutable]\fP, \fC [protected]\fP"
Should we calculate shape functions? 
.PP
Definition at line 526 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "bool libMesh::FEAbstract::calculations_started\fC [mutable]\fP, \fC [protected]\fP"
Have calculations with this object already been started? Then all get_* functions should already have been called\&. 
.PP
Definition at line 521 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FEGenericBase< FEOutputType< T >::type >::get_curl_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phideta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidetadzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidx2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxdz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxi2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidxidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidy2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidydz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidz2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_d2phidzeta2(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_div_phi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphideta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidx(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidxi(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidy(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidz(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_dphidzeta(), libMesh::FEGenericBase< FEOutputType< T >::type >::get_phi(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "const unsigned int libMesh::FEAbstract::dim\fC [protected]\fP"
The dimensionality of the object 
.PP
Definition at line 515 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.
.SS "\fBElemType\fP libMesh::FEAbstract::elem_type\fC [protected]\fP"
The element type the current data structures are set up for\&. 
.PP
Definition at line 564 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and get_type()\&.
.SS "const \fBFEType\fP libMesh::FEAbstract::fe_type\fC [protected]\fP"
The finite element type for this object\&. Note that this should be constant for the object\&. 
.PP
Definition at line 558 of file fe_abstract\&.h\&.
.PP
Referenced by compute_node_constraints(), compute_periodic_node_constraints(), get_family(), get_fe_type(), get_order(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::InfFE(), and libMesh::FESubdivision::init_shape_functions()\&.
.SS "\fBQBase\fP* libMesh::FEAbstract::qrule\fC [protected]\fP"
A pointer to the quadrature rule employed 
.PP
Definition at line 575 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::attach_quadrature_rule(), and libMesh::FESubdivision::reinit()\&.
.SS "bool libMesh::FEAbstract::shapes_on_quadrature\fC [protected]\fP"
A flag indicating if current data structures correspond to quadrature rule points 
.PP
Definition at line 581 of file fe_abstract\&.h\&.
.PP
Referenced by libMesh::FESubdivision::reinit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
