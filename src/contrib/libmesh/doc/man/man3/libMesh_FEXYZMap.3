.TH "libMesh::FEXYZMap" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::FEXYZMap \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <fe_xyz_map\&.h>\fP
.PP
Inherits \fBlibMesh::FEMap\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBFEXYZMap\fP ()"
.br
.ti -1c
.RI "virtual \fB~FEXYZMap\fP ()"
.br
.ti -1c
.RI "virtual void \fBcompute_face_map\fP (int \fBdim\fP, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *\fBside\fP)"
.br
.ti -1c
.RI "template<unsigned int Dim> void \fBinit_reference_to_physical_map\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "void \fBcompute_single_point_map\fP (const unsigned int \fBdim\fP, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem, unsigned int p, const std::vector< \fBNode\fP * > &elem_nodes)"
.br
.ti -1c
.RI "virtual void \fBcompute_affine_map\fP (const unsigned int \fBdim\fP, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "virtual void \fBcompute_map\fP (const unsigned int \fBdim\fP, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem)"
.br
.ti -1c
.RI "void \fBcompute_edge_map\fP (int \fBdim\fP, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *\fBside\fP)"
.br
.ti -1c
.RI "template<unsigned int Dim> void \fBinit_face_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *\fBside\fP)"
.br
.ti -1c
.RI "template<unsigned int Dim> void \fBinit_edge_shape_functions\fP (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *edge)"
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_xyz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_jacobian\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_JxW\fP () const "
.br
.ti -1c
.RI "std::vector< \fBReal\fP > & \fBget_JxW\fP ()"
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdxi\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_dxyzdzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxi2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdzeta2\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxideta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdxidzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBRealGradient\fP > & \fBget_d2xyzdetadzeta\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidy\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dxidz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_detadz\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadx\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetady\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_dzetadz\fP () const "
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBReal\fP > > & \fBget_psi\fP () const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_psi\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBReal\fP > > & \fBget_phi_map\fP () const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_phi_map\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBReal\fP > > & \fBget_dphidxi_map\fP () const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_dphidxi_map\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBReal\fP > > & \fBget_dphideta_map\fP () const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_dphideta_map\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBReal\fP > > & \fBget_dphidzeta_map\fP () const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_dphidzeta_map\fP ()"
.br
.ti -1c
.RI "const std::vector< std::vector
.br
< \fBPoint\fP > > & \fBget_tangents\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBPoint\fP > & \fBget_normals\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBReal\fP > & \fBget_curvatures\fP () const "
.br
.ti -1c
.RI "void \fBprint_JxW\fP (std::ostream &os) const "
.br
.ti -1c
.RI "void \fBprint_xyz\fP (std::ostream &os) const "
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_dpsidxi\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_dpsideta\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2psidxi2\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2psidxideta\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2psideta2\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phidxi2_map\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phidxideta_map\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phidxidzeta_map\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phideta2_map\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phidetadzeta_map\fP ()"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > & \fBget_d2phidzeta2_map\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBAutoPtr\fP< \fBFEMap\fP > \fBbuild\fP (\fBFEType\fP fe_type)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBresize_quadrature_map_vectors\fP (const unsigned int \fBdim\fP, unsigned int n_qp)"
.br
.ti -1c
.RI "\fBReal\fP \fBdxdxi_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdydxi_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdzdxi_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdxdeta_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdydeta_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdzdeta_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdxdzeta_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdydzeta_map\fP (const unsigned int p) const "
.br
.ti -1c
.RI "\fBReal\fP \fBdzdzeta_map\fP (const unsigned int p) const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBPoint\fP > \fBxyz\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdxyzdxi_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdxyzdeta_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBdxyzdzeta_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdxi2_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdxideta_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdeta2_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdxidzeta_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdetadzeta_map\fP"
.br
.ti -1c
.RI "std::vector< \fBRealGradient\fP > \fBd2xyzdzeta2_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdxidx_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdxidy_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdxidz_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdetadx_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdetady_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdetadz_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdzetadx_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdzetady_map\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBdzetadz_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBphi_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdphidxi_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdphideta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdphidzeta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phidxi2_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phidxideta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phidxidzeta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phideta2_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phidetadzeta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2phidzeta2_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBpsi_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdpsidxi_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBdpsideta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2psidxi2_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2psidxideta_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBReal\fP > > \fBd2psideta2_map\fP"
.br
.ti -1c
.RI "std::vector< std::vector< \fBPoint\fP > > \fBtangents\fP"
.br
.ti -1c
.RI "std::vector< \fBPoint\fP > \fBnormals\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBcurvatures\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBjac\fP"
.br
.ti -1c
.RI "std::vector< \fBReal\fP > \fBJxW\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 30 of file fe_xyz_map\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::FEXYZMap::FEXYZMap ()\fC [inline]\fP"

.PP
Definition at line 34 of file fe_xyz_map\&.h\&.
.PP
.nf
35     : FEMap(){}
.fi
.SS "virtual libMesh::FEXYZMap::~FEXYZMap ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Definition at line 37 of file fe_xyz_map\&.h\&.
.PP
.nf
37 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBAutoPtr\fP< \fBFEMap\fP > libMesh::FEMap::build (\fBFEType\fPfe_type)\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 42 of file fe_map\&.C\&.
.PP
References libMesh::FEType::family, and libMesh::XYZ\&.
.PP
.nf
43 {
44   switch( fe_type\&.family )
45     {
46     case XYZ:
47       {
48         AutoPtr<FEMap> ap( new FEXYZMap );
49         return ap;
50       }
51     default:
52       {
53         AutoPtr<FEMap> ap( new FEMap );
54         return ap;
55       }
56     }
57 
58   //Shouldn't ever get here
59   libmesh_error();
60   return AutoPtr<FEMap>();
61 }
.fi
.SS "void libMesh::FEMap::compute_affine_map (const unsigned intdim, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem)\fC [virtual]\fP, \fC [inherited]\fP"
Compute the jacobian and some other additional data fields\&. Takes the integration weights as input, along with a pointer to the element\&. The element is assumed to have a constant Jacobian 
.PP
Definition at line 723 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::d2xyzdeta2_map, libMesh::FEMap::d2xyzdetadzeta_map, libMesh::FEMap::d2xyzdxi2_map, libMesh::FEMap::d2xyzdxideta_map, libMesh::FEMap::d2xyzdxidzeta_map, libMesh::FEMap::d2xyzdzeta2_map, libMesh::FEMap::detadx_map, libMesh::FEMap::detady_map, libMesh::FEMap::detadz_map, libMesh::FEMap::dxidx_map, libMesh::FEMap::dxidy_map, libMesh::FEMap::dxidz_map, libMesh::FEMap::dxyzdeta_map, libMesh::FEMap::dxyzdxi_map, libMesh::FEMap::dxyzdzeta_map, libMesh::FEMap::dzetadx_map, libMesh::FEMap::dzetady_map, libMesh::FEMap::dzetadz_map, libMesh::Elem::get_node(), libMesh::FEMap::jac, libMesh::FEMap::JxW, libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::FEMap::phi_map, libMesh::FEMap::resize_quadrature_map_vectors(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::FEMap::xyz\&.
.PP
Referenced by libMesh::FEMap::compute_map()\&.
.PP
.nf
726 {
727   // Start logging the map computation\&.
728   START_LOG("compute_affine_map()", "FEMap");
729 
730   libmesh_assert(elem);
731 
732   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qw\&.size());
733 
734   // Resize the vectors to hold data at the quadrature points
735   this->resize_quadrature_map_vectors(dim, n_qp);
736 
737   // Determine the nodes contributing to element elem
738   std::vector<Node*> elem_nodes(elem->n_nodes(), NULL);
739   for (unsigned int i=0; i<elem->n_nodes(); i++)
740     elem_nodes[i] = elem->get_node(i);
741 
742   // Compute map at quadrature point 0
743   this->compute_single_point_map(dim, qw, elem, 0, elem_nodes);
744 
745   // Compute xyz at all other quadrature points
746   for (unsigned int p=1; p<n_qp; p++)
747     {
748       xyz[p]\&.zero();
749       for (unsigned int i=0; i<phi_map\&.size(); i++) // sum over the nodes
750         xyz[p]\&.add_scaled        (*elem_nodes[i], phi_map[i][p]    );
751     }
752 
753   // Copy other map data from quadrature point 0
754   for (unsigned int p=1; p<n_qp; p++) // for each extra quadrature point
755     {
756       dxyzdxi_map[p] = dxyzdxi_map[0];
757       dxidx_map[p] = dxidx_map[0];
758       dxidy_map[p] = dxidy_map[0];
759       dxidz_map[p] = dxidz_map[0];
760 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
761       // The map should be affine, so second derivatives are zero
762       d2xyzdxi2_map[p] = 0\&.;
763 #endif
764       if (dim > 1)
765         {
766           dxyzdeta_map[p] = dxyzdeta_map[0];
767           detadx_map[p] = detadx_map[0];
768           detady_map[p] = detady_map[0];
769           detadz_map[p] = detadz_map[0];
770 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
771           d2xyzdxideta_map[p] = 0\&.;
772           d2xyzdeta2_map[p] = 0\&.;
773 #endif
774           if (dim > 2)
775             {
776               dxyzdzeta_map[p] = dxyzdzeta_map[0];
777               dzetadx_map[p] = dzetadx_map[0];
778               dzetady_map[p] = dzetady_map[0];
779               dzetadz_map[p] = dzetadz_map[0];
780 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
781               d2xyzdxidzeta_map[p] = 0\&.;
782               d2xyzdetadzeta_map[p] = 0\&.;
783               d2xyzdzeta2_map[p] = 0\&.;
784 #endif
785             }
786         }
787       jac[p] = jac[0];
788       JxW[p] = JxW[0] / qw[0] * qw[p];
789     }
790 
791   STOP_LOG("compute_affine_map()", "FEMap");
792 }
.fi
.SS "void libMesh::FEMap::compute_edge_map (intdim, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *side)\fC [inherited]\fP"
Same as before, but for an edge\&. Useful for some projections\&. 
.PP
Definition at line 807 of file fe_boundary\&.C\&.
.PP
References libMesh::FEMap::compute_face_map(), libMesh::FEMap::curvatures, libMesh::FEMap::d2psidxi2_map, libMesh::FEMap::d2xyzdeta2_map, libMesh::FEMap::d2xyzdxi2_map, libMesh::FEMap::d2xyzdxideta_map, libMesh::FEMap::dpsidxi_map, libMesh::FEMap::dxdxi_map(), libMesh::FEMap::dxyzdeta_map, libMesh::FEMap::dxyzdxi_map, libMesh::FEMap::dydxi_map(), libMesh::FEMap::dzdxi_map(), libMesh::FEMap::JxW, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::FEMap::normals, libMesh::Elem::point(), libMesh::FEMap::psi_map, libMesh::Real, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::FEMap::tangents, and libMesh::FEMap::xyz\&.
.PP
.nf
810 {
811   libmesh_assert(edge);
812 
813   if (dim == 2)
814     {
815       // A 2D finite element living in either 2D or 3D space\&.
816       // The edges here are the sides of the element, so the
817       // (misnamed) compute_face_map function does what we want
818       this->compute_face_map(dim, qw, edge);
819       return;
820     }
821 
822   libmesh_assert_equal_to (dim, 3);  // 1D is unnecessary and currently unsupported
823 
824   START_LOG("compute_edge_map()", "FEMap");
825 
826   // The number of quadrature points\&.
827   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qw\&.size());
828 
829   // Resize the vectors to hold data at the quadrature points
830   this->xyz\&.resize(n_qp);
831   this->dxyzdxi_map\&.resize(n_qp);
832   this->dxyzdeta_map\&.resize(n_qp);
833   this->d2xyzdxi2_map\&.resize(n_qp);
834   this->d2xyzdxideta_map\&.resize(n_qp);
835   this->d2xyzdeta2_map\&.resize(n_qp);
836   this->tangents\&.resize(n_qp);
837   this->normals\&.resize(n_qp);
838   this->curvatures\&.resize(n_qp);
839 
840   this->JxW\&.resize(n_qp);
841 
842   // Clear the entities that will be summed
843   for (unsigned int p=0; p<n_qp; p++)
844     {
845       this->tangents[p]\&.resize(1);
846       this->xyz[p]\&.zero();
847       this->dxyzdxi_map[p]\&.zero();
848       this->dxyzdeta_map[p]\&.zero();
849       this->d2xyzdxi2_map[p]\&.zero();
850       this->d2xyzdxideta_map[p]\&.zero();
851       this->d2xyzdeta2_map[p]\&.zero();
852     }
853 
854   // compute x, dxdxi at the quadrature points
855   for (unsigned int i=0; i<this->psi_map\&.size(); i++) // sum over the nodes
856     {
857       const Point& edge_point = edge->point(i);
858 
859       for (unsigned int p=0; p<n_qp; p++) // for each quadrature point\&.\&.\&.
860         {
861           this->xyz[p]\&.add_scaled             (edge_point, this->psi_map[i][p]);
862           this->dxyzdxi_map[p]\&.add_scaled     (edge_point, this->dpsidxi_map[i][p]);
863           this->d2xyzdxi2_map[p]\&.add_scaled   (edge_point, this->d2psidxi2_map[i][p]);
864         }
865     }
866 
867   // Compute the tangents at the quadrature point
868   // FIXME: normals (plural!) and curvatures are uncalculated
869   for (unsigned int p=0; p<n_qp; p++)
870     {
871       const Point n  = this->dxyzdxi_map[p]\&.cross(this->dxyzdeta_map[p]);
872       this->tangents[p][0] = this->dxyzdxi_map[p]\&.unit();
873 
874       // compute the jacobian at the quadrature points
875       const Real the_jac = std::sqrt(this->dxdxi_map(p)*this->dxdxi_map(p) +
876                                      this->dydxi_map(p)*this->dydxi_map(p) +
877                                      this->dzdxi_map(p)*this->dzdxi_map(p));
878 
879       libmesh_assert_greater (the_jac, 0\&.);
880 
881       this->JxW[p] = the_jac*qw[p];
882     }
883 
884   STOP_LOG("compute_edge_map()", "FEMap");
885 }
.fi
.SS "void libMesh::FEXYZMap::compute_face_map (intdim, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *side)\fC [virtual]\fP"
Special implementation for XYZ finite elements 
.PP
Reimplemented from \fBlibMesh::FEMap\fP\&.
.PP
Definition at line 22 of file fe_xyz_map\&.C\&.
.PP
References libMesh::TypeVector< T >::cross(), libMesh::FEMap::curvatures, libMesh::FEMap::d2psideta2_map, libMesh::FEMap::d2psidxi2_map, libMesh::FEMap::d2psidxideta_map, libMesh::FEMap::d2xyzdeta2_map, libMesh::FEMap::d2xyzdxi2_map, libMesh::FEMap::d2xyzdxideta_map, libMesh::FEMap::dpsideta_map, libMesh::FEMap::dpsidxi_map, libMesh::FEMap::dxdeta_map(), libMesh::FEMap::dxdxi_map(), libMesh::FEMap::dxyzdeta_map, libMesh::FEMap::dxyzdxi_map, libMesh::FEMap::dydeta_map(), libMesh::FEMap::dydxi_map(), libMesh::FEMap::dzdeta_map(), libMesh::FEMap::dzdxi_map(), libMesh::FEMap::JxW, libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), libMesh::FEMap::normals, libMesh::Elem::point(), libMesh::FEMap::psi_map, libMesh::Real, libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::FEMap::tangents, libMesh::TypeVector< T >::unit(), and libMesh::FEMap::xyz\&.
.PP
.nf
23 {
24   libmesh_assert(side);
25 
26   START_LOG("compute_face_map()", "FEXYZMap");
27 
28   // The number of quadrature points\&.
29   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qw\&.size());
30 
31   switch(dim)
32     {
33     case 2:
34       {
35 
36         // Resize the vectors to hold data at the quadrature points
37         {
38           this->xyz\&.resize(n_qp);
39           this->dxyzdxi_map\&.resize(n_qp);
40           this->d2xyzdxi2_map\&.resize(n_qp);
41           this->tangents\&.resize(n_qp);
42           this->normals\&.resize(n_qp);
43           this->curvatures\&.resize(n_qp);
44 
45           this->JxW\&.resize(n_qp);
46         }
47 
48         // Clear the entities that will be summed
49         // Compute the tangent & normal at the quadrature point
50         for (unsigned int p=0; p<n_qp; p++)
51           {
52             this->tangents[p]\&.resize(LIBMESH_DIM-1); // 1 Tangent in 2D, 2 in 3D
53             this->xyz[p]\&.zero();
54             this->dxyzdxi_map[p]\&.zero();
55             this->d2xyzdxi2_map[p]\&.zero();
56           }
57 
58         // compute x, dxdxi at the quadrature points
59         for (unsigned int i=0; i<this->psi_map\&.size(); i++) // sum over the nodes
60           {
61             const Point& side_point = side->point(i);
62 
63             for (unsigned int p=0; p<n_qp; p++) // for each quadrature point\&.\&.\&.
64               {
65                 this->xyz[p]\&.add_scaled          (side_point, this->psi_map[i][p]);
66                 this->dxyzdxi_map[p]\&.add_scaled  (side_point, this->dpsidxi_map[i][p]);
67                 this->d2xyzdxi2_map[p]\&.add_scaled(side_point, this->d2psidxi2_map[i][p]);
68               }
69           }
70 
71         // Compute the tangent & normal at the quadrature point
72         for (unsigned int p=0; p<n_qp; p++)
73           {
74             const Point n(this->dxyzdxi_map[p](1), -this->dxyzdxi_map[p](0), 0\&.);
75 
76             this->normals[p]     = n\&.unit();
77             this->tangents[p][0] = this->dxyzdxi_map[p]\&.unit();
78 #if LIBMESH_DIM == 3  // Only good in 3D space
79             this->tangents[p][1] = this->dxyzdxi_map[p]\&.cross(n)\&.unit();
80 #endif
81             // The curvature is computed via the familiar Frenet formula:
82             // curvature = [d^2(x) / d (xi)^2] dot [normal]
83             // For a reference, see:
84             // F\&.S\&. Merritt, Mathematics Manual, 1962, McGraw-Hill, p\&. 310
85             //
86             // Note: The sign convention here is different from the
87             // 3D case\&.  Concave-upward curves (smiles) have a positive
88             // curvature\&.  Concave-downward curves (frowns) have a
89             // negative curvature\&.  Be sure to take that into account!
90             const Real numerator   = this->d2xyzdxi2_map[p] * this->normals[p];
91             const Real denominator = this->dxyzdxi_map[p]\&.size_sq();
92             libmesh_assert_not_equal_to (denominator, 0);
93             this->curvatures[p] = numerator / denominator;
94           }
95 
96         // compute the jacobian at the quadrature points
97         for (unsigned int p=0; p<n_qp; p++)
98           {
99             const Real the_jac = std::sqrt(this->dxdxi_map(p)*this->dxdxi_map(p) +
100                                            this->dydxi_map(p)*this->dydxi_map(p));
101 
102             libmesh_assert_greater (the_jac, 0\&.);
103 
104             this->JxW[p] = the_jac*qw[p];
105           }
106 
107         break;
108       }
109 
110     case 3:
111       {
112         // Resize the vectors to hold data at the quadrature points
113         {
114           this->xyz\&.resize(n_qp);
115           this->dxyzdxi_map\&.resize(n_qp);
116           this->dxyzdeta_map\&.resize(n_qp);
117           this->d2xyzdxi2_map\&.resize(n_qp);
118           this->d2xyzdxideta_map\&.resize(n_qp);
119           this->d2xyzdeta2_map\&.resize(n_qp);
120           this->tangents\&.resize(n_qp);
121           this->normals\&.resize(n_qp);
122           this->curvatures\&.resize(n_qp);
123 
124           this->JxW\&.resize(n_qp);
125         }
126 
127         // Clear the entities that will be summed
128         for (unsigned int p=0; p<n_qp; p++)
129           {
130             this->tangents[p]\&.resize(LIBMESH_DIM-1); // 1 Tangent in 2D, 2 in 3D
131             this->xyz[p]\&.zero();
132             this->dxyzdxi_map[p]\&.zero();
133             this->dxyzdeta_map[p]\&.zero();
134             this->d2xyzdxi2_map[p]\&.zero();
135             this->d2xyzdxideta_map[p]\&.zero();
136             this->d2xyzdeta2_map[p]\&.zero();
137           }
138 
139         // compute x, dxdxi at the quadrature points
140         for (unsigned int i=0; i<this->psi_map\&.size(); i++) // sum over the nodes
141           {
142             const Point& side_point = side->point(i);
143 
144             for (unsigned int p=0; p<n_qp; p++) // for each quadrature point\&.\&.\&.
145               {
146                 this->xyz[p]\&.add_scaled             (side_point, this->psi_map[i][p]);
147                 this->dxyzdxi_map[p]\&.add_scaled     (side_point, this->dpsidxi_map[i][p]);
148                 this->dxyzdeta_map[p]\&.add_scaled    (side_point, this->dpsideta_map[i][p]);
149                 this->d2xyzdxi2_map[p]\&.add_scaled   (side_point, this->d2psidxi2_map[i][p]);
150                 this->d2xyzdxideta_map[p]\&.add_scaled(side_point, this->d2psidxideta_map[i][p]);
151                 this->d2xyzdeta2_map[p]\&.add_scaled  (side_point, this->d2psideta2_map[i][p]);
152               }
153           }
154 
155         // Compute the tangents, normal, and curvature at the quadrature point
156         for (unsigned int p=0; p<n_qp; p++)
157           {
158             const Point n  = this->dxyzdxi_map[p]\&.cross(this->dxyzdeta_map[p]);
159             this->normals[p]     = n\&.unit();
160             this->tangents[p][0] = this->dxyzdxi_map[p]\&.unit();
161             this->tangents[p][1] = n\&.cross(this->dxyzdxi_map[p])\&.unit();
162 
163             // Compute curvature using the typical nomenclature
164             // of the first and second fundamental forms\&.
165             // For reference, see:
166             // 1) http://mathworld\&.wolfram\&.com/MeanCurvature\&.html
167             //    (note -- they are using inward normal)
168             // 2) F\&.S\&. Merritt, Mathematics Manual, 1962, McGraw-Hill
169             const Real L  = -this->d2xyzdxi2_map[p]    * this->normals[p];
170             const Real M  = -this->d2xyzdxideta_map[p] * this->normals[p];
171             const Real N  = -this->d2xyzdeta2_map[p]   * this->normals[p];
172             const Real E  =  this->dxyzdxi_map[p]\&.size_sq();
173             const Real F  =  this->dxyzdxi_map[p]      * this->dxyzdeta_map[p];
174             const Real G  =  this->dxyzdeta_map[p]\&.size_sq();
175 
176             const Real numerator   = E*N -2\&.*F*M + G*L;
177             const Real denominator = E*G - F*F;
178             libmesh_assert_not_equal_to (denominator, 0\&.);
179             this->curvatures[p] = 0\&.5*numerator/denominator;
180           }
181 
182         // compute the jacobian at the quadrature points, see
183         // http://sp81\&.msi\&.umn\&.edu:999/fluent/fidap/help/theory/thtoc\&.htm
184         for (unsigned int p=0; p<n_qp; p++)
185           {
186             const Real g11 = (this->dxdxi_map(p)*this->dxdxi_map(p) +
187                               this->dydxi_map(p)*this->dydxi_map(p) +
188                               this->dzdxi_map(p)*this->dzdxi_map(p));
189 
190             const Real g12 = (this->dxdxi_map(p)*this->dxdeta_map(p) +
191                               this->dydxi_map(p)*this->dydeta_map(p) +
192                               this->dzdxi_map(p)*this->dzdeta_map(p));
193 
194             const Real g21 = g12;
195 
196             const Real g22 = (this->dxdeta_map(p)*this->dxdeta_map(p) +
197                               this->dydeta_map(p)*this->dydeta_map(p) +
198                               this->dzdeta_map(p)*this->dzdeta_map(p));
199 
200 
201             const Real the_jac = std::sqrt(g11*g22 - g12*g21);
202 
203             libmesh_assert_greater (the_jac, 0\&.);
204 
205             this->JxW[p] = the_jac*qw[p];
206           }
207 
208         break;
209       }
210     default:
211       libmesh_error();
212 
213     } // switch(dim)
214 
215   STOP_LOG("compute_face_map()", "FEXYZMap");
216 
217   return;
218 }
.fi
.SS "void libMesh::FEMap::compute_map (const unsigned intdim, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem)\fC [virtual]\fP, \fC [inherited]\fP"
Compute the jacobian and some other additional data fields\&. Takes the integration weights as input, along with a pointer to the element\&. 
.PP
Definition at line 796 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::get_node(), libMesh::Elem::has_affine_map(), libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::FEMap::resize_quadrature_map_vectors(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TRI3SUBDIVISION, and libMesh::Elem::type()\&.
.PP
.nf
799 {
800   if (elem->has_affine_map())
801     {
802       compute_affine_map(dim, qw, elem);
803       return;
804     }
805 
806   // Start logging the map computation\&.
807   START_LOG("compute_map()", "FEMap");
808 
809   libmesh_assert(elem);
810 
811   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qw\&.size());
812 
813   // Resize the vectors to hold data at the quadrature points
814   this->resize_quadrature_map_vectors(dim, n_qp);
815 
816   // Determine the nodes contributing to element elem
817   std::vector<Node*> elem_nodes;
818   if (elem->type() == TRI3SUBDIVISION)
819     {
820       // Subdivision surface FE require the 1-ring around elem
821       libmesh_assert_equal_to (dim, 2);
822       const Tri3Subdivision* sd_elem = static_cast<const Tri3Subdivision*>(elem);
823       MeshTools::Subdivision::find_one_ring(sd_elem, elem_nodes);
824     }
825   else
826     {
827       // All other FE use only the nodes of elem itself
828       elem_nodes\&.resize(elem->n_nodes(), NULL);
829       for (unsigned int i=0; i<elem->n_nodes(); i++)
830         elem_nodes[i] = elem->get_node(i);
831     }
832 
833   // Compute map at all quadrature points
834   for (unsigned int p=0; p!=n_qp; p++)
835     this->compute_single_point_map(dim, qw, elem, p, elem_nodes);
836 
837   // Stop logging the map computation\&.
838   STOP_LOG("compute_map()", "FEMap");
839 }
.fi
.SS "void libMesh::FEMap::compute_single_point_map (const unsigned intdim, const std::vector< \fBReal\fP > &qw, const \fBElem\fP *elem, unsigned intp, const std::vector< \fBNode\fP * > &elem_nodes)\fC [inherited]\fP"
Compute the jacobian and some other additional data fields at the single point with index p\&. Takes the integration weights as input, along with a pointer to the element and a list of points that contribute to the element\&. 
.PP
Definition at line 318 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::d2phideta2_map, libMesh::FEMap::d2phidetadzeta_map, libMesh::FEMap::d2phidxi2_map, libMesh::FEMap::d2phidxideta_map, libMesh::FEMap::d2phidxidzeta_map, libMesh::FEMap::d2phidzeta2_map, libMesh::FEMap::d2xyzdeta2_map, libMesh::FEMap::d2xyzdetadzeta_map, libMesh::FEMap::d2xyzdxi2_map, libMesh::FEMap::d2xyzdxideta_map, libMesh::FEMap::d2xyzdxidzeta_map, libMesh::FEMap::d2xyzdzeta2_map, libMesh::FEMap::detadx_map, libMesh::FEMap::detady_map, libMesh::FEMap::detadz_map, libMesh::FEMap::dphideta_map, libMesh::FEMap::dphidxi_map, libMesh::FEMap::dphidzeta_map, libMesh::FEMap::dxdeta_map(), libMesh::FEMap::dxdxi_map(), libMesh::FEMap::dxdzeta_map(), libMesh::FEMap::dxidx_map, libMesh::FEMap::dxidy_map, libMesh::FEMap::dxidz_map, libMesh::FEMap::dxyzdeta_map, libMesh::FEMap::dxyzdxi_map, libMesh::FEMap::dxyzdzeta_map, libMesh::FEMap::dydeta_map(), libMesh::FEMap::dydxi_map(), libMesh::FEMap::dydzeta_map(), libMesh::FEMap::dzdeta_map(), libMesh::FEMap::dzdxi_map(), libMesh::FEMap::dzdzeta_map(), libMesh::FEMap::dzetadx_map, libMesh::FEMap::dzetady_map, libMesh::FEMap::dzetadz_map, libMesh::err, libMesh::DofObject::id(), libMesh::FEMap::jac, libMesh::FEMap::JxW, libMesh::libmesh_assert(), libMesh::FEMap::phi_map, libMesh::Real, and libMesh::FEMap::xyz\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), and libMesh::FEMap::compute_map()\&.
.PP
.nf
323 {
324   libmesh_assert(elem);
325   libmesh_assert_equal_to(phi_map\&.size(), elem_nodes\&.size());
326 
327   switch (dim)
328     {
329       //--------------------------------------------------------------------
330       // 0D
331     case 0:
332       {
333         libmesh_assert(elem_nodes[0]);
334         xyz[p] = *elem_nodes[0];
335         jac[p] = 1\&.0;
336         JxW[p] = qw[p];
337         break;
338       }
339 
340       //--------------------------------------------------------------------
341       // 1D
342     case 1:
343       {
344         // Clear the entities that will be summed
345         xyz[p]\&.zero();
346         dxyzdxi_map[p]\&.zero();
347 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
348         d2xyzdxi2_map[p]\&.zero();
349 #endif
350 
351         // compute x, dx, d2x at the quadrature point
352         for (unsigned int i=0; i<phi_map\&.size(); i++) // sum over the nodes
353           {
354             // Reference to the point, helps eliminate
355             // exessive temporaries in the inner loop
356             libmesh_assert(elem_nodes[i]);
357             const Point& elem_point = *elem_nodes[i];
358 
359             xyz[p]\&.add_scaled          (elem_point, phi_map[i][p]    );
360             dxyzdxi_map[p]\&.add_scaled  (elem_point, dphidxi_map[i][p]);
361 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
362             d2xyzdxi2_map[p]\&.add_scaled(elem_point, d2phidxi2_map[i][p]);
363 #endif
364           }
365 
366         // Compute the jacobian
367         //
368         // 1D elements can live in 2D or 3D space\&.
369         // The transformation matrix from local->global
370         // coordinates is
371         //
372         // T = | dx/dxi |
373         //     | dy/dxi |
374         //     | dz/dxi |
375         //
376         // The generalized determinant of T (from the
377         // so-called "normal" eqns\&.) is
378         // jac = "det(T)" = sqrt(det(T'T))
379         //
380         // where T'= transpose of T, so
381         //
382         // jac = sqrt( (dx/dxi)^2 + (dy/dxi)^2 + (dz/dxi)^2 )
383         jac[p] = dxyzdxi_map[p]\&.size();
384 
385         if (jac[p] <= 0\&.)
386           {
387             libMesh::err << "ERROR: negative Jacobian: "
388                          << jac[p]
389                          << " in element "
390                          << elem->id()
391                          << std::endl;
392             libmesh_error();
393           }
394 
395         // The inverse Jacobian entries also come from the
396         // generalized inverse of T (see also the 2D element
397         // living in 3D code)\&.
398         const Real jacm2 = 1\&./jac[p]/jac[p];
399         dxidx_map[p] = jacm2*dxdxi_map(p);
400 #if LIBMESH_DIM > 1
401         dxidy_map[p] = jacm2*dydxi_map(p);
402 #endif
403 #if LIBMESH_DIM > 2
404         dxidz_map[p] = jacm2*dzdxi_map(p);
405 #endif
406 
407         JxW[p] = jac[p]*qw[p];
408 
409         // done computing the map
410         break;
411       }
412 
413 
414       //--------------------------------------------------------------------
415       // 2D
416     case 2:
417       {
418         //------------------------------------------------------------------
419         // Compute the (x,y) values at the quadrature points,
420         // the Jacobian at the quadrature points
421 
422         xyz[p]\&.zero();
423 
424         dxyzdxi_map[p]\&.zero();
425         dxyzdeta_map[p]\&.zero();
426 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
427         d2xyzdxi2_map[p]\&.zero();
428         d2xyzdxideta_map[p]\&.zero();
429         d2xyzdeta2_map[p]\&.zero();
430 #endif
431 
432 
433         // compute (x,y) at the quadrature points, derivatives once
434         for (unsigned int i=0; i<phi_map\&.size(); i++) // sum over the nodes
435           {
436             // Reference to the point, helps eliminate
437             // exessive temporaries in the inner loop
438             libmesh_assert(elem_nodes[i]);
439             const Point& elem_point = *elem_nodes[i];
440 
441             xyz[p]\&.add_scaled          (elem_point, phi_map[i][p]     );
442 
443             dxyzdxi_map[p]\&.add_scaled      (elem_point, dphidxi_map[i][p] );
444             dxyzdeta_map[p]\&.add_scaled     (elem_point, dphideta_map[i][p]);
445 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
446             d2xyzdxi2_map[p]\&.add_scaled    (elem_point, d2phidxi2_map[i][p]);
447             d2xyzdxideta_map[p]\&.add_scaled (elem_point, d2phidxideta_map[i][p]);
448             d2xyzdeta2_map[p]\&.add_scaled   (elem_point, d2phideta2_map[i][p]);
449 #endif
450           }
451 
452         // compute the jacobian once
453         const Real dx_dxi = dxdxi_map(p),
454           dx_deta = dxdeta_map(p),
455           dy_dxi = dydxi_map(p),
456           dy_deta = dydeta_map(p);
457 
458 #if LIBMESH_DIM == 2
459         // Compute the Jacobian\&.  This assumes the 2D face
460         // lives in 2D space
461         //
462         // Symbolically, the matrix determinant is
463         //
464         //         | dx/dxi  dx/deta |
465         // jac =   | dy/dxi  dy/deta |
466         //
467         // jac = dx/dxi*dy/deta - dx/deta*dy/dxi
468         jac[p] = (dx_dxi*dy_deta - dx_deta*dy_dxi);
469 
470         if (jac[p] <= 0\&.)
471           {
472             libMesh::err << "ERROR: negative Jacobian: "
473                          << jac[p]
474                          << " in element "
475                          << elem->id()
476                          << std::endl;
477             libmesh_error();
478           }
479 
480         JxW[p] = jac[p]*qw[p];
481 
482         // Compute the shape function derivatives wrt x,y at the
483         // quadrature points
484         const Real inv_jac = 1\&./jac[p];
485 
486         dxidx_map[p]  =  dy_deta*inv_jac; //dxi/dx  =  (1/J)*dy/deta
487         dxidy_map[p]  = -dx_deta*inv_jac; //dxi/dy  = -(1/J)*dx/deta
488         detadx_map[p] = -dy_dxi* inv_jac; //deta/dx = -(1/J)*dy/dxi
489         detady_map[p] =  dx_dxi* inv_jac; //deta/dy =  (1/J)*dx/dxi
490 
491         dxidz_map[p] = detadz_map[p] = 0\&.;
492 #else
493 
494         const Real dz_dxi = dzdxi_map(p),
495           dz_deta = dzdeta_map(p);
496 
497         // Compute the Jacobian\&.  This assumes a 2D face in
498         // 3D space\&.
499         //
500         // The transformation matrix T from local to global
501         // coordinates is
502         //
503         //         | dx/dxi  dx/deta |
504         //     T = | dy/dxi  dy/deta |
505         //         | dz/dxi  dz/deta |
506         // note det(T' T) = det(T')det(T) = det(T)det(T)
507         // so det(T) = std::sqrt(det(T' T))
508         //
509         //----------------------------------------------
510         // Notes:
511         //
512         //       dX = R dXi -> R'dX = R'R dXi
513         // (R^-1)dX =   dXi    [(R'R)^-1 R']dX = dXi
514         //
515         // so R^-1 = (R'R)^-1 R'
516         //
517         // and R^-1 R = (R'R)^-1 R'R = I\&.
518         //
519         const Real g11 = (dx_dxi*dx_dxi +
520                           dy_dxi*dy_dxi +
521                           dz_dxi*dz_dxi);
522 
523         const Real g12 = (dx_dxi*dx_deta +
524                           dy_dxi*dy_deta +
525                           dz_dxi*dz_deta);
526 
527         const Real g21 = g12;
528 
529         const Real g22 = (dx_deta*dx_deta +
530                           dy_deta*dy_deta +
531                           dz_deta*dz_deta);
532 
533         const Real det = (g11*g22 - g12*g21);
534 
535         if (det <= 0\&.)
536           {
537             libMesh::err << "ERROR: negative Jacobian! "
538                          << " in element "
539                          << elem->id()
540                          << std::endl;
541             libmesh_error();
542           }
543 
544         const Real inv_det = 1\&./det;
545         jac[p] = std::sqrt(det);
546 
547         JxW[p] = jac[p]*qw[p];
548 
549         const Real g11inv =  g22*inv_det;
550         const Real g12inv = -g12*inv_det;
551         const Real g21inv = -g21*inv_det;
552         const Real g22inv =  g11*inv_det;
553 
554         dxidx_map[p]  = g11inv*dx_dxi + g12inv*dx_deta;
555         dxidy_map[p]  = g11inv*dy_dxi + g12inv*dy_deta;
556         dxidz_map[p]  = g11inv*dz_dxi + g12inv*dz_deta;
557 
558         detadx_map[p] = g21inv*dx_dxi + g22inv*dx_deta;
559         detady_map[p] = g21inv*dy_dxi + g22inv*dy_deta;
560         detadz_map[p] = g21inv*dz_dxi + g22inv*dz_deta;
561 
562 #endif
563         // done computing the map
564         break;
565       }
566 
567 
568 
569       //--------------------------------------------------------------------
570       // 3D
571     case 3:
572       {
573         //------------------------------------------------------------------
574         // Compute the (x,y,z) values at the quadrature points,
575         // the Jacobian at the quadrature point
576 
577         // Clear the entities that will be summed
578         xyz[p]\&.zero           ();
579         dxyzdxi_map[p]\&.zero   ();
580         dxyzdeta_map[p]\&.zero  ();
581         dxyzdzeta_map[p]\&.zero ();
582 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
583         d2xyzdxi2_map[p]\&.zero();
584         d2xyzdxideta_map[p]\&.zero();
585         d2xyzdxidzeta_map[p]\&.zero();
586         d2xyzdeta2_map[p]\&.zero();
587         d2xyzdetadzeta_map[p]\&.zero();
588         d2xyzdzeta2_map[p]\&.zero();
589 #endif
590 
591 
592         // compute (x,y,z) at the quadrature points,
593         // dxdxi,   dydxi,   dzdxi,
594         // dxdeta,  dydeta,  dzdeta,
595         // dxdzeta, dydzeta, dzdzeta  all once
596         for (unsigned int i=0; i<phi_map\&.size(); i++) // sum over the nodes
597           {
598             // Reference to the point, helps eliminate
599             // exessive temporaries in the inner loop
600             libmesh_assert(elem_nodes[i]);
601             const Point& elem_point = *elem_nodes[i];
602 
603             xyz[p]\&.add_scaled           (elem_point, phi_map[i][p]      );
604             dxyzdxi_map[p]\&.add_scaled   (elem_point, dphidxi_map[i][p]  );
605             dxyzdeta_map[p]\&.add_scaled  (elem_point, dphideta_map[i][p] );
606             dxyzdzeta_map[p]\&.add_scaled (elem_point, dphidzeta_map[i][p]);
607 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
608             d2xyzdxi2_map[p]\&.add_scaled      (elem_point,
609                                               d2phidxi2_map[i][p]);
610             d2xyzdxideta_map[p]\&.add_scaled   (elem_point,
611                                               d2phidxideta_map[i][p]);
612             d2xyzdxidzeta_map[p]\&.add_scaled  (elem_point,
613                                               d2phidxidzeta_map[i][p]);
614             d2xyzdeta2_map[p]\&.add_scaled     (elem_point,
615                                               d2phideta2_map[i][p]);
616             d2xyzdetadzeta_map[p]\&.add_scaled (elem_point,
617                                               d2phidetadzeta_map[i][p]);
618             d2xyzdzeta2_map[p]\&.add_scaled    (elem_point,
619                                               d2phidzeta2_map[i][p]);
620 #endif
621           }
622 
623         // compute the jacobian
624         const Real
625           dx_dxi   = dxdxi_map(p),   dy_dxi   = dydxi_map(p),   dz_dxi   = dzdxi_map(p),
626           dx_deta  = dxdeta_map(p),  dy_deta  = dydeta_map(p),  dz_deta  = dzdeta_map(p),
627           dx_dzeta = dxdzeta_map(p), dy_dzeta = dydzeta_map(p), dz_dzeta = dzdzeta_map(p);
628 
629         // Symbolically, the matrix determinant is
630         //
631         //         | dx/dxi   dy/dxi   dz/dxi   |
632         // jac =   | dx/deta  dy/deta  dz/deta  |
633         //         | dx/dzeta dy/dzeta dz/dzeta |
634         //
635         // jac = dx/dxi*(dy/deta*dz/dzeta - dz/deta*dy/dzeta) +
636         //       dy/dxi*(dz/deta*dx/dzeta - dx/deta*dz/dzeta) +
637         //       dz/dxi*(dx/deta*dy/dzeta - dy/deta*dx/dzeta)
638 
639         jac[p] = (dx_dxi*(dy_deta*dz_dzeta - dz_deta*dy_dzeta)  +
640                   dy_dxi*(dz_deta*dx_dzeta - dx_deta*dz_dzeta)  +
641                   dz_dxi*(dx_deta*dy_dzeta - dy_deta*dx_dzeta));
642 
643         if (jac[p] <= 0\&.)
644           {
645             libMesh::err << "ERROR: negative Jacobian: "
646                          << jac[p]
647                          << " in element "
648                          << elem->id()
649                          << std::endl;
650             libmesh_error();
651           }
652 
653         JxW[p] = jac[p]*qw[p];
654 
655         // Compute the shape function derivatives wrt x,y at the
656         // quadrature points
657         const Real inv_jac  = 1\&./jac[p];
658 
659         dxidx_map[p]   = (dy_deta*dz_dzeta - dz_deta*dy_dzeta)*inv_jac;
660         dxidy_map[p]   = (dz_deta*dx_dzeta - dx_deta*dz_dzeta)*inv_jac;
661         dxidz_map[p]   = (dx_deta*dy_dzeta - dy_deta*dx_dzeta)*inv_jac;
662 
663         detadx_map[p]  = (dz_dxi*dy_dzeta  - dy_dxi*dz_dzeta )*inv_jac;
664         detady_map[p]  = (dx_dxi*dz_dzeta  - dz_dxi*dx_dzeta )*inv_jac;
665         detadz_map[p]  = (dy_dxi*dx_dzeta  - dx_dxi*dy_dzeta )*inv_jac;
666 
667         dzetadx_map[p] = (dy_dxi*dz_deta   - dz_dxi*dy_deta  )*inv_jac;
668         dzetady_map[p] = (dz_dxi*dx_deta   - dx_dxi*dz_deta  )*inv_jac;
669         dzetadz_map[p] = (dx_dxi*dy_deta   - dy_dxi*dx_deta  )*inv_jac;
670 
671         // done computing the map
672         break;
673       }
674 
675     default:
676       libmesh_error();
677     }
678 }
.fi
.SS "\fBReal\fP libMesh::FEMap::dxdeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the x value of the pth entry of the dxzydeta_map\&. 
.PP
Definition at line 463 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdeta_map\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
463 { return dxyzdeta_map[p](0); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dxdxi_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the x value of the pth entry of the dxzydxi_map\&. 
.PP
Definition at line 442 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdxi_map\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
442 { return dxyzdxi_map[p](0); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dxdzeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the x value of the pth entry of the dxzydzeta_map\&. 
.PP
Definition at line 484 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdzeta_map\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
484 { return dxyzdzeta_map[p](0); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dydeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the y value of the pth entry of the dxzydeta_map\&. 
.PP
Definition at line 470 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdeta_map\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
470 { return dxyzdeta_map[p](1); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dydxi_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the y value of the pth entry of the dxzydxi_map\&. 
.PP
Definition at line 449 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdxi_map\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
449 { return dxyzdxi_map[p](1); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dydzeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the y value of the pth entry of the dxzydzeta_map\&. 
.PP
Definition at line 491 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdzeta_map\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
491 { return dxyzdzeta_map[p](1); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dzdeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the z value of the pth entry of the dxzydeta_map\&. 
.PP
Definition at line 477 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdeta_map\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
477 { return dxyzdeta_map[p](2); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dzdxi_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the z value of the pth entry of the dxzydxi_map\&. 
.PP
Definition at line 456 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdxi_map\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
456 { return dxyzdxi_map[p](2); }
.fi
.SS "\fBReal\fP libMesh::FEMap::dzdzeta_map (const unsigned intp) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Used in \fC\fBFEMap::compute_map()\fP\fP, which should be be usable in derived classes, and therefore protected\&. Returns the z value of the pth entry of the dxzydzeta_map\&. 
.PP
Definition at line 498 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdzeta_map\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map()\&.
.PP
.nf
498 { return dxyzdzeta_map[p](2); }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_curvatures () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the curvatures for use in face integration\&. 
.RE
.PP

.PP
Definition at line 305 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::curvatures\&.
.PP
.nf
306   { return curvatures;}
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phideta2_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 405 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phideta2_map\&.
.PP
.nf
406   { return d2phideta2_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phidetadzeta_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 411 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phidetadzeta_map\&.
.PP
.nf
412   { return d2phidetadzeta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phidxi2_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 387 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phidxi2_map\&.
.PP
.nf
388   { return d2phidxi2_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phidxideta_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 393 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phidxideta_map\&.
.PP
.nf
394   { return d2phidxideta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phidxidzeta_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 399 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phidxidzeta_map\&.
.PP
.nf
400   { return d2phidxidzeta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2phidzeta2_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative 
.RE
.PP

.PP
Definition at line 417 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2phidzeta2_map\&.
.PP
.nf
418   { return d2phidzeta2_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2psideta2 ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative for the side/edge 
.RE
.PP

.PP
Definition at line 356 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2psideta2_map\&.
.PP
.nf
357   { return d2psideta2_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2psidxi2 ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative for the side/edge 
.RE
.PP

.PP
Definition at line 344 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2psidxi2_map\&.
.PP
.nf
345   { return d2psidxi2_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_d2psidxideta ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map 2nd derivative for the side/edge 
.RE
.PP

.PP
Definition at line 350 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2psidxideta_map\&.
.PP
.nf
351   { return d2psidxideta_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta\&. 
.RE
.PP

.PP
Definition at line 162 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdeta2_map\&.
.PP
.nf
163   { return d2xyzdeta2_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdetadzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in eta-zeta\&. 
.RE
.PP

.PP
Definition at line 192 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdetadzeta_map\&.
.PP
.nf
193   { return d2xyzdetadzeta_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdxi2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi\&. 
.RE
.PP

.PP
Definition at line 156 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdxi2_map\&.
.PP
.nf
157   { return d2xyzdxi2_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdxideta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-eta\&. 
.RE
.PP

.PP
Definition at line 178 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdxideta_map\&.
.PP
.nf
179   { return d2xyzdxideta_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdxidzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in xi-zeta\&. 
.RE
.PP

.PP
Definition at line 186 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdxidzeta_map\&.
.PP
.nf
187   { return d2xyzdxidzeta_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_d2xyzdzeta2 () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the second partial derivatives in zeta\&. 
.RE
.PP

.PP
Definition at line 170 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::d2xyzdzeta2_map\&.
.PP
.nf
171   { return d2xyzdzeta2_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_detadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 222 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::detadx_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
223   { return detadx_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_detady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 229 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::detady_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
230   { return detady_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_detadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the deta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 236 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::detadz_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
237   { return detadz_map; }
.fi
.SS "const std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphideta_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 281 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphideta_map\&.
.PP
.nf
282   { return dphideta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphideta_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 374 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphideta_map\&.
.PP
.nf
375   { return dphideta_map; }
.fi
.SS "const std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphidxi_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 275 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphidxi_map\&.
.PP
.nf
276   { return dphidxi_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphidxi_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 368 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphidxi_map\&.
.PP
.nf
369   { return dphidxi_map; }
.fi
.SS "const std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphidzeta_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 287 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphidzeta_map\&.
.PP
.nf
288   { return dphidzeta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dphidzeta_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative 
.RE
.PP

.PP
Definition at line 380 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dphidzeta_map\&.
.PP
.nf
381   { return dphidzeta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dpsideta ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative for the side/edge 
.RE
.PP

.PP
Definition at line 338 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dpsideta_map\&.
.PP
.nf
339   { return dpsideta_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_dpsidxi ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map derivative for the side/edge 
.RE
.PP

.PP
Definition at line 332 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dpsidxi_map\&.
.PP
.nf
333   { return dpsidxi_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dxidx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 201 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxidx_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
202   { return dxidx_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dxidy () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 208 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxidy_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
209   { return dxidy_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dxidz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dxi/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 215 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxidz_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
216   { return dxidz_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_dxyzdeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in eta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 143 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdeta_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl()\&.
.PP
.nf
144   { return dxyzdeta_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_dxyzdxi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in xi-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 136 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdxi_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl()\&.
.PP
.nf
137   { return dxyzdxi_map; }
.fi
.SS "const std::vector<\fBRealGradient\fP>& libMesh::FEMap::get_dxyzdzeta () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element tangents in zeta-direction at the quadrature points\&. 
.RE
.PP

.PP
Definition at line 150 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dxyzdzeta_map\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl()\&.
.PP
.nf
151   { return dxyzdzeta_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dzetadx () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dx entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 243 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dzetadx_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
244   { return dzetadx_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dzetady () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dy entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 250 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dzetady_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
251   { return dzetady_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_dzetadz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the dzeta/dz entry in the transformation matrix from physical to local coordinates\&. 
.RE
.PP

.PP
Definition at line 257 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::dzetadz_map\&.
.PP
Referenced by libMesh::H1FETransformation< T >::map_curl(), libMesh::H1FETransformation< T >::map_d2phi(), libMesh::H1FETransformation< T >::map_div(), libMesh::H1FETransformation< T >::map_dphi(), and libMesh::HCurlFETransformation< T >::map_phi()\&.
.PP
.nf
258   { return dzetadz_map; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_jacobian () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 122 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::jac\&.
.PP
Referenced by libMesh::HCurlFETransformation< T >::map_curl()\&.
.PP
.nf
123   { return jac; }
.fi
.SS "const std::vector<\fBReal\fP>& libMesh::FEMap::get_JxW () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 129 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::JxW\&.
.PP
.nf
130   { return JxW; }
.fi
.SS "std::vector<\fBReal\fP>& libMesh::FEMap::get_JxW ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
writable reference to the element Jacobian times the quadrature weight for each quadrature point\&. 
.RE
.PP

.PP
Definition at line 427 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::JxW\&.
.PP
.nf
428   { return JxW; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEMap::get_normals () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the normal vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 299 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::normals\&.
.PP
.nf
300   { return normals; }
.fi
.SS "const std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_phi_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map for the element 
.RE
.PP

.PP
Definition at line 269 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::phi_map\&.
.PP
.nf
270   { return phi_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_phi_map ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map for the element 
.RE
.PP

.PP
Definition at line 362 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::phi_map\&.
.PP
.nf
363   { return phi_map; }
.fi
.SS "const std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_psi () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map for the side/edge 
.RE
.PP

.PP
Definition at line 263 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::psi_map\&.
.PP
.nf
264   { return psi_map; }
.fi
.SS "std::vector<std::vector<\fBReal\fP> >& libMesh::FEMap::get_psi ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the reference to physical map for the side/edge 
.RE
.PP

.PP
Definition at line 326 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::psi_map\&.
.PP
.nf
327   { return psi_map; }
.fi
.SS "const std::vector<std::vector<\fBPoint\fP> >& libMesh::FEMap::get_tangents () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the tangent vectors for face integration\&. 
.RE
.PP

.PP
Definition at line 293 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::tangents\&.
.PP
.nf
294   { return tangents; }
.fi
.SS "const std::vector<\fBPoint\fP>& libMesh::FEMap::get_xyz () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCxyz\fP spatial locations of the quadrature points on the element\&. 
.RE
.PP

.PP
Definition at line 116 of file fe_map\&.h\&.
.PP
References libMesh::FEMap::xyz\&.
.PP
.nf
117   { return xyz; }
.fi
.SS "template<unsigned int Dim> void libMesh::FEMap::init_edge_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *edge)\fC [inherited]\fP"
Same as before, but for an edge\&. This is used for some projection operators\&. Start logging the shape function initialization
.PP
Stop logging the shape function initialization
.PP
Definition at line 475 of file fe_boundary\&.C\&.
.PP
References libMesh::FEMap::d2psidxi2_map, libMesh::Elem::default_order(), libMesh::FEMap::dpsidxi_map, libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::FEMap::psi_map, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
.nf
477 {
478   libmesh_assert(edge);
479 
483   START_LOG("init_edge_shape_functions()", "FEMap");
484 
485   // The element type and order to use in
486   // the map
487   const Order    mapping_order     (edge->default_order());
488   const ElemType mapping_elem_type (edge->type());
489 
490   // The number of quadrature points\&.
491   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qp\&.size());
492 
493   const unsigned int n_mapping_shape_functions =
494     FE<Dim,LAGRANGE>::n_shape_functions (mapping_elem_type,
495                                          mapping_order);
496 
497   // resize the vectors to hold current data
498   // Psi are the shape functions used for the FE mapping
499   this->psi_map\&.resize        (n_mapping_shape_functions);
500   this->dpsidxi_map\&.resize    (n_mapping_shape_functions);
501   this->d2psidxi2_map\&.resize  (n_mapping_shape_functions);
502 
503   for (unsigned int i=0; i<n_mapping_shape_functions; i++)
504     {
505       // Allocate space to store the values of the shape functions
506       // and their first and second derivatives at the quadrature points\&.
507       this->psi_map[i]\&.resize        (n_qp);
508       this->dpsidxi_map[i]\&.resize    (n_qp);
509       this->d2psidxi2_map[i]\&.resize  (n_qp);
510 
511       // Compute the value of shape function i, and its first and
512       // second derivatives at quadrature point p
513       // (Lagrange shape functions are used for the mapping)
514       for (unsigned int p=0; p<n_qp; p++)
515         {
516           this->psi_map[i][p]        = FE<1,LAGRANGE>::shape             (mapping_elem_type, mapping_order, i,    qp[p]);
517           this->dpsidxi_map[i][p]    = FE<1,LAGRANGE>::shape_deriv       (mapping_elem_type, mapping_order, i, 0, qp[p]);
518           this->d2psidxi2_map[i][p]  = FE<1,LAGRANGE>::shape_second_deriv(mapping_elem_type, mapping_order, i, 0, qp[p]);
519         }
520     }
521 
525   STOP_LOG("init_edge_shape_functions()", "FEMap");
526 }
.fi
.SS "template<unsigned int Dim> void libMesh::FEMap::init_face_shape_functions (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *side)\fC [inherited]\fP"
Initalizes the reference to physical element map for a side\&. This is used for boundary integration\&. Start logging the shape function initialization
.PP
Stop logging the shape function initialization
.PP
Definition at line 386 of file fe_boundary\&.C\&.
.PP
References libMesh::FEMap::d2psideta2_map, libMesh::FEMap::d2psidxi2_map, libMesh::FEMap::d2psidxideta_map, libMesh::Elem::default_order(), libMesh::FEMap::dpsideta_map, libMesh::FEMap::dpsidxi_map, libMesh::libmesh_assert(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::FEMap::psi_map, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
.nf
388 {
389   libmesh_assert(side);
390 
394   START_LOG("init_face_shape_functions()", "FEMap");
395 
396   // The element type and order to use in
397   // the map
398   const Order    mapping_order     (side->default_order());
399   const ElemType mapping_elem_type (side->type());
400 
401   // The number of quadrature points\&.
402   const unsigned int n_qp = libmesh_cast_int<unsigned int>(qp\&.size());
403 
404   const unsigned int n_mapping_shape_functions =
405     FE<Dim,LAGRANGE>::n_shape_functions (mapping_elem_type,
406                                          mapping_order);
407 
408   // resize the vectors to hold current data
409   // Psi are the shape functions used for the FE mapping
410   this->psi_map\&.resize        (n_mapping_shape_functions);
411 
412   if (Dim > 1)
413     {
414       this->dpsidxi_map\&.resize    (n_mapping_shape_functions);
415       this->d2psidxi2_map\&.resize  (n_mapping_shape_functions);
416     }
417 
418   if (Dim == 3)
419     {
420       this->dpsideta_map\&.resize     (n_mapping_shape_functions);
421       this->d2psidxideta_map\&.resize (n_mapping_shape_functions);
422       this->d2psideta2_map\&.resize   (n_mapping_shape_functions);
423     }
424 
425   for (unsigned int i=0; i<n_mapping_shape_functions; i++)
426     {
427       // Allocate space to store the values of the shape functions
428       // and their first and second derivatives at the quadrature points\&.
429       this->psi_map[i]\&.resize        (n_qp);
430       if (Dim > 1)
431         {
432           this->dpsidxi_map[i]\&.resize    (n_qp);
433           this->d2psidxi2_map[i]\&.resize  (n_qp);
434         }
435       if (Dim == 3)
436         {
437           this->dpsideta_map[i]\&.resize     (n_qp);
438           this->d2psidxideta_map[i]\&.resize (n_qp);
439           this->d2psideta2_map[i]\&.resize   (n_qp);
440         }
441 
442       // Compute the value of shape function i, and its first and
443       // second derivatives at quadrature point p
444       // (Lagrange shape functions are used for the mapping)
445       for (unsigned int p=0; p<n_qp; p++)
446         {
447           this->psi_map[i][p]        = FE<Dim-1,LAGRANGE>::shape             (mapping_elem_type, mapping_order, i,    qp[p]);
448           if (Dim > 1)
449             {
450               this->dpsidxi_map[i][p]    = FE<Dim-1,LAGRANGE>::shape_deriv       (mapping_elem_type, mapping_order, i, 0, qp[p]);
451               this->d2psidxi2_map[i][p]  = FE<Dim-1,LAGRANGE>::shape_second_deriv(mapping_elem_type, mapping_order, i, 0, qp[p]);
452             }
453           // libMesh::out << "this->d2psidxi2_map["<<i<<"][p]=" << d2psidxi2_map[i][p] << std::endl;
454 
455           // If we are in 3D, then our sides are 2D faces\&.
456           // For the second derivatives, we must also compute the cross
457           // derivative d^2() / dxi deta
458           if (Dim == 3)
459             {
460               this->dpsideta_map[i][p]     = FE<Dim-1,LAGRANGE>::shape_deriv       (mapping_elem_type, mapping_order, i, 1, qp[p]);
461               this->d2psidxideta_map[i][p] = FE<Dim-1,LAGRANGE>::shape_second_deriv(mapping_elem_type, mapping_order, i, 1, qp[p]);
462               this->d2psideta2_map[i][p]   = FE<Dim-1,LAGRANGE>::shape_second_deriv(mapping_elem_type, mapping_order, i, 2, qp[p]);
463             }
464         }
465     }
466 
467 
471   STOP_LOG("init_face_shape_functions()", "FEMap");
472 }
.fi
.SS "template<unsigned int Dim> template void libMesh::FEMap::init_reference_to_physical_map< 3 > (const std::vector< \fBPoint\fP > &qp, const \fBElem\fP *elem)\fC [inherited]\fP"

.PP
Definition at line 66 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::d2phideta2_map, libMesh::FEMap::d2phidetadzeta_map, libMesh::FEMap::d2phidxi2_map, libMesh::FEMap::d2phidxideta_map, libMesh::FEMap::d2phidxidzeta_map, libMesh::FEMap::d2phidzeta2_map, libMesh::Elem::default_order(), libMesh::FEMap::dphideta_map, libMesh::FEMap::dphidxi_map, libMesh::FEMap::dphidzeta_map, libMesh::Elem::is_linear(), libMesh::FE< Dim, T >::n_shape_functions(), libMesh::FEMap::phi_map, libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::type()\&.
.PP
.nf
68 {
69   // Start logging the reference->physical map initialization
70   START_LOG("init_reference_to_physical_map()", "FEMap");
71 
72   // The number of quadrature points\&.
73   const std::size_t n_qp = qp\&.size();
74 
75   // The element type and order to use in
76   // the map
77   const Order    mapping_order     (elem->default_order());
78   const ElemType mapping_elem_type (elem->type());
79 
80   // Number of shape functions used to construt the map
81   // (Lagrange shape functions are used for mapping)
82   const unsigned int n_mapping_shape_functions =
83     FE<Dim,LAGRANGE>::n_shape_functions (mapping_elem_type,
84                                          mapping_order);
85 
86   this->phi_map\&.resize         (n_mapping_shape_functions);
87   if (Dim > 0)
88     {
89       this->dphidxi_map\&.resize     (n_mapping_shape_functions);
90 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
91       this->d2phidxi2_map\&.resize   (n_mapping_shape_functions);
92 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
93     }
94 
95   if (Dim > 1)
96     {
97       this->dphideta_map\&.resize  (n_mapping_shape_functions);
98 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
99       this->d2phidxideta_map\&.resize   (n_mapping_shape_functions);
100       this->d2phideta2_map\&.resize     (n_mapping_shape_functions);
101 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
102     }
103 
104   if (Dim > 2)
105     {
106       this->dphidzeta_map\&.resize (n_mapping_shape_functions);
107 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
108       this->d2phidxidzeta_map\&.resize  (n_mapping_shape_functions);
109       this->d2phidetadzeta_map\&.resize (n_mapping_shape_functions);
110       this->d2phidzeta2_map\&.resize    (n_mapping_shape_functions);
111 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
112     }
113 
114 
115   for (unsigned int i=0; i<n_mapping_shape_functions; i++)
116     {
117       this->phi_map[i]\&.resize         (n_qp);
118       if (Dim > 0)
119         {
120           this->dphidxi_map[i]\&.resize     (n_qp);
121 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
122           this->d2phidxi2_map[i]\&.resize     (n_qp);
123           if (Dim > 1)
124             {
125               this->d2phidxideta_map[i]\&.resize (n_qp);
126               this->d2phideta2_map[i]\&.resize (n_qp);
127             }
128           if (Dim > 2)
129             {
130               this->d2phidxidzeta_map[i]\&.resize  (n_qp);
131               this->d2phidetadzeta_map[i]\&.resize (n_qp);
132               this->d2phidzeta2_map[i]\&.resize    (n_qp);
133             }
134 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
135 
136           if (Dim > 1)
137             this->dphideta_map[i]\&.resize  (n_qp);
138 
139           if (Dim > 2)
140             this->dphidzeta_map[i]\&.resize (n_qp);
141         }
142     }
143 
144   // Optimize for the *linear* geometric elements case:
145   bool is_linear = elem->is_linear();
146 
147   switch (Dim)
148     {
149 
150       //------------------------------------------------------------
151       // 0D
152     case 0:
153       {
154         for (unsigned int i=0; i<n_mapping_shape_functions; i++)
155           for (std::size_t p=0; p<n_qp; p++)
156             this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape (mapping_elem_type, mapping_order, i,    qp[p]);
157 
158         break;
159       }
160 
161       //------------------------------------------------------------
162       // 1D
163     case 1:
164       {
165         // Compute the value of the mapping shape function i at quadrature point p
166         // (Lagrange shape functions are used for mapping)
167         if (is_linear)
168           {
169             for (unsigned int i=0; i<n_mapping_shape_functions; i++)
170               {
171                 this->phi_map[i][0]      = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[0]);
172                 this->dphidxi_map[i][0]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
173 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
174                 this->d2phidxi2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
175 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
176                 for (std::size_t p=1; p<n_qp; p++)
177                   {
178                     this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape (mapping_elem_type, mapping_order, i,    qp[p]);
179                     this->dphidxi_map[i][p]  = this->dphidxi_map[i][0];
180 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
181                     this->d2phidxi2_map[i][p] = this->d2phidxi2_map[i][0];
182 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
183                   }
184               }
185           }
186         else
187           for (unsigned int i=0; i<n_mapping_shape_functions; i++)
188             for (std::size_t p=0; p<n_qp; p++)
189               {
190                 this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[p]);
191                 this->dphidxi_map[i][p]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
192 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
193                 this->d2phidxi2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
194 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
195               }
196 
197         break;
198       }
199       //------------------------------------------------------------
200       // 2D
201     case 2:
202       {
203         // Compute the value of the mapping shape function i at quadrature point p
204         // (Lagrange shape functions are used for mapping)
205         if (is_linear)
206           {
207             for (unsigned int i=0; i<n_mapping_shape_functions; i++)
208               {
209                 this->phi_map[i][0]      = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[0]);
210                 this->dphidxi_map[i][0]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
211                 this->dphideta_map[i][0] = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 1, qp[0]);
212 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
213                 this->d2phidxi2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
214                 this->d2phidxideta_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 1, qp[0]);
215                 this->d2phideta2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 2, qp[0]);
216 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
217                 for (std::size_t p=1; p<n_qp; p++)
218                   {
219                     this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape (mapping_elem_type, mapping_order, i,    qp[p]);
220                     this->dphidxi_map[i][p]  = this->dphidxi_map[i][0];
221                     this->dphideta_map[i][p] = this->dphideta_map[i][0];
222 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
223                     this->d2phidxi2_map[i][p] = this->d2phidxi2_map[i][0];
224                     this->d2phidxideta_map[i][p] = this->d2phidxideta_map[i][0];
225                     this->d2phideta2_map[i][p] = this->d2phideta2_map[i][0];
226 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
227                   }
228               }
229           }
230         else
231           for (unsigned int i=0; i<n_mapping_shape_functions; i++)
232             for (std::size_t p=0; p<n_qp; p++)
233               {
234                 this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[p]);
235                 this->dphidxi_map[i][p]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
236                 this->dphideta_map[i][p] = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 1, qp[p]);
237 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
238                 this->d2phidxi2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
239                 this->d2phidxideta_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 1, qp[p]);
240                 this->d2phideta2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 2, qp[p]);
241 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
242               }
243 
244         break;
245       }
246 
247       //------------------------------------------------------------
248       // 3D
249     case 3:
250       {
251         // Compute the value of the mapping shape function i at quadrature point p
252         // (Lagrange shape functions are used for mapping)
253         if (is_linear)
254           {
255             for (unsigned int i=0; i<n_mapping_shape_functions; i++)
256               {
257                 this->phi_map[i][0]      = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[0]);
258                 this->dphidxi_map[i][0]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
259                 this->dphideta_map[i][0] = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 1, qp[0]);
260                 this->dphidzeta_map[i][0] = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 2, qp[0]);
261 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
262                 this->d2phidxi2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[0]);
263                 this->d2phidxideta_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 1, qp[0]);
264                 this->d2phideta2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 2, qp[0]);
265                 this->d2phidxidzeta_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 3, qp[0]);
266                 this->d2phidetadzeta_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 4, qp[0]);
267                 this->d2phidzeta2_map[i][0] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 5, qp[0]);
268 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
269                 for (std::size_t p=1; p<n_qp; p++)
270                   {
271                     this->phi_map[i][p]      = FE<Dim,LAGRANGE>::shape (mapping_elem_type, mapping_order, i,    qp[p]);
272                     this->dphidxi_map[i][p]  = this->dphidxi_map[i][0];
273                     this->dphideta_map[i][p] = this->dphideta_map[i][0];
274                     this->dphidzeta_map[i][p] = this->dphidzeta_map[i][0];
275 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
276                     this->d2phidxi2_map[i][p] = this->d2phidxi2_map[i][0];
277                     this->d2phidxideta_map[i][p] = this->d2phidxideta_map[i][0];
278                     this->d2phideta2_map[i][p] = this->d2phideta2_map[i][0];
279                     this->d2phidxidzeta_map[i][p] = this->d2phidxidzeta_map[i][0];
280                     this->d2phidetadzeta_map[i][p] = this->d2phidetadzeta_map[i][0];
281                     this->d2phidzeta2_map[i][p] = this->d2phidzeta2_map[i][0];
282 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
283                   }
284               }
285           }
286         else
287           for (unsigned int i=0; i<n_mapping_shape_functions; i++)
288             for (std::size_t p=0; p<n_qp; p++)
289               {
290                 this->phi_map[i][p]       = FE<Dim,LAGRANGE>::shape       (mapping_elem_type, mapping_order, i,    qp[p]);
291                 this->dphidxi_map[i][p]   = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
292                 this->dphideta_map[i][p]  = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 1, qp[p]);
293                 this->dphidzeta_map[i][p] = FE<Dim,LAGRANGE>::shape_deriv (mapping_elem_type, mapping_order, i, 2, qp[p]);
294 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
295                 this->d2phidxi2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 0, qp[p]);
296                 this->d2phidxideta_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 1, qp[p]);
297                 this->d2phideta2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 2, qp[p]);
298                 this->d2phidxidzeta_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 3, qp[p]);
299                 this->d2phidetadzeta_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 4, qp[p]);
300                 this->d2phidzeta2_map[i][p] = FE<Dim,LAGRANGE>::shape_second_deriv (mapping_elem_type, mapping_order, i, 5, qp[p]);
301 #endif // ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
302               }
303 
304         break;
305       }
306 
307     default:
308       libmesh_error();
309     }
310 
311   // Stop logging the reference->physical map initialization
312   STOP_LOG("init_reference_to_physical_map()", "FEMap");
313   return;
314 }
.fi
.SS "void libMesh::FEMap::print_JxW (std::ostream &os) const\fC [inherited]\fP"
Prints the Jacobian times the weight for each quadrature point\&. 
.PP
Definition at line 843 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::JxW\&.
.PP
.nf
844 {
845   for (unsigned int i=0; i<JxW\&.size(); ++i)
846     os << " [" << i << "]: " <<  JxW[i] << std::endl;
847 }
.fi
.SS "void libMesh::FEMap::print_xyz (std::ostream &os) const\fC [inherited]\fP"
Prints the spatial location of each quadrature point (on the physical element)\&. 
.PP
Definition at line 851 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::xyz\&.
.PP
.nf
852 {
853   for (unsigned int i=0; i<xyz\&.size(); ++i)
854     os << " [" << i << "]: " << xyz[i];
855 }
.fi
.SS "void libMesh::FEMap::resize_quadrature_map_vectors (const unsigned intdim, unsigned intn_qp)\fC [protected]\fP, \fC [inherited]\fP"
A utility function for use by compute_*_map 
.PP
Definition at line 682 of file fe_map\&.C\&.
.PP
References libMesh::FEMap::d2xyzdeta2_map, libMesh::FEMap::d2xyzdetadzeta_map, libMesh::FEMap::d2xyzdxi2_map, libMesh::FEMap::d2xyzdxideta_map, libMesh::FEMap::d2xyzdxidzeta_map, libMesh::FEMap::d2xyzdzeta2_map, libMesh::FEMap::detadx_map, libMesh::FEMap::detady_map, libMesh::FEMap::detadz_map, libMesh::FEMap::dxidx_map, libMesh::FEMap::dxidy_map, libMesh::FEMap::dxidz_map, libMesh::FEMap::dxyzdeta_map, libMesh::FEMap::dxyzdxi_map, libMesh::FEMap::dxyzdzeta_map, libMesh::FEMap::dzetadx_map, libMesh::FEMap::dzetady_map, libMesh::FEMap::dzetadz_map, libMesh::FEMap::jac, libMesh::FEMap::JxW, and libMesh::FEMap::xyz\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), and libMesh::FEMap::compute_map()\&.
.PP
.nf
683 {
684   // Resize the vectors to hold data at the quadrature points
685   xyz\&.resize(n_qp);
686   dxyzdxi_map\&.resize(n_qp);
687   dxidx_map\&.resize(n_qp);
688   dxidy_map\&.resize(n_qp); // 1D element may live in 2D \&.\&.\&.
689   dxidz_map\&.resize(n_qp); // \&.\&.\&. or 3D
690 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
691   d2xyzdxi2_map\&.resize(n_qp);
692 #endif
693   if (dim > 1)
694     {
695       dxyzdeta_map\&.resize(n_qp);
696       detadx_map\&.resize(n_qp);
697       detady_map\&.resize(n_qp);
698       detadz_map\&.resize(n_qp);
699 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
700       d2xyzdxideta_map\&.resize(n_qp);
701       d2xyzdeta2_map\&.resize(n_qp);
702 #endif
703       if (dim > 2)
704         {
705           dxyzdzeta_map\&.resize (n_qp);
706           dzetadx_map\&.resize   (n_qp);
707           dzetady_map\&.resize   (n_qp);
708           dzetadz_map\&.resize   (n_qp);
709 #ifdef LIBMESH_ENABLE_SECOND_DERIVATIVES
710           d2xyzdxidzeta_map\&.resize(n_qp);
711           d2xyzdetadzeta_map\&.resize(n_qp);
712           d2xyzdzeta2_map\&.resize(n_qp);
713 #endif
714         }
715     }
716 
717   jac\&.resize(n_qp);
718   JxW\&.resize(n_qp);
719 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBReal\fP> libMesh::FEMap::curvatures\fC [protected]\fP, \fC [inherited]\fP"
The mean curvature (= one half the sum of the principal curvatures) on the boundary at the quadrature points\&. The mean curvature is a scalar value\&. 
.PP
Definition at line 726 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::get_curvatures()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phideta2_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(eta)^2\&. 
.PP
Definition at line 659 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phideta2_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phidetadzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(eta)d(zeta)\&. 
.PP
Definition at line 664 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phidetadzeta_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phidxi2_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(xi)^2\&. 
.PP
Definition at line 644 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phidxi2_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phidxideta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(xi)d(eta)\&. 
.PP
Definition at line 649 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phidxideta_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phidxidzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(xi)d(zeta)\&. 
.PP
Definition at line 654 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phidxidzeta_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2phidzeta2_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivative, d^2(phi)/d(zeta)^2\&. 
.PP
Definition at line 669 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2phidzeta2_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2psideta2_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivatives (in eta) of the side shape functions\&. Useful for computing the curvature at the quadrature points\&. 
.PP
Definition at line 709 of file fe_map\&.h\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_d2psideta2(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2psidxi2_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second derivatives (in xi) of the side shape functions\&. Useful for computing the curvature at the quadrature points\&. 
.PP
Definition at line 695 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_d2psidxi2(), libMesh::FEMap::init_edge_shape_functions(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::d2psidxideta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the second (cross) derivatives in xi, eta of the side shape functions\&. Useful for computing the curvature at the quadrature points\&. 
.PP
Definition at line 702 of file fe_map\&.h\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_d2psidxideta(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdeta2_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of second partial derivatives in eta: d^2(x)/d(eta)^2 
.PP
Definition at line 539 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdeta2(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdetadzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of mixed second partial derivatives in eta-zeta: d^2(x)/d(eta)d(zeta) d^2(y)/d(eta)d(zeta) d^2(z)/d(eta)d(zeta) 
.PP
Definition at line 553 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdetadzeta(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdxi2_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of second partial derivatives in xi: d^2(x)/d(xi)^2, d^2(y)/d(xi)^2, d^2(z)/d(xi)^2 
.PP
Definition at line 527 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdxi2(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdxideta_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of mixed second partial derivatives in xi-eta: d^2(x)/d(xi)d(eta) d^2(y)/d(xi)d(eta) d^2(z)/d(xi)d(eta) 
.PP
Definition at line 533 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdxideta(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdxidzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of second partial derivatives in xi-zeta: d^2(x)/d(xi)d(zeta), d^2(y)/d(xi)d(zeta), d^2(z)/d(xi)d(zeta) 
.PP
Definition at line 547 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdxidzeta(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::d2xyzdzeta2_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of second partial derivatives in zeta: d^2(x)/d(zeta)^2 
.PP
Definition at line 559 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_d2xyzdzeta2(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::detadx_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(eta)/d(x)\&. Needed for the Jacobian\&. 
.PP
Definition at line 586 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_detadx(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::detady_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(eta)/d(y)\&. Needed for the Jacobian\&. 
.PP
Definition at line 592 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_detady(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::detadz_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(eta)/d(z)\&. Needed for the Jacobian\&. 
.PP
Definition at line 598 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_detadz(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::dphideta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the derivative, d(phi)/d(eta)\&. 
.PP
Definition at line 632 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dphideta_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::dphidxi_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the derivative, d(phi)/d(xi)\&. 
.PP
Definition at line 627 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dphidxi_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::dphidzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the derivative, d(phi)/d(zeta)\&. 
.PP
Definition at line 637 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dphidzeta_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::dpsideta_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the derivative of the side function, d(psi)/d(eta)\&. 
.PP
Definition at line 688 of file fe_map\&.h\&.
.PP
Referenced by compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_dpsideta(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::dpsidxi_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the derivative of the side functions, d(psi)/d(xi)\&. 
.PP
Definition at line 682 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_dpsidxi(), libMesh::FEMap::init_edge_shape_functions(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dxidx_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(xi)/d(x)\&. Needed for the Jacobian\&. 
.PP
Definition at line 567 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dxidx(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dxidy_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(xi)/d(y)\&. Needed for the Jacobian\&. 
.PP
Definition at line 573 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dxidy(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dxidz_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(xi)/d(z)\&. Needed for the Jacobian\&. 
.PP
Definition at line 579 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dxidz(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::dxyzdeta_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of parital derivatives: d(x)/d(eta), d(y)/d(eta), d(z)/d(eta) 
.PP
Definition at line 515 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::dxdeta_map(), libMesh::FEMap::dydeta_map(), libMesh::FEMap::dzdeta_map(), libMesh::FEMap::get_dxyzdeta(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::dxyzdxi_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of parital derivatives: d(x)/d(xi), d(y)/d(xi), d(z)/d(xi) 
.PP
Definition at line 509 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::dxdxi_map(), libMesh::FEMap::dydxi_map(), libMesh::FEMap::dzdxi_map(), libMesh::FEMap::get_dxyzdxi(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBRealGradient\fP> libMesh::FEMap::dxyzdzeta_map\fC [protected]\fP, \fC [inherited]\fP"
Vector of parital derivatives: d(x)/d(zeta), d(y)/d(zeta), d(z)/d(zeta) 
.PP
Definition at line 521 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::dxdzeta_map(), libMesh::FEMap::dydzeta_map(), libMesh::FEMap::dzdzeta_map(), libMesh::FEMap::get_dxyzdzeta(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dzetadx_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(zeta)/d(x)\&. Needed for the Jacobian\&. 
.PP
Definition at line 605 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dzetadx(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dzetady_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(zeta)/d(y)\&. Needed for the Jacobian\&. 
.PP
Definition at line 611 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dzetady(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::dzetadz_map\fC [protected]\fP, \fC [inherited]\fP"
Map for partial derivatives: d(zeta)/d(z)\&. Needed for the Jacobian\&. 
.PP
Definition at line 617 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_dzetadz(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::jac\fC [protected]\fP, \fC [inherited]\fP"
Jacobian values at quadrature points 
.PP
Definition at line 731 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_jacobian(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBReal\fP> libMesh::FEMap::JxW\fC [protected]\fP, \fC [inherited]\fP"
Jacobian*Weight values at quadrature points 
.PP
Definition at line 736 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_JxW(), libMesh::FEMap::print_JxW(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.
.SS "std::vector<\fBPoint\fP> libMesh::FEMap::normals\fC [protected]\fP, \fC [inherited]\fP"
Normal vectors on boundary at quadrature points 
.PP
Definition at line 719 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::get_normals()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::phi_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the shape function phi\&. 
.PP
Definition at line 622 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_phi_map(), and libMesh::FEMap::init_reference_to_physical_map()\&.
.SS "std::vector<std::vector<\fBReal\fP> > libMesh::FEMap::psi_map\fC [protected]\fP, \fC [inherited]\fP"
Map for the side shape functions, psi\&. 
.PP
Definition at line 676 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::get_psi(), libMesh::FEMap::init_edge_shape_functions(), and libMesh::FEMap::init_face_shape_functions()\&.
.SS "std::vector<std::vector<\fBPoint\fP> > libMesh::FEMap::tangents\fC [protected]\fP, \fC [inherited]\fP"
Tangent vectors on boundary at quadrature points\&. 
.PP
Definition at line 714 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), and libMesh::FEMap::get_tangents()\&.
.SS "std::vector<\fBPoint\fP> libMesh::FEMap::xyz\fC [protected]\fP, \fC [inherited]\fP"
The spatial locations of the quadrature points 
.PP
Definition at line 503 of file fe_map\&.h\&.
.PP
Referenced by libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_edge_map(), compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::FEMap::compute_single_point_map(), libMesh::FEMap::get_xyz(), libMesh::FEMap::print_xyz(), and libMesh::FEMap::resize_quadrature_map_vectors()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
