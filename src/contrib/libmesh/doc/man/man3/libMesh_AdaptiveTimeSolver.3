.TH "libMesh::AdaptiveTimeSolver" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::AdaptiveTimeSolver \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <adaptive_time_solver\&.h>\fP
.PP
Inherits \fBlibMesh::UnsteadySolver\fP\&.
.PP
Inherited by \fBlibMesh::TwostepTimeSolver\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBUnsteadySolver\fP \fBParent\fP"
.br
.ti -1c
.RI "typedef \fBDifferentiableSystem\fP \fBsys_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAdaptiveTimeSolver\fP (\fBsys_type\fP &s)"
.br
.ti -1c
.RI "virtual \fB~AdaptiveTimeSolver\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBreinit\fP ()"
.br
.ti -1c
.RI "virtual void \fBsolve\fP ()=0"
.br
.ti -1c
.RI "virtual void \fBadvance_timestep\fP ()"
.br
.ti -1c
.RI "virtual \fBReal\fP \fBerror_order\fP () const "
.br
.ti -1c
.RI "virtual bool \fBelement_residual\fP (bool get_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual bool \fBside_residual\fP (bool get_jacobian, \fBDiffContext\fP &)"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBDiffSolver\fP > & \fBdiff_solver\fP ()"
.br
.ti -1c
.RI "virtual void \fBinit_data\fP ()"
.br
.ti -1c
.RI "virtual void \fBadjoint_advance_timestep\fP ()"
.br
.ti -1c
.RI "virtual void \fBretrieve_timestep\fP ()"
.br
.ti -1c
.RI "\fBNumber\fP \fBold_nonlinear_solution\fP (const \fBdof_id_type\fP global_dof_number) const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBdu\fP (const \fBSystemNorm\fP &norm) const "
.br
.ti -1c
.RI "virtual bool \fBis_steady\fP () const "
.br
.ti -1c
.RI "virtual void \fBbefore_timestep\fP ()"
.br
.ti -1c
.RI "const \fBsys_type\fP & \fBsystem\fP () const "
.br
.ti -1c
.RI "\fBsys_type\fP & \fBsystem\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBLinearSolver\fP
.br
< \fBNumber\fP > > & \fBlinear_solver\fP ()"
.br
.ti -1c
.RI "void \fBset_solution_history\fP (const \fBSolutionHistory\fP &_solution_history)"
.br
.ti -1c
.RI "bool \fBis_adjoint\fP () const "
.br
.ti -1c
.RI "void \fBset_is_adjoint\fP (bool _is_adjoint_value)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBUnsteadySolver\fP > \fBcore_time_solver\fP"
.br
.ti -1c
.RI "\fBSystemNorm\fP \fBcomponent_norm\fP"
.br
.ti -1c
.RI "std::vector< float > \fBcomponent_scale\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBtarget_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBupper_tolerance\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBmax_deltat\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBmin_deltat\fP"
.br
.ti -1c
.RI "\fBReal\fP \fBmax_growth\fP"
.br
.ti -1c
.RI "bool \fBglobal_tolerance\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBNumericVector\fP< \fBNumber\fP > > \fBold_local_nonlinear_solution\fP"
.br
.ti -1c
.RI "bool \fBquiet\fP"
.br
.ti -1c
.RI "unsigned int \fBreduce_deltat_on_diffsolver_failure\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBReal\fP \fBcalculate_norm\fP (\fBSystem\fP &, \fBNumericVector\fP< \fBNumber\fP > &)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBReal\fP \fBlast_deltat\fP"
.br
.ti -1c
.RI "bool \fBfirst_solve\fP"
.br
.ti -1c
.RI "bool \fBfirst_adjoint_step\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBDiffSolver\fP > \fB_diff_solver\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBLinearSolver\fP< \fBNumber\fP > > \fB_linear_solver\fP"
.br
.ti -1c
.RI "\fBsys_type\fP & \fB_system\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBSolutionHistory\fP > \fBsolution_history\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class wraps another \fBUnsteadySolver\fP derived class, and compares the results of timestepping with deltat and timestepping with 2*deltat to adjust future timestep lengths\&.
.PP
Currently this class only works on fully coupled Systems
.PP
This class is part of the new \fBDifferentiableSystem\fP framework, which is still experimental\&. Users of this framework should beware of bugs and future API changes\&.
.PP
\fBAuthor:\fP
.RS 4
Roy H\&. Stogner 2007 
.RE
.PP

.PP
Definition at line 51 of file adaptive_time_solver\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBUnsteadySolver\fP \fBlibMesh::AdaptiveTimeSolver::Parent\fP"
The parent class 
.PP
Definition at line 57 of file adaptive_time_solver\&.h\&.
.SS "typedef \fBDifferentiableSystem\fP \fBlibMesh::TimeSolver::sys_type\fP\fC [inherited]\fP"
The type of system 
.PP
Definition at line 66 of file time_solver\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::AdaptiveTimeSolver::AdaptiveTimeSolver (\fBsys_type\fP &s)\fC [explicit]\fP"
Constructor\&. Requires a reference to the system to be solved\&. 
.PP
Definition at line 27 of file adaptive_time_solver\&.C\&.
.PP
References libMesh::UnsteadySolver::old_local_nonlinear_solution\&.
.PP
.nf
28   : UnsteadySolver(s),
29     core_time_solver(NULL),
30     target_tolerance(1\&.e-3), upper_tolerance(0\&.0),
31     max_deltat(0\&.),
32     min_deltat(0\&.),
33     max_growth(0\&.),
34     global_tolerance(true)
35 {
36   // the child class must populate core_time_solver
37   // with whatever actual time solver is to be used
38 
39   // As an UnsteadySolver, we have an old_local_nonlinear_solution, but we're
40   // going to drop it and use our core time solver's instead\&.
41   old_local_nonlinear_solution\&.reset();
42 }
.fi
.SS "libMesh::AdaptiveTimeSolver::~AdaptiveTimeSolver ()\fC [virtual]\fP"
Destructor\&. 
.PP
Definition at line 46 of file adaptive_time_solver\&.C\&.
.PP
References libMesh::UnsteadySolver::old_local_nonlinear_solution\&.
.PP
.nf
47 {
48   // As an UnsteadySolver, we have an old_local_nonlinear_solution, but it
49   // is being managed by our core_time_solver\&.  Make sure we don't delete
50   // it out from under them, in case the user wants to keep using the core
51   // solver after they're done with us\&.
52   old_local_nonlinear_solution\&.release();
53 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::UnsteadySolver::adjoint_advance_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method advances the adjoint solution to the previous timestep, after an adjoint_solve() has been performed\&. This will be done before every UnsteadySolver::adjoint_solve()\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 178 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::DifferentiableSystem::deltat, libMesh::UnsteadySolver::first_adjoint_step, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::NumericVector< T >::localize(), libMesh::UnsteadySolver::old_local_nonlinear_solution, libMesh::TimeSolver::solution_history, and libMesh::System::time\&.
.PP
.nf
179 {
180   // On the first call of this function, we dont save the adjoint solution or
181   // decrement the time, we just call the retrieve function below
182   if(!first_adjoint_step)
183     {
184       // Call the store function to store the last adjoint before decrementing the time
185       solution_history->store();
186       // Decrement the system time
187       _system\&.time -= _system\&.deltat;
188     }
189   else
190     {
191       first_adjoint_step = false;
192     }
193 
194   // Retrieve the primal solution vectors at this time using the
195   // solution_history object
196   solution_history->retrieve();
197 
198   // Dont forget to localize the old_nonlinear_solution !
199   _system\&.get_vector("_old_nonlinear_solution")\&.localize
200     (*old_local_nonlinear_solution,
201      _system\&.get_dof_map()\&.get_send_list());
202 }
.fi
.SS "void libMesh::AdaptiveTimeSolver::advance_timestep ()\fC [virtual]\fP"
This method advances the solution to the next timestep, after a \fBsolve()\fP has been performed\&. Often this will be done after every \fBUnsteadySolver::solve()\fP, but adaptive mesh refinement and/or adaptive time step selection may require some \fBsolve()\fP steps to be repeated\&. 
.PP
Reimplemented from \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 86 of file adaptive_time_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::UnsteadySolver::first_solve, libMesh::System::get_vector(), last_deltat, libMesh::System::solution, and libMesh::System::time\&.
.PP
.nf
87 {
88   NumericVector<Number> &old_nonlinear_soln =
89     _system\&.get_vector("_old_nonlinear_solution");
90   NumericVector<Number> &nonlinear_solution =
91     *(_system\&.solution);
92   //    _system\&.get_vector("_nonlinear_solution");
93 
94   old_nonlinear_soln = nonlinear_solution;
95 
96   if (!first_solve)
97     _system\&.time += last_deltat;
98 }
.fi
.SS "virtual void libMesh::TimeSolver::before_timestep ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This method is for subclasses or users to override to do arbitrary processing between timesteps 
.PP
Definition at line 152 of file time_solver\&.h\&.
.PP
.nf
152 {}
.fi
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::calculate_norm (\fBSystem\fP &s, \fBNumericVector\fP< \fBNumber\fP > &v)\fC [protected]\fP, \fC [virtual]\fP"
A helper function to calculate error norms 
.PP
Definition at line 138 of file adaptive_time_solver\&.C\&.
.PP
References libMesh::System::calculate_norm(), and component_norm\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.PP
.nf
140 {
141   return s\&.calculate_norm(v, component_norm);
142 }
.fi
.SS "\fBAutoPtr\fP< \fBDiffSolver\fP > & libMesh::AdaptiveTimeSolver::diff_solver ()\fC [virtual]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 131 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver\&.
.PP
.nf
132 {
133   return core_time_solver->diff_solver();
134 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "\fBReal\fP libMesh::UnsteadySolver::du (const \fBSystemNorm\fP &norm) const\fC [virtual]\fP, \fC [inherited]\fP"
Computes the size of ||u^{n+1} - u^{n}|| in some norm\&.
.PP
Note that, while you can always call this function, its result may or may not be very meaningful\&. For example, if you call this function right after calling \fBadvance_timestep()\fP then you'll get a result of zero since old_nonlinear_solution is set equal to nonlinear_solution in this function\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 227 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::calculate_norm(), libMesh::System::get_vector(), and libMesh::System::solution\&.
.PP
.nf
228 {
229 
230   AutoPtr<NumericVector<Number> > solution_copy =
231     _system\&.solution->clone();
232 
233   solution_copy->add(-1\&., _system\&.get_vector("_old_nonlinear_solution"));
234 
235   solution_copy->close();
236 
237   return _system\&.calculate_norm(*solution_copy, norm);
238 }
.fi
.SS "bool libMesh::AdaptiveTimeSolver::element_residual (boolget_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
This method is passed on to the core_time_solver 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 111 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver, and libMesh::libmesh_assert()\&.
.PP
.nf
113 {
114   libmesh_assert(core_time_solver\&.get());
115 
116   return core_time_solver->element_residual(request_jacobian, context);
117 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::error_order () const\fC [virtual]\fP"
This method is passed on to the core_time_solver 
.PP
Implements \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 102 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver, and libMesh::libmesh_assert()\&.
.PP
.nf
103 {
104   libmesh_assert(core_time_solver\&.get());
105 
106   return core_time_solver->error_order();
107 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::AdaptiveTimeSolver::init ()\fC [virtual]\fP"
The initialization function\&. This method is used to initialize internal data structures before a simulation begins\&. 
.PP
Reimplemented from \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 57 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver, libMesh::libmesh_assert(), and libMesh::UnsteadySolver::old_local_nonlinear_solution\&.
.PP
.nf
58 {
59   libmesh_assert(core_time_solver\&.get());
60 
61   // We override this because our core_time_solver is the one that
62   // needs to handle new vectors, diff_solver->init(), etc
63   core_time_solver->init();
64 
65   // As an UnsteadySolver, we have an old_local_nonlinear_solution, but it
66   // isn't pointing to the right place - fix it
67   //
68   // This leaves us with two AutoPtrs holding the same pointer - dangerous
69   // for future use\&.  Replace with shared_ptr?
70   old_local_nonlinear_solution =
71     AutoPtr<NumericVector<Number> >(core_time_solver->old_local_nonlinear_solution\&.get());
72 }
.fi
.SS "void libMesh::UnsteadySolver::init_data ()\fC [virtual]\fP, \fC [inherited]\fP"
The data initialization function\&. This method is used to initialize internal data structures after the underlying \fBSystem\fP has been initialized 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 55 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::GHOSTED, libMesh::TimeSolver::init_data(), libMesh::System::n_dofs(), libMesh::System::n_local_dofs(), libMesh::UnsteadySolver::old_local_nonlinear_solution, and libMesh::SERIAL\&.
.PP
.nf
56 {
57   TimeSolver::init_data();
58 
59 #ifdef LIBMESH_ENABLE_GHOSTED
60   old_local_nonlinear_solution->init (_system\&.n_dofs(), _system\&.n_local_dofs(),
61                                       _system\&.get_dof_map()\&.get_send_list(), false,
62                                       GHOSTED);
63 #else
64   old_local_nonlinear_solution->init (_system\&.n_dofs(), false, SERIAL);
65 #endif
66 }
.fi
.SS "bool libMesh::TimeSolver::is_adjoint () const\fC [inline]\fP, \fC [inherited]\fP"
Accessor for querying whether we need to do a primal or adjoint solve 
.PP
Definition at line 217 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::FEMSystem::build_context()\&.
.PP
.nf
218   { return _is_adjoint; }
.fi
.SS "virtual bool libMesh::UnsteadySolver::is_steady () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
This is not a steady-state solver\&. 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 149 of file unsteady_solver\&.h\&.
.PP
.nf
149 { return false; }
.fi
.SS "virtual \fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> >& libMesh::TimeSolver::linear_solver ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint and sensitivity problems\&. 
.PP
Definition at line 172 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_linear_solver\&.
.PP
.nf
172 { return _linear_solver; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "\fBNumber\fP libMesh::UnsteadySolver::old_nonlinear_solution (const \fBdof_id_type\fPglobal_dof_number) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the old nonlinear solution for the specified global DOF\&. 
.RE
.PP

.PP
Definition at line 216 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::n_dofs(), and libMesh::UnsteadySolver::old_local_nonlinear_solution\&.
.PP
Referenced by libMesh::EulerSolver::element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::EulerSolver::side_residual(), and libMesh::Euler2Solver::side_residual()\&.
.PP
.nf
218 {
219   libmesh_assert_less (global_dof_number, _system\&.get_dof_map()\&.n_dofs());
220   libmesh_assert_less (global_dof_number, old_local_nonlinear_solution->size());
221 
222   return (*old_local_nonlinear_solution)(global_dof_number);
223 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::AdaptiveTimeSolver::reinit ()\fC [virtual]\fP"
The reinitialization function\&. This method is used to resize internal data vectors after a mesh change\&. 
.PP
Reimplemented from \fBlibMesh::UnsteadySolver\fP\&.
.PP
Definition at line 76 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver, and libMesh::libmesh_assert()\&.
.PP
.nf
77 {
78   libmesh_assert(core_time_solver\&.get());
79 
80   // We override this because our core_time_solver is the one that
81   // needs to handle new vectors, diff_solver->reinit(), etc
82   core_time_solver->reinit();
83 }
.fi
.SS "void libMesh::UnsteadySolver::retrieve_timestep ()\fC [virtual]\fP, \fC [inherited]\fP"
This method retrieves all the stored solutions at the current system\&.time 
.PP
Reimplemented from \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 204 of file unsteady_solver\&.C\&.
.PP
References libMesh::TimeSolver::_system, libMesh::System::get_dof_map(), libMesh::DofMap::get_send_list(), libMesh::System::get_vector(), libMesh::NumericVector< T >::localize(), libMesh::UnsteadySolver::old_local_nonlinear_solution, and libMesh::TimeSolver::solution_history\&.
.PP
.nf
205 {
206   // Retrieve all the stored vectors at the current time
207   solution_history->retrieve();
208 
209   // Dont forget to localize the old_nonlinear_solution !
210   _system\&.get_vector("_old_nonlinear_solution")\&.localize
211     (*old_local_nonlinear_solution,
212      _system\&.get_dof_map()\&.get_send_list());
213 }
.fi
.SS "void libMesh::TimeSolver::set_is_adjoint (bool_is_adjoint_value)\fC [inline]\fP, \fC [inherited]\fP"
Accessor for setting whether we need to do a primal or adjoint solve 
.PP
Definition at line 224 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_is_adjoint\&.
.PP
Referenced by libMesh::DifferentiableSystem::adjoint_solve(), libMesh::FEMSystem::postprocess(), and libMesh::DifferentiableSystem::solve()\&.
.PP
.nf
225   { _is_adjoint = _is_adjoint_value; }
.fi
.SS "void libMesh::TimeSolver::set_solution_history (const \fBSolutionHistory\fP &_solution_history)\fC [inherited]\fP"
A setter function users will employ if they need to do something other than save no solution history 
.PP
Definition at line 97 of file time_solver\&.C\&.
.PP
References libMesh::SolutionHistory::clone(), and libMesh::TimeSolver::solution_history\&.
.PP
.nf
98 {
99   solution_history = _solution_history\&.clone();
100 }
.fi
.SS "bool libMesh::AdaptiveTimeSolver::side_residual (boolget_jacobian, \fBDiffContext\fP &context)\fC [virtual]\fP"
This method is passed on to the core_time_solver 
.PP
Implements \fBlibMesh::TimeSolver\fP\&.
.PP
Definition at line 121 of file adaptive_time_solver\&.C\&.
.PP
References core_time_solver, and libMesh::libmesh_assert()\&.
.PP
.nf
123 {
124   libmesh_assert(core_time_solver\&.get());
125 
126   return core_time_solver->side_residual(request_jacobian, context);
127 }
.fi
.SS "virtual void libMesh::AdaptiveTimeSolver::solve ()\fC [pure virtual]\fP"
This method solves for the solution at the next timestep\&. Usually we will only need to solve one (non)linear system per timestep, but more complex subclasses may override this\&. 
.PP
Reimplemented from \fBlibMesh::UnsteadySolver\fP\&.
.PP
Implemented in \fBlibMesh::TwostepTimeSolver\fP\&.
.SS "const \fBsys_type\fP& libMesh::TimeSolver::system () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a constant reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 157 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
Referenced by libMesh::TimeSolver::reinit(), and libMesh::TimeSolver::solve()\&.
.PP
.nf
157 { return _system; }
.fi
.SS "\fBsys_type\fP& libMesh::TimeSolver::system ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable reference to the system we are solving\&. 
.RE
.PP

.PP
Definition at line 162 of file time_solver\&.h\&.
.PP
References libMesh::TimeSolver::_system\&.
.PP
.nf
162 { return _system; }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBAutoPtr\fP<\fBDiffSolver\fP> libMesh::TimeSolver::_diff_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear or nonlinear solver to use at each timestep\&. 
.PP
Definition at line 232 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::diff_solver(), libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::solve(), and libMesh::TimeSolver::solve()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBAutoPtr\fP<\fBLinearSolver\fP<\fBNumber\fP> > libMesh::TimeSolver::_linear_solver\fC [protected]\fP, \fC [inherited]\fP"
An implicit linear solver to use for adjoint problems\&. 
.PP
Definition at line 237 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TimeSolver::init(), libMesh::TimeSolver::init_data(), libMesh::TimeSolver::linear_solver(), and libMesh::TimeSolver::reinit()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBsys_type\fP& libMesh::TimeSolver::_system\fC [protected]\fP, \fC [inherited]\fP"
A reference to the system we are solving\&. 
.PP
Definition at line 242 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::du(), libMesh::EulerSolver::element_residual(), libMesh::Euler2Solver::element_residual(), libMesh::SteadySolver::element_residual(), libMesh::EigenTimeSolver::element_residual(), libMesh::UnsteadySolver::init(), libMesh::TimeSolver::init(), libMesh::EigenTimeSolver::init(), libMesh::UnsteadySolver::init_data(), libMesh::TimeSolver::init_data(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::UnsteadySolver::reinit(), libMesh::TimeSolver::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), libMesh::EulerSolver::side_residual(), libMesh::Euler2Solver::side_residual(), libMesh::SteadySolver::side_residual(), libMesh::EigenTimeSolver::side_residual(), libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), libMesh::EigenTimeSolver::solve(), and libMesh::TimeSolver::system()\&.
.SS "\fBSystemNorm\fP libMesh::AdaptiveTimeSolver::component_norm"
Error calculations are done in this norm, DISCRETE_L2 by default\&. 
.PP
Definition at line 109 of file adaptive_time_solver\&.h\&.
.PP
Referenced by calculate_norm()\&.
.SS "std::vector<float> libMesh::AdaptiveTimeSolver::component_scale"
If component_norms is non-empty, each variable's contribution to the error of a system will also be scaled by component_scale[var], unless component_scale is empty in which case all variables will be weighted equally\&. 
.PP
Definition at line 117 of file adaptive_time_solver\&.h\&.
.SS "\fBAutoPtr\fP<\fBUnsteadySolver\fP> libMesh::AdaptiveTimeSolver::core_time_solver"
This object is used to take timesteps 
.PP
Definition at line 104 of file adaptive_time_solver\&.h\&.
.PP
Referenced by diff_solver(), element_residual(), error_order(), init(), reinit(), side_residual(), libMesh::TwostepTimeSolver::solve(), and libMesh::TwostepTimeSolver::TwostepTimeSolver()\&.
.SS "bool libMesh::UnsteadySolver::first_adjoint_step\fC [protected]\fP, \fC [inherited]\fP"
A bool that will be true the first time \fBadjoint_advance_timestep()\fP is called, (when the primal solution is to be used to set adjoint boundary conditions) and false thereafter 
.PP
Definition at line 163 of file unsteady_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep()\&.
.SS "bool libMesh::UnsteadySolver::first_solve\fC [protected]\fP, \fC [inherited]\fP"
A bool that will be true the first time \fBsolve()\fP is called, and false thereafter 
.PP
Definition at line 157 of file unsteady_solver\&.h\&.
.PP
Referenced by advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::TwostepTimeSolver::solve(), and libMesh::UnsteadySolver::solve()\&.
.SS "bool libMesh::AdaptiveTimeSolver::global_tolerance"
This flag, which is true by default, grows (shrinks) the timestep based on the expected global accuracy of the timestepping scheme\&. Global in this sense means the cumulative final-time accuracy of the scheme\&. For example, the backward Euler scheme's truncation error is locally of order 2, so that after N timesteps of size deltat, the result is first-order accurate\&. If you set this to false, you can grow (shrink) your timestep based on the local accuracy rather than the global accuracy of the core \fBTimeSolver\fP\&. Note that by setting this value to false you may fail to achieve the predicted convergence in time of the underlying method, however it may be possible to get more fine-grained control over step sizes as well\&. 
.PP
Definition at line 187 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::last_deltat\fC [protected]\fP"
We need to store the value of the last deltat used, so that \fBadvance_timestep()\fP will increment the system time correctly\&. 
.PP
Definition at line 196 of file adaptive_time_solver\&.h\&.
.PP
Referenced by advance_timestep(), and libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::max_deltat"
Do not allow the adaptive time solver to select deltat > max_deltat\&. If you use the default max_deltat=0\&.0, then deltat is unlimited\&. 
.PP
Definition at line 157 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::max_growth"
Do not allow the adaptive time solver to select a new deltat greater than max_growth times the old deltat\&. If you use the default max_growth=0\&.0, then the deltat growth is unlimited\&. 
.PP
Definition at line 171 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::min_deltat"
Do not allow the adaptive time solver to select deltat < min_deltat\&. The default value is 0\&.0\&. 
.PP
Definition at line 163 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBAutoPtr\fP<\fBNumericVector\fP<\fBNumber\fP> > libMesh::UnsteadySolver::old_local_nonlinear_solution\fC [inherited]\fP"
Serial vector of _system\&.get_vector('_old_nonlinear_solution') 
.PP
Definition at line 133 of file unsteady_solver\&.h\&.
.PP
Referenced by AdaptiveTimeSolver(), libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), init(), libMesh::UnsteadySolver::init_data(), libMesh::UnsteadySolver::old_nonlinear_solution(), libMesh::UnsteadySolver::reinit(), libMesh::UnsteadySolver::retrieve_timestep(), and ~AdaptiveTimeSolver()\&.
.SS "bool libMesh::TimeSolver::quiet\fC [inherited]\fP"
Print extra debugging information if quiet == false\&. 
.PP
Definition at line 177 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), libMesh::UnsteadySolver::solve(), and libMesh::EigenTimeSolver::solve()\&.
.SS "unsigned int libMesh::TimeSolver::reduce_deltat_on_diffsolver_failure\fC [inherited]\fP"
This value (which defaults to zero) is the number of times the \fBTimeSolver\fP is allowed to halve deltat and let the \fBDiffSolver\fP repeat the latest failed solve with a reduced timestep\&. Note that this has no effect for SteadySolvers\&. Note that you must set at least one of the \fBDiffSolver\fP flags 'continue_after_max_iterations' or 'continue_after_backtrack_failure' to allow the \fBTimeSolver\fP to retry the solve\&. 
.PP
Definition at line 205 of file time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve(), and libMesh::UnsteadySolver::solve()\&.
.SS "\fBAutoPtr\fP<\fBSolutionHistory\fP> libMesh::TimeSolver::solution_history\fC [protected]\fP, \fC [inherited]\fP"
An \fBAutoPtr\fP to a \fBSolutionHistory\fP object\&. Default is \fBNoSolutionHistory\fP, which the user can override by declaring a different kind of \fBSolutionHistory\fP in the application 
.PP
Definition at line 260 of file time_solver\&.h\&.
.PP
Referenced by libMesh::UnsteadySolver::adjoint_advance_timestep(), libMesh::UnsteadySolver::advance_timestep(), libMesh::UnsteadySolver::retrieve_timestep(), and libMesh::TimeSolver::set_solution_history()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::target_tolerance"
This tolerance is the target relative error between an exact time integration and a single time step output, scaled by deltat\&. integrator, scaled by deltat\&. If the estimated error exceeds or undershoots the target error tolerance, future timesteps will be run with deltat shrunk or grown to compensate\&.
.PP
The default value is 1\&.0e-2; obviously users should select their own tolerance\&.
.PP
If a \fInegative\fP target_tolerance is specified, then its absolute value is used to scale the estimated error from the first simulation time step, and this becomes the target tolerance of all future time steps\&. 
.PP
Definition at line 134 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.
.SS "\fBReal\fP libMesh::AdaptiveTimeSolver::upper_tolerance"
This tolerance is the maximum relative error between an exact time integration and a single time step output, scaled by deltat\&. If this error tolerance is exceeded by the estimated error of the current time step, that time step will be repeated with a smaller deltat\&.
.PP
If you use the default upper_tolerance=0\&.0, then the current time step will not be repeated regardless of estimated error\&.
.PP
If a \fInegative\fP upper_tolerance is specified, then its absolute value is used to scale the estimated error from the first simulation time step, and this becomes the upper tolerance of all future time steps\&. 
.PP
Definition at line 151 of file adaptive_time_solver\&.h\&.
.PP
Referenced by libMesh::TwostepTimeSolver::solve()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
