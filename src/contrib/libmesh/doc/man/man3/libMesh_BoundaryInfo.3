.TH "libMesh::BoundaryInfo" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::BoundaryInfo \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <boundary_info\&.h>\fP
.PP
Inherits \fBlibMesh::ParallelObject\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBFill\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBoundaryInfo\fP & \fBoperator=\fP (const \fBBoundaryInfo\fP &other_boundary_info)"
.br
.ti -1c
.RI "\fB~BoundaryInfo\fP ()"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBsync\fP (\fBUnstructuredMesh\fP &boundary_mesh, \fBMeshData\fP *boundary_mesh_data=NULL, \fBMeshData\fP *this_mesh_data=NULL)"
.br
.ti -1c
.RI "void \fBsync\fP (const std::set< \fBboundary_id_type\fP > &requested_boundary_ids, \fBUnstructuredMesh\fP &boundary_mesh, \fBMeshData\fP *boundary_mesh_data=NULL, \fBMeshData\fP *this_mesh_data=NULL)"
.br
.ti -1c
.RI "void \fBadd_node\fP (const \fBNode\fP *node, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_node\fP (const \fBdof_id_type\fP node, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_node\fP (const \fBNode\fP *node, const std::vector< \fBboundary_id_type\fP > &ids)"
.br
.ti -1c
.RI "void \fBclear_boundary_node_ids\fP ()"
.br
.ti -1c
.RI "void \fBadd_edge\fP (const \fBdof_id_type\fP elem, const unsigned short int edge, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_edge\fP (const \fBElem\fP *elem, const unsigned short int edge, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_edge\fP (const \fBElem\fP *elem, const unsigned short int edge, const std::vector< \fBboundary_id_type\fP > &ids)"
.br
.ti -1c
.RI "void \fBadd_side\fP (const \fBdof_id_type\fP elem, const unsigned short int \fBside\fP, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_side\fP (const \fBElem\fP *elem, const unsigned short int \fBside\fP, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBadd_side\fP (const \fBElem\fP *elem, const unsigned short int \fBside\fP, const std::vector< \fBboundary_id_type\fP > &ids)"
.br
.ti -1c
.RI "void \fBremove\fP (const \fBNode\fP *node)"
.br
.ti -1c
.RI "void \fBremove\fP (const \fBElem\fP *elem)"
.br
.ti -1c
.RI "void \fBremove_edge\fP (const \fBElem\fP *elem, const unsigned short int edge)"
.br
.ti -1c
.RI "void \fBremove_edge\fP (const \fBElem\fP *elem, const unsigned short int edge, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "void \fBremove_side\fP (const \fBElem\fP *elem, const unsigned short int \fBside\fP)"
.br
.ti -1c
.RI "void \fBremove_side\fP (const \fBElem\fP *elem, const unsigned short int \fBside\fP, const \fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "std::size_t \fBn_boundary_ids\fP () const "
.br
.ti -1c
.RI "bool \fBhas_boundary_id\fP (const \fBNode\fP *const node, const \fBboundary_id_type\fP id) const "
.br
.ti -1c
.RI "std::vector< \fBboundary_id_type\fP > \fBboundary_ids\fP (const \fBNode\fP *node) const "
.br
.ti -1c
.RI "unsigned int \fBn_boundary_ids\fP (const \fBNode\fP *node) const "
.br
.ti -1c
.RI "unsigned int \fBn_edge_boundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int edge) const "
.br
.ti -1c
.RI "std::vector< \fBboundary_id_type\fP > \fBedge_boundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int edge) const "
.br
.ti -1c
.RI "std::vector< \fBboundary_id_type\fP > \fBraw_edge_boundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int edge) const "
.br
.ti -1c
.RI "bool \fBhas_boundary_id\fP (const \fBElem\fP *const elem, const unsigned short int \fBside\fP, const \fBboundary_id_type\fP id) const "
.br
.ti -1c
.RI "\fBboundary_id_type\fP \fBboundary_id\fP (const \fBElem\fP *const elem, const unsigned short int \fBside\fP) const "
.br
.ti -1c
.RI "unsigned int \fBn_boundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int \fBside\fP) const "
.br
.ti -1c
.RI "std::vector< \fBboundary_id_type\fP > \fBboundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int \fBside\fP) const "
.br
.ti -1c
.RI "std::vector< \fBboundary_id_type\fP > \fBraw_boundary_ids\fP (const \fBElem\fP *const elem, const unsigned short int \fBside\fP) const "
.br
.ti -1c
.RI "unsigned int \fBside_with_boundary_id\fP (const \fBElem\fP *const elem, const \fBboundary_id_type\fP \fBboundary_id\fP) const "
.br
.ti -1c
.RI "void \fBbuild_node_boundary_ids\fP (std::vector< \fBboundary_id_type\fP > &b_ids)"
.br
.ti -1c
.RI "void \fBbuild_side_boundary_ids\fP (std::vector< \fBboundary_id_type\fP > &b_ids)"
.br
.ti -1c
.RI "std::size_t \fBn_boundary_conds\fP () const "
.br
.ti -1c
.RI "std::size_t \fBn_edge_conds\fP () const "
.br
.ti -1c
.RI "std::size_t \fBn_nodeset_conds\fP () const "
.br
.ti -1c
.RI "void \fBbuild_node_list\fP (std::vector< \fBdof_id_type\fP > &node_id_list, std::vector< \fBboundary_id_type\fP > &bc_id_list) const "
.br
.ti -1c
.RI "void \fBbuild_node_list_from_side_list\fP ()"
.br
.ti -1c
.RI "void \fBbuild_side_list_from_node_list\fP ()"
.br
.ti -1c
.RI "void \fBbuild_side_list\fP (std::vector< \fBdof_id_type\fP > &element_id_list, std::vector< unsigned short int > &side_list, std::vector< \fBboundary_id_type\fP > &bc_id_list) const "
.br
.ti -1c
.RI "const std::set
.br
< \fBboundary_id_type\fP > & \fBget_boundary_ids\fP () const "
.br
.ti -1c
.RI "const std::set
.br
< \fBboundary_id_type\fP > & \fBget_side_boundary_ids\fP () const "
.br
.ti -1c
.RI "const std::set
.br
< \fBboundary_id_type\fP > & \fBget_edge_boundary_ids\fP () const "
.br
.ti -1c
.RI "const std::set
.br
< \fBboundary_id_type\fP > & \fBget_node_boundary_ids\fP () const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "void \fBprint_summary\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "std::string & \fBsideset_name\fP (\fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "std::string & \fBnodeset_name\fP (\fBboundary_id_type\fP id)"
.br
.ti -1c
.RI "\fBboundary_id_type\fP \fBget_id_by_name\fP (const std::string &name) const "
.br
.ti -1c
.RI "std::map< \fBboundary_id_type\fP, 
.br
std::string > & \fBset_sideset_name_map\fP ()"
.br
.ti -1c
.RI "const std::map
.br
< \fBboundary_id_type\fP, 
.br
std::string > & \fBget_sideset_name_map\fP () const "
.br
.ti -1c
.RI "std::map< \fBboundary_id_type\fP, 
.br
std::string > & \fBset_nodeset_name_map\fP ()"
.br
.ti -1c
.RI "const std::map
.br
< \fBboundary_id_type\fP, 
.br
std::string > & \fBget_nodeset_name_map\fP () const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const \fBboundary_id_type\fP \fBinvalid_id\fP = -123"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBBoundaryInfo\fP (const \fBMeshBase\fP &m)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "const \fBMeshBase\fP & \fB_mesh\fP"
.br
.ti -1c
.RI "std::multimap< const \fBNode\fP 
.br
*, \fBboundary_id_type\fP > \fB_boundary_node_id\fP"
.br
.ti -1c
.RI "std::multimap< const \fBElem\fP 
.br
*, std::pair< unsigned short 
.br
int, \fBboundary_id_type\fP > > \fB_boundary_edge_id\fP"
.br
.ti -1c
.RI "std::multimap< const \fBElem\fP 
.br
*, std::pair< unsigned short 
.br
int, \fBboundary_id_type\fP > > \fB_boundary_side_id\fP"
.br
.ti -1c
.RI "std::set< \fBboundary_id_type\fP > \fB_boundary_ids\fP"
.br
.ti -1c
.RI "std::set< \fBboundary_id_type\fP > \fB_side_boundary_ids\fP"
.br
.ti -1c
.RI "std::set< \fBboundary_id_type\fP > \fB_edge_boundary_ids\fP"
.br
.ti -1c
.RI "std::set< \fBboundary_id_type\fP > \fB_node_boundary_ids\fP"
.br
.ti -1c
.RI "std::map< \fBboundary_id_type\fP, 
.br
std::string > \fB_ss_id_to_name\fP"
.br
.ti -1c
.RI "std::map< \fBboundary_id_type\fP, 
.br
std::string > \fB_ns_id_to_name\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBMeshBase\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBBoundaryInfo\fP\fP class contains information relevant to boundary conditions: it does not hold actual boundary condition data (check \fC\fBMeshData\fP\fP for that), but can mark element faces and nodes with ids useful for identifying the type of boundary condtion\&. It can also build a mesh that just includes boundary elements/faces\&.
.PP
TODO[JWP]: Generalize this to work with \fBMeshBase\fP again\&. 
.PP
Definition at line 59 of file boundary_info\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::BoundaryInfo::BoundaryInfo (const \fBMeshBase\fP &m)\fC [protected]\fP"
Constructor\&. Takes a reference to the mesh\&. The \fBBoundaryInfo\fP class is only used internally by the \fBMesh\fP class\&. A user should never instantiate this class\&. Therefore the constructor is protected\&. 
.PP
Definition at line 46 of file boundary_info\&.C\&.
.PP
.nf
46                                             :
47   ParallelObject(m\&.comm()),
48   _mesh (m)
49 {
50 }
.fi
.SS "libMesh::BoundaryInfo::~BoundaryInfo ()"
Destructor\&. Not much to do\&. 
.PP
Definition at line 114 of file boundary_info\&.C\&.
.PP
References clear()\&.
.PP
.nf
115 {
116   this->clear();
117 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::BoundaryInfo::add_edge (const \fBdof_id_type\fPelem, const unsigned short intedge, const \fBboundary_id_type\fPid)"
Add edge \fCedge\fP of element number \fCelem\fP with boundary id \fCid\fP to the boundary information data structure\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 609 of file boundary_info\&.C\&.
.PP
References _mesh, and libMesh::MeshBase::elem()\&.
.PP
.nf
612 {
613   this->add_edge (_mesh\&.elem(e), edge, id);
614 }
.fi
.SS "void libMesh::BoundaryInfo::add_edge (const \fBElem\fP *elem, const unsigned short intedge, const \fBboundary_id_type\fPid)"
Add edge \fCedge\fP of element \fCelem\fP with boundary id \fCid\fP to the boundary information data structure\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 618 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _boundary_ids, _edge_boundary_ids, libMesh::err, invalid_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
621 {
622   libmesh_assert(elem);
623 
624   // Only add BCs for level-0 elements\&.
625   libmesh_assert_equal_to (elem->level(), 0);
626 
627   if (id == invalid_id)
628     {
629       libMesh::err << "ERROR: You may not set a boundary ID of "
630                    << invalid_id << std::endl
631                    << " That is reserved for internal use\&.\n"
632                    << std::endl;
633 
634       libmesh_error();
635     }
636 
637   // A convenient typedef
638   typedef std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
639     const_iterator Iter;
640 
641   // Don't add the same ID twice
642   std::pair<Iter, Iter> pos = _boundary_edge_id\&.equal_range(elem);
643 
644   for (;pos\&.first != pos\&.second; ++pos\&.first)
645     if (pos\&.first->second\&.first == edge &&
646         pos\&.first->second\&.second == id)
647       return;
648 
649   std::pair<unsigned short int, boundary_id_type> p(edge,id);
650   std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
651     kv (elem, p);
652 
653   _boundary_edge_id\&.insert(kv);
654   _boundary_ids\&.insert(id);
655   _edge_boundary_ids\&.insert(id); // Also add this ID to the set of edge boundary IDs
656 }
.fi
.SS "void libMesh::BoundaryInfo::add_edge (const \fBElem\fP *elem, const unsigned short intedge, const std::vector< \fBboundary_id_type\fP > &ids)"
Add edge \fCedge\fP of element \fCelem\fP with boundary ids \fCids\fP to the boundary information data structure\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 660 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _boundary_ids, _edge_boundary_ids, libMesh::err, invalid_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
663 {
664   if (ids\&.empty())
665     return;
666 
667   libmesh_assert(elem);
668 
669   // Only add BCs for level-0 elements\&.
670   libmesh_assert_equal_to (elem->level(), 0);
671 
672   // A convenient typedef
673   typedef std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
674     const_iterator Iter;
675 
676   // Don't add the same ID twice
677   std::pair<Iter, Iter> pos = _boundary_edge_id\&.equal_range(elem);
678 
679   for (unsigned int i=0; i!= ids\&.size(); ++i)
680     {
681       boundary_id_type id=ids[i];
682 
683       if (id == invalid_id)
684         {
685           libMesh::err << "ERROR: You may not set a boundary ID of "
686                        << invalid_id << std::endl
687                        << " That is reserved for internal use\&.\n"
688                        << std::endl;
689 
690           libmesh_error();
691         }
692 
693       bool already_inserted = false;
694       for (Iter p = pos\&.first;p != pos\&.second; ++p)
695         if (p->second\&.first == edge &&
696             p->second\&.second == id)
697           {
698             already_inserted = true;
699             break;
700           }
701       if (already_inserted)
702         continue;
703 
704       std::pair<unsigned short int, boundary_id_type> p(edge,id);
705       std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
706         kv (elem, p);
707 
708       _boundary_edge_id\&.insert(kv);
709       _boundary_ids\&.insert(id);
710       _edge_boundary_ids\&.insert(id); // Also add this ID to the set of edge boundary IDs
711     }
712 }
.fi
.SS "void libMesh::BoundaryInfo::add_node (const \fBNode\fP *node, const \fBboundary_id_type\fPid)"
Add \fC\fBNode\fP\fP \fCnode\fP with boundary id \fCid\fP to the boundary information data structures\&. 
.PP
Definition at line 527 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _boundary_node_id, _node_boundary_ids, libMesh::err, and invalid_id\&.
.PP
Referenced by add_node(), build_node_list_from_side_list(), libMesh::CheckpointIO::read_nodesets(), and libMesh::XdrIO::read_serialized_nodesets()\&.
.PP
.nf
529 {
530   if (id == invalid_id)
531     {
532       libMesh::err << "ERROR: You may not set a boundary ID of "
533                    << invalid_id << std::endl
534                    << " That is reserved for internal use\&.\n"
535                    << std::endl;
536 
537       libmesh_error();
538     }
539 
540   // A convenient typedef
541   typedef std::multimap<const Node*, boundary_id_type>::const_iterator Iter;
542 
543   // Don't add the same ID twice
544   std::pair<Iter, Iter> pos = _boundary_node_id\&.equal_range(node);
545 
546   for (;pos\&.first != pos\&.second; ++pos\&.first)
547     if (pos\&.first->second == id)
548       return;
549 
550   std::pair<const Node*, boundary_id_type> kv (node, id);
551 
552   _boundary_node_id\&.insert(kv);
553   _boundary_ids\&.insert(id);
554   _node_boundary_ids\&.insert(id); // Also add this ID to the set of node boundary IDs
555 }
.fi
.SS "void libMesh::BoundaryInfo::add_node (const \fBdof_id_type\fPnode, const \fBboundary_id_type\fPid)"
Add node number \fCnode\fP with boundary id \fCid\fP to the boundary information data structures\&. 
.PP
Definition at line 519 of file boundary_info\&.C\&.
.PP
References _mesh, add_node(), and libMesh::MeshBase::node_ptr()\&.
.PP
.nf
521 {
522   this->add_node (_mesh\&.node_ptr(node), id);
523 }
.fi
.SS "void libMesh::BoundaryInfo::add_node (const \fBNode\fP *node, const std::vector< \fBboundary_id_type\fP > &ids)"
Add \fC\fBNode\fP\fP \fCnode\fP with boundary ids \fCids\fP to the boundary information data structure\&. 
.PP
Definition at line 557 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _boundary_node_id, _node_boundary_ids, libMesh::err, invalid_id, and libMesh::libmesh_assert()\&.
.PP
.nf
559 {
560   if (ids\&.empty())
561     return;
562 
563   libmesh_assert(node);
564 
565   // A convenient typedef
566   typedef std::multimap<const Node*, boundary_id_type>::const_iterator Iter;
567 
568   // Don't add the same ID twice
569   std::pair<Iter, Iter> pos = _boundary_node_id\&.equal_range(node);
570 
571   for (unsigned int i=0; i!= ids\&.size(); ++i)
572     {
573       boundary_id_type id=ids[i];
574 
575       if (id == invalid_id)
576         {
577           libMesh::err << "ERROR: You may not set a boundary ID of "
578                        << invalid_id << std::endl
579                        << " That is reserved for internal use\&.\n"
580                        << std::endl;
581 
582           libmesh_error();
583         }
584 
585       bool already_inserted = false;
586       for (Iter p = pos\&.first;p != pos\&.second; ++p)
587         if (p->second == id)
588           {
589             already_inserted = true;
590             break;
591           }
592       if (already_inserted)
593         continue;
594 
595       std::pair<const Node*, boundary_id_type> kv (node, id);
596 
597       _boundary_node_id\&.insert(kv);
598       _boundary_ids\&.insert(id);
599       _node_boundary_ids\&.insert(id); // Also add this ID to the set of node boundary IDs
600     }
601 }
.fi
.SS "void libMesh::BoundaryInfo::add_side (const \fBdof_id_type\fPelem, const unsigned short intside, const \fBboundary_id_type\fPid)"
Add side \fCside\fP of element number \fCelem\fP with boundary id \fCid\fP to the boundary information data structure\&. 
.PP
Definition at line 714 of file boundary_info\&.C\&.
.PP
References _mesh, libMesh::MeshBase::elem(), and side\&.
.PP
Referenced by build_side_list_from_node_list(), libMesh::CheckpointIO::read_bcs(), and libMesh::XdrIO::read_serialized_bcs()\&.
.PP
.nf
717 {
718   this->add_side (_mesh\&.elem(e), side, id);
719 }
.fi
.SS "void libMesh::BoundaryInfo::add_side (const \fBElem\fP *elem, const unsigned short intside, const \fBboundary_id_type\fPid)"
Add side \fCside\fP of element \fCelem\fP with boundary id \fCid\fP to the boundary information data structure\&. 
.PP
Definition at line 723 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _boundary_side_id, _side_boundary_ids, libMesh::err, invalid_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
726 {
727   libmesh_assert(elem);
728 
729   // Only add BCs for level-0 elements\&.
730   libmesh_assert_equal_to (elem->level(), 0);
731 
732   if (id == invalid_id)
733     {
734       libMesh::err << "ERROR: You may not set a boundary ID of "
735                    << invalid_id << std::endl
736                    << " That is reserved for internal use\&.\n"
737                    << std::endl;
738 
739       libmesh_error();
740     }
741 
742   // A convenient typedef
743   typedef std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
744     const_iterator Iter;
745 
746   // Don't add the same ID twice
747   std::pair<Iter, Iter> pos = _boundary_side_id\&.equal_range(elem);
748 
749   for (;pos\&.first != pos\&.second; ++pos\&.first)
750     if (pos\&.first->second\&.first == side &&
751         pos\&.first->second\&.second == id)
752       return;
753 
754   std::pair<unsigned short int, boundary_id_type> p(side,id);
755   std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
756     kv (elem, p);
757 
758   _boundary_side_id\&.insert(kv);
759   _boundary_ids\&.insert(id);
760   _side_boundary_ids\&.insert(id); // Also add this ID to the set of side boundary IDs
761 }
.fi
.SS "void libMesh::BoundaryInfo::add_side (const \fBElem\fP *elem, const unsigned short intside, const std::vector< \fBboundary_id_type\fP > &ids)"
Add side \fCside\fP of element \fCelem\fP with boundary ids \fCids\fP to the boundary information data structure\&. 
.PP
Definition at line 765 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _boundary_side_id, _side_boundary_ids, libMesh::err, invalid_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
768 {
769   if (ids\&.empty())
770     return;
771 
772   libmesh_assert(elem);
773 
774   // Only add BCs for level-0 elements\&.
775   libmesh_assert_equal_to (elem->level(), 0);
776 
777   // A convenient typedef
778   typedef std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
779     const_iterator Iter;
780 
781   // Don't add the same ID twice
782   std::pair<Iter, Iter> pos = _boundary_side_id\&.equal_range(elem);
783 
784   for (unsigned int i=0; i!= ids\&.size(); ++i)
785     {
786       boundary_id_type id=ids[i];
787 
788       if (id == invalid_id)
789         {
790           libMesh::err << "ERROR: You may not set a boundary ID of "
791                        << invalid_id << std::endl
792                        << " That is reserved for internal use\&.\n"
793                        << std::endl;
794 
795           libmesh_error();
796         }
797 
798       bool already_inserted = false;
799       for (Iter p = pos\&.first;p != pos\&.second; ++p)
800         if (p->second\&.first == side &&
801             p->second\&.second == id)
802           {
803             already_inserted = true;
804             break;
805           }
806       if (already_inserted)
807         continue;
808 
809       std::pair<unsigned short int, boundary_id_type> p(side,id);
810       std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
811         kv (elem, p);
812 
813       _boundary_side_id\&.insert(kv);
814       _boundary_ids\&.insert(id);
815       _side_boundary_ids\&.insert(id); // Also add this ID to the set of side boundary IDs
816     }
817 }
.fi
.SS "\fBboundary_id_type\fP libMesh::BoundaryInfo::boundary_id (const \fBElem\fP *constelem, const unsigned short intside) const"
Returns the boundary id associated with the \fCside\fP side of element \fCelem\fP\&. Note that only one id per side is allowed, however multiple sides per element are allowed\&. Returns \fCinvalid_id\fP if the \fCside\fP does not have an associated boundary id, hence \fCinvalid_id\fP can be used as the default boundary id\&. 
.PP
Definition at line 1032 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, invalid_id, libMesh::Elem::is_child_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1034 {
1035   // Asking for just one boundary id means your code isn't safe to use
1036   // on meshes with overlapping boundary ids\&.  Try using
1037   // BoundaryInfo::boundary_ids or BoundaryInfo::has_boundary_id
1038   // instead\&.
1039   libmesh_deprecated();
1040 
1041   libmesh_assert(elem);
1042 
1043   // Only level-0 elements store BCs\&.  If this is not a level-0
1044   // element, one of its parent elements may have either internal
1045   // or external boundary IDs\&.  We find that parent now\&.
1046   const Elem*  searched_elem = elem;
1047   if (elem->level() != 0)
1048     {
1049       // Child element on external side: the top_parent will have the BCs
1050       if (elem->neighbor(side) == NULL)
1051         searched_elem = elem->top_parent ();
1052 
1053 #ifdef LIBMESH_ENABLE_AMR
1054       // Child element is not on external side, but it may have internal
1055       // "boundary" IDs\&.  We will walk up the tree, at each level checking that
1056       // the current child is actually on the same side of the parent that is
1057       // currently being searched for (i\&.e\&. that was passed in as "side")\&.
1058       else
1059         while (searched_elem->parent() != NULL)
1060           {
1061             const Elem * parent = searched_elem->parent();
1062             if (parent->is_child_on_side(parent->which_child_am_i(searched_elem), side) == false)
1063               return invalid_id;
1064             searched_elem = parent;
1065           }
1066 #endif
1067     }
1068 
1069   std::pair<std::multimap<const Elem*,
1070     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1071     std::multimap<const Elem*,
1072     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1073     e = _boundary_side_id\&.equal_range(searched_elem);
1074 
1075   // elem not in the data structure
1076   if (e\&.first == e\&.second)
1077     return invalid_id;
1078 
1079   // elem is there, maybe multiple occurrences
1080   for (; e\&.first != e\&.second; ++e\&.first)
1081     // if this is true we found the requested side
1082     // of the element and want to return the id
1083     if (e\&.first->second\&.first == side)
1084       return e\&.first->second\&.second;
1085 
1086   // if we get here, we found elem in the data structure but not
1087   // the requested side, so return the default value
1088   return invalid_id;
1089 }
.fi
.SS "std::vector< \fBboundary_id_type\fP > libMesh::BoundaryInfo::boundary_ids (const \fBNode\fP *node) const"
Returns the boundary ids associated with \fC\fBNode\fP\fP \fCnode\fP\&. 
.PP
Definition at line 838 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
Referenced by libMesh::BoundaryProjectSolution::operator()(), libMesh::FEMContext::side_boundary_ids(), libMesh::XdrIO::write_serialized_bcs(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
839 {
840   std::vector<boundary_id_type> ids;
841 
842   // A convenient typedef
843   typedef std::multimap<const Node*, boundary_id_type>::const_iterator Iter;
844 
845   std::pair<Iter, Iter> pos = _boundary_node_id\&.equal_range(node);
846 
847   for (;pos\&.first != pos\&.second; ++pos\&.first)
848     ids\&.push_back(pos\&.first->second);
849 
850   return ids;
851 }
.fi
.SS "std::vector< \fBboundary_id_type\fP > libMesh::BoundaryInfo::boundary_ids (const \fBElem\fP *constelem, const unsigned short intside) const"
Returns the list of boundary ids associated with the \fCside\fP side of element \fCelem\fP\&. 
.PP
Definition at line 1136 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::is_child_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1138 {
1139   libmesh_assert(elem);
1140 
1141   std::vector<boundary_id_type> ids;
1142 
1143   // Only level-0 elements store BCs\&.  If this is not a level-0
1144   // element get its level-0 parent and infer the BCs\&.
1145   const Elem*  searched_elem = elem;
1146   if (elem->level() != 0)
1147     {
1148       if (elem->neighbor(side) == NULL)
1149         searched_elem = elem->top_parent ();
1150 #ifdef LIBMESH_ENABLE_AMR
1151       else
1152         while (searched_elem->parent() != NULL)
1153           {
1154             const Elem * parent = searched_elem->parent();
1155             if (parent->is_child_on_side(parent->which_child_am_i(searched_elem), side) == false)
1156               return ids;
1157             searched_elem = parent;
1158           }
1159 #endif
1160     }
1161 
1162   std::pair<std::multimap<const Elem*,
1163     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1164     std::multimap<const Elem*,
1165     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1166     e = _boundary_side_id\&.equal_range(searched_elem);
1167 
1168   // elem not in the data structure
1169   if (e\&.first == e\&.second)
1170     return ids;
1171 
1172   // elem is there, maybe multiple occurrences
1173   for (; e\&.first != e\&.second; ++e\&.first)
1174     // if this is true we found the requested side of the element
1175     if (e\&.first->second\&.first == side)
1176       ids\&.push_back(e\&.first->second\&.second);
1177 
1178   // Whether or not we found anything, return "ids"\&.  If it's empty, it
1179   // means no valid bounary IDs were found for "side"
1180   return ids;
1181 }
.fi
.SS "void libMesh::BoundaryInfo::build_node_boundary_ids (std::vector< \fBboundary_id_type\fP > &b_ids)"
Builds the list of unique node boundary ids\&. 
.PP
Definition at line 1440 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
.nf
1441 {
1442   b_ids\&.clear();
1443 
1444   std::multimap<const Node*, boundary_id_type>::const_iterator pos
1445     = _boundary_node_id\&.begin();
1446 
1447   for (; pos != _boundary_node_id\&.end(); ++pos)
1448     {
1449       boundary_id_type id = pos->second;
1450 
1451       if(std::find(b_ids\&.begin(),b_ids\&.end(),id) == b_ids\&.end())
1452         b_ids\&.push_back(id);
1453     }
1454 }
.fi
.SS "void libMesh::BoundaryInfo::build_node_list (std::vector< \fBdof_id_type\fP > &node_id_list, std::vector< \fBboundary_id_type\fP > &bc_id_list) const"
Creates a list of nodes and ids for those nodes\&. 
.PP
Definition at line 1548 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
Referenced by libMesh::CheckpointIO::write_nodesets()\&.
.PP
.nf
1550 {
1551   // Reserve the size, then use push_back
1552   nl\&.reserve (_boundary_node_id\&.size());
1553   il\&.reserve (_boundary_node_id\&.size());
1554 
1555   std::multimap<const Node*, boundary_id_type>::const_iterator pos
1556     = _boundary_node_id\&.begin();
1557 
1558   for (; pos != _boundary_node_id\&.end(); ++pos)
1559     {
1560       nl\&.push_back (pos->first->id());
1561       il\&.push_back (pos->second);
1562     }
1563 }
.fi
.SS "void libMesh::BoundaryInfo::build_node_list_from_side_list ()"
Adds nodes with boundary ids based on the side's boundary ids they are connected to\&. 
.PP
Definition at line 1567 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::active_family_tree_by_side(), add_node(), libMesh::Elem::build_side(), and side\&.
.PP
.nf
1568 {
1569   std::multimap<const Elem*,
1570     std::pair<unsigned short int,
1571     boundary_id_type> >::const_iterator pos;
1572 
1573   //Loop over the side list
1574   for (pos=_boundary_side_id\&.begin(); pos != _boundary_side_id\&.end(); ++pos)
1575     {
1576       // Don't add remote sides
1577       if(pos->first->is_remote())
1578         continue;
1579 
1580       //Need to loop over the sides of any possible children
1581       std::vector< const Elem * > family;
1582 #ifdef LIBMESH_ENABLE_AMR
1583       pos->first->active_family_tree_by_side (family, pos->second\&.first);
1584 #else
1585       family\&.push_back(pos->first);
1586 #endif
1587 
1588       for(std::size_t elem_it=0; elem_it < family\&.size(); elem_it++)
1589         {
1590           const Elem * cur_elem = family[elem_it];
1591 
1592           AutoPtr<Elem> side = cur_elem->build_side(pos->second\&.first);
1593 
1594           //Add each node node on the side with the side's boundary id
1595           for(unsigned int i=0; i<side->n_nodes(); i++)
1596             {
1597               Node * node = side->get_node(i);
1598 
1599               this->add_node(node, pos->second\&.second);
1600             }
1601         }
1602     }
1603 }
.fi
.SS "void libMesh::BoundaryInfo::build_side_boundary_ids (std::vector< \fBboundary_id_type\fP > &b_ids)"
Builds the list of unique side boundary ids\&. 
.PP
Definition at line 1456 of file boundary_info\&.C\&.
.PP
References _boundary_side_id\&.
.PP
.nf
1457 {
1458   b_ids\&.clear();
1459 
1460   std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::const_iterator pos
1461     = _boundary_side_id\&.begin();
1462 
1463   for (; pos != _boundary_side_id\&.end(); ++pos)
1464     {
1465       boundary_id_type id = pos->second\&.second;
1466 
1467       if(std::find(b_ids\&.begin(),b_ids\&.end(),id) == b_ids\&.end())
1468         b_ids\&.push_back(id);
1469     }
1470 }
.fi
.SS "void libMesh::BoundaryInfo::build_side_list (std::vector< \fBdof_id_type\fP > &element_id_list, std::vector< unsigned short int > &side_list, std::vector< \fBboundary_id_type\fP > &bc_id_list) const"
Creates a list of element numbers, sides, and and ids for those sides\&. 
.PP
Definition at line 1667 of file boundary_info\&.C\&.
.PP
References _boundary_side_id\&.
.PP
Referenced by libMesh::CheckpointIO::write_bcs()\&.
.PP
.nf
1670 {
1671   // Reserve the size, then use push_back
1672   el\&.reserve (_boundary_side_id\&.size());
1673   sl\&.reserve (_boundary_side_id\&.size());
1674   il\&.reserve (_boundary_side_id\&.size());
1675 
1676   std::multimap<const Elem*,
1677     std::pair<unsigned short int,
1678     boundary_id_type> >::const_iterator pos;
1679 
1680   for (pos=_boundary_side_id\&.begin(); pos != _boundary_side_id\&.end();
1681        ++pos)
1682     {
1683       el\&.push_back (pos->first->id());
1684       sl\&.push_back (pos->second\&.first);
1685       il\&.push_back (pos->second\&.second);
1686     }
1687 }
.fi
.SS "void libMesh::BoundaryInfo::build_side_list_from_node_list ()"
Adds sides to a sideset if every node on that side are in the same sideset 
.PP
Definition at line 1608 of file boundary_info\&.C\&.
.PP
References _boundary_node_id, _mesh, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), add_side(), libMesh::Elem::build_side(), libMesh::Elem::n_sides(), libMesh::out, and side\&.
.PP
.nf
1609 {
1610   // Check for early return
1611   if (_boundary_node_id\&.empty())
1612     {
1613       libMesh::out << "No boundary node IDs have been added: cannot build side list!" << std::endl;
1614       return;
1615     }
1616 
1617   // typedef for less typing!
1618   typedef std::multimap<const Node*, boundary_id_type>::const_iterator iterator_t;
1619 
1620   // Return value and iterator for equal_range()
1621   iterator_t pos;
1622   std::pair<iterator_t, iterator_t> range;
1623 
1624   MeshBase::const_element_iterator el = _mesh\&.active_elements_begin();
1625   const MeshBase::const_element_iterator end_el = _mesh\&.active_elements_end();
1626 
1627   for (; el != end_el; ++el)
1628     {
1629       const Elem* elem = *el;
1630 
1631       for (unsigned side=0; side<elem->n_sides(); ++side)
1632         {
1633           AutoPtr<Elem> side_elem = elem->build_side(side);
1634 
1635           // map from nodeset_id to count for that ID
1636           std::map<dof_id_type, unsigned> nodesets_node_count;
1637           for (unsigned node_num=0; node_num < side_elem->n_nodes(); ++node_num)
1638             {
1639               Node* node = side_elem->get_node(node_num);
1640               range = _boundary_node_id\&.equal_range(node);
1641 
1642               // For each nodeset that this node is a member of, increment the associated
1643               // nodeset ID count
1644               for (pos = range\&.first; pos != range\&.second; ++pos)
1645                 {
1646                   nodesets_node_count[pos->second]++;
1647                 }
1648             }
1649 
1650           // Now check to see what nodeset_counts have the correct number of nodes in them
1651           for (std::map<dof_id_type, unsigned>::const_iterator nodesets = nodesets_node_count\&.begin();
1652                nodesets != nodesets_node_count\&.end(); ++nodesets)
1653             {
1654               if (nodesets->second == side_elem->n_nodes())
1655                 {
1656                   // Add this side to the sideset
1657                   add_side(elem, side, nodesets->first);
1658                 }
1659             }
1660         } // end for side
1661     } // end for el
1662 }
.fi
.SS "void libMesh::BoundaryInfo::clear ()"
Clears the underlying data structures\&. Returns the object to a pristine state with no data stored\&. 
.PP
Definition at line 121 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _boundary_node_id, _boundary_side_id, _node_boundary_ids, and _side_boundary_ids\&.
.PP
Referenced by ~BoundaryInfo()\&.
.PP
.nf
122 {
123   _boundary_node_id\&.clear();
124   _boundary_side_id\&.clear();
125   _boundary_ids\&.clear();
126   _side_boundary_ids\&.clear();
127   _node_boundary_ids\&.clear();
128 }
.fi
.SS "void libMesh::BoundaryInfo::clear_boundary_node_ids ()"
Clears all the boundary information from all of the nodes in the mesh 
.PP
Definition at line 604 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
.nf
605 {
606   _boundary_node_id\&.clear();
607 }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), n_boundary_conds(), n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "std::vector< \fBboundary_id_type\fP > libMesh::BoundaryInfo::edge_boundary_ids (const \fBElem\fP *constelem, const unsigned short intedge) const"
Returns the list of boundary ids associated with the \fCedge\fP edge of element \fCelem\fP\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 868 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, libMesh::Elem::is_child_on_edge(), libMesh::Elem::is_edge_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
870 {
871   libmesh_assert(elem);
872 
873   std::vector<boundary_id_type> ids;
874 
875   // Only level-0 elements store BCs\&.  If this is not a level-0
876   // element get its level-0 parent and infer the BCs\&.
877   const Elem* searched_elem = elem;
878 #ifdef LIBMESH_ENABLE_AMR
879   if (elem->level() != 0)
880     {
881       // Find all the sides that contain edge\&. If one of those is a boundary
882       // side, then this must be a boundary edge\&. In that case, we just use the
883       // top-level parent\&.
884       bool found_boundary_edge = false;
885       for(unsigned int side=0; side<elem->n_sides(); side++)
886         {
887           if(elem->is_edge_on_side(edge,side))
888             {
889               if (elem->neighbor(side) == NULL)
890                 {
891                   searched_elem = elem->top_parent ();
892                   found_boundary_edge = true;
893                   break;
894                 }
895             }
896         }
897 
898       if(!found_boundary_edge)
899         {
900           // Child element is not on external edge, but it may have internal
901           // "boundary" IDs\&.  We will walk up the tree, at each level checking that
902           // the current child is actually on the same edge of the parent that is
903           // currently being searched for (i\&.e\&. that was passed in as "edge")\&.
904           while (searched_elem->parent() != NULL)
905             {
906               const Elem * parent = searched_elem->parent();
907               if (parent->is_child_on_edge(parent->which_child_am_i(searched_elem), edge) == false)
908                 return ids;
909               searched_elem = parent;
910             }
911         }
912     }
913 #endif
914 
915   std::pair<std::multimap<const Elem*,
916     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
917     std::multimap<const Elem*,
918     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
919     e = _boundary_edge_id\&.equal_range(searched_elem);
920 
921   // elem not in the data structure
922   if (e\&.first == e\&.second)
923     return ids;
924 
925   // elem is there, maybe multiple occurrences
926   for (; e\&.first != e\&.second; ++e\&.first)
927     // if this is true we found the requested edge of the element
928     if (e\&.first->second\&.first == edge)
929       ids\&.push_back(e\&.first->second\&.second);
930 
931   // Whether or not we found anything, return "ids"\&.  If it's empty, it
932   // means no valid bounary IDs were found for "edge"
933   return ids;
934 }
.fi
.SS "const std::set<\fBboundary_id_type\fP>& libMesh::BoundaryInfo::get_boundary_ids () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the user-specified boundary ids\&. 
.RE
.PP

.PP
Definition at line 399 of file boundary_info\&.h\&.
.PP
References _boundary_ids\&.
.PP
.nf
400   { return _boundary_ids; }
.fi
.SS "const std::set<\fBboundary_id_type\fP>& libMesh::BoundaryInfo::get_edge_boundary_ids () const\fC [inline]\fP"
Returns a reference to the set of all boundary IDs specified on edges\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 414 of file boundary_info\&.h\&.
.PP
References _edge_boundary_ids\&.
.PP
.nf
415   { return _edge_boundary_ids; }
.fi
.SS "\fBboundary_id_type\fP libMesh::BoundaryInfo::get_id_by_name (const std::string &name) const"
Returns a the id of the requested boundary by name\&. Throws an error if a sideset or nodeset by name is not found 
.PP
Definition at line 1855 of file boundary_info\&.C\&.
.PP
References _ns_id_to_name, _ss_id_to_name, and libMesh::err\&.
.PP
.nf
1856 {
1857   // This function is searching the keys of the map
1858   // We might want to make this more efficient
1859   std::map<boundary_id_type, std::string>::const_iterator iter = _ss_id_to_name\&.begin();
1860   std::map<boundary_id_type, std::string>::const_iterator end_iter = _ss_id_to_name\&.end();
1861 
1862   for ( ; iter != end_iter; ++iter)
1863     {
1864       if (iter->second == name)
1865         return iter->first;
1866     }
1867 
1868   // Loop over nodesets
1869   iter = _ns_id_to_name\&.begin();
1870   end_iter = _ns_id_to_name\&.end();
1871   for ( ; iter != end_iter; ++iter)
1872     {
1873       if (iter->second == name)
1874         return iter->first;
1875     }
1876 
1877   libMesh::err << "The sideset/nodeset named " << name << " does not exist in mesh!" << std::endl;
1878   libmesh_error();
1879 }
.fi
.SS "const std::set<\fBboundary_id_type\fP>& libMesh::BoundaryInfo::get_node_boundary_ids () const\fC [inline]\fP"
Returns a reference to the set of all boundary IDs specified on nodes\&. 
.PP
Definition at line 421 of file boundary_info\&.h\&.
.PP
References _node_boundary_ids\&.
.PP
.nf
422   { return _node_boundary_ids; }
.fi
.SS "const std::map<\fBboundary_id_type\fP, std::string>& libMesh::BoundaryInfo::get_nodeset_name_map () const\fC [inline]\fP"

.PP
Definition at line 466 of file boundary_info\&.h\&.
.PP
References _ns_id_to_name\&.
.PP
Referenced by libMesh::CheckpointIO::write_bc_names(), and libMesh::XdrIO::write_serialized_bc_names()\&.
.PP
.nf
467   { return _ns_id_to_name; }
.fi
.SS "const std::set<\fBboundary_id_type\fP>& libMesh::BoundaryInfo::get_side_boundary_ids () const\fC [inline]\fP"
Returns a reference to the set of all boundary IDs specified on sides\&. 
.PP
Definition at line 406 of file boundary_info\&.h\&.
.PP
References _side_boundary_ids\&.
.PP
.nf
407   { return _side_boundary_ids; }
.fi
.SS "const std::map<\fBboundary_id_type\fP, std::string>& libMesh::BoundaryInfo::get_sideset_name_map () const\fC [inline]\fP"

.PP
Definition at line 458 of file boundary_info\&.h\&.
.PP
References _ss_id_to_name\&.
.PP
Referenced by libMesh::CheckpointIO::write_bc_names(), and libMesh::XdrIO::write_serialized_bc_names()\&.
.PP
.nf
459   { return _ss_id_to_name; }
.fi
.SS "bool libMesh::BoundaryInfo::has_boundary_id (const \fBNode\fP *constnode, const \fBboundary_id_type\fPid) const"
Returns true iff the given node is associated with the given id\&. 
.PP
Definition at line 821 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
Referenced by libMesh::FEMContext::has_side_boundary_id()\&.
.PP
.nf
823 {
824   // A convenient typedef
825   typedef std::multimap<const Node*, boundary_id_type>::const_iterator Iter;
826 
827   std::pair<Iter, Iter> pos = _boundary_node_id\&.equal_range(node);
828 
829   for (;pos\&.first != pos\&.second; ++pos\&.first)
830     if (pos\&.first->second == id)
831       return true;
832 
833   return false;
834 }
.fi
.SS "bool libMesh::BoundaryInfo::has_boundary_id (const \fBElem\fP *constelem, const unsigned short intside, const \fBboundary_id_type\fPid) const"
Returns true iff the given side of the given element is associated with the given id\&. 
.PP
Definition at line 1093 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::is_child_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1096 {
1097   libmesh_assert(elem);
1098 
1099   // Only level-0 elements store BCs\&.  If this is not a level-0
1100   // element get its level-0 parent and infer the BCs\&.
1101   const Elem*  searched_elem = elem;
1102   if (elem->level() != 0)
1103     {
1104       if (elem->neighbor(side) == NULL)
1105         searched_elem = elem->top_parent ();
1106 #ifdef LIBMESH_ENABLE_AMR
1107       else
1108         while (searched_elem->parent() != NULL)
1109           {
1110             const Elem * parent = searched_elem->parent();
1111             if (parent->is_child_on_side(parent->which_child_am_i(searched_elem), side) == false)
1112               return false;
1113             searched_elem = parent;
1114           }
1115 #endif
1116     }
1117 
1118   std::pair<std::multimap<const Elem*,
1119     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1120     std::multimap<const Elem*,
1121     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1122     e = _boundary_side_id\&.equal_range(searched_elem);
1123 
1124   // elem is there, maybe multiple occurrences
1125   for (; e\&.first != e\&.second; ++e\&.first)
1126     // if this is true we found the requested id on this side of the element
1127     if (e\&.first->second\&.first == side &&
1128         e\&.first->second\&.second == id)
1129       return true;
1130 
1131   return false;
1132 }
.fi
.SS "std::size_t libMesh::BoundaryInfo::n_boundary_conds () const"

.PP
\fBReturns:\fP
.RS 4
the number of element-side-based boundary conditions\&. 
.RE
.PP

.PP
Definition at line 1472 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, _mesh, libMesh::ParallelObject::comm(), libMesh::MeshBase::is_serial(), libMesh::ParallelObject::processor_id(), and libMesh::Parallel::Communicator::sum()\&.
.PP
.nf
1473 {
1474   // in serial we know the number of bcs from the
1475   // size of the container
1476   if (_mesh\&.is_serial())
1477     return _boundary_side_id\&.size();
1478 
1479   // in parallel we need to sum the number of local bcs
1480   parallel_object_only();
1481 
1482   std::size_t nbcs=0;
1483 
1484   std::multimap<const Elem*,
1485     std::pair<unsigned short int,
1486     boundary_id_type> >::const_iterator pos;
1487 
1488   for (pos=_boundary_side_id\&.begin(); pos != _boundary_side_id\&.end(); ++pos)
1489     if (pos->first->processor_id() == this->processor_id())
1490       nbcs++;
1491 
1492   this->comm()\&.sum (nbcs);
1493 
1494   return nbcs;
1495 }
.fi
.SS "std::size_t libMesh::BoundaryInfo::n_boundary_ids () const\fC [inline]\fP"
Returns the number of user-specified boundary ids\&. 
.PP
Definition at line 249 of file boundary_info\&.h\&.
.PP
References _boundary_ids\&.
.PP
.nf
249 { return _boundary_ids\&.size(); }
.fi
.SS "unsigned int libMesh::BoundaryInfo::n_boundary_ids (const \fBNode\fP *node) const"
Returns the number of boundary ids associated with \fC\fBNode\fP\fP \fCnode\fP\&. 
.PP
Definition at line 855 of file boundary_info\&.C\&.
.PP
References _boundary_node_id\&.
.PP
.nf
856 {
857   // A convenient typedef
858   typedef std::multimap<const Node*, boundary_id_type>::const_iterator Iter;
859 
860   std::pair<Iter, Iter> pos = _boundary_node_id\&.equal_range(node);
861 
862   return libmesh_cast_int<unsigned int>
863     (std::distance(pos\&.first, pos\&.second));
864 }
.fi
.SS "unsigned int libMesh::BoundaryInfo::n_boundary_ids (const \fBElem\fP *constelem, const unsigned short intside) const"
Returns the number of boundary ids associated with the \fCside\fP side of element \fCelem\fP\&. 
.PP
Definition at line 1185 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::is_child_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1187 {
1188   libmesh_assert(elem);
1189 
1190   // Only level-0 elements store BCs\&.  If this is not a level-0
1191   // element get its level-0 parent and infer the BCs\&.
1192   const Elem*  searched_elem = elem;
1193   if (elem->level() != 0)
1194     {
1195       if (elem->neighbor(side) == NULL)
1196         searched_elem = elem->top_parent ();
1197 #ifdef LIBMESH_ENABLE_AMR
1198       else
1199         while (searched_elem->parent() != NULL)
1200           {
1201             const Elem * parent = searched_elem->parent();
1202             if (parent->is_child_on_side(parent->which_child_am_i(searched_elem), side) == false)
1203               return 0;
1204             searched_elem = parent;
1205           }
1206 #endif
1207     }
1208 
1209   std::pair<std::multimap<const Elem*,
1210     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1211     std::multimap<const Elem*,
1212     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1213     e = _boundary_side_id\&.equal_range(searched_elem);
1214 
1215   unsigned int n_ids = 0;
1216 
1217   // elem is there, maybe multiple occurrences
1218   for (; e\&.first != e\&.second; ++e\&.first)
1219     // if this is true we found the requested side of the element
1220     if (e\&.first->second\&.first == side)
1221       n_ids++;
1222 
1223   return n_ids;
1224 }
.fi
.SS "unsigned int libMesh::BoundaryInfo::n_edge_boundary_ids (const \fBElem\fP *constelem, const unsigned short intedge) const"
Returns the number of boundary ids associated with the \fCedge\fP edge of element \fCelem\fP\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 938 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, libMesh::Elem::is_child_on_edge(), libMesh::Elem::is_edge_on_side(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
940 {
941   libmesh_assert(elem);
942 
943   // Only level-0 elements store BCs\&.  If this is not a level-0
944   // element get its level-0 parent and infer the BCs\&.
945   const Elem* searched_elem = elem;
946 #ifdef LIBMESH_ENABLE_AMR
947   if (elem->level() != 0)
948     {
949       // Find all the sides that contain edge\&. If one of those is a boundary
950       // side, then this must be a boundary edge\&. In that case, we just use the
951       // top-level parent\&.
952       bool found_boundary_edge = false;
953       for(unsigned int side=0; side<elem->n_sides(); side++)
954         {
955           if(elem->is_edge_on_side(edge,side))
956             {
957               if (elem->neighbor(side) == NULL)
958                 {
959                   searched_elem = elem->top_parent ();
960                   found_boundary_edge = true;
961                   break;
962                 }
963             }
964         }
965 
966       if(!found_boundary_edge)
967         {
968           // Child element is not on external edge, but it may have internal
969           // "boundary" IDs\&.  We will walk up the tree, at each level checking that
970           // the current child is actually on the same edge of the parent that is
971           // currently being searched for (i\&.e\&. that was passed in as "edge")\&.
972           while (searched_elem->parent() != NULL)
973             {
974               const Elem * parent = searched_elem->parent();
975               if (parent->is_child_on_edge(parent->which_child_am_i(searched_elem), edge) == false)
976                 return 0;
977               searched_elem = parent;
978             }
979         }
980     }
981 #endif
982 
983   std::pair<std::multimap<const Elem*,
984     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
985     std::multimap<const Elem*,
986     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
987     e = _boundary_edge_id\&.equal_range(searched_elem);
988 
989   unsigned int n_ids = 0;
990 
991   // elem is there, maybe multiple occurrences
992   for (; e\&.first != e\&.second; ++e\&.first)
993     // if this is true we found the requested edge of the element
994     if (e\&.first->second\&.first == edge)
995       n_ids++;
996 
997   return n_ids;
998 }
.fi
.SS "std::size_t libMesh::BoundaryInfo::n_edge_conds () const"

.PP
\fBReturns:\fP
.RS 4
the number of edge-based boundary conditions\&. Edge-based boundary IDs should only be used in 3D\&. 
.RE
.PP

.PP
Definition at line 1497 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _mesh, libMesh::ParallelObject::comm(), libMesh::MeshBase::is_serial(), libMesh::ParallelObject::processor_id(), and libMesh::Parallel::Communicator::sum()\&.
.PP
.nf
1498 {
1499   // in serial we know the number of nodesets from the
1500   // size of the container
1501   if (_mesh\&.is_serial())
1502     return _boundary_edge_id\&.size();
1503 
1504   // in parallel we need to sum the number of local nodesets
1505   parallel_object_only();
1506 
1507   std::size_t n_edge_bcs=0;
1508 
1509   std::multimap<const Elem*,
1510     std::pair<unsigned short int,
1511     boundary_id_type> >::const_iterator pos;
1512 
1513   for (pos=_boundary_edge_id\&.begin(); pos != _boundary_edge_id\&.end(); ++pos)
1514     if (pos->first->processor_id() == this->processor_id())
1515       n_edge_bcs++;
1516 
1517   this->comm()\&.sum (n_edge_bcs);
1518 
1519   return n_edge_bcs;
1520 }
.fi
.SS "std::size_t libMesh::BoundaryInfo::n_nodeset_conds () const"

.PP
\fBReturns:\fP
.RS 4
the number of node-based boundary conditions\&. 
.RE
.PP

.PP
Definition at line 1523 of file boundary_info\&.C\&.
.PP
References _boundary_node_id, _mesh, libMesh::ParallelObject::comm(), libMesh::MeshBase::is_serial(), libMesh::ParallelObject::processor_id(), and libMesh::Parallel::Communicator::sum()\&.
.PP
.nf
1524 {
1525   // in serial we know the number of nodesets from the
1526   // size of the container
1527   if (_mesh\&.is_serial())
1528     return _boundary_node_id\&.size();
1529 
1530   // in parallel we need to sum the number of local nodesets
1531   parallel_object_only();
1532 
1533   std::size_t n_nodesets=0;
1534 
1535   std::multimap<const Node*, boundary_id_type>::const_iterator pos;
1536 
1537   for (pos=_boundary_node_id\&.begin(); pos != _boundary_node_id\&.end(); ++pos)
1538     if (pos->first->processor_id() == this->processor_id())
1539       n_nodesets++;
1540 
1541   this->comm()\&.sum (n_nodesets);
1542 
1543   return n_nodesets;
1544 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "std::string & libMesh::BoundaryInfo::nodeset_name (\fBboundary_id_type\fPid)"
Returns a writable reference for getting/setting an optional name for a nodeset name\&. 
.PP
Definition at line 1850 of file boundary_info\&.C\&.
.PP
References _ns_id_to_name\&.
.PP
.nf
1851 {
1852   return _ns_id_to_name[id];
1853 }
.fi
.SS "\fBBoundaryInfo\fP & libMesh::BoundaryInfo::operator= (const \fBBoundaryInfo\fP &other_boundary_info)"
Actual copying operation\&.
.PP
Note that it does not copy the mesh over (for obvious reasons)\&. A quick note: We're going to attempt to pull \fInew\fP pointers out of the mesh assigned to this boundary info\&. This will only work if the mesh assigned to this \fBBoundaryInfo\fP is the same mesh object as other_boundary_info \fIor\fP was constructed in exactly the same way (or constructed as a copy)\&.
.PP
Definition at line 52 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _boundary_ids, _boundary_node_id, _boundary_side_id, _mesh, _node_boundary_ids, _side_boundary_ids, libMesh::MeshBase::elem(), end, libMesh::DofObject::id(), and libMesh::MeshBase::node_ptr()\&.
.PP
.nf
53 {
60   // Copy node boundary info
61   {
62     std::multimap<const Node*, boundary_id_type>::const_iterator it = other_boundary_info\&._boundary_node_id\&.begin();
63     const std::multimap<const Node*, boundary_id_type>::const_iterator end = other_boundary_info\&._boundary_node_id\&.end();
64 
65     for(; it != end; ++it)
66       {
67         const Node * other_node = it->first;
68         _boundary_node_id\&.insert
69           (std::pair<const Node*, boundary_id_type>
70            (_mesh\&.node_ptr(other_node->id()), it->second) );
71       }
72   }
73 
74   // Copy edge boundary info
75   {
76     std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
77       const_iterator it = other_boundary_info\&._boundary_edge_id\&.begin();
78     const std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
79       const_iterator end = other_boundary_info\&._boundary_edge_id\&.end();
80 
81     for(; it != end; ++it)
82       {
83         const Elem * other_elem = it->first;
84         _boundary_edge_id\&.insert
85           (std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
86            (_mesh\&.elem(other_elem->id()), it->second) );
87       }
88   }
89 
90   // Copy side boundary info
91   {
92     std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
93       const_iterator it = other_boundary_info\&._boundary_side_id\&.begin();
94     const std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
95       const_iterator end = other_boundary_info\&._boundary_side_id\&.end();
96 
97     for(; it != end; ++it)
98       {
99         const Elem * other_elem = it->first;
100         _boundary_side_id\&.insert
101           (std::pair<const Elem*, std::pair<unsigned short int, boundary_id_type> >
102            (_mesh\&.elem(other_elem->id()), it->second) );
103       }
104   }
105 
106   _boundary_ids = other_boundary_info\&._boundary_ids;
107   _side_boundary_ids = other_boundary_info\&._side_boundary_ids;
108   _node_boundary_ids = other_boundary_info\&._node_boundary_ids;
109 
110   return *this;
111 }
.fi
.SS "void libMesh::BoundaryInfo::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP) const"
Print the boundary information data structure\&. 
.PP
Definition at line 1691 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _boundary_node_id, _boundary_side_id, and end\&.
.PP
.nf
1692 {
1693   // Print out the nodal BCs
1694   if (!_boundary_node_id\&.empty())
1695     {
1696       out_stream << "Nodal Boundary conditions:" << std::endl
1697                  << "--------------------------" << std::endl
1698                  << "  (Node No\&., ID)               " << std::endl;
1699 
1700       //       std::for_each(_boundary_node_id\&.begin(),
1701       //    _boundary_node_id\&.end(),
1702       //    PrintNodeInfo());
1703 
1704       std::multimap<const Node*, boundary_id_type>::const_iterator it        = _boundary_node_id\&.begin();
1705       const std::multimap<const Node*, boundary_id_type>::const_iterator end = _boundary_node_id\&.end();
1706 
1707       for (; it != end; ++it)
1708         out_stream << "  (" << (*it)\&.first->id()
1709                    << ", "  << (*it)\&.second
1710                    << ")"  << std::endl;
1711     }
1712 
1713   // Print out the element edge BCs
1714   if (!_boundary_edge_id\&.empty())
1715     {
1716       out_stream << std::endl
1717                  << "Edge Boundary conditions:" << std::endl
1718                  << "-------------------------" << std::endl
1719                  << "  (Elem No\&., Edge No\&., ID)      " << std::endl;
1720 
1721       //       std::for_each(_boundary_edge_id\&.begin(),
1722       //    _boundary_edge_id\&.end(),
1723       //    PrintSideInfo());
1724 
1725       std::multimap<const Elem*,
1726         std::pair<unsigned short int, boundary_id_type> >::const_iterator it = _boundary_edge_id\&.begin();
1727       const std::multimap<const Elem*,
1728         std::pair<unsigned short int, boundary_id_type> >::const_iterator end = _boundary_edge_id\&.end();
1729 
1730       for (; it != end; ++it)
1731         out_stream << "  (" << (*it)\&.first->id()
1732                    << ", "  << (*it)\&.second\&.first
1733                    << ", "  << (*it)\&.second\&.second
1734                    << ")"   << std::endl;
1735     }
1736 
1737   // Print out the element side BCs
1738   if (!_boundary_side_id\&.empty())
1739     {
1740       out_stream << std::endl
1741                  << "Side Boundary conditions:" << std::endl
1742                  << "-------------------------" << std::endl
1743                  << "  (Elem No\&., Side No\&., ID)      " << std::endl;
1744 
1745       //       std::for_each(_boundary_side_id\&.begin(),
1746       //    _boundary_side_id\&.end(),
1747       //    PrintSideInfo());
1748 
1749       std::multimap<const Elem*,
1750         std::pair<unsigned short int, boundary_id_type> >::const_iterator it = _boundary_side_id\&.begin();
1751       const std::multimap<const Elem*,
1752         std::pair<unsigned short int, boundary_id_type> >::const_iterator end = _boundary_side_id\&.end();
1753 
1754       for (; it != end; ++it)
1755         out_stream << "  (" << (*it)\&.first->id()
1756                    << ", "  << (*it)\&.second\&.first
1757                    << ", "  << (*it)\&.second\&.second
1758                    << ")"   << std::endl;
1759     }
1760 }
.fi
.SS "void libMesh::BoundaryInfo::print_summary (std::ostream &out = \fC\fBlibMesh::out\fP\fP) const"
Print a summary of the boundary information\&. 
.PP
Definition at line 1764 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, _boundary_node_id, _boundary_side_id, and end\&.
.PP
.nf
1765 {
1766   // Print out the nodal BCs
1767   if (!_boundary_node_id\&.empty())
1768     {
1769       out_stream << "Nodal Boundary conditions:" << std::endl
1770                  << "--------------------------" << std::endl
1771                  << "  (ID, number of nodes)   " << std::endl;
1772 
1773       std::map<boundary_id_type, std::size_t> ID_counts;
1774 
1775       std::multimap<const Node*, boundary_id_type>::const_iterator it        = _boundary_node_id\&.begin();
1776       const std::multimap<const Node*, boundary_id_type>::const_iterator end = _boundary_node_id\&.end();
1777 
1778       for (; it != end; ++it)
1779         ID_counts[(*it)\&.second]++;
1780 
1781       std::map<boundary_id_type, std::size_t>::const_iterator ID_it        = ID_counts\&.begin();
1782       const std::map<boundary_id_type, std::size_t>::const_iterator ID_end = ID_counts\&.end();
1783 
1784       for (; ID_it != ID_end; ++ID_it)
1785         out_stream << "  (" << (*ID_it)\&.first
1786                    << ", "  << (*ID_it)\&.second
1787                    << ")"  << std::endl;
1788     }
1789 
1790   // Print out the element edge BCs
1791   if (!_boundary_edge_id\&.empty())
1792     {
1793       out_stream << std::endl
1794                  << "Edge Boundary conditions:" << std::endl
1795                  << "-------------------------" << std::endl
1796                  << "  (ID, number of edges)   " << std::endl;
1797 
1798       std::map<boundary_id_type, std::size_t> ID_counts;
1799 
1800       std::multimap<const Elem*,
1801         std::pair<unsigned short int, boundary_id_type> >::const_iterator it = _boundary_edge_id\&.begin();
1802       const std::multimap<const Elem*,
1803         std::pair<unsigned short int, boundary_id_type> >::const_iterator end = _boundary_edge_id\&.end();
1804 
1805       for (; it != end; ++it)
1806         ID_counts[(*it)\&.second\&.second]++;
1807 
1808       std::map<boundary_id_type, std::size_t>::const_iterator ID_it        = ID_counts\&.begin();
1809       const std::map<boundary_id_type, std::size_t>::const_iterator ID_end = ID_counts\&.end();
1810 
1811       for (; ID_it != ID_end; ++ID_it)
1812         out_stream << "  (" << (*ID_it)\&.first
1813                    << ", "  << (*ID_it)\&.second
1814                    << ")"  << std::endl;
1815     }
1816 
1817   // Print out the element side BCs
1818   if (!_boundary_side_id\&.empty())
1819     {
1820       out_stream << std::endl
1821                  << "Side Boundary conditions:" << std::endl
1822                  << "-------------------------" << std::endl
1823                  << "  (ID, number of sides)   " << std::endl;
1824 
1825       std::map<boundary_id_type, std::size_t> ID_counts;
1826 
1827       std::multimap<const Elem*,
1828         std::pair<unsigned short int, boundary_id_type> >::const_iterator it = _boundary_side_id\&.begin();
1829       const std::multimap<const Elem*,
1830         std::pair<unsigned short int, boundary_id_type> >::const_iterator end = _boundary_side_id\&.end();
1831 
1832       for (; it != end; ++it)
1833         ID_counts[(*it)\&.second\&.second]++;
1834 
1835       std::map<boundary_id_type, std::size_t>::const_iterator ID_it        = ID_counts\&.begin();
1836       const std::map<boundary_id_type, std::size_t>::const_iterator ID_end = ID_counts\&.end();
1837 
1838       for (; ID_it != ID_end; ++ID_it)
1839         out_stream << "  (" << (*ID_it)\&.first
1840                    << ", "  << (*ID_it)\&.second
1841                    << ")"  << std::endl;
1842     }
1843 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), n_boundary_conds(), n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "std::vector< \fBboundary_id_type\fP > libMesh::BoundaryInfo::raw_boundary_ids (const \fBElem\fP *constelem, const unsigned short intside) const"
Returns the list of raw boundary ids associated with the \fCside\fP side of element \fCelem\fP\&. These ids are ``raw'' because they exclude ids which are implicit, such as a child's inheritance of its ancestors' boundary id\&. 
.PP
Definition at line 1228 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::libmesh_assert(), and libMesh::Elem::parent()\&.
.PP
.nf
1230 {
1231   libmesh_assert(elem);
1232 
1233   std::vector<boundary_id_type> ids;
1234 
1235   // Only level-0 elements store BCs\&.
1236   if (elem->parent())
1237     return ids;
1238 
1239   std::pair<std::multimap<const Elem*,
1240     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1241     std::multimap<const Elem*,
1242     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1243     e = _boundary_side_id\&.equal_range(elem);
1244 
1245   // Check any occurrences
1246   for (; e\&.first != e\&.second; ++e\&.first)
1247     // if this is true we found the requested side of the element
1248     if (e\&.first->second\&.first == side)
1249       ids\&.push_back(e\&.first->second\&.second);
1250 
1251   // if nothing got pushed back, we didn't find elem in the data
1252   // structure with the requested side, so return the default empty
1253   // vector
1254   return ids;
1255 }
.fi
.SS "std::vector< \fBboundary_id_type\fP > libMesh::BoundaryInfo::raw_edge_boundary_ids (const \fBElem\fP *constelem, const unsigned short intedge) const"
Returns the list of raw boundary ids associated with the \fCedge\fP edge of element \fCelem\fP\&. These ids are ``raw'' because they exclude ids which are implicit, such as a child's inheritance of its ancestors' boundary id\&. Edge-based boundary IDs should only be used in 3D\&. 
.PP
Definition at line 1002 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, libMesh::libmesh_assert(), and libMesh::Elem::parent()\&.
.PP
.nf
1004 {
1005   libmesh_assert(elem);
1006 
1007   std::vector<boundary_id_type> ids;
1008 
1009   // Only level-0 elements store BCs\&.
1010   if (elem->parent())
1011     return ids;
1012 
1013   std::pair<std::multimap<const Elem*,
1014     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1015     std::multimap<const Elem*,
1016     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1017     e = _boundary_edge_id\&.equal_range(elem);
1018 
1019   // Check any occurrences
1020   for (; e\&.first != e\&.second; ++e\&.first)
1021     // if this is true we found the requested edge of the element
1022     if (e\&.first->second\&.first == edge)
1023       ids\&.push_back(e\&.first->second\&.second);
1024 
1025   // if nothing got pushed back, we didn't find elem in the data
1026   // structure with the requested edge, so return the default empty
1027   // vector
1028   return ids;
1029 }
.fi
.SS "void libMesh::BoundaryInfo::remove (const \fBNode\fP *node)\fC [inline]\fP"
Removes the boundary conditions associated with node \fCnode\fP, if any exist\&. 
.PP
Definition at line 624 of file boundary_info\&.h\&.
.PP
References _boundary_node_id, and libMesh::libmesh_assert()\&.
.PP
.nf
625 {
626   libmesh_assert(node);
627 
628   // Erase everything associated with node
629   _boundary_node_id\&.erase (node);
630 }
.fi
.SS "void libMesh::BoundaryInfo::remove (const \fBElem\fP *elem)\fC [inline]\fP"
Removes the boundary conditions associated with element \fCelem\fP, if any exist\&. 
.PP
Definition at line 635 of file boundary_info\&.h\&.
.PP
References _boundary_edge_id, _boundary_side_id, and libMesh::libmesh_assert()\&.
.PP
.nf
636 {
637   libmesh_assert(elem);
638 
639   // Erase everything associated with elem
640   _boundary_edge_id\&.erase (elem);
641   _boundary_side_id\&.erase (elem);
642 }
.fi
.SS "void libMesh::BoundaryInfo::remove_edge (const \fBElem\fP *elem, const unsigned short intedge)"
Removes all boundary conditions associated with edge \fCedge\fP of element \fCelem\fP, if any exist\&. 
.PP
Definition at line 1258 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
1260 {
1261   libmesh_assert(elem);
1262 
1263   // The user shouldn't be trying to remove only one child's boundary
1264   // id
1265   libmesh_assert_equal_to (elem->level(), 0);
1266 
1267   std::pair<std::multimap<const Elem*,
1268     std::pair<unsigned short int, boundary_id_type> >::iterator,
1269     std::multimap<const Elem*,
1270     std::pair<unsigned short int, boundary_id_type> >::iterator >
1271     e = _boundary_edge_id\&.equal_range(elem);
1272 
1273   // elem may be there, maybe multiple occurrences
1274   while (e\&.first != e\&.second)
1275     {
1276       // if this is true we found the requested edge
1277       // of the element and want to erase the id
1278       if (e\&.first->second\&.first == edge)
1279         {
1280           // (postfix++ - increment the iterator before it's invalid)
1281           _boundary_edge_id\&.erase(e\&.first++);
1282         }
1283       else
1284         ++e\&.first;
1285     }
1286 }
.fi
.SS "void libMesh::BoundaryInfo::remove_edge (const \fBElem\fP *elem, const unsigned short intedge, const \fBboundary_id_type\fPid)"
Removes the boundary id \fCid\fP from edge \fCedge\fP of element \fCelem\fP, if it exists\&. 
.PP
Definition at line 1290 of file boundary_info\&.C\&.
.PP
References _boundary_edge_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
1293 {
1294   libmesh_assert(elem);
1295 
1296   // The user shouldn't be trying to remove only one child's boundary
1297   // id
1298   libmesh_assert_equal_to (elem->level(), 0);
1299 
1300   std::pair<std::multimap<const Elem*,
1301     std::pair<unsigned short int, boundary_id_type> >::iterator,
1302     std::multimap<const Elem*,
1303     std::pair<unsigned short int, boundary_id_type> >::iterator >
1304     e = _boundary_edge_id\&.equal_range(elem);
1305 
1306   // elem may be there, maybe multiple occurrences
1307   while (e\&.first != e\&.second)
1308     {
1309       // if this is true we found the requested edge
1310       // of the element and want to erase the requested id
1311       if (e\&.first->second\&.first == edge &&
1312           e\&.first->second\&.second == id)
1313         {
1314           // (postfix++ - increment the iterator before it's invalid)
1315           _boundary_edge_id\&.erase(e\&.first++);
1316         }
1317       else
1318         ++e\&.first;
1319     }
1320 }
.fi
.SS "void libMesh::BoundaryInfo::remove_side (const \fBElem\fP *elem, const unsigned short intside)"
Removes all boundary conditions associated with side \fCside\fP of element \fCelem\fP, if any exist\&. 
.PP
Definition at line 1322 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
1324 {
1325   libmesh_assert(elem);
1326 
1327   // The user shouldn't be trying to remove only one child's boundary
1328   // id
1329   libmesh_assert_equal_to (elem->level(), 0);
1330 
1331   std::pair<std::multimap<const Elem*,
1332     std::pair<unsigned short int, boundary_id_type> >::iterator,
1333     std::multimap<const Elem*,
1334     std::pair<unsigned short int, boundary_id_type> >::iterator >
1335     e = _boundary_side_id\&.equal_range(elem);
1336 
1337   // elem may be there, maybe multiple occurrences
1338   while (e\&.first != e\&.second)
1339     {
1340       // if this is true we found the requested side
1341       // of the element and want to erase the id
1342       if (e\&.first->second\&.first == side)
1343         {
1344           // (postfix++ - increment the iterator before it's invalid)
1345           _boundary_side_id\&.erase(e\&.first++);
1346         }
1347       else
1348         ++e\&.first;
1349     }
1350 }
.fi
.SS "void libMesh::BoundaryInfo::remove_side (const \fBElem\fP *elem, const unsigned short intside, const \fBboundary_id_type\fPid)"
Removes the boundary id \fCid\fP from side \fCside\fP of element \fCelem\fP, if it exists\&. 
.PP
Definition at line 1354 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::Elem::level(), and libMesh::libmesh_assert()\&.
.PP
.nf
1357 {
1358   libmesh_assert(elem);
1359 
1360   // The user shouldn't be trying to remove only one child's boundary
1361   // id
1362   libmesh_assert_equal_to (elem->level(), 0);
1363 
1364   std::pair<std::multimap<const Elem*,
1365     std::pair<unsigned short int, boundary_id_type> >::iterator,
1366     std::multimap<const Elem*,
1367     std::pair<unsigned short int, boundary_id_type> >::iterator >
1368     e = _boundary_side_id\&.equal_range(elem);
1369 
1370   // elem may be there, maybe multiple occurrences
1371   while (e\&.first != e\&.second)
1372     {
1373       // if this is true we found the requested side
1374       // of the element and want to erase the requested id
1375       if (e\&.first->second\&.first == side &&
1376           e\&.first->second\&.second == id)
1377         {
1378           // (postfix++ - increment the iterator before it's invalid)
1379           _boundary_side_id\&.erase(e\&.first++);
1380         }
1381       else
1382         ++e\&.first;
1383     }
1384 }
.fi
.SS "std::map<\fBboundary_id_type\fP, std::string>& libMesh::BoundaryInfo::set_nodeset_name_map ()\fC [inline]\fP"
Return a writeable reference to the whole nodeset name map 
.PP
Definition at line 464 of file boundary_info\&.h\&.
.PP
References _ns_id_to_name\&.
.PP
Referenced by libMesh::CheckpointIO::read_bc_names(), and libMesh::XdrIO::read_serialized_bc_names()\&.
.PP
.nf
465   { return _ns_id_to_name; }
.fi
.SS "std::map<\fBboundary_id_type\fP, std::string>& libMesh::BoundaryInfo::set_sideset_name_map ()\fC [inline]\fP"
Return a writeable reference to the whole sideset name map 
.PP
Definition at line 456 of file boundary_info\&.h\&.
.PP
References _ss_id_to_name\&.
.PP
Referenced by libMesh::CheckpointIO::read_bc_names(), and libMesh::XdrIO::read_serialized_bc_names()\&.
.PP
.nf
457   { return _ss_id_to_name; }
.fi
.SS "unsigned int libMesh::BoundaryInfo::side_with_boundary_id (const \fBElem\fP *constelem, const \fBboundary_id_type\fPboundary_id) const"
Returns a side of element \fCelem\fP whose associated boundary id is \fCboundary_id\fP if such a side exists\&. If multiple sides of \fCelem\fP have the same id, only the lowest numbered such side is returned\&.
.PP
Returns \fCinvalid_uint\fP if no side has the requested boundary id\&. 
.PP
Definition at line 1388 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, libMesh::invalid_uint, libMesh::Elem::is_child_on_side(), libMesh::Elem::level(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), side, libMesh::Elem::top_parent(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1390 {
1391   const Elem* searched_elem = elem;
1392   if (elem->level() != 0)
1393     searched_elem = elem->top_parent();
1394 
1395   std::pair<std::multimap<const Elem*,
1396     std::pair<unsigned short int, boundary_id_type> >::const_iterator,
1397     std::multimap<const Elem*,
1398     std::pair<unsigned short int, boundary_id_type> >::const_iterator >
1399     e = _boundary_side_id\&.equal_range(searched_elem);
1400 
1401   // elem may have zero or multiple occurrences
1402   for (; e\&.first != e\&.second; ++e\&.first)
1403     {
1404       // if this is true we found the requested boundary_id
1405       // of the element and want to return the side
1406       if (e\&.first->second\&.second == boundary_id_in)
1407         {
1408           unsigned int side = e\&.first->second\&.first;
1409 
1410           // If we're on this external boundary then we share this
1411           // external boundary id
1412           if (elem->neighbor(side) == NULL)
1413             return side;
1414 
1415           // If we're on an internal boundary then we need to be sure
1416           // it's the same internal boundary as our top_parent
1417           const Elem *p = elem;
1418 
1419 #ifdef LIBMESH_ENABLE_AMR
1420 
1421           while (p != NULL)
1422             {
1423               const Elem *parent = p->parent();
1424               if (!parent->is_child_on_side(parent->which_child_am_i(p), side))
1425                 break;
1426               p = parent;
1427             }
1428 #endif
1429           // We're on that side of our top_parent; return it
1430           if (!p)
1431             return side;
1432         }
1433     }
1434 
1435   // if we get here, we found elem in the data structure but not
1436   // the requested boundary id, so return the default value
1437   return libMesh::invalid_uint;
1438 }
.fi
.SS "std::string & libMesh::BoundaryInfo::sideset_name (\fBboundary_id_type\fPid)"
Returns a writable reference for getting/setting an optional name for a sideset name\&. 
.PP
Definition at line 1845 of file boundary_info\&.C\&.
.PP
References _ss_id_to_name\&.
.PP
.nf
1846 {
1847   return _ss_id_to_name[id];
1848 }
.fi
.SS "void libMesh::BoundaryInfo::sync (\fBUnstructuredMesh\fP &boundary_mesh, \fBMeshData\fP *boundary_mesh_data = \fCNULL\fP, \fBMeshData\fP *this_mesh_data = \fCNULL\fP)"
Close the data structures and prepare for use\&. Synchronizes the \fCboundary_mesh\fP data structures with the \fCmesh\fP data structures\&. Allows the \fCboundary_mesh\fP to be used like any other mesh\&. Before this is called the \fCboundary_mesh\fP data structure is empty\&.
.PP
If you are using a \fBMeshData\fP class with this \fBMesh\fP, you can pass a pointer to both the boundary_mesh's \fBMeshData\fP object, and the \fBMeshData\fP object used for this mesh\&. 
.PP
Definition at line 132 of file boundary_info\&.C\&.
.PP
References _boundary_ids, _mesh, libMesh::ParallelObject::comm(), invalid_id, libMesh::MeshBase::is_serial(), and libMesh::Parallel::Communicator::set_union()\&.
.PP
.nf
135 {
136   std::set<boundary_id_type> request_boundary_ids(_boundary_ids);
137   request_boundary_ids\&.insert(invalid_id);
138   if (!_mesh\&.is_serial())
139     this->comm()\&.set_union(request_boundary_ids);
140 
141   this->sync(request_boundary_ids, boundary_mesh,
142              boundary_mesh_data, this_mesh_data);
143 }
.fi
.SS "void libMesh::BoundaryInfo::sync (const std::set< \fBboundary_id_type\fP > &requested_boundary_ids, \fBUnstructuredMesh\fP &boundary_mesh, \fBMeshData\fP *boundary_mesh_data = \fCNULL\fP, \fBMeshData\fP *this_mesh_data = \fCNULL\fP)"
Close the data structures and prepare for use\&. Synchronizes the \fCboundary_mesh\fP data structures with the \fCmesh\fP data structures\&. Allows the \fCboundary_mesh\fP to be used like any other mesh\&. Before this is called the \fCboundary_mesh\fP data structure is empty\&. Only boundary elements with the specified ids are extracted\&.
.PP
If you are using a \fBMeshData\fP class with this \fBMesh\fP, you can pass a pointer to both the boundary_mesh's \fBMeshData\fP object, and the \fBMeshData\fP object used for this mesh\&. Deleting 0 elements seems weird, but it's better encapsulating than exposing a set_is_serial(false) capability that might be easily misused\&.
.PP
If the boundary_mesh is still serial, that means we \fIcan't\fP parallelize it, so to make sure we can construct it in full on every processor we'll serialize the interior mesh\&. Use a temporary serializer here\&.
.PP
The boundary mesh elements will be one lower dimension than the interior mesh elements
.PP
Re-create the boundary mesh\&.
.PP
Definition at line 147 of file boundary_info\&.C\&.
.PP
References _boundary_side_id, _mesh, libMesh::MeshBase::add_elem(), libMesh::MeshBase::add_point(), libMesh::MeshData::assign(), libMesh::Elem::build_side(), libMesh::MeshBase::clear(), libMesh::ParallelObject::comm(), libMesh::MeshBase::delete_remote_elements(), libMesh::MeshBase::elem(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::Elem::INACTIVE, invalid_id, libMesh::DofObject::invalid_processor_id, libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), libMesh::MeshBase::mesh_dimension(), libMesh::Elem::n_nodes(), libMesh::MeshBase::n_partitions(), libMesh::ParallelObject::n_processors(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::node_ptr(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::parent(), libMesh::MeshBase::partitioner(), libMesh::MeshBase::pid_elements_begin(), libMesh::MeshBase::pid_elements_end(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Elem::set_interior_parent(), libMesh::MeshBase::set_mesh_dimension(), libMesh::MeshBase::set_n_partitions(), libMesh::Elem::set_node(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Elem::set_parent(), libMesh::Parallel::Communicator::set_union(), side, libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::top_parent()\&.
.PP
.nf
151 {
152   START_LOG("sync()", "BoundaryInfo");
153 
154   boundary_mesh\&.clear();
155 
161   if (!_mesh\&.is_serial())
162     boundary_mesh\&.delete_remote_elements();
163 
170   MeshSerializer serializer
171     (const_cast<MeshBase&>(_mesh), boundary_mesh\&.is_serial());
172 
177   boundary_mesh\&.set_mesh_dimension(_mesh\&.mesh_dimension() - 1);
178 
183   boundary_mesh\&.set_n_partitions() = _mesh\&.n_partitions();
184 
185   std::map<dof_id_type, dof_id_type> node_id_map;
186   std::map<std::pair<dof_id_type, unsigned char>, dof_id_type> side_id_map;
187 
188   // We'll do the same modulus trick that ParallelMesh uses to avoid
189   // id conflicts between different processors
190   dof_id_type next_node_id = this->processor_id(),
191     next_elem_id = this->processor_id();
192 
193   // We'll pass through the mesh once first to build
194   // the maps and count boundary nodes and elements
195   // We have to examine all elements here rather than just local
196   // elements, because it's possible to have a local boundary node
197   // that's not on a local boundary element, e\&.g\&. at the tip of a
198   // triangle\&.
199   const MeshBase::const_element_iterator end_el = _mesh\&.elements_end();
200   for (MeshBase::const_element_iterator el = _mesh\&.elements_begin();
201        el != end_el; ++el)
202     {
203       const Elem *elem = *el;
204 
205       for (unsigned char s=0; s<elem->n_sides(); s++)
206         if (elem->neighbor(s) == NULL) // on the boundary
207           {
208             // Get the top-level parent for this element
209             const Elem* top_parent = elem->top_parent();
210 
211             // A convenient typedef
212             typedef
213               std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
214               const_iterator Iter;
215 
216             // Find the right id number for that side
217             std::pair<Iter, Iter> pos = _boundary_side_id\&.equal_range(top_parent);
218 
219             bool add_this_side = false;
220             boundary_id_type this_bcid = invalid_id;
221 
222             for (; pos\&.first != pos\&.second; ++pos\&.first)
223               {
224                 this_bcid = pos\&.first->second\&.second;
225 
226                 // if this side is flagged with a boundary condition
227                 // and the user wants this id
228                 if ((pos\&.first->second\&.first == s) &&
229                     (requested_boundary_ids\&.count(this_bcid)))
230                   {
231                     add_this_side = true;
232                     break;
233                   }
234               }
235 
236             // if side s wasn't found or doesn't have a boundary
237             // condition we may still want to add it
238             if (pos\&.first == pos\&.second)
239               {
240                 this_bcid = invalid_id;
241                 if (requested_boundary_ids\&.count(this_bcid))
242                   add_this_side = true;
243               }
244 
245             if (add_this_side)
246               {
247                 std::pair<dof_id_type, unsigned char> side_pair(elem->id(), s);
248                 libmesh_assert (!side_id_map\&.count(side_pair));
249                 side_id_map[side_pair] = next_elem_id;
250                 next_elem_id += this->n_processors() + 1;
251 
252                 // Use a proxy element for the side to query nodes
253                 AutoPtr<Elem> side (elem->build_side(s));
254                 for (unsigned int n = 0; n != side->n_nodes(); ++n)
255                   {
256                     Node *node = side->get_node(n);
257                     libmesh_assert(node);
258 
259                     // In parallel we only know enough to number our own nodes\&.
260                     if (node->processor_id() != this->processor_id())
261                       continue;
262 
263                     dof_id_type node_id = node->id();
264                     if (!node_id_map\&.count(node_id))
265                       {
266                         node_id_map[node_id] = next_node_id;
267                         next_node_id += this->n_processors() + 1;
268                       }
269                   }
270               }
271           }
272     }
273 
274   // Join up the results from other processors
275   this->comm()\&.set_union(side_id_map);
276   this->comm()\&.set_union(node_id_map);
277 
278   // Finally we'll pass through any unpartitioned elements to add them
279   // to the maps and counts\&.
280   next_node_id = this->n_processors();
281   next_elem_id = this->n_processors();
282 
283   const MeshBase::const_element_iterator end_unpartitioned_el =
284     _mesh\&.pid_elements_end(DofObject::invalid_processor_id);
285   for (MeshBase::const_element_iterator el =
286          _mesh\&.pid_elements_begin(DofObject::invalid_processor_id);
287        el != end_unpartitioned_el; ++el)
288     {
289       const Elem *elem = *el;
290 
291       for (unsigned char s=0; s<elem->n_sides(); s++)
292         if (elem->neighbor(s) == NULL) // on the boundary
293           {
294             // Get the top-level parent for this element
295             const Elem* top_parent = elem->top_parent();
296 
297             // A convenient typedef
298             typedef
299               std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
300               const_iterator Iter;
301 
302             // Find the right id number for that side
303             std::pair<Iter, Iter> pos = _boundary_side_id\&.equal_range(top_parent);
304 
305             bool add_this_side = false;
306             boundary_id_type this_bcid = invalid_id;
307 
308             for (; pos\&.first != pos\&.second; ++pos\&.first)
309               {
310                 this_bcid = pos\&.first->second\&.second;
311                 // if this side is flagged with a boundary condition
312                 // and the user wants this id
313                 if ((pos\&.first->second\&.first == s) &&
314                     (requested_boundary_ids\&.count(this_bcid)))
315                   {
316                     add_this_side = true;
317                     break;
318                   }
319               }
320 
321             // if side s doesn't have a boundary condition we may
322             // still want to add it
323             if (pos\&.first == pos\&.second)
324               {
325                 this_bcid = invalid_id;
326                 if (requested_boundary_ids\&.count(this_bcid))
327                   add_this_side = true;
328               }
329 
330             if (add_this_side)
331               {
332                 std::pair<dof_id_type, unsigned char> side_pair(elem->id(), s);
333                 libmesh_assert (!side_id_map\&.count(side_pair));
334                 side_id_map[side_pair] = next_elem_id;
335                 next_elem_id += this->n_processors() + 1;
336 
337                 // Use a proxy element for the side to query nodes
338                 AutoPtr<Elem> side (elem->build_side(s));
339                 for (unsigned int n = 0; n != side->n_nodes(); ++n)
340                   {
341                     Node *node = side->get_node(n);
342                     libmesh_assert(node);
343                     dof_id_type node_id = node->id();
344                     if (!node_id_map\&.count(node_id))
345                       {
346                         node_id_map[node_id] = next_node_id;
347                         next_node_id += this->n_processors() + 1;
348                       }
349                   }
350               }
351           }
352     }
353 
354   // FIXME: ought to renumber side/node_id_map image to be contiguous
355   // to save memory, also ought to reserve memory
356 
357   // Let's add all the nodes to the boundary mesh
358 
359   MeshBase::const_node_iterator n_end  = _mesh\&.nodes_end();
360 
361   for(MeshBase::const_node_iterator n_it = _mesh\&.nodes_begin();
362       n_it != n_end; ++n_it)
363     {
364       const Node* node = *n_it;
365       dof_id_type node_id = node->id();
366       if (node_id_map\&.count(node_id))
367         boundary_mesh\&.add_point(*node, node_id_map[node_id], node->processor_id());
368     }
369 
370 
371   // Finally let's add the elements
372 
373 
374   for (MeshBase::const_element_iterator el = _mesh\&.elements_begin();
375        el != end_el; ++el)
376     {
377       const Elem* elem = *el;
378 
379       for (unsigned int s=0; s<elem->n_sides(); s++)
380         if (elem->neighbor(s) == NULL) // on the boundary
381           {
382             // Get the top-level parent for this element
383             const Elem* top_parent = elem->top_parent();
384 
385             // A convenient typedef
386             typedef
387               std::multimap<const Elem*, std::pair<unsigned short int, boundary_id_type> >::
388               const_iterator Iter;
389 
390             // Find the right id number for that side
391             std::pair<Iter, Iter> pos = _boundary_side_id\&.equal_range(top_parent);
392 
393             bool add_this_side = false;
394             boundary_id_type this_bcid = invalid_id;
395 
396             for (; pos\&.first != pos\&.second; ++pos\&.first)
397               {
398                 this_bcid = pos\&.first->second\&.second;
399 
400                 // if this side is flagged with a boundary condition
401                 // and the user wants this id
402                 if ((pos\&.first->second\&.first == s) &&
403                     (requested_boundary_ids\&.count(this_bcid)))
404                   {
405                     add_this_side = true;
406                     break;
407                   }
408               }
409 
410             // if side s wasn't found or doesn't have a boundary
411             // condition we may still want to add it
412             if (pos\&.first == pos\&.second)
413               {
414                 this_bcid = invalid_id;
415                 if (requested_boundary_ids\&.count(this_bcid))
416                   add_this_side = true;
417               }
418 
419             if (add_this_side)
420               {
421                 // Build the side - do not use a "proxy" element here:
422                 // This will be going into the boundary_mesh and needs to
423                 // stand on its own\&.
424                 AutoPtr<Elem> side (elem->build_side(s, false));
425 
426                 side->processor_id() = elem->processor_id();
427 
428                 const std::pair<dof_id_type, unsigned char> side_pair(elem->id(), s);
429 
430                 libmesh_assert(side_id_map\&.count(side_pair));
431 
432                 side->set_id(side_id_map[side_pair]);
433 
434                 // Add the side
435                 Elem* new_elem = boundary_mesh\&.add_elem(side\&.release());
436 
437                 // This side's Node pointers still point to the nodes of the original mesh\&.
438                 // We need to re-point them to the boundary mesh's nodes!  Since we copied *ALL* of
439                 // the original mesh's nodes over, we should be guaranteed to have the same ordering\&.
440                 for (unsigned int nn=0; nn<new_elem->n_nodes(); ++nn)
441                   {
442                     // Get the correct node pointer, based on the id()
443                     Node* new_node = boundary_mesh\&.node_ptr(node_id_map[new_elem->node(nn)]);
444 
445                     // sanity check: be sure that the new Node exists
446                     // and its global id really matches
447                     libmesh_assert (new_node);
448                     libmesh_assert_equal_to (new_node->id(), node_id_map[new_elem->node(nn)]);
449 
450                     // Assign the new node pointer
451                     new_elem->set_node(nn) = new_node;
452                   }
453 
454 #ifdef LIBMESH_ENABLE_AMR
455                 // Finally, set the parent and interior_parent links
456                 if (elem->parent())
457                   {
458                     const std::pair<dof_id_type, unsigned char> parent_side_pair(elem->parent()->id(), s);
459 
460                     libmesh_assert(side_id_map\&.count(parent_side_pair));
461 
462                     Elem* side_parent = boundary_mesh\&.elem(side_id_map[parent_side_pair]);
463 
464                     libmesh_assert(side_parent);
465 
466                     new_elem->set_parent(side_parent);
467 
468                     side_parent->set_refinement_flag(Elem::INACTIVE);
469 
470                     // Figuring out which child we are of our parent
471                     // is a trick\&.  Due to libMesh child numbering
472                     // conventions, if we are an element on a vertex,
473                     // then we share that vertex with our parent, with
474                     // the same local index\&.
475                     bool found_child = false;
476                     for (unsigned int v=0; v != new_elem->n_vertices(); ++v)
477                       if (new_elem->get_node(v) == side_parent->get_node(v))
478                         {
479                           side_parent->add_child(new_elem, v);
480                           found_child = true;
481                         }
482 
483                     // If we don't share any vertex with our parent,
484                     // then we're the fourth child (index 3) of a
485                     // triangle\&.
486                     if (!found_child)
487                       {
488                         libmesh_assert_equal_to (new_elem->n_vertices(), 3);
489                         side_parent->add_child(new_elem, 3);
490                       }
491                   }
492 #endif
493 
494                 new_elem->set_interior_parent (const_cast<Elem*>(elem));
495               }
496           }
497     }
498 
499   // When desired, copy the MeshData
500   // to the boundary_mesh
501   if ((boundary_mesh_data != NULL) && (this_mesh_data != NULL))
502     boundary_mesh_data->assign(*this_mesh_data);
503 
504   // Don't repartition this mesh; we want it to stay in sync with the
505   // interior partitioning\&.
506   boundary_mesh\&.partitioner()\&.reset(NULL);
507 
508   // Make boundary_mesh nodes and elements contiguous
509   boundary_mesh\&.prepare_for_use(/*skip_renumber =*/ false);
510 
511   // and finally distribute element partitioning to the nodes
512   Partitioner::set_node_processor_ids(boundary_mesh);
513 
514   STOP_LOG("sync()", "BoundaryInfo");
515 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBMeshBase\fP\fC [friend]\fP"

.PP
Definition at line 62 of file boundary_info\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "std::multimap<const \fBElem\fP*, std::pair<unsigned short int, \fBboundary_id_type\fP> > libMesh::BoundaryInfo::_boundary_edge_id\fC [private]\fP"
Data structure that maps edges of elements to boundary ids\&. This is only relevant in 3D\&. 
.PP
Definition at line 497 of file boundary_info\&.h\&.
.PP
Referenced by add_edge(), edge_boundary_ids(), n_edge_boundary_ids(), n_edge_conds(), operator=(), print_info(), print_summary(), raw_edge_boundary_ids(), remove(), and remove_edge()\&.
.SS "std::set<\fBboundary_id_type\fP> libMesh::BoundaryInfo::_boundary_ids\fC [private]\fP"
A collection of user-specified boundary ids for sides, edges and nodes\&. See _side_boundary_ids, _edge_boundary_ids and _node_boundary_ids for sets containing IDs for only sides and only nodes, respectively\&. 
.PP
Definition at line 512 of file boundary_info\&.h\&.
.PP
Referenced by add_edge(), add_node(), add_side(), clear(), get_boundary_ids(), n_boundary_ids(), operator=(), and sync()\&.
.SS "std::multimap<const \fBNode\fP*, \fBboundary_id_type\fP> libMesh::BoundaryInfo::_boundary_node_id\fC [private]\fP"
Data structure that maps nodes in the mesh to boundary ids\&. 
.PP
Definition at line 489 of file boundary_info\&.h\&.
.PP
Referenced by add_node(), boundary_ids(), build_node_boundary_ids(), build_node_list(), build_side_list_from_node_list(), clear(), clear_boundary_node_ids(), has_boundary_id(), n_boundary_ids(), n_nodeset_conds(), operator=(), print_info(), print_summary(), and remove()\&.
.SS "std::multimap<const \fBElem\fP*, std::pair<unsigned short int, \fBboundary_id_type\fP> > libMesh::BoundaryInfo::_boundary_side_id\fC [private]\fP"
Data structure that maps sides of elements to boundary ids\&. 
.PP
Definition at line 505 of file boundary_info\&.h\&.
.PP
Referenced by add_side(), boundary_id(), boundary_ids(), build_node_list_from_side_list(), build_side_boundary_ids(), build_side_list(), clear(), has_boundary_id(), n_boundary_conds(), n_boundary_ids(), operator=(), print_info(), print_summary(), raw_boundary_ids(), remove(), remove_side(), side_with_boundary_id(), and sync()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "std::set<\fBboundary_id_type\fP> libMesh::BoundaryInfo::_edge_boundary_ids\fC [private]\fP"
Set of user-specified boundary IDs for edges \fIonly\fP\&. This is only relevant in 3D\&. Note: _boundary_ids is the union of this set, _side_boundary_ids and _node_boundary_ids\&. 
.PP
Definition at line 526 of file boundary_info\&.h\&.
.PP
Referenced by add_edge(), and get_edge_boundary_ids()\&.
.SS "const \fBMeshBase\fP& libMesh::BoundaryInfo::_mesh\fC [private]\fP"
The \fBMesh\fP this boundary info pertains to\&. 
.PP
Definition at line 482 of file boundary_info\&.h\&.
.PP
Referenced by add_edge(), add_node(), add_side(), build_side_list_from_node_list(), n_boundary_conds(), n_edge_conds(), n_nodeset_conds(), operator=(), and sync()\&.
.SS "std::set<\fBboundary_id_type\fP> libMesh::BoundaryInfo::_node_boundary_ids\fC [private]\fP"
Set of user-specified boundary IDs for nodes \fIonly\fP\&. Note: _boundary_ids is the union of this set, _edge_boundary_ids and _side_boundary_ids\&. 
.PP
Definition at line 532 of file boundary_info\&.h\&.
.PP
Referenced by add_node(), clear(), get_node_boundary_ids(), and operator=()\&.
.SS "std::map<\fBboundary_id_type\fP, std::string> libMesh::BoundaryInfo::_ns_id_to_name\fC [private]\fP"
This structure maintains the mapping of named node sets for file formats that support named blocks\&. Currently this is only implemented for ExodusII 
.PP
Definition at line 546 of file boundary_info\&.h\&.
.PP
Referenced by get_id_by_name(), get_nodeset_name_map(), nodeset_name(), and set_nodeset_name_map()\&.
.SS "std::set<\fBboundary_id_type\fP> libMesh::BoundaryInfo::_side_boundary_ids\fC [private]\fP"
Set of user-specified boundary IDs for sides \fIonly\fP\&. Note: _boundary_ids is the union of this set, _edge_boundary_ids and _node_boundary_ids\&. 
.PP
Definition at line 518 of file boundary_info\&.h\&.
.PP
Referenced by add_side(), clear(), get_side_boundary_ids(), and operator=()\&.
.SS "std::map<\fBboundary_id_type\fP, std::string> libMesh::BoundaryInfo::_ss_id_to_name\fC [private]\fP"
This structure maintains the mapping of named side sets for file formats that support named blocks\&. Currently this is only implemented for ExodusII 
.PP
Definition at line 539 of file boundary_info\&.h\&.
.PP
Referenced by get_id_by_name(), get_sideset_name_map(), set_sideset_name_map(), and sideset_name()\&.
.SS "const \fBboundary_id_type\fP libMesh::BoundaryInfo::invalid_id = -123\fC [static]\fP"
Number used for internal use\&. This is the return value if a boundary condition is not specified\&. 
.PP
Definition at line 473 of file boundary_info\&.h\&.
.PP
Referenced by add_edge(), add_node(), add_side(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), boundary_id(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Modification::flatten(), libMesh::SerialMesh::stitching_helper(), sync(), libMesh::XdrIO::write_serialized_bcs(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::BoundaryInfo::Fill::~Fill()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
