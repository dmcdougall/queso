.TH "libMesh::Hex27" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Hex27 \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cell_hex27\&.h>\fP
.PP
Inherits \fBlibMesh::Hex\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBRefinementState\fP { \fBCOARSEN\fP = 0, \fBDO_NOTHING\fP, \fBREFINE\fP, \fBJUST_REFINED\fP, \fBJUST_COARSENED\fP, \fBINACTIVE\fP, \fBCOARSEN_INACTIVE\fP, \fBINVALID_REFINEMENTSTATE\fP }"
.br
.ti -1c
.RI "typedef \fBPredicates::multi_predicate\fP \fBPredicate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBHex27\fP (\fBElem\fP *p=NULL)"
.br
.ti -1c
.RI "\fBElemType\fP \fBtype\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_nodes\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_sub_elem\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_vertex\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual bool \fBis_edge\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual bool \fBis_face\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual bool \fBis_node_on_side\fP (const unsigned int n, const unsigned int s) const "
.br
.ti -1c
.RI "virtual bool \fBis_node_on_edge\fP (const unsigned int n, const unsigned int e) const "
.br
.ti -1c
.RI "virtual bool \fBhas_affine_map\fP () const "
.br
.ti -1c
.RI "\fBOrder\fP \fBdefault_order\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBkey\fP (const unsigned int s) const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBElem\fP > \fBbuild_side\fP (const unsigned int i, bool proxy) const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBElem\fP > \fBbuild_edge\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual void \fBconnectivity\fP (const unsigned int sc, const \fBIOPackage\fP iop, std::vector< \fBdof_id_type\fP > &conn) const "
.br
.ti -1c
.RI "unsigned int \fBn_second_order_adjacent_vertices\fP (const unsigned int) const "
.br
.ti -1c
.RI "unsigned short int \fBsecond_order_adjacent_vertex\fP (const unsigned int n, const unsigned int v) const "
.br
.ti -1c
.RI "virtual std::pair< unsigned 
.br
short int, unsigned short int > \fBsecond_order_child_vertex\fP (const unsigned int n) const "
.br
.ti -1c
.RI "unsigned int \fBn_sides\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_vertices\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_edges\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_faces\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_children\fP () const "
.br
.ti -1c
.RI "virtual bool \fBis_child_on_side\fP (const unsigned int c, const unsigned int s) const "
.br
.ti -1c
.RI "virtual bool \fBis_edge_on_side\fP (const unsigned int e, const unsigned int s) const "
.br
.ti -1c
.RI "virtual unsigned int \fBopposite_side\fP (const unsigned int s) const "
.br
.ti -1c
.RI "virtual unsigned int \fBopposite_node\fP (const unsigned int n, const unsigned int s) const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBElem\fP > \fBside\fP (const unsigned int i) const "
.br
.ti -1c
.RI "\fBReal\fP \fBquality\fP (const \fBElemQuality\fP q) const "
.br
.ti -1c
.RI "std::pair< \fBReal\fP, \fBReal\fP > \fBqual_bounds\fP (const \fBElemQuality\fP q) const "
.br
.ti -1c
.RI "unsigned int \fBdim\fP () const "
.br
.ti -1c
.RI "bool \fBinfinite\fP () const "
.br
.ti -1c
.RI "virtual const \fBPoint\fP & \fBpoint\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual \fBPoint\fP & \fBpoint\fP (const unsigned int i)"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBnode\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual unsigned int \fBlocal_node\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "unsigned int \fBget_node_index\fP (const \fBNode\fP *node_ptr) const "
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBget_node\fP (const unsigned int i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP *& \fBset_node\fP (const unsigned int i)"
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBsubdomain_id\fP () const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP & \fBsubdomain_id\fP ()"
.br
.ti -1c
.RI "const \fBElem\fP * \fBreference_elem\fP () const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBElem\fP &rhs) const "
.br
.ti -1c
.RI "\fBElem\fP * \fBneighbor\fP (const unsigned int i) const "
.br
.ti -1c
.RI "const \fBElem\fP * \fBtopological_neighbor\fP (const unsigned int i, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP &point_locator, const \fBPeriodicBoundaries\fP *pb) const "
.br
.ti -1c
.RI "\fBElem\fP * \fBtopological_neighbor\fP (const unsigned int i, \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP &point_locator, const \fBPeriodicBoundaries\fP *pb)"
.br
.ti -1c
.RI "bool \fBhas_topological_neighbor\fP (const \fBElem\fP *elem, const \fBMeshBase\fP &\fBmesh\fP, const \fBPointLocatorBase\fP &point_locator, \fBPeriodicBoundaries\fP *pb) const "
.br
.ti -1c
.RI "void \fBset_neighbor\fP (const unsigned int i, \fBElem\fP *n)"
.br
.ti -1c
.RI "bool \fBhas_neighbor\fP (const \fBElem\fP *elem) const "
.br
.ti -1c
.RI "\fBElem\fP * \fBchild_neighbor\fP (\fBElem\fP *elem) const "
.br
.ti -1c
.RI "const \fBElem\fP * \fBchild_neighbor\fP (const \fBElem\fP *elem) const "
.br
.ti -1c
.RI "bool \fBon_boundary\fP () const "
.br
.ti -1c
.RI "bool \fBis_semilocal\fP (const \fBprocessor_id_type\fP my_pid) const "
.br
.ti -1c
.RI "unsigned int \fBwhich_neighbor_am_i\fP (const \fBElem\fP *e) const "
.br
.ti -1c
.RI "unsigned int \fBwhich_side_am_i\fP (const \fBElem\fP *e) const "
.br
.ti -1c
.RI "bool \fBcontains_vertex_of\fP (const \fBElem\fP *e) const "
.br
.ti -1c
.RI "bool \fBcontains_edge_of\fP (const \fBElem\fP *e) const "
.br
.ti -1c
.RI "void \fBfind_point_neighbors\fP (const \fBPoint\fP &p, std::set< const \fBElem\fP * > &neighbor_set) const "
.br
.ti -1c
.RI "void \fBfind_point_neighbors\fP (std::set< const \fBElem\fP * > &neighbor_set) const "
.br
.ti -1c
.RI "void \fBfind_edge_neighbors\fP (const \fBPoint\fP &p1, const \fBPoint\fP &p2, std::set< const \fBElem\fP * > &neighbor_set) const "
.br
.ti -1c
.RI "void \fBfind_edge_neighbors\fP (std::set< const \fBElem\fP * > &neighbor_set) const "
.br
.ti -1c
.RI "void \fBmake_links_to_me_remote\fP ()"
.br
.ti -1c
.RI "void \fBmake_links_to_me_local\fP (unsigned int n)"
.br
.ti -1c
.RI "virtual bool \fBis_remote\fP () const "
.br
.ti -1c
.RI "void \fBwrite_connectivity\fP (std::ostream &\fBout\fP, const \fBIOPackage\fP iop) const "
.br
.ti -1c
.RI "virtual unsigned int \fBn_neighbors\fP () const "
.br
.ti -1c
.RI "virtual \fBPoint\fP \fBcentroid\fP () const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBhmin\fP () const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBhmax\fP () const "
.br
.ti -1c
.RI "virtual \fBReal\fP \fBvolume\fP () const "
.br
.ti -1c
.RI "virtual bool \fBcontains_point\fP (const \fBPoint\fP &p, \fBReal\fP tol=\fBTOLERANCE\fP) const "
.br
.ti -1c
.RI "virtual bool \fBclose_to_point\fP (const \fBPoint\fP &p, \fBReal\fP tol) const "
.br
.ti -1c
.RI "virtual bool \fBis_linear\fP () const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "bool \fBactive\fP () const "
.br
.ti -1c
.RI "bool \fBancestor\fP () const "
.br
.ti -1c
.RI "bool \fBsubactive\fP () const "
.br
.ti -1c
.RI "bool \fBhas_children\fP () const "
.br
.ti -1c
.RI "bool \fBhas_ancestor_children\fP () const "
.br
.ti -1c
.RI "bool \fBis_ancestor_of\fP (const \fBElem\fP *descendant) const "
.br
.ti -1c
.RI "const \fBElem\fP * \fBparent\fP () const "
.br
.ti -1c
.RI "\fBElem\fP * \fBparent\fP ()"
.br
.ti -1c
.RI "void \fBset_parent\fP (\fBElem\fP *p)"
.br
.ti -1c
.RI "const \fBElem\fP * \fBtop_parent\fP () const "
.br
.ti -1c
.RI "const \fBElem\fP * \fBinterior_parent\fP () const "
.br
.ti -1c
.RI "void \fBset_interior_parent\fP (\fBElem\fP *p)"
.br
.ti -1c
.RI "\fBReal\fP \fBlength\fP (const unsigned int n1, const unsigned int n2) const "
.br
.ti -1c
.RI "unsigned int \fBlevel\fP () const "
.br
.ti -1c
.RI "unsigned int \fBp_level\fP () const "
.br
.ti -1c
.RI "\fBElem\fP * \fBchild\fP (const unsigned int i) const "
.br
.ti -1c
.RI "unsigned int \fBwhich_child_am_i\fP (const \fBElem\fP *e) const "
.br
.ti -1c
.RI "virtual bool \fBis_child_on_edge\fP (const unsigned int c, const unsigned int e) const "
.br
.ti -1c
.RI "void \fBadd_child\fP (\fBElem\fP *elem)"
.br
.ti -1c
.RI "void \fBadd_child\fP (\fBElem\fP *elem, unsigned int c)"
.br
.ti -1c
.RI "void \fBreplace_child\fP (\fBElem\fP *elem, unsigned int c)"
.br
.ti -1c
.RI "void \fBfamily_tree\fP (std::vector< const \fBElem\fP * > &family, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBtotal_family_tree\fP (std::vector< const \fBElem\fP * > &active_family, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBactive_family_tree\fP (std::vector< const \fBElem\fP * > &active_family, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBfamily_tree_by_side\fP (std::vector< const \fBElem\fP * > &family, const unsigned int \fBside\fP, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBactive_family_tree_by_side\fP (std::vector< const \fBElem\fP * > &family, const unsigned int \fBside\fP, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBfamily_tree_by_neighbor\fP (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *\fBneighbor\fP, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBfamily_tree_by_subneighbor\fP (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *\fBneighbor\fP, const \fBElem\fP *subneighbor, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "void \fBactive_family_tree_by_neighbor\fP (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *\fBneighbor\fP, const bool \fBreset\fP=true) const "
.br
.ti -1c
.RI "\fBRefinementState\fP \fBrefinement_flag\fP () const "
.br
.ti -1c
.RI "void \fBset_refinement_flag\fP (const \fBRefinementState\fP rflag)"
.br
.ti -1c
.RI "\fBRefinementState\fP \fBp_refinement_flag\fP () const "
.br
.ti -1c
.RI "void \fBset_p_refinement_flag\fP (const \fBRefinementState\fP pflag)"
.br
.ti -1c
.RI "unsigned int \fBmax_descendant_p_level\fP () const "
.br
.ti -1c
.RI "unsigned int \fBmin_p_level_by_neighbor\fP (const \fBElem\fP *\fBneighbor\fP, unsigned int current_min) const "
.br
.ti -1c
.RI "unsigned int \fBmin_new_p_level_by_neighbor\fP (const \fBElem\fP *\fBneighbor\fP, unsigned int current_min) const "
.br
.ti -1c
.RI "void \fBset_p_level\fP (const unsigned int p)"
.br
.ti -1c
.RI "void \fBhack_p_level\fP (const unsigned int p)"
.br
.ti -1c
.RI "virtual void \fBrefine\fP (\fBMeshRefinement\fP &mesh_refinement)"
.br
.ti -1c
.RI "void \fBcoarsen\fP ()"
.br
.ti -1c
.RI "void \fBcontract\fP ()"
.br
.ti -1c
.RI "void \fBlibmesh_assert_valid_neighbors\fP () const "
.br
.ti -1c
.RI "void \fBlibmesh_assert_valid_node_pointers\fP () const "
.br
.ti -1c
.RI "\fBside_iterator\fP \fBboundary_sides_begin\fP ()"
.br
.ti -1c
.RI "\fBside_iterator\fP \fBboundary_sides_end\fP ()"
.br
.ti -1c
.RI "virtual \fBPoint\fP \fBorigin\fP () const "
.br
.ti -1c
.RI "unsigned int \fBpacked_size\fP () const "
.br
.ti -1c
.RI "void \fBnullify_neighbors\fP ()"
.br
.ti -1c
.RI "void \fBclear_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBset_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBclear_dofs\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_dofs\fP (const unsigned int sys_num=\fBlibMesh::invalid_uint\fP)"
.br
.ti -1c
.RI "void \fBinvalidate_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_processor_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_dofs\fP (const unsigned int s, const unsigned int var=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBid\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP & \fBset_id\fP ()"
.br
.ti -1c
.RI "void \fBset_id\fP (const \fBdof_id_type\fP dofid)"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBunique_id\fP () const "
.br
.ti -1c
.RI "\fBunique_id_type\fP & \fBset_unique_id\fP ()"
.br
.ti -1c
.RI "bool \fBvalid_id\fP () const "
.br
.ti -1c
.RI "bool \fBvalid_unique_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP & \fBprocessor_id\fP ()"
.br
.ti -1c
.RI "void \fBprocessor_id\fP (const \fBprocessor_id_type\fP pid)"
.br
.ti -1c
.RI "bool \fBvalid_processor_id\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_systems\fP () const "
.br
.ti -1c
.RI "void \fBset_n_systems\fP (const unsigned int s)"
.br
.ti -1c
.RI "void \fBadd_system\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_var_groups\fP (const unsigned int s) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s) const "
.br
.ti -1c
.RI "void \fBset_n_vars_per_group\fP (const unsigned int s, const std::vector< unsigned int > &nvpg)"
.br
.ti -1c
.RI "unsigned int \fBn_comp\fP (const unsigned int s, const unsigned int var) const "
.br
.ti -1c
.RI "unsigned int \fBn_comp_group\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "void \fBset_n_comp\fP (const unsigned int s, const unsigned int var, const unsigned int ncomp)"
.br
.ti -1c
.RI "void \fBset_n_comp_group\fP (const unsigned int s, const unsigned int vg, const unsigned int ncomp)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBdof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp) const "
.br
.ti -1c
.RI "void \fBset_dof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp, const \fBdof_id_type\fP dn)"
.br
.ti -1c
.RI "bool \fBhas_dofs\fP (const unsigned int s=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "void \fBset_vg_dof_base\fP (const unsigned int s, const unsigned int vg, const \fBdof_id_type\fP db)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBvg_dof_base\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBpacked_indexing_size\fP () const "
.br
.ti -1c
.RI "void \fBunpack_indexing\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.ti -1c
.RI "void \fBpack_indexing\fP (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > > target) const "
.br
.ti -1c
.RI "void \fBdebug_buffer\fP () const "
.br
.ti -1c
.RI "void \fBset_buffer\fP (const std::vector< \fBdof_id_type\fP > &buf)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static \fBElemType\fP \fBsecond_order_equivalent_type\fP (const \fBElemType\fP et, const bool full_ordered=true)"
.br
.ti -1c
.RI "static \fBElemType\fP \fBfirst_order_equivalent_type\fP (const \fBElemType\fP et)"
.br
.ti -1c
.RI "static \fBAutoPtr\fP< \fBElem\fP > \fBbuild\fP (const \fBElemType\fP \fBtype\fP, \fBElem\fP *p=NULL)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBunpackable_indexing_size\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBDofObject\fP * \fBold_dof_object\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const unsigned int \fBside_nodes_map\fP [6][9]"
.br
.ti -1c
.RI "static const unsigned int \fBedge_nodes_map\fP [12][3]"
.br
.ti -1c
.RI "static const unsigned int \fBtype_to_n_nodes_map\fP [\fBINVALID_ELEM\fP]"
.br
.ti -1c
.RI "static const unsigned int \fBtype_to_n_sides_map\fP [\fBINVALID_ELEM\fP]"
.br
.ti -1c
.RI "static const unsigned int \fBtype_to_n_edges_map\fP [\fBINVALID_ELEM\fP]"
.br
.ti -1c
.RI "static const \fBdof_id_type\fP \fBinvalid_id\fP = static_cast<\fBdof_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBunique_id_type\fP \fBinvalid_unique_id\fP = static_cast<\fBunique_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBprocessor_id_type\fP \fBinvalid_processor_id\fP = static_cast<\fBprocessor_id_type\fP>(-1)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "float \fBembedding_matrix\fP (const unsigned int i, const unsigned int j, const unsigned int k) const "
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBdof_id_type\fP \fBcompute_key\fP (\fBdof_id_type\fP n0)"
.br
.ti -1c
.RI "static \fBdof_id_type\fP \fBcompute_key\fP (\fBdof_id_type\fP n0, \fBdof_id_type\fP n1)"
.br
.ti -1c
.RI "static \fBdof_id_type\fP \fBcompute_key\fP (\fBdof_id_type\fP n0, \fBdof_id_type\fP n1, \fBdof_id_type\fP n2)"
.br
.ti -1c
.RI "static \fBdof_id_type\fP \fBcompute_key\fP (\fBdof_id_type\fP n0, \fBdof_id_type\fP n1, \fBdof_id_type\fP n2, \fBdof_id_type\fP n3)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBNode\fP * \fB_nodelinks_data\fP [27]"
.br
.ti -1c
.RI "\fBElem\fP * \fB_elemlinks_data\fP [7+(LIBMESH_DIM >3)]"
.br
.ti -1c
.RI "\fBNode\fP ** \fB_nodes\fP"
.br
.ti -1c
.RI "\fBElem\fP ** \fB_elemlinks\fP"
.br
.ti -1c
.RI "\fBElem\fP ** \fB_children\fP"
.br
.ti -1c
.RI "unsigned char \fB_rflag\fP"
.br
.ti -1c
.RI "unsigned char \fB_pflag\fP"
.br
.ti -1c
.RI "unsigned char \fB_p_level\fP"
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fB_sbd_id\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static const float \fB_embedding_matrix\fP [8][27][27]"
.br
.ti -1c
.RI "static const unsigned short int \fB_second_order_adjacent_vertices\fP [12][2]"
.br
.ti -1c
.RI "static const unsigned short int \fB_second_order_vertex_child_number\fP [27]"
.br
.ti -1c
.RI "static const unsigned short int \fB_second_order_vertex_child_index\fP [27]"
.br
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const unsigned short int \fB_remaining_second_order_adjacent_vertices\fP [6][4]"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBHex27\fP\fP is an element in 3D composed of 27 nodes\&. It is numbered like this: 
.PP
.nf
HEX27:      7              18             6
o--------------o--------------o
/:             /              /|
/ :            /              / |
/  :           /              /  |
19/   :        25/            17/   |
o--------------o--------------o    |
/     :        /              /|    |
/    15o       /    23o       / |  14o
/       :      /              /  |   /|
4/        :   16/             5/   |  / |
o--------------o--------------o    | /  |
|         :    |   26         |    |/   |
|  24o    :    |    o         |  22o    |
|         :    |       10     |   /|    |
|        3o....|.........o....|../.|....o
|        .     |              | /  |   / 2
|       .    21|            13|/   |  /
12 o--------------o--------------o    | /
|     .        |              |    |/
|  11o         | 20o          |    o
|   .          |              |   / 9
|  .           |              |  /
| .            |              | /
|.             |              |/
o--------------o--------------o
0              8              1

.fi
.PP
 
.PP
Definition at line 71 of file cell_hex27\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef \fBPredicates::multi_predicate\fP \fBlibMesh::Elem::Predicate\fP\fC [inherited]\fP"
Useful iterator typedefs 
.PP
Definition at line 1069 of file elem\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBlibMesh::Elem::RefinementState\fP\fC [inherited]\fP"
Useful ENUM describing the refinement state of an element\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICOARSEN \fP\fP
.TP
\fB\fIDO_NOTHING \fP\fP
.TP
\fB\fIREFINE \fP\fP
.TP
\fB\fIJUST_REFINED \fP\fP
.TP
\fB\fIJUST_COARSENED \fP\fP
.TP
\fB\fIINACTIVE \fP\fP
.TP
\fB\fICOARSEN_INACTIVE \fP\fP
.TP
\fB\fIINVALID_REFINEMENTSTATE \fP\fP
.PP
Definition at line 827 of file elem\&.h\&.
.PP
.nf
827                        { COARSEN = 0,
828                          DO_NOTHING,
829                          REFINE,
830                          JUST_REFINED,
831                          JUST_COARSENED,
832                          INACTIVE,
833                          COARSEN_INACTIVE,
834                          INVALID_REFINEMENTSTATE };
.fi
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Hex27::Hex27 (\fBElem\fP *p = \fCNULL\fP)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. By default this element has no parent\&. 
.PP
Definition at line 253 of file cell_hex27\&.h\&.
.PP
.nf
253                     :
254   Hex(Hex27::n_nodes(), p, _nodelinks_data)
255 {
256 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool libMesh::Elem::active () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element is active (i\&.e\&. has no active descendants), \fCfalse\fP otherwise\&. Note that it suffices to check the first child only\&. Always returns \fCtrue\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1578 of file elem\&.h\&.
.PP
References libMesh::Elem::COARSEN_INACTIVE, libMesh::Elem::INACTIVE, and libMesh::Elem::refinement_flag()\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MetisPartitioner::_do_partition(), libMesh::DofMap::_dof_indices(), libMesh::MeshRefinement::_refine_elements(), libMesh::Elem::active_family_tree(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::active_family_tree_by_side(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::HPCoarsenTest::add_projection(), libMesh::Elem::ancestor(), libMesh::Patch::build_around_element(), libMesh::ParmetisPartitioner::build_graph(), libMesh::Elem::coarsen(), libMesh::MeshRefinement::coarsen_elements(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::contract(), libMesh::Elem::contract(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::Elem::family_tree(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::find_edge_neighbors(), libMesh::Patch::find_face_neighbors(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::Elem::find_point_neighbors(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::Elem::get_info(), libMesh::ErrorVector::is_active_elem(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_local(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::DofMap::old_dof_indices(), libMesh::PointLocatorList::operator()(), libMesh::Elem::refine(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Elem::subactive(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
1579 {
1580 #ifdef LIBMESH_ENABLE_AMR
1581   if ((this->refinement_flag() == INACTIVE) ||
1582       (this->refinement_flag() == COARSEN_INACTIVE))
1583     return false;
1584   else
1585     return true;
1586 #else
1587   return true;
1588 #endif
1589 }
.fi
.SS "void libMesh::Elem::active_family_tree (std::vector< const \fBElem\fP * > &active_family, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBfamily_tree()\fP\fP member, but only adds the active children\&. Can be thought of as removing all the inactive elements from the vector created by \fCfamily_tree\fP, but is implemented more efficiently\&. 
.PP
Definition at line 1493 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree(), libMesh::Elem::child(), libMesh::Elem::is_remote(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::Elem::active_family_tree(), libMesh::ParmetisPartitioner::build_graph(), and libMesh::Partitioner::set_parent_processor_ids()\&.
.PP
.nf
1495 {
1496   // The "family tree" doesn't include subactive elements
1497   libmesh_assert(!this->subactive());
1498 
1499   // Clear the vector if the flag reset tells us to\&.
1500   if (reset)
1501     active_family\&.clear();
1502 
1503   // Add this element to the family tree if it is active
1504   if (this->active())
1505     active_family\&.push_back(this);
1506 
1507   // Otherwise recurse into the element's children\&.
1508   // Do not clear the vector any more\&.
1509   else
1510     for (unsigned int c=0; c<this->n_children(); c++)
1511       if (!this->child(c)->is_remote())
1512         this->child(c)->active_family_tree (active_family, false);
1513 }
.fi
.SS "void libMesh::Elem::active_family_tree_by_neighbor (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *neighbor, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBactive_family_tree()\fP\fP member, but only adds elements which are next to \fCneighbor\fP\&. 
.PP
Definition at line 1648 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::child(), libMesh::Elem::has_neighbor(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::remote_elem, and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::active_family_tree_by_neighbor(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::Elem::find_edge_neighbors(), libMesh::Patch::find_face_neighbors(), libMesh::Elem::find_point_neighbors(), and libMesh::SparsityPattern::Build::operator()()\&.
.PP
.nf
1651 {
1652   // The "family tree" doesn't include subactive elements
1653   libmesh_assert(!this->subactive());
1654 
1655   // Clear the vector if the flag reset tells us to\&.
1656   if (reset)
1657     family\&.clear();
1658 
1659   // This only makes sense if we're already a neighbor
1660   if (this->level() >= neighbor_in->level())
1661     libmesh_assert (this->has_neighbor(neighbor_in));
1662 
1663   // Add an active element to the family tree\&.
1664   if (this->active())
1665     family\&.push_back(this);
1666 
1667   // Or recurse into an ancestor element's children\&.
1668   // Do not clear the vector any more\&.
1669   else if (!this->active())
1670     for (unsigned int c=0; c<this->n_children(); c++)
1671       {
1672         Elem *current_child = this->child(c);
1673         if (current_child != remote_elem && current_child->has_neighbor(neighbor_in))
1674           current_child->active_family_tree_by_neighbor (family, neighbor_in, false);
1675       }
1676 }
.fi
.SS "void libMesh::Elem::active_family_tree_by_side (std::vector< const \fBElem\fP * > &family, const unsigned intside, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBactive_family_tree()\fP\fP member, but only adds elements which are next to \fCside\fP\&. 
.PP
Definition at line 1543 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree_by_side(), libMesh::Elem::child(), libMesh::Elem::is_child_on_side(), libMesh::Elem::is_remote(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::active_family_tree_by_side(), libMesh::BoundaryInfo::build_node_list_from_side_list(), libMesh::ExodusII_IO_Helper::write_sidesets(), and libMesh::Nemesis_IO_Helper::write_sidesets()\&.
.PP
.nf
1546 {
1547   // The "family tree" doesn't include subactive elements
1548   libmesh_assert(!this->subactive());
1549 
1550   // Clear the vector if the flag reset tells us to\&.
1551   if (reset)
1552     family\&.clear();
1553 
1554   libmesh_assert_less (s, this->n_sides());
1555 
1556   // Add an active element to the family tree\&.
1557   if (this->active())
1558     family\&.push_back(this);
1559 
1560   // Or recurse into an ancestor element's children\&.
1561   // Do not clear the vector any more\&.
1562   else
1563     for (unsigned int c=0; c<this->n_children(); c++)
1564       if (!this->child(c)->is_remote() && this->is_child_on_side(c, s))
1565         this->child(c)->active_family_tree_by_side (family, s, false);
1566 }
.fi
.SS "void libMesh::Elem::add_child (\fBElem\fP *elem)\fC [inherited]\fP"
Adds a child pointer to the array of children of this element\&. If this is the first child to be added, this method allocates memory in the parent's _children array, otherwise, it just sets the pointer\&. 
.PP
Definition at line 1378 of file elem\&.C\&.
.PP
References libMesh::Elem::_children, libMesh::err, libMesh::Elem::n_children(), libMesh::Elem::parent(), libMesh::remote_elem, and libMesh::Elem::set_child()\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::CheckpointIO::read_connectivity(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1379 {
1380   if(_children == NULL)
1381     {
1382       _children = new Elem*[this->n_children()];
1383 
1384       for (unsigned int c=0; c<this->n_children(); c++)
1385         this->set_child(c, NULL);
1386     }
1387 
1388   for (unsigned int c=0; c<this->n_children(); c++)
1389     {
1390       if(this->_children[c] == NULL || this->_children[c] == remote_elem)
1391         {
1392           libmesh_assert_equal_to (this, elem->parent());
1393           this->set_child(c, elem);
1394           return;
1395         }
1396     }
1397 
1398   libMesh::err << "Error: Tried to add a child to an element with full children array"
1399                << std::endl;
1400   libmesh_error();
1401 }
.fi
.SS "void libMesh::Elem::add_child (\fBElem\fP *elem, unsigned intc)\fC [inherited]\fP"
Adds a new child pointer to the specified index in the array of children of this element\&. If this is the first child to be added, this method allocates memory in the parent's _children array, otherwise, it just sets the pointer\&. 
.PP
Definition at line 1405 of file elem\&.C\&.
.PP
References libMesh::Elem::_children, libMesh::Elem::child(), libMesh::Elem::has_children(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::parent(), libMesh::remote_elem, and libMesh::Elem::set_child()\&.
.PP
.nf
1406 {
1407   if(!this->has_children())
1408     {
1409       _children = new Elem*[this->n_children()];
1410 
1411       for (unsigned int i=0; i<this->n_children(); i++)
1412         this->set_child(i, NULL);
1413     }
1414 
1415   libmesh_assert (this->_children[c] == NULL || this->child(c) == remote_elem);
1416   libmesh_assert (elem == remote_elem || this == elem->parent());
1417 
1418   this->set_child(c, elem);
1419 }
.fi
.SS "void libMesh::DofObject::add_system ()\fC [inherited]\fP"
Adds an additional system to the \fC\fBDofObject\fP\fP 
.PP
Definition at line 187 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), and libMesh::DofObject::set_n_systems()\&.
.PP
.nf
188 {
189   // quick return?
190   if (this->n_systems() == 0)
191     {
192       this->set_n_systems(1);
193       return;
194     }
195 
196   DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
197 
198   std::advance(it, this->n_systems());
199 
200   // this inserts the current vector size at the position for the new system - creating the
201   // entry we need for the new system indicating there are 0 variables\&.
202   _idx_buf\&.insert(it, _idx_buf\&.size());
203 
204   // cache this value before we screw it up!
205   const unsigned int ns_orig = this->n_systems();
206 
207   // incriment the number of systems and the offsets for each of
208   // the systems including the new one we just added\&.
209   for (unsigned int i=0; i<ns_orig+1; i++)
210     _idx_buf[i]++;
211 
212   libmesh_assert_equal_to (this->n_systems(), (ns_orig+1));
213   libmesh_assert_equal_to (this->n_vars(ns_orig), 0);
214   libmesh_assert_equal_to (this->n_var_groups(ns_orig), 0);
215 }
.fi
.SS "bool libMesh::Elem::ancestor () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element is an ancestor (i\&.e\&. has an active child or ancestor child), \fCfalse\fP otherwise\&. Always returns \fCfalse\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1356 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::Elem::child(), and libMesh::Elem::has_children()\&.
.PP
Referenced by libMesh::Elem::ancestor(), libMesh::UnstructuredMesh::contract(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Elem::get_info(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshRefinement::make_coarsening_compatible(), and libMesh::Elem::refine()\&.
.PP
.nf
1357 {
1358 #ifdef LIBMESH_ENABLE_AMR
1359 
1360   if (this->active())
1361     return false;
1362 
1363   if (!this->has_children())
1364     return false;
1365   if (this->child(0)->active())
1366     return true;
1367 
1368   return this->child(0)->ancestor();
1369 #else
1370   return false;
1371 #endif
1372 }
.fi
.SS "\fBElem::side_iterator\fP libMesh::Elem::boundary_sides_begin ()\fC [inherited]\fP"
Iterator accessor functions 
.PP
Definition at line 2191 of file elem\&.C\&.
.PP
References libMesh::Elem::_first_side(), and libMesh::Elem::_last_side()\&.
.PP
.nf
2192 {
2193   Predicates::BoundarySide<SideIter> bsp;
2194   return side_iterator(this->_first_side(), this->_last_side(), bsp);
2195 }
.fi
.SS "\fBElem::side_iterator\fP libMesh::Elem::boundary_sides_end ()\fC [inherited]\fP"

.PP
Definition at line 2200 of file elem\&.C\&.
.PP
References libMesh::Elem::_last_side()\&.
.PP
.nf
2201 {
2202   Predicates::BoundarySide<SideIter> bsp;
2203   return side_iterator(this->_last_side(), this->_last_side(), bsp);
2204 }
.fi
.SS "\fBAutoPtr\fP< \fBElem\fP > libMesh::Elem::build (const \fBElemType\fPtype, \fBElem\fP *p = \fCNULL\fP)\fC [static]\fP, \fC [inherited]\fP"
Build an element of type \fCtype\fP\&. Since this method allocates memory the new \fC\fBElem\fP\fP is returned in a \fCAutoPtr<>\fP 
.PP
Definition at line 209 of file elem\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::err, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFEDGE2, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, libMesh::INFQUAD6, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, libMesh::TRI3SUBDIVISION, and libMesh::TRI6\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::create_submesh(), libMesh::MeshTools::Modification::flatten(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::Elem::refine(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.PP
.nf
211 {
212   Elem* elem = NULL;
213 
214   switch (type)
215     {
216       // 1D elements
217     case EDGE2:
218       {
219         elem = new Edge2(p);
220         break;
221       }
222     case EDGE3:
223       {
224         elem = new Edge3(p);
225         break;
226       }
227     case EDGE4:
228       {
229         elem = new Edge4(p);
230         break;
231       }
232 
233 
234 
235       // 2D elements
236     case TRI3:
237       {
238         elem = new Tri3(p);
239         break;
240       }
241     case TRI3SUBDIVISION:
242       {
243         elem = new Tri3Subdivision(p);
244         break;
245       }
246     case TRI6:
247       {
248         elem = new Tri6(p);
249         break;
250       }
251     case QUAD4:
252       {
253         elem = new Quad4(p);
254         break;
255       }
256     case QUAD8:
257       {
258         elem = new Quad8(p);
259         break;
260       }
261     case QUAD9:
262       {
263         elem = new Quad9(p);
264         break;
265       }
266 
267 
268       // 3D elements
269     case TET4:
270       {
271         elem = new Tet4(p);
272         break;
273       }
274     case TET10:
275       {
276         elem = new Tet10(p);
277         break;
278       }
279     case HEX8:
280       {
281         elem = new Hex8(p);
282         break;
283       }
284     case HEX20:
285       {
286         elem = new Hex20(p);
287         break;
288       }
289     case HEX27:
290       {
291         elem = new Hex27(p);
292         break;
293       }
294     case PRISM6:
295       {
296         elem = new Prism6(p);
297         break;
298       }
299     case PRISM15:
300       {
301         elem = new Prism15(p);
302         break;
303       }
304     case PRISM18:
305       {
306         elem = new Prism18(p);
307         break;
308       }
309     case PYRAMID5:
310       {
311         elem = new Pyramid5(p);
312         break;
313       }
314     case PYRAMID13:
315       {
316         elem = new Pyramid13(p);
317         break;
318       }
319     case PYRAMID14:
320       {
321         elem = new Pyramid14(p);
322         break;
323       }
324 
325 
326 
327 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
328 
329       // 1D infinite elements
330     case INFEDGE2:
331       {
332         elem = new InfEdge2(p);
333         break;
334       }
335 
336 
337       // 2D infinite elements
338     case INFQUAD4:
339       {
340         elem = new InfQuad4(p);
341         break;
342       }
343     case INFQUAD6:
344       {
345         elem = new InfQuad6(p);
346         break;
347       }
348 
349 
350       // 3D infinite elements
351     case INFHEX8:
352       {
353         elem = new InfHex8(p);
354         break;
355       }
356     case INFHEX16:
357       {
358         elem = new InfHex16(p);
359         break;
360       }
361     case INFHEX18:
362       {
363         elem = new InfHex18(p);
364         break;
365       }
366     case INFPRISM6:
367       {
368         elem = new InfPrism6(p);
369         break;
370       }
371     case INFPRISM12:
372       {
373         elem = new InfPrism12(p);
374         break;
375       }
376 
377 #endif
378 
379     default:
380       {
381         libMesh::err << "ERROR: Undefined element type!\&." << std::endl;
382         libmesh_error();
383       }
384     }
385 
386 
387   AutoPtr<Elem> ap(elem);
388   return ap;
389 }
.fi
.SS "\fBAutoPtr\fP< \fBElem\fP > libMesh::Hex27::build_edge (const unsigned inti) const\fC [virtual]\fP"
Builds a \fCEDGE3\fP built coincident with edge i\&. The \fCAutoPtr<Elem>\fP handles the memory aspect\&. 
.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 321 of file cell_hex27\&.C\&.
.PP
References libMesh::Hex::n_edges()\&.
.PP
.nf
322 {
323   libmesh_assert_less (i, this->n_edges());
324 
325   return AutoPtr<Elem>(new SideEdge<Edge3,Hex27>(this,i));
326 }
.fi
.SS "\fBAutoPtr\fP< \fBElem\fP > libMesh::Hex27::build_side (const unsigned inti, boolproxy) const\fC [virtual]\fP"
Builds a \fCQUAD9\fP built coincident with face i\&. The \fCAutoPtr<Elem>\fP handles the memory aspect\&. 
.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 203 of file cell_hex27\&.C\&.
.PP
References libMesh::Elem::get_node(), libMesh::Hex::n_sides(), and libMesh::Elem::subdomain_id()\&.
.PP
.nf
205 {
206   libmesh_assert_less (i, this->n_sides());
207 
208   if (proxy)
209     {
210       AutoPtr<Elem> ap(new Side<Quad9,Hex27>(this,i));
211       return ap;
212     }
213 
214   else
215     {
216       AutoPtr<Elem> face(new Quad9);
217       face->subdomain_id() = this->subdomain_id();
218 
219       // Think of a unit cube: (-1,1) x (-1,1) x (1,1)
220       switch (i)
221         {
222         case 0:  // the face at z=0
223           {
224             face->set_node(0) = this->get_node(0);
225             face->set_node(1) = this->get_node(3);
226             face->set_node(2) = this->get_node(2);
227             face->set_node(3) = this->get_node(1);
228             face->set_node(4) = this->get_node(11);
229             face->set_node(5) = this->get_node(10);
230             face->set_node(6) = this->get_node(9);
231             face->set_node(7) = this->get_node(8);
232             face->set_node(8) = this->get_node(20);
233 
234             return face;
235           }
236         case 1:  // the face at y = 0
237           {
238             face->set_node(0) = this->get_node(0);
239             face->set_node(1) = this->get_node(1);
240             face->set_node(2) = this->get_node(5);
241             face->set_node(3) = this->get_node(4);
242             face->set_node(4) = this->get_node(8);
243             face->set_node(5) = this->get_node(13);
244             face->set_node(6) = this->get_node(16);
245             face->set_node(7) = this->get_node(12);
246             face->set_node(8) = this->get_node(21);
247 
248             return face;
249           }
250         case 2:  // the face at x=1
251           {
252             face->set_node(0) = this->get_node(1);
253             face->set_node(1) = this->get_node(2);
254             face->set_node(2) = this->get_node(6);
255             face->set_node(3) = this->get_node(5);
256             face->set_node(4) = this->get_node(9);
257             face->set_node(5) = this->get_node(14);
258             face->set_node(6) = this->get_node(17);
259             face->set_node(7) = this->get_node(13);
260             face->set_node(8) = this->get_node(22);
261 
262             return face;
263           }
264         case 3: // the face at y=1
265           {
266             face->set_node(0) = this->get_node(2);
267             face->set_node(1) = this->get_node(3);
268             face->set_node(2) = this->get_node(7);
269             face->set_node(3) = this->get_node(6);
270             face->set_node(4) = this->get_node(10);
271             face->set_node(5) = this->get_node(15);
272             face->set_node(6) = this->get_node(18);
273             face->set_node(7) = this->get_node(14);
274             face->set_node(8) = this->get_node(23);
275 
276             return face;
277           }
278         case 4: // the face at x=0
279           {
280             face->set_node(0) = this->get_node(3);
281             face->set_node(1) = this->get_node(0);
282             face->set_node(2) = this->get_node(4);
283             face->set_node(3) = this->get_node(7);
284             face->set_node(4) = this->get_node(11);
285             face->set_node(5) = this->get_node(12);
286             face->set_node(6) = this->get_node(19);
287             face->set_node(7) = this->get_node(15);
288             face->set_node(8) = this->get_node(24);
289 
290             return face;
291           }
292         case 5: // the face at z=1
293           {
294             face->set_node(0) = this->get_node(4);
295             face->set_node(1) = this->get_node(5);
296             face->set_node(2) = this->get_node(6);
297             face->set_node(3) = this->get_node(7);
298             face->set_node(4) = this->get_node(16);
299             face->set_node(5) = this->get_node(17);
300             face->set_node(6) = this->get_node(18);
301             face->set_node(7) = this->get_node(19);
302             face->set_node(8) = this->get_node(25);
303 
304             return face;
305           }
306         default:
307           {
308             libmesh_error();
309             return face;
310           }
311         }
312     }
313 
314   // We'll never get here\&.
315   libmesh_error();
316   AutoPtr<Elem> ap(NULL);  return ap;
317 }
.fi
.SS "\fBPoint\fP libMesh::Elem::centroid () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the centriod of the element\&. The centroid is computed as the average of all the element vertices\&. This method is overloadable since some derived elements might want to use shortcuts to compute their centroid\&. 
.RE
.PP

.PP
Definition at line 400 of file elem\&.C\&.
.PP
References libMesh::TypeVector< T >::add(), and libMesh::Elem::n_vertices()\&.
.PP
Referenced by libMesh::SFCPartitioner::_do_partition(), libMesh::MeshCommunication::assign_global_indices(), libMesh::CentroidPartitioner::compute_centroids(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::LocationMap< T >::point_of(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::Prism6::volume(), and libMesh::Hex8::volume()\&.
.PP
.nf
401 {
402   Point cp;
403 
404   for (unsigned int n=0; n<this->n_vertices(); n++)
405     cp\&.add (this->point(n));
406 
407   return (cp /= static_cast<Real>(this->n_vertices()));
408 }
.fi
.SS "\fBElem\fP * libMesh::Elem::child (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the $ i^{th} $ child for this element\&. Do not call if this element has no children, i\&.e\&. is active\&. 
.RE
.PP

.PP
Definition at line 1796 of file elem\&.h\&.
.PP
References libMesh::Elem::_children, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::Elem::active_family_tree(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::active_family_tree_by_side(), libMesh::Elem::add_child(), libMesh::HPCoarsenTest::add_projection(), libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::ancestor(), libMesh::Elem::coarsen(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::Elem::family_tree(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::Elem::has_ancestor_children(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::refine(), libMesh::Elem::replace_child(), libMesh::Elem::set_p_level(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::MeshTools::Modification::smooth(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::total_family_tree(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::Elem::which_child_am_i(), and libMesh::XdrIO::write_serialized_connectivity()\&.
.PP
.nf
1797 {
1798   libmesh_assert(_children);
1799   libmesh_assert(_children[i]);
1800 
1801   return _children[i];
1802 }
.fi
.SS "\fBElem\fP * libMesh::Elem::child_neighbor (\fBElem\fP *elem) const\fC [inline]\fP, \fC [inherited]\fP"
If the element \fCelem\fP in question is a neighbor of a child of this element, this returns a pointer to that child\&. Otherwise it returns NULL\&. 
.PP
Definition at line 1469 of file elem\&.h\&.
.PP
References libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), and libMesh::Elem::parent()\&.
.PP
.nf
1470 {
1471   for (unsigned int n=0; n<elem->n_neighbors(); n++)
1472     if (elem->neighbor(n) &&
1473         elem->neighbor(n)->parent() == this)
1474       return elem->neighbor(n);
1475 
1476   return NULL;
1477 }
.fi
.SS "const \fBElem\fP * libMesh::Elem::child_neighbor (const \fBElem\fP *elem) const\fC [inline]\fP, \fC [inherited]\fP"
If the element \fCelem\fP in question is a neighbor of a child of this element, this returns a pointer to that child\&. Otherwise it returns NULL\&. 
.PP
Definition at line 1482 of file elem\&.h\&.
.PP
References libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), and libMesh::Elem::parent()\&.
.PP
.nf
1483 {
1484   for (unsigned int n=0; n<elem->n_neighbors(); n++)
1485     if (elem->neighbor(n) &&
1486         elem->neighbor(n)->parent() == this)
1487       return elem->neighbor(n);
1488 
1489   return NULL;
1490 }
.fi
.SS "void libMesh::DofObject::clear_dofs ()\fC [inline]\fP, \fC [inherited]\fP"
Clear the \fC\fBDofMap\fP\fP data structures and return to a pristine state\&. 
.PP
Definition at line 577 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::libmesh_assert(), and libMesh::DofObject::n_systems()\&.
.PP
Referenced by libMesh::DofObject::set_n_systems(), and libMesh::DofObject::~DofObject()\&.
.PP
.nf
578 {
579   // vector swap trick to force deallocation
580   index_buffer_t()\&.swap(_idx_buf);
581 
582   libmesh_assert_equal_to (this->n_systems(), 0);
583   libmesh_assert (_idx_buf\&.empty());
584 }
.fi
.SS "void libMesh::DofObject::clear_old_dof_object ()\fC [inherited]\fP"
Sets the \fCold_dof_object\fP to NULL 
.PP
Definition at line 134 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::old_dof_object\&.
.PP
Referenced by libMesh::DofObject::operator=(), libMesh::DofObject::set_old_dof_object(), libMesh::DofObject::unpack_indexing(), and libMesh::DofObject::~DofObject()\&.
.PP
.nf
135 {
136   delete this->old_dof_object;
137   this->old_dof_object = NULL;
138 }
.fi
.SS "bool libMesh::Elem::close_to_point (const \fBPoint\fP &p, \fBReal\fPtol) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if this element is 'close' to the point p, where 'close' is determined by the tolerance tol\&. 
.RE
.PP

.PP
Definition at line 1780 of file elem\&.C\&.
.PP
References libMesh::Elem::point_test()\&.
.PP
.nf
1781 {
1782   // This test uses the user's passed-in tolerance for the
1783   // bounding box test as well, thereby allowing the routine to
1784   // find points which are not only "in" the element, but also
1785   // "nearby" to within some tolerance\&.
1786   return this->point_test(p, tol, tol);
1787 }
.fi
.SS "void libMesh::Elem::coarsen ()\fC [inherited]\fP"
Coarsen the element\&. This is not virtual since it is the same for all element types\&. 
.PP
Definition at line 149 of file elem_refinement\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::TypeVector< T >::add_scaled(), libMesh::Elem::child(), libMesh::Elem::COARSEN, libMesh::Elem::COARSEN_INACTIVE, libMesh::Elem::embedding_matrix(), libMesh::Elem::get_node(), libMesh::Elem::INACTIVE, libMesh::Elem::JUST_COARSENED, libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_nodes(), libMesh::Elem::p_level(), libMesh::Elem::point(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::Elem::set_p_level(), and libMesh::Elem::set_refinement_flag()\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements()\&.
.PP
.nf
150 {
151   libmesh_assert_equal_to (this->refinement_flag(), Elem::COARSEN_INACTIVE);
152   libmesh_assert (!this->active());
153 
154   // We no longer delete children until MeshRefinement::contract()
155   // delete [] _children;
156   // _children = NULL;
157 
158   unsigned int parent_p_level = 0;
159 
160   // re-compute hanging node nodal locations
161   for (unsigned int c=0; c<this->n_children(); c++)
162     {
163       Elem *mychild = this->child(c);
164       if (mychild == remote_elem)
165         continue;
166       for (unsigned int nc=0; nc<mychild->n_nodes(); nc++)
167         {
168           Point new_pos;
169           bool calculated_new_pos = false;
170 
171           for (unsigned int n=0; n<this->n_nodes(); n++)
172             {
173               // The value from the embedding matrix
174               const float em_val = this->embedding_matrix(c,nc,n);
175 
176               // The node location is somewhere between existing vertices
177               if ((em_val != 0\&.) && (em_val != 1\&.))
178                 {
179                   new_pos\&.add_scaled (this->point(n), em_val);
180                   calculated_new_pos = true;
181                 }
182             }
183 
184           if(calculated_new_pos)
185             {
186               //Move the existing node back into it's original location
187               for(unsigned int i=0; i<LIBMESH_DIM; i++)
188                 {
189                   Point & child_node = *(mychild->get_node(nc));
190                   child_node(i)=new_pos(i);
191                 }
192             }
193         }
194     }
195 
196   for (unsigned int c=0; c<this->n_children(); c++)
197     {
198       Elem *mychild = this->child(c);
199       if (mychild == remote_elem)
200         continue;
201       libmesh_assert_equal_to (mychild->refinement_flag(), Elem::COARSEN);
202       mychild->set_refinement_flag(Elem::INACTIVE);
203       if (mychild->p_level() > parent_p_level)
204         parent_p_level = mychild->p_level();
205     }
206 
207   this->set_refinement_flag(Elem::JUST_COARSENED);
208   this->set_p_level(parent_p_level);
209 
210   libmesh_assert (this->active());
211 }
.fi
.SS "\fBdof_id_type\fP libMesh::Elem::compute_key (\fBdof_id_type\fPn0)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Compute a key from the specified nodes\&. 
.PP
Definition at line 1933 of file elem\&.h\&.
.PP
Referenced by libMesh::Tet::key(), libMesh::Prism::key(), libMesh::Pyramid::key(), libMesh::Hex::key(), libMesh::Tri::key(), libMesh::InfPrism::key(), libMesh::InfHex::key(), libMesh::Quad::key(), libMesh::InfQuad::key(), libMesh::Edge::key(), libMesh::Quad9::key(), libMesh::Quad8::key(), libMesh::Tri6::key(), key(), libMesh::Prism18::key(), and libMesh::InfHex18::key()\&.
.PP
.nf
1934 {
1935   return n0;
1936 }
.fi
.SS "\fBdof_id_type\fP libMesh::Elem::compute_key (\fBdof_id_type\fPn0, \fBdof_id_type\fPn1)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Compute a key from the specified nodes\&. 
.PP
Definition at line 1941 of file elem\&.h\&.
.PP
References libMesh::Utility::hashword2(), and libMesh::swap()\&.
.PP
.nf
1943 {
1944   // Order the two so that n0 < n1
1945   if (n0 > n1) std::swap (n0, n1);
1946 
1947   return Utility::hashword2(n0, n1);
1948 }
.fi
.SS "\fBdof_id_type\fP libMesh::Elem::compute_key (\fBdof_id_type\fPn0, \fBdof_id_type\fPn1, \fBdof_id_type\fPn2)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Compute a key from the specified nodes\&. 
.PP
Definition at line 1953 of file elem\&.h\&.
.PP
References libMesh::Utility::hashword(), libMesh::libmesh_assert(), and libMesh::swap()\&.
.PP
.nf
1956 {
1957   // Order the numbers such that n0 < n1 < n2\&.
1958   // We'll do it in 3 steps like this:
1959   //
1960   //     n0         n1                n2
1961   //     min(n0,n1) max(n0,n1)        n2
1962   //     min(n0,n1) min(n2,max(n0,n1) max(n2,max(n0,n1)
1963   //           |\   /|                  |
1964   //           | \ / |                  |
1965   //           |  /  |                  |
1966   //           | /  \|                  |
1967   //  gb min= min   max              gb max
1968 
1969   // Step 1
1970   if (n0 > n1) std::swap (n0, n1);
1971 
1972   // Step 2
1973   if (n1 > n2) std::swap (n1, n2);
1974 
1975   // Step 3
1976   if (n0 > n1) std::swap (n0, n1);
1977 
1978   libmesh_assert ((n0 < n1) && (n1 < n2));
1979 
1980   dof_id_type array[3] = {n0, n1, n2};
1981   return Utility::hashword(array, 3);
1982 }
.fi
.SS "\fBdof_id_type\fP libMesh::Elem::compute_key (\fBdof_id_type\fPn0, \fBdof_id_type\fPn1, \fBdof_id_type\fPn2, \fBdof_id_type\fPn3)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Compute a key from the specified nodes\&. 
.PP
Definition at line 1987 of file elem\&.h\&.
.PP
References libMesh::Utility::hashword(), libMesh::libmesh_assert(), and libMesh::swap()\&.
.PP
.nf
1991 {
1992   // Sort first
1993   // Step 1
1994   if (n0 > n1) std::swap (n0, n1);
1995 
1996   // Step 2
1997   if (n2 > n3) std::swap (n2, n3);
1998 
1999   // Step 3
2000   if (n0 > n2) std::swap (n0, n2);
2001 
2002   // Step 4
2003   if (n1 > n3) std::swap (n1, n3);
2004 
2005   // Finally sort step 5
2006   if (n1 > n2) std::swap (n1, n2);
2007 
2008   libmesh_assert ((n0 < n1) && (n1 < n2) && (n2 < n3));
2009 
2010   dof_id_type array[4] = {n0, n1, n2, n3};
2011   return Utility::hashword(array, 4);
2012 }
.fi
.SS "void libMesh::Hex27::connectivity (const unsigned intsc, const \fBIOPackage\fPiop, std::vector< \fBdof_id_type\fP > &conn) const\fC [virtual]\fP"
Returns the connectivity for this element in a specific format, which is specified by the IOPackage tag\&. This method supercedes the tecplot_connectivity(\&.\&.\&.) and vtk_connectivity(\&.\&.\&.) routines\&. 
.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 330 of file cell_hex27\&.C\&.
.PP
References libMesh::Elem::_nodes, libMesh::INVALID_IO_PACKAGE, libMesh::libmesh_assert(), n_sub_elem(), libMesh::Elem::node(), libMesh::TECPLOT, and libMesh::VTK\&.
.PP
.nf
333 {
334   libmesh_assert(_nodes);
335   libmesh_assert_less (sc, this->n_sub_elem());
336   libmesh_assert_not_equal_to (iop, INVALID_IO_PACKAGE);
337 
338   conn\&.resize(8);
339 
340   switch (iop)
341     {
342     case TECPLOT:
343       {
344         switch (sc)
345           {
346           case 0:
347 
348             conn[0] = this->node(0)+1;
349             conn[1] = this->node(8)+1;
350             conn[2] = this->node(20)+1;
351             conn[3] = this->node(11)+1;
352             conn[4] = this->node(12)+1;
353             conn[5] = this->node(21)+1;
354             conn[6] = this->node(26)+1;
355             conn[7] = this->node(24)+1;
356 
357             return;
358 
359           case 1:
360 
361             conn[0] = this->node(8)+1;
362             conn[1] = this->node(1)+1;
363             conn[2] = this->node(9)+1;
364             conn[3] = this->node(20)+1;
365             conn[4] = this->node(21)+1;
366             conn[5] = this->node(13)+1;
367             conn[6] = this->node(22)+1;
368             conn[7] = this->node(26)+1;
369 
370             return;
371 
372           case 2:
373 
374             conn[0] = this->node(11)+1;
375             conn[1] = this->node(20)+1;
376             conn[2] = this->node(10)+1;
377             conn[3] = this->node(3)+1;
378             conn[4] = this->node(24)+1;
379             conn[5] = this->node(26)+1;
380             conn[6] = this->node(23)+1;
381             conn[7] = this->node(15)+1;
382 
383             return;
384 
385           case 3:
386 
387             conn[0] = this->node(20)+1;
388             conn[1] = this->node(9)+1;
389             conn[2] = this->node(2)+1;
390             conn[3] = this->node(10)+1;
391             conn[4] = this->node(26)+1;
392             conn[5] = this->node(22)+1;
393             conn[6] = this->node(14)+1;
394             conn[7] = this->node(23)+1;
395 
396             return;
397 
398           case 4:
399 
400             conn[0] = this->node(12)+1;
401             conn[1] = this->node(21)+1;
402             conn[2] = this->node(26)+1;
403             conn[3] = this->node(24)+1;
404             conn[4] = this->node(4)+1;
405             conn[5] = this->node(16)+1;
406             conn[6] = this->node(25)+1;
407             conn[7] = this->node(19)+1;
408 
409             return;
410 
411           case 5:
412 
413             conn[0] = this->node(21)+1;
414             conn[1] = this->node(13)+1;
415             conn[2] = this->node(22)+1;
416             conn[3] = this->node(26)+1;
417             conn[4] = this->node(16)+1;
418             conn[5] = this->node(5)+1;
419             conn[6] = this->node(17)+1;
420             conn[7] = this->node(25)+1;
421 
422             return;
423 
424           case 6:
425 
426             conn[0] = this->node(24)+1;
427             conn[1] = this->node(26)+1;
428             conn[2] = this->node(23)+1;
429             conn[3] = this->node(15)+1;
430             conn[4] = this->node(19)+1;
431             conn[5] = this->node(25)+1;
432             conn[6] = this->node(18)+1;
433             conn[7] = this->node(7)+1;
434 
435             return;
436 
437           case 7:
438 
439             conn[0] = this->node(26)+1;
440             conn[1] = this->node(22)+1;
441             conn[2] = this->node(14)+1;
442             conn[3] = this->node(23)+1;
443             conn[4] = this->node(25)+1;
444             conn[5] = this->node(17)+1;
445             conn[6] = this->node(6)+1;
446             conn[7] = this->node(18)+1;
447 
448             return;
449 
450           default:
451             libmesh_error();
452           }
453       }
454 
455     case VTK:
456       {
457         // VTK now supports VTK_TRIQUADRATIC_HEXAHEDRON directly
458         conn\&.resize(27);
459 
460         conn[0] = this->node(0);
461         conn[1] = this->node(1);
462         conn[2] = this->node(2);
463         conn[3] = this->node(3);
464         conn[4] = this->node(4);
465         conn[5] = this->node(5);
466         conn[6] = this->node(6);
467         conn[7] = this->node(7);
468         conn[8] = this->node(8);
469         conn[9] = this->node(9);
470         conn[10] = this->node(10);
471         conn[11] = this->node(11); //
472         conn[12] = this->node(16);
473         conn[13] = this->node(17);
474         conn[14] = this->node(18);
475         conn[15] = this->node(19);
476         conn[16] = this->node(12);
477         conn[17] = this->node(13); //
478         conn[18] = this->node(14);
479         conn[19] = this->node(15);
480         conn[20] = this->node(24);
481         conn[21] = this->node(22);
482         conn[22] = this->node(21);
483         conn[23] = this->node(23);
484         conn[24] = this->node(20);
485         conn[25] = this->node(25);
486         conn[26] = this->node(26);
487 
488         return;
489 
490         /*
491           switch (sc)
492           {
493           case 0:
494 
495           conn[0] = this->node(0);
496           conn[1] = this->node(8);
497           conn[2] = this->node(20);
498           conn[3] = this->node(11);
499           conn[4] = this->node(12);
500           conn[5] = this->node(21);
501           conn[6] = this->node(26);
502           conn[7] = this->node(24);
503 
504           return;
505 
506           case 1:
507 
508           conn[0] = this->node(8);
509           conn[1] = this->node(1);
510           conn[2] = this->node(9);
511           conn[3] = this->node(20);
512           conn[4] = this->node(21);
513           conn[5] = this->node(13);
514           conn[6] = this->node(22);
515           conn[7] = this->node(26);
516 
517           return;
518 
519           case 2:
520 
521           conn[0] = this->node(11);
522           conn[1] = this->node(20);
523           conn[2] = this->node(10);
524           conn[3] = this->node(3);
525           conn[4] = this->node(24);
526           conn[5] = this->node(26);
527           conn[6] = this->node(23);
528           conn[7] = this->node(15);
529 
530           return;
531 
532           case 3:
533 
534           conn[0] = this->node(20);
535           conn[1] = this->node(9);
536           conn[2] = this->node(2);
537           conn[3] = this->node(10);
538           conn[4] = this->node(26);
539           conn[5] = this->node(22);
540           conn[6] = this->node(14);
541           conn[7] = this->node(23);
542 
543           return;
544 
545           case 4:
546 
547           conn[0] = this->node(12);
548           conn[1] = this->node(21);
549           conn[2] = this->node(26);
550           conn[3] = this->node(24);
551           conn[4] = this->node(4);
552           conn[5] = this->node(16);
553           conn[6] = this->node(25);
554           conn[7] = this->node(19);
555 
556           return;
557 
558           case 5:
559 
560           conn[0] = this->node(21);
561           conn[1] = this->node(13);
562           conn[2] = this->node(22);
563           conn[3] = this->node(26);
564           conn[4] = this->node(16);
565           conn[5] = this->node(5);
566           conn[6] = this->node(17);
567           conn[7] = this->node(25);
568 
569           return;
570 
571           case 6:
572 
573           conn[0] = this->node(24);
574           conn[1] = this->node(26);
575           conn[2] = this->node(23);
576           conn[3] = this->node(15);
577           conn[4] = this->node(19);
578           conn[5] = this->node(25);
579           conn[6] = this->node(18);
580           conn[7] = this->node(7);
581 
582           return;
583 
584           case 7:
585 
586           conn[0] = this->node(26);
587           conn[1] = this->node(22);
588           conn[2] = this->node(14);
589           conn[3] = this->node(23);
590           conn[4] = this->node(25);
591           conn[5] = this->node(17);
592           conn[6] = this->node(6);
593           conn[7] = this->node(18);
594 
595           return;
596 
597           default:
598           libmesh_error();
599           }
600         */
601       }
602 
603     default:
604       libmesh_error();
605     }
606 
607   libmesh_error();
608 }
.fi
.SS "bool libMesh::Elem::contains_edge_of (const \fBElem\fP *e) const\fC [inherited]\fP"
This function returns true iff an edge of \fCe\fP is contained in this element\&. (Internally, this is done by checking whether at least two vertices of \fCe\fP are contained in this element)\&. 
.PP
Definition at line 588 of file elem\&.C\&.
.PP
References libMesh::Elem::contains_point(), libMesh::Elem::n_vertices(), and libMesh::Elem::point()\&.
.PP
Referenced by libMesh::Elem::find_edge_neighbors()\&.
.PP
.nf
589 {
590   unsigned int num_contained_edges = 0;
591 
592   // Our vertices are the first numbered nodes
593   for (unsigned int n = 0; n != e->n_vertices(); ++n)
594     {
595       if (this->contains_point(e->point(n)))
596         {
597           num_contained_edges++;
598           if(num_contained_edges>=2)
599             {
600               return true;
601             }
602         }
603     }
604   return false;
605 }
.fi
.SS "bool libMesh::Elem::contains_point (const \fBPoint\fP &p, \fBReal\fPtol = \fC\fBTOLERANCE\fP\fP) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if the point p is contained in this element, false otherwise\&.
.RE
.PP
For linear elements, performs an initial tight bounding box check (as an optimization step) and (if that passes) then uses the user-defined tolerance 'tol' in a call to inverse_map() to actually test if the point is in the element\&. For quadratic elements, the bounding box optimization is skipped, and only the inverse_map() steps are performed\&.
.PP
Note that this routine should not be used to determine if a point is merely 'nearby' an element to within some tolerance\&. For that, use \fBElem::close_to_point()\fP instead\&. 
.PP
Reimplemented in \fBlibMesh::InfHex8\fP, \fBlibMesh::InfPrism6\fP, and \fBlibMesh::InfQuad4\fP\&.
.PP
Definition at line 1755 of file elem\&.C\&.
.PP
References libMesh::err, libMesh::Elem::point_test(), and libMesh::TOLERANCE\&.
.PP
Referenced by libMesh::Elem::contains_edge_of(), libMesh::Elem::contains_vertex_of(), libMesh::Elem::find_edge_neighbors(), libMesh::Elem::find_point_neighbors(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), and libMesh::HPSingularity::select_refinement()\&.
.PP
.nf
1756 {
1757   // We currently allow the user to enlarge the bounding box by
1758   // providing a tol > TOLERANCE (so this routine is identical to
1759   // Elem::close_to_point()), but print a warning so that the
1760   // user can eventually switch his code over to calling close_to_point()
1761   // instead, which is intended to be used for this purpose\&.
1762   if ( tol > TOLERANCE )
1763     {
1764       libmesh_do_once(libMesh::err
1765                       << "WARNING: Resizing bounding box to match user-specified tolerance!\n"
1766                       << "In the future, calls to Elem::contains_point() with tol > TOLERANCE\n"
1767                       << "will be more optimized, but should not be used\n"
1768                       << "to search for points 'close to' elements!\n"
1769                       << "Instead, use Elem::close_to_point() for this purpose\&.\n"
1770                       << std::endl;);
1771       return this->point_test(p, tol, tol);
1772     }
1773   else
1774     return this->point_test(p, TOLERANCE, tol);
1775 }
.fi
.SS "bool libMesh::Elem::contains_vertex_of (const \fBElem\fP *e) const\fC [inherited]\fP"
This function returns true iff a vertex of e is contained in this element 
.PP
Definition at line 577 of file elem\&.C\&.
.PP
References libMesh::Elem::contains_point(), libMesh::Elem::n_vertices(), and libMesh::Elem::point()\&.
.PP
Referenced by libMesh::Elem::find_point_neighbors()\&.
.PP
.nf
578 {
579   // Our vertices are the first numbered nodes
580   for (unsigned int n = 0; n != e->n_vertices(); ++n)
581     if (this->contains_point(e->point(n)))
582       return true;
583   return false;
584 }
.fi
.SS "void libMesh::Elem::contract ()\fC [inherited]\fP"
Contract an active element, i\&.e\&. remove pointers to any subactive children\&. This should only be called via MeshRefinement::contract, which will also remove subactive children from the mesh 
.PP
Definition at line 215 of file elem_refinement\&.C\&.
.PP
References libMesh::Elem::_children, libMesh::Elem::active(), libMesh::Elem::DO_NOTHING, libMesh::Elem::JUST_COARSENED, libMesh::libmesh_assert(), libMesh::Elem::refinement_flag(), and libMesh::Elem::set_refinement_flag()\&.
.PP
Referenced by libMesh::UnstructuredMesh::contract()\&.
.PP
.nf
216 {
217   // Subactive elements get deleted entirely, not contracted
218   libmesh_assert (this->active());
219 
220   // Active contracted elements no longer can have children
221   delete [] _children;
222   _children = NULL;
223 
224   if (this->refinement_flag() == Elem::JUST_COARSENED)
225     this->set_refinement_flag(Elem::DO_NOTHING);
226 }
.fi
.SS "void libMesh::DofObject::debug_buffer () const\fC [inherited]\fP"
Print our buffer for debugging\&. 
.PP
Definition at line 543 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, and libMesh::out\&.
.PP
.nf
544 {
545   libMesh::out << " [ ";
546   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
547     libMesh::out << _idx_buf[i] << " ";
548   libMesh::out << "]\n";
549 }
.fi
.SS "\fBOrder\fP libMesh::Hex27::default_order () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
SECOND 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 134 of file cell_hex27\&.h\&.
.PP
References libMesh::SECOND\&.
.PP
.nf
134 { return SECOND; }
.fi
.SS "unsigned int libMesh::Cell::dim () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
3, the dimensionality of the object\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 60 of file cell\&.h\&.
.PP
.nf
60 { return 3; }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 789 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::start_idx(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::DofMap::distribute_dofs(), libMesh::DofObject::DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::HPCoarsenTest::select_refinement(), libMesh::DofObject::set_dof_number(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
792 {
793   libmesh_assert_less (s,    this->n_systems());
794   libmesh_assert_less (var,  this->n_vars(s));
795   libmesh_assert_less (comp, this->n_comp(s,var));
796 
797   const unsigned int
798     vg            = this->var_to_vg(s,var),
799     start_idx_sys = this->start_idx(s);
800 
801   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
802 
803   const dof_id_type
804     base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
805 
806   // if the first component is invalid, they
807   // are all invalid
808   if (base_idx == invalid_id)
809     return invalid_id;
810 
811   // otherwise the index is the first component
812   // index augemented by the component number
813   else
814     {
815       const unsigned int
816         ncg = this->n_comp_group(s,vg),
817         vig = this->system_var_to_vg_var(s,vg,var);
818 
819       // std::cout << "base_idx, var, vg, vig, ncg, comp="
820       // << base_idx << " "
821       // << var << " "
822       // << vg << " "
823       // << vig << " "
824       // << ncg << " "
825       // << comp << '\n';
826 
827       return libmesh_cast_int<dof_id_type>(base_idx + vig*ncg + comp);
828     }
829 }
.fi
.SS "float libMesh::Hex27::embedding_matrix (const unsigned inti, const unsigned intj, const unsigned intk) const\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"
Matrix used to create the elements children\&. 
.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 217 of file cell_hex27\&.h\&.
.PP
References _embedding_matrix\&.
.PP
.nf
220   { return _embedding_matrix[i][j][k]; }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "void libMesh::Elem::family_tree (std::vector< const \fBElem\fP * > &family, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Fills the vector \fCfamily\fP with the children of this element, recursively\&. So, calling this method on a twice-refined element will give you the element itself, its direct children, and their children, etc\&.\&.\&. When the optional parameter \fCreset\fP is true then the vector will be cleared before the element and its descendants are added\&.
.PP
The family tree only includes ancestor and active elements; for subactive elements as well, use total_family_tree\&. 
.PP
Definition at line 1450 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::family_tree(), libMesh::Elem::is_remote(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::family_tree()\&.
.PP
.nf
1452 {
1453   // The "family tree" doesn't include subactive elements
1454   libmesh_assert(!this->subactive());
1455 
1456   // Clear the vector if the flag reset tells us to\&.
1457   if (reset)
1458     family\&.clear();
1459 
1460   // Add this element to the family tree\&.
1461   family\&.push_back(this);
1462 
1463   // Recurse into the elements children, if it has them\&.
1464   // Do not clear the vector any more\&.
1465   if (!this->active())
1466     for (unsigned int c=0; c<this->n_children(); c++)
1467       if (!this->child(c)->is_remote())
1468         this->child(c)->family_tree (family, false);
1469 }
.fi
.SS "void libMesh::Elem::family_tree_by_neighbor (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *neighbor, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBfamily_tree()\fP\fP member, but only adds elements which are next to \fCneighbor\fP\&. 
.PP
Definition at line 1570 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::has_neighbor(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::remote_elem, and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::family_tree_by_neighbor(), and libMesh::Elem::make_links_to_me_remote()\&.
.PP
.nf
1573 {
1574   // The "family tree" doesn't include subactive elements
1575   libmesh_assert(!this->subactive());
1576 
1577   // Clear the vector if the flag reset tells us to\&.
1578   if (reset)
1579     family\&.clear();
1580 
1581   // This only makes sense if we're already a neighbor
1582   libmesh_assert (this->has_neighbor(neighbor_in));
1583 
1584   // Add this element to the family tree\&.
1585   family\&.push_back(this);
1586 
1587   // Recurse into the elements children, if it's not active\&.
1588   // Do not clear the vector any more\&.
1589   if (!this->active())
1590     for (unsigned int c=0; c<this->n_children(); c++)
1591       {
1592         Elem *current_child = this->child(c);
1593         if (current_child != remote_elem && current_child->has_neighbor(neighbor_in))
1594           current_child->family_tree_by_neighbor (family, neighbor_in, false);
1595       }
1596 }
.fi
.SS "void libMesh::Elem::family_tree_by_side (std::vector< const \fBElem\fP * > &family, const unsigned intside, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBfamily_tree()\fP\fP member, but only adds elements which are next to \fCside\fP\&. 
.PP
Definition at line 1517 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::is_child_on_side(), libMesh::Elem::is_remote(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::family_tree_by_side(), libMesh::Elem::make_links_to_me_local(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1520 {
1521   // The "family tree" doesn't include subactive elements
1522   libmesh_assert(!this->subactive());
1523 
1524   // Clear the vector if the flag reset tells us to\&.
1525   if (reset)
1526     family\&.clear();
1527 
1528   libmesh_assert_less (s, this->n_sides());
1529 
1530   // Add this element to the family tree\&.
1531   family\&.push_back(this);
1532 
1533   // Recurse into the elements children, if it has them\&.
1534   // Do not clear the vector any more\&.
1535   if (!this->active())
1536     for (unsigned int c=0; c<this->n_children(); c++)
1537       if (!this->child(c)->is_remote() && this->is_child_on_side(c, s))
1538         this->child(c)->family_tree_by_side (family, s, false);
1539 }
.fi
.SS "void libMesh::Elem::family_tree_by_subneighbor (std::vector< const \fBElem\fP * > &family, const \fBElem\fP *neighbor, const \fBElem\fP *subneighbor, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBfamily_tree()\fP\fP member, but only adds elements which are next to \fCsubneighbor\fP\&. Only applicable when \fCthis->has_neighbor(neighbor)\fP and \fCneighbor->is_ancestor(subneighbor)\fP 
.PP
Definition at line 1600 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::has_neighbor(), libMesh::Elem::is_ancestor_of(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::remote_elem, and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Elem::family_tree_by_subneighbor(), and libMesh::Elem::make_links_to_me_remote()\&.
.PP
.nf
1604 {
1605   // The "family tree" doesn't include subactive elements
1606   libmesh_assert(!this->subactive());
1607 
1608   // Clear the vector if the flag reset tells us to\&.
1609   if (reset)
1610     family\&.clear();
1611 
1612   // To simplifly this function we need an existing neighbor
1613   libmesh_assert (neighbor_in);
1614   libmesh_assert_not_equal_to (neighbor_in, remote_elem);
1615   libmesh_assert (this->has_neighbor(neighbor_in));
1616 
1617   // This only makes sense if subneighbor descends from neighbor
1618   libmesh_assert (subneighbor);
1619   libmesh_assert_not_equal_to (subneighbor, remote_elem);
1620   libmesh_assert (neighbor_in->is_ancestor_of(subneighbor));
1621 
1622   // Add this element to the family tree if applicable\&.
1623   if (neighbor_in == subneighbor)
1624     family\&.push_back(this);
1625 
1626   // Recurse into the elements children, if it's not active\&.
1627   // Do not clear the vector any more\&.
1628   if (!this->active())
1629     for (unsigned int c=0; c != this->n_children(); ++c)
1630       {
1631         Elem *current_child = this->child(c);
1632         if (current_child != remote_elem)
1633           for (unsigned int s=0; s != current_child->n_sides(); ++s)
1634             {
1635               Elem *child_neigh = current_child->neighbor(s);
1636               if (child_neigh &&
1637                   (child_neigh == neighbor_in ||
1638                    (child_neigh->parent() == neighbor_in &&
1639                     child_neigh->is_ancestor_of(subneighbor))))
1640                 current_child->family_tree_by_subneighbor (family, child_neigh,
1641                                                            subneighbor, false);
1642             }
1643       }
1644 }
.fi
.SS "void libMesh::Elem::find_edge_neighbors (const \fBPoint\fP &p1, const \fBPoint\fP &p2, std::set< const \fBElem\fP * > &neighbor_set) const\fC [inherited]\fP"
This function finds all active elements which touch the current active element along the specified edge defined by the two points \fCp1\fP and \fCp2\fP 
.PP
Definition at line 762 of file elem\&.C\&.
.PP
References libMesh::Elem::contains_point(), end, libMesh::Elem::find_point_neighbors(), and libMesh::libmesh_assert()\&.
.PP
.nf
765 {
766   // Simple but perhaps suboptimal code: find elements containing the
767   // first point, then winnow this set down by removing elements which
768   // don't also contain the second point
769 
770   libmesh_assert(this->contains_point(p2));
771   this->find_point_neighbors(p1, neighbor_set);
772 
773   std::set<const Elem*>::iterator        it = neighbor_set\&.begin();
774   const std::set<const Elem*>::iterator end = neighbor_set\&.end();
775 
776   while(it != end) {
777     std::set<const Elem*>::iterator current = it++;
778 
779     const Elem* elem = *current;
780     // This won't invalidate iterator it, because it is already
781     // pointing to the next element
782     if (!elem->contains_point(p2))
783       neighbor_set\&.erase(current);
784   }
785 }
.fi
.SS "void libMesh::Elem::find_edge_neighbors (std::set< const \fBElem\fP * > &neighbor_set) const\fC [inherited]\fP"
This function finds all active elements which touch the current active element along any edge (more precisely, at at least two points)\&. 
.PP
Definition at line 789 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::contains_edge_of(), end, libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), and libMesh::remote_elem\&.
.PP
.nf
790 {
791   neighbor_set\&.clear();
792   neighbor_set\&.insert(this);
793 
794   std::set<const Elem *> untested_set, next_untested_set;
795   untested_set\&.insert(this);
796 
797   while (!untested_set\&.empty())
798     {
799       // Loop over all the elements in the patch that haven't already
800       // been tested
801       std::set<const Elem*>::const_iterator       it  = untested_set\&.begin();
802       const std::set<const Elem*>::const_iterator end = untested_set\&.end();
803 
804       for (; it != end; ++it)
805         {
806           const Elem* elem = *it;
807 
808           for (unsigned int s=0; s<elem->n_sides(); s++)
809             {
810               const Elem* current_neighbor = elem->neighbor(s);
811               if (current_neighbor &&
812                   current_neighbor != remote_elem)    // we have a real neighbor on this side
813                 {
814                   if (current_neighbor->active())                // \&.\&.\&. if it is active
815                     {
816                       if (this->contains_edge_of(current_neighbor) // \&.\&.\&. and touches us
817                           || current_neighbor->contains_edge_of(this))
818                         {
819                           // Make sure we'll test it
820                           if (!neighbor_set\&.count(current_neighbor))
821                             next_untested_set\&.insert (current_neighbor);
822 
823                           // And add it
824                           neighbor_set\&.insert (current_neighbor);
825                         }
826                     }
827 #ifdef LIBMESH_ENABLE_AMR
828                   else                                 // \&.\&.\&. the neighbor is *not* active,
829                     {                                  // \&.\&.\&. so add *all* neighboring
830                                                        // active children
831                       std::vector<const Elem*> active_neighbor_children;
832 
833                       current_neighbor->active_family_tree_by_neighbor
834                         (active_neighbor_children, elem);
835 
836                       std::vector<const Elem*>::const_iterator
837                         child_it = active_neighbor_children\&.begin();
838                       const std::vector<const Elem*>::const_iterator
839                         child_end = active_neighbor_children\&.end();
840                       for (; child_it != child_end; ++child_it)
841                         {
842                           const Elem *current_child = *child_it;
843                           if (this->contains_edge_of(*child_it) ||
844                               (*child_it)->contains_edge_of(this))
845                             {
846                               // Make sure we'll test it
847                               if (!neighbor_set\&.count(current_child))
848                                 next_untested_set\&.insert (current_child);
849 
850                               neighbor_set\&.insert (current_child);
851                             }
852                         }
853                     }
854 #endif // #ifdef LIBMESH_ENABLE_AMR
855                 }
856             }
857         }
858       untested_set\&.swap(next_untested_set);
859       next_untested_set\&.clear();
860     }
861 }
.fi
.SS "void libMesh::Elem::find_point_neighbors (const \fBPoint\fP &p, std::set< const \fBElem\fP * > &neighbor_set) const\fC [inherited]\fP"
This function finds all elements (including this one) which touch the current active element at the specified point, which should be a point in the current element\&. 
.PP
Definition at line 609 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::contains_point(), end, libMesh::libmesh_assert(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), and libMesh::remote_elem\&.
.PP
Referenced by libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::Elem::find_edge_neighbors(), libMesh::Patch::find_point_neighbors(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::Elem::is_semilocal(), and libMesh::MeshFunction::operator()()\&.
.PP
.nf
611 {
612   libmesh_assert(this->contains_point(p));
613 
614   neighbor_set\&.clear();
615   neighbor_set\&.insert(this);
616 
617   std::set<const Elem *> untested_set, next_untested_set;
618   untested_set\&.insert(this);
619 
620   while (!untested_set\&.empty())
621     {
622       // Loop over all the elements in the patch that haven't already
623       // been tested
624       std::set<const Elem*>::const_iterator       it  = untested_set\&.begin();
625       const std::set<const Elem*>::const_iterator end = untested_set\&.end();
626 
627       for (; it != end; ++it)
628         {
629           const Elem* elem = *it;
630 
631           for (unsigned int s=0; s<elem->n_sides(); s++)
632             {
633               const Elem* current_neighbor = elem->neighbor(s);
634               if (current_neighbor &&
635                   current_neighbor != remote_elem)    // we have a real neighbor on this side
636                 {
637                   if (current_neighbor->active())                // \&.\&.\&. if it is active
638                     {
639                       if (current_neighbor->contains_point(p))   // \&.\&.\&. and touches p
640                         {
641                           // Make sure we'll test it
642                           if (!neighbor_set\&.count(current_neighbor))
643                             next_untested_set\&.insert (current_neighbor);
644 
645                           // And add it
646                           neighbor_set\&.insert (current_neighbor);
647                         }
648                     }
649 #ifdef LIBMESH_ENABLE_AMR
650                   else                                 // \&.\&.\&. the neighbor is *not* active,
651                     {                                  // \&.\&.\&. so add *all* neighboring
652                                                        // active children that touch p
653                       std::vector<const Elem*> active_neighbor_children;
654 
655                       current_neighbor->active_family_tree_by_neighbor
656                         (active_neighbor_children, elem);
657 
658                       std::vector<const Elem*>::const_iterator
659                         child_it = active_neighbor_children\&.begin();
660                       const std::vector<const Elem*>::const_iterator
661                         child_end = active_neighbor_children\&.end();
662                       for (; child_it != child_end; ++child_it)
663                         {
664                           const Elem *current_child = *child_it;
665                           if (current_child->contains_point(p))
666                             {
667                               // Make sure we'll test it
668                               if (!neighbor_set\&.count(current_child))
669                                 next_untested_set\&.insert (current_child);
670 
671                               neighbor_set\&.insert (current_child);
672                             }
673                         }
674                     }
675 #endif // #ifdef LIBMESH_ENABLE_AMR
676                 }
677             }
678         }
679       untested_set\&.swap(next_untested_set);
680       next_untested_set\&.clear();
681     }
682 }
.fi
.SS "void libMesh::Elem::find_point_neighbors (std::set< const \fBElem\fP * > &neighbor_set) const\fC [inherited]\fP"
This function finds all elements (including this one) which touch the current element at any point 
.PP
Definition at line 686 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::contains_vertex_of(), end, libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), and libMesh::remote_elem\&.
.PP
.nf
687 {
688   neighbor_set\&.clear();
689   neighbor_set\&.insert(this);
690 
691   std::set<const Elem *> untested_set, next_untested_set;
692   untested_set\&.insert(this);
693 
694   while (!untested_set\&.empty())
695     {
696       // Loop over all the elements in the patch that haven't already
697       // been tested
698       std::set<const Elem*>::const_iterator       it  = untested_set\&.begin();
699       const std::set<const Elem*>::const_iterator end = untested_set\&.end();
700 
701       for (; it != end; ++it)
702         {
703           const Elem* elem = *it;
704 
705           for (unsigned int s=0; s<elem->n_sides(); s++)
706             {
707               const Elem* current_neighbor = elem->neighbor(s);
708               if (current_neighbor &&
709                   current_neighbor != remote_elem)    // we have a real neighbor on this side
710                 {
711                   if (current_neighbor->active())                // \&.\&.\&. if it is active
712                     {
713                       if (this->contains_vertex_of(current_neighbor) // \&.\&.\&. and touches us
714                           || current_neighbor->contains_vertex_of(this))
715                         {
716                           // Make sure we'll test it
717                           if (!neighbor_set\&.count(current_neighbor))
718                             next_untested_set\&.insert (current_neighbor);
719 
720                           // And add it
721                           neighbor_set\&.insert (current_neighbor);
722                         }
723                     }
724 #ifdef LIBMESH_ENABLE_AMR
725                   else                                 // \&.\&.\&. the neighbor is *not* active,
726                     {                                  // \&.\&.\&. so add *all* neighboring
727                                                        // active children
728                       std::vector<const Elem*> active_neighbor_children;
729 
730                       current_neighbor->active_family_tree_by_neighbor
731                         (active_neighbor_children, elem);
732 
733                       std::vector<const Elem*>::const_iterator
734                         child_it = active_neighbor_children\&.begin();
735                       const std::vector<const Elem*>::const_iterator
736                         child_end = active_neighbor_children\&.end();
737                       for (; child_it != child_end; ++child_it)
738                         {
739                           const Elem *current_child = *child_it;
740                           if (this->contains_vertex_of(current_child) ||
741                               (current_child)->contains_vertex_of(this))
742                             {
743                               // Make sure we'll test it
744                               if (!neighbor_set\&.count(current_child))
745                                 next_untested_set\&.insert (current_child);
746 
747                               neighbor_set\&.insert (current_child);
748                             }
749                         }
750                     }
751 #endif // #ifdef LIBMESH_ENABLE_AMR
752                 }
753             }
754         }
755       untested_set\&.swap(next_untested_set);
756       next_untested_set\&.clear();
757     }
758 }
.fi
.SS "\fBElemType\fP libMesh::Elem::first_order_equivalent_type (const \fBElemType\fPet)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type of the associated first-order element, e\&.g\&. when \fCthis\fP is a \fCTET10\fP, then \fCTET4\fP is returned\&. Returns \fCINVALID_ELEM\fP for first order or other elements that should not or cannot be converted into lower order equivalents\&. 
.RE
.PP

.PP
Definition at line 2024 of file elem\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::EDGE4, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, libMesh::INFQUAD6, libMesh::INVALID_ELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.PP
.nf
2025 {
2026   switch (et)
2027     {
2028     case EDGE2:
2029     case EDGE3:
2030     case EDGE4:
2031       return EDGE2;
2032     case TRI3:
2033     case TRI6:
2034       return TRI3;
2035     case QUAD4:
2036     case QUAD8:
2037     case QUAD9:
2038       return QUAD4;
2039     case TET4:
2040     case TET10:
2041       return TET4;
2042     case HEX8:
2043     case HEX27:
2044     case HEX20:
2045       return HEX8;
2046     case PRISM6:
2047     case PRISM15:
2048     case PRISM18:
2049       return PRISM6;
2050     case PYRAMID5:
2051     case PYRAMID13:
2052     case PYRAMID14:
2053       return PYRAMID5;
2054 
2055 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
2056 
2057     case INFQUAD4:
2058     case INFQUAD6:
2059       return INFQUAD4;
2060     case INFHEX8:
2061     case INFHEX16:
2062     case INFHEX18:
2063       return INFHEX8;
2064     case INFPRISM6:
2065     case INFPRISM12:
2066       return INFPRISM6;
2067 
2068 #endif
2069 
2070     default:
2071       // unknown element
2072       return INVALID_ELEM;
2073     }
2074 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "std::string libMesh::Elem::get_info () const\fC [inherited]\fP"
Prints relevant information about the element to a string\&. 
.PP
Definition at line 1903 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::Elem::dim(), libMesh::DofObject::dof_number(), libMesh::Utility::enum_to_string(), libMesh::Elem::get_node(), libMesh::Elem::has_children(), libMesh::Elem::hmax(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::Elem::infinite(), libMesh::Elem::level(), libMesh::DofObject::n_comp(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::Elem::neighbor(), libMesh::Elem::origin(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::Elem::subactive(), libMesh::Elem::type(), libMesh::DofObject::valid_id(), and libMesh::Elem::volume()\&.
.PP
Referenced by libMesh::Elem::print_info()\&.
.PP
.nf
1904 {
1905   std::ostringstream oss;
1906 
1907   oss << "  Elem Information"                                      << '\n'
1908       << "   id()=";
1909 
1910   if (this->valid_id())
1911     oss << this->id();
1912   else
1913     oss << "invalid";
1914 
1915   oss << ", processor_id()=" << this->processor_id()               << '\n';
1916 
1917   oss << "   type()="    << Utility::enum_to_string(this->type())  << '\n'
1918       << "   dim()="     << this->dim()                            << '\n'
1919       << "   n_nodes()=" << this->n_nodes()                        << '\n';
1920 
1921   for (unsigned int n=0; n != this->n_nodes(); ++n)
1922     oss << "    " << n << *this->get_node(n);
1923 
1924   oss << "   n_sides()=" << this->n_sides()                        << '\n';
1925 
1926   for (unsigned int s=0; s != this->n_sides(); ++s)
1927     {
1928       oss << "    neighbor(" << s << ")=";
1929       if (this->neighbor(s))
1930         oss << this->neighbor(s)->id() << '\n';
1931       else
1932         oss << "NULL\n";
1933     }
1934 
1935   oss << "   hmin()=" << this->hmin()
1936       << ", hmax()=" << this->hmax()                               << '\n'
1937       << "   volume()=" << this->volume()                          << '\n'
1938       << "   active()=" << this->active()
1939       << ", ancestor()=" << this->ancestor()
1940       << ", subactive()=" << this->subactive()
1941       << ", has_children()=" << this->has_children()               << '\n'
1942       << "   parent()=";
1943   if (this->parent())
1944     oss << this->parent()->id() << '\n';
1945   else
1946     oss << "NULL\n";
1947   oss << "   level()=" << this->level()
1948       << ", p_level()=" << this->p_level()                         << '\n'
1949 #ifdef LIBMESH_ENABLE_AMR
1950       << "   refinement_flag()=" << Utility::enum_to_string(this->refinement_flag())        << '\n'
1951       << "   p_refinement_flag()=" << Utility::enum_to_string(this->p_refinement_flag())    << '\n'
1952 #endif
1953 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
1954       << "   infinite()=" << this->infinite()    << '\n';
1955   if (this->infinite())
1956     oss << "   origin()=" << this->origin()    << '\n'
1957 #endif
1958       ;
1959 
1960   oss << "   DoFs=";
1961   for (unsigned int s=0; s != this->n_systems(); ++s)
1962     for (unsigned int v=0; v != this->n_vars(s); ++v)
1963       for (unsigned int c=0; c != this->n_comp(s,v); ++c)
1964         oss << '(' << s << '/' << v << '/' << this->dof_number(s,v,c) << ") ";
1965 
1966 
1967   return oss\&.str();
1968 }
.fi
.SS "\fBNode\fP * libMesh::Elem::get_node (const unsigned inti) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the pointer to local \fC\fBNode\fP\fP \fCi\fP\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 1388 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, libMesh::libmesh_assert(), and libMesh::Elem::n_nodes()\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::Prism6::build_side(), libMesh::Pyramid5::build_side(), libMesh::InfQuad4::build_side(), libMesh::Quad4::build_side(), libMesh::InfQuad6::build_side(), libMesh::Tri3::build_side(), libMesh::InfHex8::build_side(), libMesh::Hex8::build_side(), libMesh::InfPrism6::build_side(), libMesh::InfPrism12::build_side(), libMesh::Quad9::build_side(), libMesh::Quad8::build_side(), libMesh::Tri6::build_side(), libMesh::Tet4::build_side(), libMesh::InfHex18::build_side(), libMesh::InfHex16::build_side(), libMesh::Tet10::build_side(), libMesh::Hex20::build_side(), libMesh::Pyramid13::build_side(), libMesh::Prism15::build_side(), libMesh::Edge::build_side(), libMesh::Pyramid14::build_side(), build_side(), libMesh::Prism18::build_side(), libMesh::EquationSystems::build_solution_vector(), libMesh::MeshTools::Modification::change_boundary_id(), libMesh::Elem::coarsen(), libMesh::FEMap::compute_affine_map(), libMesh::FEMap::compute_map(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::dof_indices(), libMesh::UNVIO::element_out(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::MeshTools::Modification::flatten(), libMesh::Elem::get_info(), libMesh::RemoteElem::get_node(), libMesh::MeshTools::libmesh_assert_connected_nodes(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::Elem::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::old_dof_indices(), libMesh::Tri3Subdivision::prepare_subdivision_properties(), libMesh::Tri::quality(), libMesh::Elem::refine(), libMesh::DofMap::reinit(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Tet::side(), libMesh::Prism::side(), libMesh::Pyramid::side(), libMesh::Hex::side(), libMesh::Tri::side(), libMesh::InfHex::side(), libMesh::InfPrism::side(), libMesh::Quad::side(), libMesh::InfQuad::side(), libMesh::Edge::side(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::Tri3::volume(), libMesh::Pyramid5::volume(), libMesh::Tet4::volume(), and libMesh::GnuPlotIO::write_solution()\&.
.PP
.nf
1389 {
1390   libmesh_assert_less (i, this->n_nodes());
1391   libmesh_assert(_nodes[i]);
1392 
1393   return _nodes[i];
1394 }
.fi
.SS "unsigned int libMesh::Elem::get_node_index (const \fBNode\fP *node_ptr) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the local index for the \fC\fBNode\fP\fP pointer \fCnode_ptr\fP, or \fCinvalid_id\fP if \fCnode_ptr\fP is not a local node\&. 
.RE
.PP

.PP
Definition at line 1399 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, libMesh::invalid_uint, and libMesh::Elem::n_nodes()\&.
.PP
.nf
1400 {
1401   for (unsigned int n=0; n != this->n_nodes(); ++n)
1402     if (this->_nodes[n] == node_ptr)
1403       return n;
1404 
1405   return libMesh::invalid_uint;
1406 }
.fi
.SS "void libMesh::Elem::hack_p_level (const unsigned intp)\fC [inline]\fP, \fC [inherited]\fP"
Sets the value of the p refinement level for the element without altering the p level of its ancestors 
.PP
Definition at line 1922 of file elem\&.h\&.
.PP
References libMesh::Elem::_p_level\&.
.PP
Referenced by libMesh::CheckpointIO::read_connectivity(), and libMesh::XdrIO::read_serialized_connectivity()\&.
.PP
.nf
1923 {
1924   _p_level = libmesh_cast_int<unsigned char>(p);
1925 }
.fi
.SS "bool libMesh::Hex27::has_affine_map () const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the element map is definitely affine (i\&.e\&. the same at every quadrature point) within numerical tolerances 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 112 of file cell_hex27\&.C\&.
.PP
References libMesh::Elem::point(), and libMesh::TypeVector< T >::relative_fuzzy_equals()\&.
.PP
.nf
113 {
114   // Make sure x-edge endpoints are affine
115   Point v = this->point(1) - this->point(0);
116   if (!v\&.relative_fuzzy_equals(this->point(2) - this->point(3)) ||
117       !v\&.relative_fuzzy_equals(this->point(5) - this->point(4)) ||
118       !v\&.relative_fuzzy_equals(this->point(6) - this->point(7)))
119     return false;
120   // Make sure x-edges are straight
121   // and x-face and center points are centered
122   v /= 2;
123   if (!v\&.relative_fuzzy_equals(this->point(8) - this->point(0)) ||
124       !v\&.relative_fuzzy_equals(this->point(10) - this->point(3)) ||
125       !v\&.relative_fuzzy_equals(this->point(16) - this->point(4)) ||
126       !v\&.relative_fuzzy_equals(this->point(18) - this->point(7)) ||
127       !v\&.relative_fuzzy_equals(this->point(20) - this->point(11)) ||
128       !v\&.relative_fuzzy_equals(this->point(21) - this->point(12)) ||
129       !v\&.relative_fuzzy_equals(this->point(23) - this->point(15)) ||
130       !v\&.relative_fuzzy_equals(this->point(25) - this->point(19)) ||
131       !v\&.relative_fuzzy_equals(this->point(26) - this->point(24)))
132     return false;
133   // Make sure xz-faces are identical parallelograms
134   v = this->point(4) - this->point(0);
135   if (!v\&.relative_fuzzy_equals(this->point(7) - this->point(3)))
136     return false;
137   v /= 2;
138   if (!v\&.relative_fuzzy_equals(this->point(12) - this->point(0)) ||
139       !v\&.relative_fuzzy_equals(this->point(13) - this->point(1)) ||
140       !v\&.relative_fuzzy_equals(this->point(14) - this->point(2)) ||
141       !v\&.relative_fuzzy_equals(this->point(15) - this->point(3)) ||
142       !v\&.relative_fuzzy_equals(this->point(22) - this->point(9)) ||
143       !v\&.relative_fuzzy_equals(this->point(24) - this->point(11)))
144     return false;
145   // Make sure y-edges are straight
146   v = (this->point(3) - this->point(0))/2;
147   if (!v\&.relative_fuzzy_equals(this->point(11) - this->point(0)) ||
148       !v\&.relative_fuzzy_equals(this->point(9) - this->point(1)) ||
149       !v\&.relative_fuzzy_equals(this->point(17) - this->point(5)) ||
150       !v\&.relative_fuzzy_equals(this->point(19) - this->point(4)))
151     return false;
152   // If all the above checks out, the map is affine
153   return true;
154 }
.fi
.SS "bool libMesh::Elem::has_ancestor_children () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element has any descendants other than its immediate children, \fCfalse\fP otherwise\&. Always returns \fCfalse\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1630 of file elem\&.h\&.
.PP
References libMesh::Elem::_children, libMesh::Elem::child(), libMesh::Elem::has_children(), and libMesh::Elem::n_children()\&.
.PP
.nf
1631 {
1632 #ifdef LIBMESH_ENABLE_AMR
1633   if (_children == NULL)
1634     return false;
1635   else
1636     for (unsigned int c=0; c != this->n_children(); c++)
1637       if (this->child(c)->has_children())
1638         return true;
1639 #endif
1640   return false;
1641 }
.fi
.SS "bool libMesh::Elem::has_children () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element has any children (active or not), \fCfalse\fP otherwise\&. Always returns \fCfalse\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1616 of file elem\&.h\&.
.PP
References libMesh::Elem::_children\&.
.PP
Referenced by libMesh::Elem::add_child(), libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::ancestor(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::Elem::get_info(), libMesh::Elem::has_ancestor_children(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::Elem::replace_child(), libMesh::Elem::set_child(), libMesh::Elem::subactive(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::total_family_tree(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
1617 {
1618 #ifdef LIBMESH_ENABLE_AMR
1619   if (_children == NULL)
1620     return false;
1621   else
1622     return true;
1623 #else
1624   return false;
1625 #endif
1626 }
.fi
.SS "bool libMesh::DofObject::has_dofs (const unsigned ints = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if any system has variables which have been assigned, false otherwise 
.RE
.PP

.PP
Definition at line 834 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::DofObject::n_systems(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::reinit(), and libMesh::Parallel::unpack()\&.
.PP
.nf
835 {
836   if (sys == libMesh::invalid_uint)
837     {
838       for (unsigned int s=0; s<this->n_systems(); s++)
839         if (this->n_vars(s))
840           return true;
841     }
842 
843   else
844     {
845       libmesh_assert_less (sys, this->n_systems());
846 
847       if (this->n_vars(sys))
848         return true;
849     }
850 
851   return false;
852 }
.fi
.SS "bool libMesh::Elem::has_neighbor (const \fBElem\fP *elem) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element \fCelem\fP in question is a neighbor of this element, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 1457 of file elem\&.h\&.
.PP
References libMesh::Elem::n_neighbors(), and libMesh::Elem::neighbor()\&.
.PP
Referenced by libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::has_topological_neighbor(), libMesh::MeshRefinement::has_topological_neighbor(), libMesh::Elem::make_links_to_me_remote(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), and libMesh::Elem::on_boundary()\&.
.PP
.nf
1458 {
1459   for (unsigned int n=0; n<this->n_neighbors(); n++)
1460     if (this->neighbor(n) == elem)
1461       return true;
1462 
1463   return false;
1464 }
.fi
.SS "bool libMesh::Elem::has_topological_neighbor (const \fBElem\fP *elem, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP &point_locator, \fBPeriodicBoundaries\fP *pb) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element \fCelem\fP in question is a neighbor or topological neighbor of this element, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 940 of file elem\&.C\&.
.PP
References libMesh::Elem::has_neighbor(), libMesh::Elem::n_neighbors(), and libMesh::Elem::topological_neighbor()\&.
.PP
Referenced by libMesh::MeshRefinement::has_topological_neighbor()\&.
.PP
.nf
944 {
945   // First see if this is a normal "interior" neighbor
946   if (has_neighbor(elem))
947     return true;
948 
949   for (unsigned int n=0; n<this->n_neighbors(); n++)
950     if (this->topological_neighbor(n, mesh, point_locator, pb))
951       return true;
952 
953   return false;
954 }
.fi
.SS "\fBReal\fP libMesh::Elem::hmax () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the maximum vertex separation for the element\&. 
.RE
.PP

.PP
Definition at line 429 of file elem\&.C\&.
.PP
References std::max(), libMesh::Elem::n_vertices(), libMesh::Elem::point(), libMesh::Real, and libMesh::TypeVector< T >::size_sq()\&.
.PP
Referenced by libMesh::DiscontinuityMeasure::boundary_side_integration(), libMesh::KellyErrorEstimator::boundary_side_integration(), libMesh::Elem::get_info(), libMesh::LaplacianErrorEstimator::internal_side_integration(), libMesh::DiscontinuityMeasure::internal_side_integration(), libMesh::KellyErrorEstimator::internal_side_integration(), and libMesh::Elem::point_test()\&.
.PP
.nf
430 {
431   Real h_max=0;
432 
433   for (unsigned int n_outer=0; n_outer<this->n_vertices(); n_outer++)
434     for (unsigned int n_inner=n_outer+1; n_inner<this->n_vertices(); n_inner++)
435       {
436         const Point diff = (this->point(n_outer) - this->point(n_inner));
437 
438         h_max = std::max(h_max,diff\&.size_sq());
439       }
440 
441   return std::sqrt(h_max);
442 }
.fi
.SS "\fBReal\fP libMesh::Elem::hmin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the minimum vertex separation for the element\&. 
.RE
.PP

.PP
Definition at line 412 of file elem\&.C\&.
.PP
References std::max(), std::min(), libMesh::Elem::n_vertices(), libMesh::Elem::point(), libMesh::Real, and libMesh::TypeVector< T >::size_sq()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Elem::get_info(), libMesh::FEMSystem::numerical_jacobian(), and libMesh::Elem::refine()\&.
.PP
.nf
413 {
414   Real h_min=std::numeric_limits<Real>::max();
415 
416   for (unsigned int n_outer=0; n_outer<this->n_vertices(); n_outer++)
417     for (unsigned int n_inner=n_outer+1; n_inner<this->n_vertices(); n_inner++)
418       {
419         const Point diff = (this->point(n_outer) - this->point(n_inner));
420 
421         h_min = std::min(h_min,diff\&.size_sq());
422       }
423 
424   return std::sqrt(h_min);
425 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 611 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id, libMesh::libmesh_assert(), and libMesh::DofObject::valid_id()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::MeshData::assign(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEMap::compute_single_point_map(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshData::elem_to_foreign_id(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshTools::Modification::flatten(), libMesh::for(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::EquationSystems::get_solution(), libMesh::LaplaceMeshSmoother::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::TreeNode< N >::insert(), libMesh::SerialMesh::insert_elem(), libMesh::ParallelMesh::insert_elem(), libMesh::SerialMesh::insert_node(), libMesh::FE< Dim, T >::inverse_map(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::Tri3Subdivision::local_node_number(), libMesh::Elem::node(), libMesh::MeshData::node_to_foreign_id(), libMesh::VTKIO::nodes_to_vtk(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::BoundaryInfo::operator=(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::ErrorVector::plot_error(), libMesh::ParallelMesh::query_elem(), libMesh::ParallelMesh::query_node_ptr(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::AbaqusIO::read_elements(), libMesh::ParallelMesh::renumber_elem(), libMesh::ParallelMesh::renumber_node(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::DofMap::scatter_constraints(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::topological_neighbor(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::CheckpointIO::write_connectivity(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), libMesh::LegacyXdrIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::CheckpointIO::write_nodes(), and libMesh::XdrIO::write_serialized_connectivity()\&.
.PP
.nf
612 {
613   libmesh_assert (this->valid_id());
614   return _id;
615 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "bool libMesh::Cell::infinite () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
4 
.PP
\fCfalse\fP\&. All classes derived from \fC\fBCell\fP\fP are finite elements\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 74 of file cell\&.h\&.
.PP
.nf
74 { return false; }
.fi
.SS "const \fBElem\fP * libMesh::Elem::interior_parent () const\fC [inline]\fP, \fC [inherited]\fP"
In some cases it is desireable to extract the boundary (or a subset thereof) of a D-dimensional mesh as a (D-1)-dimensional manifold\&. In this case we may want to know the 'parent' element from which the manifold elements were extracted\&. We can easily do that for the level-0 manifold elements by storing the D-dimensional parent\&. This method provides access to that element\&. 
.PP
Definition at line 1709 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks, libMesh::Elem::dim(), libMesh::libmesh_assert(), and libMesh::Elem::n_sides()\&.
.PP
.nf
1710 {
1711   // interior parents make no sense for full-dimensional elements\&.
1712   libmesh_assert_less (this->dim(), LIBMESH_DIM);
1713 
1714   // // and they [USED TO BE] only good for level-0 elements
1715   // if (this->level() != 0)
1716   // return this->parent()->interior_parent();
1717 
1718   // We store the interior_parent pointer after both the parent
1719   // neighbor and neighbor pointers
1720   Elem *interior_p = _elemlinks[1+this->n_sides()];
1721 
1722   // If we have an interior_parent, it had better be the
1723   // one-higher-dimensional interior element we are looking for\&.
1724   libmesh_assert (!interior_p ||
1725                   interior_p->dim() == (this->dim()+1));
1726 
1727   return interior_p;
1728 }
.fi
.SS "void libMesh::DofObject::invalidate ()\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all the indices for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 567 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::invalidate_id(), and libMesh::DofObject::invalidate_processor_id()\&.
.PP
Referenced by libMesh::DofObject::DofObject()\&.
.PP
.nf
568 {
569   this->invalidate_dofs ();
570   this->invalidate_id ();
571   this->invalidate_processor_id ();
572 }
.fi
.SS "void libMesh::DofObject::invalidate_dofs (const unsigned intsys_num = \fC\fBlibMesh::invalid_uint\fP\fP)\fC [inline]\fP, \fC [inherited]\fP"
Sets all degree of freedom numbers to \fCinvalid_id\fP 
.PP
Definition at line 531 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::set_vg_dof_base()\&.
.PP
Referenced by libMesh::DofObject::invalidate()\&.
.PP
.nf
532 {
533   // If the user does not specify the system number\&.\&.\&.
534   if (sys_num >= this->n_systems())
535     {
536       for (unsigned int s=0; s<this->n_systems(); s++)
537         for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
538           if (this->n_comp_group(s,vg))
539             this->set_vg_dof_base(s,vg,invalid_id);
540     }
541   // \&.\&.\&.otherwise invalidate the dofs for all systems
542   else
543     for (unsigned int vg=0; vg<this->n_var_groups(sys_num); vg++)
544       if (this->n_comp_group(sys_num,vg))
545         this->set_vg_dof_base(sys_num,vg,invalid_id);
546 }
.fi
.SS "void libMesh::DofObject::invalidate_id ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the id to \fCinvalid_id\fP 
.PP
Definition at line 551 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_id, and libMesh::DofObject::set_id()\&.
.PP
Referenced by libMesh::DofObject::invalidate()\&.
.PP
.nf
552 {
553   this->set_id (invalid_id);
554 }
.fi
.SS "void libMesh::DofObject::invalidate_processor_id ()\fC [inline]\fP, \fC [inherited]\fP"
Sets the processor id to \fCinvalid_processor_id\fP 
.PP
Definition at line 559 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::DofObject::processor_id()\&.
.PP
Referenced by libMesh::MeshTools::correct_node_proc_ids(), libMesh::DofObject::invalidate(), libMesh::Partitioner::set_node_processor_ids(), and libMesh::Partitioner::set_parent_processor_ids()\&.
.PP
.nf
560 {
561   this->processor_id (invalid_processor_id);
562 }
.fi
.SS "bool libMesh::Elem::is_ancestor_of (const \fBElem\fP *descendant) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if \fCdescendant\fP is a child of \fCthis\fP, or a child of a child of \fCthis\fP, etc\&. Always returns \fCfalse\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1646 of file elem\&.h\&.
.PP
References libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::Elem::family_tree_by_subneighbor()\&.
.PP
.nf
1651 {
1652 #ifdef LIBMESH_ENABLE_AMR
1653   const Elem *e = descendant;
1654   while (e)
1655     {
1656       if (this == e)
1657         return true;
1658       e = e->parent();
1659     }
1660 #endif
1661   return false;
1662 }
.fi
.SS "bool libMesh::Elem::is_child_on_edge (const unsigned intc, const unsigned inte) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the specified child is on the specified edge 
.RE
.PP

.PP
Definition at line 1434 of file elem\&.C\&.
.PP
References libMesh::Elem::build_edge(), libMesh::Elem::n_children(), and libMesh::Elem::n_edges()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::BoundaryInfo::edge_boundary_ids(), and libMesh::BoundaryInfo::n_edge_boundary_ids()\&.
.PP
.nf
1436 {
1437   libmesh_assert_less (c, this->n_children());
1438   libmesh_assert_less (e, this->n_edges());
1439 
1440   AutoPtr<Elem> my_edge = this->build_edge(e);
1441   AutoPtr<Elem> child_edge = this->build_edge(e);
1442 
1443   // We're assuming that an overlapping child edge has the same
1444   // number and orientation as its parent
1445   return (child_edge->node(0) == my_edge->node(0) ||
1446           child_edge->node(1) == my_edge->node(1));
1447 }
.fi
.SS "bool libMesh::Hex::is_child_on_side (const unsigned intc, const unsigned ints) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the specified child is on the specified side 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 185 of file cell_hex\&.C\&.
.PP
References libMesh::Hex::n_children(), libMesh::Hex::n_sides(), and libMesh::Hex8::side_nodes_map\&.
.PP
.nf
187 {
188   libmesh_assert_less (c, this->n_children());
189   libmesh_assert_less (s, this->n_sides());
190 
191   // This array maps the Hex8 node numbering to the Hex8 child
192   // numbering\&.  I\&.e\&.
193   //   node 6 touches child 7, and
194   //   node 7 touches child 6, etc\&.
195   const unsigned int node_child_map[8] = { 0, 1, 3, 2, 4, 5, 7, 6 };
196 
197   for (unsigned int i = 0; i != 4; ++i)
198     if (node_child_map[Hex8::side_nodes_map[s][i]] == c)
199       return true;
200 
201   return false;
202 }
.fi
.SS "bool libMesh::Hex27::is_edge (const unsigned inti) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the specified (local) node number is an edge\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 72 of file cell_hex27\&.C\&.
.PP
.nf
73 {
74   if (i < 8)
75     return false;
76   if (i > 19)
77     return false;
78   return true;
79 }
.fi
.SS "bool libMesh::Hex::is_edge_on_side (const unsigned inte, const unsigned ints) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 206 of file cell_hex\&.C\&.
.PP
References libMesh::Hex8::edge_nodes_map, libMesh::Elem::is_node_on_side(), libMesh::Hex::n_edges(), and libMesh::Hex::n_sides()\&.
.PP
.nf
208 {
209   libmesh_assert_less (e, this->n_edges());
210   libmesh_assert_less (s, this->n_sides());
211 
212   return (is_node_on_side(Hex8::edge_nodes_map[e][0],s) &&
213           is_node_on_side(Hex8::edge_nodes_map[e][1],s));
214 }
.fi
.SS "bool libMesh::Hex27::is_face (const unsigned inti) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the specified (local) node number is a face\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 81 of file cell_hex27\&.C\&.
.PP
.nf
82 {
83   if (i == 26)
84     return false;
85   if (i > 19)
86     return true;
87   return false;
88 }
.fi
.SS "virtual bool libMesh::Elem::is_linear () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the Lagrange shape functions on this element are linear 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::NodeElem\fP, \fBlibMesh::Tet4\fP, \fBlibMesh::Tri3\fP, \fBlibMesh::Edge2\fP, and \fBlibMesh::Tri3Subdivision\fP\&.
.PP
Definition at line 649 of file elem\&.h\&.
.PP
Referenced by libMesh::FEMap::init_reference_to_physical_map()\&.
.PP
.nf
649 { return false; }
.fi
.SS "bool libMesh::Hex27::is_node_on_edge (const unsigned intn, const unsigned inte) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 100 of file cell_hex27\&.C\&.
.PP
References edge_nodes_map, and libMesh::Hex::n_edges()\&.
.PP
.nf
102 {
103   libmesh_assert_less (e, n_edges());
104   for (unsigned int i = 0; i != 3; ++i)
105     if (edge_nodes_map[e][i] == n)
106       return true;
107   return false;
108 }
.fi
.SS "bool libMesh::Hex27::is_node_on_side (const unsigned intn, const unsigned ints) const\fC [virtual]\fP"

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 90 of file cell_hex27\&.C\&.
.PP
References libMesh::Hex::n_sides(), and side_nodes_map\&.
.PP
.nf
92 {
93   libmesh_assert_less (s, n_sides());
94   for (unsigned int i = 0; i != 9; ++i)
95     if (side_nodes_map[s][i] == n)
96       return true;
97   return false;
98 }
.fi
.SS "virtual bool libMesh::Elem::is_remote () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Returns true if this element is remote, false otherwise\&. A remote element (see \fC\fBRemoteElem\fP\fP) is a syntactic convenience -- it is a placeholder for an element which exists on some other processor\&. Local elements are required to have valid neighbors, and these ghost elements may have remote neighbors for data structure consistency\&. The use of remote elements helps assure that any element we may access has a NULL neighbor if and only if it lies on the physical boundary of the domain\&. 
.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 357 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::active_family_tree(), libMesh::Elem::active_family_tree_by_side(), libMesh::Elem::family_tree(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::make_links_to_me_local(), libMesh::Partitioner::set_parent_processor_ids(), and libMesh::Elem::total_family_tree()\&.
.PP
.nf
358   { return false; }
.fi
.SS "bool libMesh::Elem::is_semilocal (const \fBprocessor_id_type\fPmy_pid) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this element is semilocal to the calling processor, which must specify its rank\&. 
.RE
.PP

.PP
Definition at line 556 of file elem\&.C\&.
.PP
References end, libMesh::Elem::find_point_neighbors(), and libMesh::DofObject::processor_id()\&.
.PP
Referenced by libMesh::Patch::add_semilocal_face_neighbors(), and libMesh::Patch::add_semilocal_point_neighbors()\&.
.PP
.nf
557 {
558   std::set<const Elem *> point_neighbors;
559 
560   this->find_point_neighbors(point_neighbors);
561 
562   std::set<const Elem*>::const_iterator       it  = point_neighbors\&.begin();
563   const std::set<const Elem*>::const_iterator end = point_neighbors\&.end();
564 
565   for (; it != end; ++it)
566     {
567       const Elem* elem = *it;
568       if (elem->processor_id() == my_pid)
569         return true;
570     }
571 
572   return false;
573 }
.fi
.SS "bool libMesh::Hex27::is_vertex (const unsigned inti) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
true iff the specified (local) node number is a vertex\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 65 of file cell_hex27\&.C\&.
.PP
.nf
66 {
67   if (i < 8)
68     return true;
69   return false;
70 }
.fi
.SS "\fBdof_id_type\fP libMesh::Hex27::key (const unsigned ints) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
an id associated with the \fCs\fP side of this element\&. The id is not necessariy unique, but should be close\&. This is particularly useful in the \fC\fBMeshBase::find_neighbors()\fP\fP routine\&.
.RE
.PP
We reimplemenet this method here for the \fC\fBHex27\fP\fP since we can use the center node of each face to provide a perfect (unique) key\&. 
.PP
Reimplemented from \fBlibMesh::Hex\fP\&.
.PP
Definition at line 158 of file cell_hex27\&.C\&.
.PP
References libMesh::Elem::compute_key(), libMesh::Hex::n_sides(), and libMesh::Elem::node()\&.
.PP
.nf
159 {
160   libmesh_assert_less (s, this->n_sides());
161 
162   // Think of a unit cube: (-1,1) x (-1,1) x (1,1)
163   switch (s)
164     {
165     case 0:  // the face at z=0
166 
167       return
168         this->compute_key (this->node(20));
169 
170     case 1:  // the face at y = 0
171 
172       return
173         this->compute_key (this->node(21));
174 
175     case 2:  // the face at x=1
176 
177       return
178         this->compute_key (this->node(22));
179 
180     case 3: // the face at y=1
181 
182       return
183         this->compute_key (this->node(23));
184 
185     case 4: // the face at x=0
186 
187       return
188         this->compute_key (this->node(24));
189 
190     case 5: // the face at z=1
191 
192       return
193         this->compute_key (this->node(25));
194     }
195 
196   // We'll never get here\&.
197   libmesh_error();
198   return 0;
199 }
.fi
.SS "\fBReal\fP libMesh::Elem::length (const unsigned intn1, const unsigned intn2) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the magnitude of the distance between nodes n1 and n2\&. Useful for computing the lengths of the sides of elements\&. 
.RE
.PP

.PP
Definition at line 446 of file elem\&.C\&.
.PP
References libMesh::Elem::n_vertices(), and libMesh::Elem::point()\&.
.PP
Referenced by libMesh::Hex::quality(), libMesh::InfHex::quality(), and libMesh::Quad::quality()\&.
.PP
.nf
448 {
449   libmesh_assert_less ( n1, this->n_vertices() );
450   libmesh_assert_less ( n2, this->n_vertices() );
451 
452   return (this->point(n1) - this->point(n2))\&.size();
453 }
.fi
.SS "unsigned int libMesh::Elem::level () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the refinement level of the current element\&. If the element's parent is \fCNULL\fP then by convention it is at level 0, otherwise it is simply at one level greater than its parent\&. 
.RE
.PP

.PP
Definition at line 1748 of file elem\&.h\&.
.PP
References libMesh::Elem::dim(), libMesh::Elem::level(), and libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::BoundaryInfo::add_edge(), libMesh::BoundaryInfo::add_side(), libMesh::UnstructuredMesh::all_second_order(), libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::JumpErrorEstimator::coarse_n_flux_faces_increment(), libMesh::FEAbstract::compute_node_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::Elem::get_info(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::Elem::level(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::Elem::nullify_neighbors(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::Parallel::packable_size(), libMesh::BoundaryInfo::remove_edge(), libMesh::BoundaryInfo::remove_side(), libMesh::BoundaryInfo::side_with_boundary_id(), libMesh::MeshRefinement::test_level_one(), libMesh::Elem::top_parent(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::Elem::which_neighbor_am_i(), and libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
1749 {
1750 #ifdef LIBMESH_ENABLE_AMR
1751 
1752   // if I don't have a parent I was
1753   // created directly from file
1754   // or by the user, so I am a
1755   // level-0 element
1756   if (this->parent() == NULL)
1757     return 0;
1758 
1759   // if the parent and this element are of different
1760   // dimensionality we are at the same level as
1761   // the parent (e\&.g\&. we are the 2D side of a
1762   // 3D element)
1763   if (this->dim() != this->parent()->dim())
1764     return this->parent()->level();
1765 
1766   // otherwise we are at a level one
1767   // higher than our parent
1768   return (this->parent()->level() + 1);
1769 
1770 #else
1771 
1772   // Without AMR all elements are
1773   // at level 0\&.
1774   return 0;
1775 
1776 #endif
1777 }
.fi
.SS "void libMesh::Elem::libmesh_assert_valid_neighbors () const\fC [inherited]\fP"
This function checks for consistent neighbor links at this element\&. 
.PP
Definition at line 973 of file elem\&.C\&.
.PP
References libMesh::Elem::dim(), libMesh::libmesh_assert(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::remote_elem, libMesh::Elem::subactive(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_valid_neighbors()\&.
.PP
.nf
974 {
975   for (unsigned int s=0; s<this->n_neighbors(); s++)
976     {
977       const Elem *neigh = this->neighbor(s);
978 
979       // Any element might have a remote neighbor; checking
980       // to make sure that's not inaccurate is tough\&.
981       if (neigh == remote_elem)
982         continue;
983 
984       if (neigh)
985         {
986           // Only subactive elements have subactive neighbors
987           libmesh_assert (this->subactive() || !neigh->subactive());
988 
989           const Elem *elem = this;
990 
991           // If we're subactive but our neighbor isn't, its
992           // return neighbor link will be to our first active
993           // ancestor OR to our inactive ancestor of the same
994           // level as neigh,
995           if (this->subactive() && !neigh->subactive())
996             {
997               for (elem = this; !elem->active();
998                    elem = elem->parent())
999                 libmesh_assert(elem);
1000             }
1001           else
1002             {
1003               unsigned int rev = neigh->which_neighbor_am_i(elem);
1004               libmesh_assert_less (rev, neigh->n_neighbors());
1005 
1006               if (this->subactive() && !neigh->subactive())
1007                 {
1008                   while (neigh->neighbor(rev) != elem)
1009                     {
1010                       libmesh_assert(elem->parent());
1011                       elem = elem->parent();
1012                     }
1013                 }
1014               else
1015                 {
1016                   Elem *nn = neigh->neighbor(rev);
1017                   libmesh_assert(nn);
1018 
1019                   for (; elem != nn; elem = elem->parent())
1020                     libmesh_assert(elem);
1021                 }
1022             }
1023         }
1024       // If we don't have a neighbor and we're not subactive, our
1025       // ancestors shouldn't have any neighbors in this same
1026       // direction\&.
1027       else if (!this->subactive())
1028         {
1029           const Elem *my_parent = this->parent();
1030           if (my_parent &&
1031               // A parent with a different dimension isn't really one of
1032               // our ancestors, it means we're on a boundary mesh and this
1033               // is an interior mesh element for which we're on a side\&.
1034               // Nothing to test for in that case\&.
1035               (my_parent->dim() == this->dim()))
1036             libmesh_assert (!my_parent->neighbor(s));
1037         }
1038     }
1039 }
.fi
.SS "void libMesh::Elem::libmesh_assert_valid_node_pointers () const\fC [inherited]\fP"
This function checks for a valid id and for pointers to nodes with valid ids at this element\&. 
.PP
Definition at line 961 of file elem\&.C\&.
.PP
References libMesh::Elem::get_node(), libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), and libMesh::DofObject::valid_id()\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_valid_node_pointers()\&.
.PP
.nf
962 {
963   libmesh_assert(this->valid_id());
964   for (unsigned int n=0; n != this->n_nodes(); ++n)
965     {
966       libmesh_assert(this->get_node(n));
967       libmesh_assert(this->get_node(n)->valid_id());
968     }
969 }
.fi
.SS "unsigned int libMesh::Elem::local_node (const \fBdof_id_type\fPi) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the local id number of global \fC\fBNode\fP\fP id \fCi\fP, or \fCinvalid_uint\fP if \fBNode\fP id \fCi\fP is not local\&. 
.RE
.PP

.PP
Definition at line 1376 of file elem\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::Elem::n_nodes(), and libMesh::Elem::node()\&.
.PP
Referenced by libMesh::MeshTools::find_nodal_neighbors(), and libMesh::SerialMesh::stitching_helper()\&.
.PP
.nf
1377 {
1378   for (unsigned int n=0; n != this->n_nodes(); ++n)
1379     if (this->node(n) == i)
1380       return n;
1381 
1382   return libMesh::invalid_uint;
1383 }
.fi
.SS "void libMesh::Elem::make_links_to_me_local (unsigned intn)\fC [inherited]\fP"
Resets the appropriate neighbor pointers of our nth neighbor (and its descendants, if appropriate) to point to this \fBElem\fP instead of to the global remote_elem\&. Used by the library when a formerly remote element is being added to the local processor\&. 
.PP
Definition at line 1045 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::is_remote(), libMesh::Elem::JUST_REFINED, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::Elem::side(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::Parallel::unpack()\&.
.PP
.nf
1046 {
1047   Elem *neigh = this->neighbor(n);
1048 
1049   // Don't bother calling this function unless it's necessary
1050   libmesh_assert(neigh);
1051   libmesh_assert(!neigh->is_remote());
1052 
1053   // We never have neighbors more refined than us
1054   libmesh_assert_less_equal (neigh->level(), this->level());
1055 
1056   // We never have subactive neighbors of non subactive elements
1057   libmesh_assert(!neigh->subactive() || this->subactive());
1058 
1059   // If we have a neighbor less refined than us then it must not
1060   // have any more refined active descendants we could have
1061   // pointed to instead\&.
1062   libmesh_assert(neigh->level() == this->level() ||
1063                  neigh->active());
1064 
1065   // If neigh is at our level, then its family might have
1066   // remote_elem neighbor links which need to point to us
1067   // instead, but if not, then we're done\&.
1068   if (neigh->level() != this->level())
1069     return;
1070 
1071   // If neigh is subactive then we're not updating its neighbor links
1072   // FIXME - this needs to change when we start using subactive
1073   // elements for more than just the two-phase
1074   // restriction/prolongation projections\&.
1075   if (neigh->subactive())
1076     return;
1077 
1078   // What side of neigh are we on?  We can't use the usual Elem
1079   // method because we're in the middle of restoring topology
1080   const AutoPtr<Elem> my_side = this->side(n);
1081   unsigned int nn = 0;
1082   for (; nn != neigh->n_sides(); ++nn)
1083     {
1084       const AutoPtr<Elem> neigh_side = neigh->side(nn);
1085       if (*my_side == *neigh_side)
1086         break;
1087     }
1088 
1089   // we had better be on *some* side of neigh
1090   libmesh_assert_less (nn, neigh->n_sides());
1091 
1092   // Find any elements that ought to point to elem
1093   std::vector<const Elem*> neigh_family;
1094 #ifdef LIBMESH_ENABLE_AMR
1095   if (this->active())
1096     neigh->family_tree_by_side(neigh_family, nn);
1097   else
1098 #endif
1099     neigh_family\&.push_back(neigh);
1100 
1101   // And point them to elem
1102   for (unsigned int i = 0; i != neigh_family\&.size(); ++i)
1103     {
1104       Elem* neigh_family_member = const_cast<Elem*>(neigh_family[i]);
1105 
1106       // Ideally, the neighbor link ought to either be correct
1107       // already or ought to be to remote_elem\&.
1108       //
1109       // However, if we're redistributing a newly created elem,
1110       // after an AMR step but before find_neighbors has fixed up
1111       // neighbor links, we might have an out of date neighbor
1112       // link to elem's parent instead\&.
1113 #ifdef LIBMESH_ENABLE_AMR
1114       libmesh_assert((neigh_family_member->neighbor(nn) == this) ||
1115                      (neigh_family_member->neighbor(nn) == remote_elem)
1116                      || ((this->refinement_flag() == JUST_REFINED) &&
1117                          (this->parent() != NULL) &&
1118                          (neigh_family_member->neighbor(nn) == this->parent())));
1119 #else
1120       libmesh_assert((neigh_family_member->neighbor(nn) == this) ||
1121                      (neigh_family_member->neighbor(nn) == remote_elem));
1122 #endif
1123 
1124       neigh_family_member->set_neighbor(nn, this);
1125     }
1126 }
.fi
.SS "void libMesh::Elem::make_links_to_me_remote ()\fC [inherited]\fP"
Resets this element's neighbors' appropriate neighbor pointers and its parent's and children's appropriate pointers to point to the global remote_elem instead of this\&. Used by the library before a remote element is deleted on the local processor\&. 
.PP
Definition at line 1129 of file elem\&.C\&.
.PP
References libMesh::Elem::child(), libMesh::Elem::dim(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::has_children(), libMesh::Elem::has_neighbor(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_neighbors(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::remote_elem, libMesh::Elem::set_child(), libMesh::Elem::set_neighbor(), libMesh::Elem::subactive(), libMesh::Elem::which_child_am_i(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
1130 {
1131   libmesh_assert_not_equal_to (this, remote_elem);
1132 
1133   // We need to have handled any children first
1134 #if defined(LIBMESH_ENABLE_AMR) && defined(DEBUG)
1135   if (this->has_children())
1136     for (unsigned int c = 0; c != this->n_children(); ++c)
1137       {
1138         Elem *current_child = this->child(c);
1139         libmesh_assert_equal_to (current_child, remote_elem);
1140       }
1141 #endif
1142 
1143   // Remotify any neighbor links to non-subactive elements
1144   if (!this->subactive())
1145     {
1146       for (unsigned int s = 0; s != this->n_sides(); ++s)
1147         {
1148           Elem *neigh = this->neighbor(s);
1149           if (neigh && neigh != remote_elem && !neigh->subactive())
1150             {
1151               // My neighbor should never be more refined than me; my real
1152               // neighbor would have been its parent in that case\&.
1153               libmesh_assert_greater_equal (this->level(), neigh->level());
1154 
1155               if (this->level() == neigh->level() &&
1156                   neigh->has_neighbor(this))
1157                 {
1158 #ifdef LIBMESH_ENABLE_AMR
1159                   // My neighbor may have descendants which also consider me a
1160                   // neighbor
1161                   std::vector<const Elem*> family;
1162                   neigh->family_tree_by_neighbor (family, this);
1163 
1164                   // FIXME - There's a lot of ugly const_casts here; we
1165                   // may want to make remote_elem non-const and create
1166                   // non-const versions of the family_tree methods
1167                   for (unsigned int i=0; i != family\&.size(); ++i)
1168                     {
1169                       Elem *n = const_cast<Elem*>(family[i]);
1170                       libmesh_assert (n);
1171                       if (n == remote_elem)
1172                         continue;
1173                       unsigned int my_s = n->which_neighbor_am_i(this);
1174                       libmesh_assert_less (my_s, n->n_neighbors());
1175                       libmesh_assert_equal_to (n->neighbor(my_s), this);
1176                       n->set_neighbor(my_s, const_cast<RemoteElem*>(remote_elem));
1177                     }
1178 #else
1179                   unsigned int my_s = neigh->which_neighbor_am_i(this);
1180                   libmesh_assert_less (my_s, neigh->n_neighbors());
1181                   libmesh_assert_equal_to (neigh->neighbor(my_s), this);
1182                   neigh->set_neighbor(my_s, const_cast<RemoteElem*>(remote_elem));
1183 #endif
1184                 }
1185 #ifdef LIBMESH_ENABLE_AMR
1186               // Even if my neighbor doesn't link back to me, it might
1187               // have subactive descendants which do
1188               else if (neigh->has_children())
1189                 {
1190                   // If my neighbor at the same level doesn't have me as a
1191                   // neighbor, I must be subactive
1192                   libmesh_assert(this->level() > neigh->level() ||
1193                                  this->subactive());
1194 
1195                   // My neighbor must have some ancestor of mine as a
1196                   // neighbor
1197                   Elem *my_ancestor = this->parent();
1198                   libmesh_assert(my_ancestor);
1199                   while (!neigh->has_neighbor(my_ancestor))
1200                     {
1201                       my_ancestor = my_ancestor->parent();
1202                       libmesh_assert(my_ancestor);
1203                     }
1204 
1205                   // My neighbor may have descendants which consider me a
1206                   // neighbor
1207                   std::vector<const Elem*> family;
1208                   neigh->family_tree_by_subneighbor (family, my_ancestor, this);
1209 
1210                   // FIXME - There's a lot of ugly const_casts here; we
1211                   // may want to make remote_elem non-const and create
1212                   // non-const versions of the family_tree methods
1213                   for (unsigned int i=0; i != family\&.size(); ++i)
1214                     {
1215                       Elem *n = const_cast<Elem*>(family[i]);
1216                       libmesh_assert (n);
1217                       if (n == remote_elem)
1218                         continue;
1219                       unsigned int my_s = n->which_neighbor_am_i(this);
1220                       libmesh_assert_less (my_s, n->n_neighbors());
1221                       libmesh_assert_equal_to (n->neighbor(my_s), this);
1222                       n->set_neighbor(my_s, const_cast<RemoteElem*>(remote_elem));
1223                     }
1224                 }
1225 #endif
1226             }
1227         }
1228     }
1229 
1230 #ifdef LIBMESH_ENABLE_AMR
1231   // Remotify parent's child link
1232   Elem *my_parent = this->parent();
1233   if (my_parent &&
1234       // As long as it's not already remote
1235       my_parent != remote_elem &&
1236       // And it's a real parent, not an interior parent
1237       this->dim() == my_parent->dim())
1238     {
1239       unsigned int me = my_parent->which_child_am_i(this);
1240       libmesh_assert_equal_to (my_parent->child(me), this);
1241       my_parent->set_child(me, const_cast<RemoteElem*>(remote_elem));
1242     }
1243 #endif
1244 }
.fi
.SS "unsigned int libMesh::Elem::max_descendant_p_level () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the maximum value of the p refinement levels of an ancestor element's descendants 
.PP
Definition at line 1869 of file elem\&.h\&.
.PP
References libMesh::Elem::_p_level, libMesh::Elem::active(), libMesh::Elem::child(), libMesh::libmesh_assert(), std::max(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::n_children(), libMesh::Elem::p_level(), and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::coarsened_dof_values(), and libMesh::Elem::max_descendant_p_level()\&.
.PP
.nf
1870 {
1871   // This is undefined for subactive elements,
1872   // which have no active descendants
1873   libmesh_assert (!this->subactive());
1874   if (this->active())
1875     return this->p_level();
1876 
1877   unsigned int max_p_level = _p_level;
1878   for (unsigned int c=0; c != this->n_children(); c++)
1879     max_p_level = std::max(max_p_level,
1880                            this->child(c)->max_descendant_p_level());
1881   return max_p_level;
1882 }
.fi
.SS "unsigned int libMesh::Elem::min_new_p_level_by_neighbor (const \fBElem\fP *neighbor, unsigned intcurrent_min) const\fC [inherited]\fP"
Returns the minimum new p refinement level (i\&.e\&. after refinement and coarsening is done) of elements which are descended from this and which share a side with the active \fCneighbor\fP 
.PP
Definition at line 1713 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::COARSEN, libMesh::Elem::has_neighbor(), libMesh::libmesh_assert(), libMesh::libmesh_assert_greater(), std::min(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::n_children(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::REFINE, libMesh::remote_elem, and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::MeshRefinement::eliminate_unrefined_patches(), and libMesh::Elem::min_new_p_level_by_neighbor()\&.
.PP
.nf
1715 {
1716   libmesh_assert(!this->subactive());
1717   libmesh_assert(neighbor_in->active());
1718 
1719   // If we're an active element this is simple
1720   if (this->active())
1721     {
1722       unsigned int new_p_level = this->p_level();
1723       if (this->p_refinement_flag() == Elem::REFINE)
1724         new_p_level += 1;
1725       if (this->p_refinement_flag() == Elem::COARSEN)
1726         {
1727           libmesh_assert_greater (new_p_level, 0);
1728           new_p_level -= 1;
1729         }
1730       return std::min(current_min, new_p_level);
1731     }
1732 
1733   libmesh_assert(has_neighbor(neighbor_in));
1734 
1735   unsigned int min_p_level = current_min;
1736 
1737   for (unsigned int c=0; c<this->n_children(); c++)
1738     {
1739       const Elem* const current_child = this->child(c);
1740       if (current_child && current_child != remote_elem)
1741         if (current_child->has_neighbor(neighbor_in))
1742           min_p_level =
1743             current_child->min_new_p_level_by_neighbor(neighbor_in,
1744                                                        min_p_level);
1745     }
1746 
1747   return min_p_level;
1748 }
.fi
.SS "unsigned int libMesh::Elem::min_p_level_by_neighbor (const \fBElem\fP *neighbor, unsigned intcurrent_min) const\fC [inherited]\fP"
Returns the minimum p refinement level of elements which are descended from this and which share a side with the active \fCneighbor\fP 
.PP
Definition at line 1680 of file elem\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::child(), libMesh::Elem::has_neighbor(), libMesh::libmesh_assert(), std::min(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::n_children(), libMesh::Elem::p_level(), libMesh::remote_elem, and libMesh::Elem::subactive()\&.
.PP
Referenced by libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), and libMesh::Elem::min_p_level_by_neighbor()\&.
.PP
.nf
1682 {
1683   libmesh_assert(!this->subactive());
1684   libmesh_assert(neighbor_in->active());
1685 
1686   // If we're an active element this is simple
1687   if (this->active())
1688     return std::min(current_min, this->p_level());
1689 
1690   libmesh_assert(has_neighbor(neighbor_in));
1691 
1692   // The p_level() of an ancestor element is already the minimum
1693   // p_level() of its children - so if that's high enough, we don't
1694   // need to examine any children\&.
1695   if (current_min <= this->p_level())
1696     return current_min;
1697 
1698   unsigned int min_p_level = current_min;
1699 
1700   for (unsigned int c=0; c<this->n_children(); c++)
1701     {
1702       const Elem* const current_child = this->child(c);
1703       if (current_child != remote_elem && current_child->has_neighbor(neighbor_in))
1704         min_p_level =
1705           current_child->min_p_level_by_neighbor(neighbor_in,
1706                                                  min_p_level);
1707     }
1708 
1709   return min_p_level;
1710 }
.fi
.SS "unsigned int libMesh::Hex::n_children () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
8 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 71 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex::is_child_on_side()\&.
.PP
.nf
71 { return 8; }
.fi
.SS "unsigned int libMesh::DofObject::n_comp (const unsigned ints, const unsigned intvar) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for variable \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 759 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), and libMesh::DofObject::var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), libMesh::DofObject::n_dofs(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
761 {
762   libmesh_assert_less (s,   this->n_systems());
763   libmesh_assert_less (var, this->n_vars(s));
764 
765   return this->n_comp_group(s,this->var_to_vg(s,var));
766 }
.fi
.SS "unsigned int libMesh::DofObject::n_comp_group (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 772 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::dof_number(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::n_comp(), libMesh::DofMap::reinit(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
774 {
775   libmesh_assert_less (s,  this->n_systems());
776   libmesh_assert_less (vg, this->n_var_groups(s));
777 
778   const unsigned int
779     start_idx_sys = this->start_idx(s);
780 
781   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
782 
783   return (_idx_buf[start_idx_sys + 2*vg] % ncv_magic);
784 }
.fi
.SS "unsigned int libMesh::DofObject::n_dofs (const unsigned ints, const unsigned intvar = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom associated with system \fCs\fP for this object\&. Optionally only counts degrees of freedom for variable number \fCvar\fP 
.RE
.PP

.PP
Definition at line 589 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::DofObject::n_comp(), libMesh::DofObject::n_systems(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector()\&.
.PP
.nf
591 {
592   libmesh_assert_less (s, this->n_systems());
593 
594   unsigned int num = 0;
595 
596   // Count all variables
597   if (var == libMesh::invalid_uint)
598     for (unsigned int v=0; v<this->n_vars(s); v++)
599       num += this->n_comp(s,v);
600 
601   // Only count specified variable
602   else
603     num = this->n_comp(s,var);
604 
605   return num;
606 }
.fi
.SS "unsigned int libMesh::Hex::n_edges () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
12\&. All hexahedrals have 12 edges\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 61 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex8::build_edge(), libMesh::Hex20::build_edge(), build_edge(), libMesh::Hex::is_edge_on_side(), libMesh::Hex8::is_node_on_edge(), libMesh::Hex20::is_node_on_edge(), and is_node_on_edge()\&.
.PP
.nf
61 { return 12; }
.fi
.SS "unsigned int libMesh::Hex::n_faces () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
6\&. All hexahedrals have 6 faces\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 66 of file cell_hex\&.h\&.
.PP
.nf
66 { return 6; }
.fi
.SS "virtual unsigned int libMesh::Elem::n_neighbors () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of neighbors the element that has been derived from this class has\&. By default only face (or edge in 2D) neighbors are stored, so this method returns \fBn_sides()\fP, however it may be overloaded in a derived class 
.RE
.PP

.PP
Definition at line 426 of file elem\&.h\&.
.PP
References libMesh::Elem::n_sides()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::Elem::_last_side(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::TetGenMeshInterface::check_hull_integrity(), libMesh::Elem::child_neighbor(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Tri3Subdivision::get_ordered_valence(), libMesh::Elem::has_neighbor(), libMesh::Elem::has_topological_neighbor(), libMesh::LaplaceMeshSmoother::init(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::Elem::make_links_to_me_remote(), libMesh::Elem::neighbor(), libMesh::Elem::nullify_neighbors(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::Parallel::packable_size(), libMesh::Elem::packed_size(), libMesh::Elem::set_neighbor(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::MeshRefinement::test_level_one(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
.nf
427   { return this->n_sides(); }
.fi
.SS "unsigned int libMesh::Hex27::n_nodes () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
27 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 89 of file cell_hex27\&.h\&.
.PP
Referenced by second_order_adjacent_vertex(), and second_order_child_vertex()\&.
.PP
.nf
89 { return 27; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "unsigned int libMesh::Hex27::n_second_order_adjacent_vertices (const unsigned intn) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
2 for all edge nodes, 4 for all face nodes, and 8 for the bubble node 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 614 of file cell_hex27\&.C\&.
.PP
References libMesh::invalid_uint\&.
.PP
.nf
615 {
616   switch (n)
617     {
618     case 8:
619     case 9:
620     case 10:
621     case 11:
622     case 12:
623     case 13:
624     case 14:
625     case 15:
626     case 16:
627     case 17:
628     case 18:
629     case 19:
630       return 2;
631 
632     case 20:
633     case 21:
634     case 22:
635     case 23:
636     case 24:
637     case 25:
638       return 4;
639 
640     case 26:
641       return 8;
642 
643     default:
644       libmesh_error();
645     }
646 
647   libmesh_error();
648   return libMesh::invalid_uint;
649 }
.fi
.SS "unsigned int libMesh::Hex::n_sides () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
6 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 51 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex8::build_side(), libMesh::Hex20::build_side(), build_side(), libMesh::Hex::is_child_on_side(), libMesh::Hex::is_edge_on_side(), libMesh::Hex8::is_node_on_side(), is_node_on_side(), libMesh::Hex20::is_node_on_side(), libMesh::Hex::key(), key(), libMesh::Hex::opposite_node(), and libMesh::Hex::side()\&.
.PP
.nf
51 { return 6; }
.fi
.SS "unsigned int libMesh::Hex27::n_sub_elem () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
8 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 94 of file cell_hex27\&.h\&.
.PP
Referenced by connectivity()\&.
.PP
.nf
94 { return 8; }
.fi
.SS "unsigned int libMesh::DofObject::n_systems () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of systems associated with this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 705 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofObject::add_system(), libMesh::DofObject::clear_dofs(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), libMesh::DofObject::end_idx(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofObject::has_dofs(), libMesh::DofObject::invalidate_dofs(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_dofs(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::Elem::refine(), libMesh::EquationSystems::reinit(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofObject::set_vg_dof_base(), libMesh::DofObject::start_idx(), and libMesh::DofObject::vg_dof_base()\&.
.PP
.nf
706 {
707   return _idx_buf\&.empty() ?
708     0 : libmesh_cast_int<unsigned int>(_idx_buf[0]);
709 }
.fi
.SS "unsigned int libMesh::DofObject::n_var_groups (const unsigned ints) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariableGroup\fP\fP variable groups associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 714 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::end_idx(), libMesh::DofObject::n_systems(), and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofObject::add_system(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::DofObject(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_vars(), libMesh::DofObject::operator=(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::DofObject::set_vg_dof_base(), libMesh::DofObject::var_to_vg(), and libMesh::DofObject::vg_dof_base()\&.
.PP
.nf
715 {
716   libmesh_assert_less (s, this->n_systems());
717 
718   return (this->end_idx(s) - this->start_idx(s)) / 2;
719 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with \fC\fBVariableGroup\fP\fP \fCvg\fP in system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 724 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofObject::add_system(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::DofMap::distribute_dofs(), libMesh::DofObject::dof_number(), libMesh::DofObject::DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofObject::has_dofs(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_dofs(), libMesh::DofObject::n_vars(), libMesh::DofObject::operator=(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_systems(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
726 {
727   libmesh_assert_less (s,  this->n_systems());
728   libmesh_assert_less (vg, this->n_var_groups(s));
729 
730   const unsigned int start_idx_sys = this->start_idx(s);
731 
732   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
733 
734   return (libmesh_cast_int<unsigned int>
735           (_idx_buf[start_idx_sys + 2*vg]) / ncv_magic);
736 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 741 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::n_vars()\&.
.PP
.nf
742 {
743   libmesh_assert_less (s, this->n_systems());
744 
745   const unsigned int nvg = this->n_var_groups(s);
746 
747   unsigned int val=0;
748 
749   for (unsigned int vg=0; vg<nvg; vg++)
750     val += this->n_vars(s,vg);
751 
752   return val;
753 }
.fi
.SS "unsigned int libMesh::Hex::n_vertices () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
8\&. All hexahedrals have 8 vertices\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 56 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex20::second_order_adjacent_vertex(), second_order_adjacent_vertex(), libMesh::Hex20::second_order_child_vertex(), and second_order_child_vertex()\&.
.PP
.nf
56 { return 8; }
.fi
.SS "\fBElem\fP * libMesh::Elem::neighbor (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the $ i^{th} $ neighbor of this element\&. If \fC\fBMeshBase::find_neighbors()\fP\fP has not been called this simply returns \fCNULL\fP\&. If \fC\fBMeshBase::find_neighbors()\fP\fP has been called and this returns \fCNULL\fP then the side is on a boundary of the domain\&. 
.RE
.PP

.PP
Definition at line 1437 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks, and libMesh::Elem::n_neighbors()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::TetGenMeshInterface::check_hull_integrity(), libMesh::Elem::child_neighbor(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::FEAbstract::compute_node_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::Elem::find_edge_neighbors(), libMesh::Patch::find_face_neighbors(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::Subdivision::find_one_ring(), libMesh::Elem::find_point_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::Elem::get_info(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::Elem::has_neighbor(), libMesh::LaplaceMeshSmoother::init(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::Elem::nullify_neighbors(), libMesh::SparsityPattern::Build::operator()(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::REINIT_ERROR(), libMesh::FE< Dim, T >::side_map(), libMesh::Elem::SideIter::side_on_boundary(), libMesh::BoundaryInfo::side_with_boundary_id(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::Subdivision::tag_boundary_ghosts(), libMesh::Elem::topological_neighbor(), libMesh::MeshRefinement::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::Elem::which_neighbor_am_i(), libMesh::GnuPlotIO::write_solution(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
1438 {
1439   libmesh_assert_less (i, this->n_neighbors());
1440 
1441   return _elemlinks[i+1];
1442 }
.fi
.SS "\fBdof_id_type\fP libMesh::Elem::node (const unsigned inti) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the global id number of local \fC\fBNode\fP\fP \fCi\fP\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 1364 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, libMesh::DofObject::id(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), and libMesh::Elem::n_nodes()\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::EquationSystems::build_solution_vector(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::FEMap::compute_face_map(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::InfEdge2::connectivity(), libMesh::Edge4::connectivity(), libMesh::Edge2::connectivity(), libMesh::Edge3::connectivity(), libMesh::InfQuad4::connectivity(), libMesh::Quad4::connectivity(), libMesh::InfQuad6::connectivity(), libMesh::Tri3::connectivity(), libMesh::Prism6::connectivity(), libMesh::Pyramid5::connectivity(), libMesh::Hex8::connectivity(), libMesh::InfPrism6::connectivity(), libMesh::Quad9::connectivity(), libMesh::Quad8::connectivity(), libMesh::InfPrism12::connectivity(), libMesh::Tri6::connectivity(), libMesh::InfHex8::connectivity(), libMesh::Tet4::connectivity(), libMesh::Tet10::connectivity(), libMesh::Hex20::connectivity(), libMesh::InfHex16::connectivity(), libMesh::Pyramid13::connectivity(), libMesh::Prism15::connectivity(), libMesh::Pyramid14::connectivity(), connectivity(), libMesh::InfHex18::connectivity(), libMesh::Prism18::connectivity(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::create_submesh(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshTools::get_not_subactive_node_ids(), libMesh::Tet::key(), libMesh::Prism::key(), libMesh::Pyramid::key(), libMesh::Hex::key(), libMesh::Tri::key(), libMesh::InfPrism::key(), libMesh::InfHex::key(), libMesh::Quad::key(), libMesh::InfQuad::key(), libMesh::Edge::key(), libMesh::Quad9::key(), libMesh::Quad8::key(), libMesh::Tri6::key(), key(), libMesh::Prism18::key(), libMesh::InfHex18::key(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::Elem::local_node(), libMesh::RemoteElem::node(), libMesh::Elem::operator==(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::GmshIO::read_mesh(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::FE< Dim, T >::side_map(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::BoundaryInfo::sync(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::CheckpointIO::write_connectivity(), libMesh::Elem::write_connectivity(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::EnsightIO::write_geometry_ascii(), libMesh::GmshIO::write_mesh(), libMesh::LegacyXdrIO::write_mesh(), libMesh::GmshIO::write_post(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
1365 {
1366   libmesh_assert_less (i, this->n_nodes());
1367   libmesh_assert(_nodes[i]);
1368   libmesh_assert_not_equal_to (_nodes[i]->id(), Node::invalid_id);
1369 
1370   return _nodes[i]->id();
1371 }
.fi
.SS "void libMesh::Elem::nullify_neighbors ()\fC [inherited]\fP"
Replaces this element with \fCNULL\fP for all of its neighbors\&. This is useful when deleting an element\&. 
.PP
Definition at line 1972 of file elem\&.C\&.
.PP
References libMesh::Elem::level(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), and libMesh::Elem::which_neighbor_am_i()\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements()\&.
.PP
.nf
1973 {
1974   // Tell any of my neighbors about my death\&.\&.\&.
1975   // Looks strange, huh?
1976   for (unsigned int n=0; n<this->n_neighbors(); n++)
1977     {
1978       Elem* current_neighbor = this->neighbor(n);
1979       if (current_neighbor && current_neighbor != remote_elem)
1980         {
1981           // Note:  it is possible that I see the neighbor
1982           // (which is coarser than me)
1983           // but they don't see me, so avoid that case\&.
1984           if (current_neighbor->level() == this->level())
1985             {
1986               const unsigned int w_n_a_i = current_neighbor->which_neighbor_am_i(this);
1987               libmesh_assert_less (w_n_a_i, current_neighbor->n_neighbors());
1988               current_neighbor->set_neighbor(w_n_a_i, NULL);
1989               this->set_neighbor(n, NULL);
1990             }
1991         }
1992     }
1993 }
.fi
.SS "bool libMesh::Elem::on_boundary () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this element has a side coincident with a boundary (indicated by a \fCNULL\fP neighbor), \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 1495 of file elem\&.h\&.
.PP
References libMesh::Elem::has_neighbor()\&.
.PP
.nf
1496 {
1497   // By convention, the element is on the boundary
1498   // if it has a NULL neighbor\&.
1499   return this->has_neighbor(NULL);
1500 }
.fi
.SS "bool libMesh::Elem::operator== (const \fBElem\fP &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
true if two elements are identical, false otherwise\&. This is true if the elements are connected to identical global nodes, regardless of how those nodes might be numbered local to the elements\&. 
.RE
.PP

.PP
Definition at line 457 of file elem\&.C\&.
.PP
References libMesh::Elem::n_nodes(), and libMesh::Elem::node()\&.
.PP
.nf
458 {
459 
460   // Cast rhs to an Elem*
461   //    const Elem* rhs_elem = dynamic_cast<const Elem*>(&rhs);
462   const Elem* rhs_elem = &rhs;
463 
464   // If we cannot cast to an Elem*, rhs must be a Node
465   //    if(rhs_elem == static_cast<const Elem*>(NULL))
466   //        return false;
467 
468   //   libmesh_assert (n_nodes());
469   //   libmesh_assert (rhs\&.n_nodes());
470 
471   //   // Elements can only be equal if they
472   //   // contain the same number of nodes\&.
473   //   if (this->n_nodes() == rhs\&.n_nodes())
474   //     {
475   //       // Create a set that contains our global
476   //       // node numbers and those of our neighbor\&.
477   //       // If the set is the same size as the number
478   //       // of nodes in both elements then they must
479   //       // be connected to the same nodes\&.
480   //       std::set<unsigned int> nodes_set;
481 
482   //       for (unsigned int n=0; n<this->n_nodes(); n++)
483   //         {
484   //           nodes_set\&.insert(this->node(n));
485   //           nodes_set\&.insert(rhs\&.node(n));
486   //         }
487 
488   //       // If this passes the elements are connected
489   //       // to the same global nodes
490   //       if (nodes_set\&.size() == this->n_nodes())
491   //         return true;
492   //     }
493 
494   //   // If we get here it is because the elements either
495   //   // do not have the same number of nodes or they are
496   //   // connected to different nodes\&.  Either way they
497   //   // are not the same element
498   //   return false;
499 
500   // Useful typedefs
501   typedef std::vector<dof_id_type>::iterator iterator;
502 
503 
504   // Elements can only be equal if they
505   // contain the same number of nodes\&.
506   // However, we will only test the vertices,
507   // which is sufficient & cheaper
508   if (this->n_nodes() == rhs_elem->n_nodes())
509     {
510       // The number of nodes in the element
511       const unsigned int nn = this->n_nodes();
512 
513       // Create a vector that contains our global
514       // node numbers and those of our neighbor\&.
515       // If the sorted, unique vector is the same size
516       // as the number of nodes in both elements then
517       // they must be connected to the same nodes\&.
518       //
519       // The vector will be no larger than 2*n_nodes(),
520       // so we might as well reserve the space\&.
521       std::vector<dof_id_type> common_nodes;
522       common_nodes\&.reserve (2*nn);
523 
524       // Add the global indices of the nodes
525       for (unsigned int n=0; n<nn; n++)
526         {
527           common_nodes\&.push_back (this->node(n));
528           common_nodes\&.push_back (rhs_elem->node(n));
529         }
530 
531       // Sort the vector and find out how long
532       // the sorted vector is\&.
533       std::sort (common_nodes\&.begin(), common_nodes\&.end());
534 
535       iterator new_end = std::unique (common_nodes\&.begin(),
536                                       common_nodes\&.end());
537 
538       const int new_size = libmesh_cast_int<int>
539         (std::distance (common_nodes\&.begin(), new_end));
540 
541       // If this passes the elements are connected
542       // to the same global vertex nodes
543       if (new_size == static_cast<int>(nn))
544         return true;
545     }
546 
547   // If we get here it is because the elements either
548   // do not have the same number of nodes or they are
549   // connected to different nodes\&.  Either way they
550   // are not the same element
551   return false;
552 }
.fi
.SS "unsigned int libMesh::Hex::opposite_node (const unsigned intn, const unsigned ints) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the local node number for the node opposite to node n on side \fCopposite_side(s)\fP (for a tensor product element), or throws an error otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 227 of file cell_hex\&.C\&.
.PP
References libMesh::Elem::is_node_on_side(), libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), and libMesh::Hex::n_sides()\&.
.PP
.nf
229 {
230   libmesh_assert_less (node_in, 26);
231   libmesh_assert_less (node_in, this->n_nodes());
232   libmesh_assert_less (side_in, this->n_sides());
233   libmesh_assert(this->is_node_on_side(node_in, side_in));
234 
235   static const unsigned char side05_nodes_map[] =
236     {4, 5, 6, 7, 0, 1, 2, 3, 16, 17, 18, 19, 255, 255, 255, 255, 8, 9, 10, 11, 25, 255, 255, 255, 255, 20};
237   static const unsigned char side13_nodes_map[] =
238     {3, 2, 1, 0, 7, 6, 5, 4, 10, 255, 8, 255, 15, 14, 13, 12, 18, 255, 16, 255, 255, 23, 255, 21, 255, 255};
239   static const unsigned char side24_nodes_map[] =
240     {1, 0, 3, 2, 5, 4, 7, 6, 255, 11, 255, 9, 13, 12, 15, 14, 255, 19, 255, 17, 255, 255, 24, 255, 22, 255};
241 
242   switch (side_in)
243     {
244     case 0:
245     case 5:
246       return side05_nodes_map[node_in];
247       break;
248     case 1:
249     case 3:
250       return side13_nodes_map[node_in];
251       break;
252     case 2:
253     case 4:
254       return side24_nodes_map[node_in];
255       break;
256     }
257 
258   libmesh_error();
259   return 255;
260 }
.fi
.SS "unsigned int libMesh::Hex::opposite_side (const unsigned ints) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the side number opposite to \fCs\fP (for a tensor product element), or throws an error otherwise\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 218 of file cell_hex\&.C\&.
.PP
.nf
219 {
220   libmesh_assert_less (side_in, 6);
221   static const unsigned char hex_opposites[6] = {5, 3, 4, 1, 2, 0};
222   return hex_opposites[side_in];
223 }
.fi
.SS "virtual \fBPoint\fP libMesh::Elem::origin () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the origin for an infinite element\&. Currently, \fIall\fP infinite elements used in a mesh share the same origin\&. Overload this in infinite element classes\&. By default, issues an error, because returning the all zero point would very likely lead to unexpected behavior\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::InfQuad\fP, \fBlibMesh::InfEdge2\fP, and \fBlibMesh::InfCell\fP\&.
.PP
Definition at line 1116 of file elem\&.h\&.
.PP
Referenced by libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::combine_base_radial(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::Elem::get_info(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), and libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map()\&.
.PP
.nf
1116 { libmesh_error(); return Point(); }
.fi
.SS "unsigned int libMesh::Elem::p_level () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the value of the p refinement level of an active element, or the minimum value of the p refinement levels of an ancestor element's descendants 
.PP
Definition at line 1782 of file elem\&.h\&.
.PP
References libMesh::Elem::_p_level\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::DofMap::_dof_indices(), libMesh::MeshRefinement::_refine_elements(), libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::coarsen(), libMesh::FEGenericBase< T >::coarsened_dof_values(), libMesh::FEInterface::compute_data(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::FE< Dim, T >::dofs_on_edge(), libMesh::FE< Dim, T >::dofs_on_side(), libMesh::FE< Dim, T >::edge_reinit(), libMesh::Elem::Elem(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::Elem::get_info(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::init_face_shape_functions(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::DofMap::old_dof_indices(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::Elem::refine(), libMesh::FE< Dim, T >::reinit(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::reinit(), libMesh::FEXYZ< Dim >::reinit(), libMesh::DofMap::reinit(), libMesh::REINIT_ERROR(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Elem::set_p_level(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::FE< Dim, T >::side_map(), libMesh::MeshRefinement::test_level_one(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::GMVIO::write_ascii_new_impl(), and libMesh::CheckpointIO::write_connectivity()\&.
.PP
.nf
1783 {
1784 #ifdef LIBMESH_ENABLE_AMR
1785   return _p_level;
1786 #else
1787   return 0;
1788 #endif
1789 }
.fi
.SS "\fBElem::RefinementState\fP libMesh::Elem::p_refinement_flag () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the value of the p refinement flag for the element\&. 
.PP
Definition at line 1853 of file elem\&.h\&.
.PP
References libMesh::Elem::_pflag\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::Elem::get_info(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::DofMap::old_dof_indices(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::Elem::refine(), libMesh::MeshRefinement::test_unflagged(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1854 {
1855   return static_cast<RefinementState>(_pflag);
1856 }
.fi
.SS "void libMesh::DofObject::pack_indexing (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > >target) const\fC [inherited]\fP"
A method for creating packed data from our index buffer - basically a copy with prepended size with our current implementation\&. 
.PP
Definition at line 525 of file dof_object\&.C\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), and libMesh::Elem::PackedElem::pack()\&.
.PP
.nf
526 {
527 #ifdef LIBMESH_ENABLE_AMR
528   // We might need to pack old_dof_object too
529   *target++ = (old_dof_object == NULL) ? 0 : 1;
530 #endif
531 
532   *target++ = _idx_buf\&.size();
533   std::copy(_idx_buf\&.begin(), _idx_buf\&.end(), target);
534 
535 #ifdef LIBMESH_ENABLE_AMR
536   if (old_dof_object)
537     old_dof_object->pack_indexing(target);
538 #endif
539 }
.fi
.SS "unsigned int libMesh::DofObject::packed_indexing_size () const\fC [inherited]\fP"
If we pack our indices into an buffer for communications, how many ints do we need? 
.PP
Definition at line 448 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::old_dof_object, and libMesh::DofObject::packed_indexing_size()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), libMesh::DofObject::packed_indexing_size(), libMesh::Node::packed_size(), libMesh::Elem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
449 {
450   return
451 #ifdef LIBMESH_ENABLE_AMR
452     ((old_dof_object == NULL) ? 0 : old_dof_object->packed_indexing_size()) + 2 +
453 #else
454     1 +
455 #endif
456     _idx_buf\&.size();
457 }
.fi
.SS "unsigned int libMesh::Elem::packed_size () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 2361 of file elem\&.h\&.
.PP
References libMesh::Elem::PackedElem::header_size, libMesh::Elem::n_neighbors(), libMesh::Elem::n_nodes(), and libMesh::DofObject::packed_indexing_size()\&.
.PP
Referenced by libMesh::Elem::PackedElem::pack()\&.
.PP
.nf
2362 {
2363   return PackedElem::header_size + this->n_nodes() +
2364     this->n_neighbors() + this->packed_indexing_size();
2365 }
.fi
.SS "const \fBElem\fP * libMesh::Elem::parent () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a const pointer to the element's parent\&. Returns \fCNULL\fP if the element was not created via refinement, i\&.e\&. was read from file\&. 
.RE
.PP

.PP
Definition at line 1667 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks\&.
.PP
Referenced by libMesh::LinearPartitioner::_do_partition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::Elem::add_child(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::Elem::child_neighbor(), libMesh::FEMap::compute_face_map(), libMesh::FEAbstract::compute_node_constraints(), libMesh::UnstructuredMesh::contract(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::Elem::Elem(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::for(), libMesh::Elem::get_info(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::Elem::is_ancestor_of(), libMesh::Elem::level(), libMesh::MeshTools::libmesh_assert_no_links_to_elem(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_node_pointers(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::MeshTools::libmesh_assert_valid_remote_elems(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::BoundaryInfo::raw_boundary_ids(), libMesh::BoundaryInfo::raw_edge_boundary_ids(), libMesh::Elem::refine(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Elem::set_p_level(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::side_with_boundary_id(), libMesh::MeshTools::Modification::smooth(), libMesh::Elem::subactive(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::top_parent(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::Elem::which_neighbor_am_i(), libMesh::CheckpointIO::write_connectivity(), and libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
1668 {
1669   return _elemlinks[0];
1670 }
.fi
.SS "\fBElem\fP * libMesh::Elem::parent ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the element's parent\&. Returns \fCNULL\fP if the element was not created via refinement, i\&.e\&. was read from file\&. 
.RE
.PP

.PP
Definition at line 1675 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks\&.
.PP
.nf
1676 {
1677   return _elemlinks[0];
1678 }
.fi
.SS "const \fBPoint\fP & libMesh::Elem::point (const unsigned inti) const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fC\fBPoint\fP\fP associated with local \fC\fBNode\fP\fP \fCi\fP\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 1342 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), and libMesh::Elem::n_nodes()\&.
.PP
Referenced by libMesh::PostscriptIO::_compute_edge_bezier_coeffs(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::MeshTools::Modification::all_tri(), libMesh::Tet::choose_diagonal(), libMesh::Elem::coarsen(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::compute_data(), libMesh::FEMap::compute_edge_map(), libMesh::FEXYZMap::compute_face_map(), libMesh::FEMap::compute_face_map(), libMesh::Elem::contains_edge_of(), libMesh::InfQuad4::contains_point(), libMesh::InfPrism6::contains_point(), libMesh::InfHex8::contains_point(), libMesh::Elem::contains_vertex_of(), libMesh::UnstructuredMesh::create_submesh(), libMesh::FEMContext::elem_position_get(), libMesh::Edge4::has_affine_map(), libMesh::Edge3::has_affine_map(), libMesh::Prism6::has_affine_map(), libMesh::Quad4::has_affine_map(), libMesh::Hex8::has_affine_map(), libMesh::Quad9::has_affine_map(), libMesh::Quad8::has_affine_map(), libMesh::Tri6::has_affine_map(), libMesh::Tet10::has_affine_map(), has_affine_map(), libMesh::Hex20::has_affine_map(), libMesh::Prism18::has_affine_map(), libMesh::Prism15::has_affine_map(), libMesh::Elem::hmax(), libMesh::Elem::hmin(), libMesh::TreeNode< N >::insert(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::inverse_map(), libMesh::Elem::length(), libMesh::FE< Dim, T >::map(), libMesh::InfFE< friend_Dim, friend_T_radial, friend_T_map >::map(), libMesh::FE< Dim, T >::map_eta(), libMesh::FE< Dim, T >::map_xi(), libMesh::FE< Dim, T >::map_zeta(), libMesh::Tri3::min_and_max_angle(), libMesh::Tet4::min_and_max_angle(), libMesh::FEMSystem::numerical_jacobian(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::InfCell::origin(), libMesh::InfEdge2::origin(), libMesh::InfQuad::origin(), libMesh::PostscriptIO::plot_linear_elem(), libMesh::RemoteElem::point(), libMesh::Elem::point_test(), libMesh::Elem::refine(), libMesh::FE< Dim, T >::reinit(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::MeshTools::Modification::smooth(), libMesh::Edge2::volume(), libMesh::Quad4::volume(), libMesh::Edge3::volume(), libMesh::Elem::which_side_am_i(), libMesh::EnsightIO::write_geometry_ascii(), and libMesh::GmshIO::write_post()\&.
.PP
.nf
1343 {
1344   libmesh_assert_less (i, this->n_nodes());
1345   libmesh_assert(_nodes[i]);
1346   libmesh_assert_not_equal_to (_nodes[i]->id(), Node::invalid_id);
1347 
1348   return *_nodes[i];
1349 }
.fi
.SS "\fBPoint\fP & libMesh::Elem::point (const unsigned inti)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fC\fBPoint\fP\fP associated with local \fC\fBNode\fP\fP \fCi\fP as a writeable reference\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 1354 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, and libMesh::Elem::n_nodes()\&.
.PP
.nf
1355 {
1356   libmesh_assert_less (i, this->n_nodes());
1357 
1358   return *_nodes[i];
1359 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "void libMesh::Elem::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Prints relevant information about the element\&. 
.PP
Definition at line 1895 of file elem\&.C\&.
.PP
References libMesh::Elem::get_info()\&.
.PP
Referenced by libMesh::FE< Dim, T >::inverse_map(), and libMesh::operator<<()\&.
.PP
.nf
1896 {
1897   os << this->get_info()
1898      << std::endl;
1899 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::DofObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to\&.
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 673 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::CentroidPartitioner::_do_partition(), libMesh::ParallelMesh::add_elem(), libMesh::Patch::add_local_face_neighbors(), libMesh::Patch::add_local_point_neighbors(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::SerialMesh::add_point(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::Patch::build_around_element(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::Elem::Elem(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::DofObject::invalidate_processor_id(), libMesh::Elem::is_semilocal(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshFunction::operator()(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::DofObject::processor_id(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshData::read_xdr(), libMesh::Elem::refine(), libMesh::DofMap::scatter_constraints(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::CheckpointIO::write_connectivity(), libMesh::GmshIO::write_mesh(), libMesh::CheckpointIO::write_nodes(), libMesh::XdrIO::write_serialized_connectivity(), and libMesh::Nemesis_IO_Helper::write_sidesets()\&.
.PP
.nf
674 {
675   return _processor_id;
676 }
.fi
.SS "\fBprocessor_id_type\fP & libMesh::DofObject::processor_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 681 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id\&.
.PP
.nf
682 {
683   return _processor_id;
684 }
.fi
.SS "void libMesh::DofObject::processor_id (const \fBprocessor_id_type\fPpid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the \fCprocessor_id\fP for this \fC\fBDofObject\fP\fP\&. 
.PP
Definition at line 689 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::processor_id()\&.
.PP
.nf
690 {
691   this->processor_id() = pid;
692 }
.fi
.SS "std::pair< \fBReal\fP, \fBReal\fP > libMesh::Hex::qual_bounds (const \fBElemQuality\fPq) const\fC [virtual]\fP, \fC [inherited]\fP"
Returns the suggested quality bounds for the hex based on quality measure q\&. These are the values suggested by the CUBIT User's Manual\&. 
.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 411 of file cell_hex\&.C\&.
.PP
References libMesh::ASPECT_RATIO, libMesh::CONDITION, libMesh::DIAGONAL, libMesh::DISTORTION, libMesh::JACOBIAN, libMesh::out, libMesh::SHAPE, libMesh::SHEAR, libMesh::SIZE, libMesh::SKEW, libMesh::STRETCH, and libMesh::TAPER\&.
.PP
.nf
412 {
413   std::pair<Real, Real> bounds;
414 
415   switch (q)
416     {
417 
418     case ASPECT_RATIO:
419       bounds\&.first  = 1\&.;
420       bounds\&.second = 4\&.;
421       break;
422 
423     case SKEW:
424       bounds\&.first  = 0\&.;
425       bounds\&.second = 0\&.5;
426       break;
427 
428     case SHEAR:
429     case SHAPE:
430       bounds\&.first  = 0\&.3;
431       bounds\&.second = 1\&.;
432       break;
433 
434     case CONDITION:
435       bounds\&.first  = 1\&.;
436       bounds\&.second = 8\&.;
437       break;
438 
439     case JACOBIAN:
440       bounds\&.first  = 0\&.5;
441       bounds\&.second = 1\&.;
442       break;
443 
444     case DISTORTION:
445       bounds\&.first  = 0\&.6;
446       bounds\&.second = 1\&.;
447       break;
448 
449     case TAPER:
450       bounds\&.first  = 0\&.;
451       bounds\&.second = 0\&.4;
452       break;
453 
454     case STRETCH:
455       bounds\&.first  = 0\&.25;
456       bounds\&.second = 1\&.;
457       break;
458 
459     case DIAGONAL:
460       bounds\&.first  = 0\&.65;
461       bounds\&.second = 1\&.;
462       break;
463 
464     case SIZE:
465       bounds\&.first  = 0\&.5;
466       bounds\&.second = 1\&.;
467       break;
468 
469     default:
470       libMesh::out << "Warning: Invalid quality measure chosen\&." << std::endl;
471       bounds\&.first  = -1;
472       bounds\&.second = -1;
473     }
474 
475   return bounds;
476 }
.fi
.SS "\fBReal\fP libMesh::Hex::quality (const \fBElemQuality\fPq) const\fC [virtual]\fP, \fC [inherited]\fP"
Based on the quality metric q specified by the user, returns a quantitative assessment of element quality\&. Compue the min/max diagonal ratio\&. Source: CUBIT User's Manual\&.
.PP
Minimum ratio of lengths derived from opposite edges\&. Source: CUBIT User's Manual\&.
.PP
Compute the side lengths\&.
.PP
Minimum edge length divided by max diagonal length\&. Source: CUBIT User's Manual\&.
.PP
Compute the maximum diagonal\&.
.PP
Compute the minimum edge length\&.
.PP
I don't know what to do for this metric\&. Maybe the base class knows\&.\&.\&.
.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 264 of file cell_hex\&.C\&.
.PP
References libMesh::DIAGONAL, libMesh::Elem::length(), std::max(), std::min(), libMesh::Elem::quality(), libMesh::Real, libMesh::STRETCH, and libMesh::TAPER\&.
.PP
.nf
265 {
266   switch (q)
267     {
268 
273     case DIAGONAL:
274       {
275         // Diagonal between node 0 and node 6
276         const Real d06 = this->length(0,6);
277 
278         // Diagonal between node 3 and node 5
279         const Real d35 = this->length(3,5);
280 
281         // Diagonal between node 1 and node 7
282         const Real d17 = this->length(1,7);
283 
284         // Diagonal between node 2 and node 4
285         const Real d24 = this->length(2,4);
286 
287         // Find the biggest and smallest diagonals
288         const Real min = std::min(d06, std::min(d35, std::min(d17, d24)));
289         const Real max = std::max(d06, std::max(d35, std::max(d17, d24)));
290 
291         libmesh_assert_not_equal_to (max, 0\&.0);
292 
293         return min / max;
294 
295         break;
296       }
297 
302     case TAPER:
303       {
304 
308         const Real d01 = this->length(0,1);
309         const Real d12 = this->length(1,2);
310         const Real d23 = this->length(2,3);
311         const Real d03 = this->length(0,3);
312         const Real d45 = this->length(4,5);
313         const Real d56 = this->length(5,6);
314         const Real d67 = this->length(6,7);
315         const Real d47 = this->length(4,7);
316         const Real d04 = this->length(0,4);
317         const Real d15 = this->length(1,5);
318         const Real d37 = this->length(3,7);
319         const Real d26 = this->length(2,6);
320 
321         std::vector<Real> edge_ratios(12);
322         // Front
323         edge_ratios[0] = std::min(d01, d45) / std::max(d01, d45);
324         edge_ratios[1] = std::min(d04, d15) / std::max(d04, d15);
325 
326         // Right
327         edge_ratios[2] = std::min(d15, d26) / std::max(d15, d26);
328         edge_ratios[3] = std::min(d12, d56) / std::max(d12, d56);
329 
330         // Back
331         edge_ratios[4] = std::min(d67, d23) / std::max(d67, d23);
332         edge_ratios[5] = std::min(d26, d37) / std::max(d26, d37);
333 
334         // Left
335         edge_ratios[6] = std::min(d04, d37) / std::max(d04, d37);
336         edge_ratios[7] = std::min(d03, d47) / std::max(d03, d47);
337 
338         // Bottom
339         edge_ratios[8] = std::min(d01, d23) / std::max(d01, d23);
340         edge_ratios[9] = std::min(d03, d12) / std::max(d03, d12);
341 
342         // Top
343         edge_ratios[10] = std::min(d45, d67) / std::max(d45, d67);
344         edge_ratios[11] = std::min(d56, d47) / std::max(d56, d47);
345 
346         return *(std::min_element(edge_ratios\&.begin(), edge_ratios\&.end())) ;
347 
348         break;
349       }
350 
351 
356     case STRETCH:
357       {
358         const Real sqrt3 = 1\&.73205080756888;
359 
363         const Real d06 = this->length(0,6);
364         const Real d17 = this->length(1,7);
365         const Real d35 = this->length(3,5);
366         const Real d24 = this->length(2,4);
367         const Real max_diag = std::max(d06, std::max(d17, std::max(d35, d24)));
368 
369         libmesh_assert_not_equal_to ( max_diag, 0\&.0 );
370 
374         std::vector<Real> edges(12);
375         edges[0]  = this->length(0,1);
376         edges[1]  = this->length(1,2);
377         edges[2]  = this->length(2,3);
378         edges[3]  = this->length(0,3);
379         edges[4]  = this->length(4,5);
380         edges[5]  = this->length(5,6);
381         edges[6]  = this->length(6,7);
382         edges[7]  = this->length(4,7);
383         edges[8]  = this->length(0,4);
384         edges[9]  = this->length(1,5);
385         edges[10] = this->length(2,6);
386         edges[11] = this->length(3,7);
387 
388         const Real min_edge = *(std::min_element(edges\&.begin(), edges\&.end()));
389         return sqrt3 * min_edge / max_diag ;
390       }
391 
392 
397     default:
398       {
399         return Elem::quality(q);
400       }
401     }
402 
403 
404   // Will never get here\&.\&.\&.
405   libmesh_error();
406   return 0\&.;
407 }
.fi
.SS "const \fBElem\fP * libMesh::Elem::reference_elem () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the 'reference element' associated with this element\&. The reference element is the image of this element in reference parametric space\&. Importantly, it is \fInot\fP an actual element in the mesh, but rather a Singleton-type object, so for example all \fC\fBQuad4\fP\fP elements share the same \fC\fBreference_elem()\fP\fP\&. 
.RE
.PP

.PP
Definition at line 393 of file elem\&.C\&.
.PP
References libMesh::ReferenceElem::get(), and libMesh::Elem::type()\&.
.PP
.nf
394 {
395   return &(ReferenceElem::get(this->type()));
396 }
.fi
.SS "void libMesh::Elem::refine (\fBMeshRefinement\fP &mesh_refinement)\fC [virtual]\fP, \fC [inherited]\fP"
Refine the element\&.
.PP
The following functions only apply when AMR is enabled and thus are not present otherwise\&. 
.PP
Definition at line 41 of file elem_refinement\&.C\&.
.PP
References libMesh::Elem::_children, libMesh::Elem::active(), libMesh::MeshRefinement::add_elem(), libMesh::MeshRefinement::add_point(), libMesh::Elem::ancestor(), libMesh::Elem::build(), libMesh::Elem::child(), libMesh::Elem::embedding_matrix(), libMesh::Elem::get_node(), libMesh::Elem::hmin(), libMesh::Elem::INACTIVE, libMesh::Elem::JUST_REFINED, libMesh::libmesh_assert(), libMesh::Elem::n_children(), libMesh::Elem::n_nodes(), libMesh::DofObject::n_systems(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::Elem::point(), libMesh::DofObject::processor_id(), libMesh::Real, libMesh::Elem::REFINE, libMesh::Elem::refinement_flag(), libMesh::DofObject::set_n_systems(), libMesh::Elem::set_node(), libMesh::Elem::set_p_level(), libMesh::Elem::set_p_refinement_flag(), libMesh::Elem::set_refinement_flag(), libMesh::Elem::subactive(), libMesh::TOLERANCE, and libMesh::Elem::type()\&.
.PP
.nf
42 {
43   libmesh_assert_equal_to (this->refinement_flag(), Elem::REFINE);
44   libmesh_assert (this->active());
45 
46   // Create my children if necessary
47   if (!_children)
48     {
49       _children = new Elem*[this->n_children()];
50 
51       unsigned int parent_p_level = this->p_level();
52       for (unsigned int c=0; c<this->n_children(); c++)
53         {
54           _children[c] = Elem::build(this->type(), this)\&.release();
55           _children[c]->set_refinement_flag(Elem::JUST_REFINED);
56           _children[c]->set_p_level(parent_p_level);
57           _children[c]->set_p_refinement_flag(this->p_refinement_flag());
58         }
59 
60       // Compute new nodal locations
61       // and asssign nodes to children
62       // Make these static\&.  It is unlikely the
63       // sizes will change from call to call, so having these
64       // static should save on reallocations
65       std::vector<std::vector<Point> >        p    (this->n_children());
66       std::vector<std::vector<Node*> >        nodes(this->n_children());
67 
68 
69       // compute new nodal locations
70       for (unsigned int c=0; c<this->n_children(); c++)
71         {
72           Elem *current_child = this->child(c);
73           p[c]\&.resize    (current_child->n_nodes());
74           nodes[c]\&.resize(current_child->n_nodes());
75 
76           for (unsigned int nc=0; nc<current_child->n_nodes(); nc++)
77             {
78               // zero entries
79               p[c][nc]\&.zero();
80               nodes[c][nc] = NULL;
81 
82               for (unsigned int n=0; n<this->n_nodes(); n++)
83                 {
84                   // The value from the embedding matrix
85                   const float em_val = this->embedding_matrix(c,nc,n);
86 
87                   if (em_val != 0\&.)
88                     {
89                       p[c][nc]\&.add_scaled (this->point(n), em_val);
90 
91                       // We may have found the node, in which case we
92                       // won't need to look it up later\&.
93                       if (em_val == 1\&.)
94                         nodes[c][nc] = this->get_node(n);
95                     }
96                 }
97             }
98 
99           // assign nodes to children & add them to the mesh
100           const Real pointtol = this->hmin() * TOLERANCE;
101           for (unsigned int nc=0; nc<current_child->n_nodes(); nc++)
102             {
103               if (nodes[c][nc] != NULL)
104                 {
105                   current_child->set_node(nc) = nodes[c][nc];
106                 }
107               else
108                 {
109                   current_child->set_node(nc) =
110                     mesh_refinement\&.add_point(p[c][nc],
111                                               current_child->processor_id(),
112                                               pointtol);
113                   current_child->get_node(nc)->set_n_systems
114                     (this->n_systems());
115                 }
116             }
117 
118           mesh_refinement\&.add_elem (current_child);
119           current_child->set_n_systems(this->n_systems());
120         }
121     }
122   else
123     {
124       unsigned int parent_p_level = this->p_level();
125       for (unsigned int c=0; c<this->n_children(); c++)
126         {
127           Elem *current_child = this->child(c);
128           libmesh_assert(current_child->subactive());
129           current_child->set_refinement_flag(Elem::JUST_REFINED);
130           current_child->set_p_level(parent_p_level);
131           current_child->set_p_refinement_flag(this->p_refinement_flag());
132         }
133     }
134 
135   // Un-set my refinement flag now
136   this->set_refinement_flag(Elem::INACTIVE);
137   this->set_p_refinement_flag(Elem::INACTIVE);
138 
139   for (unsigned int c=0; c<this->n_children(); c++)
140     {
141       libmesh_assert_equal_to (this->child(c)->parent(), this);
142       libmesh_assert(this->child(c)->active());
143     }
144   libmesh_assert (this->ancestor());
145 }
.fi
.SS "\fBElem::RefinementState\fP libMesh::Elem::refinement_flag () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the value of the refinement flag for the element\&. 
.PP
Definition at line 1837 of file elem\&.h\&.
.PP
References libMesh::Elem::_rflag\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::Elem::active(), libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::coarsen(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Elem::contract(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::Elem::get_info(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::Elem::make_links_to_me_local(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::DofMap::old_dof_indices(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::Elem::refine(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::DofMap::reinit(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshRefinement::test_unflagged(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1838 {
1839   return static_cast<RefinementState>(_rflag);
1840 }
.fi
.SS "void libMesh::Elem::replace_child (\fBElem\fP *elem, unsigned intc)\fC [inherited]\fP"
Replaces the child pointer at the specified index in the array of children of this element\&. 
.PP
Definition at line 1423 of file elem\&.C\&.
.PP
References libMesh::Elem::child(), libMesh::Elem::has_children(), libMesh::libmesh_assert(), and libMesh::Elem::set_child()\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order()\&.
.PP
.nf
1424 {
1425   libmesh_assert(this->has_children());
1426 
1427   libmesh_assert(this->child(c));
1428 
1429   this->set_child(c, elem);
1430 }
.fi
.SS "unsigned short int libMesh::Hex27::second_order_adjacent_vertex (const unsigned intn, const unsigned intv) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the element-local number of the $ v^{th} $ vertex that defines the $ n^{th} $ second-order node\&. Note that \fCn\fP is counted as depicted above, $ 8 \le n < 27 $\&. 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 653 of file cell_hex27\&.C\&.
.PP
References _remaining_second_order_adjacent_vertices, libMesh::Hex::_second_order_adjacent_vertices, n_nodes(), and libMesh::Hex::n_vertices()\&.
.PP
.nf
655 {
656   libmesh_assert_greater_equal (n, this->n_vertices());
657   libmesh_assert_less (n, this->n_nodes());
658 
659   switch (n)
660     {
661       /*
662        * these are all nodes that are unique to Hex27,
663        * use our _remaining\&.\&.\&.\&. matrix
664        */
665     case 20:
666     case 21:
667     case 22:
668     case 23:
669     case 24:
670     case 25:
671       {
672         libmesh_assert_less (v, 4);
673         return _remaining_second_order_adjacent_vertices[n-20][v];
674       }
675 
676       /*
677        * for the bubble node the return value is simply v\&.
678        * Why? -- the user asks for the v-th adjacent vertex,
679        * from \p n_second_order_adjacent_vertices() there
680        * are 8 adjacent vertices, and these happen to be
681        * 0\&.\&.7
682        */
683     case 26:
684       {
685         libmesh_assert_less (v, 8);
686         return static_cast<unsigned short int>(v);
687       }
688 
689       /*
690        * nodes 8\&.\&.19:
691        * these are all nodes that are identical for
692        * Hex20 and Hex27\&.  Therefore use the
693        * matrix stored in cell_hex\&.C
694        */
695     default:
696       {
697         libmesh_assert_less (v, 2);
698         return _second_order_adjacent_vertices[n-this->n_vertices()][v];
699       }
700     }
701 }
.fi
.SS "std::pair< unsigned short int, unsigned short int > libMesh::Hex27::second_order_child_vertex (const unsigned intn) const\fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
the child number \fCc\fP and element-local index \fCv\fP of the $ n^{th} $ second-order node on the parent element\&. Note that the return values are always less \fCthis->\fBn_children()\fP\fP and \fCthis->child(c)->\fBn_vertices()\fP\fP, while \fCn\fP has to be greater or equal to \fC*\fP this->\fBn_vertices()\fP\&. For linear elements this returns 0,0\&. On refined second order elements, the return value will satisfy \fCthis->get_node(n)==this->child(c)->get_node(v)\fP 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::Elem\fP\&.
.PP
Definition at line 718 of file cell_hex27\&.C\&.
.PP
References libMesh::Hex::_second_order_vertex_child_index, libMesh::Hex::_second_order_vertex_child_number, n_nodes(), and libMesh::Hex::n_vertices()\&.
.PP
.nf
719 {
720   libmesh_assert_greater_equal (n, this->n_vertices());
721   libmesh_assert_less (n, this->n_nodes());
722   /*
723    * the _second_order_vertex_child_* vectors are
724    * stored in cell_hex\&.C, since they are identical
725    * for Hex20 and Hex27 (for the first 12 higher-order nodes)
726    */
727   return std::pair<unsigned short int, unsigned short int>
728     (_second_order_vertex_child_number[n],
729      _second_order_vertex_child_index[n]);
730 }
.fi
.SS "\fBElemType\fP libMesh::Elem::second_order_equivalent_type (const \fBElemType\fPet, const boolfull_ordered = \fCtrue\fP)\fC [static]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the element type of the associated second-order element, e\&.g\&. when \fCthis\fP is a \fCTET4\fP, then \fCTET10\fP is returned\&. Returns \fCINVALID_ELEM\fP for second order or other elements that should not or cannot be converted into higher order equivalents\&.
.RE
.PP
For some elements, there exist two second-order equivalents, e\&.g\&. for \fC\fBQuad4\fP\fP there is \fC\fBQuad8\fP\fP and \fC\fBQuad9\fP\fP\&. When the optional \fCfull_ordered\fP is \fCtrue\fP, then \fCQUAD9\fP is returned\&. When \fCfull_ordered\fP is \fCfalse\fP, then \fCQUAD8\fP is returned\&. 
.PP
Definition at line 2078 of file elem\&.C\&.
.PP
References libMesh::EDGE2, libMesh::EDGE3, libMesh::HEX20, libMesh::HEX27, libMesh::HEX8, libMesh::INFEDGE2, libMesh::INFHEX16, libMesh::INFHEX18, libMesh::INFHEX8, libMesh::INFPRISM12, libMesh::INFPRISM6, libMesh::INFQUAD4, libMesh::INFQUAD6, libMesh::INVALID_ELEM, libMesh::PRISM15, libMesh::PRISM18, libMesh::PRISM6, libMesh::PYRAMID13, libMesh::PYRAMID14, libMesh::PYRAMID5, libMesh::QUAD4, libMesh::QUAD8, libMesh::QUAD9, libMesh::TET10, libMesh::TET4, libMesh::TRI3, and libMesh::TRI6\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_second_order()\&.
.PP
.nf
2080 {
2081   /* for second-order elements, always return \p INVALID_ELEM
2082    * since second-order elements should not be converted
2083    * into something else\&.  Only linear elements should
2084    * return something sensible here
2085    */
2086   switch (et)
2087     {
2088     case EDGE2:
2089       {
2090         // full_ordered not relevant
2091         return EDGE3;
2092       }
2093 
2094     case TRI3:
2095       {
2096         // full_ordered not relevant
2097         return TRI6;
2098       }
2099 
2100     case QUAD4:
2101       {
2102         if (full_ordered)
2103           return QUAD9;
2104         else
2105           return QUAD8;
2106       }
2107 
2108     case TET4:
2109       {
2110         // full_ordered not relevant
2111         return TET10;
2112       }
2113 
2114     case HEX8:
2115       {
2116         // see below how this correlates with INFHEX8
2117         if (full_ordered)
2118           return HEX27;
2119         else
2120           return HEX20;
2121       }
2122 
2123     case PRISM6:
2124       {
2125         if (full_ordered)
2126           return PRISM18;
2127         else
2128           return PRISM15;
2129       }
2130 
2131     case PYRAMID5:
2132       {
2133         if (full_ordered)
2134           return PYRAMID14;
2135         else
2136           return PYRAMID13;
2137 
2138         return INVALID_ELEM;
2139       }
2140 
2141 
2142 
2143 #ifdef LIBMESH_ENABLE_INFINITE_ELEMENTS
2144 
2145       // infinite elements
2146     case INFEDGE2:
2147       {
2148         // libmesh_error();
2149         return INVALID_ELEM;
2150       }
2151 
2152     case INFQUAD4:
2153       {
2154         // full_ordered not relevant
2155         return INFQUAD6;
2156       }
2157 
2158     case INFHEX8:
2159       {
2160         /*
2161          * Note that this matches with \p Hex8:
2162          * For full-ordered, \p InfHex18 and \p Hex27
2163          * belong together, and for not full-ordered,
2164          * \p InfHex16 and \p Hex20 belong together\&.
2165          */
2166         if (full_ordered)
2167           return INFHEX18;
2168         else
2169           return INFHEX16;
2170       }
2171 
2172     case INFPRISM6:
2173       {
2174         // full_ordered not relevant
2175         return INFPRISM12;
2176       }
2177 
2178 #endif
2179 
2180 
2181     default:
2182       {
2183         // second-order element
2184         return INVALID_ELEM;
2185       }
2186     }
2187 }
.fi
.SS "void libMesh::DofObject::set_buffer (const std::vector< \fBdof_id_type\fP > &buf)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 491 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf\&.
.PP
.nf
492   { _idx_buf = buf; }
.fi
.SS "void libMesh::DofObject::set_dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp, const \fBdof_id_type\fPdn)\fC [inherited]\fP"
Sets the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 405 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::dof_number(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::start_idx(), libMesh::DofObject::system_var_to_vg_var(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
409 {
410   libmesh_assert_less (s,    this->n_systems());
411   libmesh_assert_less (var,  this->n_vars(s));
412   libmesh_assert_less (comp, this->n_comp(s,var));
413 
414   const unsigned int
415     vg            = this->var_to_vg(s,var),
416 #ifndef NDEBUG
417     ncg           = this->n_comp_group(s,vg),
418 #endif
419     vig           = this->system_var_to_vg_var(s,vg,var),
420     start_idx_sys = this->start_idx(s);
421 
422   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
423 
424   dof_id_type &base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
425 
426   // We intend to change all dof numbers together or not at all
427   if (comp || vig)
428     libmesh_assert ((dn == invalid_id && base_idx == invalid_id) ||
429                     (dn == base_idx + vig*ncg + comp));
430 
431   // only explicitly store the base index for vig==0, comp==0
432   else
433     base_idx = dn;
434 
435   // #ifdef DEBUG
436   //   libMesh::out << " [ ";
437   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
438   //     libMesh::out << _idx_buf[i] << " ";
439   //   libMesh::out << "]\n";
440   // #endif
441 
442   libmesh_assert_equal_to (this->dof_number(s, var, comp), dn);
443 }
.fi
.SS "\fBdof_id_type\fP & libMesh::DofObject::set_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 620 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::UNVIO::element_in(), libMesh::MeshTools::Modification::flatten(), libMesh::DofObject::invalidate_id(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::RemoteElem::RemoteElem(), libMesh::SerialMesh::renumber_elem(), libMesh::ParallelMesh::renumber_elem(), libMesh::SerialMesh::renumber_node(), libMesh::ParallelMesh::renumber_node(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::DofObject::set_id(), libMesh::SerialMesh::stitching_helper(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
621 {
622   return _id;
623 }
.fi
.SS "void libMesh::DofObject::set_id (const \fBdof_id_type\fPdofid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the \fCid\fP for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 161 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::set_id()\&.
.PP
.nf
162   { this->set_id() = dofid; }
.fi
.SS "void libMesh::Elem::set_interior_parent (\fBElem\fP *p)\fC [inline]\fP, \fC [inherited]\fP"
Sets the pointer to the element's interior_parent\&. Dangerous to use in high-level code\&. 
.PP
Definition at line 1733 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks, libMesh::Elem::dim(), libMesh::libmesh_assert(), and libMesh::Elem::n_sides()\&.
.PP
Referenced by libMesh::BoundaryInfo::sync()\&.
.PP
.nf
1734 {
1735   // interior parents make no sense for full-dimensional elements\&.
1736   libmesh_assert_less (this->dim(), LIBMESH_DIM);
1737 
1738   // this had better be a one-higher-dimensional interior element
1739   libmesh_assert (!p ||
1740                   p->dim() == (this->dim()+1));
1741 
1742   _elemlinks[1+this->n_sides()] = p;
1743 }
.fi
.SS "void libMesh::DofObject::set_n_comp (const unsigned ints, const unsigned intvar, const unsigned intncomp)\fC [inherited]\fP"
Sets the number of components for \fC\fBVariable\fP\fP \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 338 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::n_systems(), libMesh::DofObject::n_vars(), libMesh::DofObject::set_n_comp_group(), and libMesh::DofObject::var_to_vg()\&.
.PP
.nf
341 {
342   libmesh_assert_less (s,   this->n_systems());
343   libmesh_assert_less (var, this->n_vars(s));
344 
345   this->set_n_comp_group(s, this->var_to_vg(s,var), ncomp);
346 }
.fi
.SS "void libMesh::DofObject::set_n_comp_group (const unsigned ints, const unsigned intvg, const unsigned intncomp)\fC [inherited]\fP"
Sets the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 350 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::err, libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofObject::ncv_magic, and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::reinit(), libMesh::DofObject::set_n_comp(), libMesh::DofObject::set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
353 {
354   libmesh_assert_less (s,  this->n_systems());
355   libmesh_assert_less (vg, this->n_var_groups(s));
356 
357   // Check for trivial return
358   if (ncomp == this->n_comp_group(s,vg)) return;
359 
360 #ifndef NDEBUG
361   if (ncomp >= ncv_magic)
362     {
363       const index_t ncvm = ncv_magic;
364       libMesh::err << "ERROR: ncomp must be less than DofObject::ncv_magic!\n"
365                    << "ncomp = " << ncomp << ", ncv_magic = " << ncvm
366                    << "\nrecompile and try again!\n";
367       libmesh_error();
368     }
369 #endif
370 
371   const unsigned int
372     start_idx_sys = this->start_idx(s),
373     n_vars_group  = this->n_vars(s,vg),
374     base_offset   = start_idx_sys + 2*vg;
375 
376   libmesh_assert_less ((base_offset + 1), _idx_buf\&.size());
377 
378   // if (ncomp)
379   //   libMesh::out << "s,vg,ncomp="
380   //       << s  << ","
381   //       << vg << ","
382   //       << ncomp << '\n';
383 
384   // set the number of components, maintaining the number
385   // of variables in the group
386   _idx_buf[base_offset] = ncv_magic*n_vars_group + ncomp;
387 
388   // We use (invalid_id - 1) to signify no
389   // components for this object
390   _idx_buf[base_offset + 1] = (ncomp == 0) ? invalid_id - 1 : invalid_id;
391 
392   // this->debug_buffer();
393   // libMesh::out << "s,vg = " << s << "," << vg << '\n'
394   //     << "base_offset=" << base_offset << '\n'
395   //     << "this->n_comp(s,vg)=" << this->n_comp(s,vg) << '\n'
396   //     << "this->n_comp_group(s,vg)=" << this->n_comp_group(s,vg) << '\n'
397   //     << "this->n_vars(s,vg)=" << this->n_vars(s,vg) << '\n'
398   //     << "this->n_var_groups(s)=" << this->n_var_groups(s) << '\n';
399 
400   libmesh_assert_equal_to (ncomp, this->n_comp_group(s,vg));
401 }
.fi
.SS "void libMesh::DofObject::set_n_systems (const unsigned ints)\fC [inherited]\fP"
Sets the number of systems for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 157 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::clear_dofs(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::n_vars()\&.
.PP
Referenced by libMesh::DofObject::add_system(), and libMesh::Elem::refine()\&.
.PP
.nf
158 {
159   // Check for trivial return
160   if (ns == this->n_systems())
161     return;
162 
163   // Clear any existing data\&.  This is safe to call
164   // even if we don't have any data\&.
165   this->clear_dofs();
166 
167   // Set the new number of systems
168   _idx_buf\&.resize(ns, ns);
169   _idx_buf[0] = ns;
170 
171 
172 #ifdef DEBUG
173 
174   // check that all systems now exist and that they have 0 size
175   libmesh_assert_equal_to (ns, this->n_systems());
176   for (unsigned int s=0; s<this->n_systems(); s++)
177     {
178       libmesh_assert_equal_to (this->n_vars(s),       0);
179       libmesh_assert_equal_to (this->n_var_groups(s), 0);
180     }
181 
182 #endif
183 }
.fi
.SS "void libMesh::DofObject::set_n_vars_per_group (const unsigned ints, const std::vector< unsigned int > &nvpg)\fC [inherited]\fP"
Sets number of variables in each group associated with system \fCs\fP for this \fC\fBDofObject\fP\fP\&. Implicit in this is salso setting the number of \fC\fBVariableGroup\fP\fP variable groups for the system\&. Has the effect of setting the number of components to 0 even when called even with (nvg == this->n_var_groups(s))\&. 
.PP
Definition at line 219 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, end, libMesh::DofObject::end_idx(), libMesh::DofObject::invalid_id, libMesh::DofObject::n_comp(), libMesh::DofObject::n_comp_group(), libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::n_vars(), libMesh::DofObject::ncv_magic, libMesh::DofObject::set_n_comp_group(), and libMesh::DofObject::start_idx()\&.
.PP
.nf
221 {
222 
223   libmesh_assert_less (s, this->n_systems());
224 
225   // number of varaible groups for this system - inferred
226   const unsigned int nvg = libmesh_cast_int<unsigned int>(nvpg\&.size());
227 
228   // BSK - note that for compatibility with the previous implementation
229   // calling this method when (nvars == this->n_vars()) requires that
230   // we invalidate the DOF indices and set the number of components to 0\&.
231   // Note this was a bit of a suprise to me - there was no quick return in
232   // the old method, which caused removal and readdition of the DOF indices
233   // even in the case of (nvars == this->n_vars()), resulting in n_comp(s,v)
234   // implicitly becoming 0 regardless of any previous value\&.
235   // quick return?
236   if (nvg == this->n_var_groups(s))
237     {
238       for (unsigned int vg=0; vg<nvg; vg++)
239         {
240           this->set_n_comp_group(s,vg,0);
241           libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
242         }
243       return;
244     }
245 
246   // since there is ample opportunity to screw up other systems, let us
247   // cache their current sizes and later assert that they are unchanged\&.
248 #ifdef DEBUG
249   DofObject::index_buffer_t old_system_sizes;
250   old_system_sizes\&.reserve(this->n_systems());
251 
252   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
253     old_system_sizes\&.push_back(this->n_var_groups(s_ctr));
254 #endif
255 
256   // remove current indices if we have some
257   if (this->n_var_groups(s) != 0)
258     {
259       const unsigned int old_nvg_s = this->n_var_groups(s);
260 
261       DofObject::index_buffer_t::iterator
262         it  = _idx_buf\&.begin(),
263         end = _idx_buf\&.begin();
264 
265       std::advance(it,  this->start_idx(s));
266       std::advance(end, this->end_idx(s));
267       _idx_buf\&.erase(it,end);
268 
269       for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
270         _idx_buf[ctr] -= 2*old_nvg_s;
271     }
272 
273   // better not have any now!
274   libmesh_assert_equal_to (this->n_var_groups(s), 0);
275 
276   // had better not screwed up any of our sizes!
277 #ifdef DEBUG
278   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
279     if (s_ctr != s)
280       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
281 #endif
282 
283   // OK, if the user requested 0 that is what we have
284   if (nvg == 0)
285     return;
286 
287   {
288     // array to hold new indices
289     DofObject::index_buffer_t var_idxs(2*nvg);
290     for (unsigned int vg=0; vg<nvg; vg++)
291       {
292         var_idxs[2*vg    ] = ncv_magic*nvpg[vg] + 0;
293         var_idxs[2*vg + 1] = invalid_id - 1;
294       }
295 
296     DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
297     std::advance(it, this->end_idx(s));
298     _idx_buf\&.insert(it, var_idxs\&.begin(), var_idxs\&.end());
299 
300     for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
301       _idx_buf[ctr] += 2*nvg;
302 
303     // resize _idx_buf to fit so no memory is wasted\&.
304     DofObject::index_buffer_t(_idx_buf)\&.swap(_idx_buf);
305   }
306 
307   // that better had worked\&.  Assert stuff\&.
308   libmesh_assert_equal_to (nvg, this->n_var_groups(s));
309 
310 #ifdef DEBUG
311 
312   // libMesh::out << " [ ";
313   // for (unsigned int i=0; i<_idx_buf\&.size(); i++)
314   //   libMesh::out << _idx_buf[i] << " ";
315   // libMesh::out << "]\n";
316 
317   libmesh_assert_equal_to (this->n_var_groups(s), nvpg\&.size());
318 
319   for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
320     {
321       libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
322       libmesh_assert_equal_to (this->n_comp_group(s,vg), 0);
323     }
324 
325   for (unsigned int v=0; v<this->n_vars(s); v++)
326     libmesh_assert_equal_to (this->n_comp(s,v), 0);
327 
328   // again, all other system sizes shoudl be unchanged!
329   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
330     if (s_ctr != s)
331       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
332 
333 #endif
334 }
.fi
.SS "void libMesh::Elem::set_neighbor (const unsigned inti, \fBElem\fP *n)\fC [inline]\fP, \fC [inherited]\fP"
Assigns \fCn\fP as the $ i^{th} $ neighbor\&. 
.PP
Definition at line 1447 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks, and libMesh::Elem::n_neighbors()\&.
.PP
Referenced by libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::Elem::nullify_neighbors(), libMesh::SerialMesh::stitching_helper(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1448 {
1449   libmesh_assert_less (i, this->n_neighbors());
1450 
1451   _elemlinks[i+1] = n;
1452 }
.fi
.SS "\fBNode\fP *& libMesh::Elem::set_node (const unsigned inti)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the pointer to local \fC\fBNode\fP\fP \fCi\fP as a writeable reference\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::RemoteElem\fP\&.
.PP
Definition at line 1411 of file elem\&.h\&.
.PP
References libMesh::Elem::_nodes, and libMesh::Elem::n_nodes()\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::TetGenMeshInterface::assign_nodes_to_elem(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::Edge::build_side(), libMesh::TriangleWrapper::copy_tri_to_mesh(), libMesh::UnstructuredMesh::create_submesh(), libMesh::UNVIO::element_in(), libMesh::MeshTools::Modification::flatten(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::Elem::refine(), libMesh::RemoteElem::set_node(), libMesh::Tet::side(), libMesh::Prism::side(), libMesh::Pyramid::side(), libMesh::Hex::side(), libMesh::Tri::side(), libMesh::InfHex::side(), libMesh::InfPrism::side(), libMesh::Quad::side(), libMesh::InfQuad::side(), libMesh::Edge::side(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1412 {
1413   libmesh_assert_less (i, this->n_nodes());
1414 
1415   return _nodes[i];
1416 }
.fi
.SS "void libMesh::DofObject::set_old_dof_object ()\fC [inherited]\fP"
Sets the \fCold_dof_object\fP to a copy of \fCthis\fP 
.PP
Definition at line 142 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::clear_old_dof_object(), libMesh::DofObject::DofObject(), libMesh::libmesh_assert(), and libMesh::DofObject::old_dof_object\&.
.PP
Referenced by libMesh::DofMap::reinit()\&.
.PP
.nf
143 {
144   this->clear_old_dof_object();
145 
146   libmesh_assert (!this->old_dof_object);
147 
148   // Make a new DofObject, assign a copy of \p this\&.
149   // Make sure the copy ctor for DofObject works!!
150   this->old_dof_object = new DofObject(*this);
151 }
.fi
.SS "void libMesh::Elem::set_p_level (const unsigned intp)\fC [inline]\fP, \fC [inherited]\fP"
Sets the value of the p refinement level for the element Note that the maximum p refinement level is currently 255 
.PP
Definition at line 1887 of file elem\&.h\&.
.PP
References libMesh::Elem::_p_level, libMesh::Elem::child(), std::min(), libMesh::Elem::n_children(), libMesh::Elem::p_level(), libMesh::Elem::parent(), and libMesh::Elem::set_p_level()\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::coarsen(), libMesh::Elem::Elem(), libMesh::Elem::refine(), libMesh::DofMap::reinit(), libMesh::Elem::set_p_level(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1888 {
1889   // Maintain the parent's p level as the minimum of it's children
1890   if (this->parent() != NULL)
1891     {
1892       unsigned int parent_p_level = this->parent()->p_level();
1893 
1894       // If our new p level is less than our parents, our parents drops
1895       if (parent_p_level > p)
1896         {
1897           this->parent()->set_p_level(p);
1898         }
1899       // If we are the lowest p level and it increases, so might
1900       // our parent's, but we have to check every other child to see
1901       else if (parent_p_level == _p_level && _p_level < p)
1902         {
1903           _p_level = libmesh_cast_int<unsigned char>(p);
1904           parent_p_level = libmesh_cast_int<unsigned char>(p);
1905           for (unsigned int c=0; c != this->parent()->n_children(); c++)
1906             parent_p_level = std::min(parent_p_level,
1907                                       this->parent()->child(c)->p_level());
1908 
1909           if (parent_p_level != this->parent()->p_level())
1910             this->parent()->set_p_level(parent_p_level);
1911 
1912           return;
1913         }
1914     }
1915 
1916   _p_level = libmesh_cast_int<unsigned char>(p);
1917 }
.fi
.SS "void libMesh::Elem::set_p_refinement_flag (const \fBRefinementState\fPpflag)\fC [inline]\fP, \fC [inherited]\fP"
Sets the value of the p refinement flag for the element\&. 
.PP
Definition at line 1861 of file elem\&.h\&.
.PP
References libMesh::Elem::_pflag\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshRefinement::_refine_elements(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshRefinement::coarsen_elements(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::Elem::refine(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1862 {
1863   _pflag = libmesh_cast_int<unsigned char>(pflag);
1864 }
.fi
.SS "void libMesh::Elem::set_parent (\fBElem\fP *p)\fC [inline]\fP, \fC [inherited]\fP"
Sets the pointer to the element's parent\&. Dangerous to use in high-level code\&. 
.PP
Definition at line 1683 of file elem\&.h\&.
.PP
References libMesh::Elem::_elemlinks\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
1684 {
1685   _elemlinks[0] = p;
1686 }
.fi
.SS "void libMesh::Elem::set_refinement_flag (const \fBRefinementState\fPrflag)\fC [inline]\fP, \fC [inherited]\fP"
Sets the value of the refinement flag for the element\&. 
.PP
Definition at line 1845 of file elem\&.h\&.
.PP
References libMesh::Elem::_rflag\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::Elem::coarsen(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Elem::contract(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::CheckpointIO::read_connectivity(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::Elem::refine(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::HPSingularity::select_refinement(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1846 {
1847   _rflag = libmesh_cast_int<RefinementState>(rflag);
1848 }
.fi
.SS "\fBunique_id_type\fP & libMesh::DofObject::set_unique_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 641 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::CheckpointIO::read_connectivity(), libMesh::CheckpointIO::read_nodes(), libMesh::XdrIO::read_serialized_connectivity(), and libMesh::Parallel::unpack()\&.
.PP
.nf
642 {
643 #ifdef LIBMESH_ENABLE_UNIQUE_ID
644   return _unique_id;
645 #else
646   libmesh_error();
647 #endif
648 }
.fi
.SS "void libMesh::DofObject::set_vg_dof_base (const unsigned ints, const unsigned intvg, const \fBdof_id_type\fPdb)\fC [inline]\fP, \fC [inherited]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 881 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), libMesh::DofObject::start_idx(), and libMesh::DofObject::vg_dof_base()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::invalidate_dofs(), libMesh::DofMap::reinit(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
884 {
885   libmesh_assert_less (s,  this->n_systems());
886   libmesh_assert_less (vg, this->n_var_groups(s));
887 
888   const unsigned int
889     start_idx_sys = this->start_idx(s);
890 
891   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
892 
893   _idx_buf[start_idx_sys + 2*vg + 1] = db;
894 
895   libmesh_assert_equal_to (this->vg_dof_base(s,vg), db);
896 }
.fi
.SS "\fBAutoPtr\fP< \fBElem\fP > libMesh::Hex::side (const unsigned inti) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a primitive (4-noded) quad for face i\&. 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 98 of file cell_hex\&.C\&.
.PP
References libMesh::Elem::get_node(), libMesh::Hex::n_sides(), and libMesh::Elem::set_node()\&.
.PP
.nf
99 {
100   libmesh_assert_less (i, this->n_sides());
101 
102 
103 
104   Elem* face = new Quad4;
105 
106   // Think of a unit cube: (-1,1) x (-1,1)x (-1,1)
107   switch (i)
108     {
109     case 0:  // the face at z = -1
110       {
111         face->set_node(0) = this->get_node(0);
112         face->set_node(1) = this->get_node(3);
113         face->set_node(2) = this->get_node(2);
114         face->set_node(3) = this->get_node(1);
115 
116         AutoPtr<Elem> ap(face);
117         return ap;
118       }
119     case 1:  // the face at y = -1
120       {
121         face->set_node(0) = this->get_node(0);
122         face->set_node(1) = this->get_node(1);
123         face->set_node(2) = this->get_node(5);
124         face->set_node(3) = this->get_node(4);
125 
126         AutoPtr<Elem> ap(face);
127         return ap;
128       }
129     case 2:  // the face at x = 1
130       {
131         face->set_node(0) = this->get_node(1);
132         face->set_node(1) = this->get_node(2);
133         face->set_node(2) = this->get_node(6);
134         face->set_node(3) = this->get_node(5);
135 
136         AutoPtr<Elem> ap(face);
137         return ap;
138       }
139     case 3: // the face at y = 1
140       {
141         face->set_node(0) = this->get_node(2);
142         face->set_node(1) = this->get_node(3);
143         face->set_node(2) = this->get_node(7);
144         face->set_node(3) = this->get_node(6);
145 
146         AutoPtr<Elem> ap(face);
147         return ap;
148       }
149     case 4: // the face at x = -1
150       {
151         face->set_node(0) = this->get_node(3);
152         face->set_node(1) = this->get_node(0);
153         face->set_node(2) = this->get_node(4);
154         face->set_node(3) = this->get_node(7);
155 
156         AutoPtr<Elem> ap(face);
157         return ap;
158       }
159     case 5: // the face at z = 1
160       {
161         face->set_node(0) = this->get_node(4);
162         face->set_node(1) = this->get_node(5);
163         face->set_node(2) = this->get_node(6);
164         face->set_node(3) = this->get_node(7);
165 
166         AutoPtr<Elem> ap(face);
167         return ap;
168       }
169     default:
170       {
171         libmesh_error();
172         AutoPtr<Elem> ap(face);
173         return ap;
174       }
175     }
176 
177   // We'll never get here\&.
178   libmesh_error();
179   AutoPtr<Elem> ap(face);
180   return ap;
181 }
.fi
.SS "bool libMesh::Elem::subactive () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the element is subactive (i\&.e\&. has no active descendants), \fCfalse\fP otherwise\&. Always returns \fCfalse\fP if AMR is disabled\&. 
.RE
.PP

.PP
Definition at line 1596 of file elem\&.h\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::has_children(), and libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::Elem::active_family_tree(), libMesh::Elem::active_family_tree_by_neighbor(), libMesh::Elem::active_family_tree_by_side(), libMesh::HPCoarsenTest::add_projection(), libMesh::FEAbstract::compute_node_constraints(), libMesh::UnstructuredMesh::contract(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::Elem::family_tree(), libMesh::Elem::family_tree_by_neighbor(), libMesh::Elem::family_tree_by_side(), libMesh::Elem::family_tree_by_subneighbor(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::Elem::get_info(), libMesh::MeshTools::get_not_subactive_node_ids(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::Elem::make_links_to_me_local(), libMesh::Elem::make_links_to_me_remote(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::min_new_p_level_by_neighbor(), libMesh::Elem::min_p_level_by_neighbor(), libMesh::Elem::refine(), libMesh::Elem::PackedElem::unpack(), and libMesh::LegacyXdrIO::write_mesh()\&.
.PP
.nf
1597 {
1598 #ifdef LIBMESH_ENABLE_AMR
1599   if (this->active())
1600     return false;
1601   if (!this->has_children())
1602     return true;
1603   for (const Elem* my_ancestor = this->parent();
1604        my_ancestor != NULL;
1605        my_ancestor = my_ancestor->parent())
1606     if (my_ancestor->active())
1607       return true;
1608 #endif
1609 
1610   return false;
1611 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::Elem::subdomain_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the subdomain that this element belongs to\&. 
.RE
.PP

.PP
Definition at line 1421 of file elem\&.h\&.
.PP
References libMesh::Elem::_sbd_id\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::AbaqusIO::assign_subdomain_ids(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::Prism6::build_side(), libMesh::InfQuad4::build_side(), libMesh::Quad4::build_side(), libMesh::Pyramid5::build_side(), libMesh::InfQuad6::build_side(), libMesh::Tri3::build_side(), libMesh::InfHex8::build_side(), libMesh::Hex8::build_side(), libMesh::InfPrism6::build_side(), libMesh::InfPrism12::build_side(), libMesh::Quad9::build_side(), libMesh::Quad8::build_side(), libMesh::Tri6::build_side(), libMesh::Tet4::build_side(), libMesh::Tet10::build_side(), libMesh::InfHex16::build_side(), libMesh::InfHex18::build_side(), libMesh::Hex20::build_side(), libMesh::Pyramid13::build_side(), libMesh::Prism15::build_side(), libMesh::Pyramid14::build_side(), build_side(), libMesh::Prism18::build_side(), libMesh::VTKIO::cells_to_vtk(), libMesh::MeshTools::Modification::change_subdomain_id(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::Elem::Elem(), libMesh::MeshTools::Modification::flatten(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::DofMap::old_dof_indices(), libMesh::ProjectSolution::operator()(), libMesh::ProjectFEMSolution::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::GmshIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::DofMap::reinit(), libMesh::MeshTools::subdomain_bounding_box(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::CheckpointIO::write_connectivity(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), and libMesh::GmshIO::write_mesh()\&.
.PP
.nf
1422 {
1423   return _sbd_id;
1424 }
.fi
.SS "\fBsubdomain_id_type\fP & libMesh::Elem::subdomain_id ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the subdomain that this element belongs to as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 1429 of file elem\&.h\&.
.PP
References libMesh::Elem::_sbd_id\&.
.PP
.nf
1430 {
1431   return _sbd_id;
1432 }
.fi
.SS "const \fBElem\fP * libMesh::Elem::top_parent () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the element's top-most (i\&.e\&. level-0) parent\&. Returns \fCthis\fP if this is a level-0 element, this element's parent if this is a level-1 element, this element's grandparent if this is a level-2 element, etc\&.\&.\&. 
.RE
.PP

.PP
Definition at line 1691 of file elem\&.h\&.
.PP
References libMesh::Elem::level(), libMesh::libmesh_assert(), and libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::BoundaryInfo::side_with_boundary_id(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
1692 {
1693   const Elem* tp = this;
1694 
1695   // Keep getting the element's parent
1696   // until that parent is at level-0
1697   while (tp->parent() != NULL)
1698     tp = tp->parent();
1699 
1700   libmesh_assert(tp);
1701   libmesh_assert_equal_to (tp->level(), 0);
1702 
1703   return tp;
1704 }
.fi
.SS "const \fBElem\fP * libMesh::Elem::topological_neighbor (const unsigned inti, const \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP &point_locator, const \fBPeriodicBoundaries\fP *pb) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a pointer to the $ i^{th} $ neighbor of this element for interior elements\&. If an element is on a periodic boundary, it will return a corresponding element on the opposite side\&. 
.RE
.PP

.PP
Definition at line 903 of file elem\&.C\&.
.PP
References libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::MeshBase::elem(), libMesh::DofObject::id(), libMesh::Elem::level(), libMesh::Elem::n_neighbors(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), and libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::Elem::has_topological_neighbor(), and libMesh::MeshRefinement::topological_neighbor()\&.
.PP
.nf
907 {
908   libmesh_assert_less (i, this->n_neighbors());
909 
910   const Elem * neighbor_i = this->neighbor(i);
911   if (neighbor_i != NULL)
912     return neighbor_i;
913 
914   if (pb)
915     {
916       // Since the neighbor is NULL it must be on a boundary\&. We need
917       // see if this is a periodic boundary in which case it will have a
918       // topological neighbor
919 
920       std::vector<boundary_id_type> boundary_ids = mesh\&.boundary_info->boundary_ids(this, i);
921       for (std::vector<boundary_id_type>::iterator j = boundary_ids\&.begin(); j != boundary_ids\&.end(); ++j)
922         if (pb->boundary(*j))
923           {
924             // Since the point locator inside of periodic boundaries
925             // returns a const pointer we will retrieve the proper
926             // pointer directly from the mesh object\&.  Also since coarse
927             // elements do not have more refined neighbors we need to make
928             // sure that we don't return one of these types of neighbors\&.
929             neighbor_i = mesh\&.elem(pb->neighbor(*j, point_locator, this, i)->id());
930             if (level() < neighbor_i->level())
931               neighbor_i = neighbor_i->parent();
932             return neighbor_i;
933           }
934     }
935 
936   return NULL;
937 }
.fi
.SS "\fBElem\fP * libMesh::Elem::topological_neighbor (const unsigned inti, \fBMeshBase\fP &mesh, const \fBPointLocatorBase\fP &point_locator, const \fBPeriodicBoundaries\fP *pb)\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a writeable pointer to the $ i^{th} $ neighbor of this element for interior elements\&. If an element is on a periodic boundary, it will return a corresponding element on the opposite side\&. 
.RE
.PP

.PP
Definition at line 865 of file elem\&.C\&.
.PP
References libMesh::PeriodicBoundaries::boundary(), libMesh::MeshBase::boundary_info, libMesh::MeshBase::elem(), libMesh::DofObject::id(), libMesh::Elem::level(), libMesh::Elem::n_neighbors(), libMesh::PeriodicBoundaries::neighbor(), libMesh::Elem::neighbor(), and libMesh::Elem::parent()\&.
.PP
.nf
869 {
870   libmesh_assert_less (i, this->n_neighbors());
871 
872   Elem * neighbor_i = this->neighbor(i);
873   if (neighbor_i != NULL)
874     return neighbor_i;
875 
876   if (pb)
877     {
878       // Since the neighbor is NULL it must be on a boundary\&. We need
879       // see if this is a periodic boundary in which case it will have a
880       // topological neighbor
881 
882       std::vector<boundary_id_type> boundary_ids = mesh\&.boundary_info->boundary_ids(this, i);
883       for (std::vector<boundary_id_type>::iterator j = boundary_ids\&.begin(); j != boundary_ids\&.end(); ++j)
884         if (pb->boundary(*j))
885           {
886             // Since the point locator inside of periodic boundaries
887             // returns a const pointer we will retrieve the proper
888             // pointer directly from the mesh object\&.  Also since coarse
889             // elements do not have more refined neighbors we need to make
890             // sure that we don't return one of these types of neighbors\&.
891             neighbor_i = mesh\&.elem(pb->neighbor(*j, point_locator, this, i)->id());
892             if (level() < neighbor_i->level())
893               neighbor_i = neighbor_i->parent();
894             return neighbor_i;
895           }
896     }
897 
898   return NULL;
899 }
.fi
.SS "void libMesh::Elem::total_family_tree (std::vector< const \fBElem\fP * > &active_family, const boolreset = \fCtrue\fP) const\fC [inherited]\fP"
Same as the \fC\fBfamily_tree()\fP\fP member, but also adds any subactive descendants\&. 
.PP
Definition at line 1473 of file elem\&.C\&.
.PP
References libMesh::Elem::child(), libMesh::Elem::has_children(), libMesh::Elem::is_remote(), libMesh::Elem::n_children(), and libMesh::Elem::total_family_tree()\&.
.PP
Referenced by libMesh::Partitioner::set_parent_processor_ids(), and libMesh::Elem::total_family_tree()\&.
.PP
.nf
1475 {
1476   // Clear the vector if the flag reset tells us to\&.
1477   if (reset)
1478     family\&.clear();
1479 
1480   // Add this element to the family tree\&.
1481   family\&.push_back(this);
1482 
1483   // Recurse into the elements children, if it has them\&.
1484   // Do not clear the vector any more\&.
1485   if (this->has_children())
1486     for (unsigned int c=0; c<this->n_children(); c++)
1487       if (!this->child(c)->is_remote())
1488         this->child(c)->total_family_tree (family, false);
1489 }
.fi
.SS "\fBElemType\fP libMesh::Hex27::type () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCHEX27\fP 
.RE
.PP

.PP
Implements \fBlibMesh::Elem\fP\&.
.PP
Definition at line 84 of file cell_hex27\&.h\&.
.PP
References libMesh::HEX27\&.
.PP
.nf
84 { return HEX27; }
.fi
.SS "\fBunique_id_type\fP libMesh::DofObject::unique_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 628 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id, libMesh::DofObject::invalid_unique_id, libMesh::libmesh_assert(), and libMesh::DofObject::valid_unique_id()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::XdrIO::pack_element(), libMesh::CheckpointIO::write_connectivity(), and libMesh::CheckpointIO::write_nodes()\&.
.PP
.nf
629 {
630 #ifdef LIBMESH_ENABLE_UNIQUE_ID
631   libmesh_assert (this->valid_unique_id());
632   return _unique_id;
633 #else
634   return invalid_unique_id;
635 #endif
636 }
.fi
.SS "void libMesh::DofObject::unpack_indexing (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)\fC [inherited]\fP"
A method for creating our index buffer from packed data - basically with our current implementation we investigate the size term and then copy\&. 
.PP
Definition at line 485 of file dof_object\&.C\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::clear_old_dof_object(), libMesh::DofObject::DofObject(), libMesh::libmesh_assert(), libMesh::DofObject::old_dof_object, and libMesh::DofObject::unpack_indexing()\&.
.PP
Referenced by libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and libMesh::DofObject::unpack_indexing()\&.
.PP
.nf
486 {
487   _idx_buf\&.clear();
488 
489 #ifdef LIBMESH_ENABLE_AMR
490   this->clear_old_dof_object();
491   const int has_old_dof_object = *begin++;
492   libmesh_assert(has_old_dof_object == 1 ||
493                  has_old_dof_object == 0);
494 #endif
495 
496   const int size = *begin++;
497   _idx_buf\&.reserve(size);
498   std::copy(begin, begin+size, back_inserter(_idx_buf));
499 
500   // Check as best we can for internal consistency now
501   libmesh_assert(_idx_buf\&.empty() ||
502                  (_idx_buf[0] <= _idx_buf\&.size()));
503 #ifdef DEBUG
504   if (!_idx_buf\&.empty())
505     for (unsigned int i=1; i < _idx_buf[0]; ++i)
506       {
507         libmesh_assert_greater_equal (_idx_buf[i], _idx_buf[i-1]);
508         libmesh_assert_equal_to ((_idx_buf[i] - _idx_buf[i-1])%2, 0);
509         libmesh_assert_less_equal (_idx_buf[i], _idx_buf\&.size());
510       }
511 #endif
512 
513 #ifdef LIBMESH_ENABLE_AMR
514   if (has_old_dof_object)
515     {
516       this->old_dof_object = new DofObject();
517       this->old_dof_object->unpack_indexing(begin+size);
518     }
519 #endif
520 }
.fi
.SS "unsigned int libMesh::DofObject::unpackable_indexing_size (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)\fC [static]\fP, \fC [inherited]\fP"
If we have indices packed into an buffer for communications, how much of that buffer applies to this dof object? 
.PP
Definition at line 463 of file dof_object\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packed_size(), libMesh::Elem::PackedElem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
464 {
465 #ifdef LIBMESH_ENABLE_AMR
466   const int has_old_dof_object = *begin++;
467 
468   // Either we have an old_dof_object or we don't
469   libmesh_assert(has_old_dof_object == 1 || has_old_dof_object == 0);
470   static const int dof_header_size = 2;
471 #else
472   static const bool has_old_dof_object = false;
473   static const int dof_header_size = 1;
474 #endif
475 
476   const int this_indexing_size = *begin++;
477 
478   return dof_header_size + this_indexing_size +
479     (has_old_dof_object ?
480      unpackable_indexing_size(begin+this_indexing_size) : 0);
481 }
.fi
.SS "bool libMesh::DofObject::valid_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 653 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_id, and libMesh::DofObject::invalid_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofObject::id(), and libMesh::Elem::libmesh_assert_valid_node_pointers()\&.
.PP
.nf
654 {
655   return (DofObject::invalid_id != _id);
656 }
.fi
.SS "bool libMesh::DofObject::valid_processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 697 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_processor_id, and libMesh::DofObject::invalid_processor_id\&.
.PP
.nf
698 {
699   return (DofObject::invalid_processor_id != _processor_id);
700 }
.fi
.SS "bool libMesh::DofObject::valid_unique_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCunique_id\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 661 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_unique_id, and libMesh::DofObject::invalid_unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::Parallel::pack(), and libMesh::DofObject::unique_id()\&.
.PP
.nf
662 {
663 #ifdef LIBMESH_ENABLE_UNIQUE_ID
664   return (DofObject::invalid_unique_id != _unique_id);
665 #else
666   return false;
667 #endif
668 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::vg_dof_base (const unsigned ints, const unsigned intvg) const\fC [inline]\fP, \fC [inherited]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 901 of file dof_object\&.h\&.
.PP
References libMesh::DofObject::_idx_buf, libMesh::DofObject::n_systems(), libMesh::DofObject::n_var_groups(), and libMesh::DofObject::start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::reinit(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::DofObject::set_vg_dof_base()\&.
.PP
.nf
903 {
904   libmesh_assert_less (s,  this->n_systems());
905   libmesh_assert_less (vg, this->n_var_groups(s));
906 
907   const unsigned int
908     start_idx_sys = this->start_idx(s);
909 
910   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
911 
912   // #ifdef DEBUG
913   //   std::cout << " [ ";
914   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
915   //     std::cout << _idx_buf[i] << " ";
916   //   std::cout << "]\n";
917   // #endif
918 
919   return _idx_buf[start_idx_sys + 2*vg + 1];
920 }
.fi
.SS "\fBReal\fP libMesh::Elem::volume () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the (length/area/volume) of the geometric element\&. 
.RE
.PP

.PP
Reimplemented in \fBlibMesh::Tet4\fP, \fBlibMesh::Hex8\fP, \fBlibMesh::Prism6\fP, \fBlibMesh::Pyramid5\fP, \fBlibMesh::Edge3\fP, \fBlibMesh::Tri3\fP, \fBlibMesh::Quad4\fP, and \fBlibMesh::Edge2\fP\&.
.PP
Definition at line 2209 of file elem\&.C\&.
.PP
References libMesh::FEGenericBase< T >::build(), libMesh::Elem::default_order(), libMesh::FEType::default_quadrature_order(), libMesh::Elem::dim(), libMesh::LAGRANGE, and libMesh::Real\&.
.PP
Referenced by libMesh::Elem::get_info()\&.
.PP
.nf
2210 {
2211   // The default implementation builds a finite element of the correct
2212   // order and sums up the JxW contributions\&.  This can be expensive,
2213   // so the various element types can overload this method and compute
2214   // the volume more efficiently\&.
2215   FEType fe_type (this->default_order() , LAGRANGE);
2216 
2217   AutoPtr<FEBase> fe (FEBase::build(this->dim(),
2218                                     fe_type));
2219 
2220   const std::vector<Real>& JxW = fe->get_JxW();
2221 
2222   // The default quadrature rule should integrate the mass matrix,
2223   // thus it should be plenty to compute the area
2224   QGauss qrule (this->dim(), fe_type\&.default_quadrature_order());
2225 
2226   fe->attach_quadrature_rule(&qrule);
2227 
2228   fe->reinit(this);
2229 
2230   Real vol=0\&.;
2231   for (unsigned int qp=0; qp<qrule\&.n_points(); ++qp)
2232     vol += JxW[qp];
2233 
2234   return vol;
2235 
2236 }
.fi
.SS "unsigned int libMesh::Elem::which_child_am_i (const \fBElem\fP *e) const\fC [inline]\fP, \fC [inherited]\fP"
This function tells you which child you \fC\fP(e) are\&. I\&.e\&. if c = a->which_child_am_i(e); then a->child(c) will be e; 
.PP
Definition at line 1817 of file elem\&.h\&.
.PP
References libMesh::Elem::child(), libMesh::err, libMesh::Elem::has_children(), libMesh::invalid_uint, libMesh::libmesh_assert(), and libMesh::Elem::n_children()\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::BoundaryInfo::boundary_id(), libMesh::BoundaryInfo::boundary_ids(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::BoundaryInfo::edge_boundary_ids(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::BoundaryInfo::has_boundary_id(), libMesh::Elem::make_links_to_me_remote(), libMesh::BoundaryInfo::n_boundary_ids(), libMesh::BoundaryInfo::n_edge_boundary_ids(), libMesh::Parallel::pack(), libMesh::Elem::PackedElem::pack(), libMesh::BoundaryInfo::side_with_boundary_id(), libMesh::Parallel::sync_element_data_by_parent_id(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
1818 {
1819   libmesh_assert(e);
1820   libmesh_assert (this->has_children());
1821 
1822   for (unsigned int c=0; c<this->n_children(); c++)
1823     if (this->child(c) == e)
1824       return c;
1825 
1826   libMesh::err << "ERROR:  which_child_am_i() was called with a non-child!"
1827                << std::endl;
1828 
1829   libmesh_error();
1830 
1831   return libMesh::invalid_uint;
1832 }
.fi
.SS "unsigned int libMesh::Elem::which_neighbor_am_i (const \fBElem\fP *e) const\fC [inline]\fP, \fC [inherited]\fP"
This function tells you which neighbor you \fC\fP(e) are\&. I\&.e\&. if s = a->which_neighbor_am_i(e); then a->neighbor(s) will be an ancestor of e; 
.PP
Definition at line 1505 of file elem\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), and libMesh::Elem::parent()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::build_graph(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::MeshTools::find_hanging_nodes_and_parents(), libMesh::Elem::libmesh_assert_valid_neighbors(), libMesh::Elem::make_links_to_me_remote(), and libMesh::Elem::nullify_neighbors()\&.
.PP
.nf
1506 {
1507   libmesh_assert(e);
1508 
1509   const Elem* eparent = e;
1510 
1511   while (eparent->level() > this->level())
1512     {
1513       eparent = eparent->parent();
1514       libmesh_assert(eparent);
1515     }
1516 
1517   for (unsigned int s=0; s<this->n_neighbors(); s++)
1518     if (this->neighbor(s) == eparent)
1519       return s;
1520 
1521   return libMesh::invalid_uint;
1522 }
.fi
.SS "unsigned int libMesh::Elem::which_side_am_i (const \fBElem\fP *e) const\fC [inline]\fP, \fC [inherited]\fP"
This function tells you which side the boundary element \fCe\fP is\&. I\&.e\&. if e = a->build_side(s) or e = a->side(s); then a->which_side_am_i(e) will be s\&.
.PP
Returns \fCinvalid_uint\fP if \fCe\fP is not a side of \fCthis\fP 
.PP
Definition at line 1527 of file elem\&.h\&.
.PP
References libMesh::invalid_uint, libMesh::Elem::is_node_on_side(), libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), and libMesh::Elem::point()\&.
.PP
.nf
1528 {
1529   libmesh_assert(e);
1530 
1531   const unsigned int ns = this->n_sides();
1532   const unsigned int nn = this->n_nodes();
1533 
1534   const unsigned int en = e->n_nodes();
1535 
1536   // e might be on any side until proven otherwise
1537   std::vector<bool> might_be_side(ns, true);
1538 
1539   for (unsigned int i=0; i != en; ++i)
1540     {
1541       Point side_point = e->point(i);
1542       unsigned int local_node_id = libMesh::invalid_uint;
1543 
1544       // Look for a node of this that's contiguous with node i of e
1545       for (unsigned int j=0; j != nn; ++j)
1546         if (this->point(j) == side_point)
1547           local_node_id = j;
1548 
1549       // If a node of e isn't contiguous with some node of this, then
1550       // e isn't a side of this\&.
1551       if (local_node_id == libMesh::invalid_uint)
1552         return libMesh::invalid_uint;
1553 
1554       // If a node of e isn't contiguous with some node on side s of
1555       // this, then e isn't on side s\&.
1556       for (unsigned int s=0; s != ns; ++s)
1557         if (!this->is_node_on_side(local_node_id, s))
1558           might_be_side[s] = false;
1559     }
1560 
1561   for (unsigned int s=0; s != ns; ++s)
1562     if (might_be_side[s])
1563       {
1564 #ifdef DEBUG
1565         for (unsigned int s2=s+1; s2 < ns; ++s2)
1566           libmesh_assert (!might_be_side[s2]);
1567 #endif
1568         return s;
1569       }
1570 
1571   // Didn't find any matching side
1572   return libMesh::invalid_uint;
1573 }
.fi
.SS "void libMesh::Elem::write_connectivity (std::ostream &out, const \fBIOPackage\fPiop) const\fC [inherited]\fP"
Writes the element connectivity for various IO packages to the passed ostream 'out'\&. Not virtual, since it is implemented in the base class\&. This function supercedes the write_tecplot_connectivity(\&.\&.\&.) and write_ucd_connectivity(\&.\&.\&.) routines\&. 
.PP
Definition at line 1248 of file elem\&.C\&.
.PP
References libMesh::Elem::_nodes, libMesh::Elem::connectivity(), libMesh::INVALID_IO_PACKAGE, libMesh::libmesh_assert(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sub_elem(), libMesh::Elem::node(), libMesh::TECPLOT, and libMesh::UCD\&.
.PP
.nf
1250 {
1251   libmesh_assert (out_stream\&.good());
1252   libmesh_assert(_nodes);
1253   libmesh_assert_not_equal_to (iop, INVALID_IO_PACKAGE);
1254 
1255   switch (iop)
1256     {
1257     case TECPLOT:
1258       {
1259         // This connectivity vector will be used repeatedly instead
1260         // of being reconstructed inside the loop\&.
1261         std::vector<dof_id_type> conn;
1262         for (unsigned int sc=0; sc <this->n_sub_elem(); sc++)
1263           {
1264             this->connectivity(sc, TECPLOT, conn);
1265 
1266             std::copy(conn\&.begin(),
1267                       conn\&.end(),
1268                       std::ostream_iterator<dof_id_type>(out_stream, " "));
1269 
1270             out_stream << '\n';
1271           }
1272         return;
1273       }
1274 
1275     case UCD:
1276       {
1277         for (unsigned int i=0; i<this->n_nodes(); i++)
1278           out_stream << this->node(i)+1 << "\t";
1279 
1280         out_stream << '\n';
1281         return;
1282       }
1283 
1284     default:
1285       libmesh_error();
1286     }
1287 
1288   libmesh_error();
1289 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBElem\fP** libMesh::Elem::_children\fC [protected]\fP, \fC [inherited]\fP"
Pointers to this element's children\&. 
.PP
Definition at line 1219 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::add_child(), libMesh::Elem::child(), libMesh::Elem::contract(), libMesh::Elem::has_ancestor_children(), libMesh::Elem::has_children(), libMesh::Elem::refine(), libMesh::Elem::set_child(), and libMesh::Elem::~Elem()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "\fBElem\fP** libMesh::Elem::_elemlinks\fC [protected]\fP, \fC [inherited]\fP"
Pointers to this element's parent and neighbors, and for lower-dimensional elements interior_parent\&. 
.PP
Definition at line 1212 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::Elem(), libMesh::Elem::interior_parent(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::Elem::set_interior_parent(), libMesh::Elem::set_neighbor(), and libMesh::Elem::set_parent()\&.
.SS "\fBElem\fP* libMesh::Hex::_elemlinks_data[7+(LIBMESH_DIM >3)]\fC [protected]\fP, \fC [inherited]\fP"
Data for links to parent/neighbor/interior_parent elements\&. 
.PP
Definition at line 133 of file cell_hex\&.h\&.
.SS "const float libMesh::Hex27::_embedding_matrix\fC [static]\fP, \fC [protected]\fP"
Matrix that computes new nodal locations/solution values from current nodes/solution\&. 
.PP
Definition at line 226 of file cell_hex27\&.h\&.
.PP
Referenced by embedding_matrix()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBNode\fP* libMesh::Hex27::_nodelinks_data[27]\fC [protected]\fP"
Data for links to nodes 
.PP
Definition at line 209 of file cell_hex27\&.h\&.
.SS "\fBNode\fP** libMesh::Elem::_nodes\fC [protected]\fP, \fC [inherited]\fP"
Pointers to the nodes we are connected to\&. 
.PP
Definition at line 1206 of file elem\&.h\&.
.PP
Referenced by libMesh::Prism6::connectivity(), libMesh::Pyramid5::connectivity(), libMesh::Hex8::connectivity(), libMesh::InfPrism6::connectivity(), libMesh::InfPrism12::connectivity(), libMesh::InfHex8::connectivity(), libMesh::Tet4::connectivity(), libMesh::Tet10::connectivity(), libMesh::InfHex16::connectivity(), libMesh::Hex20::connectivity(), libMesh::Pyramid13::connectivity(), libMesh::Prism15::connectivity(), libMesh::Pyramid14::connectivity(), libMesh::InfHex18::connectivity(), connectivity(), libMesh::Prism18::connectivity(), libMesh::Elem::Elem(), libMesh::Elem::get_node(), libMesh::Elem::get_node_index(), libMesh::Tri3Subdivision::local_node_number(), libMesh::Elem::node(), libMesh::Elem::point(), libMesh::Elem::set_node(), libMesh::Prism6::volume(), libMesh::Hex8::volume(), and libMesh::Elem::write_connectivity()\&.
.SS "unsigned char libMesh::Elem::_p_level\fC [protected]\fP, \fC [inherited]\fP"
p refinement level - the difference between the polynomial degree on this element and the minimum polynomial degree on the mesh\&. This is stored as an unsigned char to save space\&. In theory, these last four bytes might have been padding anyway\&. 
.PP
Definition at line 1243 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::hack_p_level(), libMesh::Elem::max_descendant_p_level(), libMesh::Elem::p_level(), and libMesh::Elem::set_p_level()\&.
.SS "unsigned char libMesh::Elem::_pflag\fC [protected]\fP, \fC [inherited]\fP"
p refinement flag\&. This is stored as an unsigned char to save space\&. 
.PP
Definition at line 1232 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::p_refinement_flag(), and libMesh::Elem::set_p_refinement_flag()\&.
.SS "const unsigned short int libMesh::Hex27::_remaining_second_order_adjacent_vertices\fC [static]\fP, \fC [private]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    { 0,  1,  2,  3}, 
    { 0,  1,  4,  5}, 
    { 1,  2,  5,  6}, 
    { 2,  3,  6,  7}, 
    { 0,  3,  4,  7}, 
    { 4,  5,  6,  7}, 
  }
.fi
Matrix that tells which vertices define the location of mid-side (or second-order) nodes\&. This matrix only covers the nodes that are unique to \fC\fBHex27\fP\fP, while the second-order-nodes that are identical with \fC\fBHex20\fP\fP are covered through the \fC_second_order_adjacent_vertices\fP matrix in \fC\fBcell_hex\&.C\fP\fP\&. Note that this matrix also does \fInot\fP cover the bubble node\&. The interpolation is trivial and would only blow up the size of this matrix\&. 
.PP
Definition at line 244 of file cell_hex27\&.h\&.
.PP
Referenced by second_order_adjacent_vertex()\&.
.SS "unsigned char libMesh::Elem::_rflag\fC [protected]\fP, \fC [inherited]\fP"
h refinement flag\&. This is stored as an unsigned char to save space\&. 
.PP
Definition at line 1225 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::refinement_flag(), and libMesh::Elem::set_refinement_flag()\&.
.SS "\fBsubdomain_id_type\fP libMesh::Elem::_sbd_id\fC [protected]\fP, \fC [inherited]\fP"
The subdomain to which this element belongs\&. 
.PP
Definition at line 1250 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::subdomain_id()\&.
.SS "const unsigned short int libMesh::Hex::_second_order_adjacent_vertices\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    { 0,  1}, 
    { 1,  2}, 
    { 2,  3}, 
    { 0,  3}, 

    { 0,  4}, 
    { 1,  5}, 
    { 2,  6}, 
    { 3,  7}, 

    { 4,  5}, 
    { 5,  6}, 
    { 6,  7}, 
    { 4,  7}  
  }
.fi
Matrix that tells which vertices define the location of mid-side (or second-order) nodes\&. This matrix is kept here, since the matrix (for the first 12 higher-order nodes) is identical for \fC\fBHex20\fP\fP and \fC\fBHex27\fP\fP\&. 
.PP
Definition at line 142 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex20::second_order_adjacent_vertex(), and second_order_adjacent_vertex()\&.
.SS "const unsigned short int libMesh::Hex::_second_order_vertex_child_index\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    99,99,99,99,99,99,99,99, 
    1,2,3,3,4,5,6,7,5,6,7,7, 
    2,5,6,7,7,6,             
    6                        
  }
.fi
Vector that names the child vertex index for each second order node\&. 
.PP
Definition at line 152 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex20::second_order_child_vertex(), and second_order_child_vertex()\&.
.SS "const unsigned short int libMesh::Hex::_second_order_vertex_child_number\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    99,99,99,99,99,99,99,99, 
    0,1,2,0,0,1,2,3,4,5,6,5, 
    0,0,1,2,0,4,             
    0                        
  }
.fi
Vector that names a child sharing each second order node\&. 
.PP
Definition at line 147 of file cell_hex\&.h\&.
.PP
Referenced by libMesh::Hex20::second_order_child_vertex(), and second_order_child_vertex()\&.
.SS "const unsigned int libMesh::Hex27::edge_nodes_map\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    {0, 1, 8},  
    {1, 2, 9},  
    {2, 3, 10}, 
    {0, 3, 11}, 
    {0, 4, 12}, 
    {1, 5, 13}, 
    {2, 6, 14}, 
    {3, 7, 15}, 
    {4, 5, 16}, 
    {5, 6, 17}, 
    {6, 7, 18}, 
    {4, 7, 19}  
  }
.fi
This maps the $ j^{th} $ node of the $ i^{th} $ edge to element node numbers\&. 
.PP
Definition at line 200 of file cell_hex27\&.h\&.
.PP
Referenced by is_node_on_edge()\&.
.SS "const \fBdof_id_type\fP libMesh::DofObject::invalid_id = static_cast<\fBdof_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invaild \fCid\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 335 of file dof_object\&.h\&.
.PP
Referenced by libMesh::SFCPartitioner::_do_partition(), libMesh::DofMap::_dof_indices(), libMesh::Node::active(), libMesh::SerialMesh::add_point(), libMesh::MeshRefinement::add_point(), libMesh::UnstructuredMesh::all_second_order(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofObject::dof_number(), libMesh::SerialMesh::insert_node(), libMesh::DofObject::invalidate_dofs(), libMesh::DofObject::invalidate_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::Elem::node(), libMesh::DofMap::old_dof_indices(), libMesh::XdrIO::pack_element(), libMesh::Elem::point(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::DofObject::set_dof_number(), libMesh::DofObject::set_n_comp_group(), libMesh::DofObject::set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::DofObject::valid_id(), and libMesh::System::write_parallel_data()\&.
.SS "const \fBprocessor_id_type\fP libMesh::DofObject::invalid_processor_id = static_cast<\fBprocessor_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invalid \fCprocessor_id\fP to distinguish DoFs that have not been assigned to a processor\&. 
.PP
Definition at line 346 of file dof_object\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::MeshCommunication::allgather(), libMesh::MeshTools::bounding_box(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::Elem::Elem(), libMesh::MeshCommunication::find_global_indices(), libMesh::DofObject::invalidate_processor_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::MeshBase::n_unpartitioned_elem(), libMesh::MeshBase::n_unpartitioned_nodes(), libMesh::Elem::PackedElem::processor_id(), libMesh::CheckpointIO::read_connectivity(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_dofobject_data_by_xyz(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshTools::total_weight(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::SerialMesh::unpartitioned_elements_begin(), libMesh::ParallelMesh::unpartitioned_elements_begin(), libMesh::SerialMesh::unpartitioned_elements_end(), libMesh::ParallelMesh::unpartitioned_elements_end(), libMesh::DofObject::valid_processor_id(), and libMesh::CheckpointIO::write_connectivity()\&.
.SS "const \fBunique_id_type\fP libMesh::DofObject::invalid_unique_id = static_cast<\fBunique_id_type\fP>(-1)\fC [static]\fP, \fC [inherited]\fP"
An invaild \fCunique_id\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 340 of file dof_object\&.h\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::DofObject::unique_id(), and libMesh::DofObject::valid_unique_id()\&.
.SS "\fBDofObject\fP* libMesh::DofObject::old_dof_object\fC [inherited]\fP"
This object on the last mesh\&. Useful for projecting solutions from one mesh to another\&. 
.PP
Definition at line 89 of file dof_object\&.h\&.
.PP
Referenced by libMesh::DofObject::clear_old_dof_object(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::old_dof_indices(), libMesh::DofObject::operator=(), libMesh::DofObject::packed_indexing_size(), libMesh::DofMap::reinit(), libMesh::DofObject::set_old_dof_object(), and libMesh::DofObject::unpack_indexing()\&.
.SS "const unsigned int libMesh::Hex27::side_nodes_map\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
=
  {
    {0, 3, 2, 1, 11, 10,  9,  8, 20}, 
    {0, 1, 5, 4,  8, 13, 16, 12, 21}, 
    {1, 2, 6, 5,  9, 14, 17, 13, 22}, 
    {2, 3, 7, 6, 10, 15, 18, 14, 23}, 
    {3, 0, 4, 7, 11, 12, 19, 15, 24}, 
    {4, 5, 6, 7, 16, 17, 18, 19, 25}  
  }
.fi
This maps the $ j^{th} $ node of the $ i^{th} $ side to element node numbers\&. 
.PP
Definition at line 194 of file cell_hex27\&.h\&.
.PP
Referenced by is_node_on_side()\&.
.SS "const unsigned int libMesh::Elem::type_to_n_edges_map\fC [static]\fP, \fC [inherited]\fP"
This array maps the integer representation of the \fCElemType\fP enum to the number of edges on the element\&. 
.PP
Definition at line 445 of file elem\&.h\&.
.PP
Referenced by libMesh::Parallel::packed_size()\&.
.SS "const unsigned int libMesh::Elem::type_to_n_nodes_map\fC [static]\fP, \fC [inherited]\fP"
This array maps the integer representation of the \fCElemType\fP enum to the number of nodes in the element\&. 
.PP
Definition at line 400 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::PackedElem::n_nodes(), libMesh::XdrIO::pack_element(), libMesh::Parallel::packed_size(), libMesh::CheckpointIO::read_connectivity(), libMesh::XdrIO::read_serialized_connectivity(), and libMesh::Parallel::unpack()\&.
.SS "const unsigned int libMesh::Elem::type_to_n_sides_map\fC [static]\fP, \fC [inherited]\fP"
This array maps the integer representation of the \fCElemType\fP enum to the number of sides on the element\&. 
.PP
Definition at line 411 of file elem\&.h\&.
.PP
Referenced by libMesh::Elem::PackedElem::n_neighbors(), and libMesh::Parallel::packed_size()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
