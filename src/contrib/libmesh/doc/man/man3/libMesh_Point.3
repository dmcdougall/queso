.TH "libMesh::Point" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Point \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <point\&.h>\fP
.PP
Inherits \fBlibMesh::TypeVector< Real >\fP\&.
.PP
Inherited by \fBlibMesh::Node\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPoint\fP (const \fBReal\fP \fBx\fP=0\&., const \fBReal\fP y=0\&., const \fBReal\fP z=0\&.)"
.br
.ti -1c
.RI "\fBPoint\fP (const \fBPoint\fP &p)"
.br
.ti -1c
.RI "\fBPoint\fP (const \fBTypeVector\fP< \fBReal\fP > &p)"
.br
.ti -1c
.RI "\fB~Point\fP ()"
.br
.ti -1c
.RI "void \fBassign\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "const \fBReal\fP & \fBoperator()\fP (const unsigned int i) const"
.br
.ti -1c
.RI "\fBReal\fP & \fBoperator()\fP (const unsigned int i)"
.br
.ti -1c
.RI "const \fBReal\fP & \fBslice\fP (const unsigned int i) const"
.br
.ti -1c
.RI "\fBReal\fP & \fBslice\fP (const unsigned int i)"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBoperator+\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator+=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBadd\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBadd_scaled\fP (const \fBTypeVector\fP< T2 > &, const \fBReal\fP)"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBoperator-\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< \fBReal\fP > \fBoperator-\fP () const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator-=\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBsubtract\fP (const \fBTypeVector\fP< T2 > &)"
.br
.ti -1c
.RI "void \fBsubtract_scaled\fP (const \fBTypeVector\fP< T2 > &, const \fBReal\fP)"
.br
.ti -1c
.RI "\fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, Scalar >
.br
::supertype > >::type \fBoperator*\fP (const Scalar) const"
.br
.ti -1c
.RI "\fBCompareTypes\fP< \fBReal\fP, T2 >::supertype \fBoperator*\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator*=\fP (const \fBReal\fP)"
.br
.ti -1c
.RI "\fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, Scalar >
.br
::supertype > >::type \fBoperator/\fP (const Scalar) const"
.br
.ti -1c
.RI "const \fBTypeVector\fP< \fBReal\fP > & \fBoperator/=\fP (const \fBReal\fP)"
.br
.ti -1c
.RI "\fBCompareTypes\fP< \fBReal\fP, T2 >::supertype \fBcontract\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< typename 
.br
\fBCompareTypes\fP< \fBReal\fP, T2 >
.br
::supertype > \fBcross\fP (const \fBTypeVector\fP< T2 > &) const"
.br
.ti -1c
.RI "\fBTypeVector\fP< \fBReal\fP > \fBunit\fP () const"
.br
.ti -1c
.RI "\fBReal\fP \fBsize\fP () const"
.br
.ti -1c
.RI "\fBReal\fP \fBsize_sq\fP () const"
.br
.ti -1c
.RI "void \fBzero\fP ()"
.br
.ti -1c
.RI "bool \fBrelative_fuzzy_equals\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const"
.br
.ti -1c
.RI "bool \fBabsolute_fuzzy_equals\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs, \fBReal\fP tol=\fBTOLERANCE\fP) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBTypeVector\fP< \fBReal\fP > &rhs) const"
.br
.ti -1c
.RI "void \fBprint\fP (std::ostream &os=\fBlibMesh::out\fP) const"
.br
.ti -1c
.RI "void \fBwrite_unformatted\fP (std::ostream &\fBout\fP, const bool newline=true) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBReal\fP \fB_coords\fP [LIBMESH_DIM]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBNode\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A \fC\fBPoint\fP\fP defines a location in LIBMESH_DIM dimensional Real space\&. Points are always real-valued, even if the library is configured with \fC--enable-complex\fP\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk, 2003\&. 
.RE
.PP

.PP
Definition at line 42 of file point\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Point::Point (const \fBReal\fPx = \fC0\&.\fP, const \fBReal\fPy = \fC0\&.\fP, const \fBReal\fPz = \fC0\&.\fP)\fC [inline]\fP"
Constructor\&. By default sets all entries to 0\&. Gives the point 0 in \fCLIBMESH_DIM\fP dimensions\&. 
.PP
Definition at line 89 of file point\&.h\&.
.PP
Referenced by libMesh::Node::PackedNode::build_point()\&.
.PP
.nf
91                             :
92   TypeVector<Real> (x,y,z)
93 {
94 }
.fi
.SS "libMesh::Point::Point (const \fBPoint\fP &p)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 99 of file point\&.h\&.
.PP
.nf
99                             :
100   TypeVector<Real> (p)
101 {
102 }
.fi
.SS "libMesh::Point::Point (const \fBTypeVector\fP< \fBReal\fP > &p)\fC [inline]\fP"
Copy-constructor\&. 
.PP
Definition at line 107 of file point\&.h\&.
.PP
.nf
107                                        :
108   TypeVector<Real> (p)
109 {
110 }
.fi
.SS "libMesh::Point::~Point ()\fC [inline]\fP"
Empty\&. 
.PP
Definition at line 67 of file point\&.h\&.
.PP
.nf
67 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::absolute_fuzzy_equals (const \fBTypeVector\fP< Real  > &rhs, Realtol = \fCTOLERANCE\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCtol\fP\&. 
.RE
.PP

.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::add (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Add to this vector without creating a temporary\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::add_scaled (const \fBTypeVector\fP< T2 > &, const Real)\fC [inherited]\fP"
Add a scaled value to this vector without creating a temporary\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::assign (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Assign to a vector without creating a temporary\&. 
.SS "\fBCompareTypes\fP<\fBReal\fP , T2>::supertype \fBlibMesh::TypeVector\fP< \fBReal\fP  >::contract (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::cross (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Cross 2 vectors together, i\&.e\&. cross-product\&. 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator!= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors do not occupy approximately the same physical location in space\&. 
.RE
.PP

.SS "const \fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator() (const unsigned inti) const\fC [inherited]\fP"
Return the $ i^{th} $ element of the vector\&. 
.SS "\fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator() (const unsigned inti)\fC [inherited]\fP"
Return a writeable reference to the $ i^{th} $ element of the vector\&. 
.SS "\fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , Scalar>::supertype> >::type \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator* (const Scalar) const\fC [inherited]\fP"
Multiply a vector by a number, i\&.e\&. scale\&. 
.SS "\fBCompareTypes\fP<\fBReal\fP , T2>::supertype \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator* (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Multiply 2 vectors together, i\&.e\&. dot-product\&. The vectors may be of different types\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator*= (const Real)\fC [inherited]\fP"
Multiply this vector by a number, i\&.e\&. scale\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator+ (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Add two vectors\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator+= (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Add to this vector\&. 
.SS "\fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , T2>::supertype> \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator- (const \fBTypeVector\fP< T2 > &) const\fC [inherited]\fP"
Subtract two vectors\&. 
.SS "\fBTypeVector\fP<\fBReal\fP > \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator- () const\fC [inherited]\fP"
Return the opposite of a vector 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator-= (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Subtract from this vector\&. 
.SS "\fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeVector\fP<typename \fBCompareTypes\fP<\fBReal\fP , Scalar>::supertype> >::type \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator/ (const Scalar) const\fC [inherited]\fP"
Divide a vector by a number, i\&.e\&. scale\&. 
.SS "const \fBTypeVector\fP<\fBReal\fP >& \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator/= (const Real)\fC [inherited]\fP"
Divide this vector by a number, i\&.e\&. scale\&. 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator< (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator<= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'less' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator== (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within an absolute tolerance of \fCTOLERANCE\fP\&. 
.RE
.PP

.PP
Referenced by libMesh::Node::operator==()\&.
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator> (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than another\&. Useful for sorting\&. Also used for choosing some arbitrary basis function orientations 
.RE
.PP

.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::operator>= (const \fBTypeVector\fP< Real  > &rhs) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this vector is 'greater' than or equal to another\&. Useful for sorting\&. Also used for choosing some arbitrary constraint equation directions 
.RE
.PP

.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::print (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Formatted print, by default to \fC\fBlibMesh::out\fP\fP\&. 
.SS "bool \fBlibMesh::TypeVector\fP< \fBReal\fP  >::relative_fuzzy_equals (const \fBTypeVector\fP< Real  > &rhs, Realtol = \fCTOLERANCE\fP) const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP iff two vectors occupy approximately the same physical location in space, to within a relative tolerance of \fCtol\fP\&. 
.RE
.PP

.SS "\fBReal\fP \fBlibMesh::TypeVector\fP< \fBReal\fP  >::size () const\fC [inherited]\fP"
Returns the magnitude of the vector, i\&.e\&. the square-root of the sum of the elements squared\&. 
.SS "\fBReal\fP \fBlibMesh::TypeVector\fP< \fBReal\fP  >::size_sq () const\fC [inherited]\fP"
Returns the magnitude of the vector squared, i\&.e\&. the sum of the element magnitudes squared\&. 
.SS "const \fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::slice (const unsigned inti) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 123 of file type_vector\&.h\&.
.PP
.nf
123 { return (*this)(i); }
.fi
.SS "\fBReal\fP & \fBlibMesh::TypeVector\fP< \fBReal\fP  >::slice (const unsigned inti)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 130 of file type_vector\&.h\&.
.PP
.nf
130 { return (*this)(i); }
.fi
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::subtract (const \fBTypeVector\fP< T2 > &)\fC [inherited]\fP"
Subtract from this vector without creating a temporary\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::subtract_scaled (const \fBTypeVector\fP< T2 > &, const Real)\fC [inherited]\fP"
Subtract a scaled value from this vector without creating a temporary\&. 
.SS "\fBTypeVector\fP<\fBReal\fP > \fBlibMesh::TypeVector\fP< \fBReal\fP  >::unit () const\fC [inherited]\fP"
Think of a vector as a \fCdim\fP dimensional vector\&. This will return a unit vector aligned in that direction\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::write_unformatted (std::ostream &out, const boolnewline = \fCtrue\fP) const\fC [inherited]\fP"
Unformatted print to the stream \fCout\fP\&. Simply prints the elements of the vector separated by spaces\&. Optionally prints a newline, which it does by default\&. 
.SS "void \fBlibMesh::TypeVector\fP< \fBReal\fP  >::zero ()\fC [inherited]\fP"
Zero the vector in any dimension\&. 
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBNode\fP\fC [friend]\fP"

.PP
\fBReturns:\fP
.RS 4
a key associated with this point\&. Useful for sorting\&. Make the derived class a friend 
.RE
.PP

.PP
Definition at line 81 of file point\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBReal\fP  \fBlibMesh::TypeVector\fP< \fBReal\fP  >::_coords[LIBMESH_DIM]\fC [protected]\fP, \fC [inherited]\fP"
The coordinates of the \fCTypeVector\fP 
.PP
Definition at line 347 of file type_vector\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
