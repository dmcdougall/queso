.TH "libMesh::Mesh" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::Mesh \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <mesh\&.h>\fP
.PP
Inherits \fBlibMesh::ParallelMesh\fP\&.
.PP
Inherited by \fBlibMesh::BoundaryMesh\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBPredicates::multi_predicate\fP \fBPredicate\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMesh\fP (const \fBParallel::Communicator\fP &comm_in, unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "\fBMesh\fP (unsigned int \fBdim\fP=1)"
.br
.ti -1c
.RI "\fBMesh\fP (const \fBUnstructuredMesh\fP &other_mesh)"
.br
.ti -1c
.RI "\fB~Mesh\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBMeshBase\fP > \fBclone\fP () const "
.br
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.ti -1c
.RI "virtual void \fBredistribute\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate_post_partitioning\fP ()"
.br
.ti -1c
.RI "virtual bool \fBis_serial\fP () const "
.br
.ti -1c
.RI "template<typename T > void \fBlibmesh_assert_valid_parallel_object_ids\fP (const \fBmapvector\fP< T *, \fBdof_id_type\fP > &) const "
.br
.ti -1c
.RI "virtual void \fBlibmesh_assert_valid_parallel_ids\fP () const "
.br
.ti -1c
.RI "void \fBlibmesh_assert_valid_parallel_flags\fP () const "
.br
.ti -1c
.RI "template<typename T > \fBdof_id_type\fP \fBrenumber_dof_objects\fP (\fBmapvector\fP< T *, \fBdof_id_type\fP > &)"
.br
.ti -1c
.RI "virtual void \fBrenumber_nodes_and_elements\fP ()"
.br
.ti -1c
.RI "virtual void \fBallgather\fP ()"
.br
.ti -1c
.RI "virtual void \fBdelete_remote_elements\fP ()"
.br
.ti -1c
.RI "virtual void \fBadd_extra_ghost_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBclear_extra_ghost_elems\fP ()"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_nodes\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_node_id\fP () const "
.br
.ti -1c
.RI "virtual void \fBreserve_nodes\fP (const \fBdof_id_type\fP)"
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_elem\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBn_active_elem\fP () const "
.br
.ti -1c
.RI "virtual \fBdof_id_type\fP \fBmax_elem_id\fP () const "
.br
.ti -1c
.RI "virtual void \fBreserve_elem\fP (const \fBdof_id_type\fP)"
.br
.ti -1c
.RI "virtual void \fBupdate_parallel_id_counts\fP ()"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBparallel_n_nodes\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBparallel_max_node_id\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBparallel_n_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBparallel_max_elem_id\fP () const "
.br
.ti -1c
.RI "virtual const \fBPoint\fP & \fBpoint\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual const \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP & \fBnode\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBnode_ptr\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBquery_node_ptr\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBelem\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual const \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i) const "
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBquery_elem\fP (const \fBdof_id_type\fP i)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_point\fP (const \fBPoint\fP &p, const \fBdof_id_type\fP id=\fBDofObject::invalid_id\fP, const \fBprocessor_id_type\fP proc_id=\fBDofObject::invalid_processor_id\fP)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBadd_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual \fBNode\fP * \fBinsert_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual void \fBdelete_node\fP (\fBNode\fP *n)"
.br
.ti -1c
.RI "virtual void \fBrenumber_node\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBadd_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual \fBElem\fP * \fBinsert_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBdelete_elem\fP (\fBElem\fP *e)"
.br
.ti -1c
.RI "virtual void \fBrenumber_elem\fP (\fBdof_id_type\fP old_id, \fBdof_id_type\fP new_id)"
.br
.ti -1c
.RI "virtual void \fBfix_broken_node_and_element_numbering\fP ()"
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBelements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBelements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBelements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBelements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBancestor_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBancestor_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBancestor_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBancestor_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBsubactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBsubactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBsubactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBsubactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_active_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_active_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_active_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_active_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_ancestor_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_ancestor_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_ancestor_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_ancestor_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_subactive_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_subactive_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_subactive_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_subactive_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_not_local_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_not_local_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_not_local_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_not_local_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlevel_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlevel_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlevel_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBnot_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_not_level_elements_begin\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBlocal_not_level_elements_end\fP (const unsigned int level) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBpid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBpid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBtype_elements_begin\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBtype_elements_end\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_type_elements_begin\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_type_elements_end\fP (const \fBElemType\fP type) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_pid_elements_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_pid_elements_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBunpartitioned_elements_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBunpartitioned_elements_begin\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBunpartitioned_elements_end\fP ()"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBunpartitioned_elements_end\fP () const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_local_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_subdomain_elements_begin\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBelement_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id)"
.br
.ti -1c
.RI "\fBconst_element_iterator\fP \fBactive_subdomain_elements_end\fP (const \fBsubdomain_id_type\fP subdomain_id) const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBnodes_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBnodes_begin\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBnodes_end\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBnodes_end\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBactive_nodes_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBactive_nodes_begin\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBactive_nodes_end\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBactive_nodes_end\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBlocal_nodes_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBlocal_nodes_begin\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBlocal_nodes_end\fP ()"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBlocal_nodes_end\fP () const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBpid_nodes_begin\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "\fBnode_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id)"
.br
.ti -1c
.RI "\fBconst_node_iterator\fP \fBpid_nodes_end\fP (const \fBprocessor_id_type\fP proc_id) const "
.br
.ti -1c
.RI "void \fBread\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL, bool skip_renumber_nodes_and_elements=false)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, \fBMeshData\fP *mesh_data=NULL)"
.br
.ti -1c
.RI "void \fBwrite\fP (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)"
.br
.ti -1c
.RI "virtual void \fBall_first_order\fP ()"
.br
.ti -1c
.RI "virtual void \fBall_second_order\fP (const bool full_ordered=true)"
.br
.ti -1c
.RI "void \fBcreate_pid_mesh\fP (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fP pid) const "
.br
.ti -1c
.RI "void \fBcreate_submesh\fP (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const "
.br
.ti -1c
.RI "virtual void \fBcopy_nodes_and_elements\fP (const \fBUnstructuredMesh\fP &other_mesh, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBfind_neighbors\fP (const bool reset_remote_elements=false, const bool reset_current_list=true)"
.br
.ti -1c
.RI "virtual bool \fBcontract\fP ()"
.br
.ti -1c
.RI "virtual \fBAutoPtr\fP< \fBPartitioner\fP > & \fBpartitioner\fP ()"
.br
.ti -1c
.RI "bool \fBis_prepared\fP () const "
.br
.ti -1c
.RI "unsigned int \fBmesh_dimension\fP () const "
.br
.ti -1c
.RI "void \fBset_mesh_dimension\fP (unsigned int d)"
.br
.ti -1c
.RI "unsigned int \fBspatial_dimension\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_nodes_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_nodes\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_nodes\fP () const "
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBnext_unique_id\fP ()"
.br
.ti -1c
.RI "void \fBset_next_unique_id\fP (\fBunique_id_type\fP id)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_unpartitioned_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_elem_on_proc\fP (const \fBprocessor_id_type\fP proc) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_local_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_sub_elem\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBn_active_sub_elem\fP () const "
.br
.ti -1c
.RI "void \fBprepare_for_use\fP (const bool skip_renumber_nodes_and_elements=false, const bool skip_find_neighbors=false)"
.br
.ti -1c
.RI "virtual void \fBpartition\fP (const unsigned int n_parts)"
.br
.ti -1c
.RI "void \fBpartition\fP ()"
.br
.ti -1c
.RI "void \fBallow_renumbering\fP (bool allow)"
.br
.ti -1c
.RI "bool \fBallow_renumbering\fP () const "
.br
.ti -1c
.RI "void \fBskip_partitioning\fP (bool skip)"
.br
.ti -1c
.RI "bool \fBskip_partitioning\fP () const "
.br
.ti -1c
.RI "void \fBsubdomain_ids\fP (std::set< \fBsubdomain_id_type\fP > &ids) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBn_subdomains\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_partitions\fP () const "
.br
.ti -1c
.RI "std::string \fBget_info\fP () const "
.br
.ti -1c
.RI "void \fBprint_info\fP (std::ostream &os=\fBlibMesh::out\fP) const "
.br
.ti -1c
.RI "unsigned int \fBrecalculate_n_partitions\fP ()"
.br
.ti -1c
.RI "const \fBPointLocatorBase\fP & \fBpoint_locator\fP () const "
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fBsub_point_locator\fP () const "
.br
.ti -1c
.RI "void \fBclear_point_locator\fP ()"
.br
.ti -1c
.RI "std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id)"
.br
.ti -1c
.RI "const std::string & \fBsubdomain_name\fP (\fBsubdomain_id_type\fP id) const "
.br
.ti -1c
.RI "\fBsubdomain_id_type\fP \fBget_id_by_name\fP (const std::string &name) const "
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBset_subdomain_name_map\fP ()"
.br
.ti -1c
.RI "const std::map
.br
< \fBsubdomain_id_type\fP, 
.br
std::string > & \fBget_subdomain_name_map\fP () const "
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fBcomm\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBn_processors\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBAutoPtr\fP< \fBBoundaryInfo\fP > \fBboundary_info\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBassign_unique_ids\fP ()"
.br
.ti -1c
.RI "unsigned int & \fBset_n_partitions\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBmapvector\fP< \fBNode\fP *, \fBdof_id_type\fP > \fB_nodes\fP"
.br
.ti -1c
.RI "\fBmapvector\fP< \fBElem\fP *, \fBdof_id_type\fP > \fB_elements\fP"
.br
.ti -1c
.RI "bool \fB_is_serial\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_n_nodes\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_n_elem\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_max_node_id\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_max_elem_id\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_next_free_local_node_id\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_next_free_local_elem_id\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_next_free_unpartitioned_node_id\fP"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fB_next_free_unpartitioned_elem_id\fP"
.br
.ti -1c
.RI "std::set< \fBElem\fP * > \fB_extra_ghost_elems\fP"
.br
.ti -1c
.RI "unsigned int \fB_n_parts\fP"
.br
.ti -1c
.RI "unsigned int \fB_dim\fP"
.br
.ti -1c
.RI "bool \fB_is_prepared\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPointLocatorBase\fP > \fB_point_locator\fP"
.br
.ti -1c
.RI "\fBAutoPtr\fP< \fBPartitioner\fP > \fB_partitioner\fP"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fB_next_unique_id\fP"
.br
.ti -1c
.RI "bool \fB_skip_partitioning\fP"
.br
.ti -1c
.RI "bool \fB_skip_renumber_nodes_and_elements\fP"
.br
.ti -1c
.RI "std::map< \fBsubdomain_id_type\fP, 
.br
std::string > \fB_block_id_to_name\fP"
.br
.ti -1c
.RI "const \fBParallel::Communicator\fP & \fB_communicator\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBMesh\fP\fP class is a thin wrapper, around the \fC\fBSerialMesh\fP\fP class by default\&. 
.PP
Definition at line 50 of file mesh\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef \fBPredicates::multi_predicate\fP \fBlibMesh::MeshBase::Predicate\fP\fC [inherited]\fP"
We need an empty, generic class to act as a predicate for this and derived mesh classes\&. 
.PP
Definition at line 632 of file mesh_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::Mesh::Mesh (const \fBParallel::Communicator\fP &comm_in, unsigned intdim = \fC1\fP)\fC [inline]\fP, \fC [explicit]\fP"
Constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 60 of file mesh\&.h\&.
.PP
.nf
62     : DefaultMesh(comm_in,dim) {}
.fi
.SS "libMesh::Mesh::Mesh (unsigned intdim = \fC1\fP)\fC [inline]\fP, \fC [explicit]\fP"
Deprecated constructor\&. Takes \fCdim\fP, the dimension of the mesh\&. The mesh dimension can be changed (and may automatically be changed by mesh generation/loading) later\&. 
.PP
Definition at line 71 of file mesh\&.h\&.
.PP
.nf
72     : DefaultMesh(dim) {}
.fi
.SS "libMesh::Mesh::Mesh (const \fBUnstructuredMesh\fP &other_mesh)\fC [inline]\fP"
Copy-constructor\&. This should be able to take a serial or parallel mesh\&. 
.PP
Definition at line 79 of file mesh\&.h\&.
.PP
.nf
79 : DefaultMesh(other_mesh) {}
.fi
.SS "libMesh::Mesh::~Mesh ()\fC [inline]\fP"
Destructor\&. 
.PP
Definition at line 84 of file mesh\&.h\&.
.PP
.nf
84 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 47 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
48 {
49   Predicates::Active<elem_iterator_imp> p;
50   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
51 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 272 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
273 {
274   Predicates::Active<const_elem_iterator_imp> p;
275   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
276 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 494 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
495 {
496   Predicates::Active<elem_iterator_imp> p;
497   return element_iterator(_elements\&.end(), _elements\&.end(), p);
498 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 719 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
720 {
721   Predicates::Active<const_elem_iterator_imp> p;
722   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
723 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_local_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 127 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParallelMesh::n_active_elem()\&.
.PP
.nf
128 {
129   Predicates::ActiveLocal<elem_iterator_imp> p(this->processor_id());
130   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
131 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_local_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 351 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
352 {
353   Predicates::ActiveLocal<const_elem_iterator_imp> p(this->processor_id());
354   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
355 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_local_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 574 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParallelMesh::n_active_elem()\&.
.PP
.nf
575 {
576   Predicates::ActiveLocal<elem_iterator_imp> p(this->processor_id());
577   return element_iterator(_elements\&.end(), _elements\&.end(), p);
578 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_local_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 799 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
800 {
801   Predicates::ActiveLocal<const_elem_iterator_imp> p(this->processor_id());
802   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
803 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 236 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
237 {
238   Predicates::ActiveLocalSubdomain<elem_iterator_imp> p(this->processor_id(),subdomain_id);
239   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
240 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_local_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 460 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
461 {
462   Predicates::ActiveLocalSubdomain<const_elem_iterator_imp> p(this->processor_id(),subdomain_id);
463   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
464 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 683 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
684 {
685   Predicates::ActiveLocalSubdomain<elem_iterator_imp> p(this->processor_id(),subdomain_id);
686   return element_iterator(_elements\&.end(), _elements\&.end(), p);
687 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_local_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 907 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
908 {
909   Predicates::ActiveLocalSubdomain<const_elem_iterator_imp> p(this->processor_id(),subdomain_id);
910   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
911 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::active_nodes_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 941 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
942 {
943   Predicates::Active<node_iterator_imp> p;
944   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
945 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::active_nodes_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 981 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
982 {
983   Predicates::Active<const_node_iterator_imp> p;
984   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
985 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::active_nodes_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1021 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1022 {
1023   Predicates::Active<node_iterator_imp> p;
1024   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1025 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::active_nodes_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1061 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1062 {
1063   Predicates::Active<const_node_iterator_imp> p;
1064   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1065 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_not_local_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 137 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
138 {
139   Predicates::ActiveNotLocal<elem_iterator_imp> p(this->processor_id());
140   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
141 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_not_local_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 361 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
362 {
363   Predicates::ActiveNotLocal<const_elem_iterator_imp> p(this->processor_id());
364   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
365 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_not_local_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 584 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
585 {
586   Predicates::ActiveNotLocal<elem_iterator_imp> p(this->processor_id());
587   return element_iterator(_elements\&.end(), _elements\&.end(), p);
588 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_not_local_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 809 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
810 {
811   Predicates::ActiveNotLocal<const_elem_iterator_imp> p(this->processor_id());
812   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
813 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 217 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::n_active_elem()\&.
.PP
.nf
218 {
219   Predicates::ActivePID<elem_iterator_imp> p(proc_id);
220   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
221 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 441 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
442 {
443   Predicates::ActivePID<const_elem_iterator_imp> p(proc_id);
444   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
445 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 664 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::n_active_elem()\&.
.PP
.nf
665 {
666   Predicates::ActivePID<elem_iterator_imp> p(proc_id);
667   return element_iterator(_elements\&.end(), _elements\&.end(), p);
668 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 888 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
889 {
890   Predicates::ActivePID<const_elem_iterator_imp> p(proc_id);
891   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
892 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 246 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
247 {
248   Predicates::ActiveSubdomain<elem_iterator_imp> p(subdomain_id);
249   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
250 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_subdomain_elements_begin (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 470 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
471 {
472   Predicates::ActiveSubdomain<const_elem_iterator_imp> p(subdomain_id);
473   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
474 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 693 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
694 {
695   Predicates::ActiveSubdomain<elem_iterator_imp> p(subdomain_id);
696   return element_iterator(_elements\&.end(), _elements\&.end(), p);
697 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_subdomain_elements_end (const \fBsubdomain_id_type\fPsubdomain_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 917 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
918 {
919   Predicates::ActiveSubdomain<const_elem_iterator_imp> p(subdomain_id);
920   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
921 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_type_elements_begin (const \fBElemType\fPtype)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 207 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
208 {
209   Predicates::ActiveType<elem_iterator_imp> p(type);
210   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
211 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_type_elements_begin (const \fBElemType\fPtype) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 431 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
432 {
433   Predicates::ActiveType<const_elem_iterator_imp> p(type);
434   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
435 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::active_type_elements_end (const \fBElemType\fPtype)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 654 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
655 {
656   Predicates::ActiveType<elem_iterator_imp> p(type);
657   return element_iterator(_elements\&.end(), _elements\&.end(), p);
658 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::active_type_elements_end (const \fBElemType\fPtype) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 878 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
879 {
880   Predicates::ActiveType<const_elem_iterator_imp> p(type);
881   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
882 }
.fi
.SS "\fBElem\fP * libMesh::ParallelMesh::add_elem (\fBElem\fP *e)\fC [virtual]\fP, \fC [inherited]\fP"
Add elem \fCe\fP to the end of the element array\&. To add an element locally, set e->\fBprocessor_id()\fP before adding it\&. To ensure a specific element id, call e->set_id() before adding it; only do this in parallel if you are manually keeping ids consistent\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 359 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_max_elem_id, libMesh::ParallelMesh::_n_elem, libMesh::ParallelMesh::_next_free_local_elem_id, libMesh::ParallelMesh::_next_free_unpartitioned_elem_id, libMesh::MeshBase::_next_unique_id, libMesh::ParallelObject::comm(), libMesh::DofObject::id(), libMesh::DofObject::invalid_processor_id, libMesh::ParallelMesh::is_serial(), libMesh::libmesh_assert(), std::max(), libMesh::Parallel::Communicator::max(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::DofObject::set_id(), libMesh::DofObject::set_unique_id(), libMesh::DofObject::valid_id(), and libMesh::DofObject::valid_unique_id()\&.
.PP
Referenced by libMesh::ParallelMesh::add_extra_ghost_elem()\&.
.PP
.nf
360 {
361   // Don't try to add NULLs!
362   libmesh_assert(e);
363 
364   // Trying to add an existing element is a no-op
365   if (e->valid_id() && _elements[e->id()] == e)
366     return e;
367 
368   const processor_id_type elem_procid = e->processor_id();
369 
370   if (!e->valid_id())
371     {
372       // We should only be creating new ids past the end of the range
373       // of existing ids
374       libmesh_assert_greater_equal(_next_free_unpartitioned_elem_id,
375                                    _max_elem_id);
376       libmesh_assert_greater_equal(_next_free_local_elem_id, _max_elem_id);
377 
378       // Use the unpartitioned ids for unpartitioned elems,
379       // in serial, and temporarily for ghost elems
380       dof_id_type *next_id = &_next_free_unpartitioned_elem_id;
381       if (elem_procid == this->processor_id() &&
382           !this->is_serial())
383         next_id = &_next_free_local_elem_id;
384       e->set_id (*next_id);
385     }
386 
387   {
388     // Advance next_ids up high enough that each is pointing to an
389     // unused id and any subsequent increments will still point us
390     // to unused ids
391     _max_elem_id = std::max(_max_elem_id,
392                             static_cast<dof_id_type>(e->id()+1));
393 
394     if (_next_free_unpartitioned_elem_id < _max_elem_id)
395       _next_free_unpartitioned_elem_id =
396         ((_max_elem_id-1) / (this->n_processors() + 1) + 1) *
397         (this->n_processors() + 1) + this->n_processors();
398     if (_next_free_local_elem_id < _max_elem_id)
399       _next_free_local_elem_id =
400         ((_max_elem_id + this->n_processors() - 1) / (this->n_processors() + 1) + 1) *
401         (this->n_processors() + 1) + this->processor_id();
402 
403 #ifndef NDEBUG
404     // We need a const mapvector so we don't inadvertently create
405     // NULL entries when testing for non-NULL ones
406     const mapvector<Elem*,dof_id_type>& const_elements = _elements;
407 #endif
408     libmesh_assert(!const_elements[_next_free_unpartitioned_elem_id]);
409     libmesh_assert(!const_elements[_next_free_local_elem_id]);
410   }
411 
412   // Don't try to overwrite existing elems
413   libmesh_assert (!_elements[e->id()]);
414 
415   _elements[e->id()] = e;
416 
417   // Try to make the cached elem data more accurate
418   if (elem_procid == this->processor_id() ||
419       elem_procid == DofObject::invalid_processor_id)
420     _n_elem++;
421 
422 #ifdef LIBMESH_ENABLE_UNIQUE_ID
423   if (!e->valid_unique_id() && processor_id() == e->processor_id())
424     {
425       e->set_unique_id() = _next_unique_id;
426       _next_unique_id += this->n_processors();
427     }
428 #endif
429 
430   // Unpartitioned elems should be added on every processor
431   // And shouldn't be added in the same batch as ghost elems
432   // But we might be just adding on processor 0 to
433   // broadcast later
434 #if 0
435 #ifdef DEBUG
436   if (elem_procid == DofObject::invalid_processor_id)
437     {
438       dof_id_type elem_id = e->id();
439       this->comm()\&.max(elem_id);
440       libmesh_assert_equal_to (elem_id, e->id());
441     }
442 #endif
443 #endif
444 
445   return e;
446 }
.fi
.SS "void libMesh::ParallelMesh::add_extra_ghost_elem (\fBElem\fP *e)\fC [virtual]\fP, \fC [inherited]\fP"
Inserts the element \fIand\fP adds it to a list of elements not to get deleted by delete_remote_elements\&. This is handy for inserting off-processor elements that you want to keep track of on this processor\&. 
.PP
Definition at line 1282 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_extra_ghost_elems, and libMesh::ParallelMesh::add_elem()\&.
.PP
.nf
1283 {
1284   // First add the elem like normal
1285   add_elem(e);
1286 
1287   // Now add it to the set that won't be deleted when we call
1288   // delete_remote_elements()
1289   _extra_ghost_elems\&.insert(e);
1290 }
.fi
.SS "\fBNode\fP * libMesh::ParallelMesh::add_node (\fBNode\fP *n)\fC [virtual]\fP, \fC [inherited]\fP"
Add \fC\fBNode\fP\fP \fCn\fP to the end of the vertex array\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 523 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_max_node_id, libMesh::ParallelMesh::_n_nodes, libMesh::ParallelMesh::_next_free_local_node_id, libMesh::ParallelMesh::_next_free_unpartitioned_node_id, libMesh::MeshBase::_next_unique_id, libMesh::ParallelMesh::_nodes, libMesh::ParallelObject::comm(), libMesh::DofObject::id(), libMesh::DofObject::invalid_processor_id, libMesh::ParallelMesh::is_serial(), libMesh::libmesh_assert(), std::max(), libMesh::Parallel::Communicator::max(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::DofObject::set_id(), libMesh::DofObject::set_unique_id(), libMesh::DofObject::valid_id(), and libMesh::DofObject::valid_unique_id()\&.
.PP
Referenced by libMesh::ParallelMesh::add_point(), and libMesh::ParallelMesh::insert_node()\&.
.PP
.nf
524 {
525   // Don't try to add NULLs!
526   libmesh_assert(n);
527 
528   // Trying to add an existing node is a no-op
529   if (n->valid_id() && _nodes[n->id()] == n)
530     return n;
531 
532   const processor_id_type node_procid = n->processor_id();
533 
534   if (!n->valid_id())
535     {
536       // We should only be creating new ids past the end of the range
537       // of existing ids
538       libmesh_assert_greater_equal(_next_free_unpartitioned_node_id,
539                                    _max_node_id);
540       libmesh_assert_greater_equal(_next_free_local_node_id, _max_node_id);
541 
542       // Use the unpartitioned ids for unpartitioned nodes,
543       // in serial, and temporarily for ghost nodes
544       dof_id_type *next_id = &_next_free_unpartitioned_node_id;
545       if (node_procid == this->processor_id() &&
546           !this->is_serial())
547         next_id = &_next_free_local_node_id;
548       n->set_id (*next_id);
549     }
550 
551   {
552     // Advance next_ids up high enough that each is pointing to an
553     // unused id and any subsequent increments will still point us
554     // to unused ids
555     _max_node_id = std::max(_max_node_id,
556                             static_cast<dof_id_type>(n->id()+1));
557 
558     if (_next_free_unpartitioned_node_id < _max_node_id)
559       _next_free_unpartitioned_node_id =
560         ((_max_node_id-1) / (this->n_processors() + 1) + 1) *
561         (this->n_processors() + 1) + this->n_processors();
562     if (_next_free_local_node_id < _max_node_id)
563       _next_free_local_node_id =
564         ((_max_node_id + this->n_processors() - 1) / (this->n_processors() + 1) + 1) *
565         (this->n_processors() + 1) + this->processor_id();
566 
567 #ifndef NDEBUG
568     // We need a const mapvector so we don't inadvertently create
569     // NULL entries when testing for non-NULL ones
570     const mapvector<Node*,dof_id_type>& const_nodes = _nodes;
571 #endif
572     libmesh_assert(!const_nodes[_next_free_unpartitioned_node_id]);
573     libmesh_assert(!const_nodes[_next_free_local_node_id]);
574   }
575 
576   // Don't try to overwrite existing nodes
577   libmesh_assert (!_nodes[n->id()]);
578 
579   _nodes[n->id()] = n;
580 
581   // Try to make the cached node data more accurate
582   if (node_procid == this->processor_id() ||
583       node_procid == DofObject::invalid_processor_id)
584     _n_nodes++;
585 
586 #ifdef LIBMESH_ENABLE_UNIQUE_ID
587   if (!n->valid_unique_id() && processor_id() == n->processor_id())
588     {
589       n->set_unique_id() = _next_unique_id;
590       _next_unique_id += this->n_processors();
591     }
592 #endif
593 
594 
595   // Unpartitioned nodes should be added on every processor
596   // And shouldn't be added in the same batch as ghost nodes
597   // But we might be just adding on processor 0 to
598   // broadcast later
599 #if 0
600 #ifdef DEBUG
601   if (node_procid == DofObject::invalid_processor_id)
602     {
603       dof_id_type node_id = n->id();
604       this->comm()\&.max(node_id);
605       libmesh_assert_equal_to (node_id, n->id());
606     }
607 #endif
608 #endif
609 
610   return n;
611 }
.fi
.SS "\fBNode\fP * libMesh::ParallelMesh::add_point (const \fBPoint\fP &p, const \fBdof_id_type\fPid = \fC\fBDofObject::invalid_id\fP\fP, const \fBprocessor_id_type\fPproc_id = \fC\fBDofObject::invalid_processor_id\fP\fP)\fC [virtual]\fP, \fC [inherited]\fP"
functions for adding /deleting nodes elements\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 499 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::ParallelMesh::add_node(), libMesh::Node::build(), libMesh::DofObject::id(), libMesh::libmesh_assert(), and libMesh::DofObject::processor_id()\&.
.PP
.nf
502 {
503   if (_nodes\&.count(id))
504     {
505       Node *n = _nodes[id];
506       libmesh_assert (n);
507       libmesh_assert_equal_to (n->id(), id);
508 
509       *n = p;
510       n->processor_id() = proc_id;
511 
512       return n;
513     }
514 
515   Node* n = Node::build(p, id)\&.release();
516   n->processor_id() = proc_id;
517 
518   return ParallelMesh::add_node(n);
519 }
.fi
.SS "void libMesh::UnstructuredMesh::all_first_order ()\fC [virtual]\fP, \fC [inherited]\fP"
Converts a mesh with higher-order elements into a mesh with linear elements\&. For example, a mesh consisting of \fC\fBTet10\fP\fP will be converted to a mesh with \fC\fBTet4\fP\fP etc\&. Prepare to identify (and then delete) a bunch of no-longer-used nodes\&.
.PP
Loop over the high-ordered elements\&. First make sure they \fIare\fP indeed high-order, and then replace them with an equivalent first-order element\&.
.PP
If the second order element had any boundary conditions they should be transfered to the first-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 292 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::Elem::add_child(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::delete_node(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::Elem::first_order_equivalent_type(), libMesh::Elem::get_node(), libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::libmesh_assert(), libMesh::MeshBase::max_node_id(), libMesh::Elem::n_children(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_level(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::Elem::replace_child(), libMesh::DofObject::set_id(), libMesh::Elem::set_neighbor(), libMesh::Elem::set_node(), libMesh::Partitioner::set_node_processor_ids(), libMesh::Elem::set_p_level(), libMesh::Elem::set_p_refinement_flag(), libMesh::Elem::set_parent(), libMesh::Elem::set_refinement_flag(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
.nf
293 {
294   /*
295    * when the mesh is not prepared,
296    * at least renumber the nodes and
297    * elements, so that the node ids
298    * are correct
299    */
300   if (!this->_is_prepared)
301     this->renumber_nodes_and_elements ();
302 
303   START_LOG("all_first_order()", "Mesh");
304 
308   std::vector<bool> node_touched_by_me(this->max_node_id(), false);
309 
315   element_iterator endit = elements_end();
316   for (element_iterator it = elements_begin();
317        it != endit; ++it)
318     {
319       Elem* so_elem = *it;
320 
321       libmesh_assert(so_elem);
322 
323       /*
324        * build the first-order equivalent, add to
325        * the new_elements list\&.
326        */
327       Elem* lo_elem = Elem::build
328         (Elem::first_order_equivalent_type
329          (so_elem->type()), so_elem->parent())\&.release();
330 
331       for (unsigned int s=0; s != so_elem->n_sides(); ++s)
332         if (so_elem->neighbor(s) == remote_elem)
333           lo_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
334 
335 #ifdef LIBMESH_ENABLE_AMR
336       /*
337        * Reset the parent links of any child elements
338        */
339       if (so_elem->has_children())
340         for (unsigned int c=0; c != so_elem->n_children(); ++c)
341           {
342             so_elem->child(c)->set_parent(lo_elem);
343             lo_elem->add_child(so_elem->child(c), c);
344           }
345 
346       /*
347        * Reset the child link of any parent element
348        */
349       if (so_elem->parent())
350         {
351           unsigned int c =
352             so_elem->parent()->which_child_am_i(so_elem);
353           lo_elem->parent()->replace_child(lo_elem, c);
354         }
355 
356       /*
357        * Copy as much data to the new element as makes sense
358        */
359       lo_elem->set_p_level(so_elem->p_level());
360       lo_elem->set_refinement_flag(so_elem->refinement_flag());
361       lo_elem->set_p_refinement_flag(so_elem->p_refinement_flag());
362 #endif
363 
364       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
365 
366       /*
367        * By definition the vertices of the linear and
368        * second order element are identically numbered\&.
369        * transfer these\&.
370        */
371       for (unsigned int v=0; v < so_elem->n_vertices(); v++)
372         {
373           lo_elem->set_node(v) = so_elem->get_node(v);
374           node_touched_by_me[lo_elem->node(v)] = true;
375         }
376 
383       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
384 
385       for (unsigned int s=0; s<so_elem->n_sides(); s++)
386         {
387           const std::vector<boundary_id_type> boundary_ids =
388             this->boundary_info->raw_boundary_ids (so_elem, s);
389 
390           this->boundary_info->add_side (lo_elem, s, boundary_ids);
391         }
392 
393       /*
394        * The new first-order element is ready\&.
395        * Inserting it into the mesh will replace and delete
396        * the second-order element\&.
397        */
398       lo_elem->set_id(so_elem->id());
399       lo_elem->processor_id() = so_elem->processor_id();
400       lo_elem->subdomain_id() = so_elem->subdomain_id();
401       this->insert_elem(lo_elem);
402     }
403 
404   const MeshBase::node_iterator nd_end = this->nodes_end();
405   MeshBase::node_iterator nd = this->nodes_begin();
406   while (nd != nd_end)
407     {
408       Node *the_node = *nd;
409       ++nd;
410       if (!node_touched_by_me[the_node->id()])
411         this->delete_node(the_node);
412     }
413 
414   STOP_LOG("all_first_order()", "Mesh");
415 
416   // On hanging nodes that used to also be second order nodes, we
417   // might now have an invalid nodal processor_id()
418   Partitioner::set_node_processor_ids(*this);
419 
420   // delete or renumber nodes, etc
421   this->prepare_for_use(/*skip_renumber =*/ false);
422 }
.fi
.SS "void libMesh::UnstructuredMesh::all_second_order (const boolfull_ordered = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Converts a (conforming, non-refined) mesh with linear elements into a mesh with second-order elements\&. For example, a mesh consisting of \fC\fBTet4\fP\fP will be converted to a mesh with \fC\fBTet10\fP\fP etc\&. Note that for some elements like \fC\fBHex8\fP\fP there exist \fItwo\fP higher order equivalents, \fC\fBHex20\fP\fP and \fC\fBHex27\fP\fP\&. When \fCfull_ordered\fP is \fCtrue\fP (default), then \fC\fBHex27\fP\fP is built\&. Otherwise, \fC\fBHex20\fP\fP is built\&. The same holds obviously for \fC\fBQuad4\fP\fP, \fC\fBPrism6\fP\fP \&.\&.\&. Loop over the low-ordered elements in the \fIelements vector\&. First make sure they _are\fP indeed low-order, and then replace them with an equivalent second-order element\&. Don't forget to delete the low-order element, or else it will leak!
.PP
If the linear element had any boundary conditions they should be transfered to the second-order element\&. The old boundary conditions will be removed from the \fBBoundaryInfo\fP data structure by insert_elem\&.
.PP
Also, \fBprepare_for_use()\fP will reconstruct most of our neighbor links, but if we have any remote_elem links in a distributed mesh, they need to be preserved\&. We do that in the same loop here\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 426 of file mesh_modification\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::add_point(), libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::ParallelObject::comm(), libMesh::Elem::default_order(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), libMesh::err, libMesh::FIRST, libMesh::Elem::get_node(), libMesh::DofObject::id(), libMesh::MeshBase::insert_elem(), libMesh::DofObject::invalid_id, libMesh::MeshBase::is_serial(), libMesh::Elem::level(), libMesh::libmesh_assert(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::n_vertices(), libMesh::Elem::neighbor(), libMesh::MeshBase::node(), libMesh::MeshBase::point(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::Real, libMesh::remote_elem, libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::reserve_nodes(), libMesh::Elem::second_order_equivalent_type(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube()\&.
.PP
.nf
427 {
428   // This function must be run on all processors at once
429   parallel_object_only();
430 
431   /*
432    * when the mesh is not prepared,
433    * at least renumber the nodes and
434    * elements, so that the node ids
435    * are correct
436    */
437   if (!this->_is_prepared)
438     this->renumber_nodes_and_elements ();
439 
440   /*
441    * If the mesh is empty
442    * then we have nothing to do
443    */
444   if (!this->n_elem())
445     return;
446 
447   /*
448    * If the mesh is already second order
449    * then we have nothing to do\&.
450    * We have to test for this in a round-about way to avoid
451    * a bug on distributed parallel meshes with more processors
452    * than elements\&.
453    */
454   bool already_second_order = false;
455   if (this->elements_begin() != this->elements_end() &&
456       (*(this->elements_begin()))->default_order() != FIRST)
457     already_second_order = true;
458   this->comm()\&.max(already_second_order);
459   if (already_second_order)
460     return;
461 
462   START_LOG("all_second_order()", "Mesh");
463 
464   /*
465    * this map helps in identifying second order
466    * nodes\&.  Namely, a second-order node:
467    * - edge node
468    * - face node
469    * - bubble node
470    * is uniquely defined through a set of adjacent
471    * vertices\&.  This set of adjacent vertices is
472    * used to identify already added higher-order
473    * nodes\&.  We are safe to use node id's since we
474    * make sure that these are correctly numbered\&.
475    */
476   std::map<std::vector<dof_id_type>, Node*> adj_vertices_to_so_nodes;
477 
478   /*
479    * for speed-up of the \p add_point() method, we
480    * can reserve memory\&.  Guess the number of additional
481    * nodes for different dimensions
482    */
483   switch (this->mesh_dimension())
484     {
485     case 1:
486       /*
487        * in 1D, there can only be order-increase from Edge2
488        * to Edge3\&.  Something like 1/2 of n_nodes() have
489        * to be added
490        */
491       this->reserve_nodes(static_cast<unsigned int>
492                           (1\&.5*static_cast<double>(this->n_nodes())));
493       break;
494 
495     case 2:
496       /*
497        * in 2D, either refine from Tri3 to Tri6 (double the nodes)
498        * or from Quad4 to Quad8 (again, double) or Quad9 (2\&.25 that much)
499        */
500       this->reserve_nodes(static_cast<unsigned int>
501                           (2*static_cast<double>(this->n_nodes())));
502       break;
503 
504 
505     case 3:
506       /*
507        * in 3D, either refine from Tet4 to Tet10 (factor = 2\&.5) up to
508        * Hex8 to Hex27 (something  > 3)\&.  Since in 3D there _are_ already
509        * quite some nodes, and since we do not want to overburden the memory by
510        * a too conservative guess, use the lower bound
511        */
512       this->reserve_nodes(static_cast<unsigned int>
513                           (2\&.5*static_cast<double>(this->n_nodes())));
514       break;
515 
516     default:
517       // Hm?
518       libmesh_error();
519     }
520 
521 
522 
523   /*
524    * form a vector that will hold the node id's of
525    * the vertices that are adjacent to the son-th
526    * second-order node\&.  Pull this outside of the
527    * loop so that silly compilers don't repeatedly
528    * create and destroy the vector\&.
529    */
530   std::vector<dof_id_type> adjacent_vertices_ids;
531 
538   const_element_iterator endit = elements_end();
539   for (const_element_iterator it = elements_begin();
540        it != endit; ++it)
541     {
542       // the linear-order element
543       const Elem* lo_elem = *it;
544 
545       libmesh_assert(lo_elem);
546 
547       // make sure it is linear order
548       if (lo_elem->default_order() != FIRST)
549         {
550           libMesh::err << "ERROR: This is not a linear element: type="
551                        << lo_elem->type() << std::endl;
552           libmesh_error();
553         }
554 
555       // this does _not_ work for refined elements
556       libmesh_assert_equal_to (lo_elem->level (), 0);
557 
558       /*
559        * build the second-order equivalent, add to
560        * the new_elements list\&.  Note that this here
561        * is the only point where \p full_ordered
562        * is necessary\&.  The remaining code works well
563        * for either type of seconrd-order equivalent, e\&.g\&.
564        * Hex20 or Hex27, as equivalents for Hex8
565        */
566       Elem* so_elem =
567         Elem::build (Elem::second_order_equivalent_type(lo_elem->type(),
568                                                         full_ordered) )\&.release();
569 
570       libmesh_assert_equal_to (lo_elem->n_vertices(), so_elem->n_vertices());
571 
572 
573       /*
574        * By definition the vertices of the linear and
575        * second order element are identically numbered\&.
576        * transfer these\&.
577        */
578       for (unsigned int v=0; v < lo_elem->n_vertices(); v++)
579         so_elem->set_node(v) = lo_elem->get_node(v);
580 
581       /*
582        * Now handle the additional mid-side nodes\&.  This
583        * is simply handled through a map that remembers
584        * the already-added nodes\&.  This map maps the global
585        * ids of the vertices (that uniquely define this
586        * higher-order node) to the new node\&.
587        * Notation: son = second-order node
588        */
589       const unsigned int son_begin = so_elem->n_vertices();
590       const unsigned int son_end   = so_elem->n_nodes();
591 
592 
593       for (unsigned int son=son_begin; son<son_end; son++)
594         {
595           const unsigned int n_adjacent_vertices =
596             so_elem->n_second_order_adjacent_vertices(son);
597 
598           adjacent_vertices_ids\&.resize(n_adjacent_vertices);
599 
600           for (unsigned int v=0; v<n_adjacent_vertices; v++)
601             adjacent_vertices_ids[v] =
602               so_elem->node( so_elem->second_order_adjacent_vertex(son,v) );
603 
604           /*
605            * \p adjacent_vertices_ids is now in order of the current
606            * side\&.  sort it, so that comparisons  with the
607            * \p adjacent_vertices_ids created through other elements'
608            * sides can match
609            */
610           std::sort(adjacent_vertices_ids\&.begin(),
611                     adjacent_vertices_ids\&.end());
612 
613 
614           // does this set of vertices already has a mid-node added?
615           std::pair<std::map<std::vector<dof_id_type>, Node*>::iterator,
616             std::map<std::vector<dof_id_type>, Node*>::iterator>
617             pos = adj_vertices_to_so_nodes\&.equal_range (adjacent_vertices_ids);
618 
619           // no, not added yet
620           if (pos\&.first == pos\&.second)
621             {
622               /*
623                * for this set of vertices, there is no
624                * second_order node yet\&.  Add it\&.
625                *
626                * compute the location of the new node as
627                * the average over the adjacent vertices\&.
628                */
629               Point new_location = this->point(adjacent_vertices_ids[0]);
630               for (unsigned int v=1; v<n_adjacent_vertices; v++)
631                 new_location += this->point(adjacent_vertices_ids[v]);
632 
633               new_location /= static_cast<Real>(n_adjacent_vertices);
634 
635               /* Add the new point to the mesh, giving it a globally
636                * well-defined processor id\&.
637                */
638               Node* so_node = this->add_point
639                 (new_location, DofObject::invalid_id,
640                  this->node(adjacent_vertices_ids[0])\&.processor_id());
641 
642               /*
643                * insert the new node with its defining vertex
644                * set into the map, and relocate pos to this
645                * new entry, so that the so_elem can use
646                * \p pos for inserting the node
647                */
648               adj_vertices_to_so_nodes\&.insert(pos\&.first,
649                                               std::make_pair(adjacent_vertices_ids,
650                                                              so_node));
651 
652               so_elem->set_node(son) = so_node;
653             }
654           // yes, already added\&.
655           else
656             {
657               libmesh_assert(pos\&.first->second);
658 
659               so_elem->set_node(son) = pos\&.first->second;
660             }
661         }
662 
663 
675       libmesh_assert_equal_to (lo_elem->n_sides(), so_elem->n_sides());
676 
677       for (unsigned int s=0; s<lo_elem->n_sides(); s++)
678         {
679           const std::vector<boundary_id_type> boundary_ids =
680             this->boundary_info->raw_boundary_ids (lo_elem, s);
681 
682           this->boundary_info->add_side (so_elem, s, boundary_ids);
683 
684           if (lo_elem->neighbor(s) == remote_elem)
685             so_elem->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
686         }
687 
688       /*
689        * The new second-order element is ready\&.
690        * Inserting it into the mesh will replace and delete
691        * the first-order element\&.
692        */
693       so_elem->set_id(lo_elem->id());
694       so_elem->processor_id() = lo_elem->processor_id();
695       so_elem->subdomain_id() = lo_elem->subdomain_id();
696       this->insert_elem(so_elem);
697     }
698 
699   // we can clear the map
700   adj_vertices_to_so_nodes\&.clear();
701 
702 
703   STOP_LOG("all_second_order()", "Mesh");
704 
705   // In a ParallelMesh our ghost node processor ids may be bad and
706   // the ids of nodes touching remote elements may be inconsistent\&.
707   // Fix them\&.
708   if (!this->is_serial())
709     {
710       LocationMap<Node> loc_map;
711       MeshCommunication()\&.make_nodes_parallel_consistent
712         (*this, loc_map);
713     }
714 
715   // renumber nodes, elements etc
716   this->prepare_for_use(/*skip_renumber =*/ false);
717 }
.fi
.SS "void libMesh::ParallelMesh::allgather ()\fC [virtual]\fP, \fC [inherited]\fP"
Gathers all elements and nodes of the mesh onto every processor 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1293 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_is_serial, libMesh::MeshCommunication::allgather(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids(), libMesh::ParallelMesh::max_elem_id(), libMesh::ParallelMesh::max_node_id(), libMesh::ParallelMesh::n_elem(), libMesh::ParallelMesh::n_nodes(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), and libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
1294 {
1295   if (_is_serial)
1296     return;
1297   _is_serial = true;
1298   MeshCommunication()\&.allgather(*this);
1299 
1300   // Make sure our caches are up to date and our
1301   // DofObjects are well packed
1302 #ifdef DEBUG
1303   libmesh_assert_equal_to (this->n_nodes(), this->parallel_n_nodes());
1304   libmesh_assert_equal_to (this->n_elem(), this->parallel_n_elem());
1305   const dof_id_type pmax_node_id = this->parallel_max_node_id();
1306   const dof_id_type pmax_elem_id = this->parallel_max_elem_id();
1307   libmesh_assert_equal_to (this->max_node_id(), pmax_node_id);
1308   libmesh_assert_equal_to (this->max_elem_id(), pmax_elem_id);
1309 
1310   // If we've disabled renumbering we can't be sure we're contiguous
1311   // libmesh_assert_equal_to (this->n_nodes(), this->max_node_id());
1312   // libmesh_assert_equal_to (this->n_elem(), this->max_elem_id());
1313 
1314   // Make sure our neighbor links are all fine
1315   MeshTools::libmesh_assert_valid_neighbors(*this);
1316 
1317   // Make sure our ids and flags are consistent
1318   this->libmesh_assert_valid_parallel_ids();
1319   this->libmesh_assert_valid_parallel_flags();
1320 #endif
1321 }
.fi
.SS "void libMesh::MeshBase::allow_renumbering (boolallow)\fC [inline]\fP, \fC [inherited]\fP"
If false is passed in then this mesh will no longer be renumbered when being prepared for use\&. This may slightly adversely affect performance during subsequent element access, particulary when using a distributed mesh\&. 
.PP
Definition at line 536 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::AdjointRefinementEstimator::estimate_error(), and libMesh::ErrorVector::plot_error()\&.
.PP
.nf
536 { _skip_renumber_nodes_and_elements = !allow; }
.fi
.SS "bool libMesh::MeshBase::allow_renumbering () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 537 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_renumber_nodes_and_elements\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use(), and libMesh::UnstructuredMesh::read()\&.
.PP
.nf
537 { return !_skip_renumber_nodes_and_elements; }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::ancestor_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 67 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
68 {
69   Predicates::Ancestor<elem_iterator_imp> p;
70   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
71 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::ancestor_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 291 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
292 {
293   Predicates::Ancestor<const_elem_iterator_imp> p;
294   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
295 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::ancestor_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 514 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
515 {
516   Predicates::Ancestor<elem_iterator_imp> p;
517   return element_iterator(_elements\&.end(), _elements\&.end(), p);
518 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::ancestor_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 739 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
740 {
741   Predicates::Ancestor<const_elem_iterator_imp> p;
742   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
743 }
.fi
.SS "void libMesh::ParallelMesh::assign_unique_ids ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Assign globally unique IDs to all DOF objects (Elements and Nodes) if the library has been configured with unique_id support\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1324 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::MeshBase::_next_unique_id, libMesh::ParallelMesh::_nodes, end, libMesh::ParallelObject::n_processors(), and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
1325 {
1326   {
1327     elem_iterator_imp        it = _elements\&.begin();
1328     const elem_iterator_imp end = _elements\&.end();
1329 
1330     for (; it != end; ++it)
1331       if ((*it) && ! (*it)->valid_unique_id() && processor_id() == (*it)->processor_id())
1332         {
1333           (*it)->set_unique_id() = _next_unique_id;
1334           _next_unique_id += this->n_processors();
1335         }
1336   }
1337 
1338   {
1339     node_iterator_imp it  = _nodes\&.begin();
1340     node_iterator_imp end = _nodes\&.end();
1341 
1342     for (; it != end; ++it)
1343       if ((*it) && ! (*it)->valid_unique_id() && processor_id() == (*it)->processor_id())
1344         {
1345           (*it)->set_unique_id() = _next_unique_id;
1346           _next_unique_id += this->n_processors();
1347         }
1348   }
1349 }
.fi
.SS "void libMesh::ParallelMesh::clear ()\fC [virtual]\fP, \fC [inherited]\fP"
Clear all internal data\&. 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 660 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_is_serial, libMesh::ParallelMesh::_max_elem_id, libMesh::ParallelMesh::_max_node_id, libMesh::ParallelMesh::_n_elem, libMesh::ParallelMesh::_n_nodes, libMesh::ParallelMesh::_next_free_local_elem_id, libMesh::ParallelMesh::_next_free_local_node_id, libMesh::ParallelMesh::_next_free_unpartitioned_elem_id, libMesh::ParallelMesh::_next_free_unpartitioned_node_id, libMesh::ParallelMesh::_nodes, libMesh::MeshBase::clear(), end, libMesh::ParallelObject::n_processors(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::BoundaryMesh::~BoundaryMesh(), and libMesh::ParallelMesh::~ParallelMesh()\&.
.PP
.nf
661 {
662   // Call parent clear function
663   MeshBase::clear();
664 
665 
666   // Clear our elements and nodes
667   {
668     elem_iterator_imp        it = _elements\&.begin();
669     const elem_iterator_imp end = _elements\&.end();
670 
671     // There is no need to remove the elements from
672     // the BoundaryInfo data structure since we
673     // already cleared it\&.
674     for (; it != end; ++it)
675       delete *it;
676 
677     _elements\&.clear();
678   }
679 
680   // clear the nodes data structure
681   {
682     node_iterator_imp it  = _nodes\&.begin();
683     node_iterator_imp end = _nodes\&.end();
684 
685     // There is no need to remove the nodes from
686     // the BoundaryInfo data structure since we
687     // already cleared it\&.
688     for (; it != end; ++it)
689       delete *it;
690 
691     _nodes\&.clear();
692   }
693 
694   // We're no longer distributed if we were before
695   _is_serial = true;
696 
697   // Correct our caches
698   _n_nodes = 0;
699   _n_elem = 0;
700   _max_node_id = 0;
701   _max_elem_id = 0;
702   _next_free_local_node_id = this->processor_id();
703   _next_free_local_elem_id = this->processor_id();
704   _next_free_unpartitioned_node_id = this->n_processors();
705   _next_free_unpartitioned_elem_id = this->n_processors();
706 }
.fi
.SS "virtual void libMesh::ParallelMesh::clear_extra_ghost_elems ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Clears extra ghost elements\&. 
.PP
Definition at line 179 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_extra_ghost_elems\&.
.PP
.nf
179 { _extra_ghost_elems\&.clear(); }
.fi
.SS "void libMesh::MeshBase::clear_point_locator ()\fC [inherited]\fP"
Releases the current \fCPointLocator\fP object\&. 
.PP
Definition at line 415 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator\&.
.PP
Referenced by libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::contract(), and libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
416 {
417   _point_locator\&.reset(NULL);
418 }
.fi
.SS "virtual \fBAutoPtr\fP<\fBMeshBase\fP> libMesh::ParallelMesh::clone () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Virtual copy-constructor, creates a copy of this mesh 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 88 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::ParallelMesh()\&.
.PP
.nf
89   { return AutoPtr<MeshBase>(new ParallelMesh(*this)); }
.fi
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::comm () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a reference to the \fC\fBParallel::Communicator\fP\fP object used by this mesh\&. 
.RE
.PP

.PP
Definition at line 86 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator\&.
.PP
Referenced by libMesh::__libmesh_petsc_diff_solver_monitor(), libMesh::__libmesh_petsc_diff_solver_residual(), libMesh::__libmesh_petsc_snes_residual(), libMesh::MeshRefinement::_coarsen_elements(), libMesh::ExactSolution::_compute_error(), libMesh::MetisPartitioner::_do_partition(), libMesh::ParmetisPartitioner::_do_repartition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_get_diagonal(), libMesh::SlepcEigenSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult(), libMesh::PetscLinearSolver< T >::_petsc_shell_matrix_mult_add(), libMesh::EquationSystems::_read_impl(), libMesh::MeshRefinement::_refine_elements(), libMesh::ParallelMesh::add_elem(), libMesh::ImplicitSystem::add_matrix(), libMesh::ParallelMesh::add_node(), libMesh::System::add_vector(), libMesh::UnstructuredMesh::all_second_order(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::FEMSystem::assemble_qoi(), libMesh::MeshCommunication::assign_global_indices(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::DofMap::attach_matrix(), libMesh::MeshTools::bounding_box(), libMesh::System::calculate_norm(), libMesh::MeshRefinement::coarsen_elements(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Problem_Interface::computeF(), libMesh::Problem_Interface::computeJacobian(), libMesh::Problem_Interface::computePreconditioner(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::DofMap::distribute_dofs(), DMlibMeshFunction(), DMLibMeshSetSystem(), DMVariableBounds_libMesh(), libMesh::MeshRefinement::eliminate_unrefined_patches(), libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error(), libMesh::PatchRecoveryErrorEstimator::estimate_error(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::for(), libMesh::CondensedEigenSystem::get_eigenpair(), libMesh::ImplicitSystem::get_linear_solver(), libMesh::LocationMap< T >::init(), libMesh::TimeSolver::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::EigenSystem::init_data(), libMesh::EigenSystem::init_matrices(), libMesh::ParmetisPartitioner::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::MeshRefinement::limit_level_mismatch_at_edge(), libMesh::MeshRefinement::limit_level_mismatch_at_node(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshCommunication::make_elems_parallel_consistent(), libMesh::MeshRefinement::make_flags_parallel_consistent(), libMesh::MeshCommunication::make_node_ids_parallel_consistent(), libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent(), libMesh::MeshCommunication::make_nodes_parallel_consistent(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::FEMSystem::mesh_position_set(), libMesh::MeshSerializer::MeshSerializer(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshTools::n_active_levels(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::CondensedEigenSystem::n_global_non_condensed_dofs(), libMesh::MeshTools::n_levels(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::MeshTools::n_p_levels(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::Partitioner::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::petsc_auto_fieldsplit(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshBase::prepare_for_use(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::XdrIO::read(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshBase::subdomain_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshRefinement::test_level_one(), libMesh::MeshRefinement::test_unflagged(), libMesh::MeshTools::total_weight(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), and libMesh::DivaIO::write_stream()\&.
.PP
.nf
87   { return _communicator; }
.fi
.SS "bool libMesh::UnstructuredMesh::contract ()\fC [virtual]\fP, \fC [inherited]\fP"
Delete subactive (i\&.e\&. children of coarsened) elements\&. This removes all elements descended from currently active elements in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1131 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::MeshBase::clear_point_locator(), libMesh::Elem::contract(), libMesh::MeshBase::delete_elem(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::libmesh_assert(), libMesh::Elem::parent(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::Elem::subactive()\&.
.PP
.nf
1132 {
1133   START_LOG ("contract()", "Mesh");
1134 
1135   // Flag indicating if this call actually changes the mesh
1136   bool mesh_changed = false;
1137 
1138   element_iterator in        = elements_begin();
1139   const element_iterator end = elements_end();
1140 
1141 #ifdef DEBUG
1142   for ( ; in != end; ++in)
1143     if (*in != NULL)
1144       {
1145         Elem* el = *in;
1146         libmesh_assert(el->active() || el->subactive() || el->ancestor());
1147       }
1148   in = elements_begin();
1149 #endif
1150 
1151   // Loop over the elements\&.
1152   for ( ; in != end; ++in)
1153     if (*in != NULL)
1154       {
1155         Elem* el = *in;
1156 
1157         // Delete all the subactive ones
1158         if (el->subactive())
1159           {
1160             // No level-0 element should be subactive\&.
1161             // Note that we CAN'T test elem->level(), as that
1162             // touches elem->parent()->dim(), and elem->parent()
1163             // might have already been deleted!
1164             libmesh_assert(el->parent());
1165 
1166             // Delete the element
1167             // This just sets a pointer to NULL, and doesn't
1168             // invalidate any iterators
1169             this->delete_elem(el);
1170 
1171             // the mesh has certainly changed
1172             mesh_changed = true;
1173           }
1174         else
1175           {
1176             // Compress all the active ones
1177             if (el->active())
1178               el->contract();
1179             else
1180               libmesh_assert (el->ancestor());
1181           }
1182       }
1183 
1184   // Strip any newly-created NULL voids out of the element array
1185   this->renumber_nodes_and_elements();
1186 
1187   // FIXME: Need to understand why deleting subactive children
1188   // invalidates the point locator\&.  For now we will clear it explicitly
1189   this->clear_point_locator();
1190 
1191   STOP_LOG ("contract()", "Mesh");
1192 
1193   return mesh_changed;
1194 }
.fi
.SS "void libMesh::UnstructuredMesh::copy_nodes_and_elements (const \fBUnstructuredMesh\fP &other_mesh, const boolskip_find_neighbors = \fCfalse\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Deep copy of another unstructured mesh class (used by subclass copy constructors) 
.PP
Definition at line 104 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_n_parts, libMesh::Elem::add_child(), libMesh::MeshBase::allow_renumbering(), libMesh::Elem::build(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::Elem::has_children(), libMesh::DofObject::id(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::Elem::n_children(), libMesh::MeshBase::n_elem(), libMesh::Elem::n_neighbors(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::neighbor(), libMesh::Elem::node(), libMesh::MeshBase::nodes_begin(), libMesh::MeshBase::nodes_end(), libMesh::Elem::p_refinement_flag(), libMesh::Elem::parent(), libMesh::DofObject::processor_id(), libMesh::Elem::refinement_flag(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::MeshBase::skip_partitioning(), libMesh::Elem::subdomain_id(), libMesh::Elem::type(), and libMesh::Elem::which_child_am_i()\&.
.PP
Referenced by libMesh::ParallelMesh::ParallelMesh(), libMesh::SerialMesh::SerialMesh(), and libMesh::SerialMesh::stitching_helper()\&.
.PP
.nf
105 {
106   // We're assuming our subclass data needs no copy
107   libmesh_assert_equal_to (_n_parts, other_mesh\&._n_parts);
108   libmesh_assert_equal_to (_dim, other_mesh\&._dim);
109   libmesh_assert_equal_to (_is_prepared, other_mesh\&._is_prepared);
110 
111   // We're assuming the other mesh has proper element number ordering,
112   // so that we add parents before their children\&.
113 #ifdef DEBUG
114   MeshTools::libmesh_assert_valid_amr_elem_ids(other_mesh);
115 #endif
116 
117   //Copy in Nodes
118   {
119     //Preallocate Memory if necessary
120     this->reserve_nodes(other_mesh\&.n_nodes());
121 
122     const_node_iterator it = other_mesh\&.nodes_begin();
123     const_node_iterator end = other_mesh\&.nodes_end();
124 
125     for (; it != end; ++it)
126       {
127         const Node *oldn = *it;
128 
129         // Add new nodes in old node Point locations
130         /*Node *newn =*/ this->add_point(*oldn, oldn->id(), oldn->processor_id());
131 
132         // And start them off in the same subdomain
133         //        newn->processor_id() = oldn->processor_id();
134       }
135   }
136 
137   //Copy in Elements
138   {
139     //Preallocate Memory if necessary
140     this->reserve_elem(other_mesh\&.n_elem());
141 
142     // Declare a map linking old and new elements, needed to copy the neighbor lists
143     std::map<const Elem*, Elem*> old_elems_to_new_elems;
144 
145     // Loop over the elements
146     MeshBase::const_element_iterator it = other_mesh\&.elements_begin();
147     const MeshBase::const_element_iterator end = other_mesh\&.elements_end();
148 
149     // FIXME: Where do we set element IDs??
150     for (; it != end; ++it)
151       {
152         //Look at the old element
153         const Elem *old = *it;
154         //Build a new element
155         Elem *newparent = old->parent() ?
156           this->elem(old->parent()->id()) : NULL;
157         AutoPtr<Elem> ap = Elem::build(old->type(), newparent);
158         Elem * el = ap\&.release();
159 
160         el->subdomain_id() = old->subdomain_id();
161 
162         for (unsigned int s=0; s != old->n_sides(); ++s)
163           if (old->neighbor(s) == remote_elem)
164             el->set_neighbor(s, const_cast<RemoteElem*>(remote_elem));
165 
166 #ifdef LIBMESH_ENABLE_AMR
167         if (old->has_children())
168           for (unsigned int c=0; c != old->n_children(); ++c)
169             if (old->child(c) == remote_elem)
170               el->add_child(const_cast<RemoteElem*>(remote_elem), c);
171 
172         //Create the parent's child pointers if necessary
173         if (newparent)
174           {
175             unsigned int oldc = old->parent()->which_child_am_i(old);
176             newparent->add_child(el, oldc);
177           }
178 
179         // Copy the refinement flags
180         el->set_refinement_flag(old->refinement_flag());
181         el->set_p_refinement_flag(old->p_refinement_flag());
182 #endif // #ifdef LIBMESH_ENABLE_AMR
183 
184         //Assign all the nodes
185         for(unsigned int i=0;i<el->n_nodes();i++)
186           el->set_node(i) = &this->node(old->node(i));
187 
188         // And start it off in the same subdomain
189         el->processor_id() = old->processor_id();
190 
191         // Give it the same id
192         el->set_id(old->id());
193 
194         //Hold onto it
195         if(!skip_find_neighbors)
196           {
197             this->add_elem(el);
198           }
199         else
200           {
201             Elem* new_el = this->add_elem(el);
202             old_elems_to_new_elems[old] = new_el;
203           }
204 
205         // Add the link between the original element and this copy to the map
206         if(skip_find_neighbors)
207           old_elems_to_new_elems[old] = el;
208       }
209 
210     // Loop (again) over the elements to fill in the neighbors
211     if(skip_find_neighbors)
212       {
213         it = other_mesh\&.elements_begin();
214         for (; it != end; ++it)
215           {
216             Elem* old_elem = *it;
217             Elem* new_elem = old_elems_to_new_elems[old_elem];
218             for (unsigned int s=0; s != old_elem->n_neighbors(); ++s)
219               {
220                 const Elem* old_neighbor = old_elem->neighbor(s);
221                 Elem* new_neighbor = old_elems_to_new_elems[old_neighbor];
222                 new_elem->set_neighbor(s, new_neighbor);
223               }
224           }
225       }
226   }
227 
228   //Finally prepare the new Mesh for use\&.  Keep the same numbering and
229   //partitioning but also the same renumbering and partitioning
230   //policies as our source mesh\&.
231   this->allow_renumbering(false);
232   this->skip_partitioning(true);
233   this->prepare_for_use(false, skip_find_neighbors);
234   this->allow_renumbering(other_mesh\&.allow_renumbering());
235   this->skip_partitioning(other_mesh\&.skip_partitioning());
236 }
.fi
.SS "void libMesh::UnstructuredMesh::create_pid_mesh (\fBUnstructuredMesh\fP &pid_mesh, const \fBprocessor_id_type\fPpid) const\fC [inherited]\fP"
Generates a new mesh containing all the elements which are assigned to processor \fCpid\fP\&. This mesh is written to the pid_mesh reference which you must create and pass to the function\&. 
.PP
Definition at line 997 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), libMesh::UnstructuredMesh::create_submesh(), libMesh::ParallelObject::n_processors(), and libMesh::out\&.
.PP
.nf
999 {
1000 
1001   // Issue a warning if the number the number of processors
1002   // currently available is less that that requested for
1003   // partitioning\&.  This is not necessarily an error since
1004   // you may run on one processor and still partition the
1005   // mesh into several partitions\&.
1006 #ifdef DEBUG
1007   if (this->n_processors() < pid)
1008     {
1009       libMesh::out << "WARNING:  You are creating a "
1010                    << "mesh for a processor id (="
1011                    << pid
1012                    << ") greater than "
1013                    << "the number of processors available for "
1014                    << "the calculation\&. (="
1015                    << this->n_processors()
1016                    << ")\&."
1017                    << std::endl;
1018     }
1019 #endif
1020 
1021   // Create iterators to loop over the list of elements
1022   //   const_active_pid_elem_iterator       it(this->elements_begin(),   pid);
1023   //   const const_active_pid_elem_iterator it_end(this->elements_end(), pid);
1024 
1025   const_element_iterator       it     = this->active_pid_elements_begin(pid);
1026   const const_element_iterator it_end = this->active_pid_elements_end(pid);
1027 
1028   this->create_submesh (pid_mesh, it, it_end);
1029 }
.fi
.SS "void libMesh::UnstructuredMesh::create_submesh (\fBUnstructuredMesh\fP &new_mesh, \fBconst_element_iterator\fP &it, const \fBconst_element_iterator\fP &it_end) const\fC [inherited]\fP"
Constructs a mesh called 'new_mesh' from the current mesh by iterating over the elements between it and it_end and adding them to the new mesh\&. 
.PP
Definition at line 1037 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::add_elem(), libMesh::MeshBase::add_point(), bc_id, libMesh::MeshBase::boundary_info, libMesh::Elem::build(), libMesh::MeshBase::clear(), libMesh::DofObject::invalid_id, libMesh::libmesh_assert(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_nodes(), libMesh::Elem::n_nodes(), libMesh::Elem::n_sides(), libMesh::Elem::node(), libMesh::MeshBase::node_ptr(), libMesh::Elem::point(), libMesh::MeshBase::prepare_for_use(), libMesh::DofObject::processor_id(), libMesh::Elem::set_node(), libMesh::Elem::subdomain_id(), and libMesh::Elem::type()\&.
.PP
Referenced by libMesh::UnstructuredMesh::create_pid_mesh()\&.
.PP
.nf
1040 {
1041   // Just in case the subdomain_mesh already has some information
1042   // in it, get rid of it\&.
1043   new_mesh\&.clear();
1044 
1045   // Fail if (*this == new_mesh), we cannot create a submesh inside ourself!
1046   // This may happen if the user accidently passes the original mesh into
1047   // this function!  We will check this by making sure we did not just
1048   // clear ourself\&.
1049   libmesh_assert_not_equal_to (this->n_nodes(), 0);
1050   libmesh_assert_not_equal_to (this->n_elem(), 0);
1051 
1052   // How the nodes on this mesh will be renumbered to nodes
1053   // on the new_mesh\&.
1054   std::vector<dof_id_type> new_node_numbers (this->n_nodes());
1055 
1056   std::fill (new_node_numbers\&.begin(),
1057              new_node_numbers\&.end(),
1058              DofObject::invalid_id);
1059 
1060 
1061 
1062   // the number of nodes on the new mesh, will be incremented
1063   dof_id_type n_new_nodes = 0;
1064   dof_id_type n_new_elem  = 0;
1065 
1066   for (; it != it_end; ++it)
1067     {
1068       // increment the new element counter
1069       n_new_elem++;
1070 
1071       const Elem* old_elem = *it;
1072 
1073       // Add an equivalent element type to the new_mesh
1074       Elem* new_elem =
1075         new_mesh\&.add_elem (Elem::build(old_elem->type())\&.release());
1076 
1077       libmesh_assert(new_elem);
1078 
1079       // Loop over the nodes on this element\&.
1080       for (unsigned int n=0; n<old_elem->n_nodes(); n++)
1081         {
1082           libmesh_assert_less (old_elem->node(n), new_node_numbers\&.size());
1083 
1084           if (new_node_numbers[old_elem->node(n)] == DofObject::invalid_id)
1085             {
1086               new_node_numbers[old_elem->node(n)] = n_new_nodes;
1087 
1088               // Add this node to the new mesh
1089               new_mesh\&.add_point (old_elem->point(n));
1090 
1091               // Increment the new node counter
1092               n_new_nodes++;
1093             }
1094 
1095           // Define this element's connectivity on the new mesh
1096           libmesh_assert_less (new_node_numbers[old_elem->node(n)], new_mesh\&.n_nodes());
1097 
1098           new_elem->set_node(n) = new_mesh\&.node_ptr (new_node_numbers[old_elem->node(n)]);
1099         }
1100 
1101       // Copy ids for this element
1102       new_elem->subdomain_id() = old_elem->subdomain_id();
1103       new_elem->processor_id() = old_elem->processor_id();
1104 
1105       // Maybe add boundary conditions for this element
1106       for (unsigned int s=0; s<old_elem->n_sides(); s++)
1107         // We're supporting boundary ids on internal sides now
1108         //if (old_elem->neighbor(s) == NULL)
1109         {
1110           const std::vector<boundary_id_type>& bc_ids = this->boundary_info->boundary_ids(old_elem, s);
1111           for (std::vector<boundary_id_type>::const_iterator id_it=bc_ids\&.begin(); id_it!=bc_ids\&.end(); ++id_it)
1112             {
1113               const boundary_id_type bc_id = *id_it;
1114               if (bc_id != this->boundary_info->invalid_id)
1115                 new_mesh\&.boundary_info->add_side (new_elem,
1116                                                   s,
1117                                                   bc_id);
1118             }
1119         }
1120     } // end loop over elements
1121 
1122 
1123   // Prepare the new_mesh for use
1124   new_mesh\&.prepare_for_use(/*skip_renumber =*/false);
1125 
1126 }
.fi
.SS "void libMesh::ParallelMesh::delete_elem (\fBElem\fP *e)\fC [virtual]\fP, \fC [inherited]\fP"
Removes element \fCe\fP from the mesh\&. Note that calling this method may produce isolated nodes, i\&.e\&. nodes not connected to any element\&. This method must be implemented in derived classes in such a way that it does not invalidate element iterators\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 462 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::MeshBase::boundary_info, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements(), and libMesh::ParallelMesh::insert_elem()\&.
.PP
.nf
463 {
464   libmesh_assert (e);
465 
466   // Delete the element from the BoundaryInfo object
467   this->boundary_info->remove(e);
468 
469   // But not yet from the container; we might invalidate
470   // an iterator that way!
471 
472   //_elements\&.erase(e->id());
473 
474   // Instead, we set it to NULL for now
475 
476   _elements[e->id()] = NULL;
477 
478   // delete the element
479   delete e;
480 }
.fi
.SS "void libMesh::ParallelMesh::delete_node (\fBNode\fP *n)\fC [virtual]\fP, \fC [inherited]\fP"
Removes the \fBNode\fP n from the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 622 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::MeshBase::boundary_info, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
623 {
624   libmesh_assert(n);
625   libmesh_assert(_nodes[n->id()]);
626 
627   // Delete the node from the BoundaryInfo object
628   this->boundary_info->remove(n);
629 
630   // But not yet from the container; we might invalidate
631   // an iterator that way!
632 
633   //_nodes\&.erase(n->id());
634 
635   // Instead, we set it to NULL for now
636 
637   _nodes[n->id()] = NULL;
638 
639   // delete the node
640   delete n;
641 }
.fi
.SS "void libMesh::ParallelMesh::delete_remote_elements ()\fC [virtual]\fP, \fC [inherited]\fP"
Deletes all nonlocal elements of the mesh except for 'ghosts' which touch a local element, and deletes all nodes which are not part of a local or ghost element 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1215 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_extra_ghost_elems, libMesh::ParallelMesh::_is_serial, libMesh::ParallelMesh::_nodes, libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids(), libMesh::MeshTools::libmesh_assert_valid_refinement_tree(), libMesh::ParallelMesh::max_elem_id(), libMesh::ParallelMesh::max_node_id(), libMesh::ParallelMesh::n_elem(), libMesh::ParallelMesh::n_nodes(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
1216 {
1217 #ifdef DEBUG
1218   // Make sure our neighbor links are all fine
1219   MeshTools::libmesh_assert_valid_neighbors(*this);
1220 
1221   // And our child/parent links, and our flags
1222   MeshTools::libmesh_assert_valid_refinement_tree(*this);
1223 
1224   // Make sure our ids and flags are consistent
1225   this->libmesh_assert_valid_parallel_ids();
1226   this->libmesh_assert_valid_parallel_flags();
1227 
1228   libmesh_assert_equal_to (this->n_nodes(), this->parallel_n_nodes());
1229   libmesh_assert_equal_to (this->n_elem(), this->parallel_n_elem());
1230   const dof_id_type pmax_node_id = this->parallel_max_node_id();
1231   const dof_id_type pmax_elem_id = this->parallel_max_elem_id();
1232   libmesh_assert_equal_to (this->max_node_id(), pmax_node_id);
1233   libmesh_assert_equal_to (this->max_elem_id(), pmax_elem_id);
1234 #endif
1235 
1236   _is_serial = false;
1237   MeshCommunication()\&.delete_remote_elements(*this, _extra_ghost_elems);
1238 
1239   libmesh_assert_equal_to (this->max_elem_id(), this->parallel_max_elem_id());
1240 
1241   // Now make sure the containers actually shrink - strip
1242   // any newly-created NULL voids out of the element array
1243   mapvector<Elem*,dof_id_type>::veclike_iterator e_it        = _elements\&.begin();
1244   const mapvector<Elem*,dof_id_type>::veclike_iterator e_end = _elements\&.end();
1245   for (; e_it != e_end;)
1246     if (!*e_it)
1247       _elements\&.erase(e_it++);
1248     else
1249       ++e_it;
1250 
1251   mapvector<Node*,dof_id_type>::veclike_iterator n_it        = _nodes\&.begin();
1252   const mapvector<Node*,dof_id_type>::veclike_iterator n_end = _nodes\&.end();
1253   for (; n_it != n_end;)
1254     if (!*n_it)
1255       _nodes\&.erase(n_it++);
1256     else
1257       ++n_it;
1258 
1259   // We may have deleted no-longer-connected nodes or coarsened-away
1260   // elements; let's update our caches\&.
1261   this->update_parallel_id_counts();
1262 
1263 #ifdef DEBUG
1264   // We might not have well-packed objects if the user didn't allow us
1265   // to renumber
1266   // libmesh_assert_equal_to (this->n_nodes(), this->max_node_id());
1267   // libmesh_assert_equal_to (this->n_elem(), this->max_elem_id());
1268 
1269   // Make sure our neighbor links are all fine
1270   MeshTools::libmesh_assert_valid_neighbors(*this);
1271 
1272   // And our child/parent links, and our flags
1273   MeshTools::libmesh_assert_valid_refinement_tree(*this);
1274 
1275   // Make sure our ids and flags are consistent
1276   this->libmesh_assert_valid_parallel_ids();
1277   this->libmesh_assert_valid_parallel_flags();
1278 #endif
1279 }
.fi
.SS "const \fBElem\fP * libMesh::ParallelMesh::elem (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 305 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::ParallelMesh::ParallelMesh()\&.
.PP
.nf
306 {
307   libmesh_assert(_elements[i]);
308   libmesh_assert_equal_to (_elements[i]->id(), i);
309 
310   return _elements[i];
311 }
.fi
.SS "\fBElem\fP * libMesh::ParallelMesh::elem (const \fBdof_id_type\fPi)\fC [virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ element, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 316 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::libmesh_assert()\&.
.PP
.nf
317 {
318   libmesh_assert(_elements[i]);
319   libmesh_assert_equal_to (_elements[i]->id(), i);
320 
321   return _elements[i];
322 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"
\fBElem\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 37 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
38 {
39   Predicates::NotNull<elem_iterator_imp> p;
40   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
41 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"
const \fBElem\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 262 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
263 {
264   Predicates::NotNull<const_elem_iterator_imp> p;
265   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
266 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 484 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
485 {
486   Predicates::NotNull<elem_iterator_imp> p;
487   return element_iterator(_elements\&.end(), _elements\&.end(), p);
488 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 709 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
710 {
711   Predicates::NotNull<const_elem_iterator_imp> p;
712   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
713 }
.fi
.SS "void libMesh::UnstructuredMesh::find_neighbors (const boolreset_remote_elements = \fCfalse\fP, const boolreset_current_list = \fCtrue\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Other functions from \fBMeshBase\fP requiring re-definition\&. Here we look at all of the child elements which don't already have valid neighbors\&.
.PP
If a child element has a NULL neighbor it is either because it is on the boundary or because its neighbor is at a different level\&. In the latter case we must get the neighbor from the parent\&.
.PP
If a child element has a remote_elem neighbor on a boundary it shares with its parent, that info may have become out-dated through coarsening of the neighbor's parent\&. In this case, if the parent's neighbor is active then the child should share it\&.
.PP
Furthermore, that neighbor better be active, otherwise we missed a child somewhere\&.
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 251 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::_dim, libMesh::Elem::active(), libMesh::Elem::ancestor(), libMesh::Elem::centroid(), libMesh::Elem::child(), libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), end, libMesh::err, libMesh::Elem::has_children(), libMesh::Elem::hmin(), libMesh::DofObject::id(), libMesh::Elem::is_child_on_side(), libMesh::Elem::key(), libMesh::Elem::level(), libMesh::MeshBase::level_elements_begin(), libMesh::MeshBase::level_elements_end(), libMesh::libmesh_assert(), libMesh::MeshTools::libmesh_assert_valid_neighbors(), libMesh::Elem::n_children(), libMesh::MeshTools::n_levels(), libMesh::Elem::n_neighbors(), libMesh::Elem::neighbor(), libMesh::Elem::parent(), libMesh::ParallelObject::processor_id(), libMesh::DofObject::processor_id(), libMesh::remote_elem, libMesh::Elem::set_neighbor(), libMesh::Elem::side(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::Elem::subactive(), libMesh::Elem::which_child_am_i(), and libMesh::GMVIO::write()\&.
.PP
Referenced by libMesh::TriangleWrapper::copy_tri_to_mesh()\&.
.PP
.nf
253 {
254   // We might actually want to run this on an empty mesh
255   // (e\&.g\&. the boundary mesh for a nonexistant bcid!)
256   // libmesh_assert_not_equal_to (this->n_nodes(), 0);
257   // libmesh_assert_not_equal_to (this->n_elem(), 0);
258 
259   // This function must be run on all processors at once
260   parallel_object_only();
261 
262   START_LOG("find_neighbors()", "Mesh");
263 
264   const element_iterator el_end = this->elements_end();
265 
266   //TODO:[BSK] This should be removed later?!
267   if (reset_current_list)
268     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
269       {
270         Elem* e = *el;
271         for (unsigned int s=0; s<e->n_neighbors(); s++)
272           if (e->neighbor(s) != remote_elem ||
273               reset_remote_elements)
274             e->set_neighbor(s,NULL);
275       }
276 
277   // Find neighboring elements by first finding elements
278   // with identical side keys and then check to see if they
279   // are neighbors
280   {
281     // data structures -- Use the hash_multimap if available
282     typedef unsigned int                    key_type;
283     typedef std::pair<Elem*, unsigned char> val_type;
284     typedef std::pair<key_type, val_type>   key_val_pair;
285 
286     typedef LIBMESH_BEST_UNORDERED_MULTIMAP<key_type, val_type> map_type;
287 
288     // A map from side keys to corresponding elements & side numbers
289     map_type side_to_elem_map;
290 
291 
292 
293     for (element_iterator el = this->elements_begin(); el != el_end; ++el)
294       {
295         Elem* element = *el;
296 
297         for (unsigned int ms=0; ms<element->n_neighbors(); ms++)
298           {
299           next_side:
300             // If we haven't yet found a neighbor on this side, try\&.
301             // Even if we think our neighbor is remote, that
302             // information may be out of date\&.
303             if (element->neighbor(ms) == NULL ||
304                 element->neighbor(ms) == remote_elem)
305               {
306                 // Get the key for the side of this element
307                 const unsigned int key = element->key(ms);
308 
309                 // Look for elements that have an identical side key
310                 std::pair <map_type::iterator, map_type::iterator>
311                   bounds = side_to_elem_map\&.equal_range(key);
312 
313                 // May be multiple keys, check all the possible
314                 // elements which _might_ be neighbors\&.
315                 if (bounds\&.first != bounds\&.second)
316                   {
317                     // Get the side for this element
318                     const AutoPtr<Elem> my_side(element->side(ms));
319 
320                     // Look at all the entries with an equivalent key
321                     while (bounds\&.first != bounds\&.second)
322                       {
323                         // Get the potential element
324                         Elem* neighbor = bounds\&.first->second\&.first;
325 
326                         // Get the side for the neighboring element
327                         const unsigned int ns = bounds\&.first->second\&.second;
328                         const AutoPtr<Elem> their_side(neighbor->side(ns));
329                         //libmesh_assert(my_side\&.get());
330                         //libmesh_assert(their_side\&.get());
331 
332                         // If found a match with my side
333                         //
334                         // We need special tests here for 1D:
335                         // since parents and children have an equal
336                         // side (i\&.e\&. a node), we need to check
337                         // ns != ms, and we also check level() to
338                         // avoid setting our neighbor pointer to
339                         // any of our neighbor's descendants
340                         if( (*my_side == *their_side) &&
341                             (element->level() == neighbor->level()) &&
342                             ((_dim != 1) || (ns != ms)) )
343                           {
344                             // So share a side\&.  Is this a mixed pair
345                             // of subactive and active/ancestor
346                             // elements?
347                             // If not, then we're neighbors\&.
348                             // If so, then the subactive's neighbor is
349 
350                             if (element->subactive() ==
351                                 neighbor->subactive())
352                               {
353                                 // an element is only subactive if it has
354                                 // been coarsened but not deleted
355                                 element->set_neighbor (ms,neighbor);
356                                 neighbor->set_neighbor(ns,element);
357                               }
358                             else if (element->subactive())
359                               {
360                                 element->set_neighbor(ms,neighbor);
361                               }
362                             else if (neighbor->subactive())
363                               {
364                                 neighbor->set_neighbor(ns,element);
365                               }
366                             side_to_elem_map\&.erase (bounds\&.first);
367 
368                             // get out of this nested crap
369                             goto next_side;
370                           }
371 
372                         ++bounds\&.first;
373                       }
374                   }
375 
376                 // didn't find a match\&.\&.\&.
377                 // Build the map entry for this element
378                 key_val_pair kvp;
379 
380                 kvp\&.first         = key;
381                 kvp\&.second\&.first  = element;
382                 kvp\&.second\&.second = ms;
383 
384                 // use the lower bound as a hint for
385                 // where to put it\&.
386 #if defined(LIBMESH_HAVE_UNORDERED_MAP) || defined(LIBMESH_HAVE_TR1_UNORDERED_MAP) || defined(LIBMESH_HAVE_HASH_MAP) || defined(LIBMESH_HAVE_EXT_HASH_MAP)
387                 side_to_elem_map\&.insert (kvp);
388 #else
389                 side_to_elem_map\&.insert (bounds\&.first,kvp);
390 #endif
391               }
392           }
393       }
394   }
395 
396 #ifdef LIBMESH_ENABLE_AMR
397 
418   const unsigned int n_levels = MeshTools::n_levels(*this);
419   for (unsigned int level = 1; level < n_levels; ++level)
420     {
421       element_iterator end = this->level_elements_end(level);
422       for (element_iterator el = this->level_elements_begin(level);
423            el != end; ++el)
424         {
425           Elem* current_elem = *el;
426           libmesh_assert(current_elem);
427           Elem* parent = current_elem->parent();
428           libmesh_assert(parent);
429           const unsigned int my_child_num = parent->which_child_am_i(current_elem);
430 
431           for (unsigned int s=0; s < current_elem->n_neighbors(); s++)
432             {
433               if (current_elem->neighbor(s) == NULL ||
434                   (current_elem->neighbor(s) == remote_elem &&
435                    parent->is_child_on_side(my_child_num, s)))
436                 {
437                   Elem *neigh = parent->neighbor(s);
438 
439                   // If neigh was refined and had non-subactive children
440                   // made remote earlier, then a non-subactive elem should
441                   // actually have one of those remote children as a
442                   // neighbor
443                   if (neigh && (neigh->ancestor()) && (!current_elem->subactive()))
444                     {
445 #ifdef DEBUG
446                       // Let's make sure that "had children made remote"
447                       // situation is actually the case
448                       libmesh_assert(neigh->has_children());
449                       bool neigh_has_remote_children = false;
450                       for (unsigned int c = 0; c != neigh->n_children(); ++c)
451                         {
452                           if (neigh->child(c) == remote_elem)
453                             neigh_has_remote_children = true;
454                         }
455                       libmesh_assert(neigh_has_remote_children);
456 
457                       // And let's double-check that we don't have
458                       // a remote_elem neighboring a local element
459                       libmesh_assert_not_equal_to (current_elem->processor_id(),
460                                                    this->processor_id());
461 #endif // DEBUG
462                       neigh = const_cast<RemoteElem*>(remote_elem);
463                     }
464 
465                   current_elem->set_neighbor(s, neigh);
466 #ifdef DEBUG
467                   if (neigh != NULL && neigh != remote_elem)
468                     // We ignore subactive elements here because
469                     // we don't care about neighbors of subactive element\&.
470                     if ((!neigh->active()) && (!current_elem->subactive()))
471                       {
472                         libMesh::err << "On processor " << this->processor_id()
473                                      << std::endl;
474                         libMesh::err << "Bad element ID = " << current_elem->id()
475                                      << ", Side " << s << ", Bad neighbor ID = " << neigh->id() << std::endl;
476                         libMesh::err << "Bad element proc_ID = " << current_elem->processor_id()
477                                      << ", Bad neighbor proc_ID = " << neigh->processor_id() << std::endl;
478                         libMesh::err << "Bad element size = " << current_elem->hmin()
479                                      << ", Bad neighbor size = " << neigh->hmin() << std::endl;
480                         libMesh::err << "Bad element center = " << current_elem->centroid()
481                                      << ", Bad neighbor center = " << neigh->centroid() << std::endl;
482                         libMesh::err << "ERROR: "
483                                      << (current_elem->active()?"Active":"Ancestor")
484                                      << " Element at level "
485                                      << current_elem->level() << std::endl;
486                         libMesh::err << "with "
487                                      << (parent->active()?"active":
488                                          (parent->subactive()?"subactive":"ancestor"))
489                                      << " parent share "
490                                      << (neigh->subactive()?"subactive":"ancestor")
491                                      << " neighbor at level " << neigh->level()
492                                      << std::endl;
493                         GMVIO(*this)\&.write ("bad_mesh\&.gmv");
494                         libmesh_error();
495                       }
496 #endif // DEBUG
497                 }
498             }
499         }
500     }
501 
502 #endif // AMR
503 
504 
505 #ifdef DEBUG
506   MeshTools::libmesh_assert_valid_neighbors(*this);
507 #endif
508 
509   STOP_LOG("find_neighbors()", "Mesh");
510 }
.fi
.SS "void libMesh::ParallelMesh::fix_broken_node_and_element_numbering ()\fC [virtual]\fP, \fC [inherited]\fP"
There is no reason for a user to ever call this function\&.
.PP
This function restores a previously broken element/node numbering such that \fCmesh\&.node(n)->id()\fP == n\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1162 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_nodes, libMesh::mapvector< Val, index_t >::begin(), libMesh::mapvector< Val, index_t >::end(), and end\&.
.PP
.nf
1163 {
1164   // We need access to iterators for the underlying containers,
1165   // not the mapvector<> reimplementations\&.
1166   mapvector<Node*,dof_id_type>::maptype &nodes = this->_nodes;
1167   mapvector<Elem*,dof_id_type>::maptype &elems = this->_elements;
1168 
1169   // Nodes first
1170   {
1171     mapvector<Node*,dof_id_type>::maptype::iterator
1172       it  = nodes\&.begin(),
1173       end = nodes\&.end();
1174 
1175     for (; it != end; ++it)
1176       if (it->second != NULL)
1177         it->second->set_id() = it->first;
1178   }
1179 
1180   // Elements next
1181   {
1182     mapvector<Elem*,dof_id_type>::maptype::iterator
1183       it  = elems\&.begin(),
1184       end = elems\&.end();
1185 
1186     for (; it != end; ++it)
1187       if (it->second != NULL)
1188         it->second->set_id() = it->first;
1189   }
1190 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::get_id_by_name (const std::string &name) const\fC [inherited]\fP"
Returns a the id of the requested block by name\&. Throws an error if a block by name is not found 
.PP
Definition at line 442 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name, and libMesh::err\&.
.PP
.nf
443 {
444   // This function is searching the *values* of the map (linear search)
445   // We might want to make this more efficient\&.\&.\&.
446   std::map<subdomain_id_type, std::string>::const_iterator
447     iter = _block_id_to_name\&.begin(),
448     end_iter = _block_id_to_name\&.end();
449 
450   for ( ; iter != end_iter; ++iter)
451     {
452       if (iter->second == name)
453         return iter->first;
454     }
455 
456   libMesh::err << "Block '" << name << "' does not exist in mesh" << std::endl;
457   libmesh_error();
458 }
.fi
.SS "std::string libMesh::MeshBase::get_info () const\fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
a string containing relevant information about the mesh\&. 
.RE
.PP

.PP
Definition at line 306 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::n_active_elem(), libMesh::MeshBase::n_elem(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::MeshBase::n_nodes(), libMesh::MeshBase::n_partitions(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::n_subdomains(), libMesh::n_threads, libMesh::ParallelObject::processor_id(), and libMesh::MeshBase::spatial_dimension()\&.
.PP
Referenced by libMesh::MeshBase::print_info()\&.
.PP
.nf
307 {
308   std::ostringstream oss;
309 
310   oss << " Mesh Information:"                                  << '\n'
311       << "  mesh_dimension()="    << this->mesh_dimension()    << '\n'
312       << "  spatial_dimension()=" << this->spatial_dimension() << '\n'
313       << "  n_nodes()="           << this->n_nodes()           << '\n'
314       << "    n_local_nodes()="   << this->n_local_nodes()     << '\n'
315       << "  n_elem()="            << this->n_elem()            << '\n'
316       << "    n_local_elem()="    << this->n_local_elem()      << '\n'
317 #ifdef LIBMESH_ENABLE_AMR
318       << "    n_active_elem()="   << this->n_active_elem()     << '\n'
319 #endif
320       << "  n_subdomains()="      << static_cast<std::size_t>(this->n_subdomains()) << '\n'
321       << "  n_partitions()="      << static_cast<std::size_t>(this->n_partitions()) << '\n'
322       << "  n_processors()="      << static_cast<std::size_t>(this->n_processors()) << '\n'
323       << "  n_threads()="         << static_cast<std::size_t>(libMesh::n_threads()) << '\n'
324       << "  processor_id()="      << static_cast<std::size_t>(this->processor_id()) << '\n';
325 
326   return oss\&.str();
327 }
.fi
.SS "const std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::get_subdomain_name_map () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 843 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::write_serialized_subdomain_names(), and libMesh::CheckpointIO::write_subdomain_names()\&.
.PP
.nf
844   { return _block_id_to_name; }
.fi
.SS "\fBElem\fP * libMesh::ParallelMesh::insert_elem (\fBElem\fP *e)\fC [virtual]\fP, \fC [inherited]\fP"
Insert elem \fCe\fP to the element array, preserving its id and replacing/deleting any existing element with the same id\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 450 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::delete_elem(), and libMesh::DofObject::id()\&.
.PP
.nf
451 {
452   if (_elements[e->id()])
453     this->delete_elem(_elements[e->id()]);
454 
455   _elements[e->id()] = e;
456 
457   return e;
458 }
.fi
.SS "\fBNode\fP * libMesh::ParallelMesh::insert_node (\fBNode\fP *n)\fC [virtual]\fP, \fC [inherited]\fP"
Calls \fBadd_node()\fP\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 615 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::add_node()\&.
.PP
.nf
616 {
617   return ParallelMesh::add_node(n);
618 }
.fi
.SS "bool libMesh::MeshBase::is_prepared () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the mesh has been prepared via a call to \fCprepare_for_use\fP, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 126 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_is_prepared\&.
.PP
Referenced by libMesh::DofMap::build_sparsity(), libMesh::DofMap::create_dof_constraints(), libMesh::DofMap::distribute_dofs(), and libMesh::DofMap::reinit()\&.
.PP
.nf
127   { return _is_prepared; }
.fi
.SS "virtual bool libMesh::ParallelMesh::is_serial () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if all elements and nodes of the mesh exist on the current processor, \fCfalse\fP otherwise 
.RE
.PP

.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 118 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_is_serial\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::MeshCommunication::delete_remote_elements(), and libMesh::ParallelMesh::redistribute()\&.
.PP
.nf
119   { return _is_serial; }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::level_elements_begin (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 147 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
148 {
149   Predicates::Level<elem_iterator_imp> p(level);
150   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
151 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 371 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
372 {
373   Predicates::Level<const_elem_iterator_imp> p(level);
374   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
375 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::level_elements_end (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 594 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
595 {
596   Predicates::Level<elem_iterator_imp> p(level);
597   return element_iterator(_elements\&.end(), _elements\&.end(), p);
598 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::level_elements_end (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 819 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
820 {
821   Predicates::Level<const_elem_iterator_imp> p(level);
822   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
823 }
.fi
.SS "void libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags () const\fC [inherited]\fP"
Verify refinement_flag and p_refinement_flag consistency of our elements containers\&. Calls \fBlibmesh_assert()\fP on each possible failure\&. 
.PP
Definition at line 806 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelObject::comm(), libMesh::invalid_uint, libMesh::libmesh_assert(), libMesh::Parallel::Communicator::min(), libMesh::Elem::p_refinement_flag(), libMesh::ParallelMesh::parallel_max_elem_id(), and libMesh::Elem::refinement_flag()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
807 {
808 #ifdef LIBMESH_ENABLE_AMR
809   // This function must be run on all processors at once
810   parallel_object_only();
811 
812   dof_id_type pmax_elem_id = this->parallel_max_elem_id();
813 
814   for (dof_id_type i=0; i != pmax_elem_id; ++i)
815     {
816       Elem* el = _elements[i]; // Returns NULL if there's no map entry
817 
818       unsigned int refinement_flag   = el ?
819         static_cast<unsigned int> (el->refinement_flag()) : libMesh::invalid_uint;
820 #ifndef NDEBUG
821       unsigned int p_refinement_flag = el ?
822         static_cast<unsigned int> (el->p_refinement_flag()) : libMesh::invalid_uint;
823 #endif
824 
825       unsigned int min_rflag = refinement_flag;
826       this->comm()\&.min(min_rflag);
827       // All processors with this element should agree on flag
828       libmesh_assert (!el || min_rflag == refinement_flag);
829 
830 #ifndef NDEBUG
831       unsigned int min_pflag = p_refinement_flag;
832 #endif
833       // All processors with this element should agree on flag
834       libmesh_assert (!el || min_pflag == p_refinement_flag);
835     }
836 #endif // LIBMESH_ENABLE_AMR
837 }
.fi
.SS "void libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids () const\fC [virtual]\fP, \fC [inherited]\fP"
Verify id and processor_id consistency of our elements and nodes containers\&. Calls \fBlibmesh_assert()\fP on each possible failure\&. 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 798 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_nodes, and libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
799 {
800   this->libmesh_assert_valid_parallel_object_ids (this->_elements);
801   this->libmesh_assert_valid_parallel_object_ids (this->_nodes);
802 }
.fi
.SS "template<typename T > void libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids (const \fBmapvector\fP< T *, \fBdof_id_type\fP > &objects) const\fC [inherited]\fP"
Verify id and processor_id consistency of a parallel objects container\&. Calls \fBlibmesh_assert()\fP on each possible failure in that container\&. 
.PP
Definition at line 747 of file parallel_mesh\&.C\&.
.PP
References libMesh::comm, libMesh::DofObject::invalid_id, libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), std::max(), and libMesh::processor_id()\&.
.PP
Referenced by libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids()\&.
.PP
.nf
748 {
749   // This function must be run on all processors at once
750   parallel_object_only();
751 
752   const dof_id_type pmax_node_id = this->parallel_max_node_id();
753   const dof_id_type pmax_elem_id = this->parallel_max_elem_id();
754   const dof_id_type pmax_id = std::max(pmax_node_id, pmax_elem_id);
755 
756   for (dof_id_type i=0; i != pmax_id; ++i)
757     {
758       T* obj = objects[i]; // Returns NULL if there's no map entry
759 
760       dof_id_type dofid = obj && obj->valid_id() ?
761         obj->id() : DofObject::invalid_id;
762       // Local lookups by id should return the requested object
763       libmesh_assert(!obj || obj->id() == i);
764 
765       dof_id_type min_dofid = dofid;
766       this->comm()\&.min(min_dofid);
767       // All processors with an object should agree on id
768       libmesh_assert (!obj || dofid == min_dofid);
769 
770       dof_id_type procid = obj && obj->valid_processor_id() ?
771         obj->processor_id() : DofObject::invalid_processor_id;
772 
773       dof_id_type min_procid = procid;
774       this->comm()\&.min(min_procid);
775 
776       // All processors with an object should agree on processor id
777       libmesh_assert (!obj || procid == min_procid);
778 
779       // Either:
780       // 1\&.) I own this elem (min_procid == this->processor_id()) *and* I have a valid pointer to it (obj != NULL)
781       // or
782       // 2\&.) I don't own this elem (min_procid != this->processor_id())\&.  (In this case I may or may not have a valid pointer to it\&.)
783 
784       // Original assert logic
785       // libmesh_assert (min_procid != this->processor_id() || obj);
786 
787       // More human-understandable logic\&.\&.\&.
788       libmesh_assert (
789                       ((min_procid == this->processor_id()) && obj)
790                       ||
791                       (min_procid != this->processor_id())
792                       );
793     }
794 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 107 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
108 {
109   Predicates::Local<elem_iterator_imp> p(this->processor_id());
110   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
111 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 331 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
332 {
333   Predicates::Local<const_elem_iterator_imp> p(this->processor_id());
334   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
335 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 554 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
555 {
556   Predicates::Local<elem_iterator_imp> p(this->processor_id());
557   return element_iterator(_elements\&.end(), _elements\&.end(), p);
558 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 779 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
780 {
781   Predicates::Local<const_elem_iterator_imp> p(this->processor_id());
782   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
783 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 167 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
168 {
169   Predicates::LocalLevel<elem_iterator_imp> p(this->processor_id(),level);
170   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
171 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 391 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
392 {
393   Predicates::LocalLevel<const_elem_iterator_imp> p(this->processor_id(),level);
394   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
395 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_level_elements_end (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 614 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
615 {
616   Predicates::LocalLevel<elem_iterator_imp> p(this->processor_id(),level);
617   return element_iterator(_elements\&.end(), _elements\&.end(), p);
618 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 839 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
840 {
841   Predicates::LocalLevel<const_elem_iterator_imp> p(this->processor_id(),level);
842   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
843 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::local_nodes_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 951 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
952 {
953   Predicates::Local<node_iterator_imp> p(this->processor_id());
954   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
955 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::local_nodes_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 991 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
992 {
993   Predicates::Local<const_node_iterator_imp> p(this->processor_id());
994   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
995 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::local_nodes_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1031 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
1032 {
1033   Predicates::Local<node_iterator_imp> p(this->processor_id());
1034   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1035 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::local_nodes_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1071 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
1072 {
1073   Predicates::Local<const_node_iterator_imp> p(this->processor_id());
1074   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1075 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_not_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 177 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
178 {
179   Predicates::LocalNotLevel<elem_iterator_imp> p(this->processor_id(),level);
180   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
181 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_not_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 401 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
402 {
403   Predicates::LocalNotLevel<const_elem_iterator_imp> p(this->processor_id(),level);
404   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
405 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::local_not_level_elements_end (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 624 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
625 {
626   Predicates::LocalNotLevel<elem_iterator_imp> p(this->processor_id(),level);
627   return element_iterator(_elements\&.end(), _elements\&.end(), p);
628 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::local_not_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 849 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
850 {
851   Predicates::LocalNotLevel<const_elem_iterator_imp> p(this->processor_id(),level);
852   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
853 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::ParallelMesh::max_elem_id () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Returns a number greater than or equal to the maximum element id in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 187 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_max_elem_id\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
187 { return _max_elem_id; }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::ParallelMesh::max_node_id () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Returns a number greater than or equal to the maximum node id in the mesh\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 183 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_max_node_id\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
183 { return _max_node_id; }
.fi
.SS "unsigned int libMesh::MeshBase::mesh_dimension () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the logical dimension of the mesh; i\&.e\&. the manifold dimension of the elements in the mesh\&. If we ever support multi-dimensional meshes (e\&.g\&. hexes and quads in the same mesh) then this will return the largest such dimension\&. 
.RE
.PP

.PP
Definition at line 155 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::HPCoarsenTest::add_projection(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Generation::build_cube(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::EquationSystems::build_solution_vector(), libMesh::EquationSystems::build_variable_names(), libMesh::System::calculate_norm(), libMesh::DofMap::create_dof_constraints(), libMesh::MeshTools::Modification::distort(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_nelem_target(), libMesh::MeshBase::get_info(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::LaplaceMeshSmoother::init(), libMesh::PointLocatorTree::init(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::FEInterface::n_vec_dim(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::ProjectSolution::operator()(), libMesh::MeshFunction::operator()(), libMesh::BoundaryProjectSolution::operator()(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::System::read_header(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshTools::Modification::rotate(), libMesh::HPCoarsenTest::select_refinement(), libMesh::MeshTools::Modification::smooth(), libMesh::BoundaryInfo::sync(), libMesh::DofMap::use_coupled_neighbor_dofs(), libMesh::PostscriptIO::write(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::TecplotIO::write_binary(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::UCDIO::write_nodal_data(), libMesh::EnsightIO::write_scalar_ascii(), libMesh::GnuPlotIO::write_solution(), libMesh::DivaIO::write_stream(), and libMesh::EnsightIO::write_vector_ascii()\&.
.PP
.nf
156   { return static_cast<unsigned int>(_dim); }
.fi
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::n_active_elem () const\fC [virtual]\fP, \fC [inherited]\fP"
Returns the number of active elements in the mesh\&. Implemented in terms of active_element_iterators\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1194 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::ParallelMesh::active_pid_elements_begin(), libMesh::ParallelMesh::active_pid_elements_end(), libMesh::ParallelObject::comm(), libMesh::DofObject::invalid_processor_id, and libMesh::Parallel::Communicator::sum()\&.
.PP
.nf
1195 {
1196   parallel_object_only();
1197 
1198   // Get local active elements first
1199   dof_id_type active_elements =
1200     static_cast<dof_id_type>(std::distance (this->active_local_elements_begin(),
1201                                             this->active_local_elements_end()));
1202   this->comm()\&.sum(active_elements);
1203 
1204   // Then add unpartitioned active elements, which should exist on
1205   // every processor
1206   active_elements +=
1207     static_cast<dof_id_type>(std::distance
1208                              (this->active_pid_elements_begin(DofObject::invalid_processor_id),
1209                               this->active_pid_elements_end(DofObject::invalid_processor_id)));
1210   return active_elements;
1211 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of active elements on processor \fCproc\fP\&. 
.PP
Definition at line 267 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_pid_elements_begin(), libMesh::MeshBase::active_pid_elements_end(), and libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::n_active_local_elem()\&.
.PP
.nf
268 {
269   libmesh_assert_less (proc_id, this->n_processors());
270   return static_cast<dof_id_type>(std::distance (this->active_pid_elements_begin(proc_id),
271                                                  this->active_pid_elements_end  (proc_id)));
272 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of active elements on the local processor\&. 
.PP
Definition at line 300 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_active_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParmetisPartitioner::build_graph(), libMesh::VTKIO::cells_to_vtk(), and libMesh::ParmetisPartitioner::initialize()\&.
.PP
.nf
301   { return this->n_active_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_active_sub_elem () const\fC [inherited]\fP"
Same, but only counts active elements\&. 
.PP
Definition at line 291 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), and end\&.
.PP
Referenced by libMesh::TecplotIO::write_ascii(), libMesh::GMVIO::write_ascii_old_impl(), and libMesh::TecplotIO::write_binary()\&.
.PP
.nf
292 {
293   dof_id_type ne=0;
294 
295   const_element_iterator       el  = this->active_elements_begin();
296   const const_element_iterator end = this->active_elements_end();
297 
298   for (; el!=end; ++el)
299     ne += (*el)->n_sub_elem();
300 
301   return ne;
302 }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::ParallelMesh::n_elem () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Returns the number of elements in the mesh\&. The standard \fBn_elem()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 185 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_n_elem\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
185 { return _n_elem; }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_elem_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of elements on processor \fCproc\fP\&. 
.PP
Definition at line 254 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_elements_begin(), and libMesh::MeshBase::pid_elements_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_elem(), and libMesh::MeshBase::n_unpartitioned_elem()\&.
.PP
.nf
255 {
256   // We're either counting a processor's elements or unpartitioned
257   // elements
258   libmesh_assert (proc_id < this->n_processors() ||
259                   proc_id == DofObject::invalid_processor_id);
260 
261   return static_cast<dof_id_type>(std::distance (this->pid_elements_begin(proc_id),
262                                                  this->pid_elements_end  (proc_id)));
263 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements on the local processor\&. 
.PP
Definition at line 283 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_elem_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), and libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
284   { return this->n_elem_on_proc (this->processor_id()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_local_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes on the local processor\&. 
.PP
Definition at line 197 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::n_nodes_on_proc(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::VTKIO::nodes_to_vtk(), and libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
198   { return this->n_nodes_on_proc (this->processor_id()); }
.fi
.SS "virtual \fBdof_id_type\fP libMesh::ParallelMesh::n_nodes () const\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The standard \fBn_nodes()\fP function may return a cached value on distributed meshes, and so can be called by any processor at any time\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 182 of file parallel_mesh\&.h\&.
.PP
References libMesh::ParallelMesh::_n_nodes\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
182 { return _n_nodes; }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_nodes_on_proc (const \fBprocessor_id_type\fPproc) const\fC [inherited]\fP"
Returns the number of nodes on processor \fCproc\fP\&. 
.PP
Definition at line 241 of file mesh_base\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, libMesh::libmesh_assert(), libMesh::ParallelObject::n_processors(), libMesh::MeshBase::pid_nodes_begin(), and libMesh::MeshBase::pid_nodes_end()\&.
.PP
Referenced by libMesh::MeshBase::n_local_nodes(), and libMesh::MeshBase::n_unpartitioned_nodes()\&.
.PP
.nf
242 {
243   // We're either counting a processor's nodes or unpartitioned
244   // nodes
245   libmesh_assert (proc_id < this->n_processors() ||
246                   proc_id == DofObject::invalid_processor_id);
247 
248   return static_cast<dof_id_type>(std::distance (this->pid_nodes_begin(proc_id),
249                                                  this->pid_nodes_end  (proc_id)));
250 }
.fi
.SS "unsigned int libMesh::MeshBase::n_partitions () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of partitions which have been defined via a call to either mesh\&.partition() or by building a \fBPartitioner\fP object and calling partition\&. Note that the partitioner objects are responsible for setting this value\&. 
.PP
Definition at line 578 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::Partitioner::set_node_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::UnstructuredMesh::write(), libMesh::GMVIO::write_ascii_new_impl(), and libMesh::GMVIO::write_ascii_old_impl()\&.
.PP
.nf
579   { return _n_parts; }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::n_processors () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of processors in the group\&. 
.RE
.PP

.PP
Definition at line 92 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::size()\&.
.PP
Referenced by libMesh::ParmetisPartitioner::_do_repartition(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::LaplaceMeshSmoother::allgather_graph(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::AztecLinearSolver< T >::AztecLinearSolver(), libMesh::ParallelMesh::clear(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::UnstructuredMesh::create_pid_mesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::EnsightIO::EnsightIO(), libMesh::MeshBase::get_info(), libMesh::EquationSystems::init(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::Nemesis_IO_Helper::initialize(), libMesh::MeshTools::libmesh_assert_valid_dof_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::DofMap::local_variable_indices(), libMesh::MeshBase::n_active_elem_on_proc(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::Partitioner::partition(), libMesh::MeshBase::partition(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::PetscLinearSolver< T >::PetscLinearSolver(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::MeshTools::processor_bounding_box(), libMesh::System::project_vector(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::UnstructuredMesh::read(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::System::read_serialized_vector(), libMesh::Partitioner::repartition(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::BoundaryInfo::sync(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::CheckpointIO::write(), libMesh::GMVIO::write_binary(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::XdrIO::write_serialized_nodes(), and libMesh::XdrIO::write_serialized_nodesets()\&.
.PP
.nf
93   { return libmesh_cast_int<processor_id_type>(_communicator\&.size()); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_sub_elem () const\fC [inherited]\fP"
This function returns the number of elements that will be written out in the Tecplot format\&. For example, a 9-noded quadrilateral will be broken into 4 linear sub-elements for plotting purposes\&. Thus, for a mesh of 2 \fCQUAD9\fP elements \fCn_tecplot_elem()\fP will return 8\&. Implemented in terms of element_iterators\&. 
.PP
Definition at line 276 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::elements_begin(), libMesh::MeshBase::elements_end(), and end\&.
.PP
.nf
277 {
278   dof_id_type ne=0;
279 
280   const_element_iterator       el  = this->elements_begin();
281   const const_element_iterator end = this->elements_end();
282 
283   for (; el!=end; ++el)
284     ne += (*el)->n_sub_elem();
285 
286   return ne;
287 }
.fi
.SS "\fBsubdomain_id_type\fP libMesh::MeshBase::n_subdomains () const\fC [inherited]\fP"
Returns the number of subdomains in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 226 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::subdomain_ids()\&.
.PP
Referenced by libMesh::MeshBase::get_info(), libMesh::XdrIO::write(), and libMesh::UnstructuredMesh::write()\&.
.PP
.nf
227 {
228   // This requires an inspection on every processor
229   parallel_object_only();
230 
231   std::set<subdomain_id_type> ids;
232 
233   this->subdomain_ids (ids);
234 
235   return ids\&.size();
236 }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_elem () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of elements owned by no processor\&. 
.PP
Definition at line 289 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_elem_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_elem()\&.
.PP
.nf
290   { return this->n_elem_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBdof_id_type\fP libMesh::MeshBase::n_unpartitioned_nodes () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the number of nodes owned by no processor\&. 
.PP
Definition at line 203 of file mesh_base\&.h\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::MeshBase::n_nodes_on_proc()\&.
.PP
Referenced by libMesh::ParallelMesh::parallel_n_nodes()\&.
.PP
.nf
204   { return this->n_nodes_on_proc (DofObject::invalid_processor_id); }
.fi
.SS "\fBunique_id_type\fP libMesh::MeshBase::next_unique_id ()\fC [inline]\fP, \fC [inherited]\fP"
Returns the next unique id to be used\&. 
.PP
Definition at line 216 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
216 { return _next_unique_id; }
.fi
.SS "const \fBNode\fP & libMesh::ParallelMesh::node (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 229 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::libmesh_assert()\&.
.PP
.nf
230 {
231   libmesh_assert(_nodes[i]);
232   libmesh_assert_equal_to (_nodes[i]->id(), i);
233 
234   return (*_nodes[i]);
235 }
.fi
.SS "\fBNode\fP & libMesh::ParallelMesh::node (const \fBdof_id_type\fPi)\fC [virtual]\fP, \fC [inherited]\fP"
Return a reference to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 241 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::libmesh_assert()\&.
.PP
.nf
242 {
243   libmesh_assert(_nodes[i]);
244   libmesh_assert_equal_to (_nodes[i]->id(), i);
245 
246   return (*_nodes[i]);
247 }
.fi
.SS "const \fBNode\fP * libMesh::ParallelMesh::node_ptr (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 251 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::libmesh_assert()\&.
.PP
.nf
252 {
253   libmesh_assert(_nodes[i]);
254   libmesh_assert_equal_to (_nodes[i]->id(), i);
255 
256   return _nodes[i];
257 }
.fi
.SS "\fBNode\fP * libMesh::ParallelMesh::node_ptr (const \fBdof_id_type\fPi)\fC [virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ node, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 262 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::libmesh_assert()\&.
.PP
.nf
263 {
264   libmesh_assert(_nodes[i]);
265   libmesh_assert_equal_to (_nodes[i]->id(), i);
266 
267   return _nodes[i];
268 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::nodes_begin ()\fC [virtual]\fP, \fC [inherited]\fP"
non-const \fBNode\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 931 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
932 {
933   Predicates::NotNull<node_iterator_imp> p;
934   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
935 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::nodes_begin () const\fC [virtual]\fP, \fC [inherited]\fP"
const \fBNode\fP iterator accessor functions\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 971 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
972 {
973   Predicates::NotNull<const_node_iterator_imp> p;
974   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
975 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::nodes_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1011 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
1012 {
1013   Predicates::NotNull<node_iterator_imp> p;
1014   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1015 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::nodes_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1051 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1052 {
1053   Predicates::NotNull<const_node_iterator_imp> p;
1054   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1055 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_active_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 57 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
58 {
59   Predicates::NotActive<elem_iterator_imp> p;
60   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
61 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_active_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 281 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
282 {
283   Predicates::NotActive<const_elem_iterator_imp> p;
284   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
285 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_active_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 504 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
505 {
506   Predicates::NotActive<elem_iterator_imp> p;
507   return element_iterator(_elements\&.end(), _elements\&.end(), p);
508 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_active_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 729 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
730 {
731   Predicates::NotActive<const_elem_iterator_imp> p;
732   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
733 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_ancestor_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 77 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
78 {
79   Predicates::Ancestor<elem_iterator_imp> p;
80   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
81 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_ancestor_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 301 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
302 {
303   Predicates::Ancestor<const_elem_iterator_imp> p;
304   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
305 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_ancestor_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 524 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
525 {
526   Predicates::Ancestor<elem_iterator_imp> p;
527   return element_iterator(_elements\&.end(), _elements\&.end(), p);
528 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_ancestor_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 749 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
750 {
751   Predicates::Ancestor<const_elem_iterator_imp> p;
752   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
753 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_level_elements_begin (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 157 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
158 {
159   Predicates::NotLevel<elem_iterator_imp> p(level);
160   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
161 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_level_elements_begin (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 381 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
382 {
383   Predicates::NotLevel<const_elem_iterator_imp> p(level);
384   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
385 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_level_elements_end (const unsigned intlevel)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 604 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
605 {
606   Predicates::NotLevel<elem_iterator_imp> p(level);
607   return element_iterator(_elements\&.end(), _elements\&.end(), p);
608 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_level_elements_end (const unsigned intlevel) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 829 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
830 {
831   Predicates::NotLevel<const_elem_iterator_imp> p(level);
832   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
833 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_local_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 117 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
118 {
119   Predicates::NotLocal<elem_iterator_imp> p(this->processor_id());
120   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
121 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_local_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 341 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
342 {
343   Predicates::NotLocal<const_elem_iterator_imp> p(this->processor_id());
344   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
345 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_local_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 564 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
565 {
566   Predicates::NotLocal<elem_iterator_imp> p(this->processor_id());
567   return element_iterator(_elements\&.end(), _elements\&.end(), p);
568 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_local_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 789 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, and libMesh::ParallelObject::processor_id()\&.
.PP
.nf
790 {
791   Predicates::NotLocal<const_elem_iterator_imp> p(this->processor_id());
792   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
793 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_subactive_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 97 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
98 {
99   Predicates::NotSubActive<elem_iterator_imp> p;
100   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
101 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_subactive_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 321 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
322 {
323   Predicates::NotSubActive<const_elem_iterator_imp> p;
324   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
325 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::not_subactive_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 544 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
545 {
546   Predicates::NotSubActive<elem_iterator_imp> p;
547   return element_iterator(_elements\&.end(), _elements\&.end(), p);
548 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::not_subactive_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 769 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
770 {
771   Predicates::NotSubActive<const_elem_iterator_imp> p;
772   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
773 }
.fi
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::parallel_max_elem_id () const\fC [inherited]\fP"

.PP
Definition at line 178 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelObject::comm(), and libMesh::Parallel::Communicator::max()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
179 {
180   // This function must be run on all processors at once
181   parallel_object_only();
182 
183   dof_id_type max_local = _elements\&.empty() ?
184     0 : _elements\&.rbegin()->first + 1;
185   this->comm()\&.max(max_local);
186   return max_local;
187 }
.fi
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::parallel_max_node_id () const\fC [inherited]\fP"

.PP
Definition at line 204 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::ParallelObject::comm(), and libMesh::Parallel::Communicator::max()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
205 {
206   // This function must be run on all processors at once
207   parallel_object_only();
208 
209   dof_id_type max_local = _nodes\&.empty() ?
210     0 : _nodes\&.rbegin()->first + 1;
211   this->comm()\&.max(max_local);
212   return max_local;
213 }
.fi
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::parallel_n_elem () const\fC [virtual]\fP, \fC [inherited]\fP"
Returns the number of elements in the mesh\&. The \fBparallel_n_elem()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 165 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelObject::comm(), libMesh::n_local, libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_unpartitioned_elem(), and libMesh::Parallel::Communicator::sum()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
166 {
167   // This function must be run on all processors at once
168   parallel_object_only();
169 
170   dof_id_type n_local = this->n_local_elem();
171   this->comm()\&.sum(n_local);
172   n_local += this->n_unpartitioned_elem();
173   return n_local;
174 }
.fi
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::parallel_n_nodes () const\fC [virtual]\fP, \fC [inherited]\fP"
Returns the number of nodes in the mesh\&. This function and others must be defined in derived classes since the \fBMeshBase\fP class has no specific storage for nodes or elements\&. The \fBparallel_n_nodes()\fP function returns a newly calculated parallel-synchronized value on distributed meshes, and so must be called in parallel only\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 191 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelObject::comm(), libMesh::n_local, libMesh::MeshBase::n_local_nodes(), libMesh::MeshBase::n_unpartitioned_nodes(), and libMesh::Parallel::Communicator::sum()\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
192 {
193   // This function must be run on all processors at once
194   parallel_object_only();
195 
196   dof_id_type n_local = this->n_local_nodes();
197   this->comm()\&.sum(n_local);
198   n_local += this->n_unpartitioned_nodes();
199   return n_local;
200 }
.fi
.SS "void libMesh::MeshBase::partition (const unsigned intn_parts)\fC [virtual]\fP, \fC [inherited]\fP"
Call the default partitioner (currently \fCmetis_partition()\fP)\&. 
.PP
Definition at line 344 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::is_serial(), libMesh::MeshBase::partitioner(), libMesh::MeshBase::recalculate_n_partitions(), libMesh::MeshBase::skip_partitioning(), and libMesh::MeshBase::update_post_partitioning()\&.
.PP
.nf
345 {
346   // NULL partitioner means don't partition
347   // Non-serial meshes aren't ready for partitioning yet\&.
348   if(!skip_partitioning() &&
349      partitioner()\&.get() &&
350      this->is_serial())
351     {
352       partitioner()->partition (*this, n_parts);
353     }
354   else
355     {
356       // Make sure locally cached partition count
357       this->recalculate_n_partitions();
358 
359       // Make sure any other locally cached data is correct
360       this->update_post_partitioning();
361     }
362 }
.fi
.SS "void libMesh::MeshBase::partition ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 514 of file mesh_base\&.h\&.
.PP
References libMesh::ParallelObject::n_processors()\&.
.PP
Referenced by libMesh::MeshBase::prepare_for_use()\&.
.PP
.nf
515   { this->partition(this->n_processors()); }
.fi
.SS "virtual \fBAutoPtr\fP<\fBPartitioner\fP>& libMesh::MeshBase::partitioner ()\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP 
.PP
Definition at line 115 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_partitioner\&.
.PP
Referenced by libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::MeshBase::partition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
115 { return _partitioner; }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::pid_elements_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 187 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::unpartitioned_elements_begin()\&.
.PP
.nf
188 {
189   Predicates::PID<elem_iterator_imp> p(proc_id);
190   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
191 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::pid_elements_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 411 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
412 {
413   Predicates::PID<const_elem_iterator_imp> p(proc_id);
414   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
415 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::pid_elements_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 634 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
Referenced by libMesh::ParallelMesh::unpartitioned_elements_end()\&.
.PP
.nf
635 {
636   Predicates::PID<elem_iterator_imp> p(proc_id);
637   return element_iterator(_elements\&.end(), _elements\&.end(), p);
638 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::pid_elements_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 858 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
859 {
860   Predicates::PID<const_elem_iterator_imp> p(proc_id);
861   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
862 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 961 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
962 {
963   Predicates::PID<node_iterator_imp> p(proc_id);
964   return node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
965 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::pid_nodes_begin (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1001 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1002 {
1003   Predicates::PID<const_node_iterator_imp> p(proc_id);
1004   return const_node_iterator(_nodes\&.begin(), _nodes\&.end(), p);
1005 }
.fi
.SS "\fBParallelMesh::node_iterator\fP libMesh::ParallelMesh::pid_nodes_end (const \fBprocessor_id_type\fPproc_id)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1041 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1042 {
1043   Predicates::PID<node_iterator_imp> p(proc_id);
1044   return node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1045 }
.fi
.SS "\fBParallelMesh::const_node_iterator\fP libMesh::ParallelMesh::pid_nodes_end (const \fBprocessor_id_type\fPproc_id) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1081 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes\&.
.PP
.nf
1082 {
1083   Predicates::PID<const_node_iterator_imp> p(proc_id);
1084   return const_node_iterator(_nodes\&.end(), _nodes\&.end(), p);
1085 }
.fi
.SS "const \fBPoint\fP & libMesh::ParallelMesh::point (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a constant reference (for reading only) to the $ i^{th} $ point, which should be present in this processor's subset of the mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 217 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, and libMesh::libmesh_assert()\&.
.PP
.nf
218 {
219   libmesh_assert(_nodes[i]);
220   libmesh_assert_equal_to (_nodes[i]->id(), i);
221 
222   return (*_nodes[i]);
223 }
.fi
.SS "const \fBPointLocatorBase\fP & libMesh::MeshBase::point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should never be used in threaded or non-parallel_only code, and so is deprecated\&. 
.PP
Definition at line 384 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
.nf
385 {
386   libmesh_deprecated();
387 
388   if (_point_locator\&.get() == NULL)
389     {
390       // PointLocator construction may not be safe within threads
391       libmesh_assert(!Threads::in_threads);
392 
393       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
394     }
395 
396   return *_point_locator;
397 }
.fi
.SS "void libMesh::MeshBase::prepare_for_use (const boolskip_renumber_nodes_and_elements = \fCfalse\fP, const boolskip_find_neighbors = \fCfalse\fP)\fC [inherited]\fP"
Prepare a newly created (or read) mesh for use\&. This involves 3 steps: 1\&.) call \fC\fBfind_neighbors()\fP\fP 2\&.) call \fC\fBpartition()\fP\fP 3\&.) call \fC\fBrenumber_nodes_and_elements()\fP\fP 
.PP
The argument to skip renumbering is now deprecated - to prevent a mesh from being renumbered, set allow_renumbering(false)\&. 
.PP
Definition at line 120 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_is_prepared, libMesh::MeshBase::_skip_renumber_nodes_and_elements, libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::assign_unique_ids(), libMesh::MeshBase::clear_point_locator(), libMesh::ParallelObject::comm(), libMesh::MeshBase::delete_remote_elements(), libMesh::dim, libMesh::MeshBase::find_neighbors(), libMesh::MeshBase::is_serial(), libMesh::libmesh_assert(), libMesh::Parallel::Communicator::max(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::partition(), libMesh::MeshBase::renumber_nodes_and_elements(), libMesh::MeshBase::set_mesh_dimension(), libMesh::MeshBase::update_parallel_id_counts(), and libMesh::Parallel::verify()\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::MeshRefinement::coarsen_elements(), libMesh::UnstructuredMesh::create_submesh(), libMesh::MeshTools::Modification::flatten(), libMesh::MeshTools::Subdivision::prepare_subdivision_mesh(), libMesh::GMVIO::read(), libMesh::UnstructuredMesh::read(), libMesh::MeshRefinement::refine_and_coarsen_elements(), libMesh::MeshRefinement::refine_elements(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::MeshRefinement::uniformly_coarsen(), and libMesh::MeshRefinement::uniformly_refine()\&.
.PP
.nf
121 {
122   parallel_object_only();
123 
124   // A distributed mesh may have processors with no elements (or
125   // processors with no elements of higher dimension, if we ever
126   // support mixed-dimension meshes), but we want consistent
127   // mesh_dimension anyways\&.
128   libmesh_assert(this->comm()\&.verify(this->is_serial()));
129 
130   if (!this->is_serial())
131     {
132       unsigned int dim = this->mesh_dimension();
133       this->comm()\&.max(dim);
134       this->set_mesh_dimension(dim);
135     }
136 
137   // Renumber the nodes and elements so that they in contiguous
138   // blocks\&.  By default, _skip_renumber_nodes_and_elements is false\&.
139   //
140   // We may currently change that by passing
141   // skip_renumber_nodes_and_elements==true to this function, but we
142   // should use the allow_renumbering() accessor instead\&.
143   //
144   // Instances where you if prepare_for_use() should not renumber the nodes
145   // and elements include reading in e\&.g\&. an xda/r or gmv file\&. In
146   // this case, the ordering of the nodes may depend on an accompanying
147   // solution, and the node ordering cannot be changed\&.
148 
149   if (skip_renumber_nodes_and_elements)
150     {
151       libmesh_deprecated();
152       this->allow_renumbering(false);
153     }
154 
155   // Mesh modification operations might not leave us with consistent
156   // id counts, but our partitioner might need that consistency\&.
157   if(!_skip_renumber_nodes_and_elements)
158     this->renumber_nodes_and_elements();
159   else
160     this->update_parallel_id_counts();
161 
162   // Let all the elements find their neighbors
163   if(!skip_find_neighbors)
164     this->find_neighbors();
165 
166   // Partition the mesh\&.
167   this->partition();
168 
169   // If we're using ParallelMesh, we'll want it parallelized\&.
170   this->delete_remote_elements();
171 
172 #ifdef LIBMESH_ENABLE_UNIQUE_ID
173   // Assign DOF object unique ids
174   this->assign_unique_ids();
175 #endif
176 
177   if(!_skip_renumber_nodes_and_elements)
178     this->renumber_nodes_and_elements();
179 
180   // Reset our PointLocator\&.  This needs to happen any time the elements
181   // in the underlying elements in the mesh have changed, so we do it here\&.
182   this->clear_point_locator();
183 
184   // The mesh is now prepared for use\&.
185   _is_prepared = true;
186 }
.fi
.SS "void libMesh::MeshBase::print_info (std::ostream &os = \fC\fBlibMesh::out\fP\fP) const\fC [inherited]\fP"
Prints relevant information about the mesh\&. 
.PP
Definition at line 330 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::get_info()\&.
.PP
Referenced by libMesh::InfElemBuilder::build_inf_elem(), and libMesh::operator<<()\&.
.PP
.nf
331 {
332   os << this->get_info()
333      << std::endl;
334 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::ParallelObject::processor_id () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
\fBReturns:\fP
.RS 4
the rank of this processor in the group\&. 
.RE
.PP

.PP
Definition at line 98 of file parallel_object\&.h\&.
.PP
References libMesh::ParallelObject::_communicator, and libMesh::Parallel::Communicator::rank()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::EquationSystems::_read_impl(), libMesh::SerialMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::SerialMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::SerialMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::SerialMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::SerialMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::SerialMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_second_order(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::EquationSystems::build_discontinuous_solution_vector(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::DofMap::build_sparsity(), libMesh::ParallelMesh::clear(), libMesh::ExodusII_IO_Helper::close(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_communication_map_parameters(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_node_communication_maps(), libMesh::Nemesis_IO_Helper::compute_num_global_elem_blocks(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::Nemesis_IO_Helper::construct_nemesis_filename(), libMesh::ExodusII_IO_Helper::create(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::end_dof(), libMesh::DofMap::end_old_dof(), libMesh::EnsightIO::EnsightIO(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::DofMap::first_dof(), libMesh::DofMap::first_old_dof(), libMesh::Nemesis_IO_Helper::get_cmap_params(), libMesh::Nemesis_IO_Helper::get_eb_info_global(), libMesh::Nemesis_IO_Helper::get_elem_cmap(), libMesh::Nemesis_IO_Helper::get_elem_map(), libMesh::MeshBase::get_info(), libMesh::Nemesis_IO_Helper::get_init_global(), libMesh::Nemesis_IO_Helper::get_init_info(), libMesh::Nemesis_IO_Helper::get_loadbal_param(), libMesh::Nemesis_IO_Helper::get_node_cmap(), libMesh::Nemesis_IO_Helper::get_node_map(), libMesh::Nemesis_IO_Helper::get_ns_param_global(), libMesh::Nemesis_IO_Helper::get_ss_param_global(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), libMesh::SystemSubsetBySubdomain::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::ExodusII_IO_Helper::initialize_element_variables(), libMesh::ExodusII_IO_Helper::initialize_global_variables(), libMesh::ExodusII_IO_Helper::initialize_nodal_variables(), libMesh::SparsityPattern::Build::join(), libMesh::DofMap::last_dof(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::SerialMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_begin(), libMesh::SerialMesh::local_elements_end(), libMesh::ParallelMesh::local_elements_end(), libMesh::SerialMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::SerialMesh::local_level_elements_end(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::SerialMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::SerialMesh::local_nodes_end(), libMesh::ParallelMesh::local_nodes_end(), libMesh::SerialMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::SerialMesh::local_not_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshBase::n_active_local_elem(), libMesh::BoundaryInfo::n_boundary_conds(), libMesh::BoundaryInfo::n_edge_conds(), libMesh::DofMap::n_local_dofs(), libMesh::System::n_local_dofs(), libMesh::MeshBase::n_local_elem(), libMesh::MeshBase::n_local_nodes(), libMesh::BoundaryInfo::n_nodeset_conds(), libMesh::SerialMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::SerialMesh::not_local_elements_end(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::SparsityPattern::Build::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::MeshFunction::operator()(), libMesh::ParallelMesh::ParallelMesh(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), libMesh::System::project_vector(), libMesh::Nemesis_IO_Helper::put_cmap_params(), libMesh::Nemesis_IO_Helper::put_elem_cmap(), libMesh::Nemesis_IO_Helper::put_elem_map(), libMesh::Nemesis_IO_Helper::put_loadbal_param(), libMesh::Nemesis_IO_Helper::put_node_cmap(), libMesh::Nemesis_IO_Helper::put_node_map(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::UnstructuredMesh::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::ExodusII_IO_Helper::read_elem_num_map(), libMesh::System::read_header(), libMesh::System::read_legacy_data(), libMesh::ExodusII_IO_Helper::read_node_num_map(), libMesh::System::read_parallel_data(), libMesh::System::read_SCALAR_dofs(), libMesh::XdrIO::read_serialized_bc_names(), libMesh::XdrIO::read_serialized_bcs(), libMesh::System::read_serialized_blocked_dof_objects(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::System::read_serialized_data(), libMesh::XdrIO::read_serialized_nodes(), libMesh::XdrIO::read_serialized_nodesets(), libMesh::XdrIO::read_serialized_subdomain_names(), libMesh::System::read_serialized_vector(), libMesh::System::read_serialized_vectors(), libMesh::MeshData::read_xdr(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::BoundaryInfo::sync(), libMesh::MeshTools::total_weight(), libMesh::ParallelMesh::update_parallel_id_counts(), libMesh::MeshTools::weight(), libMesh::ExodusII_IO::write(), libMesh::CheckpointIO::write(), libMesh::XdrIO::write(), libMesh::UnstructuredMesh::write(), libMesh::EquationSystems::write(), libMesh::GMVIO::write_discontinuous_gmv(), libMesh::ExodusII_IO::write_element_data(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::ExodusII_IO::write_global_data(), libMesh::ExodusII_IO_Helper::write_global_values(), libMesh::System::write_header(), libMesh::ExodusII_IO::write_information_records(), libMesh::ExodusII_IO_Helper::write_information_records(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::UCDIO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_discontinuous(), libMesh::ExodusII_IO_Helper::write_nodal_values(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::System::write_parallel_data(), libMesh::System::write_SCALAR_dofs(), libMesh::XdrIO::write_serialized_bc_names(), libMesh::XdrIO::write_serialized_bcs(), libMesh::System::write_serialized_blocked_dof_objects(), libMesh::XdrIO::write_serialized_connectivity(), libMesh::System::write_serialized_data(), libMesh::XdrIO::write_serialized_nodes(), libMesh::XdrIO::write_serialized_nodesets(), libMesh::XdrIO::write_serialized_subdomain_names(), libMesh::System::write_serialized_vector(), libMesh::System::write_serialized_vectors(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::ExodusII_IO::write_timestep(), and libMesh::ExodusII_IO_Helper::write_timestep()\&.
.PP
.nf
99   { return libmesh_cast_int<processor_id_type>(_communicator\&.rank()); }
.fi
.SS "const \fBElem\fP * libMesh::ParallelMesh::query_elem (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 327 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
.nf
328 {
329   std::map<dof_id_type, Elem*>::const_iterator it = _elements\&.find(i);
330   if (it != _elements\&.end()\&.it)
331     {
332       const Elem* e = it->second;
333       libmesh_assert (!e || e->id() == i);
334       return e;
335     }
336 
337   return NULL;
338 }
.fi
.SS "\fBElem\fP * libMesh::ParallelMesh::query_elem (const \fBdof_id_type\fPi)\fC [virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ element, or NULL if no such element exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 343 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
.nf
344 {
345   std::map<dof_id_type, Elem*>::const_iterator it = _elements\&.find(i);
346   if (it != _elements\&.end()\&.it)
347     {
348       Elem* e = _elements[i];
349       libmesh_assert (!e || e->id() == i);
350       return e;
351     }
352 
353   return NULL;
354 }
.fi
.SS "const \fBNode\fP * libMesh::ParallelMesh::query_node_ptr (const \fBdof_id_type\fPi) const\fC [virtual]\fP, \fC [inherited]\fP"
Return a pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 273 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
.nf
274 {
275   std::map<dof_id_type, Node*>::const_iterator it = _nodes\&.find(i);
276   if (it != _nodes\&.end()\&.it)
277     {
278       const Node* n = it->second;
279       libmesh_assert (!n || n->id() == i);
280       return n;
281     }
282 
283   return NULL;
284 }
.fi
.SS "\fBNode\fP * libMesh::ParallelMesh::query_node_ptr (const \fBdof_id_type\fPi)\fC [virtual]\fP, \fC [inherited]\fP"
Return a writeable pointer to the $ i^{th} $ node, or NULL if no such node exists in this processor's mesh data structure\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 289 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::DofObject::id(), and libMesh::libmesh_assert()\&.
.PP
.nf
290 {
291   std::map<dof_id_type, Node*>::const_iterator it = _nodes\&.find(i);
292   if (it != _nodes\&.end()\&.it)
293     {
294       Node* n = it->second;
295       libmesh_assert (!n || n->id() == i);
296       return n;
297     }
298 
299   return NULL;
300 }
.fi
.SS "void libMesh::UnstructuredMesh::read (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP, boolskip_renumber_nodes_and_elements = \fCfalse\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Reads the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. This is now the only way to read a mesh\&. The \fC\fBUnstructuredMesh\fP\fP then initializes its data structures and is ready for use\&.
.PP
In order to read the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you will use with this mesh, since these read methods expect it\&.
.PP
The skip_renumber_nodes_and_elements argument is now deprecated - to disallow renumbering, set \fCMeshBase::allow_renumbering(false)\fP 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 514 of file unstructured_mesh\&.C\&.
.PP
References libMesh::MeshBase::allow_renumbering(), libMesh::XdrIO::binary(), libMesh::MeshCommunication::broadcast(), libMesh::err, libMesh::XdrIO::legacy(), libMesh::ParallelObject::n_processors(), libMesh::Quality::name(), libMesh::MeshBase::prepare_for_use(), libMesh::ParallelObject::processor_id(), libMesh::AbaqusIO::read(), libMesh::OFFIO::read(), libMesh::UCDIO::read(), libMesh::TetGenIO::read(), libMesh::UNVIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GmshIO::read(), libMesh::GMVIO::read(), libMesh::CheckpointIO::read(), libMesh::XdrIO::read(), libMesh::VTKIO::read(), libMesh::MatlabIO::read(), libMesh::LegacyXdrIO::read_mgf(), libMesh::START_LOG(), and libMesh::STOP_LOG()\&.
.PP
.nf
517 {
518   // See if the file exists\&.  Perform this check on all processors
519   // so that the code is terminated properly in the case that the
520   // file does not exist\&.
521 
522   // For Nemesis files, the name we try to read will have suffixes
523   // identifying processor rank
524   if (name\&.rfind("\&.nem") + 4 == name\&.size() ||
525       name\&.rfind("\&.n") + 2 == name\&.size())
526     {
527       std::ostringstream full_name;
528 
529       // Find the length of a string which represents the highest processor ID
530       full_name << (this->n_processors());
531       unsigned field_width = full_name\&.str()\&.size();
532 
533       // reset the string stream
534       full_name\&.str("");
535 
536       // And build up the full filename
537       full_name << name
538                 << '\&.' << this->n_processors()
539                 << '\&.' << std::setfill('0') << std::setw(field_width) << this->processor_id();
540 
541       std::ifstream in (full_name\&.str()\&.c_str());
542 
543       if (!in\&.good())
544         {
545           libMesh::err << "ERROR: cannot locate specified file:\n\t"
546                        << full_name\&.str()
547                        << std::endl;
548           libmesh_error();
549         }
550     }
551   else if(name\&.rfind("\&.cp")) {} // Do error checking in the reader
552   else
553     {
554       std::ifstream in (name\&.c_str());
555 
556       if (!in\&.good())
557         {
558           libMesh::err << "ERROR: cannot locate specified file:\n\t"
559                        << name
560                        << std::endl;
561           libmesh_error();
562         }
563     }
564 
565   // Set the skip_renumber_nodes_and_elements flag on all processors\&.
566   // This ensures that renumber_nodes_and_elements is *not* called
567   // during prepare_for_use() for certain types of mesh files\&.
568   // This is required in cases where there is an associated solution
569   // file which expects a certain ordering of the nodes\&.
570   if(name\&.rfind("\&.gmv")+4==name\&.size())
571     {
572       skip_renumber_nodes_and_elements =  true;
573     }
574 
575   // Look for parallel formats first
576   if (is_parallel_file_format(name))
577     {
578       // no need to handle bz2 files here -- the Xdr class does that\&.
579       if ((name\&.rfind("\&.xda") < name\&.size()) ||
580           (name\&.rfind("\&.xdr") < name\&.size()))
581         {
582           XdrIO xdr_io(*this);
583 
584           // \&.xda* ==> bzip2/gzip/ASCII flavors
585           if (name\&.rfind("\&.xda") < name\&.size())
586             {
587               xdr_io\&.binary() = false;
588               xdr_io\&.read (name);
589             }
590           else // \&.xdr* ==> true binary XDR file
591             {
592               xdr_io\&.binary() = true;
593               xdr_io\&.read (name);
594             }
595 
596           // The xdr_io object gets constructed with legacy() == false\&.
597           // if legacy() == true then it means that a legacy file was detected and
598           // thus processor 0 performed the read\&. We therefore need to broadcast the
599           // mesh\&.  Further, for this flavor of mesh solution data ordering is tied
600           // to the node ordering, so we better not reorder the nodes!
601           if (xdr_io\&.legacy())
602             {
603               this->allow_renumbering(false);
604               MeshCommunication()\&.broadcast(*this);
605             }
606 
607           // libHilbert-enabled libMesh builds should construct files
608           // with a canonical node ordering, which libHilbert-enabled
609           // builds will be able to read in again regardless of any
610           // renumbering\&.  So in that case we're free to renumber\&.
611           // However, if either the writer or the reader of this file
612           // don't have libHilbert, then we'll have to skip
613           // renumbering because we need the numbering to remain
614           // consistent with any solution file we read in next\&.
615 #ifdef LIBMESH_HAVE_LIBHILBERT
616           // if (!xdr_io\&.libhilbert_ordering())
617           //   skip_renumber_nodes_and_elements = true;
618 #else
619           this->allow_renumbering(false);
620 #endif
621         }
622       else if (name\&.rfind("\&.nem") < name\&.size() ||
623                name\&.rfind("\&.n")   < name\&.size())
624         Nemesis_IO(*this)\&.read (name);
625       else if (name\&.rfind("\&.cp") < name\&.size())
626         {
627           if(name\&.rfind("\&.cpa") < name\&.size())
628             CheckpointIO(*this, false)\&.read(name);
629           else
630             CheckpointIO(*this, true)\&.read(name);
631         }
632     }
633 
634   // Serial mesh formats
635   else
636     {
637       START_LOG("read()", "Mesh");
638 
639       // Read the file based on extension\&.  Only processor 0
640       // needs to read the mesh\&.  It will then broadcast it and
641       // the other processors will pick it up
642       if (this->processor_id() == 0)
643         {
644           std::ostringstream pid_suffix;
645           pid_suffix << '_' << getpid();
646           // Nasty hack for reading/writing zipped files
647           std::string new_name = name;
648           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
649             {
650 #ifdef LIBMESH_HAVE_BZIP
651               new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
652               new_name += pid_suffix\&.str();
653               std::string system_string = "bunzip2 -f -k -c ";
654               system_string += name + " > " + new_name;
655               START_LOG("system(bunzip2)", "Mesh");
656               if (std::system(system_string\&.c_str()))
657                 libmesh_file_error(system_string);
658               STOP_LOG("system(bunzip2)", "Mesh");
659 #else
660               libMesh::err << "ERROR: need bzip2/bunzip2 to open \&.bz2 file "
661                            << name << std::endl;
662               libmesh_error();
663 #endif
664             }
665           else if (name\&.size() - name\&.rfind("\&.xz") == 3)
666             {
667 #ifdef LIBMESH_HAVE_XZ
668               new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
669               new_name += pid_suffix\&.str();
670               std::string system_string = "xz -f -d -k -c ";
671               system_string += name + " > " + new_name;
672               START_LOG("system(xz -d)", "XdrIO");
673               if (std::system(system_string\&.c_str()))
674                 libmesh_file_error(system_string);
675               STOP_LOG("system(xz -d)", "XdrIO");
676 #else
677               libMesh::err << "ERROR: need xz to open \&.xz file "
678                            << name << std::endl;
679               libmesh_error();
680 #endif
681             }
682 
683           if (new_name\&.rfind("\&.mat") < new_name\&.size())
684             MatlabIO(*this)\&.read(new_name);
685 
686           else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
687             UCDIO(*this)\&.read (new_name);
688 
689           else if ((new_name\&.rfind("\&.off")  < new_name\&.size()) ||
690                    (new_name\&.rfind("\&.ogl")  < new_name\&.size()) ||
691                    (new_name\&.rfind("\&.oogl") < new_name\&.size()))
692             OFFIO(*this)\&.read (new_name);
693 
694           else if (new_name\&.rfind("\&.mgf") < new_name\&.size())
695             LegacyXdrIO(*this,true)\&.read_mgf (new_name);
696 
697           else if (new_name\&.rfind("\&.unv") < new_name\&.size())
698             {
699               if (mesh_data == NULL)
700                 {
701                   libMesh::err << "Error! You must pass a "
702                                << "valid MeshData pointer to "
703                                << "read UNV files!" << std::endl;
704                   libmesh_error();
705                 }
706               UNVIO(*this, *mesh_data)\&.read (new_name);
707             }
708 
709           else if ((new_name\&.rfind("\&.node")  < new_name\&.size()) ||
710                    (new_name\&.rfind("\&.ele")   < new_name\&.size()))
711             TetGenIO(*this,mesh_data)\&.read (new_name);
712 
713           else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
714                    new_name\&.rfind("\&.e") < new_name\&.size())
715             ExodusII_IO(*this)\&.read (new_name);
716 
717           else if (new_name\&.rfind("\&.msh") < new_name\&.size())
718             GmshIO(*this)\&.read (new_name);
719 
720           else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
721             GMVIO(*this)\&.read (new_name);
722 
723           else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
724             VTKIO(*this)\&.read(new_name);
725 
726           else if (new_name\&.rfind("\&.inp") < new_name\&.size())
727             AbaqusIO(*this)\&.read(new_name);
728 
729           else
730             {
731               libMesh::err << " ERROR: Unrecognized file extension: " << name
732                            << "\n   I understand the following:\n\n"
733                            << "     *\&.e    -- Sandia's ExodusII format\n"
734                            << "     *\&.exd  -- Sandia's ExodusII format\n"
735                            << "     *\&.gmv  -- LANL's General Mesh Viewer format\n"
736                            << "     *\&.mat  -- Matlab triangular ASCII file\n"
737                            << "     *\&.n    -- Sandia's Nemesis format\n"
738                            << "     *\&.nem  -- Sandia's Nemesis format\n"
739                            << "     *\&.off  -- OOGL OFF surface format\n"
740                            << "     *\&.ucd  -- AVS's ASCII UCD format\n"
741                            << "     *\&.unv  -- I-deas Universal format\n"
742                            << "     *\&.vtu  -- Paraview VTK format\n"
743                            << "     *\&.inp  -- Abaqus \&.inp format\n"
744                            << "     *\&.xda  -- libMesh ASCII format\n"
745                            << "     *\&.xdr  -- libMesh binary format\n"
746                            << "     *\&.gz   -- any above format gzipped\n"
747                            << "     *\&.bz2  -- any above format bzip2'ed\n"
748                            << "     *\&.xz   -- any above format xzipped\n"
749                            << "     *\&.cpa  -- libMesh Checkpoint ASCII format\n"
750                            << "     *\&.cpr  -- libMesh Checkpoint binary format\n"
751 
752                            << std::endl;
753               libmesh_error();
754             }
755 
756           // If we temporarily decompressed a file, remove the
757           // uncompressed version
758           if (name\&.size() - name\&.rfind("\&.bz2") == 4)
759             std::remove(new_name\&.c_str());
760           if (name\&.size() - name\&.rfind("\&.xz") == 3)
761             std::remove(new_name\&.c_str());
762         }
763 
764 
765       STOP_LOG("read()", "Mesh");
766 
767       // Send the mesh & bcs (which are now only on processor 0) to the other
768       // processors
769       MeshCommunication()\&.broadcast (*this);
770     }
771 
772   if (skip_renumber_nodes_and_elements)
773     {
774       // Use MeshBase::allow_renumbering() yourself instead\&.
775       libmesh_deprecated();
776       this->allow_renumbering(false);
777     }
778 
779   // Done reading the mesh\&.  Now prepare it for use\&.
780   this->prepare_for_use();
781 }
.fi
.SS "unsigned int libMesh::MeshBase::recalculate_n_partitions ()\fC [inherited]\fP"
In a few (very rare) cases, the user may have manually tagged the elements with specific processor IDs by hand, without using a partitioner\&. In this case, the \fBMesh\fP will not know that the total number of partitions, _n_parts, has changed, unless you call this function\&. This is an O(N active elements) calculation\&. The return value is the number of partitions, and _n_parts is also set by this function\&. 
.PP
Definition at line 364 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_n_parts, libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, std::max(), and libMesh::Parallel::Communicator::max()\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
365 {
366   const_element_iterator       el  = this->active_elements_begin();
367   const const_element_iterator end = this->active_elements_end();
368 
369   unsigned int max_proc_id=0;
370 
371   for (; el!=end; ++el)
372     max_proc_id = std::max(max_proc_id, static_cast<unsigned int>((*el)->processor_id()));
373 
374   // The number of partitions is one more than the max processor ID\&.
375   _n_parts = max_proc_id+1;
376 
377   this->comm()\&.max(_n_parts);
378 
379   return _n_parts;
380 }
.fi
.SS "void libMesh::ParallelMesh::redistribute ()\fC [virtual]\fP, \fC [inherited]\fP"
Redistribute elements between processors\&. This gets called automatically by the \fBPartitioner\fP, and is a no-op in the case of a serialized mesh\&. 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 710 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::is_serial(), libMesh::MeshCommunication::redistribute(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
711 {
712   // If this is a truly parallel mesh, go through the redistribution/gather/delete remote steps
713   if (!this->is_serial())
714     {
715       // Construct a MeshCommunication object to actually redistribute the nodes
716       // and elements according to the partitioner, and then to re-gather the neighbors\&.
717       MeshCommunication mc;
718       mc\&.redistribute(*this);
719 
720       this->update_parallel_id_counts();
721 
722       // Is this necessary?  If we are called from prepare_for_use(), this will be called
723       // anyway\&.\&.\&. but users can always call partition directly, in which case we do need
724       // to call delete_remote_elements()\&.\&.\&.
725       //
726       // Regardless of whether it's necessary, it isn't safe\&.  We
727       // haven't communicated new node processor_ids yet, and we can't
728       // delete nodes until we do\&.
729       // this->delete_remote_elements();
730     }
731 }
.fi
.SS "template<typename T > \fBdof_id_type\fP libMesh::ParallelMesh::renumber_dof_objects (\fBmapvector\fP< T *, \fBdof_id_type\fP > &objects)\fC [inherited]\fP"
Renumber a parallel objects container Returns the smallest globally unused id for that container\&. 
.PP
Definition at line 843 of file parallel_mesh\&.C\&.
.PP
References libMesh::mapvector< Val, index_t >::begin(), libMesh::comm, libMesh::mapvector< Val, index_t >::end(), end, libMesh::mapvector< Val, index_t >::erase(), libMesh::DofObject::invalid_processor_id, libMesh::DofObject::invalid_unique_id, libMesh::libmesh_assert(), libMesh::n_processors(), libMesh::MeshTools::Subdivision::next, libMesh::processor_id(), and libMesh::Parallel::verify()\&.
.PP
Referenced by libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.PP
.nf
844 {
845   // This function must be run on all processors at once
846   parallel_object_only();
847 
848   typedef typename mapvector<T*,dof_id_type>::veclike_iterator object_iterator;
849 
850   // In parallel we may not know what objects other processors have\&.
851   // Start by figuring out how many
852   dof_id_type unpartitioned_objects = 0;
853 
854   std::vector<dof_id_type>
855     ghost_objects_from_proc(this->n_processors(), 0);
856 
857   object_iterator it  = objects\&.begin();
858   object_iterator end = objects\&.end();
859 
860   for (; it != end;)
861     {
862       T *obj = *it;
863 
864       // Remove any NULL container entries while we're here,
865       // being careful not to invalidate our iterator
866       if (!*it)
867         objects\&.erase(it++);
868       else
869         {
870           processor_id_type obj_procid = obj->processor_id();
871           if (obj_procid == DofObject::invalid_processor_id)
872             unpartitioned_objects++;
873           else
874             ghost_objects_from_proc[obj_procid]++;
875           ++it;
876         }
877     }
878 
879   std::vector<dof_id_type> objects_on_proc(this->n_processors(), 0);
880   this->comm()\&.allgather(ghost_objects_from_proc[this->processor_id()],
881                          objects_on_proc);
882 
883 #ifndef NDEBUG
884   libmesh_assert(this->comm()\&.verify(unpartitioned_objects));
885   for (processor_id_type p=0; p != this->n_processors(); ++p)
886     libmesh_assert_less_equal (ghost_objects_from_proc[p], objects_on_proc[p]);
887 #endif
888 
889   // We'll renumber objects in blocks by processor id
890   std::vector<dof_id_type> first_object_on_proc(this->n_processors());
891   for (processor_id_type i=1; i != this->n_processors(); ++i)
892     first_object_on_proc[i] = first_object_on_proc[i-1] +
893       objects_on_proc[i-1];
894   dof_id_type next_id = first_object_on_proc[this->processor_id()];
895   dof_id_type first_free_id =
896     first_object_on_proc[this->n_processors()-1] +
897     objects_on_proc[this->n_processors()-1] +
898     unpartitioned_objects;
899 
900   // First set new local object ids and build request sets
901   // for non-local object ids
902 
903   // Request sets to send to each processor
904   std::vector<std::vector<dof_id_type> >
905     requested_ids(this->n_processors());
906 
907 #ifdef LIBMESH_ENABLE_UNIQUE_ID
908   std::vector<std::vector<unique_id_type> >
909     requested_unique_ids(this->n_processors());
910 #endif
911 
912   // We know how many objects live on each processor, so reseve() space for
913   // each\&.
914   for (processor_id_type p=0; p != this->n_processors(); ++p)
915     if (p != this->processor_id())
916       {
917         requested_ids[p]\&.reserve(ghost_objects_from_proc[p]);
918 #ifdef LIBMESH_ENABLE_UNIQUE_ID
919         requested_unique_ids[p]\&.reserve(ghost_objects_from_proc[p]);
920 #endif
921       }
922 
923   end = objects\&.end();
924   for (it = objects\&.begin(); it != end; ++it)
925     {
926       T *obj = *it;
927       if (obj->processor_id() == this->processor_id())
928         obj->set_id(next_id++);
929       else if (obj->processor_id() != DofObject::invalid_processor_id)
930         {
931           requested_ids[obj->processor_id()]\&.push_back(obj->id());
932 #ifdef LIBMESH_ENABLE_UNIQUE_ID
933           // It's possible to have an invalid id for dofs not owned by this process\&.
934           // We'll assert that they match on the receiving end\&.
935           requested_unique_ids[obj->processor_id()]\&.push_back(obj->valid_unique_id() ? obj-> unique_id() : DofObject::invalid_unique_id);
936 #endif
937         }
938     }
939 
940   // Next set ghost object ids from other processors
941   if (this->n_processors() > 1)
942     {
943       for (processor_id_type p=1; p != this->n_processors(); ++p)
944         {
945           // Trade my requests with processor procup and procdown
946           processor_id_type procup = (this->processor_id() + p) %
947             this->n_processors();
948           processor_id_type procdown = (this->n_processors() +
949                                         this->processor_id() - p) %
950             this->n_processors();
951           std::vector<dof_id_type> request_to_fill;
952           this->comm()\&.send_receive(procup, requested_ids[procup],
953                                     procdown, request_to_fill);
954 
955 #ifdef LIBMESH_ENABLE_UNIQUE_ID
956           std::vector<unique_id_type> unique_request_to_fill;
957           this->comm()\&.send_receive(procup, requested_unique_ids[procup],
958                                     procdown, unique_request_to_fill);
959           std::vector<unique_id_type> new_unique_ids(unique_request_to_fill\&.size());
960 #endif
961 
962           // Fill those requests
963           std::vector<dof_id_type> new_ids(request_to_fill\&.size());
964           for (std::size_t i=0; i != request_to_fill\&.size(); ++i)
965             {
966               T *obj = objects[request_to_fill[i]];
967               libmesh_assert(obj);
968               libmesh_assert_equal_to (obj->processor_id(), this->processor_id());
969               new_ids[i] = obj->id();
970 #ifdef LIBMESH_ENABLE_UNIQUE_ID
971               new_unique_ids[i] = obj->valid_unique_id() ? obj->unique_id() : DofObject::invalid_unique_id;
972 #endif
973 
974               libmesh_assert_greater_equal (new_ids[i],
975                                             first_object_on_proc[this->processor_id()]);
976               libmesh_assert_less (new_ids[i],
977                                    first_object_on_proc[this->processor_id()] +
978                                    objects_on_proc[this->processor_id()]);
979             }
980 
981           // Trade back the results
982           std::vector<dof_id_type> filled_request;
983           this->comm()\&.send_receive(procdown, new_ids,
984                                     procup, filled_request);
985 
986 #ifdef LIBMESH_ENABLE_UNIQUE_ID
987           std::vector<unique_id_type> unique_filled_request;
988           this->comm()\&.send_receive(procdown, new_unique_ids,
989                                     procup, unique_filled_request);
990 #endif
991 
992           // And copy the id changes we've now been informed of
993           for (std::size_t i=0; i != filled_request\&.size(); ++i)
994             {
995               T *obj = objects[requested_ids[procup][i]];
996               libmesh_assert (obj);
997               libmesh_assert_equal_to (obj->processor_id(), procup);
998               libmesh_assert_greater_equal (filled_request[i],
999                                             first_object_on_proc[procup]);
1000               libmesh_assert_less (filled_request[i],
1001                                    first_object_on_proc[procup] +
1002                                    objects_on_proc[procup]);
1003               obj->set_id(filled_request[i]);
1004 
1005 #ifdef LIBMESH_ENABLE_UNIQUE_ID
1006               if (!obj->valid_unique_id() && unique_filled_request[i] != DofObject::invalid_unique_id)
1007                 obj->set_unique_id() = unique_filled_request[i];
1008 #endif
1009             }
1010         }
1011     }
1012 
1013   // Next set unpartitioned object ids
1014   next_id = 0;
1015   for (processor_id_type i=0; i != this->n_processors(); ++i)
1016     next_id += objects_on_proc[i];
1017   for (it = objects\&.begin(); it != end; ++it)
1018     {
1019       T *obj = *it;
1020       if (obj->processor_id() == DofObject::invalid_processor_id)
1021         obj->set_id(next_id++);
1022     }
1023 
1024   // Finally shuffle around objects so that container indices
1025   // match ids
1026   end = objects\&.end();
1027   for (it = objects\&.begin(); it != end;)
1028     {
1029       T *obj = *it;
1030       if (obj) // don't try shuffling already-NULL entries
1031         {
1032           T *next = objects[obj->id()];
1033           // If we have to move this object
1034           if (next != obj)
1035             {
1036               // NULL out its original position for now
1037               // (our shuffling may put another object there shortly)
1038               *it = NULL;
1039 
1040               // There may already be another object with this id that
1041               // needs to be moved itself
1042               while (next)
1043                 {
1044                   // We shouldn't be trying to give two objects the
1045                   // same id
1046                   libmesh_assert_not_equal_to (next->id(), obj->id());
1047                   objects[obj->id()] = obj;
1048                   obj = next;
1049                   next = objects[obj->id()];
1050                 }
1051               objects[obj->id()] = obj;
1052             }
1053         }
1054       // Remove any container entries that were left as NULL,
1055       // being careful not to invalidate our iterator
1056       if (!*it)
1057         objects\&.erase(it++);
1058       else
1059         ++it;
1060     }
1061 
1062   return first_free_id;
1063 }
.fi
.SS "void libMesh::ParallelMesh::renumber_elem (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [virtual]\fP, \fC [inherited]\fP"
Changes the id of element \fCold_id\fP, both by changing elem(old_id)->id() and by moving elem(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 484 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::DofObject::id(), libMesh::libmesh_assert(), and libMesh::DofObject::set_id()\&.
.PP
.nf
486 {
487   Elem *el = _elements[old_id];
488   libmesh_assert (el);
489   libmesh_assert_equal_to (el->id(), old_id);
490 
491   el->set_id(new_id);
492   libmesh_assert (!_elements[new_id]);
493   _elements[new_id] = el;
494   _elements\&.erase(old_id);
495 }
.fi
.SS "void libMesh::ParallelMesh::renumber_node (\fBdof_id_type\fPold_id, \fBdof_id_type\fPnew_id)\fC [virtual]\fP, \fC [inherited]\fP"
Changes the id of node \fCold_id\fP, both by changing node(old_id)->id() and by moving node(old_id) in the mesh's internal container\&. No element with the id \fCnew_id\fP should already exist\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 645 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_nodes, libMesh::DofObject::id(), libMesh::libmesh_assert(), and libMesh::DofObject::set_id()\&.
.PP
.nf
647 {
648   Node *nd = _nodes[old_id];
649   libmesh_assert (nd);
650   libmesh_assert_equal_to (nd->id(), old_id);
651 
652   nd->set_id(new_id);
653   libmesh_assert (!_nodes[new_id]);
654   _nodes[new_id] = nd;
655   _nodes\&.erase(old_id);
656 }
.fi
.SS "void libMesh::ParallelMesh::renumber_nodes_and_elements ()\fC [virtual]\fP, \fC [inherited]\fP"
Remove NULL elements from arrays 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 1066 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_elements, libMesh::ParallelMesh::_n_elem, libMesh::ParallelMesh::_n_nodes, libMesh::ParallelMesh::_nodes, libMesh::MeshBase::_skip_renumber_nodes_and_elements, libMesh::MeshBase::boundary_info, libMesh::ParallelMesh::elements_begin(), libMesh::ParallelMesh::elements_end(), end, libMesh::DofObject::id(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids(), libMesh::ParallelMesh::max_elem_id(), libMesh::ParallelMesh::max_node_id(), libMesh::ParallelMesh::n_elem(), libMesh::ParallelMesh::n_nodes(), libMesh::Elem::n_nodes(), libMesh::Elem::node(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::START_LOG(), libMesh::STOP_LOG(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
1067 {
1068   parallel_object_only();
1069 
1070   if (_skip_renumber_nodes_and_elements)
1071     {
1072       this->update_parallel_id_counts();
1073       return;
1074     }
1075 
1076   START_LOG("renumber_nodes_and_elements()", "ParallelMesh");
1077 
1078 #ifdef DEBUG
1079   // Make sure our ids and flags are consistent
1080   this->libmesh_assert_valid_parallel_ids();
1081   this->libmesh_assert_valid_parallel_flags();
1082 #endif
1083 
1084   std::set<dof_id_type> used_nodes;
1085 
1086   // flag the nodes we need
1087   {
1088     element_iterator  it = elements_begin();
1089     element_iterator end = elements_end();
1090 
1091     for (; it != end; ++it)
1092       {
1093         Elem *el = *it;
1094 
1095         for (unsigned int n=0; n != el->n_nodes(); ++n)
1096           used_nodes\&.insert(el->node(n));
1097       }
1098   }
1099 
1100   // Nodes not connected to any local elements, and NULL node entries
1101   // in our container, are deleted
1102   {
1103     node_iterator_imp  it = _nodes\&.begin();
1104     node_iterator_imp end = _nodes\&.end();
1105 
1106     for (; it != end;)
1107       {
1108         Node *nd = *it;
1109         if (!nd)
1110           _nodes\&.erase(it++);
1111         else if (!used_nodes\&.count(nd->id()))
1112           {
1113             // remove any boundary information associated with
1114             // this node
1115             this->boundary_info->remove (nd);
1116 
1117             // delete the node
1118             delete nd;
1119 
1120             _nodes\&.erase(it++);
1121           }
1122         else
1123           ++it;
1124       }
1125   }
1126 
1127   // Finally renumber all the elements
1128   _n_elem = this->renumber_dof_objects (this->_elements);
1129 
1130   // and all the remaining nodes
1131   _n_nodes = this->renumber_dof_objects (this->_nodes);
1132 
1133   // And figure out what IDs we should use when adding new nodes and
1134   // new elements
1135   this->update_parallel_id_counts();
1136 
1137   // Make sure our caches are up to date and our
1138   // DofObjects are well packed
1139 #ifdef DEBUG
1140   libmesh_assert_equal_to (this->n_nodes(), this->parallel_n_nodes());
1141   libmesh_assert_equal_to (this->n_elem(), this->parallel_n_elem());
1142   const dof_id_type pmax_node_id = this->parallel_max_node_id();
1143   const dof_id_type pmax_elem_id = this->parallel_max_elem_id();
1144   libmesh_assert_equal_to (this->max_node_id(), pmax_node_id);
1145   libmesh_assert_equal_to (this->max_elem_id(), pmax_elem_id);
1146   libmesh_assert_equal_to (this->n_nodes(), this->max_node_id());
1147   libmesh_assert_equal_to (this->n_elem(), this->max_elem_id());
1148 
1149   // Make sure our ids and flags are consistent
1150   this->libmesh_assert_valid_parallel_ids();
1151   this->libmesh_assert_valid_parallel_flags();
1152 
1153   // And make sure we've made our numbering monotonic
1154   MeshTools::libmesh_assert_valid_elem_ids(*this);
1155 #endif
1156 
1157   STOP_LOG("renumber_nodes_and_elements()", "ParallelMesh");
1158 }
.fi
.SS "virtual void libMesh::ParallelMesh::reserve_elem (const \fBdof_id_type\fPne)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Reserves space for a known number of elements\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of elements you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 188 of file parallel_mesh\&.h\&.
.PP
.nf
188 { }
.fi
.SS "virtual void libMesh::ParallelMesh::reserve_nodes (const \fBdof_id_type\fPnn)\fC [inline]\fP, \fC [virtual]\fP, \fC [inherited]\fP"
Reserves space for a known number of nodes\&. Note that this method may or may not do anything, depending on the actual \fC\fBMesh\fP\fP implementation\&. If you know the number of nodes you will add and call this method before repeatedly calling \fC\fBadd_point()\fP\fP the implementation will be more efficient\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 184 of file parallel_mesh\&.h\&.
.PP
.nf
184 { }
.fi
.SS "void libMesh::MeshBase::set_mesh_dimension (unsigned intd)\fC [inline]\fP, \fC [inherited]\fP"
Resets the logical dimension of the mesh\&. 
.PP
Definition at line 161 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_dim\&.
.PP
Referenced by libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::TriangleWrapper::copy_tri_to_mesh(), libMesh::MeshBase::prepare_for_use(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::GMVIO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::AbaqusIO::read_elements(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::BoundaryInfo::sync(), and libMesh::TriangleInterface::triangulate()\&.
.PP
.nf
162   { _dim = d; }
.fi
.SS "unsigned int& libMesh::MeshBase::set_n_partitions ()\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Returns a writeable reference to the number of partitions\&. 
.PP
Definition at line 859 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_n_parts\&.
.PP
Referenced by libMesh::Partitioner::partition(), libMesh::Partitioner::repartition(), and libMesh::BoundaryInfo::sync()\&.
.PP
.nf
860   { return _n_parts; }
.fi
.SS "void libMesh::MeshBase::set_next_unique_id (\fBunique_id_type\fPid)\fC [inline]\fP, \fC [inherited]\fP"
Sets the next unique id to be used\&. 
.PP
Definition at line 221 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_next_unique_id\&.
.PP
.nf
221 { _next_unique_id = id; }
.fi
.SS "std::map<\fBsubdomain_id_type\fP, std::string>& libMesh::MeshBase::set_subdomain_name_map ()\fC [inline]\fP, \fC [inherited]\fP"
Return a writeable reference to the whole subdomain name map 
.PP
Definition at line 841 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by libMesh::XdrIO::read_serialized_subdomain_names(), and libMesh::CheckpointIO::read_subdomain_names()\&.
.PP
.nf
842   { return _block_id_to_name; }
.fi
.SS "void libMesh::MeshBase::skip_partitioning (boolskip)\fC [inline]\fP, \fC [inherited]\fP"
If true is passed in then this mesh will no longer be (re)partitioned\&. It would probably be a bad idea to call this on a Serial \fBMesh\fP \fIbefore\fP the first partitioning has happened\&.\&.\&. because no elements would get assigned to your processor pool\&.
.PP
Note that turning on \fBskip_partitioning()\fP can have adverse effects on your performance when using AMR\&.\&.\&. ie you could get large load imbalances\&.
.PP
However you might still want to use this if the communication and computation of the rebalance and repartition is too high for your application\&. 
.PP
Definition at line 551 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements()\&.
.PP
.nf
551 { _skip_partitioning = skip; }
.fi
.SS "bool libMesh::MeshBase::skip_partitioning () const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Definition at line 552 of file mesh_base\&.h\&.
.PP
References libMesh::MeshBase::_skip_partitioning\&.
.PP
Referenced by libMesh::MeshBase::partition()\&.
.PP
.nf
552 { return _skip_partitioning; }
.fi
.SS "unsigned int libMesh::MeshBase::spatial_dimension () const\fC [inline]\fP, \fC [inherited]\fP"
Returns the spatial dimension of the mesh\&. Note that this is defined at compile time in the header \fC\fBlibmesh_common\&.h\fP\fP\&. 
.PP
Definition at line 168 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::ExactSolution::_compute_error(), libMesh::MeshBase::get_info(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::UNVIO::node_out(), libMesh::MeshTools::Modification::scale(), libMesh::MeshTools::subdomain_bounding_box(), and libMesh::Nemesis_IO_Helper::write_exodus_initialization_info()\&.
.PP
.nf
169   { return static_cast<unsigned int>(LIBMESH_DIM); }
.fi
.SS "\fBAutoPtr\fP< \fBPointLocatorBase\fP > libMesh::MeshBase::sub_point_locator () const\fC [inherited]\fP"
\fCreturns\fP a pointer to a subordinate \fC\fBPointLocatorBase\fP\fP object for this mesh, constructing a master PointLocator first if necessary\&. This should not be used in threaded or non-parallel_only code unless the master has already been constructed\&. 
.PP
Definition at line 400 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_point_locator, libMesh::PointLocatorBase::build(), libMesh::Threads::in_threads, libMesh::libmesh_assert(), and libMesh::TREE\&.
.PP
Referenced by libMesh::DofMap::create_dof_constraints(), libMesh::MeshFunction::init(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshRefinement::make_refinement_compatible(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), and libMesh::MeshRefinement::test_level_one()\&.
.PP
.nf
401 {
402   if (_point_locator\&.get() == NULL)
403     {
404       // PointLocator construction may not be safe within threads
405       libmesh_assert(!Threads::in_threads);
406 
407       _point_locator\&.reset (PointLocatorBase::build(TREE, *this)\&.release());
408     }
409 
410   return PointLocatorBase::build(TREE, *this, _point_locator\&.get());
411 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::subactive_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 87 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
88 {
89   Predicates::SubActive<elem_iterator_imp> p;
90   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
91 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::subactive_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 311 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
312 {
313   Predicates::SubActive<const_elem_iterator_imp> p;
314   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
315 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::subactive_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 534 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
535 {
536   Predicates::SubActive<elem_iterator_imp> p;
537   return element_iterator(_elements\&.end(), _elements\&.end(), p);
538 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::subactive_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 759 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
760 {
761   Predicates::SubActive<const_elem_iterator_imp> p;
762   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
763 }
.fi
.SS "void libMesh::MeshBase::subdomain_ids (std::set< \fBsubdomain_id_type\fP > &ids) const\fC [inherited]\fP"
Constructs a list of all subdomain identifiers in the global mesh\&. Subdomains correspond to separate subsets of the mesh which could correspond e\&.g\&. to different materials in a solid mechanics application, or regions where different physical processes are important\&. The subdomain mapping is independent from the parallel decomposition\&. 
.PP
Definition at line 207 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::active_elements_begin(), libMesh::MeshBase::active_elements_end(), libMesh::ParallelObject::comm(), end, and libMesh::Parallel::Communicator::set_union()\&.
.PP
Referenced by libMesh::MeshBase::n_subdomains(), and libMesh::TecplotIO::TecplotIO()\&.
.PP
.nf
208 {
209   // This requires an inspection on every processor
210   parallel_object_only();
211 
212   ids\&.clear();
213 
214   const_element_iterator       el  = this->active_elements_begin();
215   const const_element_iterator end = this->active_elements_end();
216 
217   for (; el!=end; ++el)
218     ids\&.insert((*el)->subdomain_id());
219 
220   // Some subdomains may only live on other processors
221   this->comm()\&.set_union(ids);
222 }
.fi
.SS "std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid)\fC [inherited]\fP"
Returns a writable reference for getting/setting an optional name for a subdomain\&. 
.PP
Definition at line 422 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
Referenced by DMLibMeshSetSystem(), libMesh::ExodusII_IO::read(), libMesh::TecplotIO::write_binary(), and libMesh::ExodusII_IO_Helper::write_elements()\&.
.PP
.nf
423 {
424   return _block_id_to_name[id];
425 }
.fi
.SS "const std::string & libMesh::MeshBase::subdomain_name (\fBsubdomain_id_type\fPid) const\fC [inherited]\fP"

.PP
Definition at line 427 of file mesh_base\&.C\&.
.PP
References libMesh::MeshBase::_block_id_to_name\&.
.PP
.nf
428 {
429   // An empty string to return when no matching subdomain name is found
430   static const std::string empty;
431 
432   std::map<subdomain_id_type, std::string>::const_iterator iter = _block_id_to_name\&.find(id);
433   if (iter == _block_id_to_name\&.end())
434     return empty;
435   else
436     return iter->second;
437 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::type_elements_begin (const \fBElemType\fPtype)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 197 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
198 {
199   Predicates::Type<elem_iterator_imp> p(type);
200   return element_iterator(_elements\&.begin(), _elements\&.end(), p);
201 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::type_elements_begin (const \fBElemType\fPtype) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 421 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
422 {
423   Predicates::Type<const_elem_iterator_imp> p(type);
424   return const_element_iterator(_elements\&.begin(), _elements\&.end(), p);
425 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::type_elements_end (const \fBElemType\fPtype)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 644 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
645 {
646   Predicates::Type<elem_iterator_imp> p(type);
647   return element_iterator(_elements\&.end(), _elements\&.end(), p);
648 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::type_elements_end (const \fBElemType\fPtype) const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 868 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::ParallelMesh::_elements\&.
.PP
.nf
869 {
870   Predicates::Type<const_elem_iterator_imp> p(type);
871   return const_element_iterator(_elements\&.end(), _elements\&.end(), p);
872 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::unpartitioned_elements_begin ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 227 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::ParallelMesh::pid_elements_begin()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
228 {
229   return this->pid_elements_begin(DofObject::invalid_processor_id);
230 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::unpartitioned_elements_begin () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 451 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::ParallelMesh::pid_elements_begin()\&.
.PP
.nf
452 {
453   return this->pid_elements_begin(DofObject::invalid_processor_id);
454 }
.fi
.SS "\fBParallelMesh::element_iterator\fP libMesh::ParallelMesh::unpartitioned_elements_end ()\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 674 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::ParallelMesh::pid_elements_end()\&.
.PP
Referenced by libMesh::MeshCommunication::delete_remote_elements()\&.
.PP
.nf
675 {
676   return this->pid_elements_end(DofObject::invalid_processor_id);
677 }
.fi
.SS "\fBParallelMesh::const_element_iterator\fP libMesh::ParallelMesh::unpartitioned_elements_end () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 898 of file parallel_mesh_iterators\&.C\&.
.PP
References libMesh::DofObject::invalid_processor_id, and libMesh::ParallelMesh::pid_elements_end()\&.
.PP
.nf
899 {
900   return this->pid_elements_end(DofObject::invalid_processor_id);
901 }
.fi
.SS "void libMesh::ParallelMesh::update_parallel_id_counts ()\fC [virtual]\fP, \fC [inherited]\fP"
Updates parallel caches so that methods like \fBn_elem()\fP accurately reflect changes on other processors 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 133 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::_max_elem_id, libMesh::ParallelMesh::_max_node_id, libMesh::ParallelMesh::_n_elem, libMesh::ParallelMesh::_n_nodes, libMesh::ParallelMesh::_next_free_local_elem_id, libMesh::ParallelMesh::_next_free_local_node_id, libMesh::ParallelMesh::_next_free_unpartitioned_elem_id, libMesh::ParallelMesh::_next_free_unpartitioned_node_id, libMesh::ParallelObject::n_processors(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::parallel_n_elem(), libMesh::ParallelMesh::parallel_n_nodes(), and libMesh::ParallelObject::processor_id()\&.
.PP
Referenced by libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::ParallelMesh(), libMesh::ParallelMesh::redistribute(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_post_partitioning()\&.
.PP
.nf
134 {
135   // This function must be run on all processors at once
136   parallel_object_only();
137 
138   _n_elem  = this->parallel_n_elem();
139   _n_nodes = this->parallel_n_nodes();
140   _max_node_id = this->parallel_max_node_id();
141   _max_elem_id = this->parallel_max_elem_id();
142 
143   if (_next_free_unpartitioned_elem_id < _max_elem_id)
144     _next_free_unpartitioned_elem_id =
145       ((_max_elem_id-1) / (this->n_processors() + 1) + 1) *
146       (this->n_processors() + 1) + this->n_processors();
147   if (_next_free_local_elem_id < _max_elem_id)
148     _next_free_local_elem_id =
149       ((_max_elem_id + this->n_processors() - 1) / (this->n_processors() + 1) + 1) *
150       (this->n_processors() + 1) + this->processor_id();
151 
152   if (_next_free_unpartitioned_node_id < _max_node_id)
153     _next_free_unpartitioned_node_id =
154       ((_max_node_id-1) / (this->n_processors() + 1) + 1) *
155       (this->n_processors() + 1) + this->n_processors();
156   if (_next_free_local_node_id < _max_node_id)
157     _next_free_local_node_id =
158       ((_max_node_id + this->n_processors() - 1) / (this->n_processors() + 1) + 1) *
159       (this->n_processors() + 1) + this->processor_id();
160 }
.fi
.SS "void libMesh::ParallelMesh::update_post_partitioning ()\fC [virtual]\fP, \fC [inherited]\fP"
Recalculate cached data after elements and nodes have been repartitioned\&. 
.PP
Reimplemented from \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 735 of file parallel_mesh\&.C\&.
.PP
References libMesh::ParallelMesh::update_parallel_id_counts()\&.
.PP
.nf
736 {
737   // this->recalculate_n_partitions();
738 
739   // Partitioning changes our numbers of unpartitioned objects
740   this->update_parallel_id_counts();
741 }
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, \fBMeshData\fP *mesh_data = \fCNULL\fP)\fC [virtual]\fP, \fC [inherited]\fP"
Write the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&.
.PP
In order to write the UNV and TetGen file types, you must also pass a separate pointer to the \fBMeshData\fP object you have been using with this mesh, since these write methods expect it\&. 
.PP
Implements \fBlibMesh::MeshBase\fP\&.
.PP
Definition at line 785 of file unstructured_mesh\&.C\&.
.PP
References libMesh::Parallel::Communicator::barrier(), libMesh::Parallel::Communicator::broadcast(), libMesh::ParallelObject::comm(), libMesh::err, libMesh::MeshBase::n_partitions(), libMesh::Quality::name(), libMesh::GMVIO::partitioning(), libMesh::ParallelObject::processor_id(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::FroIO::write(), libMesh::DivaIO::write(), libMesh::TecplotIO::write(), libMesh::MEDITIO::write(), libMesh::GMVIO::write(), libMesh::UCDIO::write(), libMesh::TetGenIO::write(), libMesh::UNVIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::GmshIO::write(), libMesh::XdrIO::write(), libMesh::VTKIO::write(), and libMesh::LegacyXdrIO::write_mgf()\&.
.PP
.nf
787 {
788   // parallel formats are special -- they may choose to write
789   // separate files, let's not try to handle the zipping here\&.
790   if (is_parallel_file_format(name))
791     {
792       // no need to handle bz2 files here -- the Xdr class does that\&.
793       if (name\&.rfind("\&.xda") < name\&.size())
794         XdrIO(*this)\&.write(name);
795 
796       else if (name\&.rfind("\&.xdr") < name\&.size())
797         XdrIO(*this,true)\&.write(name);
798 
799       else if (name\&.rfind("\&.nem") < name\&.size() ||
800                name\&.rfind("\&.n")   < name\&.size())
801         Nemesis_IO(*this)\&.write(name);
802     }
803 
804   // serial file formats
805   else
806     {
807       START_LOG("write()", "Mesh");
808 
809       // Nasty hack for reading/writing zipped files
810       std::string new_name = name;
811       processor_id_type pid_0 = 0;
812       if (this->processor_id() == 0)
813         pid_0 = getpid();
814       this->comm()\&.broadcast(pid_0);
815       std::ostringstream pid_suffix;
816       pid_suffix << '_' << pid_0;
817 
818       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
819         {
820           new_name\&.erase(new_name\&.end() - 4, new_name\&.end());
821           new_name += pid_suffix\&.str();
822         }
823       else if (name\&.size() - name\&.rfind("\&.xz") == 3)
824         {
825           new_name\&.erase(new_name\&.end() - 3, new_name\&.end());
826           new_name += pid_suffix\&.str();
827         }
828 
829       // New scope so that io will close before we try to zip the file
830       {
831         // Write the file based on extension
832         if (new_name\&.rfind("\&.dat") < new_name\&.size())
833           TecplotIO(*this)\&.write (new_name);
834 
835         else if (new_name\&.rfind("\&.plt") < new_name\&.size())
836           TecplotIO(*this,true)\&.write (new_name);
837 
838         else if (new_name\&.rfind("\&.ucd") < new_name\&.size())
839           UCDIO (*this)\&.write (new_name);
840 
841         else if (new_name\&.rfind("\&.gmv") < new_name\&.size())
842           if (this->n_partitions() > 1)
843             GMVIO(*this)\&.write (new_name);
844           else
845             {
846               GMVIO io(*this);
847               io\&.partitioning() = false;
848               io\&.write (new_name);
849             }
850 
851         else if (new_name\&.rfind("\&.ugrid") < new_name\&.size())
852           DivaIO(*this)\&.write(new_name);
853         else if (new_name\&.rfind("\&.exd") < new_name\&.size() ||
854                  new_name\&.rfind("\&.e") < new_name\&.size())
855           ExodusII_IO(*this)\&.write(new_name);
856         else if (new_name\&.rfind("\&.mgf")  < new_name\&.size())
857           LegacyXdrIO(*this,true)\&.write_mgf(new_name);
858 
859         else if (new_name\&.rfind("\&.unv") < new_name\&.size())
860           {
861             if (mesh_data == NULL)
862               {
863                 libMesh::err << "Error! You must pass a "
864                              << "valid MeshData pointer to "
865                              << "write UNV files!" << std::endl;
866                 libmesh_error();
867               }
868             UNVIO(*this, *mesh_data)\&.write (new_name);
869           }
870 
871         else if (new_name\&.rfind("\&.mesh") < new_name\&.size())
872           MEDITIO(*this)\&.write (new_name);
873 
874         else if (new_name\&.rfind("\&.poly") < new_name\&.size())
875           TetGenIO(*this)\&.write (new_name);
876 
877         else if (new_name\&.rfind("\&.msh") < new_name\&.size())
878           GmshIO(*this)\&.write (new_name);
879 
880         else if (new_name\&.rfind("\&.fro") < new_name\&.size())
881           FroIO(*this)\&.write (new_name);
882 
883         else if (new_name\&.rfind("\&.vtu") < new_name\&.size())
884           VTKIO(*this)\&.write (new_name);
885 
886         else
887           {
888             libMesh::err
889               << " ERROR: Unrecognized file extension: " << name
890               << "\n   I understand the following:\n\n"
891               << "     *\&.dat   -- Tecplot ASCII file\n"
892               << "     *\&.e     -- Sandia's ExodusII format\n"
893               << "     *\&.exd   -- Sandia's ExodusII format\n"
894               << "     *\&.fro   -- ACDL's surface triangulation file\n"
895               << "     *\&.gmv   -- LANL's GMV (General Mesh Viewer) format\n"
896               << "     *\&.mesh  -- MEdit mesh format\n"
897               << "     *\&.mgf   -- MGF binary mesh format\n"
898               << "     *\&.msh   -- GMSH ASCII file\n"
899               << "     *\&.n     -- Sandia's Nemesis format\n"
900               << "     *\&.nem   -- Sandia's Nemesis format\n"
901               << "     *\&.plt   -- Tecplot binary file\n"
902               << "     *\&.poly  -- TetGen ASCII file\n"
903               << "     *\&.ucd   -- AVS's ASCII UCD format\n"
904               << "     *\&.ugrid -- Kelly's DIVA ASCII format\n"
905               << "     *\&.unv   -- I-deas Universal format\n"
906               << "     *\&.vtu   -- VTK (paraview-readable) format\n"
907               << "     *\&.xda   -- libMesh ASCII format\n"
908               << "     *\&.xdr   -- libMesh binary format,\n"
909               << std::endl
910               << "\n Exiting without writing output\n";
911           }
912       }
913 
914       // Nasty hack for reading/writing zipped files
915       if (name\&.size() - name\&.rfind("\&.bz2") == 4)
916         {
917           START_LOG("system(bzip2)", "Mesh");
918           if (this->processor_id() == 0)
919             {
920               std::string system_string = "bzip2 -f -c ";
921               system_string += new_name + " > " + name;
922               if (std::system(system_string\&.c_str()))
923                 libmesh_file_error(system_string);
924               std::remove(new_name\&.c_str());
925             }
926           this->comm()\&.barrier();
927           STOP_LOG("system(bzip2)", "Mesh");
928         }
929       if (name\&.size() - name\&.rfind("\&.xz") == 3)
930         {
931           START_LOG("system(xz)", "Mesh");
932           if (this->processor_id() == 0)
933             {
934               std::string system_string = "xz -f -c ";
935               system_string += new_name + " > " + name;
936               if (std::system(system_string\&.c_str()))
937                 libmesh_file_error(system_string);
938               std::remove(new_name\&.c_str());
939             }
940           this->comm()\&.barrier();
941           STOP_LOG("system(xz)", "Mesh");
942         }
943 
944       STOP_LOG("write()", "Mesh");
945     }
946 }
.fi
.SS "void libMesh::UnstructuredMesh::write (const std::string &name, const std::vector< \fBNumber\fP > &values, const std::vector< std::string > &variable_names)\fC [inherited]\fP"
Write to the file specified by \fCname\fP\&. Attempts to figure out the proper method by the file extension\&. Also writes data\&. 
.PP
Definition at line 950 of file unstructured_mesh\&.C\&.
.PP
References libMesh::err, libMesh::MeshBase::n_subdomains(), libMesh::GMVIO::partitioning(), libMesh::START_LOG(), libMesh::STOP_LOG(), libMesh::TecplotIO::write_nodal_data(), libMesh::VTKIO::write_nodal_data(), and libMesh::GMVIO::write_nodal_data()\&.
.PP
.nf
953 {
954   START_LOG("write()", "Mesh");
955 
956   // Write the file based on extension
957   if (name\&.rfind("\&.dat") < name\&.size())
958     TecplotIO(*this)\&.write_nodal_data (name, v, vn);
959 
960   else if (name\&.rfind("\&.plt") < name\&.size())
961     TecplotIO(*this,true)\&.write_nodal_data (name, v, vn);
962 
963   else if (name\&.rfind("\&.gmv") < name\&.size())
964     {
965       if (n_subdomains() > 1)
966         GMVIO(*this)\&.write_nodal_data (name, v, vn);
967       else
968         {
969           GMVIO io(*this);
970           io\&.partitioning() = false;
971           io\&.write_nodal_data (name, v, vn);
972         }
973     }
974   else if (name\&.rfind("\&.pvtu") < name\&.size())
975     {
976       VTKIO(*this)\&.write_nodal_data (name, v, vn);
977     }
978   else
979     {
980       libMesh::err
981         << " ERROR: Unrecognized file extension: " << name
982         << "\n   I understand the following:\n\n"
983         << "     *\&.dat  -- Tecplot ASCII file\n"
984         << "     *\&.gmv  -- LANL's GMV (General Mesh Viewer) format\n"
985         << "     *\&.plt  -- Tecplot binary file\n"
986         << "     *\&.pvtu -- Paraview VTK file\n"
987         << "\n Exiting without writing output\n";
988     }
989 
990   STOP_LOG("write()", "Mesh");
991 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "std::map<\fBsubdomain_id_type\fP, std::string> libMesh::MeshBase::_block_id_to_name\fC [protected]\fP, \fC [inherited]\fP"
This structure maintains the mapping of named blocks for file formats that support named blocks\&. Currently this is only implemented for ExodusII 
.PP
Definition at line 924 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::get_id_by_name(), libMesh::MeshBase::get_subdomain_name_map(), libMesh::MeshBase::set_subdomain_name_map(), and libMesh::MeshBase::subdomain_name()\&.
.SS "const \fBParallel::Communicator\fP& libMesh::ParallelObject::_communicator\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 104 of file parallel_object\&.h\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector(), libMesh::ParallelObject::comm(), libMesh::EquationSystems::get_solution(), libMesh::ParallelObject::n_processors(), libMesh::ParallelObject::operator=(), and libMesh::ParallelObject::processor_id()\&.
.SS "unsigned int libMesh::MeshBase::_dim\fC [protected]\fP, \fC [inherited]\fP"
The logical dimension of the mesh\&. 
.PP
Definition at line 876 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshBase::mesh_dimension(), libMesh::MeshBase::MeshBase(), and libMesh::MeshBase::set_mesh_dimension()\&.
.SS "\fBmapvector\fP<\fBElem\fP*,\fBdof_id_type\fP> libMesh::ParallelMesh::_elements\fC [protected]\fP, \fC [inherited]\fP"
The elements in the mesh\&. 
.PP
Definition at line 433 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::active_elements_begin(), libMesh::ParallelMesh::active_elements_end(), libMesh::ParallelMesh::active_local_elements_begin(), libMesh::ParallelMesh::active_local_elements_end(), libMesh::ParallelMesh::active_local_subdomain_elements_begin(), libMesh::ParallelMesh::active_local_subdomain_elements_end(), libMesh::ParallelMesh::active_not_local_elements_begin(), libMesh::ParallelMesh::active_not_local_elements_end(), libMesh::ParallelMesh::active_pid_elements_begin(), libMesh::ParallelMesh::active_pid_elements_end(), libMesh::ParallelMesh::active_subdomain_elements_begin(), libMesh::ParallelMesh::active_subdomain_elements_end(), libMesh::ParallelMesh::active_type_elements_begin(), libMesh::ParallelMesh::active_type_elements_end(), libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::ancestor_elements_begin(), libMesh::ParallelMesh::ancestor_elements_end(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::delete_elem(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::elem(), libMesh::ParallelMesh::elements_begin(), libMesh::ParallelMesh::elements_end(), libMesh::ParallelMesh::fix_broken_node_and_element_numbering(), libMesh::ParallelMesh::insert_elem(), libMesh::ParallelMesh::level_elements_begin(), libMesh::ParallelMesh::level_elements_end(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_flags(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids(), libMesh::ParallelMesh::local_elements_begin(), libMesh::ParallelMesh::local_elements_end(), libMesh::ParallelMesh::local_level_elements_begin(), libMesh::ParallelMesh::local_level_elements_end(), libMesh::ParallelMesh::local_not_level_elements_begin(), libMesh::ParallelMesh::local_not_level_elements_end(), libMesh::ParallelMesh::not_active_elements_begin(), libMesh::ParallelMesh::not_active_elements_end(), libMesh::ParallelMesh::not_ancestor_elements_begin(), libMesh::ParallelMesh::not_ancestor_elements_end(), libMesh::ParallelMesh::not_level_elements_begin(), libMesh::ParallelMesh::not_level_elements_end(), libMesh::ParallelMesh::not_local_elements_begin(), libMesh::ParallelMesh::not_local_elements_end(), libMesh::ParallelMesh::not_subactive_elements_begin(), libMesh::ParallelMesh::not_subactive_elements_end(), libMesh::ParallelMesh::parallel_max_elem_id(), libMesh::ParallelMesh::pid_elements_begin(), libMesh::ParallelMesh::pid_elements_end(), libMesh::ParallelMesh::query_elem(), libMesh::ParallelMesh::renumber_elem(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::subactive_elements_begin(), libMesh::ParallelMesh::subactive_elements_end(), libMesh::ParallelMesh::type_elements_begin(), and libMesh::ParallelMesh::type_elements_end()\&.
.SS "std::set<\fBElem\fP *> libMesh::ParallelMesh::_extra_ghost_elems\fC [protected]\fP, \fC [inherited]\fP"
These are extra ghost elements that we want to make sure not to delete when we call \fBdelete_remote_elements()\fP 
.PP
Definition at line 458 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_extra_ghost_elem(), libMesh::ParallelMesh::clear_extra_ghost_elems(), libMesh::ParallelMesh::delete_remote_elements(), and libMesh::ParallelMesh::ParallelMesh()\&.
.SS "bool libMesh::MeshBase::_is_prepared\fC [protected]\fP, \fC [inherited]\fP"
Flag indicating if the mesh has been prepared for use\&. 
.PP
Definition at line 881 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshBase::is_prepared(), and libMesh::MeshBase::prepare_for_use()\&.
.SS "bool libMesh::ParallelMesh::_is_serial\fC [protected]\fP, \fC [inherited]\fP"
A boolean remembering whether we're serialized or not 
.PP
Definition at line 438 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::allgather(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::delete_remote_elements(), and libMesh::ParallelMesh::is_serial()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_max_elem_id\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 443 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::max_elem_id(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_max_node_id\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 443 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::max_node_id(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_n_elem\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 443 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::n_elem(), libMesh::ParallelMesh::ParallelMesh(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_n_nodes\fC [protected]\fP, \fC [inherited]\fP"
Cached data from the last renumber_nodes_and_elements call 
.PP
Definition at line 443 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::n_nodes(), libMesh::ParallelMesh::ParallelMesh(), libMesh::ParallelMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "unsigned int libMesh::MeshBase::_n_parts\fC [protected]\fP, \fC [inherited]\fP"
The number of partitions the mesh has\&. This is set by the partitioners, and may not be changed directly by the user\&. \fBNOTE\fP The number of partitions \fIneed not\fP equal this->\fBn_processors()\fP, consider for example the case where you simply want to partition a mesh on one processor and view the result in GMV\&. 
.PP
Definition at line 871 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshBase::n_partitions(), libMesh::MeshBase::recalculate_n_partitions(), and libMesh::MeshBase::set_n_partitions()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_next_free_local_elem_id\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 449 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_next_free_local_node_id\fC [protected]\fP, \fC [inherited]\fP"
Guaranteed globally unused IDs for use when adding new nodes or elements\&. 
.PP
Definition at line 449 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_next_free_unpartitioned_elem_id\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 451 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBdof_id_type\fP libMesh::ParallelMesh::_next_free_unpartitioned_node_id\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 451 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::ParallelMesh(), and libMesh::ParallelMesh::update_parallel_id_counts()\&.
.SS "\fBunique_id_type\fP libMesh::MeshBase::_next_unique_id\fC [protected]\fP, \fC [inherited]\fP"
The next available unique id for assigning ids to DOF objects 
.PP
Definition at line 904 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::SerialMesh::assign_unique_ids(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::MeshBase::next_unique_id(), libMesh::ParallelMesh::ParallelMesh(), libMesh::SerialMesh::SerialMesh(), and libMesh::MeshBase::set_next_unique_id()\&.
.SS "\fBmapvector\fP<\fBNode\fP*,\fBdof_id_type\fP> libMesh::ParallelMesh::_nodes\fC [protected]\fP, \fC [inherited]\fP"
The verices (spatial coordinates) of the mesh\&. 
.PP
Definition at line 428 of file parallel_mesh\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::active_nodes_begin(), libMesh::ParallelMesh::active_nodes_end(), libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::add_point(), libMesh::ParallelMesh::assign_unique_ids(), libMesh::ParallelMesh::clear(), libMesh::ParallelMesh::delete_node(), libMesh::ParallelMesh::delete_remote_elements(), libMesh::ParallelMesh::fix_broken_node_and_element_numbering(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_ids(), libMesh::ParallelMesh::local_nodes_begin(), libMesh::ParallelMesh::local_nodes_end(), libMesh::ParallelMesh::node(), libMesh::ParallelMesh::node_ptr(), libMesh::ParallelMesh::nodes_begin(), libMesh::ParallelMesh::nodes_end(), libMesh::ParallelMesh::parallel_max_node_id(), libMesh::ParallelMesh::pid_nodes_begin(), libMesh::ParallelMesh::pid_nodes_end(), libMesh::ParallelMesh::point(), libMesh::ParallelMesh::query_node_ptr(), libMesh::ParallelMesh::renumber_node(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.SS "\fBAutoPtr\fP<\fBPartitioner\fP> libMesh::MeshBase::_partitioner\fC [protected]\fP, \fC [inherited]\fP"
A partitioner to use at each \fBprepare_for_use()\fP\&.
.PP
This will be built in the constructor of each derived class, but can be replaced by the user through the \fBpartitioner()\fP accessor\&. 
.PP
Definition at line 898 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::MeshBase(), libMesh::ParallelMesh::ParallelMesh(), libMesh::MeshBase::partitioner(), and libMesh::SerialMesh::SerialMesh()\&.
.SS "\fBAutoPtr\fP<\fBPointLocatorBase\fP> libMesh::MeshBase::_point_locator\fC [mutable]\fP, \fC [protected]\fP, \fC [inherited]\fP"
A \fCPointLocator\fP class for this mesh\&. This will not actually be built unless needed\&. Further, since we want our \fC\fBpoint_locator()\fP\fP method to be \fCconst\fP (yet do the dynamic allocating) this needs to be mutable\&. Since the \fBPointLocatorBase::build()\fP member is used, and it operates on a constant reference to the mesh, this is OK\&. 
.PP
Definition at line 890 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::clear_point_locator(), libMesh::MeshBase::point_locator(), and libMesh::MeshBase::sub_point_locator()\&.
.SS "bool libMesh::MeshBase::_skip_partitioning\fC [protected]\fP, \fC [inherited]\fP"
If this is true then no partitioning should be done\&. 
.PP
Definition at line 910 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::skip_partitioning()\&.
.SS "bool libMesh::MeshBase::_skip_renumber_nodes_and_elements\fC [protected]\fP, \fC [inherited]\fP"
If this is true then renumbering will be kept to a miniumum\&.
.PP
This is set when \fBprepare_for_use()\fP is called\&. 
.PP
Definition at line 917 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshBase::allow_renumbering(), libMesh::MeshBase::prepare_for_use(), libMesh::SerialMesh::renumber_nodes_and_elements(), and libMesh::ParallelMesh::renumber_nodes_and_elements()\&.
.SS "\fBAutoPtr\fP<\fBBoundaryInfo\fP> libMesh::MeshBase::boundary_info\fC [inherited]\fP"
This class holds the boundary information\&. It can store nodes, edges, and faces with a corresponding id that facilitates setting boundary conditions\&. 
.PP
Definition at line 110 of file mesh_base\&.h\&.
.PP
Referenced by libMesh::MeshRefinement::_coarsen_elements(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::AbaqusIO::assign_boundary_node_ids(), libMesh::AbaqusIO::assign_sideset_ids(), libMesh::MeshTools::Generation::build_cube(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::MeshTools::Modification::change_boundary_id(), libMesh::MeshBase::clear(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEAbstract::compute_periodic_node_constraints(), libMesh::UnstructuredMesh::create_submesh(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshTools::Modification::flatten(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::BoundaryProjectSolution::operator()(), libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), libMesh::ParallelMesh::ParallelMesh(), libMesh::AbaqusIO::read(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::CheckpointIO::read_bcs(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::CheckpointIO::read_nodesets(), libMesh::SerialMesh::renumber_nodes_and_elements(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::SerialMesh::SerialMesh(), libMesh::SerialMesh::stitching_helper(), libMesh::Elem::topological_neighbor(), libMesh::Parallel::unpack(), libMesh::FroIO::write(), libMesh::Nemesis_IO::write(), libMesh::ExodusII_IO::write(), libMesh::XdrIO::write(), libMesh::LegacyXdrIO::write_mesh(), libMesh::Nemesis_IO::write_nodal_data(), libMesh::ExodusII_IO::write_nodal_data_common(), libMesh::ExodusII_IO_Helper::write_nodesets(), libMesh::Nemesis_IO_Helper::write_nodesets(), libMesh::ExodusII_IO_Helper::write_sidesets(), libMesh::Nemesis_IO_Helper::write_sidesets(), libMesh::LegacyXdrIO::write_soln(), and libMesh::DivaIO::write_stream()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
