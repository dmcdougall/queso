.TH "libMesh::TypeNTensor< N, T >" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::TypeNTensor< N, T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tensor_tools\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTypeNTensor\fP ()"
.br
.ti -1c
.RI "\fBTypeNTensor\fP (const T &)"
.br
.ti -1c
.RI "\fBTypeNTensor\fP (const \fBTypeVector\fP< T > &)"
.br
.ti -1c
.RI "\fBTypeNTensor\fP (const \fBTypeTensor\fP< T > &)"
.br
.ti -1c
.RI "\fBoperator TypeVector< T >\fP () const "
.br
.ti -1c
.RI "\fBoperator VectorValue< T >\fP () const "
.br
.ti -1c
.RI "\fBoperator TypeTensor< T >\fP () const "
.br
.ti -1c
.RI "\fBoperator TensorValue< T >\fP () const "
.br
.ti -1c
.RI "\fB~TypeNTensor\fP ()"
.br
.ti -1c
.RI "const \fBTypeNTensor\fP< N-1, T > \fBslice\fP (const unsigned int) const "
.br
.ti -1c
.RI "\fBTypeNTensor\fP< N-1, T > \fBslice\fP (const unsigned int)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeNTensor\fP< N, typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator+\fP (const \fBTypeNTensor\fP< N, T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeNTensor\fP< N, T > & \fBoperator+=\fP (const \fBTypeNTensor\fP< N, T2 > &)"
.br
.ti -1c
.RI "template<typename T2 > \fBTypeNTensor\fP< N, typename 
.br
\fBCompareTypes\fP< T, T2 >
.br
::supertype > \fBoperator-\fP (const \fBTypeNTensor\fP< N, T2 > &) const "
.br
.ti -1c
.RI "template<typename T2 > const \fBTypeNTensor\fP< N, T > & \fBoperator-=\fP (const \fBTypeNTensor\fP< N, T2 > &)"
.br
.ti -1c
.RI "\fBTypeNTensor\fP< N, T > \fBoperator-\fP () const "
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeNTensor\fP< N, 
.br
typename \fBCompareTypes\fP< T, 
.br
Scalar >::supertype > >::type \fBoperator*\fP (const Scalar) const "
.br
.ti -1c
.RI "template<typename Scalar > const \fBTypeNTensor\fP< N, T > & \fBoperator*=\fP (const Scalar)"
.br
.ti -1c
.RI "template<typename Scalar > \fBboostcopy::enable_if_c\fP
.br
< \fBScalarTraits\fP< Scalar >
.br
::value, \fBTypeNTensor\fP< N, 
.br
typename \fBCompareTypes\fP< T, 
.br
Scalar >::supertype > >::type \fBoperator/\fP (const Scalar) const "
.br
.ti -1c
.RI "const \fBTypeNTensor\fP< N, T > & \fBoperator/=\fP (const T)"
.br
.ti -1c
.RI "template<typename T2 > \fBCompareTypes\fP< T, T2 >::supertype \fBcontract\fP (const \fBTypeNTensor\fP< N, T2 > &) const "
.br
.ti -1c
.RI "\fBReal\fP \fBsize_sq\fP () const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTypeNTensor\fP< N, T > &) const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBTypeNTensor\fP< N, T > &) const "
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBTypeNTensor\fP< N, T > &) const "
.br
.ti -1c
.RI "void \fBprint\fP (std::ostream &) const "
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBTypeNTensor\fP< N, T > &t)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int N, typename T>class libMesh::TypeNTensor< N, T >"
This class will eventually define a rank-N tensor in \fCLIBMESH_DIM\fP dimensional space of type T\&. Right now it defines a shim to allow for rank-independent code to compile (but not give correct results) in the case of vector-valued elements and second derivatives\&.
.PP
\fBAuthor:\fP
.RS 4
Roy Stogner, 2012\&. 
.RE
.PP

.PP
Definition at line 34 of file tensor_tools\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::\fBTypeNTensor\fP ()\fC [inline]\fP"

.PP
Definition at line 49 of file type_n_tensor\&.h\&.
.PP
.nf
49 {}
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::\fBTypeNTensor\fP (const T &)\fC [inline]\fP"

.PP
Definition at line 51 of file type_n_tensor\&.h\&.
.PP
.nf
51 {}
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::\fBTypeNTensor\fP (const \fBTypeVector\fP< T > &)\fC [inline]\fP"

.PP
Definition at line 53 of file type_n_tensor\&.h\&.
.PP
.nf
53 {}
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::\fBTypeNTensor\fP (const \fBTypeTensor\fP< T > &)\fC [inline]\fP"

.PP
Definition at line 55 of file type_n_tensor\&.h\&.
.PP
.nf
55 {}
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::~\fBTypeNTensor\fP ()\fC [inline]\fP"
Destructor\&. 
.PP
Definition at line 66 of file type_n_tensor\&.h\&.
.PP
.nf
66 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<unsigned int N, typename T> template<typename T2 > \fBCompareTypes\fP<T,T2>::supertype \fBlibMesh::TypeNTensor\fP< N, T >::contract (const \fBTypeNTensor\fP< N, T2 > &) const\fC [inline]\fP"
Multiply 2 tensors together, i\&.e\&. dyadic product sum_ij Aij*Bij\&. The tensors may be of different types\&. 
.PP
Definition at line 153 of file type_n_tensor\&.h\&.
.PP
Referenced by libMesh::TensorTools::inner_product()\&.
.PP
.nf
153 { return 0; }
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::operator \fBTensorValue\fP< T > () const\fC [inline]\fP"

.PP
Definition at line 61 of file type_n_tensor\&.h\&.
.PP
.nf
61 { libmesh_error(); return 0; }
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::operator \fBTypeTensor\fP< T > () const\fC [inline]\fP"

.PP
Definition at line 60 of file type_n_tensor\&.h\&.
.PP
.nf
60 { libmesh_error(); return 0; }
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::operator \fBTypeVector\fP< T > () const\fC [inline]\fP"

.PP
Definition at line 57 of file type_n_tensor\&.h\&.
.PP
.nf
57 { libmesh_error(); return 0; }
.fi
.SS "template<unsigned int N, typename T> \fBlibMesh::TypeNTensor\fP< N, T >::operator \fBVectorValue\fP< T > () const\fC [inline]\fP"

.PP
Definition at line 58 of file type_n_tensor\&.h\&.
.PP
.nf
58 { libmesh_error(); return 0; }
.fi
.SS "template<unsigned int N, typename T> template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeNTensor\fP<N,typename \fBCompareTypes\fP<T, Scalar>::supertype> >::type \fBlibMesh::TypeNTensor\fP< N, T >::operator* (const Scalar) const\fC [inline]\fP"
Multiply a tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 123 of file type_n_tensor\&.h\&.
.PP
.nf
124   { return TypeNTensor<N,typename CompareTypes<T, Scalar>::supertype>(); }
.fi
.SS "template<unsigned int N, typename T> template<typename Scalar > const \fBTypeNTensor\fP<N,T>& \fBlibMesh::TypeNTensor\fP< N, T >::operator*= (const Scalar)\fC [inline]\fP"
Multiply this tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 130 of file type_n_tensor\&.h\&.
.PP
.nf
130 { return *this; }
.fi
.SS "template<unsigned int N, typename T> template<typename T2 > \fBTypeNTensor\fP<N,typename \fBCompareTypes\fP<T, T2>::supertype> \fBlibMesh::TypeNTensor\fP< N, T >::operator+ (const \fBTypeNTensor\fP< N, T2 > &) const\fC [inline]\fP"
Add two tensors\&. 
.PP
Definition at line 85 of file type_n_tensor\&.h\&.
.PP
.nf
86   { return TypeNTensor<N,typename CompareTypes<T,T2>::supertype>(); }
.fi
.SS "template<unsigned int N, typename T> template<typename T2 > const \fBTypeNTensor\fP<N,T>& \fBlibMesh::TypeNTensor\fP< N, T >::operator+= (const \fBTypeNTensor\fP< N, T2 > &)\fC [inline]\fP"
Add to this tensor\&. 
.PP
Definition at line 92 of file type_n_tensor\&.h\&.
.PP
.nf
93   { return *this; }
.fi
.SS "template<unsigned int N, typename T> template<typename T2 > \fBTypeNTensor\fP<N,typename \fBCompareTypes\fP<T, T2>::supertype> \fBlibMesh::TypeNTensor\fP< N, T >::operator- (const \fBTypeNTensor\fP< N, T2 > &) const\fC [inline]\fP"
Subtract two tensors\&. 
.PP
Definition at line 100 of file type_n_tensor\&.h\&.
.PP
.nf
101   { return TypeNTensor<N,typename CompareTypes<T,T2>::supertype>(); }
.fi
.SS "template<unsigned int N, typename T> \fBTypeNTensor\fP<N,T> \fBlibMesh::TypeNTensor\fP< N, T >::operator- () const\fC [inline]\fP"
Return the opposite of a tensor 
.PP
Definition at line 113 of file type_n_tensor\&.h\&.
.PP
.nf
114   { return *this; }
.fi
.SS "template<unsigned int N, typename T> template<typename T2 > const \fBTypeNTensor\fP<N,T>& \fBlibMesh::TypeNTensor\fP< N, T >::operator-= (const \fBTypeNTensor\fP< N, T2 > &)\fC [inline]\fP"
Subtract from this tensor\&. 
.PP
Definition at line 107 of file type_n_tensor\&.h\&.
.PP
.nf
108   { return *this; }
.fi
.SS "template<unsigned int N, typename T> template<typename Scalar > \fBboostcopy::enable_if_c\fP< \fBScalarTraits\fP<Scalar>::value, \fBTypeNTensor\fP<N,typename \fBCompareTypes\fP<T, Scalar>::supertype> >::type \fBlibMesh::TypeNTensor\fP< N, T >::operator/ (const Scalar) const\fC [inline]\fP"
Divide a tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 139 of file type_n_tensor\&.h\&.
.PP
.nf
139 { return *this; }
.fi
.SS "template<unsigned int N, typename T> const \fBTypeNTensor\fP<N,T>& \fBlibMesh::TypeNTensor\fP< N, T >::operator/= (const T)\fC [inline]\fP"
Divide this tensor by a number, i\&.e\&. scale\&. 
.PP
Definition at line 144 of file type_n_tensor\&.h\&.
.PP
.nf
144 { return *this; }
.fi
.SS "template<unsigned int N, typename T> bool \fBlibMesh::TypeNTensor\fP< N, T >::operator< (const \fBTypeNTensor\fP< N, T > &) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this tensor is 'less' than another\&. Useful for sorting\&. 
.RE
.PP

.PP
Definition at line 171 of file type_n_tensor\&.h\&.
.PP
.nf
172   { return false; }
.fi
.SS "template<unsigned int N, typename T> bool \fBlibMesh::TypeNTensor\fP< N, T >::operator== (const \fBTypeNTensor\fP< N, T > &) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if two tensors are equal valued\&. 
.RE
.PP

.PP
Definition at line 164 of file type_n_tensor\&.h\&.
.PP
.nf
165   { return true; }
.fi
.SS "template<unsigned int N, typename T> bool \fBlibMesh::TypeNTensor\fP< N, T >::operator> (const \fBTypeNTensor\fP< N, T > &) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this tensor is 'greater' than another\&. 
.RE
.PP

.PP
Definition at line 178 of file type_n_tensor\&.h\&.
.PP
.nf
179   { return false; }
.fi
.SS "template<unsigned int N, typename T> void \fBlibMesh::TypeNTensor\fP< N, T >::print (std::ostream &) const\fC [inline]\fP"
Formatted print, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 184 of file type_n_tensor\&.h\&.
.PP
.nf
184 {}
.fi
.SS "template<unsigned int N, typename T> \fBReal\fP \fBlibMesh::TypeNTensor\fP< N, T >::size_sq () const\fC [inline]\fP"
Returns the Frobenius norm of the tensor squared, i\&.e\&. sum of the element magnitudes squared\&. 
.PP
Definition at line 159 of file type_n_tensor\&.h\&.
.PP
.nf
159 { return 0\&.;}
.fi
.SS "template<unsigned int N, typename T> const \fBTypeNTensor\fP<N-1,T> \fBlibMesh::TypeNTensor\fP< N, T >::slice (const unsignedint) const\fC [inline]\fP"
Return a proxy for the $ i^{th} $ slice of the tensor\&. 
.PP
Definition at line 71 of file type_n_tensor\&.h\&.
.PP
.nf
72   { return TypeNTensor<N-1,T>(); }
.fi
.SS "template<unsigned int N, typename T> \fBTypeNTensor\fP<N-1,T> \fBlibMesh::TypeNTensor\fP< N, T >::slice (const unsignedint)\fC [inline]\fP"
Return a writeable proxy for the $ i^{th} $ slice of the tensor\&. 
.PP
Definition at line 77 of file type_n_tensor\&.h\&.
.PP
.nf
78   { return TypeNTensor<N-1,T>(); }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<unsigned int N, typename T> std::ostream& operator<< (std::ostream &os, const \fBTypeNTensor\fP< N, T > &t)\fC [friend]\fP"
Formatted print as above but allows you to do std::cout << t << std::endl; 
.PP
Definition at line 190 of file type_n_tensor\&.h\&.
.PP
.nf
192   {
193     t\&.print(os);
194     return os;
195   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
