.TH "libMesh::DofObject" 3 "Tue May 6 2014" "libMesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libMesh::DofObject \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <dof_object\&.h>\fP
.PP
Inherits \fBlibMesh::ReferenceCountedObject< DofObject >\fP\&.
.PP
Inherited by \fBlibMesh::Elem\fP, and \fBlibMesh::Node\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBclear_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBset_old_dof_object\fP ()"
.br
.ti -1c
.RI "void \fBclear_dofs\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_dofs\fP (const unsigned int sys_num=\fBlibMesh::invalid_uint\fP)"
.br
.ti -1c
.RI "void \fBinvalidate_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate_processor_id\fP ()"
.br
.ti -1c
.RI "void \fBinvalidate\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_dofs\fP (const unsigned int s, const unsigned int var=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBid\fP () const "
.br
.ti -1c
.RI "\fBdof_id_type\fP & \fBset_id\fP ()"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fBunique_id\fP () const "
.br
.ti -1c
.RI "\fBunique_id_type\fP & \fBset_unique_id\fP ()"
.br
.ti -1c
.RI "void \fBset_id\fP (const \fBdof_id_type\fP dofid)"
.br
.ti -1c
.RI "bool \fBvalid_id\fP () const "
.br
.ti -1c
.RI "bool \fBvalid_unique_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fBprocessor_id\fP () const "
.br
.ti -1c
.RI "\fBprocessor_id_type\fP & \fBprocessor_id\fP ()"
.br
.ti -1c
.RI "void \fBprocessor_id\fP (const \fBprocessor_id_type\fP pid)"
.br
.ti -1c
.RI "bool \fBvalid_processor_id\fP () const "
.br
.ti -1c
.RI "unsigned int \fBn_systems\fP () const "
.br
.ti -1c
.RI "void \fBset_n_systems\fP (const unsigned int s)"
.br
.ti -1c
.RI "void \fBadd_system\fP ()"
.br
.ti -1c
.RI "unsigned int \fBn_var_groups\fP (const unsigned int s) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBn_vars\fP (const unsigned int s) const "
.br
.ti -1c
.RI "void \fBset_n_vars_per_group\fP (const unsigned int s, const std::vector< unsigned int > &nvpg)"
.br
.ti -1c
.RI "unsigned int \fBn_comp\fP (const unsigned int s, const unsigned int var) const "
.br
.ti -1c
.RI "unsigned int \fBn_comp_group\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "void \fBset_n_comp\fP (const unsigned int s, const unsigned int var, const unsigned int ncomp)"
.br
.ti -1c
.RI "void \fBset_n_comp_group\fP (const unsigned int s, const unsigned int vg, const unsigned int ncomp)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBdof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp) const "
.br
.ti -1c
.RI "void \fBset_dof_number\fP (const unsigned int s, const unsigned int var, const unsigned int comp, const \fBdof_id_type\fP dn)"
.br
.ti -1c
.RI "bool \fBhas_dofs\fP (const unsigned int s=\fBlibMesh::invalid_uint\fP) const "
.br
.ti -1c
.RI "void \fBset_vg_dof_base\fP (const unsigned int s, const unsigned int vg, const \fBdof_id_type\fP db)"
.br
.ti -1c
.RI "\fBdof_id_type\fP \fBvg_dof_base\fP (const unsigned int s, const unsigned int vg) const "
.br
.ti -1c
.RI "unsigned int \fBpacked_indexing_size\fP () const "
.br
.ti -1c
.RI "void \fBunpack_indexing\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.ti -1c
.RI "void \fBpack_indexing\fP (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > > target) const "
.br
.ti -1c
.RI "void \fBdebug_buffer\fP () const "
.br
.ti -1c
.RI "void \fBset_buffer\fP (const std::vector< \fBdof_id_type\fP > &buf)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static unsigned int \fBunpackable_indexing_size\fP (std::vector< \fBlargest_id_type\fP >::const_iterator begin)"
.br
.ti -1c
.RI "static std::string \fBget_info\fP ()"
.br
.ti -1c
.RI "static void \fBprint_info\fP (std::ostream &\fBout\fP=\fBlibMesh::out\fP)"
.br
.ti -1c
.RI "static unsigned int \fBn_objects\fP ()"
.br
.ti -1c
.RI "static void \fBenable_print_counter_info\fP ()"
.br
.ti -1c
.RI "static void \fBdisable_print_counter_info\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBDofObject\fP * \fBold_dof_object\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const \fBdof_id_type\fP \fBinvalid_id\fP = static_cast<\fBdof_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBunique_id_type\fP \fBinvalid_unique_id\fP = static_cast<\fBunique_id_type\fP>(-1)"
.br
.ti -1c
.RI "static const \fBprocessor_id_type\fP \fBinvalid_processor_id\fP = static_cast<\fBprocessor_id_type\fP>(-1)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< std::string, 
.br
std::pair< unsigned int, 
.br
unsigned int > > \fBCounts\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBDofObject\fP ()"
.br
.ti -1c
.RI "\fB~DofObject\fP ()"
.br
.ti -1c
.RI "\fBDofObject\fP (const \fBDofObject\fP &)"
.br
.ti -1c
.RI "\fBDofObject\fP & \fBoperator=\fP (const \fBDofObject\fP &dof_obj)"
.br
.ti -1c
.RI "void \fBincrement_constructor_count\fP (const std::string &name)"
.br
.ti -1c
.RI "void \fBincrement_destructor_count\fP (const std::string &name)"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBCounts\fP \fB_counts\fP"
.br
.ti -1c
.RI "static \fBThreads::atomic\fP
.br
< unsigned int > \fB_n_objects\fP"
.br
.ti -1c
.RI "static \fBThreads::spin_mutex\fP \fB_mutex\fP"
.br
.ti -1c
.RI "static bool \fB_enable_print_counter\fP = true"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef \fBdof_id_type\fP \fBindex_t\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBindex_t\fP > \fBindex_buffer_t\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "unsigned int \fBvar_to_vg\fP (const unsigned int s, const unsigned int var) const "
.br
.ti -1c
.RI "unsigned int \fBsystem_var_to_vg_var\fP (const unsigned int s, const unsigned int vg, const unsigned int var) const "
.br
.ti -1c
.RI "unsigned int \fBstart_idx\fP (const unsigned int s) const "
.br
.ti -1c
.RI "unsigned int \fBend_idx\fP (const unsigned int s) const "
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBdof_id_type\fP \fB_id\fP"
.br
.ti -1c
.RI "\fBunique_id_type\fP \fB_unique_id\fP"
.br
.ti -1c
.RI "\fBprocessor_id_type\fP \fB_processor_id\fP"
.br
.ti -1c
.RI "\fBindex_buffer_t\fP \fB_idx_buf\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const \fBindex_t\fP \fBncv_magic\fP = 256"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fC\fBDofObject\fP\fP defines an abstract base class for objects that have degrees of freedom associated with them\&. Examples of such objects are the \fC\fBNode\fP\fP and \fC\fBElem\fP\fP classes\&. This class can not be instantiated, only derived from\&.
.PP
\fBAuthor:\fP
.RS 4
Benjamin S\&. Kirk 
.RE
.PP
\fBDate:\fP
.RS 4
2003, 2011 
.RE
.PP

.PP
Definition at line 51 of file dof_object\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef std::map<std::string, std::pair<unsigned int, unsigned int> > \fBlibMesh::ReferenceCounter::Counts\fP\fC [protected]\fP, \fC [inherited]\fP"
Data structure to log the information\&. The log is identified by the class name\&. 
.PP
Definition at line 113 of file reference_counter\&.h\&.
.SS "typedef std::vector<\fBindex_t\fP> \fBlibMesh::DofObject::index_buffer_t\fP\fC [private]\fP"

.PP
Definition at line 464 of file dof_object\&.h\&.
.SS "typedef \fBdof_id_type\fP \fBlibMesh::DofObject::index_t\fP\fC [private]\fP"
DoF index information\&. This is packed into a contiguous buffer of the following format:
.PP
[ns end_0 end_1 \&.\&.\&. end_{ns-1} (ncv_0 idx_0 ncv_1 idx_1 \&.\&.\&. ncv_nv idx_nv)_0 (ncv_0 idx_0 ncv_1 idx_1 \&.\&.\&. ncv_nv idx_nv)_1 \&.\&.\&. (ncv_0 idx_0 ncv_1 idx_1 \&.\&.\&. ncv_nv idx_nv)_ns ]
.PP
where 'end_s' is the index past the end of the variable group storage for system \fCs\fP\&. Note that we specifically do not store the end for the last system - this always _idx_buf\&.size()\&.
.PP
Specifically, consider the case of 4 systems, with 3, 0, 1, 2 variable groups, respectively\&. The _idx_buf then looks like: 
.PP
.nf
[4 10 10 12 () (ncv_0 idx_0 ncv_1 idx_1 ncv_2 idx_2) () (ncv_0 idx_0) (ncv_0 idx_0 ncv_1 idx_1)]
[0  1  2  3         4     5     6     7     8     9         10    11      12    13    14    15]
.fi
.PP
 The ending index is then given by 
.PP
.nf
end_s = _idx_buf.size(), s == (ns-1),
= _idx_buf[s+1]    otherwise.

.fi
.PP
 The starting indices are not specifically stored, but rather inferred as follows:
.PP
start_s = _idx_buf[s];
.PP
Now, the defining characteristic of the \fC\fBVariableGroup\fP\fP is that it supports an arbitrary number of variables of the same type\&. At the \fC\fBDofObject\fP\fP level, what that means is that each \fC\fBVariable\fP\fP in the \fC\fBVariableGroup\fP\fP will have the same number of nonzero components, and they can all be indexed from the same base number\&. We use this information in the ncv_# and idx_# entries as follows:
.PP
ncv_# = n_vars*ncv_magic + n_comp for variable group # idx_# = base_offset for variable group #
.PP
the DoF index for a particular component c of variable v within that group is then given by
.PP
idx_var = idx_# + n_comp*v + c
.PP
note there is a subtlety here - 'variable v within that group' usually means nothing to the user\&. This class is either indexed with variable group numbers, or variable numbers counted \fIwithin the system\fP\&. So for a system with 2 variable groups, 4 and 8 variables each, the 5th variable in the system is the 1st variable in 2nd variable group\&. (Now of course 0-base everything\&.\&.\&. but you get the idea\&.) 
.PP
Definition at line 463 of file dof_object\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "libMesh::DofObject::DofObject ()\fC [inline]\fP, \fC [protected]\fP"
Constructor\&. Protected so that you can't instantiate one of these except as a part of a \fBNode\fP or \fBElem\fP\&. 
.PP
Definition at line 501 of file dof_object\&.h\&.
.PP
References invalidate()\&.
.PP
Referenced by operator=(), set_old_dof_object(), and unpack_indexing()\&.
.PP
.nf
501                       :
502 #ifdef LIBMESH_ENABLE_AMR
503   old_dof_object(NULL),
504 #endif
505   _id (invalid_id),
506 #ifdef LIBMESH_ENABLE_UNIQUE_ID
507   _unique_id (invalid_unique_id),
508 #endif
509   _processor_id (invalid_processor_id)
510 {
511   this->invalidate();
512 }
.fi
.SS "libMesh::DofObject::~DofObject ()\fC [inline]\fP, \fC [protected]\fP"
Destructor\&. Protected so that you can't destroy one of these except as a part of a \fBNode\fP or \fBElem\fP\&. 
.PP
Definition at line 519 of file dof_object\&.h\&.
.PP
References clear_dofs(), and clear_old_dof_object()\&.
.PP
.nf
520 {
521   // Free all memory\&.
522 #ifdef LIBMESH_ENABLE_AMR
523   this->clear_old_dof_object ();
524 #endif
525   this->clear_dofs ();
526 }
.fi
.SS "libMesh::DofObject::DofObject (const \fBDofObject\fP &dof_obj)\fC [protected]\fP"
Copy-constructor\&. 
.PP
Definition at line 42 of file dof_object\&.C\&.
.PP
References dof_number(), n_comp(), n_systems(), n_var_groups(), and n_vars()\&.
.PP
.nf
42                                               :
43   ReferenceCountedObject<DofObject>(),
44 #ifdef LIBMESH_ENABLE_AMR
45   old_dof_object (NULL),
46 #endif
47   _id            (dof_obj\&._id),
48 #ifdef LIBMESH_ENABLE_UNIQUE_ID
49   _unique_id     (dof_obj\&._unique_id),
50 #endif
51   _processor_id  (dof_obj\&._processor_id),
52   _idx_buf       (dof_obj\&._idx_buf)
53 {
54 
55   // Check that everything worked
56 #ifdef DEBUG
57 
58   libmesh_assert_equal_to (this->n_systems(), dof_obj\&.n_systems());
59 
60   for (unsigned int s=0; s<this->n_systems(); s++)
61     {
62       libmesh_assert_equal_to (this->n_vars(s),       dof_obj\&.n_vars(s));
63       libmesh_assert_equal_to (this->n_var_groups(s), dof_obj\&.n_var_groups(s));
64 
65       for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
66         libmesh_assert_equal_to (this->n_vars(s,vg), dof_obj\&.n_vars(s,vg));
67 
68       for (unsigned int v=0; v<this->n_vars(s); v++)
69         {
70           libmesh_assert_equal_to (this->n_comp(s,v), dof_obj\&.n_comp(s,v));
71 
72           for (unsigned int c=0; c<this->n_comp(s,v); c++)
73             libmesh_assert_equal_to (this->dof_number(s,v,c), dof_obj\&.dof_number(s,v,c));
74         }
75     }
76 
77 #endif
78 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void libMesh::DofObject::add_system ()"
Adds an additional system to the \fC\fBDofObject\fP\fP 
.PP
Definition at line 187 of file dof_object\&.C\&.
.PP
References _idx_buf, n_systems(), n_var_groups(), n_vars(), and set_n_systems()\&.
.PP
.nf
188 {
189   // quick return?
190   if (this->n_systems() == 0)
191     {
192       this->set_n_systems(1);
193       return;
194     }
195 
196   DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
197 
198   std::advance(it, this->n_systems());
199 
200   // this inserts the current vector size at the position for the new system - creating the
201   // entry we need for the new system indicating there are 0 variables\&.
202   _idx_buf\&.insert(it, _idx_buf\&.size());
203 
204   // cache this value before we screw it up!
205   const unsigned int ns_orig = this->n_systems();
206 
207   // incriment the number of systems and the offsets for each of
208   // the systems including the new one we just added\&.
209   for (unsigned int i=0; i<ns_orig+1; i++)
210     _idx_buf[i]++;
211 
212   libmesh_assert_equal_to (this->n_systems(), (ns_orig+1));
213   libmesh_assert_equal_to (this->n_vars(ns_orig), 0);
214   libmesh_assert_equal_to (this->n_var_groups(ns_orig), 0);
215 }
.fi
.SS "void libMesh::DofObject::clear_dofs ()\fC [inline]\fP"
Clear the \fC\fBDofMap\fP\fP data structures and return to a pristine state\&. 
.PP
Definition at line 577 of file dof_object\&.h\&.
.PP
References _idx_buf, libMesh::libmesh_assert(), and n_systems()\&.
.PP
Referenced by set_n_systems(), and ~DofObject()\&.
.PP
.nf
578 {
579   // vector swap trick to force deallocation
580   index_buffer_t()\&.swap(_idx_buf);
581 
582   libmesh_assert_equal_to (this->n_systems(), 0);
583   libmesh_assert (_idx_buf\&.empty());
584 }
.fi
.SS "void libMesh::DofObject::clear_old_dof_object ()"
Sets the \fCold_dof_object\fP to NULL 
.PP
Definition at line 134 of file dof_object\&.C\&.
.PP
References old_dof_object\&.
.PP
Referenced by operator=(), set_old_dof_object(), unpack_indexing(), and ~DofObject()\&.
.PP
.nf
135 {
136   delete this->old_dof_object;
137   this->old_dof_object = NULL;
138 }
.fi
.SS "void libMesh::DofObject::debug_buffer () const"
Print our buffer for debugging\&. 
.PP
Definition at line 543 of file dof_object\&.C\&.
.PP
References _idx_buf, and libMesh::out\&.
.PP
.nf
544 {
545   libMesh::out << " [ ";
546   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
547     libMesh::out << _idx_buf[i] << " ";
548   libMesh::out << "]\n";
549 }
.fi
.SS "void libMesh::ReferenceCounter::disable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"

.PP
Definition at line 106 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
107 {
108   _enable_print_counter = false;
109   return;
110 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 789 of file dof_object\&.h\&.
.PP
References _idx_buf, invalid_id, n_comp(), n_comp_group(), n_systems(), n_vars(), start_idx(), system_var_to_vg_var(), and var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::ExodusII_IO::copy_elemental_solution(), libMesh::ExodusII_IO::copy_nodal_solution(), libMesh::DofMap::distribute_dofs(), DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), libMesh::DofMap::old_dof_indices(), operator=(), libMesh::HPCoarsenTest::select_refinement(), set_dof_number(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
792 {
793   libmesh_assert_less (s,    this->n_systems());
794   libmesh_assert_less (var,  this->n_vars(s));
795   libmesh_assert_less (comp, this->n_comp(s,var));
796 
797   const unsigned int
798     vg            = this->var_to_vg(s,var),
799     start_idx_sys = this->start_idx(s);
800 
801   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
802 
803   const dof_id_type
804     base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
805 
806   // if the first component is invalid, they
807   // are all invalid
808   if (base_idx == invalid_id)
809     return invalid_id;
810 
811   // otherwise the index is the first component
812   // index augemented by the component number
813   else
814     {
815       const unsigned int
816         ncg = this->n_comp_group(s,vg),
817         vig = this->system_var_to_vg_var(s,vg,var);
818 
819       // std::cout << "base_idx, var, vg, vig, ncg, comp="
820       // << base_idx << " "
821       // << var << " "
822       // << vg << " "
823       // << vig << " "
824       // << ncg << " "
825       // << comp << '\n';
826 
827       return libmesh_cast_int<dof_id_type>(base_idx + vig*ncg + comp);
828     }
829 }
.fi
.SS "void libMesh::ReferenceCounter::enable_print_counter_info ()\fC [static]\fP, \fC [inherited]\fP"
Methods to enable/disable the reference counter output from \fBprint_info()\fP 
.PP
Definition at line 100 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter\&.
.PP
.nf
101 {
102   _enable_print_counter = true;
103   return;
104 }
.fi
.SS "unsigned int libMesh::DofObject::end_idx (const unsigned ints) const\fC [inline]\fP, \fC [private]\fP"
The ending index for system \fCs\fP\&. 
.PP
Definition at line 868 of file dof_object\&.h\&.
.PP
References _idx_buf, and n_systems()\&.
.PP
Referenced by n_var_groups(), and set_n_vars_per_group()\&.
.PP
.nf
869 {
870   libmesh_assert_less (s, this->n_systems());
871   libmesh_assert_less (s, _idx_buf\&.size());
872 
873   return ((s+1) == this->n_systems()) ?
874     libmesh_cast_int<unsigned int>(_idx_buf\&.size()) :
875     libmesh_cast_int<unsigned int>(_idx_buf[s+1]);
876 }
.fi
.SS "std::string libMesh::ReferenceCounter::get_info ()\fC [static]\fP, \fC [inherited]\fP"
Gets a string containing the reference information\&. 
.PP
Definition at line 47 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_counts, and libMesh::Quality::name()\&.
.PP
Referenced by libMesh::ReferenceCounter::print_info()\&.
.PP
.nf
48 {
49 #if defined(LIBMESH_ENABLE_REFERENCE_COUNTING) && defined(DEBUG)
50 
51   std::ostringstream oss;
52 
53   oss << '\n'
54       << " ---------------------------------------------------------------------------- \n"
55       << "| Reference count information                                                |\n"
56       << " ---------------------------------------------------------------------------- \n";
57 
58   for (Counts::iterator it = _counts\&.begin();
59        it != _counts\&.end(); ++it)
60     {
61       const std::string name(it->first);
62       const unsigned int creations    = it->second\&.first;
63       const unsigned int destructions = it->second\&.second;
64 
65       oss << "| " << name << " reference count information:\n"
66           << "|  Creations:    " << creations    << '\n'
67           << "|  Destructions: " << destructions << '\n';
68     }
69 
70   oss << " ---------------------------------------------------------------------------- \n";
71 
72   return oss\&.str();
73 
74 #else
75 
76   return "";
77 
78 #endif
79 }
.fi
.SS "bool libMesh::DofObject::has_dofs (const unsigned ints = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
true if any system has variables which have been assigned, false otherwise 
.RE
.PP

.PP
Definition at line 834 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, n_systems(), and n_vars()\&.
.PP
Referenced by libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::reinit(), and libMesh::Parallel::unpack()\&.
.PP
.nf
835 {
836   if (sys == libMesh::invalid_uint)
837     {
838       for (unsigned int s=0; s<this->n_systems(); s++)
839         if (this->n_vars(s))
840           return true;
841     }
842 
843   else
844     {
845       libmesh_assert_less (sys, this->n_systems());
846 
847       if (this->n_vars(sys))
848         return true;
849     }
850 
851   return false;
852 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 611 of file dof_object\&.h\&.
.PP
References _id, libMesh::libmesh_assert(), and valid_id()\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::UniformRefinementEstimator::_estimate_error(), libMesh::MeshTools::Subdivision::add_boundary_ghosts(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::MeshData::assign(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::MeshTools::Generation::build_delaunay_square(), libMesh::Nemesis_IO_Helper::build_element_and_node_maps(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::ParmetisPartitioner::build_graph(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::VTKIO::cells_to_vtk(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEMap::compute_single_point_map(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshRefinement::create_parent_error_vector(), libMesh::SerialMesh::delete_elem(), libMesh::ParallelMesh::delete_elem(), libMesh::SerialMesh::delete_node(), libMesh::ParallelMesh::delete_node(), libMesh::MeshCommunication::delete_remote_elements(), libMesh::MeshData::elem_to_foreign_id(), libMesh::JumpErrorEstimator::estimate_error(), libMesh::AdjointRefinementEstimator::estimate_error(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::find_nodal_neighbors(), libMesh::MeshRefinement::flag_elements_by_elem_fraction(), libMesh::MeshRefinement::flag_elements_by_error_fraction(), libMesh::MeshRefinement::flag_elements_by_error_tolerance(), libMesh::MeshRefinement::flag_elements_by_mean_stddev(), libMesh::MeshTools::Modification::flatten(), libMesh::for(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::EquationSystems::get_solution(), libMesh::LaplaceMeshSmoother::init(), libMesh::ParmetisPartitioner::initialize(), libMesh::ExodusII_IO_Helper::initialize(), libMesh::TreeNode< N >::insert(), libMesh::SerialMesh::insert_elem(), libMesh::ParallelMesh::insert_elem(), libMesh::SerialMesh::insert_node(), libMesh::FE< Dim, T >::inverse_map(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::MeshTools::libmesh_assert_valid_refinement_flags(), libMesh::Tri3Subdivision::local_node_number(), libMesh::Elem::node(), libMesh::MeshData::node_to_foreign_id(), libMesh::VTKIO::nodes_to_vtk(), libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()(), libMesh::BoundaryInfo::operator=(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::ErrorVector::plot_error(), libMesh::ParallelMesh::query_elem(), libMesh::ParallelMesh::query_node_ptr(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::AbaqusIO::read_elements(), libMesh::ParallelMesh::renumber_elem(), libMesh::ParallelMesh::renumber_node(), libMesh::ParallelMesh::renumber_nodes_and_elements(), libMesh::DofMap::scatter_constraints(), libMesh::HPCoarsenTest::select_refinement(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::FE< Dim, T >::shape(), libMesh::FE< Dim, T >::shape_deriv(), libMesh::FE< Dim, T >::shape_second_deriv(), libMesh::LaplaceMeshSmoother::smooth(), libMesh::MeshTools::Modification::smooth(), libMesh::SerialMesh::stitching_helper(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Elem::topological_neighbor(), libMesh::TetGenMeshInterface::triangulate_conformingDelaunayMesh_carvehole(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::GMVIO::write_ascii_new_impl(), libMesh::GMVIO::write_ascii_old_impl(), libMesh::CheckpointIO::write_connectivity(), libMesh::ExodusII_IO_Helper::write_element_values(), libMesh::ExodusII_IO_Helper::write_elements(), libMesh::GmshIO::write_mesh(), libMesh::LegacyXdrIO::write_mesh(), libMesh::ExodusII_IO_Helper::write_nodal_coordinates(), libMesh::CheckpointIO::write_nodes(), and libMesh::XdrIO::write_serialized_connectivity()\&.
.PP
.nf
612 {
613   libmesh_assert (this->valid_id());
614   return _id;
615 }
.fi
.SS "void libMesh::ReferenceCounter::increment_constructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the construction counter\&. Should be called in the constructor of any derived class that will be reference counted\&. 
.PP
Definition at line 163 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::ReferenceCountedObject()\&.
.PP
.nf
164 {
165   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
166   std::pair<unsigned int, unsigned int>& p = _counts[name];
167 
168   p\&.first++;
169 }
.fi
.SS "void libMesh::ReferenceCounter::increment_destructor_count (const std::string &name)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Increments the destruction counter\&. Should be called in the destructor of any derived class that will be reference counted\&. 
.PP
Definition at line 176 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_counts, libMesh::Quality::name(), and libMesh::Threads::spin_mtx\&.
.PP
Referenced by libMesh::ReferenceCountedObject< RBParametrized >::~ReferenceCountedObject()\&.
.PP
.nf
177 {
178   Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
179   std::pair<unsigned int, unsigned int>& p = _counts[name];
180 
181   p\&.second++;
182 }
.fi
.SS "void libMesh::DofObject::invalidate ()\fC [inline]\fP"
Invalidates all the indices for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 567 of file dof_object\&.h\&.
.PP
References invalidate_dofs(), invalidate_id(), and invalidate_processor_id()\&.
.PP
Referenced by DofObject()\&.
.PP
.nf
568 {
569   this->invalidate_dofs ();
570   this->invalidate_id ();
571   this->invalidate_processor_id ();
572 }
.fi
.SS "void libMesh::DofObject::invalidate_dofs (const unsigned intsys_num = \fC\fBlibMesh::invalid_uint\fP\fP)\fC [inline]\fP"
Sets all degree of freedom numbers to \fCinvalid_id\fP 
.PP
Definition at line 531 of file dof_object\&.h\&.
.PP
References invalid_id, n_comp_group(), n_systems(), n_var_groups(), and set_vg_dof_base()\&.
.PP
Referenced by invalidate()\&.
.PP
.nf
532 {
533   // If the user does not specify the system number\&.\&.\&.
534   if (sys_num >= this->n_systems())
535     {
536       for (unsigned int s=0; s<this->n_systems(); s++)
537         for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
538           if (this->n_comp_group(s,vg))
539             this->set_vg_dof_base(s,vg,invalid_id);
540     }
541   // \&.\&.\&.otherwise invalidate the dofs for all systems
542   else
543     for (unsigned int vg=0; vg<this->n_var_groups(sys_num); vg++)
544       if (this->n_comp_group(sys_num,vg))
545         this->set_vg_dof_base(sys_num,vg,invalid_id);
546 }
.fi
.SS "void libMesh::DofObject::invalidate_id ()\fC [inline]\fP"
Sets the id to \fCinvalid_id\fP 
.PP
Definition at line 551 of file dof_object\&.h\&.
.PP
References invalid_id, and set_id()\&.
.PP
Referenced by invalidate()\&.
.PP
.nf
552 {
553   this->set_id (invalid_id);
554 }
.fi
.SS "void libMesh::DofObject::invalidate_processor_id ()\fC [inline]\fP"
Sets the processor id to \fCinvalid_processor_id\fP 
.PP
Definition at line 559 of file dof_object\&.h\&.
.PP
References invalid_processor_id, and processor_id()\&.
.PP
Referenced by libMesh::MeshTools::correct_node_proc_ids(), invalidate(), libMesh::Partitioner::set_node_processor_ids(), and libMesh::Partitioner::set_parent_processor_ids()\&.
.PP
.nf
560 {
561   this->processor_id (invalid_processor_id);
562 }
.fi
.SS "unsigned int libMesh::DofObject::n_comp (const unsigned ints, const unsigned intvar) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for variable \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 759 of file dof_object\&.h\&.
.PP
References n_comp_group(), n_systems(), n_vars(), and var_to_vg()\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::DofMap::constrain_p_dofs(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), dof_number(), DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::local_variable_indices(), n_dofs(), libMesh::DofMap::old_dof_indices(), operator=(), set_dof_number(), set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), and libMesh::System::zero_variable()\&.
.PP
.nf
761 {
762   libmesh_assert_less (s,   this->n_systems());
763   libmesh_assert_less (var, this->n_vars(s));
764 
765   return this->n_comp_group(s,this->var_to_vg(s,var));
766 }
.fi
.SS "unsigned int libMesh::DofObject::n_comp_group (const unsigned ints, const unsigned intvg) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP\&. For example, the \fCHIERARCHIC\fP shape functions may have \fImultiple\fP DoFs associated with \fIone\fP node\&. Another example is the \fCMONOMIALs\fP, where only the elements hold the DoFs\&. For the different spatial directions, and orders, see \fC\fBFE\fP\fP\&. 
.RE
.PP

.PP
Definition at line 772 of file dof_object\&.h\&.
.PP
References _idx_buf, n_systems(), n_var_groups(), ncv_magic, and start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), dof_number(), invalidate_dofs(), n_comp(), libMesh::DofMap::reinit(), set_dof_number(), set_n_comp_group(), set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
774 {
775   libmesh_assert_less (s,  this->n_systems());
776   libmesh_assert_less (vg, this->n_var_groups(s));
777 
778   const unsigned int
779     start_idx_sys = this->start_idx(s);
780 
781   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
782 
783   return (_idx_buf[start_idx_sys + 2*vg] % ncv_magic);
784 }
.fi
.SS "unsigned int libMesh::DofObject::n_dofs (const unsigned ints, const unsigned intvar = \fC\fBlibMesh::invalid_uint\fP\fP) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of degrees of freedom associated with system \fCs\fP for this object\&. Optionally only counts degrees of freedom for variable number \fCvar\fP 
.RE
.PP

.PP
Definition at line 589 of file dof_object\&.h\&.
.PP
References libMesh::invalid_uint, n_comp(), n_systems(), and n_vars()\&.
.PP
Referenced by libMesh::EquationSystems::build_solution_vector()\&.
.PP
.nf
591 {
592   libmesh_assert_less (s, this->n_systems());
593 
594   unsigned int num = 0;
595 
596   // Count all variables
597   if (var == libMesh::invalid_uint)
598     for (unsigned int v=0; v<this->n_vars(s); v++)
599       num += this->n_comp(s,v);
600 
601   // Only count specified variable
602   else
603     num = this->n_comp(s,var);
604 
605   return num;
606 }
.fi
.SS "static unsigned int libMesh::ReferenceCounter::n_objects ()\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"
Prints the number of outstanding (created, but not yet destroyed) objects\&. 
.PP
Definition at line 79 of file reference_counter\&.h\&.
.PP
References libMesh::ReferenceCounter::_n_objects\&.
.PP
.nf
80   { return _n_objects; }
.fi
.SS "unsigned int libMesh::DofObject::n_systems () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of systems associated with this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 705 of file dof_object\&.h\&.
.PP
References _idx_buf\&.
.PP
Referenced by libMesh::DofMap::_dof_indices(), add_system(), clear_dofs(), dof_number(), DofObject(), end_idx(), libMesh::Node::get_info(), libMesh::Elem::get_info(), has_dofs(), invalidate_dofs(), libMesh::MeshTools::libmesh_assert_equal_n_systems(), n_comp(), n_comp_group(), n_dofs(), n_var_groups(), n_vars(), libMesh::DofMap::old_dof_indices(), operator=(), libMesh::Elem::refine(), libMesh::EquationSystems::reinit(), set_dof_number(), set_n_comp(), set_n_comp_group(), set_n_systems(), set_n_vars_per_group(), set_vg_dof_base(), start_idx(), and vg_dof_base()\&.
.PP
.nf
706 {
707   return _idx_buf\&.empty() ?
708     0 : libmesh_cast_int<unsigned int>(_idx_buf[0]);
709 }
.fi
.SS "unsigned int libMesh::DofObject::n_var_groups (const unsigned ints) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariableGroup\fP\fP variable groups associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 714 of file dof_object\&.h\&.
.PP
References end_idx(), n_systems(), and start_idx()\&.
.PP
Referenced by add_system(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), DofObject(), invalidate_dofs(), n_comp_group(), n_vars(), operator=(), set_n_comp_group(), set_n_systems(), set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), set_vg_dof_base(), var_to_vg(), and vg_dof_base()\&.
.PP
.nf
715 {
716   libmesh_assert_less (s, this->n_systems());
717 
718   return (this->end_idx(s) - this->start_idx(s)) / 2;
719 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints, const unsigned intvg) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with \fC\fBVariableGroup\fP\fP \fCvg\fP in system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 724 of file dof_object\&.h\&.
.PP
References _idx_buf, n_systems(), n_var_groups(), ncv_magic, and start_idx()\&.
.PP
Referenced by libMesh::DofMap::add_neighbors_to_send_list(), add_system(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::DofMap::distribute_dofs(), dof_number(), DofObject(), libMesh::Node::get_info(), libMesh::Elem::get_info(), has_dofs(), n_comp(), n_dofs(), n_vars(), operator=(), set_dof_number(), set_n_comp(), set_n_comp_group(), set_n_systems(), set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), system_var_to_vg_var(), and var_to_vg()\&.
.PP
.nf
726 {
727   libmesh_assert_less (s,  this->n_systems());
728   libmesh_assert_less (vg, this->n_var_groups(s));
729 
730   const unsigned int start_idx_sys = this->start_idx(s);
731 
732   libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf\&.size());
733 
734   return (libmesh_cast_int<unsigned int>
735           (_idx_buf[start_idx_sys + 2*vg]) / ncv_magic);
736 }
.fi
.SS "unsigned int libMesh::DofObject::n_vars (const unsigned ints) const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the number of \fC\fBVariable\fP\fP variables associated with system \fCs\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 741 of file dof_object\&.h\&.
.PP
References n_systems(), n_var_groups(), and n_vars()\&.
.PP
.nf
742 {
743   libmesh_assert_less (s, this->n_systems());
744 
745   const unsigned int nvg = this->n_var_groups(s);
746 
747   unsigned int val=0;
748 
749   for (unsigned int vg=0; vg<nvg; vg++)
750     val += this->n_vars(s,vg);
751 
752   return val;
753 }
.fi
.SS "\fBDofObject\fP & libMesh::DofObject::operator= (const \fBDofObject\fP &dof_obj)\fC [protected]\fP"
Deep-copying assignment operator 
.PP
Definition at line 82 of file dof_object\&.C\&.
.PP
References _id, _idx_buf, _processor_id, _unique_id, clear_old_dof_object(), dof_number(), DofObject(), n_comp(), n_systems(), n_var_groups(), n_vars(), and old_dof_object\&.
.PP
.nf
83 {
84   if (&dof_obj == this)
85     return *this;
86 
87 #ifdef LIBMESH_ENABLE_AMR
88   this->clear_old_dof_object();
89 
90   this->old_dof_object = new DofObject(*(dof_obj\&.old_dof_object));
91 #endif
92 
93   _id           = dof_obj\&._id;
94 #ifdef LIBMESH_ENABLE_UNIQUE_ID
95   _unique_id    = dof_obj\&._unique_id;
96 #endif
97   _processor_id = dof_obj\&._processor_id;
98   _idx_buf      = dof_obj\&._idx_buf;
99 
100 
101   // Check that everything worked
102 #ifdef DEBUG
103 
104   libmesh_assert_equal_to (this->n_systems(), dof_obj\&.n_systems());
105 
106   for (unsigned int s=0; s<this->n_systems(); s++)
107     {
108       libmesh_assert_equal_to (this->n_vars(s),       dof_obj\&.n_vars(s));
109       libmesh_assert_equal_to (this->n_var_groups(s), dof_obj\&.n_var_groups(s));
110 
111       for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
112         libmesh_assert_equal_to (this->n_vars(s,vg), dof_obj\&.n_vars(s,vg));
113 
114       for (unsigned int v=0; v<this->n_vars(s); v++)
115         {
116           libmesh_assert_equal_to (this->n_comp(s,v), dof_obj\&.n_comp(s,v));
117 
118           for (unsigned int c=0; c<this->n_comp(s,v); c++)
119             libmesh_assert_equal_to (this->dof_number(s,v,c), dof_obj\&.dof_number(s,v,c));
120         }
121     }
122 
123 #endif
124 
125   return *this;
126 }
.fi
.SS "void libMesh::DofObject::pack_indexing (std::back_insert_iterator< std::vector< \fBlargest_id_type\fP > >target) const"
A method for creating packed data from our index buffer - basically a copy with prepended size with our current implementation\&. 
.PP
Definition at line 525 of file dof_object\&.C\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), and libMesh::Elem::PackedElem::pack()\&.
.PP
.nf
526 {
527 #ifdef LIBMESH_ENABLE_AMR
528   // We might need to pack old_dof_object too
529   *target++ = (old_dof_object == NULL) ? 0 : 1;
530 #endif
531 
532   *target++ = _idx_buf\&.size();
533   std::copy(_idx_buf\&.begin(), _idx_buf\&.end(), target);
534 
535 #ifdef LIBMESH_ENABLE_AMR
536   if (old_dof_object)
537     old_dof_object->pack_indexing(target);
538 #endif
539 }
.fi
.SS "unsigned int libMesh::DofObject::packed_indexing_size () const"
If we pack our indices into an buffer for communications, how many ints do we need? 
.PP
Definition at line 448 of file dof_object\&.C\&.
.PP
References _idx_buf, old_dof_object, and packed_indexing_size()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packable_size(), packed_indexing_size(), libMesh::Node::packed_size(), libMesh::Elem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
449 {
450   return
451 #ifdef LIBMESH_ENABLE_AMR
452     ((old_dof_object == NULL) ? 0 : old_dof_object->packed_indexing_size()) + 2 +
453 #else
454     1 +
455 #endif
456     _idx_buf\&.size();
457 }
.fi
.SS "void libMesh::ReferenceCounter::print_info (std::ostream &out = \fC\fBlibMesh::out\fP\fP)\fC [static]\fP, \fC [inherited]\fP"
Prints the reference information, by default to \fC\fBlibMesh::out\fP\fP\&. 
.PP
Definition at line 88 of file reference_counter\&.C\&.
.PP
References libMesh::ReferenceCounter::_enable_print_counter, and libMesh::ReferenceCounter::get_info()\&.
.PP
.nf
89 {
90   if( _enable_print_counter ) out_stream << ReferenceCounter::get_info();
91 }
.fi
.SS "\fBprocessor_id_type\fP libMesh::DofObject::processor_id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to\&.
.RE
.PP
When partitioning and DoF numbering have been performed by \fBlibMesh\fP, every current DoF on this \fBDofObject\fP will belong to its processor\&. 
.PP
Definition at line 673 of file dof_object\&.h\&.
.PP
References _processor_id\&.
.PP
Referenced by libMesh::MetisPartitioner::_do_partition(), libMesh::LinearPartitioner::_do_partition(), libMesh::SFCPartitioner::_do_partition(), libMesh::CentroidPartitioner::_do_partition(), libMesh::ParallelMesh::add_elem(), libMesh::Patch::add_local_face_neighbors(), libMesh::Patch::add_local_point_neighbors(), libMesh::DofMap::add_neighbors_to_send_list(), libMesh::ParallelMesh::add_node(), libMesh::SerialMesh::add_point(), libMesh::ParallelMesh::add_point(), libMesh::UnstructuredMesh::all_first_order(), libMesh::UnstructuredMesh::all_second_order(), libMesh::MeshTools::Modification::all_tri(), libMesh::DofMap::allgather_recursive_constraints(), libMesh::ParmetisPartitioner::assign_partitioning(), libMesh::Patch::build_around_element(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::Nemesis_IO_Helper::compute_border_node_ids(), libMesh::Nemesis_IO_Helper::compute_internal_and_border_elems_and_internal_nodes(), libMesh::Nemesis_IO_Helper::compute_num_global_nodesets(), libMesh::Nemesis_IO_Helper::compute_num_global_sidesets(), libMesh::UnstructuredMesh::copy_nodes_and_elements(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_dofs(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::Elem::Elem(), libMesh::UnstructuredMesh::find_neighbors(), libMesh::MeshTools::Modification::flatten(), libMesh::Node::get_info(), libMesh::Elem::get_info(), libMesh::DofMap::get_info(), libMesh::DofMap::get_local_constraints(), libMesh::MeshFunction::gradient(), libMesh::MeshFunction::hessian(), invalidate_processor_id(), libMesh::Elem::is_semilocal(), libMesh::MeshTools::libmesh_assert_valid_amr_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_elem_ids(), libMesh::MeshTools::libmesh_assert_valid_procids< Elem >(), libMesh::MeshTools::libmesh_assert_valid_procids< Node >(), libMesh::DofMap::local_variable_indices(), libMesh::MeshRefinement::make_coarsening_compatible(), libMesh::MeshFunction::operator()(), libMesh::Parallel::pack(), libMesh::Node::PackedNode::pack(), libMesh::Elem::PackedElem::pack(), libMesh::XdrIO::pack_element(), libMesh::Partitioner::partition_unpartitioned_elements(), libMesh::System::point_gradient(), libMesh::System::point_hessian(), libMesh::System::point_value(), processor_id(), libMesh::Nemesis_IO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::MeshData::read_xdr(), libMesh::Elem::refine(), libMesh::DofMap::scatter_constraints(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), libMesh::CheckpointIO::write_connectivity(), libMesh::GmshIO::write_mesh(), libMesh::CheckpointIO::write_nodes(), libMesh::XdrIO::write_serialized_connectivity(), and libMesh::Nemesis_IO_Helper::write_sidesets()\&.
.PP
.nf
674 {
675   return _processor_id;
676 }
.fi
.SS "\fBprocessor_id_type\fP & libMesh::DofObject::processor_id ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the processor that this \fBDofObject\fP belongs to as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 681 of file dof_object\&.h\&.
.PP
References _processor_id\&.
.PP
.nf
682 {
683   return _processor_id;
684 }
.fi
.SS "void libMesh::DofObject::processor_id (const \fBprocessor_id_type\fPpid)\fC [inline]\fP"
Sets the \fCprocessor_id\fP for this \fC\fBDofObject\fP\fP\&. 
.PP
Definition at line 689 of file dof_object\&.h\&.
.PP
References processor_id()\&.
.PP
.nf
690 {
691   this->processor_id() = pid;
692 }
.fi
.SS "void libMesh::DofObject::set_buffer (const std::vector< \fBdof_id_type\fP > &buf)\fC [inline]\fP"

.PP
Definition at line 491 of file dof_object\&.h\&.
.PP
References _idx_buf\&.
.PP
.nf
492   { _idx_buf = buf; }
.fi
.SS "void libMesh::DofObject::set_dof_number (const unsigned ints, const unsigned intvar, const unsigned intcomp, const \fBdof_id_type\fPdn)"
Sets the global degree of freedom number for variable \fCvar\fP, component \fCcomp\fP for system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 405 of file dof_object\&.C\&.
.PP
References _idx_buf, dof_number(), invalid_id, libMesh::libmesh_assert(), n_comp(), n_comp_group(), n_systems(), n_vars(), start_idx(), system_var_to_vg_var(), and var_to_vg()\&.
.PP
.nf
409 {
410   libmesh_assert_less (s,    this->n_systems());
411   libmesh_assert_less (var,  this->n_vars(s));
412   libmesh_assert_less (comp, this->n_comp(s,var));
413 
414   const unsigned int
415     vg            = this->var_to_vg(s,var),
416 #ifndef NDEBUG
417     ncg           = this->n_comp_group(s,vg),
418 #endif
419     vig           = this->system_var_to_vg_var(s,vg,var),
420     start_idx_sys = this->start_idx(s);
421 
422   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
423 
424   dof_id_type &base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
425 
426   // We intend to change all dof numbers together or not at all
427   if (comp || vig)
428     libmesh_assert ((dn == invalid_id && base_idx == invalid_id) ||
429                     (dn == base_idx + vig*ncg + comp));
430 
431   // only explicitly store the base index for vig==0, comp==0
432   else
433     base_idx = dn;
434 
435   // #ifdef DEBUG
436   //   libMesh::out << " [ ";
437   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
438   //     libMesh::out << _idx_buf[i] << " ";
439   //   libMesh::out << "]\n";
440   // #endif
441 
442   libmesh_assert_equal_to (this->dof_number(s, var, comp), dn);
443 }
.fi
.SS "\fBdof_id_type\fP & libMesh::DofObject::set_id ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the \fCid\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 620 of file dof_object\&.h\&.
.PP
References _id\&.
.PP
Referenced by libMesh::GMVIO::_read_one_cell(), libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::UnstructuredMesh::all_first_order(), libMesh::MeshTools::Subdivision::all_subdivision(), libMesh::MeshTools::Modification::all_tri(), libMesh::MeshCommunication::assign_global_indices(), libMesh::MeshTools::Generation::build_extrusion(), libMesh::InfElemBuilder::build_inf_elem(), libMesh::UNVIO::element_in(), libMesh::MeshTools::Modification::flatten(), invalidate_id(), libMesh::Nemesis_IO::read(), libMesh::ExodusII_IO::read(), libMesh::VTKIO::read(), libMesh::CheckpointIO::read_connectivity(), libMesh::UCDIO::read_implementation(), libMesh::GmshIO::read_mesh(), libMesh::LegacyXdrIO::read_mesh(), libMesh::XdrIO::read_serialized_connectivity(), libMesh::OFFIO::read_stream(), libMesh::MatlabIO::read_stream(), libMesh::RemoteElem::RemoteElem(), libMesh::SerialMesh::renumber_elem(), libMesh::ParallelMesh::renumber_elem(), libMesh::SerialMesh::renumber_node(), libMesh::ParallelMesh::renumber_node(), libMesh::SerialMesh::renumber_nodes_and_elements(), set_id(), libMesh::SerialMesh::stitching_helper(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), and libMesh::Elem::PackedElem::unpack()\&.
.PP
.nf
621 {
622   return _id;
623 }
.fi
.SS "void libMesh::DofObject::set_id (const \fBdof_id_type\fPdofid)\fC [inline]\fP"
Sets the \fCid\fP for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 161 of file dof_object\&.h\&.
.PP
References set_id()\&.
.PP
.nf
162   { this->set_id() = dofid; }
.fi
.SS "void libMesh::DofObject::set_n_comp (const unsigned ints, const unsigned intvar, const unsigned intncomp)"
Sets the number of components for \fC\fBVariable\fP\fP \fCvar\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 338 of file dof_object\&.C\&.
.PP
References n_systems(), n_vars(), set_n_comp_group(), and var_to_vg()\&.
.PP
.nf
341 {
342   libmesh_assert_less (s,   this->n_systems());
343   libmesh_assert_less (var, this->n_vars(s));
344 
345   this->set_n_comp_group(s, this->var_to_vg(s,var), ncomp);
346 }
.fi
.SS "void libMesh::DofObject::set_n_comp_group (const unsigned ints, const unsigned intvg, const unsigned intncomp)"
Sets the number of components for \fC\fBVariableGroup\fP\fP \fCvg\fP of system \fCs\fP associated with this \fC\fBDofObject\fP\fP 
.PP
Definition at line 350 of file dof_object\&.C\&.
.PP
References _idx_buf, libMesh::err, invalid_id, n_comp_group(), n_systems(), n_var_groups(), n_vars(), ncv_magic, and start_idx()\&.
.PP
Referenced by libMesh::DofMap::reinit(), set_n_comp(), set_n_vars_per_group(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
353 {
354   libmesh_assert_less (s,  this->n_systems());
355   libmesh_assert_less (vg, this->n_var_groups(s));
356 
357   // Check for trivial return
358   if (ncomp == this->n_comp_group(s,vg)) return;
359 
360 #ifndef NDEBUG
361   if (ncomp >= ncv_magic)
362     {
363       const index_t ncvm = ncv_magic;
364       libMesh::err << "ERROR: ncomp must be less than DofObject::ncv_magic!\n"
365                    << "ncomp = " << ncomp << ", ncv_magic = " << ncvm
366                    << "\nrecompile and try again!\n";
367       libmesh_error();
368     }
369 #endif
370 
371   const unsigned int
372     start_idx_sys = this->start_idx(s),
373     n_vars_group  = this->n_vars(s,vg),
374     base_offset   = start_idx_sys + 2*vg;
375 
376   libmesh_assert_less ((base_offset + 1), _idx_buf\&.size());
377 
378   // if (ncomp)
379   //   libMesh::out << "s,vg,ncomp="
380   //       << s  << ","
381   //       << vg << ","
382   //       << ncomp << '\n';
383 
384   // set the number of components, maintaining the number
385   // of variables in the group
386   _idx_buf[base_offset] = ncv_magic*n_vars_group + ncomp;
387 
388   // We use (invalid_id - 1) to signify no
389   // components for this object
390   _idx_buf[base_offset + 1] = (ncomp == 0) ? invalid_id - 1 : invalid_id;
391 
392   // this->debug_buffer();
393   // libMesh::out << "s,vg = " << s << "," << vg << '\n'
394   //     << "base_offset=" << base_offset << '\n'
395   //     << "this->n_comp(s,vg)=" << this->n_comp(s,vg) << '\n'
396   //     << "this->n_comp_group(s,vg)=" << this->n_comp_group(s,vg) << '\n'
397   //     << "this->n_vars(s,vg)=" << this->n_vars(s,vg) << '\n'
398   //     << "this->n_var_groups(s)=" << this->n_var_groups(s) << '\n';
399 
400   libmesh_assert_equal_to (ncomp, this->n_comp_group(s,vg));
401 }
.fi
.SS "void libMesh::DofObject::set_n_systems (const unsigned ints)"
Sets the number of systems for this \fC\fBDofObject\fP\fP 
.PP
Definition at line 157 of file dof_object\&.C\&.
.PP
References _idx_buf, clear_dofs(), n_systems(), n_var_groups(), and n_vars()\&.
.PP
Referenced by add_system(), and libMesh::Elem::refine()\&.
.PP
.nf
158 {
159   // Check for trivial return
160   if (ns == this->n_systems())
161     return;
162 
163   // Clear any existing data\&.  This is safe to call
164   // even if we don't have any data\&.
165   this->clear_dofs();
166 
167   // Set the new number of systems
168   _idx_buf\&.resize(ns, ns);
169   _idx_buf[0] = ns;
170 
171 
172 #ifdef DEBUG
173 
174   // check that all systems now exist and that they have 0 size
175   libmesh_assert_equal_to (ns, this->n_systems());
176   for (unsigned int s=0; s<this->n_systems(); s++)
177     {
178       libmesh_assert_equal_to (this->n_vars(s),       0);
179       libmesh_assert_equal_to (this->n_var_groups(s), 0);
180     }
181 
182 #endif
183 }
.fi
.SS "void libMesh::DofObject::set_n_vars_per_group (const unsigned ints, const std::vector< unsigned int > &nvpg)"
Sets number of variables in each group associated with system \fCs\fP for this \fC\fBDofObject\fP\fP\&. Implicit in this is salso setting the number of \fC\fBVariableGroup\fP\fP variable groups for the system\&. Has the effect of setting the number of components to 0 even when called even with (nvg == this->n_var_groups(s))\&. 
.PP
Definition at line 219 of file dof_object\&.C\&.
.PP
References _idx_buf, end, end_idx(), invalid_id, n_comp(), n_comp_group(), n_systems(), n_var_groups(), n_vars(), ncv_magic, set_n_comp_group(), and start_idx()\&.
.PP
.nf
221 {
222 
223   libmesh_assert_less (s, this->n_systems());
224 
225   // number of varaible groups for this system - inferred
226   const unsigned int nvg = libmesh_cast_int<unsigned int>(nvpg\&.size());
227 
228   // BSK - note that for compatibility with the previous implementation
229   // calling this method when (nvars == this->n_vars()) requires that
230   // we invalidate the DOF indices and set the number of components to 0\&.
231   // Note this was a bit of a suprise to me - there was no quick return in
232   // the old method, which caused removal and readdition of the DOF indices
233   // even in the case of (nvars == this->n_vars()), resulting in n_comp(s,v)
234   // implicitly becoming 0 regardless of any previous value\&.
235   // quick return?
236   if (nvg == this->n_var_groups(s))
237     {
238       for (unsigned int vg=0; vg<nvg; vg++)
239         {
240           this->set_n_comp_group(s,vg,0);
241           libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
242         }
243       return;
244     }
245 
246   // since there is ample opportunity to screw up other systems, let us
247   // cache their current sizes and later assert that they are unchanged\&.
248 #ifdef DEBUG
249   DofObject::index_buffer_t old_system_sizes;
250   old_system_sizes\&.reserve(this->n_systems());
251 
252   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
253     old_system_sizes\&.push_back(this->n_var_groups(s_ctr));
254 #endif
255 
256   // remove current indices if we have some
257   if (this->n_var_groups(s) != 0)
258     {
259       const unsigned int old_nvg_s = this->n_var_groups(s);
260 
261       DofObject::index_buffer_t::iterator
262         it  = _idx_buf\&.begin(),
263         end = _idx_buf\&.begin();
264 
265       std::advance(it,  this->start_idx(s));
266       std::advance(end, this->end_idx(s));
267       _idx_buf\&.erase(it,end);
268 
269       for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
270         _idx_buf[ctr] -= 2*old_nvg_s;
271     }
272 
273   // better not have any now!
274   libmesh_assert_equal_to (this->n_var_groups(s), 0);
275 
276   // had better not screwed up any of our sizes!
277 #ifdef DEBUG
278   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
279     if (s_ctr != s)
280       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
281 #endif
282 
283   // OK, if the user requested 0 that is what we have
284   if (nvg == 0)
285     return;
286 
287   {
288     // array to hold new indices
289     DofObject::index_buffer_t var_idxs(2*nvg);
290     for (unsigned int vg=0; vg<nvg; vg++)
291       {
292         var_idxs[2*vg    ] = ncv_magic*nvpg[vg] + 0;
293         var_idxs[2*vg + 1] = invalid_id - 1;
294       }
295 
296     DofObject::index_buffer_t::iterator it = _idx_buf\&.begin();
297     std::advance(it, this->end_idx(s));
298     _idx_buf\&.insert(it, var_idxs\&.begin(), var_idxs\&.end());
299 
300     for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
301       _idx_buf[ctr] += 2*nvg;
302 
303     // resize _idx_buf to fit so no memory is wasted\&.
304     DofObject::index_buffer_t(_idx_buf)\&.swap(_idx_buf);
305   }
306 
307   // that better had worked\&.  Assert stuff\&.
308   libmesh_assert_equal_to (nvg, this->n_var_groups(s));
309 
310 #ifdef DEBUG
311 
312   // libMesh::out << " [ ";
313   // for (unsigned int i=0; i<_idx_buf\&.size(); i++)
314   //   libMesh::out << _idx_buf[i] << " ";
315   // libMesh::out << "]\n";
316 
317   libmesh_assert_equal_to (this->n_var_groups(s), nvpg\&.size());
318 
319   for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
320     {
321       libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
322       libmesh_assert_equal_to (this->n_comp_group(s,vg), 0);
323     }
324 
325   for (unsigned int v=0; v<this->n_vars(s); v++)
326     libmesh_assert_equal_to (this->n_comp(s,v), 0);
327 
328   // again, all other system sizes shoudl be unchanged!
329   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
330     if (s_ctr != s)
331       libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
332 
333 #endif
334 }
.fi
.SS "void libMesh::DofObject::set_old_dof_object ()"
Sets the \fCold_dof_object\fP to a copy of \fCthis\fP 
.PP
Definition at line 142 of file dof_object\&.C\&.
.PP
References clear_old_dof_object(), DofObject(), libMesh::libmesh_assert(), and old_dof_object\&.
.PP
Referenced by libMesh::DofMap::reinit()\&.
.PP
.nf
143 {
144   this->clear_old_dof_object();
145 
146   libmesh_assert (!this->old_dof_object);
147 
148   // Make a new DofObject, assign a copy of \p this\&.
149   // Make sure the copy ctor for DofObject works!!
150   this->old_dof_object = new DofObject(*this);
151 }
.fi
.SS "\fBunique_id_type\fP & libMesh::DofObject::set_unique_id ()\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP as a writeable reference\&. 
.RE
.PP

.PP
Definition at line 641 of file dof_object\&.h\&.
.PP
References _unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::CheckpointIO::read_connectivity(), libMesh::CheckpointIO::read_nodes(), libMesh::XdrIO::read_serialized_connectivity(), and libMesh::Parallel::unpack()\&.
.PP
.nf
642 {
643 #ifdef LIBMESH_ENABLE_UNIQUE_ID
644   return _unique_id;
645 #else
646   libmesh_error();
647 #endif
648 }
.fi
.SS "void libMesh::DofObject::set_vg_dof_base (const unsigned ints, const unsigned intvg, const \fBdof_id_type\fPdb)\fC [inline]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 881 of file dof_object\&.h\&.
.PP
References _idx_buf, n_systems(), n_var_groups(), start_idx(), and vg_dof_base()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), invalidate_dofs(), libMesh::DofMap::reinit(), and libMesh::DofMap::set_nonlocal_dof_objects()\&.
.PP
.nf
884 {
885   libmesh_assert_less (s,  this->n_systems());
886   libmesh_assert_less (vg, this->n_var_groups(s));
887 
888   const unsigned int
889     start_idx_sys = this->start_idx(s);
890 
891   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
892 
893   _idx_buf[start_idx_sys + 2*vg + 1] = db;
894 
895   libmesh_assert_equal_to (this->vg_dof_base(s,vg), db);
896 }
.fi
.SS "unsigned int libMesh::DofObject::start_idx (const unsigned ints) const\fC [inline]\fP, \fC [private]\fP"
The starting index for system \fCs\fP\&. 
.PP
Definition at line 857 of file dof_object\&.h\&.
.PP
References _idx_buf, and n_systems()\&.
.PP
Referenced by dof_number(), n_comp_group(), n_var_groups(), n_vars(), set_dof_number(), set_n_comp_group(), set_n_vars_per_group(), set_vg_dof_base(), and vg_dof_base()\&.
.PP
.nf
858 {
859   libmesh_assert_less (s, this->n_systems());
860   libmesh_assert_less (s, _idx_buf\&.size());
861 
862   return libmesh_cast_int<unsigned int>(_idx_buf[s]);
863 }
.fi
.SS "unsigned int libMesh::DofObject::system_var_to_vg_var (const unsigned ints, const unsigned intvg, const unsigned intvar) const\fC [inline]\fP, \fC [private]\fP"
\fBUtility\fP function - for variable \fCvar\fP in system \fCs\fP, figure out what variable group it lives in\&. 
.PP
Definition at line 945 of file dof_object\&.h\&.
.PP
References n_vars()\&.
.PP
Referenced by dof_number(), and set_dof_number()\&.
.PP
.nf
948 {
949   unsigned int accumulated_sum=0;
950 
951   for (unsigned int vgc=0; vgc<vg; vgc++)
952     accumulated_sum += this->n_vars(s,vgc);
953 
954   libmesh_assert_less_equal (accumulated_sum, var);
955 
956   return (var - accumulated_sum);
957 }
.fi
.SS "\fBunique_id_type\fP libMesh::DofObject::unique_id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
the globally \fCunique_id\fP for this \fC\fBDofObject\fP\fP 
.RE
.PP

.PP
Definition at line 628 of file dof_object\&.h\&.
.PP
References _unique_id, invalid_unique_id, libMesh::libmesh_assert(), and valid_unique_id()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::XdrIO::pack_element(), libMesh::CheckpointIO::write_connectivity(), and libMesh::CheckpointIO::write_nodes()\&.
.PP
.nf
629 {
630 #ifdef LIBMESH_ENABLE_UNIQUE_ID
631   libmesh_assert (this->valid_unique_id());
632   return _unique_id;
633 #else
634   return invalid_unique_id;
635 #endif
636 }
.fi
.SS "void libMesh::DofObject::unpack_indexing (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)"
A method for creating our index buffer from packed data - basically with our current implementation we investigate the size term and then copy\&. 
.PP
Definition at line 485 of file dof_object\&.C\&.
.PP
References _idx_buf, clear_old_dof_object(), DofObject(), libMesh::libmesh_assert(), old_dof_object, and unpack_indexing()\&.
.PP
Referenced by libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), and unpack_indexing()\&.
.PP
.nf
486 {
487   _idx_buf\&.clear();
488 
489 #ifdef LIBMESH_ENABLE_AMR
490   this->clear_old_dof_object();
491   const int has_old_dof_object = *begin++;
492   libmesh_assert(has_old_dof_object == 1 ||
493                  has_old_dof_object == 0);
494 #endif
495 
496   const int size = *begin++;
497   _idx_buf\&.reserve(size);
498   std::copy(begin, begin+size, back_inserter(_idx_buf));
499 
500   // Check as best we can for internal consistency now
501   libmesh_assert(_idx_buf\&.empty() ||
502                  (_idx_buf[0] <= _idx_buf\&.size()));
503 #ifdef DEBUG
504   if (!_idx_buf\&.empty())
505     for (unsigned int i=1; i < _idx_buf[0]; ++i)
506       {
507         libmesh_assert_greater_equal (_idx_buf[i], _idx_buf[i-1]);
508         libmesh_assert_equal_to ((_idx_buf[i] - _idx_buf[i-1])%2, 0);
509         libmesh_assert_less_equal (_idx_buf[i], _idx_buf\&.size());
510       }
511 #endif
512 
513 #ifdef LIBMESH_ENABLE_AMR
514   if (has_old_dof_object)
515     {
516       this->old_dof_object = new DofObject();
517       this->old_dof_object->unpack_indexing(begin+size);
518     }
519 #endif
520 }
.fi
.SS "unsigned int libMesh::DofObject::unpackable_indexing_size (std::vector< \fBlargest_id_type\fP >::const_iteratorbegin)\fC [static]\fP"
If we have indices packed into an buffer for communications, how much of that buffer applies to this dof object? 
.PP
Definition at line 463 of file dof_object\&.C\&.
.PP
References libMesh::libmesh_assert()\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::Parallel::packed_size(), libMesh::Elem::PackedElem::packed_size(), and libMesh::Parallel::unpack()\&.
.PP
.nf
464 {
465 #ifdef LIBMESH_ENABLE_AMR
466   const int has_old_dof_object = *begin++;
467 
468   // Either we have an old_dof_object or we don't
469   libmesh_assert(has_old_dof_object == 1 || has_old_dof_object == 0);
470   static const int dof_header_size = 2;
471 #else
472   static const bool has_old_dof_object = false;
473   static const int dof_header_size = 1;
474 #endif
475 
476   const int this_indexing_size = *begin++;
477 
478   return dof_header_size + this_indexing_size +
479     (has_old_dof_object ?
480      unpackable_indexing_size(begin+this_indexing_size) : 0);
481 }
.fi
.SS "bool libMesh::DofObject::valid_id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 653 of file dof_object\&.h\&.
.PP
References _id, and invalid_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::Node::get_info(), libMesh::Elem::get_info(), id(), and libMesh::Elem::libmesh_assert_valid_node_pointers()\&.
.PP
.nf
654 {
655   return (DofObject::invalid_id != _id);
656 }
.fi
.SS "bool libMesh::DofObject::valid_processor_id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCid\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 697 of file dof_object\&.h\&.
.PP
References _processor_id, and invalid_processor_id\&.
.PP
.nf
698 {
699   return (DofObject::invalid_processor_id != _processor_id);
700 }
.fi
.SS "bool libMesh::DofObject::valid_unique_id () const\fC [inline]\fP"

.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if this \fC\fBDofObject\fP\fP has a valid \fCunique_id\fP set, \fCfalse\fP otherwise\&. 
.RE
.PP

.PP
Definition at line 661 of file dof_object\&.h\&.
.PP
References _unique_id, and invalid_unique_id\&.
.PP
Referenced by libMesh::SerialMesh::add_elem(), libMesh::ParallelMesh::add_elem(), libMesh::SerialMesh::add_node(), libMesh::ParallelMesh::add_node(), libMesh::Parallel::pack(), and unique_id()\&.
.PP
.nf
662 {
663 #ifdef LIBMESH_ENABLE_UNIQUE_ID
664   return (DofObject::invalid_unique_id != _unique_id);
665 #else
666   return false;
667 #endif
668 }
.fi
.SS "unsigned int libMesh::DofObject::var_to_vg (const unsigned ints, const unsigned intvar) const\fC [inline]\fP, \fC [private]\fP"
\fBUtility\fP function - for variable \fCvar\fP in system \fCs\fP, figure out what variable group it lives in\&. 
.PP
Definition at line 925 of file dof_object\&.h\&.
.PP
References n_var_groups(), and n_vars()\&.
.PP
Referenced by dof_number(), n_comp(), set_dof_number(), and set_n_comp()\&.
.PP
.nf
927 {
928   const unsigned int
929     nvg = this->n_var_groups(s);
930 
931   for (unsigned int vg=0, vg_end=0; vg<nvg; vg++)
932     {
933       vg_end += this->n_vars(s,vg);
934       if (var < vg_end) return vg;
935     }
936 
937   // we should never get here
938   libmesh_error();
939   return 0;
940 }
.fi
.SS "\fBdof_id_type\fP libMesh::DofObject::vg_dof_base (const unsigned ints, const unsigned intvg) const\fC [inline]\fP"
\fC\fBVariableGroup\fP\fP DoF indices are indexed as id = base + var_in_vg*ncomp + comp This method allows for direct access to the base\&. 
.PP
Definition at line 901 of file dof_object\&.h\&.
.PP
References _idx_buf, n_systems(), n_var_groups(), and start_idx()\&.
.PP
Referenced by libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), libMesh::DofMap::reinit(), libMesh::DofMap::set_nonlocal_dof_objects(), and set_vg_dof_base()\&.
.PP
.nf
903 {
904   libmesh_assert_less (s,  this->n_systems());
905   libmesh_assert_less (vg, this->n_var_groups(s));
906 
907   const unsigned int
908     start_idx_sys = this->start_idx(s);
909 
910   libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf\&.size());
911 
912   // #ifdef DEBUG
913   //   std::cout << " [ ";
914   //   for (unsigned int i=0; i<_idx_buf\&.size(); i++)
915   //     std::cout << _idx_buf[i] << " ";
916   //   std::cout << "]\n";
917   // #endif
918 
919   return _idx_buf[start_idx_sys + 2*vg + 1];
920 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBReferenceCounter::Counts\fP libMesh::ReferenceCounter::_counts\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Actually holds the data\&. 
.PP
Definition at line 118 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::get_info(), libMesh::ReferenceCounter::increment_constructor_count(), and libMesh::ReferenceCounter::increment_destructor_count()\&.
.SS "bool libMesh::ReferenceCounter::_enable_print_counter = true\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Flag to control whether reference count information is printed when print_info is called\&. 
.PP
Definition at line 137 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::disable_print_counter_info(), libMesh::ReferenceCounter::enable_print_counter_info(), and libMesh::ReferenceCounter::print_info()\&.
.SS "\fBdof_id_type\fP libMesh::DofObject::_id\fC [private]\fP"
The \fCid\fP of the \fC\fBDofObject\fP\fP 
.PP
Definition at line 400 of file dof_object\&.h\&.
.PP
Referenced by id(), operator=(), set_id(), and valid_id()\&.
.SS "\fBindex_buffer_t\fP libMesh::DofObject::_idx_buf\fC [private]\fP"

.PP
Definition at line 465 of file dof_object\&.h\&.
.PP
Referenced by add_system(), clear_dofs(), debug_buffer(), dof_number(), end_idx(), n_comp_group(), n_systems(), n_vars(), operator=(), packed_indexing_size(), set_buffer(), set_dof_number(), set_n_comp_group(), set_n_systems(), set_n_vars_per_group(), set_vg_dof_base(), start_idx(), unpack_indexing(), and vg_dof_base()\&.
.SS "\fBThreads::spin_mutex\fP libMesh::ReferenceCounter::_mutex\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Mutual exclusion object to enable thread-safe reference counting\&. 
.PP
Definition at line 131 of file reference_counter\&.h\&.
.SS "\fBThreads::atomic\fP< unsigned int > libMesh::ReferenceCounter::_n_objects\fC [static]\fP, \fC [protected]\fP, \fC [inherited]\fP"
The number of objects\&. Print the reference count information when the number returns to 0\&. 
.PP
Definition at line 126 of file reference_counter\&.h\&.
.PP
Referenced by libMesh::ReferenceCounter::n_objects(), libMesh::ReferenceCounter::ReferenceCounter(), and libMesh::ReferenceCounter::~ReferenceCounter()\&.
.SS "\fBprocessor_id_type\fP libMesh::DofObject::_processor_id\fC [private]\fP"
The \fCprocessor_id\fP of the \fC\fBDofObject\fP\fP\&. Degrees of freedom are wholly owned by processors, however they may be duplicated on other processors\&.
.PP
This is stored as an unsigned short int since we cannot expect to be solving on 65000+ processors any time soon, can we?? 
.PP
Definition at line 419 of file dof_object\&.h\&.
.PP
Referenced by operator=(), processor_id(), and valid_processor_id()\&.
.SS "\fBunique_id_type\fP libMesh::DofObject::_unique_id\fC [private]\fP"
A globally unique id, guarenteed not to change as the mesh is repartioned or adapted 
.PP
Definition at line 407 of file dof_object\&.h\&.
.PP
Referenced by operator=(), set_unique_id(), unique_id(), and valid_unique_id()\&.
.SS "const \fBdof_id_type\fP libMesh::DofObject::invalid_id = static_cast<\fBdof_id_type\fP>(-1)\fC [static]\fP"
An invaild \fCid\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 335 of file dof_object\&.h\&.
.PP
Referenced by libMesh::SFCPartitioner::_do_partition(), libMesh::DofMap::_dof_indices(), libMesh::Node::active(), libMesh::SerialMesh::add_point(), libMesh::MeshRefinement::add_point(), libMesh::UnstructuredMesh::all_second_order(), libMesh::FEGenericBase< T >::compute_periodic_constraints(), libMesh::FEGenericBase< T >::compute_proj_constraints(), libMesh::UnstructuredMesh::create_submesh(), libMesh::DofMap::distribute_local_dofs_node_major(), libMesh::DofMap::distribute_local_dofs_var_major(), dof_number(), libMesh::SerialMesh::insert_node(), invalidate_dofs(), invalidate_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::Elem::node(), libMesh::DofMap::old_dof_indices(), libMesh::XdrIO::pack_element(), libMesh::Elem::point(), libMesh::System::read_legacy_data(), libMesh::System::read_parallel_data(), libMesh::XdrIO::read_serialized_connectivity(), set_dof_number(), set_n_comp_group(), set_n_vars_per_group(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Parallel::unpack(), libMesh::Elem::PackedElem::unpack(), valid_id(), and libMesh::System::write_parallel_data()\&.
.SS "const \fBprocessor_id_type\fP libMesh::DofObject::invalid_processor_id = static_cast<\fBprocessor_id_type\fP>(-1)\fC [static]\fP"
An invalid \fCprocessor_id\fP to distinguish DoFs that have not been assigned to a processor\&. 
.PP
Definition at line 346 of file dof_object\&.h\&.
.PP
Referenced by libMesh::ParallelMesh::add_elem(), libMesh::ParallelMesh::add_node(), libMesh::MeshCommunication::allgather(), libMesh::MeshTools::bounding_box(), libMesh::MeshTools::correct_node_proc_ids(), libMesh::Elem::Elem(), libMesh::MeshCommunication::find_global_indices(), invalidate_processor_id(), libMesh::ParallelMesh::libmesh_assert_valid_parallel_object_ids(), libMesh::ParallelMesh::n_active_elem(), libMesh::MeshBase::n_elem_on_proc(), libMesh::MeshBase::n_nodes_on_proc(), libMesh::MeshBase::n_unpartitioned_elem(), libMesh::MeshBase::n_unpartitioned_nodes(), libMesh::Elem::PackedElem::processor_id(), libMesh::CheckpointIO::read_connectivity(), libMesh::ParallelMesh::renumber_dof_objects(), libMesh::Partitioner::set_node_processor_ids(), libMesh::DofMap::set_nonlocal_dof_objects(), libMesh::Partitioner::set_parent_processor_ids(), libMesh::BoundaryInfo::sync(), libMesh::Parallel::sync_dofobject_data_by_id(), libMesh::Parallel::sync_dofobject_data_by_xyz(), libMesh::Parallel::sync_element_data_by_parent_id(), libMesh::MeshTools::total_weight(), libMesh::Node::PackedNode::unpack(), libMesh::Parallel::unpack(), libMesh::SerialMesh::unpartitioned_elements_begin(), libMesh::ParallelMesh::unpartitioned_elements_begin(), libMesh::SerialMesh::unpartitioned_elements_end(), libMesh::ParallelMesh::unpartitioned_elements_end(), valid_processor_id(), and libMesh::CheckpointIO::write_connectivity()\&.
.SS "const \fBunique_id_type\fP libMesh::DofObject::invalid_unique_id = static_cast<\fBunique_id_type\fP>(-1)\fC [static]\fP"
An invaild \fCunique_id\fP to distinguish an uninitialized \fC\fBDofObject\fP\fP 
.PP
Definition at line 340 of file dof_object\&.h\&.
.PP
Referenced by libMesh::Parallel::pack(), libMesh::ParallelMesh::renumber_dof_objects(), unique_id(), and valid_unique_id()\&.
.SS "const \fBindex_t\fP libMesh::DofObject::ncv_magic = 256\fC [static]\fP, \fC [private]\fP"
Above we introduced the chimera ncv, which is a hybrid of the form ncv = ncv_magic*nv + nc where nv are the number of identical variables of a given type, and nc is the number of components for this set of variables\&.
.PP
It is hoped that by setting this to a power of two, an optimizing compiler will recgnize later that #/ncv_magic is simply a bitshift 
.PP
Definition at line 476 of file dof_object\&.h\&.
.PP
Referenced by n_comp_group(), n_vars(), set_n_comp_group(), and set_n_vars_per_group()\&.
.SS "\fBDofObject\fP* libMesh::DofObject::old_dof_object"
This object on the last mesh\&. Useful for projecting solutions from one mesh to another\&. 
.PP
Definition at line 89 of file dof_object\&.h\&.
.PP
Referenced by clear_old_dof_object(), libMesh::MeshTools::libmesh_assert_old_dof_objects(), libMesh::DofMap::old_dof_indices(), operator=(), packed_indexing_size(), libMesh::DofMap::reinit(), set_old_dof_object(), and unpack_indexing()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for libMesh from the source code\&.
