#include <queso/Environment.h>
#include <queso/EnvironmentOptions.h>
#include <queso/VectorSpace.h>
#include <queso/GaussianVectorRealizer.h>
#include <queso/GslMatrix.h>
#include <queso/GslNumericVector.h>
#include <queso/GslSparseMatrix.h>

#define QUESO_REQUIRE_CLOSE(a, b, c) do { if (!require_close(a, b, c)) { \
                                            std::cerr << "FAILED: " << a \
                                                      << " and " << b \
                                                      << " differ by " << c \
                                                      << " in the relative " \
                                                      << "sense." \
                                                      << std::endl; \
                                            queso_error(); \
                                          } \
                                        } while (0)

#define QUESO_REQUIRE(a) do { if (!(a)) { \
                                std::cerr << "FAILED: " << (a) \
                                          << " is false." \
                                          << std::endl; \
                                queso_error(); \
                              } \
                            } while (0)

using namespace QUESO;

int require_close(double a, double b, double tol) {
  return (std::abs(a - b) / std::abs(b) > tol) ? 0 : 1;
}

int main(int argc, char ** argv) {
#ifdef QUESO_HAS_MPI
  MPI_Init(&argc, &argv);
#endif

  EnvOptionsValues envOptionsValues;

  // Force gsl to prevent regression failures with other rngs
  envOptionsValues.m_rngType = "gsl";
#ifdef QUESO_HAS_MPI
  FullEnvironment env(MPI_COMM_WORLD, "", "", &envOptionsValues);
#else
  FullEnvironment env("", "", &envOptionsValues);
#endif

  VectorSpace<GslNumericVector<libMesh::Number>, GslSparseMatrix<libMesh::Number>> imageSpace(env, "test_space", 2, NULL);
  Map eMap(2, 0, env.fullComm());

  GslNumericVector<libMesh::Number> imageMinVal(env, eMap, -INFINITY);
  GslNumericVector<libMesh::Number> imageMaxVal(env, eMap,  INFINITY);

  BoxSubset<GslNumericVector<libMesh::Number>, GslSparseMatrix<libMesh::Number>> domain("domain", imageSpace, imageMinVal,
      imageMaxVal);

  double tol = 1e-16;

  // Tests
  // Test 1: mean = 0, covMatrix = identity
  GslNumericVector<libMesh::Number> expectedValues(env, eMap, 0.0);
  GslSparseMatrix<libMesh::Number> lowerCholCovMatrix(env, eMap, 1.0); // identity

  int ierr = lowerCholCovMatrix.chol();
  QUESO_REQUIRE( ierr==0 ); // make sure cholesky succeeded

  lowerCholCovMatrix.zeroUpper(false); // zero upper triangular

  GaussianVectorRealizer<GslNumericVector<libMesh::Number>, GslSparseMatrix<libMesh::Number>>* gaussianRealizer =
    new GaussianVectorRealizer<GslNumericVector<libMesh::Number>, GslSparseMatrix<libMesh::Number>>("test_realizer",
        domain, expectedValues, lowerCholCovMatrix);

  GslNumericVector<libMesh::Number> myRealization(expectedValues);

  gaussianRealizer->realization(myRealization);

  // NOTE: Data generated by running rng (i.e. this is a regression test).
  // If default seed value or rng algorithm are changed, these asserts will fail.
  QUESO_REQUIRE_CLOSE(myRealization[0],  2.2285703126720258e-01, tol);
  QUESO_REQUIRE_CLOSE(myRealization[1], -8.5156524864967331e-01, tol);

  delete gaussianRealizer;

  // Test 2: mean = [-2; 1], covMatrix = [2, 1; 1, 2]
  expectedValues[0] = -2.0; expectedValues[1] = 1.0;

  lowerCholCovMatrix(0,0) = 2.0; lowerCholCovMatrix(0,1) = 1.0;
  lowerCholCovMatrix(1,0) = 1.0; lowerCholCovMatrix(1,1) = 2.0;

  ierr = lowerCholCovMatrix.chol();
  QUESO_REQUIRE( ierr==0 ); // make sure cholesky succeeded

  lowerCholCovMatrix.zeroUpper(false); // zero upper triangular

  gaussianRealizer = new GaussianVectorRealizer<GslNumericVector<libMesh::Number>, GslSparseMatrix<libMesh::Number>>(
      "test_realizer", domain, expectedValues, lowerCholCovMatrix);

  // Generate realization
  gaussianRealizer->realization(myRealization);

  QUESO_REQUIRE_CLOSE(myRealization[0], -1.315078621127142e+00, tol);
  QUESO_REQUIRE_CLOSE(myRealization[1],  9.780380444774379e-01, tol);

  delete gaussianRealizer;

  // Clean up
#ifdef QUESO_HAS_MPI
  MPI_Finalize();
#endif

  return 0;
}
